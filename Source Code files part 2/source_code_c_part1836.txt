lished.h ===
/***************************************************************************\
*
* File: Published.h
*
* Description:
* Available headers for other internal projects
*
* Published.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUI project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.
*
* Definitions that are not exposed through this file are considered project
* specific implementation details and should not used in other projects.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__Published_h__INCLUDED)
#define DUIBASE__Published_h__INCLUDED
#pragma once


#include "Debug.h"
#include "Alloc.h"
#include "SBAlloc.h"
#include "Btreelookup.h"
#include "Dynamicarray.h"
#include "Valuemap.h"


#endif // DUIBASE__Published_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\debug.h ===
/***************************************************************************\
*
* File: Debug.h
*
* Description:
* Debug.h defines routinues common to most projects, including
* - Macros
* - Disabling known compiler warnings
* - Debugging / ASSERT
*
* Debug.h makes use of DirectUser's AutoUtil library
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(DUIBASE__Debug_h__INCLUDED)
#define DUIBASE__Debug_h__INCLUDED


#include <crtdbg.h>
#include <basetyps.h>


/***************************************************************************\
*
* Macros
*
\***************************************************************************/

#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)
#define _countof(x) (sizeof(x) / sizeof(x[0]))

#define UNREFERENCED_MSG_PARAMETERS(uMsg, wParam, lParam, bHandled)\
    UNREFERENCED_PARAMETER(uMsg); \
    UNREFERENCED_PARAMETER(wParam); \
    UNREFERENCED_PARAMETER(lParam); \
    UNREFERENCED_PARAMETER(bHandled)



/***************************************************************************\
*
* Debugging: ASSERT, TRACE, VERIFY
*
\***************************************************************************/

#undef INTERFACE
#define INTERFACE IDebug
DECLARE_INTERFACE(IDebug)
{
    STDMETHOD_(BOOL, AssertFailedLine)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum) PURE;
    STDMETHOD_(BOOL, IsValidAddress)(THIS_ const void * lp, UINT nBytes, BOOL bReadWrite) PURE;
    STDMETHOD_(void, BuildStack)(THIS_ HGLOBAL * phStackData, UINT * pcCSEntries) PURE;
    STDMETHOD_(BOOL, Prompt)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle) PURE;
};

EXTERN_C  IDebug * WINAPI GetDebug();
EXTERN_C  void _cdecl AutoTrace(const char * pszFormat, ...);

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->lpVtbl->AssertFailedLine(p, a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->lpVtbl->IsValidAddress(p, a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->lpVtbl->BuildStack(p, a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->lpVtbl->Prompt(p, a, b, c, d)
#else
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->AssertFailedLine(a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->IsValidAddress(a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->BuildStack(a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->Prompt(a, b, c, d)
#endif

// Define AutoDebugBreak

#ifndef AutoDebugBreak
#define AutoDebugBreak() _CrtDbgBreak()
#endif

// Undefine previous definitions

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef ASSERT_
#undef ASSERT_
#endif

#ifdef VERIFY
#undef VERIFY
#endif

#ifdef VERIFY_
#undef VERIFY_
#endif

#ifdef ASSERTHR
#undef ASSERTHR
#endif

#ifdef ASSERTHR_
#undef ASSERTHR_
#endif

#ifdef VERIFYHR
#undef VERIFYHR
#endif

#ifdef VERIFYHR_
#undef VERIFYHR_
#endif

#ifdef TRACE
#undef TRACE
#endif


// Define ASSERT, VERIFY, etc.

#if DBG

// AutoDebug functions that are only available in DEBUG builds

#define ASSERT(f) \
    do \
    { \
    if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define ASSERT_(f, comment) \
    do \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define ASSERTHR(f) \
    do \
    { \
    if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define ASSERTHR_(f, comment) \
    do \
    { \
        if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define VERIFY(f)               ASSERT((f))
#define VERIFY_(f, comment)     ASSERT_((f), comment)
#define VERIFYHR(f)             ASSERTHR((f))
#define VERIFYHR_(f, comment)   ASSERTHR_((f), comment)
#define DEBUG_ONLY(f)       (f)

#define TRACE                   AutoTrace("Dui: "); AutoTrace

#define PROMPT(comment, prompt) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), comment, __FILE__, __LINE__, prompt)) \
            AutoDebugBreak(); \
    } while (0) \

#define ASSERT_READ_PTR(p) \
    ASSERT_(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), FALSE), "Check pointer memory is valid"); \
    ASSERT_(p != NULL, "Check pointer is not NULL")

#define ASSERT_READ_PTR_(p, s) \
    ASSERT_(IDebug_IsValidAddress(GetDebug(), p, s, FALSE), "Check pointer memory is valid"); \
    ASSERT_(p != NULL, "Check pointer is not NULL")

#define ASSERT_WRITE_PTR(p) \
    ASSERT_(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), TRUE), "Check pointer memory is valid"); \
    ASSERT_(p != NULL, "Check pointer is not NULL")

#define ASSERT_WRITE_PTR_(p, s) \
    ASSERT_(IDebug_IsValidAddress(GetDebug(), p, s, TRUE), "Check pointer memory is valid"); \
    ASSERT_(p != NULL, "Check pointer is not NULL")

#define ASSERT_INDEX(idx, nMax) \
    ASSERT_((idx < nMax) && (idx >= 0), "Check pointer is not NULL")

#define ASSERT_HWND(hwnd) \
    ASSERT_(IsWindow(hwnd), "Check valid window")

#define ASSERT_HANDLE(h) \
    ASSERT_(h != NULL, "Check valid handle")

#define ASSERT_INSTANCE(p) \
    do \
    { \
        ASSERT_WRITE_PTR(p); \
        p->AssertValid(); \
    } while (0)

#define ASSERT_STRING(s) \
    do \
    { \
        ASSERT(s != NULL); \
    } while (0)

#else // DBG

#define ASSERT(f)               ((void) 0)
#define ASSERT_(f, comment)     ((void) 0)
#define VERIFY(f)               ((void)(f))
#define VERIFY_(f, comment)     ((void)(f, comment))
#define ASSERTHR(f)             ((void) 0)
#define ASSERTHR_(f, comment)   ((void) 0)
#define VERIFYHR(f)             ((void)(f))
#define VERIFYHR_(f, comment)   ((void)(f, comment))
#define DEBUG_ONLY(f)       ((void) 0)

#define TRACE               1 ? (void) 0 : AutoTrace

#define PROMPT(comment, prompt) ((void) 0)

#define ASSERT_READ_PTR(p)      ((void) 0)
#define ASSERT_READ_PTR_(p, s)  ((void) 0)
#define ASSERT_WRITE_PTR(p)     ((void) 0)
#define ASSERT_WRITE_PTR_(p)    ((void) 0)
#define ASSERT_INDEX(idx, nMax) ((void) 0)
#define ASSERT_HWND(hwnd)       ((void) 0)
#define ASSERT_HANDLE(h)        ((void) 0)
#define ASSERT_INSTANCE(p)      ((void) 0)
#define ASSERT_STRING(s)        ((void) 0)

#endif // DBG

#define CHECK_VALID_READ_PTR(p) \
    do \
    { \
        ASSERT_VALID_READ_PTR(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)

#define CHECK_VALID_WRITE_PTR(p) \
    do \
    { \
        ASSERT_VALID_WRITE_PTR(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)


/***************************************************************************\
*
* Debugging: Parameter validation
*
\***************************************************************************/

#if DBG

//
// AutoDebug functions that are only available in DEBUG builds
//

inline BOOL ISBADCODE(const void * pv)
{
    return IsBadCodePtr((FARPROC) pv);
}

template <class T>
inline BOOL ISBADREAD(const void * pv, T cb)
{
    return IsBadReadPtr(pv, (UINT_PTR) cb);
}

template <class T>
inline BOOL ISBADWRITE(void * pv, T cb)
{
    return IsBadWritePtr(pv, (UINT_PTR) cb);
}

inline BOOL ISBADSTRING(LPCTSTR pv, int cb)
{
    return IsBadStringPtr(pv, (UINT_PTR) cb);
}

inline BOOL ISBADSTRINGA(LPCSTR pv, int cb)
{
    return IsBadStringPtrA(pv, (UINT_PTR) cb);
}

inline BOOL ISBADSTRINGW(LPCWSTR pv, int cb)
{
    return IsBadStringPtrW(pv, (UINT_PTR) cb);
}

#else // DBG

inline BOOL ISBADCODE(const void * pv)
{
    UNREFERENCED_PARAMETER(pv);
    return false;
}

template <class T>
inline BOOL ISBADREAD(const void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

template <class T>
inline BOOL ISBADWRITE(void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL ISBADSTRING(LPCTSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL ISBADSTRINGA(LPCSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL ISBADSTRINGW(LPCWSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

#endif // DBG


//
// Individual parameter validation rountines
//


#define VALIDATE_FLAGS(f, m)                                \
    if ((f & m) != f) {                                     \
        PROMPT_INVALID("Specified flags are invalid");      \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }

#define VALIDATE_RANGE(i, a, b)                             \
    if (((i) < (a)) || ((i) > (b))) {                       \
        PROMPT_INVALID("Value is outside expected range");  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_CODE_PTR(p)                                \
    if ((p == NULL) || ISBADCODE(p)) {                      \
        PROMPT_INVALID("Bad code pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_CODE_PTR_OR_NULL(p)                        \
    if ((p != NULL) && ISBADCODE((FARPROC) p)) {            \
        PROMPT_INVALID("Bad code pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_READ_PTR(p)                                \
    if ((p == NULL) || ISBADREAD(p, sizeof(BYTE))) {        \
        PROMPT_INVALID("Bad read pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_READ_PTR_(p, b)                            \
    if ((p == NULL) || ISBADREAD(p, b)) {                   \
        PROMPT_INVALID("Bad read pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL(p)                        \
    if ((p != NULL) && ISBADREAD(p, sizeof(BYTE))) {        \
        PROMPT_INVALID("Bad read pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL_(p, b)                    \
    if ((p != NULL) && ISBADREAD(p, b)) {                   \
        PROMPT_INVALID("Bad read pointer: " STRINGIZE(p));  \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_WRITE_PTR(p)                               \
    if ((p == NULL) || ISBADWRITE(p, sizeof(BYTE))) {       \
        PROMPT_INVALID("Bad write pointer: " STRINGIZE(p)); \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_WRITE_PTR_(p, b)                           \
    if ((p == NULL) || ISBADWRITE(p, b)) {                  \
        PROMPT_INVALID("Bad write pointer: " STRINGIZE(p)); \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_WRITE_PTR_OR_NULL_(p, b)                   \
    if ((p != NULL) && ISBADWRITE(p, b)) {                  \
        PROMPT_INVALID("Bad write pointer: " STRINGIZE(p)); \
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_STRING_PTR(p, cch)                         \
    if ((p == NULL) || ISBADSTRING(p, cch)) {               \
        PROMPT_INVALID("Bad string pointer: " STRINGIZE(p));\
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_STRINGA_PTR(p, cch)                        \
    if ((p == NULL) || ISBADSTRINGA(p, cch)) {              \
        PROMPT_INVALID("Bad string pointer: " STRINGIZE(p));\
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \

#define VALIDATE_STRINGW_PTR(p, cch)                        \
    if ((p == NULL) || ISBADSTRINGW(p, cch)) {              \
        PROMPT_INVALID("Bad string pointer: " STRINGIZE(p));\
        hr = E_INVALIDARG;                                  \
        goto Failure;                                       \
    }                                                       \


#endif // DUIBASE__Debug_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\sballoc.cpp ===
/***************************************************************************\
*
* File: SBAlloc.cpp
*
* Description:
* Small block allocator for quick fixed size block allocations
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "SBAlloc.h"

#include "Debug.h"
#include "Alloc.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiSBAlloc
*
* SBAlloc is intended for structures and reserves the first byte of the block for
* block flags. The structure used will be auto-packed by the compiler
*
* BLOCK: | BYTE | ------ Non-reserved DATA ------ S
*
* SBAlloc does not have a static creation method. Memory failures will be
* exposed via it's Alloc method
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*
* Construct allocator
*
\***************************************************************************/

DuiSBAlloc::DuiSBAlloc(
    IN  UINT uBlockSize, 
    IN  UINT uBlocksPerSection, 
    IN  ISBLeak * pISBLeak)
{
    TRACE("DUI Small-block allocator (blocksize = %d)\n", uBlockSize);

    //
    // Leak callback interface, not ref counted
    //

    m_pISBLeak = pISBLeak;

    m_uBlockSize = uBlockSize;
    m_uBlocksPerSection = uBlocksPerSection;


    //
    // Setup first section, extra byte per block as InUse flag
    //

    m_pSections = (Section *) DuiHeap::Alloc(sizeof(Section));

    if (m_pSections != NULL) {
        m_pSections->pNext = NULL;

        m_pSections->pData = (BYTE *) DuiHeap::Alloc(m_uBlockSize * m_uBlocksPerSection);

        if (m_pSections->pData != NULL) {
#if DBG
            memset(m_pSections->pData, SBALLOC_FILLCHAR, m_uBlockSize * m_uBlocksPerSection);
#endif
            for (UINT i = 0; i < m_uBlocksPerSection; i++) {
                *(m_pSections->pData + (i * m_uBlockSize)) = 0; // Block not in use
            }
        }
    }


    //
    // Create free block stack
    //

    m_ppStack = (BYTE **) DuiHeap::Alloc(sizeof(BYTE *) * m_uBlocksPerSection);
    m_dStackPtr = -1;
}


/***************************************************************************\
*
* Free allocator
*
\***************************************************************************/

DuiSBAlloc::~DuiSBAlloc()
{
    //
    // Free all sections
    //

    Section * psbs = m_pSections;
    Section * ptmp;

    while (psbs != NULL) {

        //
        // Leak detection
        //

        if (m_pISBLeak && psbs->pData) {
            BYTE * pScan;


            //
            // Check for leaks
            //

            for (UINT i = 0; i < m_uBlocksPerSection; i++) {
                pScan = psbs->pData + (i * m_uBlockSize);

                if (*pScan) {
                    m_pISBLeak->AllocLeak(pScan);
                }
            }
        }

        ptmp = psbs;
        psbs = psbs->pNext;


        //
        // Delete section
        //

        if (ptmp->pData != NULL) {
            DuiHeap::Free(ptmp->pData);
        }

        if (ptmp != NULL) {
            DuiHeap::Free(ptmp);
        }
    }


    //
    // Delete stack
    //

    if (m_ppStack != NULL) {
        DuiHeap::Free(m_ppStack);
    }
}


/***************************************************************************\
*
* Populate cache stack, returns FALSE on memory errors
*
\***************************************************************************/

BOOL 
DuiSBAlloc::FillStack()
{
    if ((m_pSections == NULL) || (m_ppStack == NULL)) {
        return FALSE;
    }


    //
    // Scan for free block
    //

    Section * psbs = m_pSections;

    BYTE * pScan;

    for(;;) {


        //
        // Locate free blocks in section and populate stack
        //

        if (psbs->pData != NULL)
        {
            for (UINT i = 0; i < m_uBlocksPerSection; i++) {

                pScan = psbs->pData + (i * m_uBlockSize);

                if (*pScan == NULL) {


                    //
                    // Block free, store in stack
                    //

                    m_dStackPtr++;
                    m_ppStack[m_dStackPtr] = pScan;

                    if ((UINT)(m_dStackPtr + 1) == m_uBlocksPerSection)
                        return true;
                }
            }
        }

        if (psbs->pNext == NULL)
        {

           //
            // No block found, and out of sections, create new section
            //

            Section * pnew = (Section *) DuiHeap::Alloc(sizeof(Section));

            if (pnew != NULL) {
                pnew->pNext = NULL;

                pnew->pData = (BYTE *) DuiHeap::Alloc(m_uBlockSize * m_uBlocksPerSection);

                if (pnew->pData) {
#if DBG
                    memset(pnew->pData, SBALLOC_FILLCHAR, m_uBlockSize * m_uBlocksPerSection);
#endif
                    for (UINT i = 0; i < m_uBlocksPerSection; i++) {

                        //
                        // Block not in use
                        //

                        *(pnew->pData + (i * m_uBlockSize)) = 0;
                    }
                }
            }
            else {
                return FALSE;
            }

            psbs->pNext = pnew;
        }


        //
        // Search in next section
        //

        psbs = psbs->pNext;
    }
}


/***************************************************************************\
*
* Do block allocation
*
\***************************************************************************/

void * 
DuiSBAlloc::Alloc()
{
    if (m_dStackPtr == -1) {
        if (FillStack() == FALSE) {
            return NULL;
        }
    }

    if (m_ppStack == NULL) {
        return NULL;
    }

    BYTE * pBlock = m_ppStack[m_dStackPtr];

#if DBG
     memset(pBlock, SBALLOC_FILLCHAR, m_uBlockSize);
#endif


    //
    // Mark as in use
    //

    *pBlock = 1;

    m_dStackPtr--;

    return pBlock;
}


/***************************************************************************\
*
* Free previous allocation
*
\***************************************************************************/

void 
DuiSBAlloc::Free(
    IN  void * pBlock)
{
    if (pBlock == NULL) {
        return;
    }


    //
    // Return to stack
    //

    BYTE * pHold = (BYTE *) pBlock;

#if DBG
     memset(pHold, SBALLOC_FILLCHAR, m_uBlockSize);
#endif


    //
    // No longer in use
    //

    *pHold = 0;

    if ((UINT)(m_dStackPtr + 1) != m_uBlocksPerSection) {
        m_dStackPtr++;

        if (m_ppStack != NULL) {
            m_ppStack[m_dStackPtr] = pHold;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\dynamicarray.h ===
/***************************************************************************\
*
* File: Dynamicarray.h
*
* Description:
* Stores values in an array the double size when it reaches capacity
*
* Compile DEBUG for bounds checking and other ASSERT_s, see public class
* declarations for API
*
* Values are stored natively. Type is chosen at compile time. For example
* (Value is type BYTE, initial capacity is 10):
*
* DuiDynamicArray<BYTE>* pda;
* DuiDynamicArray<BYTE>::Create(10, &pda);
*
* pda->Add(4);
* pda->Insert(0, 7);
*
* DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 7
* DUITrace("1: %d\n", pda->GetItem(1));  // a[1] = 4
*
* pda->Remove(0);
*
* DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 4
*
* The Value type must support the following operation:
*    Assignment (=)
*
* History:
*  9/18/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__DuiDynamicArray_h__INCLUDED)
#define DUIBASE__DuiDynamicArray_h__INCLUDED
#pragma once


// REFORMAT


template <typename T> class DuiDynamicArray
{
public:                                                // API
    static HRESULT Create(UINT uCapacity, BOOL fZeroData, OUT DuiDynamicArray<T>** ppArray);
    virtual ~DuiDynamicArray();

    // 'Ptr' methods return addesses, note that Add and Insert may cause the array
    // to be reallocated and moved in memory. Be sure not to use pointers after
    // an Add or Insert operation

    typedef int (__cdecl *QSORTCMP )(const void*, const void*);

    HRESULT Add(T tItem);                              // Insert Item at end of list (double capacity if needed)
    HRESULT AddPtr(OUT T** ppNewItem);                 // Allocate room for Item at end of list and return pointer (double capacity if needed)
    HRESULT Insert(UINT uIndex, T tItem);              // Insert Item at location (double capacity if needed)
    HRESULT InsertPtr(UINT uIndex, OUT T** pNewItem);  // Allocate room at insertion point and return pointer (double capacity if needed)
    void SetItem(UINT uIndex, T tItem);                // Overwrite Item at location
    T GetItem(UINT uIndex);                            // Get Item at location
    T* GetItemPtr(UINT uIndex);                        // Get pointer to Item at location
    UINT GetSize();                                    // Return size of array (not current capacity)
    UINT GetIndexPtr(T* pItem);                        // Return index of Item based on its pointer
    int GetIndexOf(T tItem);                           // Return index of Item
    void Remove(UINT uIndex);                          // Remove Item at location
    void Reset();                                      // Reset array to be reused (make zero size)
    HRESULT Trim();                                    // Free excess memory (make capacity equal to size)
    BOOL WasMoved();                                   // May be called right after Add or Insert to determine if da was moved in memory
    HRESULT Clone(OUT DuiDynamicArray<T>** ppClone);      // Make exact copy of array
    BOOL IsEqual(DuiDynamicArray<T>* pda);                // Return TRUE if contents are equal to da
    void Sort(QSORTCMP fpCmp);                         // Sort the array
    void MakeImmutable();                              // Write-once, make so can only do read-only operations
    void MakeWritable();                               // Make read/write

protected:
    DuiDynamicArray() { }
    HRESULT Initialize(UINT uCapacity, BOOL fZeroData);

private:
    UINT _uSize;
    UINT _uCapacity;
    T* _pData;

	BOOL _fZeroData  : 1;                   // Zero memory for data if InsertPtr is used
    BOOL _fWasMoved  : 1;                   // On a reallocation (via Add or Insert), TRUE if block was moved
    BOOL _fImmutable : 1;                   // If TRUE, can only do read-only operations
};

template <typename T> HRESULT DuiDynamicArray<T>::Create(UINT uCapacity, BOOL fZeroData, OUT DuiDynamicArray<T>** ppArray)
{
    *ppArray = NULL;

    // Instantiate
    DuiDynamicArray<T>* pda = new DuiDynamicArray<T>;
    if (!pda)
        return E_OUTOFMEMORY;

    HRESULT hr = pda->Initialize(uCapacity, fZeroData);
    if (FAILED(hr))
        return hr;

    *ppArray = pda;

    return S_OK;
}

template <typename T> HRESULT DuiDynamicArray<T>::Initialize(UINT uCapacity, BOOL fZeroData)
{
    _uCapacity = uCapacity;
    _uSize = 0;

    if (_uCapacity)  // Allocate only if have an initial capacity
    {
        _pData = (T*)DuiHeap::Alloc(sizeof(T) * _uCapacity);
        if (!_pData)
            return E_OUTOFMEMORY;
    }
    else
        _pData = NULL;

    _fZeroData = fZeroData;
    _fWasMoved = FALSE;
    _fImmutable = FALSE;

    return S_OK;
}

template <typename T> DuiDynamicArray<T>::~DuiDynamicArray()
{
    if (_pData)
        DuiHeap::Free(_pData);
}

// Copy data into array
template <typename T> HRESULT DuiDynamicArray<T>::Add(T tItem)
{
    return Insert(_uSize, tItem);
}

template <typename T> HRESULT DuiDynamicArray<T>::AddPtr(OUT T** ppNewItem)
{
    return InsertPtr(_uSize, ppNewItem);
}

template <typename T> HRESULT DuiDynamicArray<T>::Insert(UINT uIndex, T tItem)
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    _fWasMoved = FALSE;

    ASSERT_(uIndex <= _uSize, "DuiDynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current block
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)DuiHeap::ReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)DuiHeap::Alloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = TRUE;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    // Copy new data at insertion point
    _pData[uIndex] = tItem;

    _uSize++;

    return S_OK;
}

template <typename T> HRESULT DuiDynamicArray<T>::InsertPtr(UINT uIndex, T** pNewItem)
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    _fWasMoved = FALSE;

    ASSERT_(uIndex <= _uSize, "DuiDynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current block
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)DuiHeap::ReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)DuiHeap::Alloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = TRUE;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    _uSize++;

    if (_fZeroData)
        ZeroMemory(_pData + uIndex, sizeof(T));

    *pNewItem = _pData + uIndex;

    return S_OK;
}

template <typename T> void DuiDynamicArray<T>::SetItem(UINT uIndex, T tItem)
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    ASSERT_(uIndex < _uSize, "DuiDynamicArray index out of bounds");

    // Copy new data at insertion point
    _pData[uIndex] = tItem;
}

template <typename T> T DuiDynamicArray<T>::GetItem(UINT uIndex)
{
    ASSERT_(uIndex < _uSize, "DuiDynamicArray index out of bounds");

    return _pData[uIndex];
}

template <typename T> T* DuiDynamicArray<T>::GetItemPtr(UINT uIndex)
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    ASSERT_(uIndex < _uSize, "DuiDynamicArray index out of bounds");

    return _pData + uIndex;
}

template <typename T> UINT DuiDynamicArray<T>::GetIndexPtr(T* pItem)
{
    ASSERT_((((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) >= 0 && (((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) < _uSize, "GetIndexPtr out of bounds");
    return (UINT)(((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T));
}

template <typename T> int DuiDynamicArray<T>::GetIndexOf(T tItem)
{
    for (UINT i = 0; i < _uSize; i++)
    {
        if (_pData[i] == tItem)
            return i;
    }

    return -1;
}

template <typename T> UINT DuiDynamicArray<T>::GetSize()
{
    return _uSize;
}

template <typename T> void DuiDynamicArray<T>::Remove(UINT uIndex)
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    ASSERT_(uIndex < _uSize, "DuiDynamicArray index out of bounds");

    // Shift memory
    MoveMemory(_pData + uIndex, _pData + (uIndex + 1), (_uSize - uIndex - 1) * sizeof(T));

    _uSize--;
}

template <typename T> void DuiDynamicArray<T>::Reset()
{
    ASSERT_(!_fImmutable, "Only read operations allowed on immutable DuiDynamicArray");

    _uSize = 0;
    _fWasMoved = FALSE;
}

template <typename T> HRESULT DuiDynamicArray<T>::Trim()
{
    if (_pData && (_uCapacity > _uSize))
    {
        // Reallocate current block
        UINT_PTR pOld = (UINT_PTR)_pData;
        UINT uNewCapacity = _uSize;

        if (uNewCapacity == 0)
        {
            DuiHeap::Free(_pData);
            _pData = NULL;
        }
        else
        {
            T* pNewData = (T*)DuiHeap::ReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;
    }

    return S_OK;
}

template <typename T> BOOL DuiDynamicArray<T>::WasMoved()
{
    return _fWasMoved;
}

template <typename T> HRESULT DuiDynamicArray<T>::Clone(OUT DuiDynamicArray<T>** ppClone)  // New instance returned
{
    // Validate parameters
    ASSERT_(ppClone, "Invalid parameter: ppClone == NULL");

    *ppClone = NULL;

    DuiDynamicArray<T>* pda = new DuiDynamicArray<T>;
    if (!pda)
        return E_OUTOFMEMORY;

    pda->_uSize = _uSize;
    pda->_uCapacity = _uCapacity;
    pda->_fZeroData = _fZeroData;
    pda->_fWasMoved = _fWasMoved;
    pda->_fImmutable = FALSE;
    pda->_pData = NULL;

    if (_pData)
    {
        pda->_pData = (T*)DuiHeap::Alloc(sizeof(T) * _uCapacity);
        if (!pda->_pData)
        {
            delete pda;
            return E_OUTOFMEMORY;
        }

        CopyMemory(pda->_pData, _pData, sizeof(T) * _uSize);
    }

    *ppClone = pda;

    return S_OK;
}

template <typename T> BOOL DuiDynamicArray<T>::IsEqual(DuiDynamicArray<T>* pda)
{
    if (!pda)
        return FALSE;

    if (_uSize != pda->_uSize)
        return FALSE;

    ASSERT_(!((_pData && !pda->_pData) || (!_pData && pda->_pData)), "Invalid comparison");

    if (_pData && memcmp(_pData, pda->_pData, sizeof(T) * _uSize) != 0)
        return FALSE;

    return TRUE;
}

template <typename T> void DuiDynamicArray<T>::Sort(QSORTCMP fpCmp)
{
    if (_uSize)
    {
        qsort(_pData, _uSize, sizeof(T), fpCmp);
    }
}

template <typename T> void DuiDynamicArray<T>::MakeImmutable()
{
#if DBG
    _fImmutable = TRUE;
#endif
}

template <typename T> void DuiDynamicArray<T>::MakeWritable()
{
#if DBG
    _fImmutable = FALSE;
#endif
}


#endif // DUIBASE__DuiDynamicArray_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__StdAfx_h__INCLUDED)
#define DUIBASE__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUIBASE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\core.h ===
/***************************************************************************\
*
* File: Core.h
*
* Description:
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Core_h__INCLUDED)
#define DUICORE__Core_h__INCLUDED
#pragma once

//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//

#include <DUIBaseP.h>
#include <DUIObjectAPIP.h>


//
// Project-specific prompt
//

#if DBG

#define PROMPT_INVALID(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUI/Core Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else  // DBG

#define PROMPT_INVALID(comment) ((void) 0)

#endif // DBG


#endif // DUICORE__Core_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\sballoc.h ===
/***************************************************************************\
*
* File: SBAlloc.cpp
*
* Description:
* Small block allocator for quick fixed size block allocations
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__SBAlloc_h__INCLUDED)
#define DUIBASE__SBAlloc_h__INCLUDED
#pragma once

//
// Debugging fill character
//

#define SBALLOC_FILLCHAR    0xFE


/***************************************************************************\
*
* Small block allocator
* 
\***************************************************************************/

class DuiSBAlloc
{
// Structures / Interfaces
public:
    //
    // Data structure for each section in the allocator. Each section is
    // made up of a set (constant) of blocks
    //
     
    struct Section
    {
        Section *   pNext;
        BYTE *      pData;
    };

    //
    // interface ISBLeak is used for reporting leaks, it is not ref counted
    //

    interface ISBLeak
    {
        virtual void    AllocLeak(IN void * pBlock) PURE;
    };

// Construction
public:
            DuiSBAlloc(IN UINT uBlockSize, IN UINT uBlocksPerSection, IN ISBLeak * pISBLeak);
            ~DuiSBAlloc();

// Operations
            void *      Alloc();
            void        Free(IN void * pBlock);

// Implementation
private:
            BOOL        FillStack();

// Data
private:
            UINT        m_uBlockSize;
            UINT        m_uBlocksPerSection;
            Section *   m_pSections;            // Sections list
            BYTE **     m_ppStack;              // Free block cache
            int         m_dStackPtr;            // Position in cache
            ISBLeak *   m_pISBLeak;
};


#endif // DUIBASE__SBAlloc_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\valuemap.h ===
/***************************************************************************\
*
* File: Valuemap.h
*
* Description:
* Stores Key/Value pairs
*
* Compile DEBUG for ASSERT_s, see public class declarations for API
*
* Keys and Values are stored natively and the type of each can be chosen
* at compile time. For example (Key is an int, Value is a string pointer,
* and the map will have 5 buckets):
*
* DuiValueMap<int,LPWSTR>* pvm;
* DuiValueMap<int,LPWSTR>::Create(5, &pvm);
* pvm->SetItem(1150, L"One thousand one hundred and fifty");
* LPWSTR psz;
* pvm->GetItem(1150, &psz);
* DUITrace("%s\n", psz);
*
* The Key type must support the following operations:
*    Assignment (=)
*    Int cast for finding bucket (int)
*    Equality (==)
*
* The Value type must support the following operation:
*    Assignment (=)
*
* Given the above, a key can be created based on a string where the
* correct mapping occurs even though the instance of the string is different.
*
*    class StringKey
*    {
*    public:
*        StringKey(LPWSTR);
*        operator =(LPWSTR);
*        BOOL operator ==(StringKey);
*        operator INT_PTR();
*
*    private:
*        LPWSTR pszStr;
*    };
*
*    StringKey::StringKey(LPWSTR pstr)
*    {
*        pszStr = pstr;
*    }
*
*    StringKey::operator =(LPWSTR pstr)
*    {
*        pszStr = pstr;
*    }
*
*    BOOL StringKey::operator ==(StringKey st)
*    {
*        return wcscmp(pszStr, st.pszStr) == 0;
*    }
*
*    StringKey::operator INT_PTR()  // Create hash code from string
*    {
*        int dHash = 0;
*        LPWSTR pstr = pszStr;
*        WCHAR c;
*
*        while (*pstr)
*        {
*            c = *pstr++;
*            dHash += (c << 1) + (c >> 1) + c;
*        }
*
*        return dHash;
*    }
*
* It's usage would be:
*
* DuiValueMap<StringKey, int> v(11);
*
* v.SetItem(L"My favorite number", 4);
* v.SetItem(L"Your favorite number", 8);
*
* TRACE1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 4
* TRACE1(L"Yours: %d\n", *v.GetItem(L"Your favorite number");    // 8
*
* v.SetItem(L"My favorite number", 5150);
*
* TRACE1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 5150
*
* v.Remove(L"Your favorite number";
*
* ASSERT_(!v.ContainsKey(L"Your favorite number"), "Error!");    // Mapping is removed
*
* History:
*  9/18/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__Valuemap_h__INCLUDED)
#define DUIBASE__Valuemap_h__INCLUDED
#pragma once


// REFORMAT


template <typename K, typename D> class DuiValueMap
{
    typedef struct _ENTRY
    {
        BOOL fInUse;
        K tKey;
        D tData;
        struct _ENTRY* peNext;

    } ENTRY, *PENTRY;

    typedef void (*VMENUMCALLBACK)(K tKey, D tData);

public:                                     // API
    static HRESULT Create(UINT uBuckets, OUT DuiValueMap<K,D>** ppMap);
    virtual ~DuiValueMap();

    D* GetItem(K, BOOL);                    // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(K, D*, BOOL);           // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(K, D, BOOL);            // Setup Key/Value map, creates new is doesn't exist
    void Remove(K, BOOL, BOOL);             // Removes Key/Value map, ok if Key doesn't exist
    void Enum(VMENUMCALLBACK pfnCallback);  // Callback with every item in map
    BOOL IsEmpty();                         // True if no entries
    K* GetFirstKey();                       // Returns pointer to first key found in table
    HRESULT GetDistribution(WCHAR**);       // Returns a null terminated string describing table distribution (must DuiHeap::Free)

protected:
    DuiValueMap() { }
    HRESULT Initialize(UINT uBuckets);

private:
    UINT _uBuckets;
    PENTRY* _ppBuckets;
};

template <typename K, typename D> HRESULT DuiValueMap<K,D>::Create(UINT uBuckets, OUT DuiValueMap<K,D>** ppMap)
{
    ASSERT_(uBuckets > 0, "Must create at least one bucket in DuiValueMap");

    *ppMap = NULL;

    // Instantiate
    DuiValueMap<K,D>* pvm = new DuiValueMap<K,D>;
    if (!pvm)
        return E_OUTOFMEMORY;

    HRESULT hr = pvm->Initialize(uBuckets);
    if (FAILED(hr))
        return hr;

    *ppMap = pvm;

    return S_OK;
}

template <typename K, typename D> HRESULT DuiValueMap<K,D>::Initialize(UINT uBuckets)
{
    _uBuckets = uBuckets;
    _ppBuckets = (PENTRY*)DuiHeap::AllocAndZero(sizeof(PENTRY) * _uBuckets);

    if (!_ppBuckets)
    {
        // Object isn't created if buckets cannot be allocated
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

template <typename K, typename D> DuiValueMap<K,D>::~DuiValueMap()
{
    PENTRY pe;
    PENTRY peNext;

    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            peNext = pe->peNext;
            DuiHeap::Free(pe);

            pe = peNext;
        }
    }

    DuiHeap::Free(_ppBuckets);
}

template <typename K, typename D> void DuiValueMap<K,D>::Enum(VMENUMCALLBACK pfnCallback)
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                pfnCallback(pe->tKey, pe->tData);

            pe = pe->peNext;
        }
    }
}

template <typename K, typename D> K* DuiValueMap<K,D>::GetFirstKey()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                return &pe->tKey;

            pe = pe->peNext;
        }
    }

    return NULL;
}

template <typename K, typename D> D* DuiValueMap<K,D>::GetItem(K tKey, BOOL fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    // Search for items in buckets

    PENTRY pe = _ppBuckets[(UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets)];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pe = pe->peNext;
    }

    return (pe) ? &pe->tData : NULL;
}

// Stores the value of tData (via indirection)
template <typename K, typename D> HRESULT DuiValueMap<K,D>::SetItem(K tKey, D* pData, BOOL fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = *pData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = *pData;
        }
        else
        {
            pe = (PENTRY)DuiHeap::Alloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = *pData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

// Stores the value of tData
template <typename K, typename D> HRESULT DuiValueMap<K,D>::SetItem(K tKey, D tData, BOOL fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = tData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = tData;
        }
        else
        {
            pe = (PENTRY)DuiHeap::Alloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = tData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

template <typename K, typename D> void DuiValueMap<K,D>::Remove(K tKey, BOOL fFree, BOOL fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pePrev = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pePrev = pe;      // Keep the previous item
        pe = pe->peNext;
    }

    if (pe)
    {
        if (fFree)
        {
            if (pePrev != NULL)
            {
                pePrev->peNext = pe->peNext;
            }
            else
            {
                _ppBuckets[uBucket] = pe->peNext;
            }

            DuiHeap::Free(pe);
        }
        else
        {
            pe->fInUse = false;
        }
    }
}

template <typename K, typename D> BOOL DuiValueMap<K,D>::IsEmpty()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            if (pe->fInUse)
                return false;

            pe = pe->peNext;
        }
    }

    return true;
}

template <typename K, typename D> HRESULT DuiValueMap<K,D>::GetDistribution(OUT WCHAR** ppszDist)
{
    *ppszDist = NULL;

    LPWSTR pszOut = (LPWSTR)DuiHeap::Alloc((256 + _uBuckets * 24) * sizeof(WCHAR));
    if (!pszOut)
        return E_OUTOFMEMORY
        
    WCHAR pszBuf[151];

    swprintf(pszOut, L"Buckets for %x (Slots InUse/Total): %d - ", this, _uBuckets);

    PENTRY pe;
    UINT cInUse;
    UINT cCount;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];

        cInUse = 0;
        cCount = 0;

        while (pe)
        {
            cCount++;
            if (pe->fInUse)
                cInUse++;

            pe = pe->peNext;
        }

        swprintf(pszBuf, L"(B%d): %d/%d ", i, cInUse, cCount);
        wcscat(pszOut, pszBuf);
    }

    return pszOut;
}


#endif // DUIBASE__Valuemap_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\hierarchy.cpp ===
/***************************************************************************\
*
* File: Hierarchy.cpp
*
* Description:
* Base object hierarchy methods
*
* History:
*  9/20/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Element.h"

#include "Register.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiElement (external representation is 'Element')
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*
* DuiElement::Add
*
\***************************************************************************/

HRESULT
DuiElement::Add(
    IN  DuiElement * pe)
{
    HRESULT hr;

    DuiValue * pv = DuiValue::BuildElementRef(this);
    
    hr = pe->SetValue(GlobalPI::ppiElementParent, DirectUI::PropertyInfo::iLocal, pv);
    if (FAILED(hr)) {
        goto Failure;
    }

    pv->Release();

    return S_OK;


Failure:

    if (pv != NULL) {
        pv->Release();
    }

    return hr;
}


//------------------------------------------------------------------------------
void
DuiElement::Destroy()
{
    //
    // Async-invoke of Destroy. OnAsyncDestroy will result after
    // any defer cycle
    //

    EventMsg msg;
    ZeroMemory(&msg, sizeof(msg));

    msg.cbSize   = sizeof(msg);
    msg.nMsg     = GM_DUIASYNCDESTROY;
    msg.hgadMsg  = GetDisplayNode();

    DUserPostEvent(&msg, 0);
}


//------------------------------------------------------------------------------
DuiElement *
DuiElement::GetChild(
    IN UINT nChild)
{
    BOOL fLayoutOnly = nChild & DirectUI::Element::gcLayoutOnly;
    nChild &= DirectUI::Element::gcChildBits;


    HGADGET hgad = GetGadget(GetDisplayNode(), nChild);
    DuiElement * pe = NULL;


    //
    // Find first gadget that is actually an Element
    //

    while (hgad != NULL) {

        pe = DuiElement::ElementFromDisplayNode(hgad);   
        if (pe != NULL) {
            
            if (!fLayoutOnly || 
                (pe->GetLayoutPos() != DirectUI::Layout::lpAbsolute && 
                 pe->GetLayoutPos() != DirectUI::Layout::lpNone)) {
                break;
            }
        }


        //
        // Move to next gadget since queried gadget was not an Element
        //

        hgad = GetGadget(hgad, (nChild == DirectUI::Element::gcFirst) ? GG_NEXT : GG_PREV);
    }


    return pe;

    //return DuiElement::ElementFromDisplayNode(GetGadget(GetDisplayNode(), nChild));
}


//------------------------------------------------------------------------------
DuiElement *
DuiElement::GetSibling(
    IN UINT nSibling)
{
    BOOL fLayoutOnly = nSibling & DirectUI::Element::gsLayoutOnly;
    nSibling &= DirectUI::Element::gsSiblingBits;


    HGADGET hgad = GetGadget(GetDisplayNode(), nSibling);
    DuiElement * pe = NULL;


    //
    // Find next gadget that is actually an Element
    //

    while (hgad != NULL) {

        pe = DuiElement::ElementFromDisplayNode(hgad);   
        if (pe != NULL) {

            if (!fLayoutOnly || 
                (pe->GetLayoutPos() != DirectUI::Layout::lpAbsolute && 
                 pe->GetLayoutPos() != DirectUI::Layout::lpNone)) {
                break;
            }
        }


        //
        // Move to next gadget since queried gadget was not an Element
        //

        hgad = GetGadget(hgad, nSibling);
    }


    return pe;

    //return DuiElement::ElementFromDisplayNode(GetGadget(GetDisplayNode(), nSibling));
}


//------------------------------------------------------------------------------
UINT
DuiElement::GetChildCount(
    IN  UINT nMode)
{
    UINT nCount = 0;
    DuiElement * pe = GetChild(DirectUI::Element::gcFirst | nMode);

    while (pe != NULL) {
        nCount++;

        pe = pe->GetSibling(DirectUI::Element::gsNext | nMode);
    }

    return nCount;
}


/***************************************************************************\
*
* DuiElement::GetImmediateChild
*
* Locate direct descendant that is an ancestor of the given Element.
*
\***************************************************************************/

DuiElement * 
DuiElement::GetImmediateChild(
    IN DuiElement * peFrom)
{
    if (peFrom == NULL) {
        return NULL;
    }


    DuiElement * peParent = peFrom->GetParent();

    while (peParent != this) {

        if (peParent == NULL) {
            return NULL;
        }

        peFrom = peParent;
        peParent = peParent->GetParent();
    }


    return peFrom;
}


/***************************************************************************\
*
* DuiElement::GetAdjacent
*
* GetAdjacent is used to locate a physically neighboring element given 
* a "starting" (source) element. It is used most commonly for directional
* navigation of keyboard focus, but it is general purpose enough to be used
* for other applications.
*
* peSource vs. peFrom
*   peFrom is a convenience that narrows it down to self, immediate child, 
*   or *else* (logical uses peFrom, directional uses peFrom & optionally
*   peSource)
*
* peFrom:
*   NULL: Navigating from something outside element's scope (peer, parent, etc.)
*   this: Navigating from this element itself
*   immediate child: Navigation from one of this element's children
*
* peSource:
*   NULL: Navigating from space (i.e. outside this Element's hierarchy)
*   Non-NULL: Navigating from this exact element (received press)
*
\***************************************************************************/

BOOL
DuiElement::GetAdjacent(
    IN  DuiElement * peFrom,                    // Hint
    IN  int iNavDir,                            // Type of navigation
    IN  DuiElement * peSource,                  // Source of keyboard navigation (received press)
    IN  const DirectUI::Rectangle * prcSource,  // Source reference rectangle
    IN  BOOL fKeyableOnly,
    OUT DuiElement ** ppeAdj)
{
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(peSource);
    UNREFERENCED_PARAMETER(prcSource);
    UNREFERENCED_PARAMETER(fKeyableOnly);


    *ppeAdj = NULL;


    return FALSE;
}


/***************************************************************************\
*
* DuiElement::EnsureVisible
*
* Ensure area of Element is not obstructed
*
\***************************************************************************/

BOOL
DuiElement::EnsureVisible(
    IN  int x,
    IN  int y,
    IN  int cx,
    IN  int cy)
{
    BOOL fChanged = FALSE;

    DuiElement * peParent = GetParent();
    if (peParent != NULL) {
        
        DuiValue * pv = GetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iActual);
        const DirectUI::Rectangle * pr = pv->GetRectangle();


        if (cx == -1) {
            cx = pr->width;
        }

        if (cy == -1) {
            cy = pr->height;
        }


        fChanged = peParent->EnsureVisible(pr->x + x, pr->y + y, cx, cy);


        pv->Release();
    }


    return fChanged;
}


/***************************************************************************\
*
* DuiElement::AsyncDestroy
*
* Destruction process for Elements always starts with the destroy of
* the display node. This will, in turn, cause the Element to be destroyed.
* The DeleteHandle may initiate externally (safe if outside a defer cycle).
* It's best to always use Element's Destroy API.
*
\***************************************************************************/

void
DuiElement::AsyncDestroy()
{
    DeleteHandle(GetDisplayNode());
}


/***************************************************************************\
*
* DuiElement::FlushDS
*
* Call UpdateDesiredSize with specfied value constraints on node that
* has no parent/non-absolute (a "DS Root"). DFS from root happens by layouts
* having to call UpdateDesiredSize on all non-absolute children. (1-pass)
*
\***************************************************************************/

HRESULT
DuiElement::FlushDS(
    IN  DuiElement * pe)
{
    HRESULT hr;

    HDC hDC = NULL;


    //
    // Roots get their specified size
    //

    DuiValue * pv = pe->GetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iSpecified);

    int width = pv->GetRectangleSD()->width;
    int height = pv->GetRectangleSD()->height;

    pv->Release();

    if (width == -1) {
        width = INT_MAX;
    }

    if (height == -1) {
        height = INT_MAX;
    }


    //
    // Reuse DC for renderer during update
    // Use NULL handle since may not be visible (no display node)
    // Have constraints at DS Root, update desired size of children
    //

    hDC = GetDC(NULL);

    SIZE sizeDS;

    hr = pe->UpdateDesiredSize(width, height, hDC, &sizeDS);
    if (FAILED(hr)) {
        goto Failure;
    }

    ReleaseDC(NULL, hDC);

    return S_OK;


Failure:

    if (hDC == NULL) {
        ReleaseDC(NULL, hDC);
    }

    return hr;
}


/***************************************************************************\
*
* DuiElement::FlushLayout
*
* Perform a DFS on a tree and Layout nodes if they have a Layout queued.
* As laying out, childrens' bounds may change. If bounds change, Layout
* Managers call LayoutUpdateBounds. This results in a direct layout queue
* on that child. Children will lay out during the same pass of the tree as
* a result. (1-pass)
*
\***************************************************************************/

HRESULT
DuiElement::FlushLayout(
    IN  DuiElement * pe, 
    IN  DuiDeferCycle * pdc)
{
    HRESULT hr;

    DuiValue * pv = NULL;
    DuiElement * peChild = NULL;


    if (pe->m_fBit.fNeedsLayout) {

        ASSERT_(pe->m_fBit.fNeedsLayout == DirectUI::Layout::lcNormal, "Optimized layout bit should have been cleared before the flush");  // Must not be LC_Optimize

        pe->m_fBit.fNeedsLayout = DirectUI::Layout::lcPass;


        if (pe->IsSelfLayout() || pe->HasLayout()) {

            DuiValue * pv = pe->GetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iActual);
            int cxLayout = pv->GetRectangle()->width;
            int cyLayout = pv->GetRectangle()->height;
            pv->Release();


            //
            // Setup UpdateBounds hint data which is used for automatic
            // layout adjustments (such as RTL)
            //

            DuiLayout::UpdateBoundsHint ubh = { cxLayout };  // Actual width of container

/*
            // Box model, subtract off border and padding from total extent
            const RECT* pr = pe->GetBorderThickness(&pv);  // Border thickness
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();

            pr = pe->GetPadding(&pv);  // Padding
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();
*/
            //
            // Higher priority border and padding may cause layout size to go negative
            //

            if (cxLayout < 0) {
                cxLayout = 0;
            }

            if (cyLayout < 0) {
                cyLayout = 0;
            }

            
            //
            // Self layout gets precidence
            //

            if (pe->IsSelfLayout()) {
                hr = pe->SelfLayoutDoLayout(cxLayout, cyLayout);
                if (FAILED(hr)) {
                    goto Failure;
                }
            } else {
                pv = pe->GetValue(GlobalPI::ppiElementLayout, DirectUI::PropertyInfo::iSpecified);
                DuiLayout * pl = pv->GetLayout();

                //hr = DuiLayout::ExternalCast(pl)->DoLayout(DuiElement::ExternalCast(pe), cxLayout, cyLayout);
                hr = pl->DoLayout(pe, cxLayout, cyLayout, &ubh);
                if (FAILED(hr)) {
                    goto Failure;
                }

                pv->Release();
            }
        }
    }


    //
    // Layout non-absolute children (all non-Root children). If a child has a
    // layout position of none, set its size and position to zero and skip.
    //

    int nLayoutPos;

    peChild = pe->GetChild(DirectUI::Element::gcFirst);
    while (peChild != NULL) {

        nLayoutPos = peChild->GetLayoutPos();


        if (nLayoutPos == DirectUI::Layout::lpNone) {
            hr = peChild->UpdateBounds(0, 0, 0, 0, NULL);
            if (FAILED(hr)) {
                goto Failure;
            }
        } else if (nLayoutPos != DirectUI::Layout::lpAbsolute) {
            hr = FlushLayout(peChild, pdc);
            if (FAILED(hr)) {
                goto Failure;
            }
        }


        peChild = peChild->GetSibling(DirectUI::Element::gsNext);
    }

    return S_OK;


Failure:

    if (pv != NULL) {
        pv->Release();
    }

    return hr;
}


/***************************************************************************\
*
* DuiElement::UpdateDesiredSize (for use only by Layout Managers)
*
* Given constraints, return what size Element would like to be (and cache
* information). Returned size is no larger than constraints passed in.
* 
*
\***************************************************************************/

HRESULT
DuiElement::UpdateDesiredSize(
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC,
    OUT SIZE * psizeDesired)
{
    ASSERT_((cxConstraint >= 0) && (cyConstraint >= 0), "Constrained size must not be negative");

    HRESULT hr;
    
    DuiValue * pv = NULL;


    BOOL fChangedConst = (m_sizeLastDSConst.cx != cxConstraint) || (m_sizeLastDSConst.cy != cyConstraint);

    if (m_fBit.fNeedsDSUpdate || fChangedConst) {

        m_fBit.fNeedsDSUpdate = FALSE;

        if (fChangedConst) {
            m_sizeLastDSConst.cx = cxConstraint;
            m_sizeLastDSConst.cy = cyConstraint;
        }


        //        
        // Update desired size cache since it was marked as dirty or a
        // new constraint is being used.
        //

        DuiValue * pv = GetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iSpecified);

        int cxSpecified = pv->GetRectangleSD()->width;
        if (cxSpecified > cxConstraint)
            cxSpecified = cxConstraint;

        int cySpecified = pv->GetRectangleSD()->height;
        if (cySpecified > cyConstraint)
            cySpecified = cyConstraint;


        pv->Release();


        psizeDesired->cx = (cxSpecified == -1) ? cxConstraint : cxSpecified;
        psizeDesired->cy = (cySpecified == -1) ? cyConstraint : cySpecified;


        //
        // KEY POINT:  One would think that, at this point, if a size is specified
        // for both the width and height, then there is no need to go through the rest
        // of the work here to ask what the desired size for the Element is.  Looking
        // at the math here, that is completely true.  The key is that the "get desired size"
        // calls below have the side effect of recursively caching the desired sizes of
        // the descendants of this element.
        //
        // A perf improvement going forward would be allowing the specified width
        // and height case to bail early, and have the computing and caching of descendant
        // desired sizes happening as needed at a later point.
        //


        //
        // Initial DS is spec value if unconstrained (auto). If constrained and spec
        // value is "auto", dimension can be constrained or lesser value. If
        // constrained and spec value is larger, use constraint.
        //
        
        //
        // Adjusted constrained dimensions for passing to renderer/layout.
        //

        int cxClientConstraint = psizeDesired->cx;
        int cyClientConstraint = psizeDesired->cy;


        //
        // Get constrained desired size of border and padding (box model).
        //

        SIZE sizeNonContent;

        // TODO
        sizeNonContent.cx = 0;
        sizeNonContent.cy = 0;

        /*
        const RECT* pr = GetBorderThickness(&pv);   // Border thickness
        sizeNonContent.cx = pr->left + pr->right;
        sizeNonContent.cy = pr->top + pr->bottom;
        pv->Release();

        pr = GetPadding(&pv);                       // Padding
        sizeNonContent.cx += pr->left + pr->right;
        sizeNonContent.cy += pr->top + pr->bottom;
        pv->Release();
        */

        cxClientConstraint -= sizeNonContent.cx;
        if (cxClientConstraint < 0) {
            sizeNonContent.cx += cxClientConstraint;
            cxClientConstraint = 0;
        }

        cyClientConstraint -= sizeNonContent.cy;
        if (cyClientConstraint < 0) {
            sizeNonContent.cy += cyClientConstraint;
            cyClientConstraint = 0;
        }

        
        //
        // Get content constrained desired size
        //

        SIZE sizeContent;


        if (IsSelfLayout()) {
            //
            // Element has self-layout, use it
            //

            hr = SelfLayoutUpdateDesiredSize(cxClientConstraint, cyClientConstraint, hDC, &sizeContent);
            if (FAILED(hr)) {
                goto Failure;
            }
        } else {
            //
            // No self-layout, check for external layout
            //

            if (HasLayout()) {
                //
                // External layout
                //

                pv = GetValue(GlobalPI::ppiElementLayout, DirectUI::PropertyInfo::iSpecified);

                DuiLayout * pl = pv->GetLayout();

                //hr = DuiLayout::ExternalCast(pl)->UpdateDesiredSize(DuiElement::ExternalCast(this), cxClientConstraint, cyClientConstraint, hDC, &sizeContent);
                hr = pl->UpdateDesiredSize(this, cxClientConstraint, cyClientConstraint, hDC, &sizeContent);
                if (FAILED(hr)) {
                    goto Failure;
                }

                pv->Release();
            } else {
                //
                // No layout, ask renderer
                //

                sizeContent = GetContentSize(cxClientConstraint, cyClientConstraint, hDC);
            }
        }

        
        //
        // Find content desired size
        // 0 <= cx <= cxConstraint
        // 0 <= cy <= cyConstraint
        //

        if (sizeContent.cx < 0) {
            ASSERT_(FALSE, "Out-of-range value:  Negative width for desired size.");
            sizeContent.cx = 0;
        } else if (sizeContent.cx > cxClientConstraint) {
            ASSERT_(FALSE, "Out-of-range value:  Width greater than constraint for desired size.");
            sizeContent.cx = cxClientConstraint;
        }

        if (sizeContent.cy < 0) {
            ASSERT_(FALSE, "Out-of-range value:  Negative height for desired size.");
            sizeContent.cy = 0;
        } else if (sizeContent.cy > cyClientConstraint) {
            ASSERT_(FALSE, "Out-of-range value:  Height greater than constraint for desired size.");
            sizeContent.cy = cyClientConstraint;
        }

        
        //
        // New desired size is sum of border/padding and content dimensions if auto,
        // or if was auto and constrained, use sum if less.
        //

        if (cxSpecified == -1) {
            int cxSum = sizeNonContent.cx + sizeContent.cx;
            if (cxSum < psizeDesired->cx)
                psizeDesired->cx = cxSum;
        }

        if (cySpecified == -1) {
            int cySum = sizeNonContent.cy + sizeContent.cy;
            if (cySum < psizeDesired->cy)
                psizeDesired->cy = cySum;
        }


        //
        // Update Desired Size
        //

        pv = DuiValue::BuildSize(psizeDesired->cx, psizeDesired->cy);
        if (pv == NULL) {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }

        hr = SetValue(GlobalPI::ppiElementDesiredSize, DirectUI::PropertyInfo::iLocal, pv);
        if (FAILED(hr)) {
            goto Failure;
        }


        if (hr != DUI_S_NOCHANGE) {
            //
            // Desired size changed, check if this is a DS/Layout Root. If so, manually queue
            // a layout for the root since a change of desired size does not automatically
            // queue a layout for this. Rather, it queues one for the parent. The only
            // time a layout would be queued on self for a DS change is if it's a root.
            // If a layout were auto-queued on self and parent if DS changes, it would
            // be unoptimal.
            //

            if ((GetParent() == NULL) || (GetLayoutPos() == DirectUI::Layout::lpAbsolute)) {
                m_fBit.fNeedsLayout = TRUE;
            }
        }


        pv->Release();

    } else {
        //
        // Desired size doesn't need to be updated, return current
        //

        *psizeDesired = *GetDesiredSize();
    }

    return S_OK;


Failure:

    if (pv != NULL) {
        pv->Release();
    }

    return hr;
}


/***************************************************************************\
*
* DuiElement::UpdateBounds (for use only by Layout Managers)
*
\***************************************************************************/

HRESULT 
DuiElement::UpdateBounds(
    IN  int x,
    IN  int y,
    IN  int width,
    IN  int height,
    IN  DuiLayout::UpdateBoundsHint * pubh)
{
    ASSERT_((width >= 0) && (height >= 0), "New child size must be greater than or equal to zero");

    HRESULT hr;

    //
    // Adjust for RTL if needed by using hint
    //

    if (pubh != NULL) {
        //if (IsRTL()) {
        //    x = pubh->cxParent - (x + width);
        //}
    }


    DuiValue * pv = DuiValue::BuildRectangle(x, y, width, height);
    if (pv == NULL) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    hr = SetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iActual, pv);
    if (FAILED(hr)) {
        goto Failure;
    }

    pv->Release();


    //
    // Directly queue a Layout for this so that it will be included
    // in current layout pass
    //

    if (hr != DUI_S_NOCHANGE) {
        m_fBit.fNeedsLayout = DirectUI::Layout::lcNormal;
    }

    return S_OK;


Failure:

    if (pv != NULL) {
        pv->Release();
    }

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::SelfLayoutUpdateDesiredSize(
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC,
    OUT SIZE * psize)
{
    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(cxConstraint);
    UNREFERENCED_PARAMETER(cyConstraint);

    ASSERT_(FALSE, "Must override");

    psize->cx = 0;
    psize->cy = 0;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::SelfLayoutDoLayout(
    IN  int width, 
    IN  int height)
{
    UNREFERENCED_PARAMETER(width);
    UNREFERENCED_PARAMETER(height);

    ASSERT_(FALSE, "Must override");

    return S_OK;
}


//------------------------------------------------------------------------------
void
DuiElement::FireEvent(
    IN  DirectUI::EventPUID evpuid, 
    IN  DirectUI::Element::Event * pev, 
    IN  BOOL fFull)
{
    //
    // Package generic event into a gadget message and send to target (self)
    //

    GMSG_DUIEVENT gmsgEv;
    gmsgEv.cbSize   = sizeof(GMSG_DUIEVENT);
    gmsgEv.nMsg     = GM_DUIEVENT;
    gmsgEv.hgadMsg  = GetDisplayNode();  // this


    //
    // Initialize fields
    //

    gmsgEv.peTarget = this;
    gmsgEv.evpuid   = evpuid;
    gmsgEv.pev      = pev;

    DUserSendEvent(&gmsgEv, fFull ? SGM_FULL : 0);
}


//------------------------------------------------------------------------------
void
DuiElement::OnInput(
    IN  DuiElement * peTarget,
    IN  DirectUI::Element::InputEvent * pInput)
{
    UNREFERENCED_PARAMETER(pInput);

    //
    // Handle direct and unhandled bubbled events
    //

    if ((pInput->nStage == GMF_DIRECT) || (pInput->nStage == GMF_BUBBLED)) {

        switch (pInput->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                DirectUI::Element::KeyboardEvent * pke = static_cast<DirectUI::Element::KeyboardEvent *> (pInput);
                int iNavDir = -1;

                switch (pke->nCode)
                {
                case GKEY_DOWN:
                    switch (pke->ch)
                    {
                        case VK_DOWN:   iNavDir = DirectUI::Layout::navDown;     break;
                        case VK_UP:     iNavDir = DirectUI::Layout::navUp;       break;
                        case VK_LEFT:   iNavDir = DirectUI::Layout::navLeft;     break;
                        case VK_RIGHT:  iNavDir = DirectUI::Layout::navRight;    break;
                        case VK_HOME:   iNavDir = DirectUI::Layout::navFirst;    break;   // TODO:  check for ctrl modifier
                        case VK_END:    iNavDir = DirectUI::Layout::navLast;     break;   // TODO:  check for ctrl modifier
                        case VK_TAB:    pke->fHandled = TRUE;                    return;  // Handled in GKEY_CHAR
                    }
                    break;

                /*
                case GKEY_UP:
                    return;
                */            

                case GKEY_CHAR:
                    if (pke->ch == VK_TAB) {
                        iNavDir = (pke->nModifiers & GMODIFIER_SHIFT) ? DirectUI::Layout::navPrev : DirectUI::Layout::navNext;
                    }
                    break;
                }

                if (iNavDir != -1) { 

                    DuiElement * peTo = NULL;
                    DuiElement * peSource = peTarget;
                    DuiElement * peFrom = (peSource == this) ? this : GetImmediateChild(peSource);


                    //
                    // Three cases:
                    // 1) Directional navigation
                    // 2) Logical forward navigation: Call GetAdjacent. Nav'ing into.
                    // 3) Logical backward navigation: Return null, Want to go up a level. 
                    //    Nav'ing back out.
                    //

                    ASSERT_(peFrom != NULL, "Should have found a child");
                    ASSERT_(peFrom->GetKeyWithin(), "Key focus should still be in this child");


                    BOOL fValid = GetAdjacent(peFrom, iNavDir, peSource, NULL, TRUE, &peTo);
                    if (fValid && (peTo != NULL)) {
                        peTo->SetKeyFocus();

                        pke->fHandled = TRUE;
                        return;
                    }
                }
                break;
            }
        }
    }
}


//------------------------------------------------------------------------------
void
DuiElement::OnKeyFocusMoved(
    IN  DuiElement * peFrom, 
    IN  DuiElement * peTo)
{
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(peTo);
}


//------------------------------------------------------------------------------
void
DuiElement::OnMouseFocusMoved(
    IN  DuiElement * peFrom, 
    IN  DuiElement * peTo)
{
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(peTo);
}


//------------------------------------------------------------------------------
void 
DuiElement::OnEvent(
    IN  DuiElement * peTarget,
    IN  DirectUI::EventPUID evpuid,
    IN  DirectUI::Element::Event * pev)
{
    UNREFERENCED_PARAMETER(peTarget);
    UNREFERENCED_PARAMETER(evpuid);
    UNREFERENCED_PARAMETER(pev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\layout.cpp ===
/***************************************************************************\
*
* File: Layout.cpp
*
* Description:
* Base Layout object
*
* History:
*  10/05/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Layout.h"

#include "Element.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiLayout (external representation is 'Layout')
*
*****************************************************************************
\***************************************************************************/


//
// Definition
//

IMPLEMENT_GUTS_DirectUI__Layout(DuiLayout, DUser::SGadget)


//------------------------------------------------------------------------------
void
DuiLayout::OnAttach(
    IN  DuiElement * pec)
{
    UNREFERENCED_PARAMETER(pec);
}


//------------------------------------------------------------------------------
void
DuiLayout::OnDetach(
    IN  DuiElement * pec)
{
    UNREFERENCED_PARAMETER(pec);
}


//------------------------------------------------------------------------------
void
DuiLayout::OnAdd(
    IN  DuiElement * pec, 
    IN  DuiElement * peAdded)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peAdded);
}


//------------------------------------------------------------------------------
void
DuiLayout::OnRemove(
    IN  DuiElement * pec, 
    IN  DuiElement * peRemoved)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peRemoved);
}


//------------------------------------------------------------------------------
void
DuiLayout::OnLayoutPosChanged(
    IN  DuiElement * pec, 
    IN  DuiElement * peChanged,
    IN  int nOldPos,
    IN  int nNewPos)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peChanged);
    UNREFERENCED_PARAMETER(nOldPos);
    UNREFERENCED_PARAMETER(nNewPos);
}


//------------------------------------------------------------------------------
HRESULT
DuiLayout::DoLayout(
    IN  DuiElement * pec, 
    IN  int cx, 
    IN  int cy,
    IN  UpdateBoundsHint * pubh)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(cx);
    UNREFERENCED_PARAMETER(cy);
    UNREFERENCED_PARAMETER(pubh);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuiLayout::UpdateDesiredSize(
    IN  DuiElement * pec,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC, 
    OUT SIZE * psize)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(cxConstraint);
    UNREFERENCED_PARAMETER(cyConstraint);
    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(psize);

    return S_OK;
}


//------------------------------------------------------------------------------
BOOL
DuiLayout::GetAdjacent(
    IN  DuiElement * pec, 
    IN  DuiElement * peFrom, 
    IN  int iNavDir, 
    IN  DuiElement * peSource, 
    IN  const DirectUI::Rectangle * prcSource, 
    IN  BOOL fKeyableOnly,
    OUT DuiElement ** ppeAdj)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(peSource);
    UNREFERENCED_PARAMETER(prcSource);
    UNREFERENCED_PARAMETER(fKeyableOnly);
    UNREFERENCED_PARAMETER(ppeAdj);

    return FALSE;
}


/***************************************************************************\
*****************************************************************************
*
* class DuiLayout::NavScoring
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL 
DuiLayout::NavScoring::TrackScore(
    IN  DuiElement * pe, 
    IN  DuiElement * peChild)
{
    UNREFERENCED_PARAMETER(pe);
    UNREFERENCED_PARAMETER(peChild);

    return FALSE;
}


//------------------------------------------------------------------------------
BOOL 
DuiLayout::NavScoring::Try(
    IN  DuiElement * peChild, 
    IN  int iNavDir, 
    IN  DuiElement * peSource,
    IN  const DirectUI::Rectangle * prcSource,
    IN  BOOL fKeyableOnly)
{
    UNREFERENCED_PARAMETER(peChild);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(peSource);
    UNREFERENCED_PARAMETER(prcSource);
    UNREFERENCED_PARAMETER(fKeyableOnly);

    return FALSE;
}


//------------------------------------------------------------------------------
void 
DuiLayout::NavScoring::Init(
    IN  DuiElement * peRelative, 
    IN  int iNavDir, 
    IN  DuiElement * peSource,
    IN  const DirectUI::Rectangle * prcSource)
{
    UNREFERENCED_PARAMETER(peRelative);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(peSource);
    UNREFERENCED_PARAMETER(prcSource);
}


/***************************************************************************\
*
* External API implementation (validation layer)
*
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuiLayout::ApiDoLayout(
    IN  DirectUI::Element * pece,
    IN  int cx,
    IN  int cy,
    IN  void * pvCookie)
{ 
    HRESULT hr;
    DuiLayout::UpdateBoundsHint * pubh = NULL;
    DuiElement * pec = NULL;

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_READ_PTR_OR_NULL(pvCookie);

    pubh = DuiLayout::UpdateBoundsHint::InternalCast(pvCookie);
    pec = DuiElement::InternalCast(pece);

    hr = DoLayout(pec, cx, cy, pubh);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiLayout::ApiUpdateDesiredSize(
    IN  DirectUI::Element * pece,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC,
    OUT SIZE * psize)
{
    HRESULT hr;
    DuiElement * pec = NULL;

    if (hDC == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_WRITE_PTR_(psize, sizeof(SIZE));

    pec = DuiElement::InternalCast(pece);

    hr = UpdateDesiredSize(pec, cxConstraint, cyConstraint, hDC, psize);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\element.cpp ===
/***************************************************************************\
*
* File: Element.cpp
*
* Description:
* Base object
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Element.h"

#include "Register.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiElement (external representation is 'Element')
*
*****************************************************************************
\***************************************************************************/


//
// Definition
//

IMPLEMENT_GUTS_DirectUI__Element(DuiElement, DUser::SGadget)


//------------------------------------------------------------------------------
HRESULT
DuiElement::PreBuild(
    IN  DUser::Gadget::ConstructInfo * pciData)
{
    UNREFERENCED_PARAMETER(pciData);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pciData)
{
    HRESULT hr;

    m_pLocal = NULL;
    m_hgDisplayNode = NULL;
    DirectUI::Element::ConstructInfo * peci = static_cast<DirectUI::Element::ConstructInfo *> (pciData);


    //
    // Validation layer required here
    //

    ASSERT_(peci != NULL, "Element::ConstructInfo expected");

    if (peci == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }


    //
    // Allocate local storage
    //

    hr = DuiBTreeLookup<DuiValue *>::Create(FALSE, &m_pLocal);
    if (FAILED(hr))
        goto Failure;


    //
    // Defer table and index information
    //

    m_iGCSlot   = -1;
    m_iPCTail   = -1;


    //
    // Bit store and other member initialization
    //

    ZeroMemory(&m_fBit, sizeof(m_fBit));

    m_sizeLastDSConst.cx = 0;
    m_sizeLastDSConst.cy = 0;


    //
    // Cache, initialize with default values from PropertyInfos
    //

    m_peLocParent        =   GlobalPI::ppiElementParent     ->pvDefault->GetElement();
    m_nSpecLayoutPos     =   GlobalPI::ppiElementLayoutPos  ->pvDefault->GetInt();
    m_sizeLocDesiredSize = *(GlobalPI::ppiElementDesiredSize->pvDefault->GetSize());

    //
    // Create DisplayNode based on data in construction information.
    // If pReserved0 is non-NULL, build display node. Otherwise, direct
    // subclass will create it
    //

    if (peci->pReserved0 == NULL) {

        m_hgDisplayNode = CreateGadget(NULL, GC_SIMPLE, DisplayNodeCallback, this);
        if (m_hgDisplayNode != NULL) {

            SetGadgetMessageFilter(m_hgDisplayNode, NULL, 
                    GMFI_PAINT | GMFI_CHANGESTATE, 
                    GMFI_PAINT | GMFI_CHANGESTATE | GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | GMFI_INPUTKEYBOARD | GMFI_CHANGERECT | GMFI_CHANGESTYLE);
            SetGadgetStyle(m_hgDisplayNode, GS_RELATIVE | GS_OPAQUE, GS_RELATIVE | GS_HREDRAW | GS_VREDRAW | GS_OPAQUE | GS_VISIBLE | GS_KEYBOARDFOCUS | GS_MOUSEFOCUS);

            /**** TEMP ****/
            SetGadgetStyle(m_hgDisplayNode, GS_VISIBLE | GS_HREDRAW | GS_VREDRAW, GS_VISIBLE | GS_HREDRAW | GS_VREDRAW);
        }

        if (m_hgDisplayNode == NULL) {
            hr = GetLastError();
            goto Failure;
        }
    }


    return S_OK;
    

Failure:

    if (m_hgDisplayNode != NULL) {
        DeleteHandle(m_hgDisplayNode);
        m_hgDisplayNode = NULL;
    }


    if (m_pLocal != NULL) {
        delete m_pLocal;
        m_pLocal = NULL;
    }


    return hr;
}


//------------------------------------------------------------------------------
void ReleaseValueCallback(
    IN  void * ppi, 
    IN  DuiValue * pv)
{
    UNREFERENCED_PARAMETER(ppi);

    //
    // Value destroy
    //

    pv->Release();
}


//------------------------------------------------------------------------------
DuiElement::~DuiElement()
{
    //
    // Free storage
    //

    if (m_pLocal != NULL) {

        //
        // Release any held local values
        //

        m_pLocal->Enum(ReleaseValueCallback);

        delete m_pLocal;
    }   
}


/***************************************************************************\
*
* DuiElement::DisplayNodeCallback
*
\***************************************************************************/

HRESULT
DuiElement::DisplayNodeCallback(
    IN  HGADGET hgadCur, 
    IN  void * pvCur,
    IN  EventMsg * pmsg)
{
    UNREFERENCED_PARAMETER(hgadCur);

    DuiElement * pe = reinterpret_cast<DuiElement *> (pvCur);

    switch (pmsg->nMsg)
    {
    case GM_DESTROY:
        {
            GMSG_DESTROY * pDestroy = reinterpret_cast<GMSG_DESTROY *> (pmsg);

            if (pDestroy->nCode == GDESTROY_FINAL) {
                //
                // Display node is destroyed
                //

                pe->m_hgDisplayNode = NULL;


                //
                // Delete through stub which will delete DuiElement
                //

                pe->GetStub()->Delete();
            }
        }
        return DU_S_COMPLETE;

    case GM_PAINT:                      // Direct
        {
            GMSG_PAINT * pPaint = static_cast<GMSG_PAINT *> (pmsg);

            ASSERT_(pPaint->nCmd == GPAINT_RENDER, "Invalid painting command");

            switch (pPaint->nSurfaceType)
            {
            case GSURFACE_HDC:
                {
                    GMSG_PAINTRENDERI * pPaintDC = static_cast<GMSG_PAINTRENDERI *> (pPaint);
                    //DuiElement::ExternalCast(pe)->Paint(pPaintDC->hdc, pPaintDC->prcGadgetPxl, pPaintDC->prcInvalidPxl, NULL, NULL);
                    pe->Paint(pPaintDC->hdc, pPaintDC->prcGadgetPxl, pPaintDC->prcInvalidPxl, NULL, NULL);
                }
                break;

            default:
                ASSERT_(TRUE, "Invalid painting surface type");
                break;
            }
            
        }
        return DU_S_COMPLETE;


    case GM_CHANGESTATE:
        {
            //
            // Gadget state changed
            //

            //
            // Full message, only allow direct and bubbled change state
            // messages, ignore routed
            //

            if (GET_EVENT_DEST(pmsg) == GMF_ROUTED) {
                break;
            }


            GMSG_CHANGESTATE * pSC = static_cast<GMSG_CHANGESTATE *> (pmsg);


            //
            // Retrieve corresponding Elements of state change
            //

            DuiElement * peSet  = DuiElement::ElementFromDisplayNode(pSC->hgadSet);
            DuiElement * peLost = DuiElement::ElementFromDisplayNode(pSC->hgadLost);


            // Handle by input type
            switch (pSC->nCode)
            {
            case GSTATE_KEYBOARDFOCUS:
                {
                    //
                    // Track focus, map to Focused read-only property. Set keyboard
                    // focus state only on direct messages (will be inherited).
                    //

                    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {

                        if (pSC->nCmd == GSC_SET) {
                            //
                            // Gaining focus
                            //

                            ASSERT_(pe == peSet, "Incorrect keyboard focus state");
                        
                            pe->SetValue(GlobalPI::ppiElementKeyFocused, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolTrue);

                            pe->EnsureVisible(0, 0, -1, -1);
                        } else {
                            //
                            // Losing focus
                            //

                            ASSERT_(pe->GetKeyFocused() && (pe == peLost), "Incorrect keyboard focus state");

                            pe->RemoveLocalValue(GlobalPI::ppiElementKeyFocused);
                        }
                    } else if (pSC->nCmd == GSC_LOST) {
                        //
                        // Eat the lost part of this chain once we've hit a common ancestor, 
                        // from this common ancestor up, we will only react to the set part of
                        // this chain; this will remove the duplicate notifications that occur
                        // from the common ancestor up otherwise (OnKeyFocusMoved).
                        //
                        // We are eating the lost, not the set, because the lost happens first,
                        // and the ancestors should be told after the both the lost chain and
                        // set chain has run up from below them.
                        //
                        // We only have to check set because we are receiving the lost, hence,
                        // we know peLost is a descendent.
                        //

                        if (pe->GetImmediateChild(peSet) != NULL) {
                            return DU_S_COMPLETE;
                        }
                    }


                    //
                    // Update KeyWithin property
                    //

                    DuiElement * peParent = peSet;
                    while (peParent != NULL) {
                        if (peParent == pe) {
                            break;
                        }
                        peParent = peParent->GetParent();
                    }

                    if (peParent == pe) {
                        if (!pe->GetKeyWithin()) {
                            pe->SetValue(GlobalPI::ppiElementKeyWithin, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolTrue);
                        }
                    } else {
                        if (pe->GetKeyWithin()) {
                            pe->SetValue(GlobalPI::ppiElementKeyWithin, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolFalse);
                        }
                    }
                

                    //
                    // Fire system event (direct and bubble)
                    //

                    pe->OnKeyFocusMoved(peLost, peSet);
                }

                return DU_S_PARTIAL;


            case GSTATE_MOUSEFOCUS:
                {
                    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {

                        //
                        // Set mouse focus state only on direct messages (will be inherited)
                        //

                        if (pSC->nCmd == GSC_SET) {
                            ASSERT_(!pe->GetMouseFocused() && (pe == peSet), "Incorrect mouse focus state");
                            pe->SetValue(GlobalPI::ppiElementMouseFocused, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolTrue);
                        } else {
                            ASSERT_(pe->GetMouseFocused() && (pe == peLost), "Incorrect mouse focus state");
                            pe->RemoveLocalValue(GlobalPI::ppiElementMouseFocused);
                        }
                    } else if (pSC->nCmd == GSC_LOST) {
                        //
                        // See comments for key focus
                        //

                        if (pe->GetImmediateChild(peSet)) {
                            return DU_S_COMPLETE;
                        }
                    }


                    //
                    // Update MouseWithin property
                    //

                    DuiElement * peParent = peSet;
                    while (peParent != NULL) {
                        if (peParent == pe) {
                            break;
                        }
                        peParent = peParent->GetParent();
                    }

                    if (peParent == pe) {
                        if (!pe->GetMouseWithin()) {
                            pe->SetValue(GlobalPI::ppiElementMouseWithin, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolTrue);
                        }
                    } else {
                        if (pe->GetMouseWithin()) {
                            pe->SetValue(GlobalPI::ppiElementMouseWithin, DirectUI::PropertyInfo::iLocal, DuiValue::s_pvBoolFalse);
                        }
                    }


                    //
                    // Fire system event
                    //

                    pe->OnMouseFocusMoved(peLost, peSet);
                }

                return DU_S_PARTIAL;
            }
        }
        break;


    case GM_INPUT:                      // Full
        {
            GMSG_INPUT * pInput = static_cast<GMSG_INPUT *> (pmsg);

            DuiElement * peTarget;

            
            //
            // Get target of this message
            //

            if (GET_EVENT_DEST(pInput) == GMF_DIRECT) {
                peTarget = pe;
            } else {
                peTarget = DuiElement::ElementFromDisplayNode(pInput->hgadMsg);
            }


            if (peTarget == NULL) {
                //
                // Not an Element
                //

                break;
            }


            //
            // Map to an input system event and call OnInput
            //

            switch (pInput->nDevice)
            {
            case GINPUT_MOUSE:
                {
                    DirectUI::Element::MouseEvent * pme = NULL;
                    union
                    {
                        DirectUI::Element::MouseEvent      me;
                        DirectUI::Element::MouseDragEvent  mde;
                        DirectUI::Element::MouseClickEvent mce;
                        DirectUI::Element::MouseWheelEvent mwe;
                    };

                
                    switch (pInput->nCode)
                    {
                    case GMOUSE_DRAG:
                        {
                            GMSG_MOUSEDRAG * pMouseDrag = static_cast<GMSG_MOUSEDRAG *> (pInput);
                            mde.cbSize    = sizeof(mde);
                            mde.sizeDelta = pMouseDrag->sizeDelta;
                            mde.fWithin   = pMouseDrag->fWithin;
                            pme           = &mde;
                        }
                        break;

                    case GMOUSE_WHEEL:
                        {
                            mwe.cbSize    = sizeof(mwe);
                            mwe.sWheel    = (static_cast<GMSG_MOUSEWHEEL *> (pInput))->sWheel;
                            pme           = &mwe;
                        }
                        break;

                    case GMOUSE_UP:
                    case GMOUSE_DOWN:
                        {
                            mce.cbSize    = sizeof(mce);
                            mce.cClicks   = (static_cast<GMSG_MOUSECLICK *> (pInput))->cClicks;
                            pme           = &mce;
                        }
                        break;

                    default:
                        {
                            me.cbSize     = sizeof(me);
                            pme           = &me;
                        }
                        break;
                    }


                    GMSG_MOUSE * pMouse = static_cast<GMSG_MOUSE *> (pInput);

                    pme->fHandled    = FALSE;
                    pme->nStage      = GET_EVENT_DEST(pMouse);
                    pme->nDevice     = pMouse->nDevice;
                    pme->nCode       = pMouse->nCode;
                    pme->ptClientPxl = pMouse->ptClientPxl;
                    pme->bButton     = pMouse->bButton;
                    pme->nFlags      = pMouse->nFlags;
                    pme->nModifiers  = pMouse->nModifiers;


                    //
                    // Fire system event
                    //

                    pe->OnInput(peTarget, pme);
                    //DuiElement::ExternalCast(pe)->OnInput(DuiElement::ExternalCast(peTarget), pme);


                    if (pme->fHandled) {
                        return DU_S_COMPLETE;
                    }
                }
                break;

            case GINPUT_KEYBOARD:
                {
                    GMSG_KEYBOARD * pKbd = static_cast<GMSG_KEYBOARD *> (pInput);

                    DirectUI::Element::KeyboardEvent ke;

                    ke.cbSize     = sizeof(ke);
                    ke.fHandled   = FALSE;
                    ke.nStage     = GET_EVENT_DEST(pKbd);
                    ke.nDevice    = pKbd->nDevice;
                    ke.nCode      = pKbd->nCode;
                    ke.ch         = pKbd->ch;
                    ke.cRep       = pKbd->cRep;
                    ke.wFlags     = pKbd->wFlags;
                    ke.nModifiers = pKbd->nModifiers;


                    //
                    // Fire system event
                    //

                    pe->OnInput(peTarget, &ke);
                    //DuiElement::ExternalCast(pe)->OnInput(DuiElement::ExternalCast(peTarget), &ke);


                    if (ke.fHandled) {
                        return DU_S_COMPLETE;
                    }
                }
                break;
            }
        }
        break;


    case GM_DUIASYNCDESTROY:
        {
            //
            // Destroy, process may differ depending on type of Element
            //

            pe->AsyncDestroy();
        }
        return DU_S_COMPLETE;


    case GM_DUIGETELEMENT:
        {
            //
            // Gadget query for Element pointer
            //

            ASSERT_(hgadCur == pmsg->hgadMsg, "Must only be a direct message");

            GMSG_DUIGETELEMENT* pGetEl = (GMSG_DUIGETELEMENT*)pmsg;
            pGetEl->pe = pe;
        }
        return DU_S_COMPLETE;


    case GM_DUIEVENT:
        {
            //
            // Generic DUI event
            //

            //
            // Possible full message
            //

            GMSG_DUIEVENT * pDUIEv = static_cast<GMSG_DUIEVENT *> (pmsg);

            
            //
            // Set what stage this is (routed, direct, or bubbled)
            //

            pDUIEv->pev->nStage = GET_EVENT_DEST(pmsg);


            //
            // Call handler
            //

            pe->OnEvent(pDUIEv->peTarget, pDUIEv->evpuid, pDUIEv->pev);
            //DuiElement::ExternalCast(pe)->OnEvent(DuiElement::ExternalCast(peTarget), pDUIEv->evpuid, pDUIEv->pev);


            if (pDUIEv->pev->fHandled) {
                return DU_S_COMPLETE;
            }
        }
        break;
    }


    return DU_S_NOTHANDLED;
}


/***************************************************************************\
*
* External API implementation (validation layer)
*
\***************************************************************************/

//------------------------------------------------------------------------------
DirectUI::Value *
DuiElement::ApiGetValue(
    IN  DirectUI::PropertyPUID ppuid,
    IN  UINT iIndex)
{
    DuiValue * pv = NULL;

    DuiPropertyInfo * ppi = DuiRegister::PropertyInfoFromPUID(ppuid);
    if (ppi == NULL) {
        goto Failure;
    }

    pv = GetValue(ppi, iIndex);

    return DuiValue::ExternalCast(pv);


Failure:

    //
    // Always return an acceptable Value
    //

    if ((iIndex == DirectUI::PropertyInfo::iLocal) || (ppi == NULL)) {
        pv = DuiValue::s_pvUnset;
    } else {
        pv = ppi->pvDefault;
    }

    return DuiValue::ExternalCast(pv);
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::ApiSetValue(
    IN  DirectUI::PropertyPUID ppuid,
    IN  UINT iIndex,
    IN  DirectUI::Value * pve)
{ 
    HRESULT hr = S_OK;
    DuiValue * pv = NULL;

    DuiPropertyInfo * ppi = DuiRegister::PropertyInfoFromPUID(ppuid);
    if (ppi == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }

    VALIDATE_READ_PTR_(pve, sizeof(DuiValue));

    pv = DuiValue::InternalCast(pve);

    hr = SetValue(ppi, iIndex, pv);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::ApiAdd(
    IN  DirectUI::Element * pee)
{
    HRESULT hr = S_OK;

    DuiElement * pe = NULL;

    VALIDATE_WRITE_PTR(pee);

    pe = DuiElement::InternalCast(pee);

    hr = Add(pe);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
void
DuiElement::ApiDestroy()
{
    Destroy();
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::ApiPaint(
    IN  HDC hDC, 
    IN  const RECT * prcBounds, 
    IN  const RECT * prcInvalid, 
    OUT RECT * prcSkipBorder, 
    OUT RECT * prcSkipContent)
{
    HRESULT hr = S_OK;

    if (hDC == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }
    VALIDATE_READ_PTR_(prcBounds, sizeof(RECT));
    VALIDATE_READ_PTR_(prcInvalid, sizeof(RECT));
    VALIDATE_WRITE_PTR_OR_NULL_(prcSkipBorder, sizeof(RECT));
    VALIDATE_WRITE_PTR_OR_NULL_(prcSkipContent, sizeof(RECT));

    Paint(hDC, prcBounds, prcInvalid, prcSkipBorder, prcSkipContent);

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiElement::ApiGetContentSize(
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC, 
    OUT SIZE * psize)
{
    HRESULT hr = S_OK;

    if (hDC == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }
    VALIDATE_WRITE_PTR_(psize, sizeof(SIZE));

    GetContentSize(cxConstraint, cyConstraint, hDC);

    return S_OK;


Failure:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\layout.h ===
/***************************************************************************\
*
* File: Layout.h
*
* Description:
* Base Layout object
*
* History:
*  10/05/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Layout_h__INCLUDED)
#define DUICORE__Layout_h__INCLUDED
#pragma once


//
// Forward declarations
//

class DuiElement;


/***************************************************************************\
*
* class DuiLayout (external respresentation is 'Layout')
*
\***************************************************************************/


/***************************************************************************\
*
* Layout managers will use the following Element APIs:
*
*  Child enumeration:
*
*     DuiElement * pe = pec->GetChild(DirectUI::Element::gcFirst | 
*                                     DirectUI::Element::gcLayoutOnly);
*
*     pe = pe->GetSibling(DirectUI::Element::gsNext | 
*                         DirectUI::Element::gsLayoutOnly);
*
*  Dimension query, Desried Size (used in UpdateDesiredSize):
*
*     const SIZE * psize = pe->GetDesiredSize();
*
*  Dimension query, Margins:
*
*     DuiValue * pv;
*     const DirectUI::Thickness * ptk = pe->GetMargins(&pv);
*     pv->Release();  // When done with ptk
*
*  Element update and return of Desired Size (used in UpdateDesiredSize):
*
*     HRESULT hr = pe->UpdateDesiredSize(cxConstraint, cyConstraint, 
*                                        hDC, &size);
*
*  Element update of Bounds (used in DoLayout);
*
*     HRESULT hr = pe->UpdateBounds(x, y, cx, cy, pubh);
*
\***************************************************************************/


class DuiLayout : 
        public DirectUI::LayoutImpl<DuiLayout, DUser::SGadget>
{
// Construction
public:
            DuiLayout() { }
    virtual ~DuiLayout() { }

// API Layer
public:
    dapi    HRESULT     ApiDoLayout(IN DirectUI::Element * pec, IN int cx, IN int cy, IN void * pvCookie);  /* Virtual */
    dapi    HRESULT     ApiUpdateDesiredSize(IN DirectUI::Element * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);  /* Virtual */

// Embedded classes
public:
    class UpdateBoundsHint
    {
    // Operations
    public:

    static inline void *      
                        ExternalCast(IN UpdateBoundsHint * pubh);
    static inline UpdateBoundsHint *
                        InternalCast(IN void * pubh);
    // Data
    public:
            int         cxParent;
    };

// Operations
public:
    virtual void        OnAttach(IN DuiElement * pec);
    virtual void        OnDetach(IN DuiElement * pec);
    virtual void        OnAdd(IN DuiElement * pec, IN DuiElement * peAdded);
    virtual void        OnRemove(IN DuiElement * pec, IN DuiElement * peRemoved);
    virtual void        OnLayoutPosChanged(IN DuiElement * pec, IN DuiElement * peChanged, IN int nOldPos, IN int nNewPos);
    virtual HRESULT     DoLayout(IN DuiElement * pec, IN int cx, IN int cy, IN UpdateBoundsHint * pubh);
    virtual HRESULT     UpdateDesiredSize(IN DuiElement * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);
    virtual BOOL        GetAdjacent(IN DuiElement * pec, IN DuiElement * peFrom, IN int iNavDir, IN DuiElement * peSource, IN const DirectUI::Rectangle * prcSource, IN BOOL fKeyableOnly, OUT DuiElement ** ppeAdj);

    static inline DirectUI::Layout *
                        ExternalCast(IN DuiLayout * pl);
    static inline DuiLayout *
                        InternalCast(IN DirectUI::Layout * pl);

// Navigation scoring
    class NavScoring
    {
    // Operations
    public:
            void        Init(IN DuiElement * peRelative, IN int iNavDir, IN DuiElement * peSource, IN const DirectUI::Rectangle * prcSource);
            BOOL        TrackScore(IN DuiElement * peTest, IN DuiElement * peChild);
            BOOL        Try(IN DuiElement * peChild, IN int iNavDir, IN DuiElement * peSource, IN const DirectUI::Rectangle * prcSource, IN BOOL fKeyableOnly);

    // Data
    public:
            int         m_iHighScore;
            DuiElement *
                        m_peWinner;
    private:
            int         m_iBaseIndex;
            int         m_iLow;
            int         m_iHigh;
            int         m_iMajorityScore;
    };
};


#include "Layout.inl"


#endif // DUICORE__Layout_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\element.h ===
/***************************************************************************\
*
* File: Element.h
*
* Description:
* Base object
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Element_h__INCLUDED)
#define DUICORE__Element_h__INCLUDED
#pragma once


//
// Required includes (forward declarations)
//

#include "Value.h"
#include "Property.h"
#include "Layout.h"


/***************************************************************************\
*
* class DuiElement (external respresentation is 'Element')
*
\***************************************************************************/

class DuiElement : 
        public DirectUI::ElementImpl<DuiElement, DUser::SGadget>
{
// Construction
public:
            DuiElement() { }
    virtual ~DuiElement();

// API Layer
public:
    dapi    DirectUI::Value *
                        ApiGetValue(IN DirectUI::PropertyPUID ppuid, IN UINT iIndex);  /* Final */
    dapi    HRESULT     ApiSetValue(IN DirectUI::PropertyPUID ppuid, IN UINT iIndex, IN DirectUI::Value * pv);  /* Final */
    dapi    HRESULT     ApiAdd(IN DirectUI::Element * pe);  /* Virtual */
    dapi    void        ApiDestroy();  /* Final */
    dapi    HRESULT     ApiPaint(IN HDC hDC, IN const RECT * prcBounds, IN const RECT * prcInvalid, OUT RECT * prcSkipBorder, OUT RECT * prcSkipContent);  /* Virtual */
    dapi    HRESULT     ApiGetContentSize(IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);  /* Virtual */

// Operations (Methods)
public:
    static  HRESULT     StartDefer();
    static  HRESULT     EndDefer();
            DuiValue *  GetValue(IN DuiPropertyInfo * ppi, IN UINT iIndex);
            HRESULT     SetValue(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiValue * pv);
            HRESULT     RemoveLocalValue(IN DuiPropertyInfo * ppi);

    virtual HRESULT     Add(IN DuiElement * pe);
            void        Destroy();
    inline  BOOL        GetVisible();
    inline  BOOL        GetEnabled();
            DuiElement *
                        GetChild(IN UINT nChild);
            DuiElement *
                        GetSibling(IN UINT nSibling);
            UINT        GetChildCount(IN UINT nMode);
            DuiElement * 
                        GetImmediateChild(IN DuiElement * peFrom);
    virtual BOOL        EnsureVisible(IN int x, IN int y, IN int cx, IN int cy);
    inline  void        MapElementPoint(IN DuiElement * peFrom, IN const POINT * pptFrom, OUT POINT * pptTo);
    virtual BOOL        GetAdjacent(IN DuiElement * peFrom, IN int iNavDir, IN DuiElement * peSource, IN const DirectUI::Rectangle * prcSource, IN BOOL fKeyableOnly, OUT DuiElement ** ppeAdj);
    inline  void        SetKeyFocus();

    virtual void        Paint(IN HDC hDC, IN const RECT * prcBounds, IN const RECT * prcInvalid, OUT RECT * prcSkipBorder, OUT RECT * prcSkipContent);
    virtual SIZE        GetContentSize(IN int cxConstraint, IN int cyConstraint, IN HDC hDC);

            void        FireEvent(IN DirectUI::EventPUID evpuid, IN DirectUI::Element::Event * pev, BOOL fFull);

    inline  HGADGET     GetDisplayNode();

    static  inline
            DuiElement *
                        ElementFromDisplayNode(IN HGADGET hgad);

    static inline 
            DirectUI::Element *
                        ExternalCast(IN DuiElement * pe);
    static inline 
            DuiElement *
                        InternalCast(IN DirectUI::Element * pe);

// Layout manager operations
public:
            HRESULT     UpdateDesiredSize(IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);  // For use only by LMs
            HRESULT     UpdateBounds(IN int x, IN int y, IN int width, IN int height, IN DuiLayout::UpdateBoundsHint * pubh);  // For use only by LMs

            HRESULT     SelfLayoutUpdateDesiredSize(IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);
            HRESULT     SelfLayoutDoLayout(IN int width, IN int height);

    inline  void        StartOptimizedLayoutQ();  // For use only by LMs
    inline  void        EndOptimizedLayoutQ();  // For use only by LMs

// Events
public:
    virtual void        OnPropertyChanged(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiValue * pvOld, IN DuiValue * pvNew);  // Direct
    virtual void        OnGroupChanged(IN int fGroups);  // Direct
    virtual void        OnInput(IN DuiElement * peTarget, IN DirectUI::Element::InputEvent * pInput);  // Routed, direct and bubbled
    virtual void        OnKeyFocusMoved(IN DuiElement * peFrom, IN DuiElement * peTo);  // Direct and bubbled
    virtual void        OnMouseFocusMoved(IN DuiElement * peFrom, IN DuiElement * peTo);  // Direct and bubbled
    virtual void        OnEvent(IN DuiElement * peTarget, IN DirectUI::EventPUID evpuid, IN DirectUI::Element::Event * pev);

// Direct cached access
    inline  DuiElement *
                        GetParent();
    inline  int         GetLayoutPos();
    inline  const SIZE *
                        GetDesiredSize();
    inline  BOOL        HasLayout();
    inline  BOOL        IsSelfLayout();
    inline  UINT        GetActive();
    inline  BOOL        GetKeyFocused();
    inline  BOOL        GetMouseFocused();
    inline  BOOL        GetKeyWithin();
    inline  BOOL        GetMouseWithin();
    inline  const DirectUI::Thickness *
                        GetMargins(OUT DuiValue ** ppv);
        
// Implementation
public:
    virtual void        AsyncDestroy();

    static  HRESULT     PreBuild(IN DUser::Gadget::ConstructInfo * pciData);
            HRESULT     PostBuild(IN DUser::Gadget::ConstructInfo * pciData);

    static  HRESULT     DisplayNodeCallback(IN HGADGET hgadCur, IN void * pvCur, IN EventMsg * pmsg);

    static  void        AddDependency(IN DuiElement * pe, DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiDeferCycle::DepRecs * pdr, IN DuiDeferCycle * pdc, OUT HRESULT * phr);

private:
            HRESULT     PreSourceChange(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiValue * pvOld, IN DuiValue * pvNew);
            HRESULT     PostSourceChange();

            HRESULT     GetDependencies(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiDeferCycle::DepRecs * pdr, IN DuiDeferCycle * pdc);
    static  void        VoidPCNotifyTree(IN int iPCPos, IN DuiDeferCycle * pdc);

    static  HRESULT     FlushDS(IN DuiElement * pe);
    static  HRESULT     FlushLayout(IN DuiElement * pe, IN DuiDeferCycle * pdc);

// Data
protected:
            HGADGET     m_hgDisplayNode;        // Display Node

            DuiBTreeLookup<DuiValue *> *
                        m_pLocal;               // Local Value store

            int         m_iGCSlot;              // GPC index
            int         m_iPCTail;              // PC index

            DuiElement *
                        m_peLocParent;          // Parent local storage
            int         m_nSpecLayoutPos;       // Cached layout position
            SIZE        m_sizeLocDesiredSize;   // DesiredSize local storage
            SIZE        m_sizeLastDSConst;      // Last Desired Size constraint

    struct BitStore
    {
            UINT        nLocActive        : 2;  // Cached active state local storage
            BOOL        fLocKeyWithin     : 1;  // Keyboard within local storage
            BOOL        fLocMouseWithin   : 1;  // Mouse within local storage

            BOOL        fHasLayout        : 1;  // Cached layout state (likely to be default, no full cache)
            BOOL        fSpecKeyFocused   : 1;  // Cached keyboard focused state specified
            BOOL        fSpecMouseFocused : 1;  // Cached mouse focused state specified

            UINT        fNeedsDSUpdate    : 1;
            UINT        fNeedsLayout      : 2;
            BOOL        fSelfLayout       : 1;
    } m_fBit;
};


/***************************************************************************\
*
* Element-specific messages
*
\***************************************************************************/

#define GM_DUIASYNCDESTROY            GM_USER - 1
#define GM_DUIGETELEMENT              GM_USER - 2
#define GM_DUIEVENT                   GM_USER - 3


BEGIN_STRUCT(GMSG_DUIGETELEMENT, EventMsg)
    DuiElement * pe;
END_STRUCT(GMSG_DUIGETELEMENT)


BEGIN_STRUCT(GMSG_DUIEVENT, EventMsg)
    DuiElement * peTarget;
    DirectUI::EventPUID evpuid;
    DirectUI::Element::Event * pev;
END_STRUCT(GMSG_DUIEVENT)


#include "Element.inl"


#endif // DUICORE__Element_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\process.cpp ===
/***************************************************************************\
*
* File: Process.cpp
*
* Description:
* Process startup/shutdown
*
* History:
*  11/06/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Process.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiProcess
*
* Static process methods and data
*
*****************************************************************************
\***************************************************************************/


//
// Per-context DirectUI core specific thread local storage slot
//

DWORD   DuiProcess::s_dwCoreSlot = (DWORD) -1;


//
// Process initialization success
//

HRESULT DuiProcess::s_hrInit;


/***************************************************************************\
*
* DuiThread::Init
*
* Initialize Process
*
\***************************************************************************/

HRESULT
DuiProcess::Init()
{
    s_hrInit = S_OK;

    
    //
    // Per-thread core storage slot
    //

    s_dwCoreSlot = TlsAlloc();

    if (s_dwCoreSlot == (DWORD)-1) {
        s_hrInit = DU_E_OUTOFKERNELRESOURCES;
        goto Failure;
    }
    

    TRACE("Process startup <%x>\n", GetCurrentProcess());


    return s_hrInit;


Failure:

    if (s_dwCoreSlot != (DWORD)-1) {
        TlsFree(s_dwCoreSlot);
        s_dwCoreSlot = (DWORD)-1;
    }

    return s_hrInit;
}


/***************************************************************************\
*
* DuiPrcess::UnInit
*
* Full success of Init if s_hr is not Failed
*
\***************************************************************************/

HRESULT
DuiProcess::UnInit()
{
    if (FAILED(s_hrInit)) {
        return s_hrInit;
    }


    TlsFree(s_dwCoreSlot);


    TRACE("Process shutdown <%x>\n", GetCurrentProcess());


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\layout.inl ===
/***************************************************************************\
*
* File: Layout.inl
*
* Description:
* Layout specific inline functions
*
* History:
*  10/06/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


//------------------------------------------------------------------------------
inline DirectUI::Layout *
DuiLayout::ExternalCast(
    IN  DuiLayout * pl)
{ 
    return pl->GetStub();
}


//------------------------------------------------------------------------------
inline DuiLayout *
DuiLayout::InternalCast(
    IN  DirectUI::Layout * pl)
{
    return reinterpret_cast<DuiLayout *> (DUserGetGutsData(pl, DuiLayout::s_mc.hclNew));
}


//------------------------------------------------------------------------------
inline void *
DuiLayout::UpdateBoundsHint::ExternalCast(
    IN  DuiLayout::UpdateBoundsHint * pubh)
{
    return reinterpret_cast<void *> (pubh);
}


//------------------------------------------------------------------------------
inline DuiLayout::UpdateBoundsHint *
DuiLayout::UpdateBoundsHint::InternalCast(
    IN  void * pubh)
{
    return reinterpret_cast<DuiLayout::UpdateBoundsHint *> (pubh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\process.h ===
/***************************************************************************\
*
* File: Process.h
*
* Description:
* Process startup/shutdown
*
* History:
*  11/06/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Process_h__INCLUDED)
#define DUICORE__Process_h__INCLUDED
#pragma once


/***************************************************************************\
*
* class DuiProcess
*
* Static process methods and data
*
\***************************************************************************/


class DuiProcess
{
// Operations
public:

    static  HRESULT     Init();
    static  HRESULT     UnInit();

// Data
public:
    
    static  HRESULT     s_hrInit;
    static  DWORD       s_dwCoreSlot;
};


#endif // DUICORE__Process_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\element.inl ===
/***************************************************************************\
*
* File: Element.inl
*
* Description:
* Element specific inline functions
*
* History:
*  9/15/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


//------------------------------------------------------------------------------
inline DirectUI::Element *
DuiElement::ExternalCast(
    IN  DuiElement * pe)
{ 
    return pe->GetStub();
}


//------------------------------------------------------------------------------
inline DuiElement *
DuiElement::InternalCast(
    IN  DirectUI::Element * pe)    
{
    return reinterpret_cast<DuiElement *> (DUserGetGutsData(pe, DuiElement::s_mc.hclNew));
}


//------------------------------------------------------------------------------
inline HGADGET
DuiElement::GetDisplayNode()    
{ 
    return m_hgDisplayNode;
}


/***************************************************************************\
*
* DuiElement::StartOptimizedLayoutQ
*
* Use in DoLayout on children where one or more properties will be changed
* which will cause a Layout GPC to be queued. This will cancel the layout
* GPCs and force the child to be included in the current layout cycle.
*
\***************************************************************************/

inline void
DuiElement::StartOptimizedLayoutQ()
{
    ASSERT_(m_fBit.fNeedsLayout != DirectUI::Layout::lcOptimize, "Optimized layout Q hint start incorrect");
    m_fBit.fNeedsLayout = DirectUI::Layout::lcOptimize;
}


//------------------------------------------------------------------------------
inline void
DuiElement::EndOptimizedLayoutQ()
{
    m_fBit.fNeedsLayout = DirectUI::Layout::lcNormal;
}


//------------------------------------------------------------------------------
inline DuiElement *
DuiElement::GetParent()    
{ 
    return m_peLocParent;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetVisible()    
{ 
    // TODO
    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetEnabled()    
{ 
    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::HasLayout()
{
    return m_fBit.fHasLayout;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::IsSelfLayout()
{
    return m_fBit.fSelfLayout;
}


//------------------------------------------------------------------------------
inline int
DuiElement::GetLayoutPos()    
{ 
    return m_nSpecLayoutPos;
}


//------------------------------------------------------------------------------
inline const SIZE *
DuiElement::GetDesiredSize()    
{ 
    return &m_sizeLocDesiredSize;
}


//------------------------------------------------------------------------------
inline UINT
DuiElement::GetActive()    
{ 
    return m_fBit.nLocActive;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetKeyFocused()    
{ 
    return m_fBit.fSpecKeyFocused;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetMouseFocused()    
{ 
    return m_fBit.fSpecMouseFocused;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetKeyWithin()    
{ 
    return m_fBit.fLocKeyWithin;
}


//------------------------------------------------------------------------------
inline BOOL
DuiElement::GetMouseWithin()    
{ 
    return m_fBit.fLocMouseWithin;
}


//------------------------------------------------------------------------------
inline const DirectUI::Thickness *
DuiElement::GetMargins(
    OUT DuiValue ** ppv)
{
    //
    // TODO: Use real property when available.
    // Returing zero rectangle for now
    //

    *ppv = DuiValue::s_pvThicknessZero;
    return (*ppv)->GetThickness();
}


//------------------------------------------------------------------------------
inline void
DuiElement::MapElementPoint(
    IN  DuiElement * peFrom, 
    IN  const POINT * pptFrom, 
    OUT POINT * pptTo)
{
    POINT pt = *pptFrom;
    MapGadgetPoints(peFrom->GetDisplayNode(), GetDisplayNode(), &pt, 1);

    *pptTo = pt;
}


//------------------------------------------------------------------------------
inline void
DuiElement::SetKeyFocus()
{ 
    SetGadgetFocus(GetDisplayNode());
}


//------------------------------------------------------------------------------
inline DuiElement *
DuiElement::ElementFromDisplayNode(HGADGET hgad)
{
    if (hgad == NULL) {
        return NULL;
    }

    GMSG_DUIGETELEMENT gmsgGetEl;
    ZeroMemory(&gmsgGetEl, sizeof(gmsgGetEl));

    gmsgGetEl.cbSize  = sizeof(gmsgGetEl);
    gmsgGetEl.nMsg    = GM_DUIGETELEMENT;
    gmsgGetEl.hgadMsg = hgad;

    DUserSendEvent(&gmsgGetEl, FALSE);
    
    return gmsgGetEl.pe;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\property.h ===
/***************************************************************************\
*
* File: Property.h
*
* Description:
* Property-specific, brought in by Element.h only
*
* History:
*  9/23/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Property_h__INCLUDED)
#define DUICORE__Property_h__INCLUDED
#pragma once


/***************************************************************************\
*
* class DuiDeferCycle
*
* Per-context defer table
*
\***************************************************************************/

//
// Forward declarations
//

class DuiValue;
class DuiElement;
struct DuiPropertyInfo;


class DuiDeferCycle
{
// Structures
public:

    //
    // Group notifications: deferred until EndDefer and coalesced
    //

    struct GCRecord
    {
        DuiElement *    pe;
        UINT            nGroups;
    };


    //
    // Track dependency records in PC list
    //

    struct DepRecs
    {
        int             iDepPos;
        int             cDepCnt;
    };


    //
    // Property notifications: deferred until source's dependency
    // graph is searched (within SetValue call), not coalesced
    //

    struct PCRecord
    {
        BOOL            fVoid;
        DuiElement *    pe;
        DuiPropertyInfo * 
                        ppi;
        UINT            iIndex;
        DuiValue *      pvOld;
        DuiValue *      pvNew;
        DepRecs         dr;
        int             iPrevElRec;
    };


// Construction
public:
    static  HRESULT     Build(OUT DuiDeferCycle ** ppDC);
    virtual             ~DuiDeferCycle();

protected:
                        DuiDeferCycle() { }
            HRESULT     Create();

// Operations    
public:
            void        Reset();

// Data
public:
            DuiDynamicArray<GCRecord> * 
                        pdaGC;            // Group changed database
            DuiDynamicArray<PCRecord> * 
                        pdaPC;            // Property changed database
            DuiValueMap<DuiElement *,BYTE> *
                        pvmLayoutRoot;   // Layout trees pending
            DuiValueMap<DuiElement *,BYTE> * 
                        pvmUpdateDSRoot; // Update desired size trees pending

            BOOL        fActive;
            int         cReEnter;
            BOOL        fFiring;
            int         iGCPtr;
            int         iPCPtr;
            int         iPCSSUpdate;
            int         cPCEnter;
};


#endif // DUICORE__Property_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\register.cpp ===
/***************************************************************************\
*
* File: Register.cpp
*
* Description:
* Registering Classes, Properties, and Events
*
* History:
*  10/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Register.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiRegister
*
*****************************************************************************
\***************************************************************************/


DuiDynamicArray<DuiNamespaceInfo *> * DuiRegister::m_pdaNamespaces = NULL;


//------------------------------------------------------------------------------
HRESULT
DuiRegister::Initialize(
    IN  DuiNamespaceInfo * pniDirectUI)
{
    HRESULT hr;

    m_pdaNamespaces = NULL;

    
    hr = DuiDynamicArray<DuiNamespaceInfo *>::Create(32, FALSE, &m_pdaNamespaces);
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Index zero is always DirectUI namespace. Table built into DLL.
    // No allocations/registration required.
    //

    m_pdaNamespaces->Add(pniDirectUI);


    return S_OK;


Failure:

    if (m_pdaNamespaces != NULL) {
        delete m_pdaNamespaces;
        m_pdaNamespaces = NULL;
    }


    return hr;
}


//------------------------------------------------------------------------------
void
DuiRegister::Destroy()
{
    //
    // Destroy namespace tables (DirectUI namespace not included)
    //


    //
    // Free namespace tracking list
    //

    if (m_pdaNamespaces != NULL) {
        delete m_pdaNamespaces;
    }
}


/***************************************************************************\
*
* DuiRegister::PropertyInfoFromPUID
*
* Performs parameter invalidation, used by validation layer
*
\***************************************************************************/

DuiPropertyInfo *
DuiRegister::PropertyInfoFromPUID(
    IN  DirectUI::PropertyPUID ppuid)
{
    DuiNamespaceInfo * pni = NULL;
    UINT nidx = 0;
    DuiElementInfo * pei = NULL;
    UINT eidx = 0;
    DuiPropertyInfo * ppi = NULL;
    UINT pidx = 0;


    if (m_pdaNamespaces == NULL) {
        goto Failure;
    }

    
    if (!DuiRegister::IsPropertyMUID(DirectUI::MUIDFromPUID(ppuid, NULL))) {
        goto Failure;
    }
    

    //
    // Locate NamespaceInfo
    //

    nidx = ExtractNamespaceIdx(ppuid);
    if (nidx >= m_pdaNamespaces->GetSize()) {
        goto Failure;
    }

    pni = m_pdaNamespaces->GetItem(nidx);
    

    //
    // Locate ElementInfo
    //

    eidx = ExtractClassIdx(ppuid);
    if (eidx >= pni->cei) {
        goto Failure;
    }

    pei = pni->ppei[eidx];


    //
    // Locate PropertyInfo
    //

    pidx = ExtractModifierIdx(ppuid);
    if (pidx >= pei->cpi) {
        goto Failure;
    }

    ppi = pei->pppi[pidx];


    return ppi;


Failure:

    return NULL;
}


//------------------------------------------------------------------------------
void
DuiRegister::VerifyNamespace(
    IN  DirectUI::NamespacePUID npuid)
{
    if (m_pdaNamespaces == NULL) {
        return;
    }

    UINT nidx = ExtractNamespaceIdx(npuid);

    if (nidx >= m_pdaNamespaces->GetSize()) {
        return;
    }


    DuiNamespaceInfo * pni;

    UINT e;
    DuiElementInfo * pei;
    DirectUI::ElementMUID emuid;

    UINT p;
    DuiPropertyInfo * ppi;
    DirectUI::PropertyMUID pmuid;


    pni = m_pdaNamespaces->GetItem(nidx);

    TRACE("Namespace: %S\n", pni->szName);

    for (e = 0; e < pni->cei; e++) {

        pei = pni->ppei[e];
        emuid = DirectUIMakeElementMUID(e);

        ASSERT_(pei->emuid == emuid, "ElementInfo/ElementMUID mismatch");

        TRACE("  %S\n", pei->szName);

        for (p = 0; p < pei->cpi; p++) {

            ppi = pei->pppi[p];
            pmuid = DirectUIMakePropertyMUID(emuid, p);

            ASSERT_(ppi->pmuid == pmuid, "PropertyInfo/PropertyMUID mismatch");

            TRACE("    %S\n", ppi->szName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\published.h ===
/***************************************************************************\
*
* File: Published.h
*
* Description:
* Available headers for other internal projects
*
* Published.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUI project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.
*
* Definitions that are not exposed through this file are considered project
* specific implementation details and should not used in other projects.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Published_h__INCLUDED)
#define DUICORE__Published_h__INCLUDED
#pragma once


#include "Value.h"
#include "Thread.h"
#include "Element.h"
#include "Root.h"
#include "Layout.h"
#include "Register.h"
#include "Process.h"


#endif // DUICORE__Published_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\property.cpp ===
/***************************************************************************\
*
* File: Property.cpp
*
* Description:
* Base object property methods
*
* History:
*  9/20/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Element.h"

#include "Register.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiElement (external representation is 'Element')
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
HRESULT
DuiElement::StartDefer()
{
    HRESULT hr;

    //
    // Per-context storage
    //

    DuiDeferCycle * pdc = DuiThread::GetCCDC();
    if (pdc == NULL) {
        hr = DUI_E_NOCONTEXTSTORE;
        goto Failure;
    }

    if (pdc->fActive) {

        //
        // Recursive cycle, track
        //

        pdc->cReEnter++;
    }

    // Enter defer cycle
    pdc->fActive = TRUE;

    return S_OK;


Failure:

    return hr;    
}


/***************************************************************************\
*
* DuiElement::EndDefer
*
* EndDefer will return on a reentrancy. The "outter-most" EndDefer will
* empty the defer table queues in priority order. This priority is:
*    Normal Priority Group Property Changes (Affects DS/Layout, 
*        Affects Parent DS/Layout)
*    Update Desired Size of Q'ed roots (updates DesiredSize property)
*    Layout of Q'ed roots (invokes UpdateLayoutSize, UpdateLayoutPosition)
*    Low Priority Group Property Changes (Invalidation)
*
* The outter-most EndDefer will happen outside any OnPropertyChange
* notification
*
\***************************************************************************/

HRESULT 
DuiElement::EndDefer()
{
    HRESULT hr;

    HRESULT hrPartial = S_OK;


    //
    // Per-context storage
    //

    DuiDeferCycle * pdc = DuiThread::GetCCDC();
    if (pdc == NULL) {
        hr = DUI_E_NOCONTEXTSTORE;
        goto Failure;
    }


    ASSERT_(pdc->fActive, "EndDefer called while not in a defer cycle");

    if (pdc->cReEnter > 0) {
        //
        // Recursive cycle track
        //

        pdc->cReEnter--;
        return S_OK;
    }

    //
    // EndDefer when reentrancy is 0 completes cycle
    //

    ASSERT_(!pdc->fFiring, "Mismatched Start and End defer");

    if (pdc->cReEnter == 0) {

        pdc->fFiring = TRUE;

        //
        // Complete defer cycle
        //

        BOOL fDone = FALSE;
        while (!fDone) {

            //
            // Fire group changed notifications
            //

            if (pdc->iGCPtr + 1 < (int)pdc->pdaGC->GetSize()) {
                pdc->iGCPtr++;

                DuiDeferCycle::GCRecord * pgcr = pdc->pdaGC->GetItemPtr(pdc->iGCPtr);


                //
                // No pending group changes
                //

                pgcr->pe->m_iGCSlot = -1;


                //
                // Fire
                //

                pgcr->pe->OnGroupChanged(pgcr->nGroups);

            } else {

                //
                // Check for trees needing desired size updated
                //

                DuiElement ** ppe = pdc->pvmUpdateDSRoot->GetFirstKey();
                if (ppe != NULL) {

                    TRACE("DUI: Update Desired Size, Root<%x>\n", *ppe);
                    
                    hr = FlushDS(*ppe);

                    pdc->pvmUpdateDSRoot->Remove(*ppe, FALSE, TRUE);

                    if (FAILED(hr)) {
                        hrPartial = hr;
                    }

                } else {

                    //
                    // Check for trees needing layout update
                    //

                    DuiElement ** ppe = pdc->pvmLayoutRoot->GetFirstKey();
                    if (ppe != NULL) {

                        //
                        // Order for Layout goes: layout of parent which changes the
                        // bounds of children and queues an immediate layout for
                        // each child that changes. The root doesn't have a parent.
                        // If a layout is queued for the root, update it's size now.
                        // Use specified x and y, and desired size for width and height.
                        //

                        if ((*ppe)->m_fBit.fNeedsLayout) {
                            DuiValue * pv = (*ppe)->GetValue(GlobalPI::ppiElementBounds, DirectUI::PropertyInfo::iSpecified);
                            const DirectUI::RectangleSD * prsd = pv->GetRectangleSD();
                            const SIZE * psizeDesired = (*ppe)->GetDesiredSize();

                            hr = (*ppe)->UpdateBounds(prsd->x, prsd->y, psizeDesired->cx, psizeDesired->cy, NULL);
                            if (FAILED(hr)) {
                                hrPartial = hr;
                            }

                            pv->Release();
                        }

                        TRACE("DUI: Layout, Root<%x>\n", *ppe);

                        hr = FlushLayout(*ppe, pdc);

                        pdc->pvmLayoutRoot->Remove(*ppe, FALSE, TRUE);

                        if (FAILED(hr)) {
                            hrPartial = hr;
                        }

                    } else {

                        fDone = TRUE;
                    }
                }
            }
        }
    }

    //
    // Reset for next cycle
    //

    ASSERT_((pdc->fActive) && (pdc->fFiring), "Incorrect state for end of defer cycle");

    pdc->Reset();

    ASSERT_(pdc->pvmLayoutRoot->IsEmpty(), "Defer cycle ending with pending layouts");
    ASSERT_(pdc->pvmUpdateDSRoot->IsEmpty(), "Defer cycle ending with pending update desired sizes");


    return hrPartial;


Failure:


    return hr;
}


/***************************************************************************\
*
* DuiElement::PreSourceChange
*
* PreSourceChange queues up the source change and all the dependencies of
* this source change. Depending on the dependency graph configuration, 
* multiple dependents may be queued. However, these will be coalesed when 
* PostSourceChange is called. All old values are stored at this stage as
* well. After PreSourceChange, the PC record state is ready for the actual
* change followed by the PostSourceChange.
*
* PreSourceChange will always run despite the PC rentrancy count
*
\***************************************************************************/

HRESULT
DuiElement::PreSourceChange(
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiValue * pvOld,
    IN  DuiValue * pvNew)
{
    HRESULT hr;

    //
    // If any failure occurs during a dependency Q, track. Will recover and return partial error
    //

    HRESULT hrPartial = S_OK;

    UINT iPCPtr = 0;


    //
    // Per-thread storage
    //

    DuiDeferCycle * pdc = DuiThread::GetCCDC();
    if (pdc == NULL) {
        hr = DUI_E_NODEFERTABLE;
        goto Failure;
    }

    ASSERT_((pdc->cPCEnter == 0) ? (pdc->iPCPtr == -1) : true, "PropertyChange index pointer should have 'reset' value on first pre source change");

    pdc->cPCEnter++;


    //
    // Record this property change
    //

    DuiDeferCycle::PCRecord * ppcr;
    
    hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr)) {
        goto Failure;
    }

    ppcr->fVoid = FALSE;
    ppcr->pe = this; ppcr->ppi = ppi; ppcr->iIndex = iIndex;


    //
    // Track last record for this element instance
    // If this is first record in cycle, iPrevElRec will not be valid, however, coalecsing
    // lookups (which uses this) will not go past the first record
    //

    ppcr->iPrevElRec = ppcr->pe->m_iPCTail;
    ppcr->pe->m_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    pvOld->AddRef();
    ppcr->pvOld = pvOld;

    pvNew->AddRef();
    ppcr->pvNew = pvNew;


    //
    // Append list of all steady state values from the dependency graph this source affects.
    // Do so in a BFS manner as to get direct dependents first
    //

    iPCPtr = pdc->pdaPC->GetIndexPtr(ppcr);

    ASSERT_((int)iPCPtr == pdc->iPCSSUpdate, "Record should match index of post-update starting point");

    DuiDeferCycle::DepRecs dr;

    while (iPCPtr < pdc->pdaPC->GetSize()) { // Size may change during iteration

        //
        // Get property changed record
        //

        ppcr = pdc->pdaPC->GetItemPtr(iPCPtr);


        //
        // Get all dependencies of this source (append to end of list) and track in this record
        //

        hr = ppcr->pe->GetDependencies(ppcr->ppi, ppcr->iIndex, &dr, pdc);
        if (FAILED(hr)) {
            hrPartial = hr;
        }
        

        //
        // GetDependencies may have added records which may have caused the da to move in memory,
        // so recompute pointer to record (if no new records, this AddPtr may have caused a move, do anyway)
        //

        ppcr = pdc->pdaPC->GetItemPtr(iPCPtr);


        //
        // Get old value
        //

        if (ppcr->pvOld == NULL) {
            ppcr->pvOld = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex);  // Use ref count
        }


        //
        // Track position of dependent records
        //

        ppcr->dr = dr;
    
        iPCPtr++;
    }


    if (FAILED(hr)) {
        goto Failure;
    }


    ASSERT_(iPCPtr == pdc->pdaPC->GetSize(), "Index pointer and actual property change array size mismatch");


    return hrPartial;


Failure:

    //
    // On a total failure, there is no dependency tree. Reentrancy is set if defer object was available
    //

    return hr;
}


/***************************************************************************\
*
* DuiElement::PostSourceChange
*
* PostSourceChange takes the list of dependencies and old values created
* in PreSourceChange and retrieves all the new values (and, in the cases
* of the value remaining the same, will void the PC record and all
* dependencies of that record).
*
* The value state is now back to steady state of this point (GetValue
* will return the value set).
*
* Only the "outter-most" PostSourceChange continues at this point (all
* other's return). PostSourceChange will continue and coalesce PC records,
* queues up GPC's based on the property changed, and finally fires
* OnPropertyChanged().
*
* OnPropertyChanged() events are guaranteed to be in the order of sets.
* However, it is not guaranteed that an OnPropertyChanged() will be
* called right after a set happens. If another set happens within an
* OnPropertyChanged(), the event will be deferred until the outter-most 
* PostSourceChange processes the notification
*
\***************************************************************************/

HRESULT
DuiElement::PostSourceChange()
{
    HRESULT hr;

    //
    // If any failure occurs during a group Q, track. Will recover
    // and return partial error
    //

    HRESULT hrPartial = S_OK;

    int cSize = 0;


    //
    // Per-thread storage
    //

    DuiDeferCycle * pdc = DuiThread::GetCCDC();
    if (pdc == NULL) {
        hr = DUI_E_NODEFERTABLE;
        goto Failure;
    }


    hr = StartDefer();
    if (FAILED(hr)) {
        goto Failure;
    }


    DuiDeferCycle::PCRecord * ppcr;


    //
    // Source change happened, dependent values (cached) need updating.
    // Go through records, get new value, and compare with old. If different, void
    //

    //
    // iPCSSUpdate holds the starting index of a group of records that needs post processing
    // (get new values, compare and void if needed)
    //

    cSize = (int)pdc->pdaPC->GetSize();
    while (pdc->iPCSSUpdate < cSize) { // Size constant during iteration
    
        ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCSSUpdate);

        //
        // Items may have been voided by below
        //

        if (!ppcr->fVoid) {

            ASSERT_(ppcr->pvOld != NULL, "Non-voided items should have a valid 'old' value");

            //
            // Retrieve new value (Element/Property/Index will be back to SS)
            // Force update of cached values
            //

            if (ppcr->pvNew == NULL) {
                ppcr->pvNew = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex | DirectUI::PropertyInfo::iUpdateCache);
            } 


            //
            // If new value hasn't changed, void this and all dependent notifications
            //

            if (ppcr->pvOld->IsEqual(ppcr->pvNew)) {
                VoidPCNotifyTree(pdc->iPCSSUpdate, pdc);
            }
        }

        pdc->iPCSSUpdate++;
    }


    //
    // Back to steady state at this point
    //

    //
    // First entered PostSourceChange is responsible for coalecsing, voiding duplicate property
    // change records, logging group changes, and firing property changes.
    // OnPropertyChanged is fired when values (sources and dependents) are at steady state (SS)
    //

    if (pdc->cPCEnter == 1) {
        int iScan;
        int iLastDup;

        while (pdc->iPCPtr + 1 < (int)pdc->pdaPC->GetSize()) { // Size may change during iteration

            pdc->iPCPtr++;

            //
            // Coalecse and void duplicates
            //

            ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

            if (!ppcr->fVoid) {

                DuiDeferCycle::PCRecord * ppcrChk;

                //
                // Search only records that refer to this record's element instance
                // Walk backwards from tail of element's record set (tracked by element) to
                // this, scanning for matches
                //

                iScan = ppcr->pe->m_iPCTail;
                iLastDup = -1;

                ASSERT_(pdc->iPCPtr <= ppcr->pe->m_iPCTail, "Element property change tail index mismatch");

                while (iScan != pdc->iPCPtr) {

                    ppcrChk = pdc->pdaPC->GetItemPtr(iScan);

                    if (!ppcrChk->fVoid) {

                        // Check for match
                        if (ppcrChk->iIndex == ppcr->iIndex && 
                            ppcrChk->ppi == ppcr->ppi) {

                            ASSERT_(ppcrChk->pe == ppcr->pe, "Property change record does not match with current lookup list");

                            if (iLastDup == -1) {
                                //
                                // Found the last duplicate, track
                                //

                                iLastDup = iScan;
                            } else  {
                                //
                                // Found a duplicate between last and initial record, void
                                //

                                ppcrChk->fVoid = TRUE;
                                ppcrChk->pvOld->Release();
                                ppcrChk->pvNew->Release();
                            }

                            ASSERT_(iScan <= ppcr->pe->m_iPCTail, "Coalescing pass went past property change lookup list");
                        }
                    }


                    //
                    // Walk back
                    //

                    iScan = ppcrChk->iPrevElRec;
                }

                /*
                // Simple check, use for debugging
                iScan = pdc->iPCPtr;
                iLastDup = -1;

                cSize = (int)pdc->pdaPC->GetSize();
                while (++iScan < cSize) {

                    ppcrChk = pdc->pdaPC->GetItemPtr(iScan);

                    if (!ppcrChk->fVoid) {

                        if (ppcrChk->iIndex == ppcr->iIndex && 
                            ppcrChk->ppi == ppcr->ppi && 
                            ppcrChk->pe == ppcr->pe) {

                            //
                            // Match found
                            //

                            if (iLastDup != -1) {
                                //
                                // Multiple duplicates, void last for coalesce and clear values
                                //

                                ppcrChk = pdc->pdaPC->GetItemPtr(iLastDup);

                                ppcrChk->fVoid = TRUE;
                                ppcrChk->pvOld->Release();
                                ppcrChk->pvNew->Release();
                            }

                            //
                            // Track new
                            //

                            iLastDup = iScan;
                        }
                    }
                }
                */

                //
                // Check if should postpone notification
                //

                //
                // Cleanup of this notification will happen at end regardless of use
                //

                if (iLastDup != -1) {
                    //
                    // Another copy found, coalesce to last record, transfer old value
                    // Old value will be same within a single SS group, different across multiple
                    // Multiple SS groups occur when a set happens within an OnPropertyChanged
                    //

                    ppcrChk = pdc->pdaPC->GetItemPtr(iLastDup);


                    //
                    // Release record's old value
                    //

                    ppcrChk->pvOld->Release();


                    //
                    // Transfer value
                    //

                    ppcrChk->pvOld = ppcr->pvOld;
                    ppcrChk->pvOld->AddRef();


                    //
                    // If the old and new value of the resultant coaleased record are the same,
                    // void out the record
                    //

                    if (ppcrChk->pvNew->IsEqual(ppcrChk->pvOld)) {
                        //
                        // Void and release
                        //

                        ppcrChk->fVoid = TRUE;
                        ppcrChk->pvOld->Release();
                        ppcrChk->pvNew->Release();
                    }
                } else {
                    //
                    // No duplicates found, track group changes and fire notification
                    //

                    //
                    // Log property groups only if retrieval index and not Actual
                    // (iLocal for fLocalOnly, iSpecified for fNormal and fActual).
                    // Direct mapping except for Actual.
                    //

                    UINT nQIndex = (ppcr->ppi->nFlags & DirectUI::PropertyInfo::fTypeBits);
                    if (nQIndex == DirectUI::PropertyInfo::fTriLevel) {
                        nQIndex = DirectUI::PropertyInfo::iSpecified;
                    }


                    if (nQIndex == ppcr->iIndex) {

                        DuiDeferCycle::GCRecord * pgcr;

                        UINT nGroups = ppcr->ppi->nGroups;

                        //
                        // If layout optimization is set on the Element, don't queue a layout GPC
                        // (which will, when fired, mark it as needing layout and queue another
                        // layout cycle). Rather, clear the layout GPC bit since the layout will be
                        // forced to happen within the current layout cycle
                        //

                        if (ppcr->pe->m_fBit.fNeedsLayout == DirectUI::Layout::lcOptimize) {
                            nGroups &= ~DirectUI::PropertyInfo::gAffectsLayout;
                        }


                        //
                        // Record group changes
                        //

                        if (ppcr->pe->m_iGCSlot == -1) {
                            //
                            // No GC record
                            //

                            hr = pdc->pdaGC->AddPtr(&pgcr);
                            if (FAILED(hr)) {
                                hrPartial = hr;
                            } else {
                                pgcr->pe = ppcr->pe;
                                pgcr->nGroups = 0;
                                ppcr->pe->m_iGCSlot = pdc->pdaGC->GetIndexPtr(pgcr);
                            }
                        } else {
                            //
                            // Has GC record
                            //

                            pgcr = pdc->pdaGC->GetItemPtr(ppcr->pe->m_iGCSlot);
                        }


                        //
                        // Mark groups that have changed for later async group notifications
                        //

                        pgcr->nGroups |= nGroups;
                    }


                    //
                    // Property change notification
                    //

                    ppcr->pe->OnPropertyChanged(ppcr->ppi, ppcr->iIndex, ppcr->pvOld, ppcr->pvNew);


                    //
                    // OnPropertyChanged may have added record which may have caused the da to move in memory,
                    // so recompute pointer to record
                    //

                    ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

                }


                //
                // Done with notification
                //

                ppcr->fVoid = TRUE;
                ppcr->pvOld->Release();
                ppcr->pvNew->Release();
            }
        }


        //
        // Reset PC List
        //

        pdc->iPCPtr = -1;
        pdc->iPCSSUpdate = 0;
        pdc->pdaPC->Reset();
    }

    pdc->cPCEnter--;


    hr = EndDefer();

    if (FAILED(hr)) {
        hrPartial = hr;
    }


    return hrPartial;


Failure:

    //
    // Lack of a defer object will result in a total failure. In this case, 
    // PreSourceChange would have failed as well. As a result, there is
    // no dependency tree to destroy
    //

    return hr;
}


//------------------------------------------------------------------------------
DuiValue * 
DuiElement::GetValue(
    IN  DuiPropertyInfo * ppi,
    IN  UINT iIndex)
{
    DuiValue * pv = DuiValue::s_pvUnset;

    BOOL fUC = (iIndex & DirectUI::PropertyInfo::iUpdateCache);

    switch (iIndex & DirectUI::PropertyInfo::iIndexBits)
    {
    //
    // Local Values
    //
    // Some system properties backed by Element storage. By default, state
    // stored in local b-tree store.
    //

    case DirectUI::PropertyInfo::iLocal:

        //
        // On a failure, always return Unset
        //

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementParent:  // Main store in DisplayNode
            pv = (m_peLocParent != NULL) ? DuiValue::BuildElementRef(m_peLocParent) : DuiValue::s_pvElementNull;  // Use ref count
            break;

        case GlobalPI::iElementDesiredSize:
            pv = DuiValue::BuildSize(m_sizeLocDesiredSize.cx, m_sizeLocDesiredSize.cy);  // Use ref count
            break;

        case GlobalPI::iElementActive:  // Main store in DisplayNode
            pv = DuiValue::BuildInt(m_fBit.nLocActive);  // Use ref count
            break;

        case GlobalPI::iElementKeyWithin:
            pv = DuiValue::BuildBool(m_fBit.fLocKeyWithin);  // Use ref count
            break;

        case GlobalPI::iElementMouseWithin:
            pv = DuiValue::BuildBool(m_fBit.fLocMouseWithin);  // Use ref count
            break;

        default:
            {
                //
                // Check local store
                //
            
                DuiValue ** ppv = m_pLocal->GetItem(ppi);
                if (ppv != NULL) {
                    pv = *ppv;
                    pv->AddRef();
                }
            }
            break;
        }


        //
        // Unset on failure
        //

        if (pv == NULL) {
            pv = DuiValue::s_pvUnset;
        }

        break;


    //
    // Specified Values
    //
    // Value Expression that is common for all Elements and varies slightly
    // between Properties being queried. Hardcoded since never changes. Supports VE caching.
    //

    case DirectUI::PropertyInfo::iSpecified:
        {
            //
            // Merging stage. pv is merged Value (destination).
            // On a failure, always return Default
            //

            //
            // Return Value based on cache, if available. Cache is additional state
            // that reflects all or part of Value.
            //

            if (!fUC && (ppi->nFlags & DirectUI::PropertyInfo::fCached)) {

                switch (ppi->iGlobal)
                {
                case GlobalPI::iElementLayout:
                    if (!HasLayout()) {
                        pv = GlobalPI::ppiElementLayout->pvDefault;
                    }
                    break;

                case GlobalPI::iElementLayoutPos:
                    pv = DuiValue::BuildInt(m_nSpecLayoutPos);  // Use ref count
                    break;

                case GlobalPI::iElementKeyFocused:
                    pv = DuiValue::BuildBool(m_fBit.fSpecKeyFocused);  // Use ref count
                    break;

                case GlobalPI::iElementMouseFocused:
                    pv = DuiValue::BuildBool(m_fBit.fSpecMouseFocused);  // Use ref count
                    break;
                }


                if (pv->IsComplete()) {
                    //
                    // Done, Value was available in cache, return
                    //

                    break;
                }
            }


            ASSERT_(pv == DuiValue::s_pvUnset, "Must be Unset for start of a non-cached Get");


            DuiValue * pvS = NULL;                  // Source Value for merging
            DuiThread::CoreCtxStore * pCCS = NULL;  // Context used for merging


            //
            // Local value
            //

            pv = GetValue(ppi, DirectUI::PropertyInfo::iLocal);  // Use ref count
            if (pv->IsComplete()) {
                goto SpecUC;
            }


            //
            // Access to context store required for Value merges if
            // Value is sub-divided type
            //
           
            if (pv->IsSubDivided()) {
                pCCS = DuiThread::GetCCStore();
                if (pCCS == NULL) {
                    pv->Release();
                    pv = ppi->pvDefault;
                    break;
                }
            }


            //
            // Inherited value (if applicable)
            //

            if (ppi->nFlags & DirectUI::PropertyInfo::fInherit) {
                
                //
                // Conditional inheritance
                //

                BOOL fInherit = TRUE;

                switch (ppi->iGlobal)
                {
                case GlobalPI::iElementKeyFocused:
                    fInherit = (GetActive() & DirectUI::Element::aeKeyboard) == 0;
                    break;

                case GlobalPI::iElementMouseFocused:
                    fInherit = (GetActive() & DirectUI::Element::aeMouse) == 0;
                    break;
                }

                
                if (fInherit) {
                    DuiElement * peParent = GetParent();
                    if (peParent != NULL) {

                        // TODO: Check if property is valid on parent

                        pvS = peParent->GetValue(ppi, DirectUI::PropertyInfo::iSpecified);

                        pv = pv->Merge(pvS, pCCS);  // pv auto-released, use ref count
                        pvS->Release();

                        if (pv->IsComplete()) {
                            goto SpecUC;
                        }
                    }
                }
            }


            //
            // Default value (default values are always complete)
            //

            pvS = ppi->pvDefault;

            pv = pv->Merge(pvS, pCCS);  // pv auto-released, use ref count
            pvS->Release();
            if (pv == NULL) {
                pv = ppi->pvDefault;
            }


            //
            // Update cached Values if required. Cache is additional state
            // that reflects all or part of Value. This additional state may be
            // in the display node itself. In cases were the Value of a property
            // can come from more than one place, it's not possible to use
            // the display node for the only storage.
            //
SpecUC:
            if (fUC && (ppi->nFlags & DirectUI::PropertyInfo::fCached)) {

                switch (ppi->iGlobal)
                {
                case GlobalPI::iElementLayout:
                    m_fBit.fHasLayout = (pv->GetLayout() != NULL);
                    break;

                case GlobalPI::iElementLayoutPos:
                    m_nSpecLayoutPos = pv->GetInt();
                    break;

                case GlobalPI::iElementKeyFocused:
                    m_fBit.fSpecKeyFocused = pv->GetBool();
                    break;

                case GlobalPI::iElementMouseFocused:
                    m_fBit.fSpecMouseFocused = pv->GetBool();
                    break;
                }
            }


            ASSERT_(pv->IsComplete(), "Specified Value retrieval must be Complete");
        }


        break;


    //
    // Actual
    //

    case DirectUI::PropertyInfo::iActual:

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementBounds:
            RECT rc;
            GetGadgetRect(GetDisplayNode(), &rc, SGR_PARENT);
            pv = DuiValue::BuildRectangle(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
            break;

        default:
            
            //
            // By default, all specified values are assumed to be what is
            // actually used unless the iActual value is not Unset
            //

            ASSERT_(FALSE, "Actual mode is unavailable for this property");
        }


        if (pv == NULL) {
            //
            // On Failure, use default value
            //

            pv = ppi->pvDefault;
        }


        break;
    }


    ASSERT_(pv != NULL, "GetValue return must never be NULL");

    
    return pv;
}


/***************************************************************************\
*
* DuiElement::SetValue
*
\***************************************************************************/

HRESULT
DuiElement::SetValue(
    IN  DuiPropertyInfo * ppi,
    IN  UINT iIndex,
    IN  DuiValue * pv)
{
    ASSERT_(iIndex != DirectUI::PropertyInfo::iSpecified, "Cannot set Specified Values");


    //
    // Get old value
    //

    DuiValue * pvOld = GetValue(ppi, iIndex);

    HRESULT hr;

    HRESULT hrPartial = S_OK;


    if (!pvOld->IsEqual(pv)) {

        //
        // OnPropertyChanging
        //

        //
        // Setup defer table for change
        //

        hr = PreSourceChange(ppi, iIndex, pvOld, pv);
        if (FAILED(hr)) {
            hrPartial = hr;
        }


        //
        // Store value locally (either on Element or DisplayNode). It is possible
        // to store on the display node if the Value can only come from
        // one place (i.e. LocalOnly values can only be accessed locally from the Element).
        //
        // Some values may be stored on Element as well as on the DisplayNode
        // for best performance for high-traffic properties.
        //

        if (iIndex == DirectUI::PropertyInfo::iLocal) {
            //
            // Local value store
            //

            switch (ppi->iGlobal)
            {
            case GlobalPI::iElementParent:  // Dual storage (dup on Element for speed)
                m_peLocParent = pv->GetElement();
                SetGadgetParent(GetDisplayNode(), pv->GetElement()->GetDisplayNode(), NULL, GORDER_TOP);
                break;

            case GlobalPI::iElementDesiredSize:
                m_sizeLocDesiredSize.cx = pv->GetSize()->cx;
                m_sizeLocDesiredSize.cy = pv->GetSize()->cy;
                break;

            case GlobalPI::iElementActive:  // Dual storage (dup on Element for speed)
                {
                    m_fBit.nLocActive = pv->GetInt();

                    UINT nStyle = 0;
                    UINT nFilter = 0;

                    if (pv->GetInt() & DirectUI::Element::aeMouse) {
                        nStyle |= GS_MOUSEFOCUS;
                        nFilter |= GMFI_INPUTMOUSE;
                    }
                    if (pv->GetInt() & DirectUI::Element::aeKeyboard) {
                        nStyle |= GS_KEYBOARDFOCUS;
                        nFilter |= GMFI_INPUTKEYBOARD;
                    }

                    SetGadgetStyle(GetDisplayNode(), nStyle, GS_MOUSEFOCUS | GS_KEYBOARDFOCUS);
                    SetGadgetMessageFilter(GetDisplayNode(), NULL, nFilter, GMFI_INPUTMOUSE | GMFI_INPUTKEYBOARD);
                }
                break;

            case GlobalPI::iElementKeyWithin:
                m_fBit.fLocKeyWithin = pv->GetBool();
                break;

            case GlobalPI::iElementMouseWithin:
                m_fBit.fLocMouseWithin = pv->GetBool();
                break;

            default:
                //
                // Store value on Element
                //

                pv->AddRef();
                m_pLocal->SetItem(ppi, pv);

                //
                // Storing new value, release the local reference
                //

                pvOld->Release();
                break;
            }
        } else {
            //
            // Actual value store (no default storage)
            //

            ASSERT_(iIndex == DirectUI::PropertyInfo::iActual, "Expecting Actual index");


            switch (ppi->iGlobal)
            {
            case GlobalPI::iElementBounds:
                {
                    const DirectUI::Rectangle * pr = pv->GetRectangle();
                    SetGadgetRect(GetDisplayNode(), pr->x, pr->y, pr->width, pr->height, SGR_PARENT | SGR_SIZE | ((GetParent() != NULL) ? SGR_MOVE : 0));
                }
                break;

            default:
                //
                // No default
                //

                break;
            }
        }


        //
        // Change occured, track new values of dependencies and fire events if needed
        //

        hr = PostSourceChange();
        if (FAILED(hr)) {
            hrPartial = hr;
        }
    } else {
        //
        // Property values were equal
        //

        hrPartial = DUI_S_NOCHANGE;
    }


    //
    // Release for GetValue
    //

    pvOld->Release();

    return hrPartial;
}


/***************************************************************************\
*
* DuiElement::RemoveLocalValue
*
\***************************************************************************/

HRESULT 
DuiElement::RemoveLocalValue(
    IN  DuiPropertyInfo * ppi)
{
    HRESULT hr;

    HRESULT hrPartial = S_OK;

    //
    // Get current value in local store for property
    //

    DuiValue ** ppv = m_pLocal->GetItem(ppi);
    if (ppv) {

        //
        // Make copy in case it moves
        //

        DuiValue * pv = *ppv;


        //
        // Store pre-change state
        //

        hr = PreSourceChange(ppi, DirectUI::PropertyInfo::iLocal, pv, DuiValue::s_pvUnset);
        if (FAILED(hr)) {
            hrPartial = hr;
        }


        m_pLocal->Remove(ppi);

        //
        // Old value removed, release for local reference
        //

        pv->Release();


        //
        // Store post-change state
        //

        hr = PostSourceChange();
        if (FAILED(hr)) {
            hrPartial = hr;
        }
    }


    return hrPartial;
}


/***************************************************************************\
*
* DuiElement::GetDependencies
*
* Go through all direct dependents of this source change and append
* them into a PCRecord (ignoring irrelevant changes). Store their current
* value into pvOld as well
*
* In the event of a failure of adding a dependency, adding of dependencies
* will continue and no work is undone. A failure will still be reported
*
\***************************************************************************/

HRESULT
DuiElement::GetDependencies(
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiDeferCycle::DepRecs * pdr, 
    IN  DuiDeferCycle * pdc)
{
    HRESULT hrPartial = S_OK;


    pdr->iDepPos = -1;
    pdr->cDepCnt = 0;


    switch (iIndex)
    {
    case DirectUI::PropertyInfo::iLocal:

        //
        // Default general dependencies on this (Local flag)
        //

        if ((ppi->nFlags & DirectUI::PropertyInfo::fTypeBits) != DirectUI::PropertyInfo::fLocalOnly) {
            //
            // Specified is dependent for Normal and TriLevel
            //

            AddDependency(this, ppi, DirectUI::PropertyInfo::iSpecified, pdr, pdc, &hrPartial);  
        }

        break;

    case DirectUI::PropertyInfo::iSpecified:

        //
        // Default general dependencies on this (Specified flag)
        //

        if ((ppi->nFlags & DirectUI::PropertyInfo::fTypeBits) == DirectUI::PropertyInfo::fNormal) {
            //
            // Specified of child is dependent for Normal
            //

            //
            // Inherited dependencies
            //

            if (ppi->nFlags & DirectUI::PropertyInfo::fInherit)
            {
                DuiElement * peChild = GetChild(DirectUI::Element::gcFirst);

                while (peChild != NULL) {
                
                    // TODO: Check if is a valid property on child

                    AddDependency(peChild, ppi, DirectUI::PropertyInfo::iSpecified, pdr, pdc, &hrPartial);

                    peChild = peChild->GetSibling(DirectUI::Element::gsNext);
                }
            }
        }

        break;

    case DirectUI::PropertyInfo::iActual:
        break;
    }


    return hrPartial;
}


/***************************************************************************\
*
* DuiElement::AddDependency
*
\***************************************************************************/

void
DuiElement::AddDependency(
    IN  DuiElement * pe, 
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiDeferCycle::DepRecs * pdr, 
    IN  DuiDeferCycle * pdc, 
    OUT HRESULT * phr)
{
    DuiDeferCycle::PCRecord * ppcr;
    
    HRESULT hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr)) {
        //
        // Only set on a failure
        //

        *phr = hr;
        return;
    }

    ppcr->fVoid = FALSE;
    ppcr->pe = pe; ppcr->ppi = ppi; ppcr->iIndex = iIndex;

    //
    // Track last record for this element instance
    //

    ppcr->iPrevElRec = pe->m_iPCTail;
    pe->m_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    ppcr->pvOld = NULL; ppcr->pvNew = NULL;
    if (pdr->cDepCnt == 0) {
        pdr->iDepPos = pe->m_iPCTail;
    }
    pdr->cDepCnt++;
}


//------------------------------------------------------------------------------
void
DuiElement::VoidPCNotifyTree(
    IN  int iPCPos, 
    IN  DuiDeferCycle * pdc)
{
    DuiDeferCycle::PCRecord * ppcr = pdc->pdaPC->GetItemPtr(iPCPos);

    ppcr->fVoid = TRUE;
    ppcr->pvOld->Release();
    if (ppcr->pvNew) {
        ppcr->pvNew->Release();
    }

    //
    // Void subtree
    //

    for (int i = 0; i < ppcr->dr.cDepCnt; i++) {
        VoidPCNotifyTree(ppcr->dr.iDepPos + i, pdc);
    }
}


//------------------------------------------------------------------------------
void
DuiElement::OnPropertyChanged(
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiValue * pvOld, 
    IN  DuiValue * pvNew)
{
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

#if DBG
    WCHAR szvOld[81];
    WCHAR szvNew[81];
    LPCWSTR pszIndex[3] = { L"Local", L"Specified", L"Actual" };

    TRACE("PC: <%x> %S[%S] O:%S N:%S\n", this, ppi->szName, pszIndex[iIndex - 1], pvOld->ToString(szvOld, ARRAYSIZE(szvOld)), pvNew->ToString(szvNew, ARRAYSIZE(szvNew)));
#endif


    switch (iIndex)
    {
    case DirectUI::PropertyInfo::iLocal:
        //
        // Local
        //

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementParent:

            DuiElement * peNewParent = pvNew->GetElement();
            DuiElement * peOldParent = pvOld->GetElement();
            DuiValue * pv;

            if (peOldParent != NULL) {
                //
                // Unparenting
                //

                //
                // Inform parent's layout that this is being removed
                //

                if (peOldParent->HasLayout()) {
                    pv = peOldParent->GetValue(GlobalPI::ppiElementLayout, DirectUI::PropertyInfo::iSpecified);

                    pv->GetLayout()->OnRemove(peOldParent, this);

                    pv->Release();
                }
            }

            if (peNewParent != NULL) {
                //
                // Parenting
                //

                //
                // No longer a "Root", remove possible Q for UpdateDS and Layout
                //

                DuiDeferCycle * pdc = DuiThread::GetCCDC();
                if (pdc != NULL) {
                    pdc->pvmUpdateDSRoot->Remove(this, FALSE, TRUE);
                    pdc->pvmLayoutRoot->Remove(this, FALSE, TRUE);
                }


                //
                // Inform parent's layout that this is being added
                //

                if (peNewParent->HasLayout()) {
                    pv = peNewParent->GetValue(GlobalPI::ppiElementLayout, DirectUI::PropertyInfo::iSpecified);

                    pv->GetLayout()->OnAdd(peNewParent, this);

                    pv->Release();
                }
            }
        
            break;
        }

        break;


    case DirectUI::PropertyInfo::iSpecified:
        //
        // Specified
        //

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementLayout:
            {
                // TODO: OnAdd, OnRemove of all children

                //
                // Detach from old
                //

                DuiLayout * pl = pvOld->GetLayout();

                if (pl != NULL) {
                    pl->OnDetach(this);
                }


                //
                // Attach to new
                //

                pl = pvNew->GetLayout();

                if (pl != NULL) {
                    pl->OnAttach(this);
                }
            }

            break;


        case GlobalPI::iElementLayoutPos:
            {
                //
                // If no longer a "Root", remove possible Q for UpdateDS and Layout
                //

                if (pvNew->GetInt() != DirectUI::Layout::lpAbsolute) {

                    DuiDeferCycle * pdc = DuiThread::GetCCDC();
                    if (pdc != NULL) {
                        pdc->pvmUpdateDSRoot->Remove(this, FALSE, TRUE);
                        pdc->pvmLayoutRoot->Remove(this, FALSE, TRUE);
                    }
                }


                //
                // Inform parent layout (if any) of change
                //

                DuiElement * peParent = GetParent();
                if ((peParent != NULL) && (peParent->HasLayout())) {
                    DuiValue * pv = peParent->GetValue(GlobalPI::ppiElementLayout, DirectUI::PropertyInfo::iLocal);
                    DuiLayout * pl = pv->GetLayout();

                    //
                    // Inform layout of layoutpos only for external layouts
                    //

                    pl->OnLayoutPosChanged(peParent, this, pvOld->GetInt(), pvNew->GetInt());

                    pv->Release();
                }
            }
        
            break;
        }


        break;
    }
}


//------------------------------------------------------------------------------
void
DuiElement::OnGroupChanged(
    IN  int fGroups)
{
    DuiDeferCycle * pdc = DuiThread::GetCCDC();
    if (pdc == NULL) {
        return;
    }

    
    //
    // Affects Desired Size or Affects Layout (or either on Parent)
    //

    BOOL fAffDS    = fGroups & DirectUI::PropertyInfo::gAffectsDesiredSize;
    BOOL fAffLt    = fGroups & DirectUI::PropertyInfo::gAffectsLayout;
    BOOL fAffParDS = fGroups & DirectUI::PropertyInfo::gAffectsParentDesiredSize;
    BOOL fAffParLt = fGroups & DirectUI::PropertyInfo::gAffectsParentLayout;

    if (fAffDS || fAffLt || fAffParDS || fAffParLt) {

        //
        // Locate Layout/DS root and queue tree as needing a layout/UDS pass
        // Root doesn't have parent or is absolute positioned
        //


        //
        // Staring condition depends on AffDS flags. Since AffDS bits are set
        // on all ancestors, if AffDS is set, the starting Element for the
        // climb can be this. As ancesors are discovered, they'll be marked
        // as needing DS update. So, if AffParDS is set, it'll automatically
        // be set as needing DS update. If no AffDS flag is set, start
        // at this (simply walk tree for Layout root).
        //

        
        DuiElement * peRoot = this;
        DuiElement * peClimb = this;  // Start condition
        if (fAffParDS) {
            peClimb = GetParent();    // Override start to be parent
        } else if (fAffDS) {
            peClimb = this;           // Override start to be this
        }

        int nLayoutPos;


        while (peClimb != NULL) {

            //
            // Queue DS
            //

            if (fAffDS || fAffParDS) {
                peClimb->m_fBit.fNeedsDSUpdate = TRUE;
            }


            //
            // Stop if absolutely positioned
            //

            nLayoutPos = peClimb->GetLayoutPos();
            if (nLayoutPos == DirectUI::Layout::lpAbsolute) {
                break;
            }

            
            //
            // Climb
            //

            peRoot = peClimb;
            peClimb = peClimb->GetParent();
        }


        ASSERT_(peRoot != NULL, "Root not located for layout/update desired size bit set");
        

        //
        // Queue layout
        //

        if (fAffLt) {
            m_fBit.fNeedsLayout = DirectUI::Layout::lcNormal;
        }

        if (fAffParLt && (GetParent() != NULL)) {
            GetParent()->m_fBit.fNeedsLayout = DirectUI::Layout::lcNormal;
        }


        //
        // Queue root
        //

        if (fAffDS || fAffParDS) {
            pdc->pvmUpdateDSRoot->SetItem(peRoot, 1, TRUE);
        }

        if (fAffLt || fAffParLt) {
            pdc->pvmLayoutRoot->SetItem(peRoot, 1, TRUE);
        }
    }


    //
    // Affects display
    //

    if (fGroups & DirectUI::PropertyInfo::gAffectsDisplay) {
        InvalidateGadget(GetDisplayNode());
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuiDeferCycle
*
* Per-context defer table
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT 
DuiDeferCycle::Build(
    OUT DuiDeferCycle ** ppDC)
{
    *ppDC = NULL;

    DuiDeferCycle * pdc = new DuiDeferCycle;
    if (pdc == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pdc->Create();
    if (FAILED(hr)) {
        delete pdc;
        return hr;
    }

    *ppDC = pdc;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT 
DuiDeferCycle::Create()
{
    //
    // Defer cycle state
    //

    cReEnter          = 0;
    cPCEnter          = 0;

    iGCPtr            = -1;
    iPCPtr            = -1;
    iPCSSUpdate       = 0;

    fActive           = FALSE;
    fFiring           = FALSE;

    //
    // Defer cycle tables
    //

    pvmUpdateDSRoot   = NULL;
    pvmLayoutRoot     = NULL;
    pdaPC             = NULL;
    pdaGC             = NULL;

    HRESULT hr;

    hr = DuiValueMap<DuiElement *,BYTE>::Create(11, &pvmUpdateDSRoot);      // Update desired size trees pending
    if (FAILED(hr)) {
        goto Failure;
    }

    hr = DuiValueMap<DuiElement *,BYTE>::Create(11, &pvmLayoutRoot);        // Layout trees pending
    if (FAILED(hr)) {
        goto Failure;
    }

    hr = DuiDynamicArray<PCRecord>::Create(32, FALSE, &pdaPC);              // Property changed database
    if (FAILED(hr)) {
        goto Failure;
    }

    hr = DuiDynamicArray<GCRecord>::Create(32, FALSE, &pdaGC);              // Group changed database
    if (FAILED(hr)) {
        goto Failure;
    }


    return S_OK;

Failure:

    if (pvmUpdateDSRoot != NULL) {
        delete pvmUpdateDSRoot;
        pvmUpdateDSRoot = NULL;
    }
    if (pvmLayoutRoot != NULL) {
        delete pvmLayoutRoot;
        pvmLayoutRoot = NULL;
    }
    if (pdaPC != NULL) {
        delete pdaPC;
        pdaPC = NULL;
    }
    if (pdaGC != NULL) {
        delete pdaGC;
        pdaGC = NULL;
    }


    return hr;
}

DuiDeferCycle::~DuiDeferCycle()
{
    if (pdaGC != NULL) {
        delete pdaGC;
    }
    if (pdaPC != NULL) {
        delete pdaPC;
    }
    if (pvmLayoutRoot != NULL) {
        delete pvmLayoutRoot;
    }
    if (pvmUpdateDSRoot != NULL) {
        delete pvmUpdateDSRoot;
    }
}

void 
DuiDeferCycle::Reset()
{
    //
    // Return to initial state for reuse
    //

    fActive = FALSE;
    fFiring = FALSE;


    iGCPtr = -1;
    if (pdaGC) {
        pdaGC->Reset();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\render.cpp ===
/***************************************************************************\
*
* File: Render.cpp
*
* Description:
* Rendering
*
* History:
*  9/29/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Element.h"

#include "Value.h"
#include "Register.h"


//------------------------------------------------------------------------------
void 
DuiElement::Paint(
    IN  HDC hDC, 
    IN  const RECT * prcBounds, 
    IN  const RECT * prcInvalid, 
    OUT RECT * prcSkipBorder, 
    OUT RECT * prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcInvalid);
    UNREFERENCED_PARAMETER(prcSkipBorder);
    UNREFERENCED_PARAMETER(prcSkipContent);

    
    DuiValue * pv = GetValue(GlobalPI::ppiElementBackground, DirectUI::PropertyInfo::iSpecified);

    RECT rc = *prcBounds;

    if (pv->GetType() == DirectUI::Value::tInt) {
        FillRect(hDC, &rc, GetStdColorBrushI(SC_Black));
        InflateRect(&rc, -4, -4);
        if (rc.right < rc.left) {
            rc.right = rc.left;
        }
        if (rc.bottom < rc.top) {
            rc.bottom = rc.top;
        }
        FillRect(hDC, &rc, GetStdColorBrushI(pv->GetInt()));
    }

    pv->Release();
}


//------------------------------------------------------------------------------
SIZE
DuiElement::GetContentSize(
    IN  int cxConstraint,
    IN  int cyConstraint, 
    IN  HDC hDC)
{
    
    UNREFERENCED_PARAMETER(hDC);

    SIZE size = { cxConstraint, cyConstraint };

    //
    // Added by dwaynen to test some stuff.
    //
    if (size.cx > 50) {
        size.cx /= 2;
    }

    if (size.cy > 50) {
        size.cy /= 2;
    }

    return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\register.inl ===
/***************************************************************************\
*
* File: Register.inl
*
* Description:
* Register specific inline functions
*
* History:
*  10/23/2000: MarkFi:      Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


//------------------------------------------------------------------------------
inline BOOL
DuiRegister::IsPropertyMUID(
    IN  DirectUI::MUID muid)
{
    return (muid & ModifierTypeMask) == PropertyType;
}


//------------------------------------------------------------------------------
inline BOOL
DuiRegister::IsElementMUID(
    IN  DirectUI::MUID muid)
{
    return (muid & ClassTypeMask) == ElementType;
}


//------------------------------------------------------------------------------
inline UINT
DuiRegister::ExtractNamespaceIdx(
    IN  DirectUI::PUID puid)
{
    return (NamespaceIdxMask & puid) >> 24;
}


//------------------------------------------------------------------------------
inline UINT
DuiRegister::ExtractClassIdx(
    IN  DirectUI::PUID puid)
{
    return (ClassIdxMask & puid) >> 12;
}


//------------------------------------------------------------------------------
inline UINT
DuiRegister::ExtractModifierIdx(
    IN  DirectUI::PUID puid)
{
    return (ModifierIdxMask & puid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\root.h ===
/***************************************************************************\
*
* File: Root.h
*
* Description:
* Root Elements
*
* History:
*  9/26/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Root_h__INCLUDED)
#define DUICORE__Root_h__INCLUDED
#pragma once


#include "Element.h"


/***************************************************************************\
*
* class DuiHWNDRoot (external respresentation is 'HWNDRoot')
*
\***************************************************************************/

class DuiHWNDRoot :
        public DirectUI::HWNDRootImpl<DuiHWNDRoot, DuiElement>
{
// Construction
public:
            DuiHWNDRoot() { }

// API Layer
public:
    dapi    LRESULT     ApiWndProc(IN HWND hWnd, IN UINT nMsg, IN WPARAM wParam, IN LPARAM lParam);

// Operations
public:
    static inline 
            DirectUI::HWNDRoot *
                        ExternalCast(IN DuiHWNDRoot * per);
    static inline 
            DuiHWNDRoot *
                        InternalCast(IN DirectUI::HWNDRoot * per);

// Callbacks
public:
    virtual void        OnPropertyChanged(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiValue * pvOld, IN DuiValue * pvNew);

// Implementation
public:
    virtual void        AsyncDestroy();
            HRESULT     PostBuild(IN DUser::Gadget::ConstructInfo * pciData);
    static  LRESULT CALLBACK 
                        StaticWndProc(IN HWND hWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam);    
            LRESULT     WndProc(IN HWND hWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam);

// Data
private:
            HWND        m_hWnd;
};


#include "Root.inl"


#endif // DUICORE__Root_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\register.h ===
/***************************************************************************\
*
* File: Register.h
*
* Description:
* Registering Classes, Properties, and Events
*
* History:
*  10/19/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Register_h__INCLUDED)
#define DUICORE__Register_h__INCLUDED
#pragma once


//
// Forward declarations
//

class DuiValue;


/***************************************************************************\
*
* Internal registration structures
*
\***************************************************************************/

struct DuiPropertyInfo
{
    DirectUI::PropertyMUID
                pmuid;

    WCHAR       szName[101];
    UINT        nFlags;
    UINT        nGroups;
    int *       pValidValues;
    void *      pEnumMaps;  /* EnumMap * */
    DuiValue *  pvDefault;

    UINT        iGlobal;
};


struct DuiElementInfo
{
    DirectUI::ElementMUID
                emuid;

    WCHAR       szName[101];
    DuiPropertyInfo **
                pppi;
    UINT        cpi;
};


struct DuiEventInfo
{
    WCHAR       szName[101];
};


struct DuiNamespaceInfo
{
    WCHAR       szName[101];
    DuiElementInfo **
                ppei;
    UINT        cei;
};


/***************************************************************************\
*
* class DuiRegister
*
\***************************************************************************/

class DuiRegister
{
// Operations
public:
    static  HRESULT     Initialize(IN  DuiNamespaceInfo * pniDirectUI);
    static  void        Destroy();

    static  DuiPropertyInfo *
                        PropertyInfoFromPUID(IN DirectUI::PropertyPUID ppuid);

    static  void        VerifyNamespace(IN DirectUI::NamespacePUID npuid);


    static inline BOOL  IsPropertyMUID(IN DirectUI::MUID muid);
    static inline BOOL  IsElementMUID(IN DirectUI::MUID muid);
    
    static inline UINT  ExtractNamespaceIdx(IN DirectUI::PUID puid);
    static inline UINT  ExtractClassIdx(IN DirectUI::MUID muid);
    static inline UINT  ExtractModifierIdx(IN DirectUI::MUID muid);                     


    //
    // Modifier types (PMEs)
    //

    static const UINT   PropertyType        = 0x00000000;
    static const UINT   MethodType          = 0x00000200;
    static const UINT   EventType           = 0x00000400;

    static const UINT   ModifierTypeMask    = 0x00000E00;
    static const UINT   ModifierIdxMask     = 0x000001FF;


    //
    // Class types
    //

    static const UINT   ElementType         = 0x00000000;
    static const UINT   LayoutType          = 0x00200000;
    
    static const UINT   ClassTypeMask       = 0x00E00000;
    static const UINT   ClassIdxMask        = 0x001FF000;


    //
    // Namespaces
    //

    static const UINT   NamespaceIdxMask    = 0xFF000000;


// Data
private:
    static  DuiDynamicArray<DuiNamespaceInfo *> *
                        m_pdaNamespaces;
};


/***************************************************************************\
*
* Known global property indicies for compile-time internal identification.
* Direct access property info pointers for internal property access.
*
\***************************************************************************/

struct GlobalPI
{
    enum EIndex
    {
        iElementParent          = 0,
        iElementBounds          = 1,
        iElementLayout          = 2,
        iElementLayoutPos       = 3,
        iElementDesiredSize     = 4,
        iElementActive          = 5,
        iElementKeyFocused      = 6,
        iElementMouseFocused    = 7,
        iElementKeyWithin       = 8,
        iElementMouseWithin     = 9,
        iElementBackground      = 10,

        iUnavailable            = 0xFFFFFFFF
    };


    static DuiPropertyInfo *    ppiElementParent;
    static DuiPropertyInfo *    ppiElementBounds;
    static DuiPropertyInfo *    ppiElementLayout;
    static DuiPropertyInfo *    ppiElementLayoutPos;
    static DuiPropertyInfo *    ppiElementDesiredSize;
    static DuiPropertyInfo *    ppiElementActive;
    static DuiPropertyInfo *    ppiElementKeyFocused;
    static DuiPropertyInfo *    ppiElementMouseFocused;
    static DuiPropertyInfo *    ppiElementKeyWithin;
    static DuiPropertyInfo *    ppiElementMouseWithin;
    static DuiPropertyInfo *    ppiElementBackground;
};


#include "Register.inl"


#endif // DUICORE__Register_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\root.cpp ===
/***************************************************************************\
*
* File: Root.cpp
*
* Description:
* Root Elements
*
* History:
*  9/26/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Root.h"

#include "Value.h"
#include "Register.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiHWNDRoot (external representation is 'HWNDRoot')
*
*****************************************************************************
\***************************************************************************/


//
// Definition
//

IMPLEMENT_GUTS_DirectUI__HWNDRoot(DuiHWNDRoot, DuiElement)


//------------------------------------------------------------------------------
HRESULT
DuiHWNDRoot::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pciData)
{
    HRESULT hr;

    m_hWnd = NULL;
    HGADGET hgDN = NULL;
    DuiValue * pv = NULL;
    DirectUI::HWNDRoot::ConstructInfo * phrci = static_cast<DirectUI::HWNDRoot::ConstructInfo *> (pciData);


    //
    // Validation layer required here
    //

    ASSERT_(phrci != NULL, "HWNDRoot::ConstructInfo expected");

    if ((phrci == NULL) || (phrci->hParent == NULL)) {
        hr = E_INVALIDARG;
        goto Failure;
    }


    //
    // Register host window class (if isn't already registered)
    //

    WNDCLASSEXW wc;

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"DirectUIHWNDRoot", &wc)) {

        ZeroMemory(&wc, sizeof(wc));

        wc.cbSize        = sizeof(wc);
        wc.hInstance     = GetModuleHandleW(NULL);
        wc.hCursor       = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        wc.lpszClassName = L"DirectUIHWNDRoot";
        wc.lpfnWndProc   = DuiHWNDRoot::StaticWndProc;
        wc.cbWndExtra    = 4;

        if (RegisterClassExW(&wc) == 0) {
            hr = DUI_E_USERFAILURE;
            goto Failure;
        }
    }


    //
    // Create HWND container
    //

    m_hWnd = CreateWindowExW(0, L"DirectUIHWNDRoot", NULL, WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
            0, 0, 0, 0, phrci->hParent, 0, GetModuleHandleW(NULL), 0);
    
    if (m_hWnd == NULL) {
        hr = DUI_E_USERFAILURE;
        goto Failure;
    }


    //
    // Store pointer to the Element in HWND
    //

    SetWindowLongPtrW(m_hWnd, 0, (LONG_PTR)this);


    //
    // Create custom display node
    //

    hgDN = CreateGadget(m_hWnd, GC_HWNDHOST, DisplayNodeCallback, this);
    if (hgDN != NULL) {

        SetGadgetMessageFilter(hgDN, NULL, 
                GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | GMFI_PAINT | GMFI_CHANGESTATE, 
                GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | GMFI_PAINT | GMFI_CHANGESTATE | GMFI_INPUTKEYBOARD | GMFI_CHANGERECT | GMFI_CHANGESTYLE);
        SetGadgetStyle(hgDN, GS_RELATIVE | GS_OPAQUE | ((phrci->fDblBuffer) ? GS_BUFFERED : 0), GS_RELATIVE | GS_HREDRAW | GS_VREDRAW | GS_VISIBLE | GS_KEYBOARDFOCUS | GS_OPAQUE | GS_BUFFERED);

        /**** TEMP ****/
        SetGadgetStyle(hgDN, GS_VISIBLE | GS_HREDRAW | GS_VREDRAW, GS_VISIBLE | GS_HREDRAW | GS_VREDRAW);
    }

    if (hgDN == NULL) {
        hr = GetLastError();
        goto Failure;
    }


    //
    // Call base, no create of display node
    //

    phrci->pReserved0 = reinterpret_cast<void *> (-1);

    hr = DuiElement::PostBuild(pciData);
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Display node available
    //

    m_hgDisplayNode = hgDN;


    //
    // Initialize root-specific state
    //

    //
    // Roots always have mouse focus, update cache to reflect
    //

    m_fBit.nLocActive = DirectUI::Element::aeMouse;


    return S_OK;


Failure:

    if (m_hWnd != NULL) {
        DestroyWindow(m_hWnd);
        m_hWnd = NULL;
    }

    if (hgDN != NULL) {
        DeleteHandle(hgDN);
        hgDN = NULL;
        m_hgDisplayNode = NULL;
    }

    if (pv != NULL) {
        pv->Release();
        pv = NULL;
    }
    

    return hr;
}


/***************************************************************************\
*
* DuiHWNDRoot::AsyncDestroy
*
* Destruction process for HWNDRoots always starts with the owned HWND.
* DestroyWindow will be called on it, which will cause a DeleteHandle
* on the display node. This will, in turn, cause the Element to be destroyed.
* The DestroyWindow may initiate externally. The DestroyWindow must
* happen outside a defer cycle. If it's happening as a result of a close
* and the default window proc is being used, this is safe since the
* message pump is outside a defer cycle.
*
\***************************************************************************/

void
DuiHWNDRoot::AsyncDestroy()
{
    DestroyWindow(m_hWnd);
}


//------------------------------------------------------------------------------
void
DuiHWNDRoot::OnPropertyChanged(
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiValue * pvOld, 
    IN  DuiValue * pvNew)
{
    DuiElement::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);


    if (iIndex == DirectUI::PropertyInfo::iActual) {

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementBounds:
            //
            // Match HWND to bounds changes in root
            //

            if (m_hWnd != NULL) {
                const DirectUI::Rectangle * pr = pvNew->GetRectangle();

                SetWindowPos(m_hWnd, NULL, pr->x, pr->y, pr->width, pr->height, SWP_NOACTIVATE);
            }            

            break;
        }
    }
}


//------------------------------------------------------------------------------
LRESULT
DuiHWNDRoot::WndProc(
    IN  HWND hWnd, 
    IN  UINT nMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam)
{
    switch (nMsg)
    {
    case WM_DESTROY:
        //
        // Detach HWNDRoot Element
        //

        SetWindowLongPtrW(hWnd, 0, NULL);
        break;
    }

    return CallWindowProcW(DefWindowProcW, hWnd, nMsg, wParam, lParam);
}


//------------------------------------------------------------------------------
LRESULT CALLBACK 
DuiHWNDRoot::StaticWndProc(
    IN  HWND hWnd, 
    IN  UINT uMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam)
{
    //
    // Get context
    //

    DuiHWNDRoot * phr = reinterpret_cast<DuiHWNDRoot *> (GetWindowLongPtrW(hWnd, 0));
    if (phr == NULL) {
        return CallWindowProcW(DefWindowProcW, hWnd, uMsg, wParam, lParam);
    }

    
    //
    // Call out (virtual)
    //

    //return DuiHWNDRoot::ExternalCast(phr)->WndProc(hWnd, uMsg, wParam, lParam);
    return phr->WndProc(hWnd, uMsg, wParam, lParam);
}


/***************************************************************************\
*
* External API implementation (validation layer)
*
\***************************************************************************/

//------------------------------------------------------------------------------
LRESULT
DuiHWNDRoot::ApiWndProc(
    IN  HWND hWnd, 
    IN  UINT nMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam)
{
    return WndProc(hWnd, nMsg, wParam, lParam); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__StdAfx_h__INCLUDED)
#define DUICORE__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUICORE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\thread.cpp ===
/***************************************************************************\
*
* File: Thread.cpp
*
* Description:
* Thread and context-specific functionality
*
* History:
*  9/15/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Thread.h"

#include "Property.h"
#include "Value.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiThread
*
* Static thread/context methods and data
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*
* DuiThread::CoreCtxStore::AllocLeak
*
* Value leak detection callback
*
\***************************************************************************/

void 
DuiThread::CoreCtxStore::AllocLeak(
    IN  void * pBlock)
{
    DuiValue * pv = (DuiValue *) pBlock;

    WCHAR sz[2048];
    TRACE(">> DUIValue Leak! Type: %S, Value: %S, Refs: %d\n", DuiValue::GetTypeName(pv->GetType()), pv->ToString(sz, sizeof(sz) / sizeof(WCHAR)), pv->GetRefCount());
}


/***************************************************************************\
*
* DuiThread::Init
*
* Initialize thread. Store ref-counted context information on thread.
* Only one thread per context supported
*
\***************************************************************************/

HRESULT
DuiThread::Init()
{
    HRESULT hr;

    CoreCtxStore * pCCS = NULL;


    //
    // Ensure no context store is present on thread
    //

    if ((pCCS = GetCCStore()) != NULL) {

        //
        // Thread already part of a context, adjust refcount
        //

        pCCS->cRef++;

        
        return S_OK;
    }


    //
    // Setup context storage
    //

    pCCS = new CoreCtxStore;
    if (pCCS == NULL) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }


    pCCS->hCtx = NULL;
    pCCS->pSBA = NULL;
    pCCS->pDC  = NULL;
    pCCS->cRef = 1;


    //
    // Store context info in thread storage
    //

    TlsSetValue(DuiProcess::s_dwCoreSlot, pCCS);


    //
    // Create small block allocator
    //

    pCCS->pSBA = new DuiSBAlloc(sizeof(DuiValue), 48, pCCS);
    if (pCCS->pSBA == NULL) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }


    //
    // Create defer cycle table
    //
    hr = DuiDeferCycle::Build(&pCCS->pDC);
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Initialize DirectUser Context
    //

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_SEPARATE;        // Allow only 1 thread per context (this one)
    ig.nMsgMode     = IGMM_ADVANCED;
    pCCS->hCtx = InitGadgets(&ig);
    if (pCCS->hCtx == NULL) {
        hr = GetLastError();
        goto Failure;
    }


    TRACE("Thread startup <%x>\n", GetCurrentThread());


    return S_OK;


Failure:

    //
    // Failed to fully initialize thread, back out
    //

    if (pCCS != NULL) {

        if (pCCS->hCtx != NULL) {
            DeleteHandle(pCCS->hCtx);
        }

        if (pCCS->pDC != NULL) {
            delete pCCS->pDC;
        }

        if (pCCS->pSBA != NULL) {
            delete pCCS->pSBA;
        }

        TlsSetValue(DuiProcess::s_dwCoreSlot, NULL);


        delete pCCS;
    }


    return hr;
}


/***************************************************************************\
*
* DuiThread::UnInit
*
* UnInitialize thread. Free context information since only allow single
* thread per context
*
\***************************************************************************/

HRESULT
DuiThread::UnInit()
{
    //
    // Get store information, if available, all contents are valid
    //

    CoreCtxStore * pCCS = GetCCStore();
    if (pCCS == NULL) {
        return DUI_E_NOCONTEXTSTORE;
    }


    //
    // If initialize function called multiple times, return
    //

    if (pCCS->cRef > 1) {
        pCCS->cRef--;

        return S_OK;
    }


    //
    // Delete DirectUser Context
    //

    DeleteHandle(pCCS->hCtx);

    
    //
    // Free defer cycle table
    //

    delete pCCS->pDC;


    //
    // Free small block allocator
    //

    delete pCCS->pSBA;


    //
    // Clear out thread slot
    //

    TlsSetValue(DuiProcess::s_dwCoreSlot, NULL);


    delete pCCS;


    TRACE("Thread shutdown <%x>\n", GetCurrentThread());


    return S_OK;
}


/***************************************************************************\
*
* DuiThread::PumpMessages
*
\***************************************************************************/

void
DuiThread::PumpMessages()
{
    MSG msg;
    BOOL fProcess = TRUE;

    while (fProcess && (GetMessageExW(&msg, 0, 0, 0) != 0)) {

        if (msg.message == WM_QUIT) {
            fProcess = FALSE;
        }

        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\thread.h ===
/***************************************************************************\
*
* File: Thread.h
*
* Description:
* Thread and context-specific functionality
*
* History:
*  9/15/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUICORE__Thread_h__INCLUDED)
#define DUICORE__Thread_h__INCLUDED
#pragma once


/***************************************************************************\
*
* class DuiThread
*
* Static thread/context methods and data
*
\***************************************************************************/


//
// Required includes (forward declarations)
//

#include "Process.h"


//
// Forward declarations
//

class DuiDeferCycle;


class DuiThread
{
// Structures
public:
    //
    // Per-context DirectUI specific core storage. Ref counted. Pointer stored
    // on every thread
    //

    class CoreCtxStore : public DuiSBAlloc::ISBLeak
    {
    // Operations
    public:
                void    AllocLeak(IN void * pBlock);

    // Data
    public:
        UINT            cRef;       // Reference count
        HCONTEXT        hCtx;       // DirectUser context handle
        DuiSBAlloc *    pSBA;       // Small block allocator
        DuiDeferCycle * pDC;        // Defer cycle table
    };

// Operations
public:

    static  HRESULT     Init();
    static  HRESULT     UnInit();

    static  void        PumpMessages();

    static inline CoreCtxStore *
                        GetCCStore();
    static inline DuiDeferCycle *
                        GetCCDC();
};


#include "Thread.inl"


#endif // DUICORE__Thread_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\root.inl ===
/***************************************************************************\
*
* File: Root.inl
*
* Description:
* Root Element specific inline functions
*
* History:
*  9/26/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


//------------------------------------------------------------------------------
inline DirectUI::HWNDRoot *
DuiHWNDRoot::ExternalCast(
    IN  DuiHWNDRoot * per)
{ 
    return per->GetStub();
}


//------------------------------------------------------------------------------
inline DuiHWNDRoot *
DuiHWNDRoot::InternalCast(
    IN  DirectUI::HWNDRoot * per)    
{ 
    return reinterpret_cast<DuiHWNDRoot *> (DUserGetGutsData(per, DuiHWNDRoot::s_mc.hclNew));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\value.cpp ===
/***************************************************************************\
*
* File: Value.cpp
*
* Description:
* Value object that is used by properties
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Value.h"

#include "Thread.h"
#include "Layout.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiValue
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*
* DuiValue::Build<type>
*
* Type-safe DuiValue builder methods.
*
\***************************************************************************/

//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildInt(
    IN  int v)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType  = DirectUI::Value::tInt;
    pv->m_intVal = v;
    pv->m_cRef   = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildBool(
    IN  BOOL v)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType   = DirectUI::Value::tBool;
    pv->m_boolVal = v;
    pv->m_cRef    = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildElementRef(
    IN  DuiElement * v)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType = DirectUI::Value::tElementRef;
    pv->m_peVal = v;
    pv->m_cRef  = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildLayout(
    IN  DuiLayout * v)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType = DirectUI::Value::tLayout;
    pv->m_plVal = v;
    pv->m_cRef  = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildRectangle(
    IN  int x,
    IN  int y,
    IN  int width,
    IN  int height)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType          = DirectUI::Value::tRectangle;
    pv->m_rectVal.x      = x;
    pv->m_rectVal.y      = y;
    pv->m_rectVal.width  = width;
    pv->m_rectVal.height = height;
    pv->m_cRef           = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildThickness(
    IN  int left,
    IN  int top,
    IN  int right,
    IN  int bottom)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType           = DirectUI::Value::tThickness;
    pv->m_thickVal.left   = left;
    pv->m_thickVal.top    = top;
    pv->m_thickVal.right  = right;
    pv->m_thickVal.bottom = bottom;
    pv->m_cRef            = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildSize(
    IN  int cx,
    IN  int cy)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType          = DirectUI::Value::tSize;
    pv->m_sizeVal.cx     = cx;
    pv->m_sizeVal.cy     = cy;
    pv->m_cRef           = 1;


    return pv;
}


//------------------------------------------------------------------------------
DuiValue *
DuiValue::BuildRectangleSD(
    IN  UINT nUnsetMask,
    IN  int x,
    IN  int y,
    IN  int width,
    IN  int height)
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return NULL;
    }

    DuiValue * pv = (DuiValue *) pCCS->pSBA->Alloc();
    if (pv == NULL) {
        return NULL;
    }


    pv->m_nType                = DirectUI::Value::tRectangleSD;
    pv->m_rectSDVal.nUnsetMask = nUnsetMask;
    pv->m_rectSDVal.x          = x;
    pv->m_rectSDVal.y          = y;
    pv->m_rectSDVal.width      = width;
    pv->m_rectSDVal.height     = height;
    pv->m_cRef                 = 1;


    return pv;
}


/***************************************************************************\
*
* DuiValue::Build
*
* Generic single entry point DuiValue builder. Accepts a void pointer.
* Pointer will be reinterpreted as needed for the specific type being
* built. Once casted, the appropriate Build<type> method will be called.
*
\***************************************************************************/

DuiValue *
DuiValue::Build(
    IN  int nType,
    IN  void * v)
{
    switch (nType)
    {
    case DirectUI::Value::tInt:
        return DuiValue::BuildInt(PtrToInt(v));

    case DirectUI::Value::tBool:
        return DuiValue::BuildBool((BOOL)PtrToInt(v));

    case DirectUI::Value::tElementRef:
        return DuiValue::BuildElementRef(reinterpret_cast<DuiElement *> (v));

    case DirectUI::Value::tLayout:
        return DuiValue::BuildLayout(reinterpret_cast<DuiLayout *> (v));

    case DirectUI::Value::tRectangle:
        {
            DirectUI::Rectangle * pr = reinterpret_cast<DirectUI::Rectangle *> (v);
            return DuiValue::BuildRectangle(pr->x, pr->y, pr->width, pr->height);
        }

    case DirectUI::Value::tThickness:
        {
            DirectUI::Thickness * pt = reinterpret_cast<DirectUI::Thickness *> (v);
            return DuiValue::BuildThickness(pt->left, pt->top, pt->right, pt->bottom);
        }

    case DirectUI::Value::tSize:
        {
            SIZE * ps = reinterpret_cast<SIZE *> (v);
            return DuiValue::BuildSize(ps->cx, ps->cy);
        }

    case DirectUI::Value::tRectangleSD:
        {
            DirectUI::RectangleSD * prsd = reinterpret_cast<DirectUI::RectangleSD *> (v);
            return DuiValue::BuildRectangleSD(prsd->nUnsetMask ,prsd->x, prsd->y, prsd->width, prsd->height);
        }

    default:
        ASSERT("Invalid type");
        return NULL;
    }
}


/***************************************************************************\
*
* DuiValue::Merge()
*
* Source replaces Unset destination
*
* Merge sub-divided Value into this, return a new Value. Any sub-value
* that is valid in this is never overridden. Hence, this object's
* subvalues are higher priority. Source and destination must have
* matching sub-divided types.
*
* For non-sub-divided Values, merge consists of whether or not the
* destination is Unset. If it is, the merged Value is the source.
* At least one Value type must be Unset.
*
* Merge will automatically Release this value and AddRef the new
* merged value before returning.
*
\***************************************************************************/

DuiValue *
DuiValue::Merge(
    IN  DuiValue * pv,
    IN  DuiThread::CoreCtxStore * pCCS)
{
    DuiValue * pvM = NULL;  // Resulting merged Value


    //
    // If this is Unset, always merge (replace). If the source is Unset,
    // only use this.
    //

    if (GetType() == DirectUI::Value::tUnset) {
        //
        // U <- U == U
        // U <- N == N
        //
        // Destination is Unset, return source (even if it's Unset)
        //

        pv->AddRef();
        pvM = pv;
    } else if (pv->GetType() == DirectUI::Value::tUnset) {
        //
        // N <- U == N
        //
        // Destination is not Unset, source is Unset so return dest
        //

        AddRef();
        pvM = this;
    }
    

    if (pvM == NULL) {
        //
        // Na <- Nb == Na    For non-subdivided Values
        // Na <- Nb == Nm    For subdivided Values (merged, types must match)
        //
        // Both Values are not Unset, return this (dest) if non-subdivided since this 
        // has higher priority. Otherwise, return subdivided merge. The Unset Value
        // is not considered subdivided.
        //

        if (!IsSubDivided()) {
            AddRef();
            pvM = this;
        } else {
            ASSERT_(pv->IsSubDivided() && (GetType() == pv->GetType()), "Value merge mismatch, expecting subdivided Values with matching types");

            //
            // Dealing with subdivided Values, merge based on unset sub-values
            //

            if (m_sdHeader.nUnsetMask == 0) {
                //
                // Value complete
                //

                AddRef();
                pvM = this;
            } else {
                // 
                // Do merge
                //

                pvM = (DuiValue *) pCCS->pSBA->Alloc();
                if (pvM == NULL) {
                    return NULL;
                }

                pvM->m_nType = GetType();
                pvM->m_cRef  = 1;

   
                //
                // Copy data
                //

                CopyMemory(&pvM->m_buf, &m_buf, sizeof(m_buf));


                //
                // Merge, scan fields based on type
                //

                #define MergeSubValue(dest, src, data, subdata, unbit) \
                        if ((dest->data.nUnsetMask & unbit) && (!(src->data.nUnsetMask & unbit))) { \
                            dest->data.subdata = src->data.subdata; \
                            dest->data.nUnsetMask &= ~unbit; \
                        }

                switch (GetType())
                {
                case DirectUI::Value::tRectangleSD:
                    MergeSubValue(pvM, pv, m_rectSDVal, x,      DirectUI::RectangleSD::unX);
                    MergeSubValue(pvM, pv, m_rectSDVal, y,      DirectUI::RectangleSD::unY);
                    MergeSubValue(pvM, pv, m_rectSDVal, width,  DirectUI::RectangleSD::unWidth);
                    MergeSubValue(pvM, pv, m_rectSDVal, height, DirectUI::RectangleSD::unHeight);
                    break;
                }
            }
        }
    }


    //
    // Auto-Release this
    //

    Release();


    return pvM;
}


/***************************************************************************\
*
* DuiValue::GetData
*
* Generic single entry point DuiValue content retrieval. Value data is
* cast to void pointer.
*
\***************************************************************************/

void *
DuiValue::GetData(
    IN  int nType)
{
    switch (nType)
    {
    case DirectUI::Value::tInt:
        return IntToPtr(GetInt());

    case DirectUI::Value::tBool:
        return IntToPtr(GetBool());

    case DirectUI::Value::tElementRef:
        return reinterpret_cast<void *> (GetElement());

    case DirectUI::Value::tLayout:
        return reinterpret_cast<void *> (GetLayout());

    case DirectUI::Value::tRectangle:
        return reinterpret_cast <void *> (const_cast<DirectUI::Rectangle *> (GetRectangle()));

    case DirectUI::Value::tThickness:
        return reinterpret_cast <void *> (const_cast<DirectUI::Thickness *> (GetThickness()));

    case DirectUI::Value::tSize:
        return reinterpret_cast <void *> (const_cast<SIZE *> (GetSize()));

    case DirectUI::Value::tRectangleSD:
        return reinterpret_cast <void *> (const_cast<DirectUI::RectangleSD *> (GetRectangleSD()));

    default:
        ASSERT("Invalid type");
        return NULL;
    }
}


/***************************************************************************\
*
* DuiValue::ZeroRelease
*
* Zero ref count. Destroy any externally referenced data to Value along
* with the value itself.
*
\***************************************************************************/

void
DuiValue::ZeroRelease()
{
    DuiThread::CoreCtxStore * pCCS = DuiThread::GetCCStore();
    if (pCCS == NULL) {
        return;
    }


    switch (m_nType)
    {
    case DirectUI::Value::tLayout:
        if (m_plVal != NULL) {
            m_plVal->GetStub()->Delete();
        }
        break;
    }


    pCCS->pSBA->Free(this);
}


/***************************************************************************\
*
* DuiValue::IsEqual
*
* Compare DuiValue to passed in DuiValue for content equality.
*
\***************************************************************************/

BOOL
DuiValue::IsEqual(
    IN  DuiValue * pv)
{
    if (this == pv)
        return TRUE;

    if (m_nType == pv->m_nType) {

        switch (m_nType)
        {
        case DirectUI::Value::tUnset:
            return TRUE;

        case DirectUI::Value::tInt:
            return m_intVal == pv->m_intVal;

        case DirectUI::Value::tBool:
            return m_boolVal == pv->m_boolVal;

        case DirectUI::Value::tElementRef:
            return m_peVal == pv->m_peVal;

        case DirectUI::Value::tLayout:
            return m_plVal == pv->m_plVal;

        case DirectUI::Value::tRectangle:
            return (m_rectVal.x == pv->m_rectVal.x) && (m_rectVal.y == pv->m_rectVal.y) && 
                   (m_rectVal.width == pv->m_rectVal.width) && (m_rectVal.height == pv->m_rectVal.height);

        case DirectUI::Value::tThickness:
            return (m_thickVal.left == pv->m_thickVal.left) && (m_thickVal.top == pv->m_thickVal.top) && 
                   (m_thickVal.right == pv->m_thickVal.right) && (m_thickVal.bottom == pv->m_thickVal.bottom);

        case DirectUI::Value::tSize:
            return (m_sizeVal.cx == pv->m_sizeVal.cx) && (m_sizeVal.cy == pv->m_sizeVal.cy);

        case DirectUI::Value::tRectangleSD:
            return (m_rectSDVal.nUnsetMask == pv->m_rectSDVal.nUnsetMask) &&
                   (m_rectSDVal.x == pv->m_rectSDVal.x) && (m_rectSDVal.y == pv->m_rectSDVal.y) && 
                   (m_rectSDVal.width == pv->m_rectSDVal.width) && (m_rectSDVal.height == pv->m_rectSDVal.height);
        }
    }


    return FALSE;
}


/***************************************************************************\
*
* DuiValue::ToString
*
* Create string representation of content of DuiValue
*
\***************************************************************************/

LPWSTR
DuiValue::ToString(
    IN  LPWSTR psz,
    IN  UINT c)
{
    switch (m_nType)
    {
    case DirectUI::Value::tUnset:
        wcsncpy(psz, L"Unset", c);
        break;

    case DirectUI::Value::tInt:
        _snwprintf(psz, c, L"%d", m_intVal);
        break;

    case DirectUI::Value::tBool:
        _snwprintf(psz, c, L"%s", (m_boolVal) ? L"True" : L"False");
        break;

    case DirectUI::Value::tElementRef:
        _snwprintf(psz, c, L"El<%x>", m_peVal);
        break;

    case DirectUI::Value::tLayout:
        _snwprintf(psz, c, L"Layt<%x>", m_plVal);
        break;

    case DirectUI::Value::tRectangle:
        _snwprintf(psz, c, L"Rect<%d,%d,%d,%d>", m_rectVal.x, m_rectVal.y, m_rectVal.width, m_rectVal.height);
        break;

    case DirectUI::Value::tThickness:
        _snwprintf(psz, c, L"Thick<%d,%d,%d,%d>", m_thickVal.left, m_thickVal.top, m_thickVal.right, m_thickVal.bottom);
        break;

    case DirectUI::Value::tSize:
        _snwprintf(psz, c, L"Size<%d,%d>", m_sizeVal.cx, m_sizeVal.cy);
        break;

    case DirectUI::Value::tRectangleSD:
        _snwprintf(psz, c, L"RectSD<%x|%d,%d,%d,%d>", m_rectSDVal.nUnsetMask, m_rectSDVal.x, m_rectSDVal.y, m_rectSDVal.width, m_rectSDVal.height);
        break;

    default:
        wcsncpy(psz, L"<ToString Unavailable>", c);
        break;
    }


    //
    // Auto-terminate
    //

    *(psz + (c - 1)) = NULL;


    return psz;
}


/***************************************************************************\
*
* DuiValue::GetTypeName
*
\***************************************************************************/

LPCWSTR
DuiValue::GetTypeName(
    IN  int nType)
{
    switch (nType)
    {
    case DirectUI::Value::tInt:
        return L"Integer";

    case DirectUI::Value::tBool:
        return L"Boolean";

    case DirectUI::Value::tElementRef:
        return L"ElementRef";

    case DirectUI::Value::tLayout:
        return L"Layout";

    case DirectUI::Value::tRectangle:
        return L"Rectangle";

    case DirectUI::Value::tThickness:
        return L"Thickness";

    case DirectUI::Value::tSize:
        return L"Size";

    case DirectUI::Value::tRectangleSD:
        return L"RectangleSD";

    default:
        return L"<Must Add>";
    }
}


/***************************************************************************\
*
*
\***************************************************************************/


/***************************************************************************\
*
* DuiValue Common Values
*
* Compile-time common values. DuiStaticValue struct has the same
* data fields and DuiValue. DuiStaticValue is safely cast to DuiValue.
*
\***************************************************************************/

DuiDefineStaticValue   (s_vDuiUnset,         DirectUI::Value::tUnset,      0)
DuiDefineStaticValue   (s_vDuiNull,          DirectUI::Value::tNull,       0)
DuiDefineStaticValue   (s_vDuiIntZero,       DirectUI::Value::tInt,        0)
DuiDefineStaticValue   (s_vDuiBoolTrue,      DirectUI::Value::tBool,       TRUE)
DuiDefineStaticValue   (s_vDuiBoolFalse,     DirectUI::Value::tBool,       FALSE)
DuiDefineStaticValue   (s_vDuiElementNull,   DirectUI::Value::tElementRef, 0)
DuiDefineStaticValuePtr(s_vDuiLayoutNull,    DirectUI::Value::tLayout,     NULL)
DuiDefineStaticValue4  (s_vDuiRectangleZero, DirectUI::Value::tRectangle,  0, 0, 0, 0)
DuiDefineStaticValue4  (s_vDuiThicknessZero, DirectUI::Value::tThickness,  0, 0, 0, 0)
DuiDefineStaticValue2  (s_vDuiSizeZero,      DirectUI::Value::tSize,       0, 0)

DuiValue * DuiValue::s_pvUnset          = reinterpret_cast<DuiValue *> (&s_vDuiUnset);
DuiValue * DuiValue::s_pvNull           = reinterpret_cast<DuiValue *> (&s_vDuiNull);
DuiValue * DuiValue::s_pvIntZero        = reinterpret_cast<DuiValue *> (&s_vDuiIntZero);
DuiValue * DuiValue::s_pvBoolTrue       = reinterpret_cast<DuiValue *> (&s_vDuiBoolTrue);
DuiValue * DuiValue::s_pvBoolFalse      = reinterpret_cast<DuiValue *> (&s_vDuiBoolFalse);
DuiValue * DuiValue::s_pvElementNull    = reinterpret_cast<DuiValue *> (&s_vDuiElementNull);
DuiValue * DuiValue::s_pvLayoutNull     = reinterpret_cast<DuiValue *> (&s_vDuiLayoutNull);
DuiValue * DuiValue::s_pvRectangleZero  = reinterpret_cast<DuiValue *> (&s_vDuiRectangleZero);
DuiValue * DuiValue::s_pvThicknessZero  = reinterpret_cast<DuiValue *> (&s_vDuiThicknessZero);
DuiValue * DuiValue::s_pvSizeZero       = reinterpret_cast<DuiValue *> (&s_vDuiSizeZero);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\dll\directui.cpp ===
/***************************************************************************\
*
* File: DirectUI.cpp
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Dll.h"

extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved);


/***************************************************************************\
*
* DirectUI MetaData
*
* External DLLs will use registration methods. When dealing with 
* namespace 0 (DirectUI), use internal data structures directly
*
\***************************************************************************/


/***************************************************************************\
*****************************************************************************
*
* Properties
*
*****************************************************************************
\***************************************************************************/


//
// Element
//


// Parent property: Matching DisplayNode state driven by Element (using DN as storage)
static int vvParent[] = { DirectUI::Value::tElementRef, -1 };       // NS: 0, EL: 0, PROP: 0
static DuiPropertyInfo ElementParentPI = {
                                        DirectUI::Element::Parent,
                                        L"Parent", 
                                        DirectUI::PropertyInfo::fLocalOnly,
                                        DirectUI::PropertyInfo::gAffectsDesiredSize | DirectUI::PropertyInfo::gAffectsLayout,
                                        vvParent,
                                        NULL,
                                        DuiValue::s_pvElementNull,
                                        GlobalPI::iElementParent };
DuiPropertyInfo * GlobalPI::ppiElementParent = &ElementParentPI;


// Bounds property: Matching DisplayNode state (Actual only) driven by Element (using DN as storage)
static int vvBounds[] = { DirectUI::Value::tRectangleSD, -1 };      // NS: 0, EL: 0, PROP: 1
DuiDefineStaticValue5(s_vDuiDefaultBounds, DirectUI::Value::tRectangleSD, 0, 0, 0, -1, -1)
static DuiPropertyInfo ElementBoundsPI = {
                                        DirectUI::Element::Bounds,
                                        L"Bounds",
                                        DirectUI::PropertyInfo::fTriLevel,
                                        DirectUI::PropertyInfo::gAffectsDesiredSize,
                                        vvBounds,
                                        NULL,
                                        reinterpret_cast <DuiValue *> (&s_vDuiDefaultBounds),
                                        GlobalPI::iElementBounds };
DuiPropertyInfo * GlobalPI::ppiElementBounds = &ElementBoundsPI;

// Layout property
static int vvLayout[] = { DirectUI::Value::tLayout, -1 };           // NS: 0, EL: 0, PROP: 2
static DuiPropertyInfo ElementLayoutPI = {
                                        DirectUI::Element::Layout,
                                        L"Layout",
                                        DirectUI::PropertyInfo::fNormal | DirectUI::PropertyInfo::fCached,
                                        DirectUI::PropertyInfo::gAffectsDesiredSize | DirectUI::PropertyInfo::gAffectsLayout, 
                                        vvLayout,
                                        NULL,
                                        DuiValue::s_pvLayoutNull,
                                        GlobalPI::iElementLayout };
DuiPropertyInfo * GlobalPI::ppiElementLayout = &ElementLayoutPI;

// LayoutPos property
static int vvLayoutPos[] = { DirectUI::Value::tInt, -1 };           // NS: 0, EL: 0, PROP: 3
DuiDefineStaticValue(s_vDuiDefaultLayoutPos, DirectUI::Value::tInt, DirectUI::Layout::lpAuto)
static DuiPropertyInfo ElementLayoutPosPI = {
                                        DirectUI::Element::LayoutPos,
                                        L"LayoutPos", 
                                        DirectUI::PropertyInfo::fNormal | DirectUI::PropertyInfo::fCascade | DirectUI::PropertyInfo::fCached,
                                        DirectUI::PropertyInfo::gAffectsDesiredSize | DirectUI::PropertyInfo::gAffectsParentLayout,
                                        vvLayoutPos,
                                        NULL,
                                        reinterpret_cast<DuiValue *> (&s_vDuiDefaultLayoutPos),
                                        GlobalPI::iElementLayoutPos };
DuiPropertyInfo * GlobalPI::ppiElementLayoutPos = &ElementLayoutPosPI;

// DesiredSize property
static int vvDesiredSize[] = { DirectUI::Value::tSize, -1 };        // NS: 0, EL: 0, PROP: 4
static DuiPropertyInfo ElementDesiredSizePI = {
                                        DirectUI::Element::DesiredSize,
                                        L"DesiredSize",
                                        DirectUI::PropertyInfo::fLocalOnly | DirectUI::PropertyInfo::fReadOnly,
                                        DirectUI::PropertyInfo::gAffectsParentLayout, 
                                        vvDesiredSize,
                                        NULL,
                                        DuiValue::s_pvSizeZero,
                                        GlobalPI::iElementDesiredSize };
DuiPropertyInfo * GlobalPI::ppiElementDesiredSize = &ElementDesiredSizePI;

// Active property: Matching DisplayNode state driven by Element (using DN as storage)
static int vvActive[] = { DirectUI::Value::tInt, -1 };              // NS: 0, EL: 0, PROP: 5
static DuiPropertyInfo ElementActivePI = {
                                        DirectUI::Element::Active,
                                        L"Active",
                                        DirectUI::PropertyInfo::fLocalOnly,
                                        0, 
                                        vvActive,
                                        NULL,
                                        DuiValue::s_pvIntZero /*aeInactive*/,
                                        GlobalPI::iElementActive };
DuiPropertyInfo * GlobalPI::ppiElementActive = &ElementActivePI;

// KeyFocused property: Matching DisplayNode state driven by DisplayNode
static int vvKeyFocused[] = { DirectUI::Value::tBool, -1 };         // NS: 0, EL: 0, PROP: 6
static DuiPropertyInfo ElementKeyFocusedPI = {
                                        DirectUI::Element::KeyFocused,
                                        L"KeyFocused",
                                        DirectUI::PropertyInfo::fNormal | DirectUI::PropertyInfo::fReadOnly | DirectUI::PropertyInfo::fInherit /* Conditional inherit */ | DirectUI::PropertyInfo::fCached,
                                        0, 
                                        vvKeyFocused,
                                        NULL,
                                        DuiValue::s_pvBoolFalse,
                                        GlobalPI::iElementKeyFocused };
DuiPropertyInfo * GlobalPI::ppiElementKeyFocused = &ElementKeyFocusedPI;

// MouseFocused property: Matching DisplayNode state driven by DisplayNode
static int vvMouseFocused[] = { DirectUI::Value::tBool, -1 };       // NS: 0, EL: 0, PROP: 7
static DuiPropertyInfo ElementMouseFocusedPI = {
                                        DirectUI::Element::MouseFocused,
                                        L"MouseFocused",
                                        DirectUI::PropertyInfo::fNormal | DirectUI::PropertyInfo::fReadOnly | DirectUI::PropertyInfo::fInherit /* Conditional inherit */ | DirectUI::PropertyInfo::fCached,
                                        0, 
                                        vvMouseFocused,
                                        NULL,
                                        DuiValue::s_pvBoolFalse,
                                        GlobalPI::iElementMouseFocused };
DuiPropertyInfo * GlobalPI::ppiElementMouseFocused = &ElementMouseFocusedPI;

// KeyWithin property
static int vvKeyWithin[] = { DirectUI::Value::tBool, -1 };          // NS: 0, EL: 0, PROP: 8
static DuiPropertyInfo ElementKeyWithinPI = {
                                        DirectUI::Element::KeyWithin,
                                        L"KeyWithin",
                                        DirectUI::PropertyInfo::fLocalOnly | DirectUI::PropertyInfo::fReadOnly,
                                        0, 
                                        vvKeyWithin,
                                        NULL,
                                        DuiValue::s_pvBoolFalse,
                                        GlobalPI::iElementKeyWithin };
DuiPropertyInfo * GlobalPI::ppiElementKeyWithin = &ElementKeyWithinPI;

// MouseWithin property
static int vvMouseWithin[] = { DirectUI::Value::tBool, -1 };        // NS: 0, EL: 0, PROP: 9
static DuiPropertyInfo ElementMouseWithinPI = {
                                        DirectUI::Element::MouseWithin,
                                        L"MouseWithin",
                                        DirectUI::PropertyInfo::fLocalOnly | DirectUI::PropertyInfo::fReadOnly,
                                        0, 
                                        vvMouseWithin,
                                        NULL,
                                        DuiValue::s_pvBoolFalse,
                                        GlobalPI::iElementMouseWithin };
DuiPropertyInfo * GlobalPI::ppiElementMouseWithin = &ElementMouseWithinPI;

// Background property
static int vvBackground[] = { DirectUI::Value::tInt /* Std Color */, -1 };  // NS: 0, EL: 0, PROP: 10
static DuiPropertyInfo ElementBackgroundPI = {
                                        DirectUI::Element::Background,
                                        L"Background",
                                        DirectUI::PropertyInfo::fNormal | DirectUI::PropertyInfo::fCascade,
                                        DirectUI::PropertyInfo::gAffectsDisplay,
                                        vvBackground,
                                        NULL,
                                        DuiValue::s_pvIntZero,
                                        GlobalPI::iElementBackground };
DuiPropertyInfo * GlobalPI::ppiElementBackground = &ElementBackgroundPI;


static DuiPropertyInfo * ElementPIs[] = {
                                        &ElementParentPI,
                                        &ElementBoundsPI,
                                        &ElementLayoutPI,
                                        &ElementLayoutPosPI,
                                        &ElementDesiredSizePI,
                                        &ElementActivePI,
                                        &ElementKeyFocusedPI,
                                        &ElementMouseFocusedPI,
                                        &ElementKeyWithinPI,
                                        &ElementMouseWithinPI,
                                        &ElementBackgroundPI,
                                    };


/***************************************************************************\
*****************************************************************************
*
* Classes
*
*****************************************************************************
\***************************************************************************/

//
// Elements
//
  
static DuiElementInfo ElementEI = {
                                        DirectUI::Element::Class,
                                        L"Element",
                                        ElementPIs,
                                        ARRAYSIZE(ElementPIs) };


static DuiElementInfo * DirectUIEIs[] = {
                                        &ElementEI,
                                    };


/***************************************************************************\
*****************************************************************************
*
* DirectUI Namespace
*
*****************************************************************************
\***************************************************************************/


static DuiNamespaceInfo DirectUINI = {
                                        L"DirectUI.DLL",
                                        DirectUIEIs,
                                        ARRAYSIZE(DirectUIEIs) };


/***************************************************************************\
*****************************************************************************
*
* DirectUI DLL Entry/Exit
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*
* InitializeMTClasses
*
* Initializes all classes within this DLL that make use of Message Tables.
* DLL must be loaded before any class can be built
*
\***************************************************************************/

HRESULT
InitializeMTClasses()
{
    HRESULT hr;

    //
    // DirectUI classes
    //

    if (!DuiElement::InitDirectUI__Element()) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    if (!DuiHWNDRoot::InitDirectUI__HWNDRoot()) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    if (!DuiLayout::InitDirectUI__Layout()) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    if (!DuiGridLayout::InitDirectUI__GridLayout()) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    if (!DuiBorderLayout::InitDirectUI__BorderLayout()) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


/***************************************************************************\
*
* DuiProcessAttach
*
\***************************************************************************/

HRESULT DuiProcessAttach()
{
    HRESULT hr;


    //
    // Global process initialization
    //

    hr = DuiProcess::Init();
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Create namespace registry, pass in constant DirectUI table
    //

    hr = DuiRegister::Initialize(&DirectUINI);
    if (FAILED(hr)) {
        goto Failure;
    }

    DuiRegister::VerifyNamespace(DirectUIMakeNamespacePUID(0));


    //
    // Initialize message table classes
    //

    hr = InitializeMTClasses();
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


/***************************************************************************\
*
* DuiProcessDetach
*
\***************************************************************************/

HRESULT DuiProcessDetach()
{
    HRESULT hr;


    //
    // Global process uninitialization
    //

    hr = DuiProcess::UnInit();
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Destroy namespace registry
    //

    DuiRegister::Destroy();


    return S_OK;


Failure:

    return hr;
}


/***************************************************************************\
*
* DllMain
*
* DllMain() is called after the CRT has fully ininitialized.
*
\***************************************************************************/

extern "C" BOOL WINAPI 
DllMain(
    HINSTANCE hModule, 
    DWORD dwReason,
    LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if (FAILED(DuiProcessAttach())) {
            goto Failure;
        }
        break;
        
    case DLL_PROCESS_DETACH:
        if (FAILED(DuiProcessDetach())) {
            goto Failure;
        }
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;


Failure:

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\thread.inl ===
/***************************************************************************\
*
* File: Thread.inl
*
* Description:
* Thread specific inline functions
*
* History:
*  9/15/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


/***************************************************************************\
*
* DuiThread::GetCCStore()
*
* Retrieve DirectUI context-specific core information
*
\***************************************************************************/

inline DuiThread::CoreCtxStore *
DuiThread::GetCCStore()
{
    return reinterpret_cast<DuiThread::CoreCtxStore *> (TlsGetValue(DuiProcess::s_dwCoreSlot));
}


/***************************************************************************\
*
* DuiThread::GetCCDC()
*
* Retrieve DirectUI core context-specific defer cycle
*
\***************************************************************************/

inline DuiDeferCycle *
DuiThread::GetCCDC()
{
    CoreCtxStore * pCS = GetCCStore();
    if (pCS != NULL) {
        return pCS->pDC;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\value.h ===
/***************************************************************************\
*
* File: Value.h
*
* Description:
* Value object that is used by properties
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(DUICORE__Value_h__INCLUDED)
#define DUICORE__Value_h__INCLUDED
#pragma once


#include "Thread.h"


//
// Forward declarations
//

class DuiElement;
class DuiLayout;


/***************************************************************************\
*
* DuiValue class (external representation is 'Value')
*
* Class is 32-bytes
*
\***************************************************************************/

class DuiValue
{
// Construction
public:

// Operations
public:

    static  DuiValue *  BuildInt(IN int v);
    static  DuiValue *  BuildBool(IN BOOL v);
    static  DuiValue *  BuildElementRef(IN DuiElement * v);
    static  DuiValue *  BuildLayout(IN DuiLayout * v);
    static  DuiValue *  BuildRectangle(IN int x, IN int y, IN int width, IN int height);
    static  DuiValue *  BuildThickness(IN int left, IN int top, IN int right, IN int bottom);
    static  DuiValue *  BuildSize(IN int cx, IN int cy);
    static  DuiValue *  BuildRectangleSD(IN UINT nUnsetMask, IN int x, IN int y, IN int width, IN int height);
    static  DuiValue *  Build(IN int nType, IN void * v);

    inline  void        AddRef();
    inline  void        Release();
    inline  int         GetRefCount();

    inline  short       GetType();

    static  LPCWSTR     GetTypeName(int nType);

    inline  int         GetInt();
    inline  BOOL        GetBool();
    inline  DuiElement *
                        GetElement();
    inline  DuiLayout * GetLayout();
    inline  const DirectUI::Rectangle * 
                        GetRectangle();
    inline  const DirectUI::Thickness * 
                        GetThickness();
    inline  const SIZE *
                        GetSize();
    inline  const DirectUI::RectangleSD * 
                        GetRectangleSD();
            void *      GetData(IN int nType);

    inline  BOOL        IsSubDivided();
    inline  BOOL        IsComplete();
            BOOL        IsEqual(IN DuiValue * pv);
            LPWSTR      ToString(IN LPWSTR psz, IN UINT c);
            DuiValue *  Merge(IN DuiValue * pv, IN DuiThread::CoreCtxStore * pCCS);

    static inline 
            DirectUI::Value *
                        ExternalCast(DuiValue * pv);
    static inline 
            DuiValue *  InternalCast(DirectUI::Value * pve);

// Implementation
private:
            void        ZeroRelease();

// Data
private:

            BYTE        m_fReserved0;          // Reserved for small block allocator
            BYTE        m_fReserved1;          // Data alignment padding
            short       m_nType;
            int         m_cRef;
            union
            {
                int                     m_intVal;
                BOOL                    m_boolVal;
                DuiElement *            m_peVal;
                DuiLayout *             m_plVal;
                DirectUI::Rectangle     m_rectVal;
                DirectUI::Thickness     m_thickVal;
                SIZE                    m_sizeVal;

                DirectUI::SubDivValue   m_sdHeader;
                DirectUI::RectangleSD   m_rectSDVal;

                BYTE                    m_buf[24];         // Alignment requirement, total size
            };

public:

    //
    // Common values
    //

    static  DuiValue *  s_pvUnset;
    static  DuiValue *  s_pvNull;
    static  DuiValue *  s_pvIntZero;
    static  DuiValue *  s_pvBoolTrue;
    static  DuiValue *  s_pvBoolFalse;
    static  DuiValue *  s_pvElementNull;
    static  DuiValue *  s_pvLayoutNull;
    static  DuiValue *  s_pvRectangleZero;
    static  DuiValue *  s_pvThicknessZero;
    static  DuiValue *  s_pvSizeZero;
};


/***************************************************************************\
*
* DuiStaticValue class
*
* Compile-time static version of the DuiValue class
*
\***************************************************************************/

struct DuiStaticValue
{
    BYTE        fReserved0; // +
    BYTE        fReserved1; // | 8-bytes header
    short       nType;      // |
    int         cRef;       // +
    int         val0;       // +
    int         val1;       // |
    int         val2;       // | 24-bytes data
    int         val3;       // |
    int         val4;       // |
    int         val5;       // +
};

struct DuiStaticValuePtr
{
    BYTE        fReserved0;
    BYTE        fReserved1;
    short       nType;
    int         cRef;
    void *      ptr;
};


#define DuiDefineStaticValue(name, type, v0)                      static DuiStaticValue    name = { 0, 0, type, -1, v0, 0, 0, 0, 0, 0 };
#define DuiDefineStaticValue2(name, type, v0, v1)                 static DuiStaticValue    name = { 0, 0, type, -1, v0, v1, 0, 0, 0, 0 };
#define DuiDefineStaticValue3(name, type, v0, v1, v2)             static DuiStaticValue    name = { 0, 0, type, -1, v0, v1, v2, 0, 0, 0 };
#define DuiDefineStaticValue4(name, type, v0, v1, v2, v3)         static DuiStaticValue    name = { 0, 0, type, -1, v0, v1, v2, v3, 0, 0 };
#define DuiDefineStaticValue5(name, type, v0, v1, v2, v3, v4)     static DuiStaticValue    name = { 0, 0, type, -1, v0, v1, v2, v3, v4, 0 };
#define DuiDefineStaticValue6(name, type, v0, v1, v2, v3, v4, v5) static DuiStaticValue    name = { 0, 0, type, -1, v0, v1, v2, v3, v4, v5 };
#define DuiDefineStaticValuePtr(name, type, ptr)                  static DuiStaticValuePtr name = { 0, 0, type, -1, ptr };


#include "Value.inl"


#endif // DUICORE__Value_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\core\value.inl ===
/***************************************************************************\
*
* File: Value.inl
*
* Description:
* Value object that is used by properties, inline methods
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


//------------------------------------------------------------------------------
inline DirectUI::Value *
DuiValue::ExternalCast(
    IN  DuiValue * pv)    
{ 
    return reinterpret_cast<DirectUI::Value *> (pv);
}


//------------------------------------------------------------------------------
inline DuiValue *
DuiValue::InternalCast(
    IN  DirectUI::Value * pve)
{ 
    return reinterpret_cast<DuiValue *> (pve);
}


//------------------------------------------------------------------------------
inline void 
DuiValue::AddRef()    
{ 
    //
    // -1 is static value
    //

    if (m_cRef != -1) {
        m_cRef++; 
    }
}


//------------------------------------------------------------------------------
inline void 
DuiValue::Release() 
{ 
    //
    // -1 is static value
    //

    if ((m_cRef != -1) && (--m_cRef == 0)) {
        ZeroRelease();
    }
}


/***************************************************************************\
*
* DuiValue::IsSubDivided()
*
* A Value is subdivided if any members of the overall Value can be 
* considered "Unset". The Value's Data derives from SubDivValue
*
\***************************************************************************/

inline BOOL
DuiValue::IsSubDivided() 
{
    return m_nType > DirectUI::Value::tMinSD;
}


/***************************************************************************\
*
* DuiValue::IsComplete()
*
* A Value is considered "Complete" if it's a sub-divided value with no
* Unset parameters, or if it's a standard Value that isn't the Unset Value
*
\***************************************************************************/

inline BOOL
DuiValue::IsComplete() 
{
    if (IsSubDivided()) {
        return m_sdHeader.nUnsetMask == 0; 
    } else {
        return m_nType != DirectUI::Value::tUnset;
    }
}


//------------------------------------------------------------------------------
inline int
DuiValue::GetRefCount() 
{ 
    return m_cRef;
}


//------------------------------------------------------------------------------
inline short
DuiValue::GetType()
{
    return m_nType;
}


//------------------------------------------------------------------------------
inline int
DuiValue::GetInt()
{
    ASSERT_(m_nType == DirectUI::Value::tInt, "Invalid value type");

    //
    // Copy passed out
    //

    return m_intVal;
}


//------------------------------------------------------------------------------
inline BOOL
DuiValue::GetBool()
{
    ASSERT_(m_nType == DirectUI::Value::tBool, "Invalid value type");

    //
    // Copy passed out
    //

    return m_boolVal;
}


//------------------------------------------------------------------------------
inline DuiElement *
DuiValue::GetElement()
{
    ASSERT_(m_nType == DirectUI::Value::tElementRef, "Invalid value type");

    //
    // Copy passed out
    //

    return m_peVal;
}


//------------------------------------------------------------------------------
inline DuiLayout *
DuiValue::GetLayout()
{
    ASSERT_(m_nType == DirectUI::Value::tLayout, "Invalid value type");

    //
    // Copy passed out
    //

    return m_plVal;
}


//------------------------------------------------------------------------------
inline const DirectUI::Rectangle *
DuiValue::GetRectangle()
{
    ASSERT_(m_nType == DirectUI::Value::tRectangle, "Invalid value type");

    //
    // Const pointer passed out
    //

    return &m_rectVal;
}


//------------------------------------------------------------------------------
inline const DirectUI::Thickness *
DuiValue::GetThickness()
{
    ASSERT_(m_nType == DirectUI::Value::tThickness, "Invalid value type");

    //
    // Const pointer passed out
    //

    return &m_thickVal;
}


//------------------------------------------------------------------------------
inline const SIZE *
DuiValue::GetSize()
{
    ASSERT_(m_nType == DirectUI::Value::tSize, "Invalid value type");

    //
    // Const pointer passed out
    //

    return &m_sizeVal;
}


//------------------------------------------------------------------------------
inline const DirectUI::RectangleSD *
DuiValue::GetRectangleSD()
{
    ASSERT_(m_nType == DirectUI::Value::tRectangleSD, "Invalid value type");

    //
    // Const pointer passed out
    //

    return &m_rectSDVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DUser.rc
//
#define IDD_DLG                         100
#define IDB_SPYICON                     101
#define IDD_ASSERT                      101
#define IDC_ebcFileName                 1000
#define IDC_ebcExpression               1001
#define IDC_ebcLineNum                  1002
#define IDC_IGNORE                      1003
#define IDC_COPY                        1004
#define IDC_lvcCallStack                1005
#define IDC_DEBUG                       1008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\dll\dll.h ===
/***************************************************************************\
*
* File: Dll.h
*
* Description:
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIDLL__Dll_h__INCLUDED)
#define DUIDLL__Dll_h__INCLUDED
#pragma once

//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//

#include <DUIBaseP.h>
#include <DUIObjectAPIP.h>
#include <DUICoreP.h>
#include <DUILayoutP.h>


#endif // DUIDLL__Dll_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\dll\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIDLL__StdAfx_h__INCLUDED)
#define DUIDLL__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUIDLL__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\dll\test.cpp ===
/***************************************************************************\
*
* File: Test.cpp
*
* Description:
* Internal data structures QA
*
* History:
*  9/18/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Dll.h"


//#if DBG


// REFORMAT


/***************************************************************************\
*****************************************************************************
*
* Test class
*
*****************************************************************************
\***************************************************************************/

#ifdef TEST
#undef TEST
#endif

#define TEST(c)             { if (!(c)) { AutoDebugBreak(); MessageBoxW(NULL, L"Test failed!", L"DirectUI", MB_OK|MB_ICONERROR); return DU_E_GENERIC; } }

class DuiTestInternal
{
public:
    //
    // Used by Utility test
    //

    struct TestRecord
    {
        BOOL        fVoid;
        void *      pe;
        void *      ppi;
        int         iIndex;
        void *      pvOld;
        void *      pvNew;
    };

    
    //
    // Used by small block allocator test
    //

    class LeakCheck : public DuiSBAlloc::ISBLeak
    {
    public:
        LeakCheck() { cLeaks = 0; }
        void AllocLeak(void* pBlock) { UNREFERENCED_PARAMETER(pBlock); cLeaks++; }
        UINT cLeaks;
    };

    struct TestAlloc
    {
        BYTE        fReserved;
        int         dVal;
    };
    
    //
    // Test passes
    //

    enum EType
    {
        tNone             = -1,  // Test classes initialization
        tAll              = 0,
        tUtilities,
        tSmallBlockAlloc,
        tNestedGrid,
    };

    static  HRESULT     Test(UINT nTest);
    static  HRESULT     TestUtilities();
    static  HRESULT     TestSmallBlockAlloc();
    static  HRESULT     TestNestedGrid();
};


/***************************************************************************\
*
* Test classes
*
\***************************************************************************/

//
// Declaration
//

class DuiMolecule :
        public DirectUI::MoleculeImpl<DuiMolecule, DuiElement>
{
public:
// Construction
    DuiMolecule() { } 
    virtual ~DuiMolecule();

            HRESULT     PostBuild(IN DUser::Gadget::ConstructInfo * pciData);

// Notifications
    virtual void        OnPropertyChanged(IN DuiPropertyInfo * ppi, IN UINT iIndex, IN DuiValue * pvOld, IN DuiValue * pvNew);  // Direct

// Data
private:
            DuiValue *  m_pvOriginal;
            DuiValue *  m_pvMouse;
            DuiValue *  m_pvKeyboard;
};


//
// Definition
//

IMPLEMENT_GUTS_DirectUI__Molecule(DuiMolecule, DuiElement)


//------------------------------------------------------------------------------
HRESULT
DuiMolecule::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pciData)
{ 
    HRESULT hr;

    DuiValue * pv = NULL;

    //
    // Init
    //
    
    m_pvOriginal = NULL;

    m_pvMouse    = DuiValue::BuildInt(SC_Yellow);
    m_pvKeyboard = DuiValue::BuildInt(SC_Green);

    if ((m_pvMouse == NULL) || (m_pvKeyboard == NULL)) {
        hr = E_OUTOFMEMORY;
    }


    //
    // Init base (make display node available)
    //

    hr = DuiElement::PostBuild(pciData);
    if (FAILED(hr)) {
        goto Failure;
    }


    //
    // Set properties
    //

    pv = DuiValue::BuildInt(DirectUI::Element::aeMouseAndKeyboard);
    if (pv == NULL) {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    hr = SetValue(GlobalPI::ppiElementActive, DirectUI::PropertyInfo::iLocal, pv);
    if (FAILED(hr)) {
        goto Failure;
    }

    pv->Release();


    return S_OK;


Failure:

    if (m_pvMouse != NULL) {
        m_pvMouse->Release();
        m_pvMouse = NULL;
    }

    if (m_pvKeyboard != NULL) {
        m_pvKeyboard->Release();
        m_pvKeyboard = NULL;
    }

    if (pv != NULL) {
        pv->Release();
        pv = NULL;
    }


    return  hr;
}


//------------------------------------------------------------------------------
DuiMolecule::~DuiMolecule()
{
    if (m_pvOriginal != NULL) {
        m_pvOriginal->Release();
    }

    if (m_pvMouse != NULL) {
        m_pvMouse->Release();
    }

    if (m_pvKeyboard != NULL) {
        m_pvKeyboard->Release();
    }
}


//------------------------------------------------------------------------------
void
DuiMolecule::OnPropertyChanged(
    IN  DuiPropertyInfo * ppi, 
    IN  UINT iIndex, 
    IN  DuiValue * pvOld, 
    IN  DuiValue * pvNew)
{
    UNREFERENCED_PARAMETER(pvOld);


    DuiElement::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    
    if (iIndex == DirectUI::PropertyInfo::iSpecified) {

        switch (ppi->iGlobal)
        {
        case GlobalPI::iElementBackground:
            //
            // Store background on first change
            //

            if (m_pvOriginal == NULL) {
                m_pvOriginal = pvNew;
                m_pvOriginal->AddRef();
            }
            break;

        case GlobalPI::iElementMouseFocused:
            {
                DuiValue * pvChange = pvNew->GetBool() ? m_pvMouse : m_pvOriginal;
                SetValue(GlobalPI::ppiElementBackground, DirectUI::PropertyInfo::iLocal, pvChange);
            }
            break;

        case GlobalPI::iElementKeyFocused:
            {
                DuiValue * pvChange = pvNew->GetBool() ? m_pvKeyboard : m_pvOriginal;
                SetValue(GlobalPI::ppiElementBackground, DirectUI::PropertyInfo::iLocal, pvChange);
            }
            break;
        }
    }
}


/***************************************************************************\
*
* DuiTestInternal::TestNestedGrid
*
\***************************************************************************/

HRESULT
DuiTestInternal::TestNestedGrid()
{
    return S_OK;
}


/***************************************************************************\
*
* DuiTestInternal::TestSmallBlockAlloc
*
\***************************************************************************/

HRESULT
DuiTestInternal::TestSmallBlockAlloc()
{
    TRACE("DUI: Testing Small Block Allocator...");

    LeakCheck lCheck;

    DuiSBAlloc* psba = new DuiSBAlloc(sizeof(TestAlloc), 2, &lCheck);

    void* b0 = psba->Alloc();
    void* b1 = psba->Alloc();

    TEST(b0 && b1);

    psba->Free(b0);
    psba->Free(b1);

    b1 = psba->Alloc();
    b0 = psba->Alloc();

    TEST(b0 && b1);

    psba->Free(b0);
    psba->Free(b1);

    //
    // Check leak detector
    //

    for (int i = 0; i < 256; i++)
        psba->Alloc();

    delete psba;

    TEST(lCheck.cLeaks == 256);


    TRACE("SUCCESS!\n");

    return S_OK;
}


/***************************************************************************\
*
* DuiTestInternal::TestUtilties
*
\***************************************************************************/

HRESULT
DuiTestInternal::TestUtilities()
{
    TRACE("DUI: Testing Utility Classes...");

    // BTree lookup
    DuiBTreeLookup<int>* pbl;
    DuiBTreeLookup<int>::Create(FALSE, &pbl);

    TEST(!pbl->GetItem((void*)9));

    pbl->SetItem((void*)9, 1111);
    pbl->SetItem((void*)7, 2222);

    TEST(*(pbl->GetItem((void*)9)) == 1111);

    pbl->SetItem((void*)9, 3333);
    TEST(*(pbl->GetItem((void*)7)) == 2222);
    TEST(*(pbl->GetItem((void*)9)) == 3333);

    pbl->Remove((void*)0);
    pbl->Remove((void*)9);

    TEST(!pbl->GetItem((void*)9));

    pbl->Remove((void*)7);

    TEST(!pbl->GetItem((void*)7));

    pbl->SetItem((void*)0, 9999);

    TEST(*(pbl->GetItem((void*)0)) == 9999);

    delete pbl;

    // Value map
    DuiValueMap<int,int>* pvm;
    DuiValueMap<int,int>::Create(5, &pvm);

    pvm->SetItem(1, 1111, FALSE);
    pvm->SetItem(2, 2222, FALSE);

    int* pValue;

    pValue = pvm->GetItem(2, FALSE);
    TEST(*pValue == 2222);

    pvm->Remove(2, FALSE, FALSE);

    pValue = pvm->GetItem(2, FALSE);
    TEST(pValue == NULL);

    pValue = pvm->GetItem(1, FALSE);
    TEST(*pValue == 1111);

    pvm->SetItem(5, 5555, FALSE);

    pValue = pvm->GetItem(5, FALSE);
    TEST(*pValue == 5555);

    pvm->Remove(1, TRUE, FALSE);

    pValue = pvm->GetItem(5, FALSE);
    TEST(*pValue == 5555);

    delete pvm;

    // Dynamic array
    DuiDynamicArray<int>* pda;
    DuiDynamicArray<int>::Create(0, 0, &pda);

    pda->Add(1000);
    pda->Add(3000);
    pda->Add(4000);

    TEST(pda->GetItem(0) == 1000);
    TEST(pda->GetItem(1) == 3000);

    pda->Insert(1, 2000);

    TEST(pda->GetItem(1) == 2000);
    TEST(pda->GetItem(3) == 4000);

    pda->SetItem(2, 9999);

    TEST(pda->GetItem(2) == 9999);

    TEST(pda->GetSize() == 4);

    pda->Remove(0);
    pda->Remove(0);

    TEST(pda->GetSize() == 2);
    TEST(pda->GetItem(1) == 4000);

    pda->Reset();

    pda->Add(9);
    pda->Insert(0, 8);
    pda->Insert(0, 7);
    pda->Insert(0, 6);
    pda->Insert(0, 5);
    pda->Insert(0, 4);
    pda->Insert(0, 3);
    pda->Insert(0, 2);
    pda->Insert(0, 1);
    pda->Insert(0, 0);

    TEST(pda->GetSize() == 10);
    TEST(pda->GetItem(1) == 1);

    DuiDynamicArray<TestRecord>* pdaPC;
    DuiDynamicArray<TestRecord>::Create(0, 0, &pdaPC);
    TestRecord* pr;

    for (int i = 0; i < 10000; i++)
    {
        pdaPC->AddPtr(&pr);
        pr->pe     = (void*)(INT_PTR)i;
        pr->ppi    = (void*)(INT_PTR)i;
        pr->iIndex = i;
        pr->fVoid  = FALSE;
        pr->pvNew  = NULL;
        pr->pvOld  = NULL;
    }

    TEST(pdaPC->GetSize() == 10000);

    delete pda;
    delete pdaPC;
   

    TRACE("SUCCESS!\n");

    return S_OK;
}


/***************************************************************************\
*
* DuiTestInternal::Test
*
* Generic test access
*
\***************************************************************************/

HRESULT
DuiTestInternal::Test(UINT nTest)
{
    switch (nTest)
    {
    case tAll:
        {
            HRESULT hr = S_OK;

            hr = TestUtilities();
            if (FAILED(hr))
                return hr;

            hr = TestSmallBlockAlloc();
            if (FAILED(hr))
                return hr;

            return hr;
        }
        break;
        
    case tUtilities:
        return TestUtilities();

    case tSmallBlockAlloc:
        return TestSmallBlockAlloc();

    case tNestedGrid:
        return TestNestedGrid();
    }


    return DU_E_GENERIC;
}


/***************************************************************************\
*
* External test access
*
\***************************************************************************/

HRESULT
DirectUITestInternal(
    IN  UINT nTest)
{
    //
    // Test classes initialization
    //

    DuiMolecule::InitDirectUI__Molecule();


    return DuiTestInternal::Test(nTest);
}


//#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\duibasep.h ===
/***************************************************************************\
*
* File: DUIBaseP.h
*
* Description:
* Central location for project specific headers for cross project inclusion
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DUIBaseP_h__INCLUDED)
#define DUI__DUIBaseP_h__INCLUDED
#pragma once


#include "..\Base\Published.h"


#endif // DUI__DUIBaseP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\commonstdafx.h ===
/***************************************************************************\
*
* File: CommonStdAfx.h
*
* Description:
* Common include for all stdafx.h project headers
* This includes all common external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__CommonStdAfx_h__INCLUDED)
#define DUI__CommonStdAfx_h__INCLUDED
#pragma once


// Engine warning pragmas
#pragma warning (disable:4127)  // W4: Conditional expression is constant
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function
#pragma warning (disable:4201)  // W4: Nameless struct/union may not be compiler portable

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <gdiplus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser headers

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS

#include <duser.h>              // DirectUser

#endif // DUI__CommonStdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\duicorep.h ===
/***************************************************************************\
*
* File: DUICoreP.h
*
* Description:
* Central location for project specific headers for cross project inclusion
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DUICoreP_h__INCLUDED)
#define DUI__DUICoreP_h__INCLUDED
#pragma once


#include "..\Core\Published.h"


#endif // DUI__DUICoreP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\duilayoutp.h ===
/***************************************************************************\
*
* File: DUILayoutP.h
*
* Description:
* Central location for project specific headers for cross project inclusion
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DUILayoutP_h__INCLUDED)
#define DUI__DUILayoutP_h__INCLUDED
#pragma once


#include "..\Layout\Published.h"


#endif // DUI__DUILayoutP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\duiobjectapip.h ===
/***************************************************************************\
*
* File: DUIObjectAPIP.h
*
* Description:
* Central location for project specific headers for cross project inclusion
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DUIObjectAPIP_h__INCLUDED)
#define DUI__DUIObjectAPIP_h__INCLUDED
#pragma once


#include "..\ObjectAPI\Published.h"


#endif // DUI__DUIObjectAPIP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\inc\duiwinapip.h ===
/***************************************************************************\
*
* File: DUIWinAPIP.h
*
* Description:
* Central location for project specific headers for cross project inclusion
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DUIWinAPIP_h__INCLUDED)
#define DUI__DUIWinAPIP_h__INCLUDED
#pragma once


#include "..\WinAPI\Published.h"


#endif // DUI__DUIWinAPIP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\borderlayout.cpp ===
/***************************************************************************\
*
* File: BorderLayout.cpp
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Layout.h"
#include "BorderLayout.h"

using namespace DirectUI;

typedef HRESULT (*PfnBorderLayoutChildCallback)(DuiElement * peChild, int iLayoutPos, void * pData);

struct LayoutData
{
    DirectUI::Rectangle rcLayout;
    DuiLayout::UpdateBoundsHint * pubh;
    DuiBorderLayout * pLayout;
    DuiBorderLayoutSpacing * pSpacing;
};

struct DesiredSizeData
{
    SIZE sizeEdge;
    SIZE sizeClient;
    SIZE sizeMax;
    HDC hDC;
    DuiBorderLayout * pLayout;
    DuiBorderLayoutSpacing * pSpacing;
};


//
// This function enumerates the children in semantic order.  For the border
// layout, the ordering of the children is significant and is preserved, with
// one exception.  That is that the center child is enumerated last, no
// matter where it actually was in the child list.
//
HRESULT ForAllBorderLayoutChildren(DuiElement * peParent,
                                   void * pData,
                                   PfnBorderLayoutChildCallback pfnCallback)
{
    HRESULT hr = S_OK;
    int iLayoutPos = 0;
    DuiElement * peChild = NULL;
    DuiElement * peCenterChild = NULL;

    for (peChild = peParent->GetChild(DirectUI::Element::gcFirst | DirectUI::Element::gcLayoutOnly);
         peChild != NULL;
         peChild = peChild->GetSibling(DirectUI::Element::gsNext | DirectUI::Element::gsLayoutOnly))
    {
        //
        // Get the layout position for this child.
        //
        iLayoutPos = peChild->GetLayoutPos(); 
        ASSERT_(iLayoutPos == DirectUI::Layout::lpAuto ||
                iLayoutPos == BLP_Left ||
                iLayoutPos == BLP_Top ||
                iLayoutPos == BLP_Right ||
                iLayoutPos == BLP_Bottom ||
                iLayoutPos == BLP_Center,
                "Invalid layout position!");

        if (iLayoutPos == BLP_Center) {
            //
            // We have to process the center element last.  Its an error to have more than one
            // center element.
            //
            ASSERT_(peCenterChild == NULL, "Can't have more than one center child!");
            peCenterChild = peChild;
        } else {
            hr = pfnCallback(peChild, iLayoutPos, pData);

            //
            // The callback can return S_FALSE to terminate the loop, while still
            // returning SUCCESS to the caller.  All failures terminate the loop
            // as well.
            //
            if (hr != S_OK) {
                break;
            }
        }

    }

    //
    // If we successfully completed the loop, finish up by processing the
    // center child, if any.
    //
    if (hr == S_OK && peCenterChild != NULL) {
        hr = pfnCallback(peCenterChild, BLP_Center, pData);
    }

    //
    // Don't return S_FALSE to the caller.  This is only an internal
    // implementation detail!
    //
    if(hr == S_FALSE)
    {
        hr = S_OK;
    }

    return hr;
}


/***************************************************************************\
*****************************************************************************
*
* class DuiBorderLayout
*
*****************************************************************************
\***************************************************************************/


//
// Definition
//
IMPLEMENT_GUTS_DirectUI__BorderLayout(DuiBorderLayout, DuiLayout);

//------------------------------------------------------------------------------
DuiBorderLayout::DuiBorderLayout( unsigned long hgap, unsigned long vgap)
{
    m_vgap = vgap;
    m_hgap = hgap;
}

//------------------------------------------------------------------------------
DuiBorderLayout::~DuiBorderLayout()
{
}

//------------------------------------------------------------------------------
HRESULT
DuiBorderLayout::DoLayout(
    IN  DuiElement * pec, 
    IN  int cx, 
    IN  int cy,
    IN  UpdateBoundsHint * pubh)
{
    HRESULT hr = S_OK;
    LayoutData data;

    //
    // Initialize the output parameters, and validate the input parameters.
    //
    if (pec == NULL ||
        cx < 0 ||
        cy < 0 ||
        pubh == NULL) {
        return E_INVALIDARG;
    }

    data.rcLayout.x = 0;
    data.rcLayout.y = 0;
    data.rcLayout.width = cx;
    data.rcLayout.height = cy;
    data.pubh = pubh;
    data.pLayout = this;
    data.pSpacing = NULL;

    //
    // Spin through each of the children and lay them out.
    //
    hr = ForAllBorderLayoutChildren(pec, (void*) &data, DoChildLayout);
	if(SUCCEEDED(hr))
	{
		//
		// Don't report early termination (when hr == S_FALSE)!
		//
		hr = S_OK;
	}
    return hr;
}

//------------------------------------------------------------------------------
HRESULT DuiBorderLayout::DoChildLayout(
    DuiElement * peChild,
    int iLayoutPos,
    void * pData)
{
    HRESULT hr = S_OK;
    LayoutData * pLayoutData = (LayoutData*)pData;

    //
    // Get the desired size of this child.  This was previously set during
    // the UpdateDesiredSize() function.
    //
    const SIZE * psizeChild = peChild->GetDesiredSize();
    if (psizeChild == NULL) {
        return E_FAIL;
    }
    SIZE sizeChild = *psizeChild;

    switch(iLayoutPos)
    {
        case DirectUI::Layout::lpAuto:
        case BLP_Left:
            peChild->UpdateBounds(pLayoutData->rcLayout.x /*+ m_hgap*/,
                                  pLayoutData->rcLayout.y /*+ m_vgap*/,
                                  sizeChild.cx,
                                  pLayoutData->rcLayout.height /*- 2*m_vgap*/,
                                  pLayoutData->pubh);
            pLayoutData->rcLayout.x += /*m_hgap + */sizeChild.cx;
            pLayoutData->rcLayout.width -= /*m_hgap + */sizeChild.cx;
            break;

        case BLP_Right:
            peChild->UpdateBounds(pLayoutData->rcLayout.x + pLayoutData->rcLayout.width /*- m_hgap*/ - sizeChild.cx,
                                  pLayoutData->rcLayout.y /*+ m_vgap*/,
                                  sizeChild.cx,
                                  pLayoutData->rcLayout.height /*- 2*m_vgap*/,
                                  pLayoutData->pubh);
            pLayoutData->rcLayout.width -= /*m_hgap +*/ sizeChild.cx;
            break;

        case BLP_Top:
            peChild->UpdateBounds(pLayoutData->rcLayout.x /*+ m_hgap*/,
                                  pLayoutData->rcLayout.y /*+ m_vgap*/,
                                  pLayoutData->rcLayout.width /*- 2*m_hgap*/,
                                  sizeChild.cy,
                                  pLayoutData->pubh);
            pLayoutData->rcLayout.y += /*m_vgap */+ sizeChild.cy;
            pLayoutData->rcLayout.height -= /*m_vgap */+ sizeChild.cy;
            break;

        case BLP_Bottom:
            peChild->UpdateBounds(pLayoutData->rcLayout.x /*+ m_hgap*/,
                                  pLayoutData->rcLayout.y + pLayoutData->rcLayout.height /*- m_vgap*/ - sizeChild.cy,
                                  pLayoutData->rcLayout.width /*- 2*m_hgap*/,
                                  sizeChild.cy,
                                  pLayoutData->pubh);
            pLayoutData->rcLayout.height -= /*m_vgap + */sizeChild.cy;
            break;

        case BLP_Center:
            peChild->UpdateBounds(pLayoutData->rcLayout.x/* + m_hgap*/,
                                  pLayoutData->rcLayout.y /*+ m_vgap*/,
                                  pLayoutData->rcLayout.width /*- m_hgap*/,
                                  pLayoutData->rcLayout.height/* - m_hgap*/,
                                  pLayoutData->pubh);
            pLayoutData->rcLayout.x = 0;
            pLayoutData->rcLayout.width = 0;
            pLayoutData->rcLayout.y = 0;
            pLayoutData->rcLayout.height = 0;
            break;
    }

    //
    // When the position left after the child is completely empty in both
    // dimensions, we are done.
    //
    ASSERT(pLayoutData->rcLayout.width >= 0 && pLayoutData->rcLayout.height >= 0);
    if (SUCCEEDED(hr) && pLayoutData->rcLayout.width == 0 && pLayoutData->rcLayout.height == 0) {
        hr = S_FALSE;
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT
DuiBorderLayout::UpdateDesiredSize(
    IN  DuiElement * pec,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC, 
    OUT SIZE * psize)
{
    HRESULT hr = S_OK;
    DesiredSizeData data;

    //
    // Initialize the output parameters, and validate the input parameters.
    //
    if (psize != NULL) {
        psize->cx = 0;
        psize->cy = 0;
    }
    if (pec == NULL ||
        cxConstraint < 0 ||
        cyConstraint < 0 ||
        hDC == NULL ||
        psize == NULL) {
        return E_INVALIDARG;
    }

    data.sizeMax.cx = cxConstraint;
    data.sizeMax.cy = cyConstraint;
    data.sizeClient.cx = 0;
    data.sizeClient.cy = 0;
    data.sizeEdge.cx = 0;
    data.sizeEdge.cy = 0;
    data.hDC = hDC;
    data.pLayout = this;
    data.pSpacing = NULL;

    //
    // Spin through each of the children and factor in their desired size.
    //
    hr = ForAllBorderLayoutChildren(pec, (void*) &data, UpdateChildDesiredSize);

    //
    // Return the size needed to composit our children to their desired sizes.
    //
    if (SUCCEEDED(hr)) {
        psize->cx = data.sizeEdge.cx + data.sizeClient.cx;
        psize->cy = data.sizeEdge.cy + data.sizeClient.cy;
    }

    return hr;
}


//------------------------------------------------------------------------------
HRESULT DuiBorderLayout::UpdateChildDesiredSize(
    DuiElement * peChild,
    int iLayoutPos,
    void * pData)
{
    HRESULT hr = S_OK;
    DesiredSizeData * pDesiredSizeData = (DesiredSizeData*)pData;
    SIZE sizeChild = {0, 0};

    //
    // Let this child specify the dimensions it wants to be.
    //
    hr = peChild->UpdateDesiredSize(pDesiredSizeData->sizeMax.cx,
                                    pDesiredSizeData->sizeMax.cy,
                                    pDesiredSizeData->hDC,
                                    &sizeChild);

    if (SUCCEEDED(hr)) {
        switch(iLayoutPos)
        {
        case DirectUI::Layout::lpAuto:
        case BLP_Left:
        case BLP_Right:
            pDesiredSizeData->sizeEdge.cx += sizeChild.cx;
            pDesiredSizeData->sizeClient.cx -= min(pDesiredSizeData->sizeClient.cx, sizeChild.cx);
            pDesiredSizeData->sizeClient.cy = max(pDesiredSizeData->sizeClient.cy, sizeChild.cy);
            pDesiredSizeData->sizeMax.cx -= sizeChild.cx;
            break;

        case BLP_Top:
        case BLP_Bottom:
            pDesiredSizeData->sizeEdge.cy += sizeChild.cy;
            pDesiredSizeData->sizeClient.cy -= min(pDesiredSizeData->sizeClient.cy, sizeChild.cy);
            pDesiredSizeData->sizeClient.cx = max(pDesiredSizeData->sizeClient.cx, sizeChild.cx);
            pDesiredSizeData->sizeMax.cy -= sizeChild.cy;
            break;

        case BLP_Center:
            pDesiredSizeData->sizeClient.cx = sizeChild.cx;
            pDesiredSizeData->sizeClient.cy = sizeChild.cy;

            //
            // After we lay out the center child, we shouldn't layout any
            // more children!  This is guaranteed by the enumerator, but its
            // tidy to remind ourselves of that here.
            //
            pDesiredSizeData->sizeMax.cx = 0;
            pDesiredSizeData->sizeMax.cy = 0;
            break;
        }
    }

    //
    // No child is allowed to violate the constraints.  Therefore, the size
    // remaining should never be negative.
    //
    ASSERT_(pDesiredSizeData->sizeMax.cx >= 0 && pDesiredSizeData->sizeMax.cy >= 0, "Invalid size remaining!");
    
    //
    // When the size left after the child is completely empty in both
    // dimensions, we are done.
    //
    if (SUCCEEDED(hr) && pDesiredSizeData->sizeMax.cx == 0 && pDesiredSizeData->sizeMax.cy == 0) {
        hr = S_FALSE;
    }

    return hr;
}



/***************************************************************************\
*
* External API implementation (validation layer)
*
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuiBorderLayout::ApiDoLayout(
    IN  DirectUI::Element * pece,
    IN  int cx,
    IN  int cy,
    IN  void * pvCookie)
{ 
    HRESULT hr;
    DuiLayout::UpdateBoundsHint * pubh = NULL;
    DuiElement * pec = NULL;

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_READ_PTR_OR_NULL(pvCookie);

    pubh = DuiLayout::UpdateBoundsHint::InternalCast(pvCookie);
    pec = DuiElement::InternalCast(pece);

    hr = DoLayout(pec, cx, cy, pubh);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiBorderLayout::ApiUpdateDesiredSize(
    IN  DirectUI::Element * pece,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC,
    OUT SIZE * psize)
{
    HRESULT hr;
    DuiElement * pec = NULL;

    if (hDC == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_WRITE_PTR_(psize, sizeof(SIZE));

    pec = DuiElement::InternalCast(pece);

    hr = UpdateDesiredSize(pec, cxConstraint, cyConstraint, hDC, psize);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:
    
    return hr;
}

/***************************************************************************\
*****************************************************************************
*
* class DuiBorderLayoutSpacing
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuiBorderLayoutSpacing::DuiBorderLayoutSpacing(IN DuiBorderLayout * pLayout,
                                               IN DuiElement * pec)
{
    DuiElement * peChild = NULL;

    
    UNREFERENCED_PARAMETER(pLayout);

    m_cHorizontalSpacing = 0;
    m_rgHorizontalSpacing = NULL;
    m_cVerticalSpacing = 0;
    m_rgVerticalSpacing = NULL;

    for (peChild = pec->GetChild(DirectUI::Element::gcFirst | DirectUI::Element::gcLayoutOnly);
         peChild != NULL;
         peChild = peChild->GetSibling(DirectUI::Element::gsNext | DirectUI::Element::gsLayoutOnly))
    {
        
    }
}

//------------------------------------------------------------------------------
DuiBorderLayoutSpacing::~DuiBorderLayoutSpacing()
{
    if (m_rgHorizontalSpacing != NULL) {
        delete[] m_rgHorizontalSpacing;
        m_rgVerticalSpacing = NULL;
    }

    if (m_rgVerticalSpacing != NULL) {
        delete[] m_rgVerticalSpacing;
        m_rgVerticalSpacing = NULL;
    }
}

//------------------------------------------------------------------------------
unsigned long DuiBorderLayoutSpacing::GetHorizontalSpacing(unsigned long i)
{
    if (i < m_cHorizontalSpacing) {
        return m_rgHorizontalSpacing[i];
    }

    return 0;
}

//------------------------------------------------------------------------------
unsigned long DuiBorderLayoutSpacing::GetVerticalSpacing(unsigned long i)
{
    if (i < m_cVerticalSpacing) {
        return m_rgVerticalSpacing[i];
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\layout.h ===
/***************************************************************************\
*
* File: Layout.h
*
* Description:
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  10/9/2000: MarkFi:        Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUILAYOUT__Layout_h__INCLUDED)
#define DUILAYOUT__Layout_h__INCLUDED
#pragma once

//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//

#include <DUIBaseP.h>
#include <DUIObjectAPIP.h>
#include <DUICoreP.h>


//
// Project-specific prompt
//

#if DBG

#define PROMPT_INVALID(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUI/Layout Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else  // DBG

#define PROMPT_INVALID(comment) ((void) 0)

#endif // DBG


#endif // DUILAYOUT__Layout_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\gridlayout.h ===
/***************************************************************************\
*
* File: GridLayout.h
*
* Description:
*
* History:
*  10/9/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUILAYOUT__GridLayout_h__INCLUDED)
#define DUILAYOUT__GridLayout_h__INCLUDED
#pragma once


/***************************************************************************\
*
* class DuiGridLayout
*
\***************************************************************************/

class DuiGridLayout :
        public DirectUI::GridLayoutImpl<DuiGridLayout, DuiLayout>
{
// Construction
public:
            DuiGridLayout() { }
    virtual ~DuiGridLayout() { }

// API Layer
public:
    dapi    HRESULT     ApiDoLayout(IN DirectUI::Element * pec, IN int cx, IN int cy, IN void * pvCookie);  /* Virtual */
    dapi    HRESULT     ApiUpdateDesiredSize(IN DirectUI::Element * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);  /* Virtual */


// Operations
public:
    virtual HRESULT     DoLayout(IN DuiElement * pec, IN int cx, IN int cy, IN DuiLayout::UpdateBoundsHint * pubh);
    virtual HRESULT     UpdateDesiredSize(IN DuiElement * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);
};

#endif // DUILAYOUT__GridLayout_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\published.h ===
/***************************************************************************\
*
* File: Published.h
*
* Description:
* Available headers for other internal projects
*
* Published.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUI project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.
*
* Definitions that are not exposed through this file are considered project
* specific implementation details and should not used in other projects.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUILAYOUT__Published_h__INCLUDED)
#define DUILAYOUT__Published_h__INCLUDED
#pragma once


#include "GridLayout.h"
#include "BorderLayout.h"


#endif // DUILAYOUT__Published_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\gridlayout.cpp ===
/***************************************************************************\
*
* File: GridLayout.cpp
*
* Description:
*
* History:
*  10/9/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Layout.h"
#include "GridLayout.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiGridLayout
*
*****************************************************************************
\***************************************************************************/


//
// Definition
//

IMPLEMENT_GUTS_DirectUI__GridLayout(DuiGridLayout, DuiLayout)


//------------------------------------------------------------------------------
HRESULT
DuiGridLayout::DoLayout(
    IN  DuiElement * pec, 
    IN  int cx, 
    IN  int cy,
    IN  DuiLayout::UpdateBoundsHint * pubh)
{
    UNREFERENCED_PARAMETER(pubh);

    DuiElement * pe = pec->GetChild(DirectUI::Element::gcFirst | DirectUI::Element::gcLayoutOnly);
    UINT nQuad = 0;
    DirectUI::Rectangle pr = { 0 };


    while ((pe != NULL) && (nQuad < 4)) {

        switch (nQuad)
        {
        case 0:
            pr.x = 0; pr.y = 0; pr.width = cx / 2, pr.height = cy / 2;
            break;

        case 1:
            pr.x = cx / 2; pr.y = cy / 2; pr.width = cx / 2, pr.height = cy / 2;
            break;

        case 2:
            pr.x = cx / 2; pr.y = 0; pr.width = cx / 2, pr.height = cy / 2;
            break;

        case 3:
            pr.x = 0; pr.y = cy / 2; pr.width = cx / 2, pr.height = cy / 2;
            break;
        }


        pe->UpdateBounds(pr.x, pr.y, pr.width, pr.height, pubh);


        nQuad++;
        pe = pe->GetSibling(DirectUI::Element::gsNext | DirectUI::Element::gsLayoutOnly);
    }


    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuiGridLayout::UpdateDesiredSize(
    IN  DuiElement * pec,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC, 
    OUT SIZE * psize)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(cxConstraint);
    UNREFERENCED_PARAMETER(cyConstraint);
    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(psize);


    psize->cx = cxConstraint;
    psize->cy = cyConstraint;


    return S_OK;
}


/***************************************************************************\
*
* External API implementation (validation layer)
*
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuiGridLayout::ApiDoLayout(
    IN  DirectUI::Element * pece,
    IN  int cx,
    IN  int cy,
    IN  void * pvCookie)
{ 
    HRESULT hr;
    DuiLayout::UpdateBoundsHint * pubh = NULL;
    DuiElement * pec = NULL;

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_READ_PTR_OR_NULL(pvCookie);

    pubh = DuiLayout::UpdateBoundsHint::InternalCast(pvCookie);
    pec = DuiElement::InternalCast(pece);

    hr = DoLayout(pec, cx, cy, pubh);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuiGridLayout::ApiUpdateDesiredSize(
    IN  DirectUI::Element * pece,
    IN  int cxConstraint, 
    IN  int cyConstraint, 
    IN  HDC hDC,
    OUT SIZE * psize)
{
    HRESULT hr;
    DuiElement * pec = NULL;

    if (hDC == NULL) {
        hr = E_INVALIDARG;
        goto Failure;
    }

    VALIDATE_WRITE_PTR(pece);
    VALIDATE_WRITE_PTR_(psize, sizeof(SIZE));

    pec = DuiElement::InternalCast(pece);

    hr = UpdateDesiredSize(pec, cxConstraint, cyConstraint, hDC, psize);
    if (FAILED(hr)) {
        goto Failure;
    }

    return S_OK;


Failure:
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\objectapi\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__StdAfx_h__INCLUDED)
#define DUIBASE__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUIBASE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\borderlayout.h ===
/***************************************************************************\
*
* File: BorderLayout.h
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUILAYOUT__BorderLayout_h__INCLUDED)
#define DUILAYOUT__BorderLayout_h__INCLUDED
#pragma once

#define BLP_Left        0
#define BLP_Top         1
#define BLP_Right       2
#define BLP_Bottom      3
#define BLP_Center      4

/***************************************************************************\
*
* class DuiBorderLayout
*
\***************************************************************************/

class DuiBorderLayout :
    public DirectUI::BorderLayoutImpl<DuiBorderLayout, DuiLayout>
{
// Construction
public:
            DuiBorderLayout(unsigned long gapVert = 5, unsigned long gapHorz = 5);
    virtual ~DuiBorderLayout();

// API Layer
public:
    dapi    HRESULT     ApiDoLayout(IN DirectUI::Element * pec, IN int cx, IN int cy, IN void * pvCookie);  /* Virtual */
    dapi    HRESULT     ApiUpdateDesiredSize(IN DirectUI::Element * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);  /* Virtual */


// Operations
public:
    virtual HRESULT     DoLayout(IN DuiElement * pec, IN int cx, IN int cy, IN UpdateBoundsHint * pubh);
    virtual HRESULT     UpdateDesiredSize(IN DuiElement * pec, IN int cxConstraint, IN int cyConstraint, IN HDC hDC, OUT SIZE * psize);

// Helpers
protected:
    static HRESULT DoChildLayout(DuiElement * peChild, int iLayoutPos, void * pData);
    static HRESULT UpdateChildDesiredSize(DuiElement * peChild, int iLayoutPos, void * pData);

private:
    unsigned long m_hgap;
    unsigned long m_vgap;
};


/***************************************************************************\
*
* class DuiBorderLayoutSpacing
*
\***************************************************************************/

class DuiBorderLayoutSpacing
{
public:
    DuiBorderLayoutSpacing(IN DuiBorderLayout * pLayout, IN DuiElement * pec);
    ~DuiBorderLayoutSpacing();

    unsigned long GetHorizontalSpacing(unsigned long i);
    unsigned long GetVerticalSpacing(unsigned long i);

private:
    unsigned long m_cHorizontalSpacing;
    unsigned long * m_rgHorizontalSpacing;
    unsigned long m_cVerticalSpacing;
    unsigned long * m_rgVerticalSpacing;
};

#endif // DUILAYOUT__BorderLayout_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\objectapi\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: DirectUI.gidl
    Gidl.exe DirectUI.gidl DirectUI.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml

$(O)\super.cpp: DirectUI.gidl
    Gidl.exe DirectUI.gidl DirectUI.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\winapi\published.h ===
/***************************************************************************\
*
* File: Published.h
*
* Description:
* Available headers for other internal projects
*
* Published.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUI project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.
*
* Definitions that are not exposed through this file are considered project
* specific implementation details and should not used in other projects.
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIWINAPI__Published_h__INCLUDED)
#define DUIWINAPI__Published_h__INCLUDED
#pragma once


#endif // DUIWINAPI__Published_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\objectapi\objectapi.h ===
/***************************************************************************\
*
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIOBJECTAPI__ObjectAPI_h__INCLUDED)
#define DUIOBJECTAPI__ObjectAPI_h__INCLUDED
#pragma once


//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//

#include <DUIBaseP.h>


#endif // DUIOBJECTAPI__ObjectAPI_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\layout\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  10/9/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUILAYOUT__StdAfx_h__INCLUDED)
#define DUILAYOUT__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUILAYOUT__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\objectapi\published.h ===
/***************************************************************************\
*
* File: Published.h
*
* Description:
* Available headers for other internal projects
*
* Published.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUI project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.
*
* Definitions that are not exposed through this file are considered project
* specific implementation details and should not used in other projects.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIOBJECTAPI__Published_h__INCLUDED)
#define DUIOBJECTAPI__Published_h__INCLUDED
#pragma once


#include "Stub.h"
#include "Super.h"


#endif // DUIOBJECTAPI__Published_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\winapi\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* Description:
* External dependencies
*
* This includes all project-specific external headers that will be precompiled
* All external headers must be available via the include path
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIWINAPI__StdAfx_h__INCLUDED)
#define DUIWINAPI__StdAfx_h__INCLUDED
#pragma once


#include "CommonStdAfx.h"  // Include globally used headers


#endif // DUIWINAPI__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\winapi\apistubs.cpp ===
/***************************************************************************\
*
* File: ApiStubs.cpp
*
* Description:
* ApiStubs.cpp exposes all public DirectUI flat API's in the Win32 world.
*
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#include "stdafx.h"
#include "WinAPI.h"


/***************************************************************************\
*****************************************************************************
*
* DirectUI Flat API
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
HRESULT
DirectUIThreadInit()
{
    return DuiThread::Init();
}


//------------------------------------------------------------------------------
HRESULT
DirectUIThreadUnInit()
{
    return DuiThread::UnInit();
}


//------------------------------------------------------------------------------
void
DirectUIPumpMessages()
{
    DuiThread::PumpMessages();
}


/***************************************************************************\
*
* Value APIs
*
\***************************************************************************/


//------------------------------------------------------------------------------
DirectUI::Value *
DirectUIValueBuild(
    IN  int nType,
    IN  void * v)
{
    //
    // Cast to internal versions
    //

    switch (nType)
    {
    case DirectUI::Value::tLayout:
        v = DuiLayout::InternalCast(reinterpret_cast<DirectUI::Layout *> (v));
        break;
    }


    return DuiValue::ExternalCast(DuiValue::Build(nType, v));
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueAddRef(
    IN  DirectUI::Value * pve)
{
    HRESULT hr = S_OK;

    DuiValue * pv = NULL;

    VALIDATE_WRITE_PTR_(pve, sizeof(DuiValue));

    pv = DuiValue::InternalCast(pve);

    pv->AddRef();

Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueRelease(
    IN  DirectUI::Value * pve)
{
    HRESULT hr = S_OK;

    DuiValue * pv = NULL;

    VALIDATE_WRITE_PTR_(pve, sizeof(DuiValue));

    pv = DuiValue::InternalCast(pve);

    pv->Release();

Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueGetType(
    IN  DirectUI::Value * pve,
    OUT int * pRes)
{
    HRESULT hr = S_OK;

    DuiValue * pv = NULL;

    VALIDATE_READ_PTR_(pve, sizeof(DuiValue));

    pv = DuiValue::InternalCast(pve);

    *pRes = pv->GetType();

Failure:
    
    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueGetData(
    IN  DirectUI::Value * pve, 
    IN  int nType,
    OUT void ** pRes)
{
    HRESULT hr = S_OK;

    DuiValue * pv  = NULL;

    VALIDATE_READ_PTR_(pve, sizeof(DuiValue));

    pv = DuiValue::InternalCast(pve);

    *pRes = pv->GetData(nType);

    switch (nType)
    {
    case DirectUI::Value::tLayout:
        *pRes = DuiLayout::ExternalCast(reinterpret_cast<DuiLayout *> (*pRes));
        break;
    }

Failure:
    
    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueIsEqual(
    IN  DirectUI::Value * pve0, 
    IN  DirectUI::Value * pve1,
    OUT BOOL * pRes)
{
    HRESULT hr = S_OK;

    *pRes = FALSE;

    DuiValue * pv  = NULL;
    DuiValue * pvc = NULL;

    VALIDATE_READ_PTR_(pve0, sizeof(DuiValue));
    VALIDATE_READ_PTR_(pve1, sizeof(DuiValue));

    pv  = DuiValue::InternalCast(pve0);
    pvc = DuiValue::InternalCast(pve1);

    *pRes = pv->IsEqual(pvc);

Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIValueToString(
    IN  DirectUI::Value * pve, 
    IN  LPWSTR psz, 
    IN  UINT c)
{
    HRESULT hr = S_OK;

    DuiValue * pv = NULL;

    VALIDATE_READ_PTR_(pve, sizeof(DuiValue));
    VALIDATE_STRINGW_PTR(psz, c);

    pv = DuiValue::InternalCast(pve);

    pv->ToString(psz, c);

Failure:

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DirectUIElementStartDefer()
{
    return DuiElement::StartDefer();
}


//------------------------------------------------------------------------------
HRESULT
DirectUIElementEndDefer()
{
    return DuiElement::EndDefer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\winapi\winapi.h ===
/***************************************************************************\
*
* File: WinAPI.h
*
* Description:
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  9/13/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIWINAPI__WinAPI_h__INCLUDED)
#define DUIWINAPI__WinAPI_h__INCLUDED
#pragma once


//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//

#include <DUIBaseP.h>
#include <DUIObjectAPIP.h>
#include <DUICoreP.h>


//
// Project-specific prompt
//

#if DBG

#define PROMPT_INVALID(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUI/WinAPI Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else  // DBG

#define PROMPT_INVALID(comment) ((void) 0)

#endif // DBG


#endif // DUIWINAPI__WinAPI_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\test\sources.inc ===
!IF 0

    Shared sources.inc file for Test projects.

!ENDIF

# Do not use NTBUILD's Warning.h pragmas, will treat all warnings as errors and use highest level (W4)
COMPILER_WARNINGS=

MSC_STDCALL=1
MSC_WARNING_LEVEL=/W4

USE_CRTDLL=1

INCLUDES=\
        $(WINDOWS_INC_PATH)\DUser;\
        $(BASEDIR)\windows\advcore\duser\inc\Public;\
        $(SHELL_INC_PATH);\
        $(SDK_INC_PATH)\gdiplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\test\suite\stdafx.h ===
/***************************************************************************\
*
* File: StdAfx.h
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUISUITE__StdAfx_h__INCLUDED)
#define DUISUITE__StdAfx_h__INCLUDED
#pragma once


// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser
#include <duser.h>

#include <DirectUI.h>


#endif // DUISUITE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\test\suite\suite.h ===
/***************************************************************************\
*
* File: Suite.h
*
* Description:
* Test suite
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#define ASSERT(c)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\inc\directui.h ===
/***************************************************************************\
*
* File: DirectUI.h
*
* Description:
* Common include for DirectUI
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUI__DirectUI_h__INCLUDED)
#define DUI__DirectUI_h__INCLUDED
#pragma once


#ifdef DIRECTUI_EXPORTS
#define DIRECTUI_API    extern "C" 
#else
#define DIRECTUI_API    extern "C" __declspec(dllimport)
#endif


#ifdef __cplusplus


/***************************************************************************\
*****************************************************************************
*
* DirectUI Error codes
*
* If any DUI API can fail to an abnormal program event, the API's return value
* is always HRESULT. Any API that isn't part of this category either returns
* void or any other data type.
*
* All erroneous program events (internal invalid state or invalid parameters)
* are handled by asserts.
*
* Any creation/destruction method is transaction based for errors (upon
* failure, all changes/memory are backed out as if the call never happened).
* Where possible, other methods use transaction based error handling.
* If not possible, upon an error, the first error is recorded and the method
* will recover and return the error (partial error).
*
*****************************************************************************
\***************************************************************************/

/*
 *
 */
#define DUI_S_NOCHANGE                  MAKE_DUSUCCESS(500)

/*
 *
 */
#define DUI_E_USERFAILURE               MAKE_DUERROR(1001)

/*
 *
 */
#define DUI_E_NOCONTEXTSTORE            MAKE_DUERROR(1002)

/*
 *
 */
#define DUI_E_NODEFERTABLE              MAKE_DUERROR(1003)



/***************************************************************************\
*****************************************************************************
*
* DirectUI flat APIs. For use by wrappers only.
*
*****************************************************************************
\***************************************************************************/

//
// Forward declare types
//

namespace DirectUI
{
class Value;
class Element;
class Layout;
}

DIRECTUI_API    HRESULT     DirectUIThreadInit();
DIRECTUI_API    HRESULT     DirectUIThreadUnInit();
DIRECTUI_API    void        DirectUIPumpMessages();

DIRECTUI_API    DirectUI::Value *
                            DirectUIValueBuild(IN int nType, IN void * v);
DIRECTUI_API    HRESULT     DirectUIValueAddRef(IN DirectUI::Value * pv);
DIRECTUI_API    HRESULT     DirectUIValueRelease(IN DirectUI::Value * pv);
DIRECTUI_API    HRESULT     DirectUIValueGetType(IN DirectUI::Value * pv, OUT int * pRes);
DIRECTUI_API    HRESULT     DirectUIValueGetData(IN DirectUI::Value * pv, IN int nType, OUT void ** pRes);
DIRECTUI_API    HRESULT     DirectUIValueIsEqual(IN DirectUI::Value * pv0, IN DirectUI::Value * pv1, OUT BOOL * pRes);
DIRECTUI_API    HRESULT     DirectUIValueToString(IN DirectUI::Value * pv, IN LPWSTR psz, IN UINT c);

DIRECTUI_API    HRESULT     DirectUIElementStartDefer();
DIRECTUI_API    HRESULT     DirectUIElementEndDefer();

DIRECTUI_API    HRESULT     DirectUITestInternal(IN UINT nTest);


/***************************************************************************\
*****************************************************************************
*
* DirectUI Class-based Layer
*
*****************************************************************************
\***************************************************************************/


namespace DirectUI
{


/***************************************************************************\
*
* Registration operations
*
\***************************************************************************/

typedef UINT    UID;

typedef UINT    ClassID;
typedef UINT    PropertyID;
//typedef UINT    EventID;


/***************************************************************************\
*
* Thread/Context operations
*
\***************************************************************************/

class Thread
{
// Operations
public:
    
    static  HRESULT     Init()          { return DirectUIThreadInit(); }
    static  HRESULT     UnInit()        { return DirectUIThreadUnInit(); }
    static  void        PumpMessages()  { DirectUIPumpMessages(); }
};


//------------------------------------------------------------------------------
inline void   
Using(IN LPCWSTR pszModule)
{
    LoadLibraryW(pszModule);
}


/***************************************************************************\
*
* Values
*
\***************************************************************************/


struct SubDivValue
{
    UINT        nUnsetMask;
};


//
// RectangleSD Value (Value::tRectangleSD)
//

struct RectangleSD : SubDivValue
{
    enum EUnsetMask
    {
        unX         = 0x00000001,
        unY         = 0x00000002,
        unWidth     = 0x00000004,
        unHeight    = 0x00000008
    };

    int         x;
    int         y;
    int         width;
    int         height;
};


//
// Rectangle Value (Value::tRectangle)
//

struct Rectangle
{
    int         x;
    int         y;
    int         width;
    int         height;
};


//
// Thickness Value (Value::tThickness)
//

struct Thickness
{
    int         left;
    int         top;
    int         right;
    int         bottom;
};


//
// Font Value (Value::tFont)
//

struct Font
{
    enum EFont
    {
        //
        // Font Styles
        //

        fsNone          = 0x00000000,
        fsItalic        = 0x00000001,
        fsUnderline     = 0x00000002,
        fsStrikeOut     = 0x00000004,

        //
        // Font Weights
        //

        fwDontCare      = 0,
        fwThin          = 100,
        fwExtraLight    = 200,
        fwLight         = 300,
        fwNormal        = 400,
        fwMedium        = 500,
        fwSemiBold      = 600,
        fwBold          = 700,
        fwExtraBold     = 800,
        fwHeavy         = 900,
    };

    WCHAR       szFace[LF_FACESIZE];
    int         dWeight;
    int         dSize;
    UINT        nStyle;
};


//
// Color Value (Value::tColor)
//

struct Color
{
    enum EType
    {
        tHGradient = 0,
        tVGradient,
        tRadialGradient,
        tPointGradient,
        tSolid
    };

    BYTE        nType;
    COLORREF    cr;
    COLORREF    crSec;
    USHORT      x;
    USHORT      y;
};


class Value
{
// Operations
public:
    enum EType
    {
        tUnset          = -1,       // Standard types
        tNull,
        tInt,
        tBool,
        tElementRef,
        tLayout,
        tRectangle,
        tThickness,
        tSize,

        tMinSD          = 16384,
        tRectangleSD,               // Subdivided types
    };

    static  Value *     BuildInt(int v)     { return DirectUIValueBuild(tInt, IntToPtr(v)); }
    static  Value *     BuildBool(BOOL v)   { return DirectUIValueBuild(tBool, IntToPtr(v)); }
    static  Value *     BuildElementRef(Element * v) {
                                                return DirectUIValueBuild(tElementRef, reinterpret_cast<void *> (v));
                                            }
    static  Value *     BuildLayout(Layout * v) {
                                                return DirectUIValueBuild(tLayout, reinterpret_cast<void *> (v));
                                            }
    static  Value *     BuildRectangle(int x, int y, int w, int h) {
                                                Rectangle rc = { x, y, w, h };
                                                return DirectUIValueBuild(tRectangle, &rc);
                                            }
    static  Value *     BuildThickness(int l, int t, int r, int b) {
                                                Thickness th = { l, t, r, b };
                                                return DirectUIValueBuild(tThickness, &th);
                                            }
    static  Value *     BuildSize(int cx, int cy) {
                                                SIZE s = { cx, cy };
                                                return DirectUIValueBuild(tSize, &s);
                                            }
    static  Value *     BuildRectangleSD(UINT um, int x, int y, int w, int h) {
                                                RectangleSD rcsd;
                                                rcsd.nUnsetMask = um; 
                                                rcsd.x = x; rcsd.y = y; rcsd.width = w; rcsd.height = h;;
                                                return DirectUIValueBuild(tRectangleSD, &rcsd);
                                            }

    inline  void        AddRef()            { DirectUIValueAddRef(this); }
    inline  void        Release()           { DirectUIValueRelease(this); }

    inline  int         GetType()           { int t; DirectUIValueGetType(this, &t); return t; }

    inline  int         GetInt()            { void * v; DirectUIValueGetData(this, tInt, &v); return PtrToInt(v); }
    inline  BOOL        GetBool()           { void * v; DirectUIValueGetData(this, tBool, &v); return (BOOL) PtrToInt(v); }
    inline  Element *   GetElement()        { void * v; DirectUIValueGetData(this, tElementRef, &v); return reinterpret_cast<Element *> (v); }
    inline  Layout *    GetLayout()         { void * v; DirectUIValueGetData(this, tLayout, &v); return reinterpret_cast<Layout *> (v); }
    inline  const Rectangle *
                        GetRectangle()      { void * v; DirectUIValueGetData(this, tRectangle, &v); return reinterpret_cast<const Rectangle *> (v); }
    inline  const Thickness *
                        GetThickness()      { void * v; DirectUIValueGetData(this, tThickness, &v); return reinterpret_cast<const Thickness *> (v); }
    inline  const SIZE * 
                        GetSize()           { void * v; DirectUIValueGetData(this, tSize, &v); return reinterpret_cast<const SIZE *> (v); }
    inline  const RectangleSD *
                        GetRectangleSD()    { void * v; DirectUIValueGetData(this, tRectangleSD, &v); return reinterpret_cast<const RectangleSD *> (v); }

    inline  BOOL        IsEqual(Value * pv) { BOOL fRes; DirectUIValueIsEqual(this, pv, &fRes); return fRes; }
    inline  LPWSTR      ToString(LPWSTR psz, UINT c) { 
                                                  DirectUIValueToString(this, psz, c); return psz; }
};


//------------------------------------------------------------------------------
inline COLORREF   
ARGB(
    IN BYTE a,
    IN BYTE r,
    IN BYTE g,
    IN BYTE b)
{
    return ((a << 24) | RGB(r, g, b));   // Current A values may be 255 (opaque) or 0 (transparent)
}


//------------------------------------------------------------------------------
inline COLORREF   
ORGB(
    IN BYTE r,
    IN BYTE g,
    IN BYTE b)
{
    return ARGB(255, r, g, b);           // Current A values may be 255 (opaque) or 0 (transparent)
}


/***************************************************************************\
*
* Metadata
*
\***************************************************************************/

typedef UINT    MUID;
typedef UINT    PUID;


typedef MUID    ElementMUID;
typedef MUID    LayoutMUID;

typedef MUID    PropertyMUID;
typedef MUID    MethodMUID;
typedef MUID    EventMUID;


typedef PUID    NamespacePUID;

typedef PUID    ElementPUID;
typedef PUID    LayoutPUID;

typedef PUID    PropertyPUID;
typedef PUID    MethodPUID;
typedef PUID    EventPUID;


#define DirectUIMakeNamespacePUID(nsidx) \
            ((DirectUI::NamespacePUID)(0x00FFFFFF | ((0xFF & nsidx) << 24)))
            

#define DirectUIMakeElementMUID(eidx) \
            ((DirectUI::ElementMUID)  (0xFF000FFF | 0x000000 | ((0x1FF & eidx) << 12)))

#define DirectUIMakeLayoutMUID(lidx) \
            ((DirectUI::LayoutMUID)   (0xFF000FFF | 0x200000 | ((0x1FF & lidx) << 12)))


#define DirectUIMakePropertyMUID(clmuid, pidx) \
            ((DirectUI::PropertyMUID) (0xFF000000 | (0xFFF000 & clmuid) | 0x000 | (0x1FF & pidx)))

#define DirectUIMakeMethodMUID(clmuid, midx) \
            ((DirectUI::MethodMUID)   (0xFF000000 | (0xFFF000 & clmuid) | 0x200 | (0x1FF & midx)))

#define DirectUIMakeEventMUID(clmuid, eidx) \
            ((DirectUI::EventMUID)    (0xFF000000 | (0xFFF000 & clmuid) | 0x400 | (0x1FF & eidx)))


inline  MUID MUIDFromPUID(IN PUID puid, OUT NamespacePUID * pnspuid) { if (pnspuid != NULL) { *pnspuid = 0x00FFFFFF | puid; } return (MUID)(0xFF000000 | puid); }
inline  PUID PUIDFromMUID(IN NamespacePUID nspuid, IN MUID muid) { return (PUID)(nspuid & muid); }


const NamespacePUID Namespace   = DirectUIMakeNamespacePUID(0);


struct PropertyInfo
{
// Enumerations
    enum EIndex
    {
        iLocal                      = 0x00000001,
        iSpecified                  = 0x00000002,
        iActual                     = 0x00000003,

        iIndexBits                  = 0x0FFFFFFF,

        iUpdateCache                = 0x10000000
    };

    enum EFlags
    {
        fLocalOnly                  = 0x00000001,
        fNormal                     = 0x00000002,
        fTriLevel                   = 0x00000003,

        fTypeBits                   = 0x00000003,

        fCascade                    = 0x00000004,
        fInherit                    = 0x00000008,
        fReadOnly                   = 0x00000010,
        fCached                     = 0x00000020    // Internal use only
    };

    enum EGroups
    {
        gAffectsDesiredSize         = 0x00000001,
        gAffectsParentDesiredSize   = 0x00000002,
        gAffectsLayout              = 0x00000004,
        gAffectsParentLayout        = 0x00000008,
        gAffectsDisplay             = 0x00000010
    };
};


/***************************************************************************\
*
* Construction
*
\***************************************************************************/

template <class T>
inline T * 
BuildElement()
{
    Element::ConstructInfo eci;
    ZeroMemory(&eci, sizeof(eci));

    eci.cbSize = sizeof(eci);

    return T::Build(&eci);
}


template <class T>
inline T *
BuildHWNDRoot(
    IN  HWND hParent,
    IN  BOOL fDblBuffer)
{
    HWNDRoot::ConstructInfo hrci;
    ZeroMemory(&hrci, sizeof(hrci));

    hrci.cbSize     = sizeof(hrci);
    hrci.hParent    = hParent;
    hrci.fDblBuffer = fDblBuffer;

    return T::Build(&hrci);
}

template <class T>
inline T * 
BuildLayout()
{
    return T::Build();
}


}  // namespace DirectUI


#else  // __cplusplus


#error C++ compilation required


#endif // __cplusplus


#endif // DUI__DirectUI_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\test\suite\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: ..\..\Engine\ObjectAPI\DirectUI.gidl
    Gidl.exe -I..\..\Engine\ObjectAPI DirectUI.gidl DirectUI.gh -dtarget=$(_BUILDARCH) -dproject=..\..\Suite.h -o$(O) -t$(NTMAKEENV)\Template.gml

$(O)\super.cpp: ..\..\Engine\ObjectAPI\DirectUI.gidl
    Gidl.exe -I..\..\Engine\ObjectAPI DirectUI.gidl DirectUI.gh -dtarget=$(_BUILDARCH) -dproject=..\..\Suite.h -o$(O) -t$(NTMAKEENV)\Template.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\bridgecp.cpp ===
// DUser.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "BridgeCP.h"
#include "Bridge.h"

/***************************************************************************\
*
* DllMain
*
* DllMain() is called after the CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if (!InitBridges()) {
            return FALSE;
        }
        break;
        
    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\test\suite\suite.cpp ===
/***************************************************************************\
*
* File: Suite.cpp
*
* Description:
* Test suite
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "suite.h"

#include "stub.h"      // GIDL declarations (impl in stub.cpp)

using namespace DirectUI;


//
// Yuck!  Remove me when we make these externally visible.
//
#define BLP_Left        0
#define BLP_Top         1
#define BLP_Right       2
#define BLP_Bottom      3
#define BLP_Center      4

LRESULT SuiteWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void MultiAdd(Element * peParent, UINT nCount, UINT nDepth);


//
// Main entry
//

int 
WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, 
    int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);


    HRESULT hr;

    //
    // Create top-level window
    //

    HWND hTop = NULL;

    // Make sure window class is registered
    WNDCLASSEXW wc;

    // Register host window class, if needed
    wc.cbSize = sizeof(WNDCLASSEX);

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"DUITopLevel", &wc)) {

        ZeroMemory(&wc, sizeof(wc));

        wc.cbSize        = sizeof(wc);
        wc.hInstance     = GetModuleHandleW(NULL);
        wc.hCursor       = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpszClassName = L"DUITopLevel";
        wc.lpfnWndProc   = SuiteWndProc;

        if (RegisterClassExW(&wc) == 0) {
            return 0;
        }
    }

    hTop = CreateWindowExW(0, L"DUITopLevel", L"Suite", WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                           0, 0, 0, 0, NULL, 0, NULL, NULL);

    if (hTop == NULL) {
        return 0;
    }


    //
    // Initialize thread
    //

    hr = Thread::Init();
    if (FAILED(hr)) {
        return 0;
    }


    //
    // Internal tests (all), plus init test classes
    //

    DirectUITestInternal(3);


    //
    // Setup
    //

    Element::StartDefer();



    HWNDRoot * phr = BuildHWNDRoot<HWNDRoot>(hTop, FALSE);

    SetWindowLongPtrW(hTop, GWLP_USERDATA, (LONG_PTR)phr);
    SetWindowPos(hTop, NULL, 100, 100, 500, 500, SWP_NOACTIVATE);
    ShowWindow(hTop, SW_SHOWNORMAL);

    //
    // Add a bunch of children!
    //
    MultiAdd(phr, 16, 1);


    Element::EndDefer();


    //
    // Message pump
    //

    Thread::PumpMessages();
    

    //
    // UnInitialize thread
    //

    Thread::UnInit();

    return 0;
}

//
// Quad add
//

void
MultiAdd(Element * peParent, UINT nCount, UINT nDepth)
{
    if (nDepth == 0) {
        return;
    }

    Value * pv;
    
    Layout * pl = BuildLayout<BorderLayout>();
    pv = Value::BuildLayout(pl);
    peParent->SetValue(PUIDFromMUID(Namespace, Element::Layout), PropertyInfo::iLocal, pv);
    pv->Release();
    
    UINT i;
    int iLayoutPos = 0;
    Element * pe;
    for(i = 0; i < nCount; i++)
    {
        //
        // Create a new element to insert.
        //
        pe = BuildElement<Molecule>();

        //
        // Set the background color.
        //
        pv = Value::BuildInt((i*3)%(SC_MAXCOLORS+1));
        pe->SetValue(PUIDFromMUID(Namespace, Element::Background), PropertyInfo::iLocal, pv);
        pv->Release();

        //
        // Set the layout position.  Insert clockwise from the top.
        //
        switch(i%4)
        {
        case 0:
            iLayoutPos = BLP_Top;
            break;

        case 1:
            iLayoutPos = BLP_Right;
            break;

        case 2:
            iLayoutPos = BLP_Bottom;
            break;

        case 3:
            iLayoutPos = BLP_Left;
            break;
        }
        pv = Value::BuildInt(iLayoutPos);
        pe->SetValue(PUIDFromMUID(Namespace, Element::LayoutPos), PropertyInfo::iLocal, pv);
        pv->Release();

        //
        // Now that the element is configured, add it to the parent.
        //
        peParent->Add(pe);

        //
        // Repeat the process for each child added...
        //
        MultiAdd(pe, nCount, nDepth - 1);
    }
}


//
// Suite WndProc
//

LRESULT SuiteWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE:
        {
            HWNDRoot * phr = reinterpret_cast<HWNDRoot *> (GetWindowLongPtrW(hWnd, GWLP_USERDATA));
            if (phr != NULL) {
                Value * pv = Value::BuildRectangleSD(0, 0, 0, LOWORD(lParam), HIWORD(lParam));
                if (pv != NULL) {
                    phr->SetValue(PUIDFromMUID(Namespace, Element::Bounds), PropertyInfo::iLocal, pv);
                    pv->Release();
                }
            }
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\bridgecp.h ===
#if !defined(BRIDGECP__BridgeCP_h__INCLUDED)
#define BRIDGECP__BridgeCP_h__INCLUDED
#pragma once

typedef UINT    (CALLBACK * EventProc)(EventMsg * pMsg);
typedef void    (CALLBACK * MethodProc)(MethodMsg * pMsg);

struct BridgeData
{
    EventProc   pfnEvent;
    MethodProc  pfnMethod;
};

BridgeData *    GetBridgeData();

//------------------------------------------------------------------------------
inline void SetError(HRESULT hr)
{
    SetLastError((DWORD) hr);
}


#endif // BRIDGECP__BridgeCP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\factory.h ===
#if !defined(BRIDGECP__Factory_h__INCLUDED)
#define BRIDGECP__Factory_h__INCLUDED
#pragma once

extern "C"  BOOL        WINAPI  InitBridge();
extern "C"  DUser::Gadget *
                        WINAPI  BuildBridgeGadget(HCLASS hcl, DUser::Gadget::ConstructInfo * pmicData, EventProc pfnEvent, MethodProc pfnMethod);

#endif // BRIDGECP__Factory_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\factory.cpp ===
#include "stdafx.h"
#include "BridgeCP.h"
#include "Factory.h"

DWORD g_tls = (DWORD) -1;

//------------------------------------------------------------------------------
BridgeData *
GetBridgeData()
{
    return (BridgeData *) TlsGetValue(g_tls);
}


//------------------------------------------------------------------------------
BOOL
InitBridge()
{
    if (g_tls == (DWORD) -1) {
        g_tls = TlsAlloc();
        if (g_tls == (DWORD) -1) {
            SetError(DU_E_OUTOFKERNELRESOURCES);
            return FALSE;
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
DUser::Gadget *
BuildBridgeGadget(
    IN  HCLASS hcl, 
    IN  DUser::Gadget::ConstructInfo * pmicData, 
    IN  EventProc pfnEvent, 
    IN  MethodProc pfnMethod)
{
    if (g_tls == -1) {
        SetError(DU_E_NOTINITIALIZED);
        return NULL;
    }

    BridgeData * pbd = (BridgeData *) TlsGetValue(g_tls);
    if (pbd == NULL) {
        pbd = (BridgeData *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BridgeData));
        if (pbd == NULL) {
            SetError(E_OUTOFMEMORY);
            return NULL;
        }
        TlsSetValue(g_tls, pbd);
    }

    pbd->pfnEvent   = pfnEvent;
    pbd->pfnMethod  = pfnMethod;

    return DUserBuildGadget(hcl, pmicData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -t$(NTMAKEENV)\Template.gml

$(O)\super.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -t$(NTMAKEENV)\Template.gml

$(O)\Api.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml

$(O)\Bridge.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml

$(O)\BridgeCP.def: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser DUser.gidl DUser.gh -dtarget=$(_BUILDARCH) -dproject=..\BridgeCP.h -o$(O) -tApi.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\bridgecp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
#define AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_

#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500		// TODO: Remove this when updated headers are available
#endif


// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros


// COM Header Files
#include <ObjBase.h>            // CoCreateInstance, IUnknown
#include <DDraw.h>              // DirectDraw
#include <oleidl.h>             // OLE2 Interfaces

// Related services
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)


// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <tchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Gadgets Header Files
#include <AutoUtil.h>           // External debugging support

#define GADGET_ENABLE_ALL
#include <DUser.h>

#endif // !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\sources.inc ===
!IF 0

    Shared sources.inc file for Engine projects.

!ENDIF

# Do not use NTBUILD's Warning.h pragmas, will treat all warnings as errors and use highest level (W4)
COMPILER_WARNINGS=

MSC_STDCALL=1
MSC_WARNING_LEVEL=/W4

USE_MSVCRT=1

INCLUDES=\
        $(WINDOWS_INC_PATH)\DUser;\
        $(ADVCORE_PATH)\duser\inc;\
        $(SDK_INC_PATH)\gdiplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\alloc.cpp ===
/*
 * Heap allocation methods
 */

#include "stdafx.h"
#include "base.h"

#include "duialloc.h"

#include "duierror.h"

namespace DirectUI
{

HANDLE g_hHeap = NULL;

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\base.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_BASE_BASE_H_INCLUDED
#define DUI_BASE_BASE_H_INCLUDED

#pragma once

#endif // DUI_BASE_BASE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\error.cpp ===
/*
 * Error checking support methods
 */

#include "stdafx.h"
#include "base.h"

#include "duierror.h"

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// Debugging

void ForceDebugBreak()
{
    DebugBreak();
}

/////////////////////////////////////////////////////////////////////////////
// Profiling support
//
#ifdef PROFILING

typedef (__stdcall *ICPROFILE)(int nLevel, unsigned long dwId);

HINSTANCE hIceCap = NULL;
ICPROFILE pfnStart = NULL;
ICPROFILE pfnStop = NULL;

void ICProfileOn()
{
    if (!pfnStart)
    {
        if (!hIceCap)
        {
            hIceCap = LoadLibraryW(L"icecap.dll");
        }

        if (hIceCap)
        {
            pfnStart = (ICPROFILE)GetProcAddress(hIceCap, L"StartProfile");
        }
    }

    if (pfnStart)
        pfnStart(3, (ULONG)-1);
}

void ICProfileOff()
{
    if (!pfnStop)
    {
        if (!hIceCap)
        {
            hIceCap = LoadLibraryW(L"icecap.dll");
        }

        if (hIceCap)
        {
            pfnStop = (ICPROFILE)GetProcAddress(hIceCap, L"StopProfile");
        }
    }

    if (pfnStop)
        pfnStop(3, (ULONG)-1);
}

#endif

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\linkedlist.h ===
/*
 * Linked List
 */

#ifndef DUI_BASE_LINKEDLIST_H_INCLUDED
#define DUI_BASE_LINKEDLIST_H_INCLUDED

#pragma once

#include "stdafx.h"
#include "base.h"

namespace DirectUI
{

class LinkedListNode
{
public:
    LinkedListNode* pNext;
    LinkedListNode* pPrev;
};

class LinkedList
{
public:
    LinkedList();
    ~LinkedList();
    void Add(LinkedListNode* pNode);
    void Remove(LinkedListNode* pNode);
    LinkedListNode* RemoveTail();

private:
    LinkedListNode* pHead;
    LinkedListNode* pTail;
};

} // namespace DirectUI

#endif // DUI_BASE_LINKEDLIST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\linkedlist.cpp ===
/*
 * LinkedList
 */

#include "stdafx.h"
#include "base.h"

#include "linkedlist.h"

#include "duierror.h"

namespace DirectUI
{

LinkedList::LinkedList()
{
    pHead = NULL;
    pTail = NULL;
}

LinkedList::~LinkedList()
{
    DUIAssert(!pHead, "List destroyed with without all nodes removed first");
}

void LinkedList::Add(LinkedListNode* pNode)
{
    DUIAssertNoMsg(pNode && !pNode->pNext && !pNode->pPrev);

    pNode->pNext = pHead;
    
    if (pHead)
        pHead->pPrev = pNode;
    else
        pTail = pNode;

    pHead = pNode;
    pNode->pPrev = NULL;
}

void LinkedList::Remove(LinkedListNode* pNode)
{
    if (pNode->pPrev)
        pNode->pPrev->pNext = pNode->pNext;
    else
        pHead = pNode->pNext;

    if (pNode->pNext)
        pNode->pNext->pPrev = pNode->pPrev;
    else
        pTail = pNode->pPrev;

    pNode->pNext = NULL;
    pNode->pPrev = NULL;
}

LinkedListNode* LinkedList::RemoveTail()
{
    LinkedListNode* pNode = NULL;

    if (pTail)
    {
        pNode = pTail;
        Remove(pTail);
    }

    return pNode;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\sources.inc ===
!IF 0

    DirectUI Base Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\alloc.cpp        \
        ..\error.cpp        \
        ..\fontcache.cpp    \
        ..\linkedlist.cpp   \
        ..\sballoc.cpp      \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxbase.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_BASE_PUBLISHED_H_INCLUDED
#define DUI_BASE_PUBLISHED_H_INCLUDED

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

#endif // DUI_BASE_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_BASE_STDAFX_H_INCLUDED
#define DUI_BASE_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_BASE_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\fontcache.cpp ===
/*
 * Font Cache
 */

#include "stdafx.h"
#include "base.h"

#include "duifontcache.h"

#include "duierror.h"
#include "duialloc.h"

// Font cache exposes GDI font failures by returning NULL font handles

namespace DirectUI
{

int __cdecl FCSort(const void* pA, const void* pB)
{
    FontCache::RecordIdx* priA = (FontCache::RecordIdx*)pA;
    FontCache::RecordIdx* priB = (FontCache::RecordIdx*)pB;

    DUIAssert(priA->pfcContext == priB->pfcContext, "Font cache sort context mismatch");

    FontCache* pfc = priA->pfcContext;

    UINT uAHits = pfc->_GetRecordHits(priA->idx);
    UINT uBHits = pfc->_GetRecordHits(priB->idx);

    if (uAHits == uBHits)
        return 0;

    if (uAHits > uBHits)
        return -1;
    else
        return 1;
}

HRESULT FontCache::Create(UINT uCacheSize, OUT FontCache** ppCache)
{
    DUIAssert(uCacheSize >= 1, "Cache size must be greater than 1");
    
    *ppCache = NULL;

    FontCache* pfc = HNew<FontCache>();
    if (!pfc)
        return E_OUTOFMEMORY;

    HRESULT hr = pfc->Initialize(uCacheSize);
    if (FAILED(hr))
    {
        pfc->Destroy();
        return hr;
    }

    *ppCache = pfc;

    return S_OK;
}

HRESULT FontCache::Initialize(UINT uCacheSize)
{
    // Initialize
    _pDB = NULL;
    _pFreq = NULL;
    _fLock = false;
    _uCacheSize = uCacheSize;

    // Create tables
    _pDB = (FontRecord*)HAllocAndZero(sizeof(FontRecord) * _uCacheSize);
    if (!_pDB)
        return E_OUTOFMEMORY;

    _pFreq = (RecordIdx*)HAlloc(sizeof(RecordIdx) * _uCacheSize);
    if (!_pFreq)
    {
        HFree(_pDB);
        _pDB = NULL;
        return E_OUTOFMEMORY;
    }

    for (UINT i = 0; i < _uCacheSize; i++)
    {
        _pFreq[i].pfcContext = this;  // Store context for global sort routine
        _pFreq[i].idx = i;
    }

    return S_OK;
}

void FontCache::Destroy()
{ 
    HDelete<FontCache>(this); 
}

FontCache::~FontCache()
{
    if (_pFreq)
        HFree(_pFreq);

    if (_pDB)
    {
        // Free all fonts
        for (UINT i = 0; i < _uCacheSize; i++)
        {
            if ((_pDB + i)->hFont)
                DeleteObject((_pDB + i)->hFont);
        }

        HFree(_pDB);
    }
}

HFONT FontCache::CheckOutFont(LPWSTR szFamily, int dSize, int dWeight, int dStyle, int dAngle)
{
    // Only one font can be checked out at a time, use CheckInFont to unlock cache
    DUIAssert(!_fLock, "Only one font can be checked out at a time.");

    _fLock = true;

    // Search for font in order of most-frequently-used Index
    FontRecord* pRec = NULL;
    UINT i;
    for (i = 0; i < _uCacheSize; i++)
    {
        // Get record
        pRec = _pDB + _pFreq[i].idx;

        // Check for match
        if (pRec->dStyle == dStyle &&
            pRec->dWeight == dWeight &&
            pRec->dSize == dSize &&
            pRec->dAngle == dAngle &&
            !_wcsicmp(pRec->szFamily, szFamily))
        {
            // Match, _pFreq[i].idx has record number
            break;
        }

        pRec = NULL;
    }

    // Check existance of record
    if (!pRec)
    {
        // Record not found, create
        // Take LFU (last index) and fill struct
        i--;

        pRec = _pDB + _pFreq[i].idx;

        // Destroy record first, if exists
        if (pRec->hFont)
            DeleteObject(pRec->hFont);
        
        // Create new font
        LOGFONTW lf;
        ZeroMemory(&lf, sizeof(LOGFONT));

        lf.lfHeight = dSize;
        lf.lfWeight = dWeight;
        lf.lfItalic = (dStyle & FS_Italic) != 0;
        lf.lfUnderline = (dStyle & FS_Underline) != 0;
        lf.lfStrikeOut = (dStyle & FS_StrikeOut) != 0;
        lf.lfCharSet = DEFAULT_CHARSET;
        lf.lfQuality = DEFAULT_QUALITY;
        lf.lfEscapement = dAngle;
        lf.lfOrientation = dAngle;
        wcscpy(lf.lfFaceName, szFamily);

        // Create
        pRec->hFont = CreateFontIndirectW(&lf);

#if DBG
        DUIAssert(pRec->hFont, "Unable to create font!");

        HDC hdc = GetDC(NULL);
        HFONT hOldFont = (HFONT)SelectObject(hdc, pRec->hFont);

        
        WCHAR szUsed[81];
        GetTextFaceW(hdc, 80, szUsed);

        SelectObject(hdc, hOldFont);
        ReleaseDC(NULL, hdc);

        //DUITrace(">> Font: '%S' (Actual: %S)\n", lf.lfFaceName, szUsed);
#endif

        // Fill rest of record
        pRec->dSize = dSize;
        pRec->dStyle = dStyle;
        pRec->dWeight = dWeight;
        pRec->dAngle = dAngle;
        wcscpy(pRec->szFamily, szFamily);
        pRec->uHits = 0;
    }

    // Add font hit
    pRec->uHits++;

    // Check if should resort index by checking number of hit of previous index
    if (i != 0 && pRec->uHits >= (_pDB + _pFreq[i-1].idx)->uHits)
    {
        qsort(_pFreq, _uCacheSize, sizeof(RecordIdx), FCSort);

        //OutputDebugStringW(L"FontCache Hit sort: ");
        //WCHAR buf[81];
        //for (UINT j = 0; j < _uCacheSize; j++)
        //{
        //    wsprintf(buf, L"%d[%d] ", _pFreq[j].idx, _GetRecordHits(_pFreq[j].idx));
        //    OutputDebugStringW(buf);
        //}
        //OutputDebugStringW(L"\n");
    }

    return pRec->hFont;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\behavior.h ===
/*
 * Behavior
 */

#ifndef DUI_CONTROL_BEHAVIOR_H_INCLUDED
#define DUI_CONTROL_BEHAVIOR_H_INCLUDED

#pragma once

//typedef void    (CALLBACK * EventCallback)(Element* pe);

namespace DirectUI
{

typedef struct tagClickInfo
{
    UINT  nCount;
    UINT  uModifiers;
    POINT pt;
} ClickInfo;

BOOL CheckContext(Element* pe, InputEvent* pie, BOOL* pbPressed, ClickInfo* pci);
BOOL CheckClick(Element* pe, InputEvent* pie, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci);
BOOL CheckClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci);
BOOL CheckRepeatClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbActionDelay, HACTION* phAction, ACTIONPROC pfnActionCallback, ClickInfo* pci);

} // namespace DirectUI

#endif // DUI_CONTROL_BEHAVIOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\sballoc.cpp ===
/*
 * Fixed-Size Small Block Allocator
 */

#include "stdafx.h"
#include "base.h"

#include "duisballoc.h"

#include "duialloc.h"
#include "duierror.h"

// SBAlloc is intended for structures and reserves the first byte of the block for
// block flags. The structure used will be auto-packed by the compiler
//
// BLOCK: | BYTE | ------ Non-reserved DATA ------ S

// SBAlloc does not have a static creation method. Memory failures will be
// exposed via it's Alloc method

// Define SBALLOCDISABLE to force small block allocator to simply make
// every process allocation using the process heap. Although much slower,
// it is useful when running tools to detect heap corruption (including
// mismatched reference counting)
//#define SBALLOCDISABLE

namespace DirectUI
{

#if DBG
int g_cSBAllocs = 0;
int g_cSBRefills = 0;
#endif

#ifndef SBALLOCDISABLE

HRESULT SBAlloc::Create(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak, SBAlloc** ppSBA)
{
    HRESULT hr;

    *ppSBA = NULL;

    SBAlloc* psba = HNew<SBAlloc>();
    if (!psba)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    psba->_pSections = NULL;
    psba->_ppStack = NULL;
        
    // Leak callback interface, not ref counted
    psba->_pisbLeak = pisbLeak;

    psba->_uBlockSize = uBlockSize;
    psba->_uBlocksPerSection = uBlocksPerSection;

    // Setup first section, extra byte per block as InUse flag
    psba->_pSections = (SBSection*)HAlloc(sizeof(SBSection));
    if (!psba->_pSections)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    psba->_pSections->pNext = NULL;

    psba->_pSections->pData = (BYTE*)HAlloc(psba->_uBlockSize * psba->_uBlocksPerSection);

    if (psba->_pSections->pData)
    {
#if DBG
        memset(psba->_pSections->pData, SBALLOC_FILLCHAR, psba->_uBlockSize * psba->_uBlocksPerSection);
#endif
        for (UINT i = 0; i < psba->_uBlocksPerSection; i++)
            *(psba->_pSections->pData + (i * psba->_uBlockSize)) = 0; // Block not in use
    }

    // Create free block stack
    psba->_ppStack = (BYTE**)HAlloc(sizeof(BYTE*) * psba->_uBlocksPerSection);
    if (!psba->_ppStack)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }
    
    psba->_dStackPtr = -1;

    *ppSBA = psba;

    //DUITrace("DUI Small-block allocator created (block size: %d)\n", uBlockSize);

    return S_OK;

Failure:

    if (psba)
    {
        if (psba->_ppStack)
            HFree(psba->_ppStack);

        if (psba->_pSections)
            HFree(psba->_pSections);

        psba->Destroy();
    }

    return hr;
}

void SBAlloc::Destroy() 
{ 
    HDelete<SBAlloc>(this); 
}

SBAlloc::~SBAlloc()
{
    // Free all sections
    SBSection* psbs = _pSections;
    SBSection* ptmp;

    while (psbs)
    {
        // Leak detection
        if (_pisbLeak && psbs->pData)
        {
            BYTE* pScan;

            // Check for leaks
            for (UINT i = 0; i < _uBlocksPerSection; i++)
            {
                pScan = psbs->pData + (i * _uBlockSize);
                if (*pScan)
                    _pisbLeak->AllocLeak(pScan);
            }
        }

        ptmp = psbs;
        psbs = psbs->pNext;

        // Free section
        if (ptmp->pData)
            HFree(ptmp->pData);
        if (ptmp)
            HFree(ptmp);
    }

    // Free stack
    if (_ppStack)
        HFree(_ppStack);
}

// Returns false on memory errors
bool SBAlloc::_FillStack()
{
#if DBG
    g_cSBRefills++;
#endif

    if (!_pSections || !_ppStack)
        return false;

    // Scan for free block
    SBSection* psbs = _pSections;

    BYTE* pScan;

    for(;;)
    {
        // Locate free blocks in section and populate stack
        if (psbs->pData)
        {
            for (UINT i = 0; i < _uBlocksPerSection; i++)
            {
                pScan = psbs->pData + (i * _uBlockSize);

                if (!*pScan)
                {
                    // Block free, store in stack
                    _dStackPtr++;
                    _ppStack[_dStackPtr] = pScan;

                    if ((UINT)(_dStackPtr + 1) == _uBlocksPerSection)
                        return true;
                }
            }
        }

        if (!psbs->pNext)
        {
            // No block found, and out of sections, create new section
            SBSection* pnew = (SBSection*)HAlloc(sizeof(SBSection));

            if (pnew)
            {
                pnew->pNext = NULL;

                pnew->pData = (BYTE*)HAlloc(_uBlockSize * _uBlocksPerSection);

                if (pnew->pData)
                {
#if DBG
                    memset(pnew->pData, SBALLOC_FILLCHAR, _uBlockSize * _uBlocksPerSection);
#endif
                    for (UINT i = 0; i < _uBlocksPerSection; i++)
                        *(pnew->pData + (i * _uBlockSize)) = 0; // Block not in use
                }
            }
            else
                return false;

            psbs->pNext = pnew;
        }

        // Search in next section
        psbs = psbs->pNext;
    }
}

void* SBAlloc::Alloc()
{
#if DBG
    g_cSBAllocs++;
#endif

    if (_dStackPtr == -1)
    {
        if (!_FillStack())
            return NULL;
    }

    if (!_ppStack)
        return NULL;

    BYTE* pBlock = _ppStack[_dStackPtr];

#if DBG
     memset(pBlock, SBALLOC_FILLCHAR, _uBlockSize);
#endif

    *pBlock = 1;  // Mark as in use

    _dStackPtr--;

    return pBlock;
}

void SBAlloc::Free(void* pBlock)
{
    if (!pBlock)
        return;

    // Return to stack
    BYTE* pHold = (BYTE*)pBlock;

#if DBG
     memset(pHold, SBALLOC_FILLCHAR, _uBlockSize);
#endif

    *pHold = 0;  // No longer in use

    if ((UINT)(_dStackPtr + 1) != _uBlocksPerSection)
    {
        _dStackPtr++;

        if (_ppStack)
            _ppStack[_dStackPtr] = pHold;
    }
}

#else // SBALLOCDISABLE

#error Use for temporary corruption detection only

SBAlloc::SBAlloc(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak)
{
    //DUITrace("DUI Small-block allocator created (block size: %d)\n", uBlockSize);

    // Leak callback interface, not ref counted
    _pisbLeak = pisbLeak;

    _uBlockSize = uBlockSize;
    _uBlocksPerSection = uBlocksPerSection;

    _pSections = NULL;
    _ppStack = NULL;
}

SBAlloc::~SBAlloc()
{
}

// Returns false on memory errors
bool SBAlloc::_FillStack()
{
#if DBG
    g_cSBRefills++;
#endif

    return true;
}

void* SBAlloc::Alloc()
{
#if DBG
    g_cSBAllocs++;
#endif

    return HAlloc(_uBlockSize);
}

void SBAlloc::Free(void* pBlock)
{
    HFree(pBlock);
}

#endif // SBALLOCDISABLE

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\behavior.cpp ===
/*
 * Button
 */

#include "stdafx.h"
#include "control.h"

#include "Behavior.h"

namespace DirectUI
{

BOOL CheckContext(Element* pe, InputEvent* pie, BOOL* pbPressed, ClickInfo* pci)
{
    BOOL bUnused;

    if (CheckClick(pe, pie, GBUTTON_RIGHT, pbPressed, &bUnused, pci))
        return TRUE;
        
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        if (pie->nDevice == GINPUT_KEYBOARD)
        {
            KeyboardEvent* pke = (KeyboardEvent*)pie;

            switch (pke->ch)
            {
                case VK_F10:
                    if ((pke->nCode == GKEY_SYSDOWN) && (pke->uModifiers & GMODIFIER_SHIFT))
                    {
                        *pbPressed = FALSE;
                        pci->nCount = 1;
                        pci->pt.x = -1;
                        pci->pt.y = -1;
                        pci->uModifiers = (pke->uModifiers & ~GMODIFIER_SHIFT);
                        pie->fHandled = true;
                        return TRUE;
                    }
                    break;

                case VK_APPS:
                    if (pke->nCode == GKEY_DOWN)
                    {
                        *pbPressed = TRUE;
                        pie->fHandled = true;
                    }
                    else if (pke->nCode == GKEY_UP)
                    {
                        pie->fHandled = true;

                        if (*pbPressed)
                        {
                            *pbPressed = FALSE;
                            pci->nCount = 1;
                            pci->pt.x = -1;
                            pci->pt.y = -1;
                            pci->uModifiers = pke->uModifiers;
                            return TRUE;
                        }
                    }
                    break;

                case 0x1B:  // ESC
                    if (pke->nCode == GKEY_DOWN && *pbPressed)
                    {
                        // todo:  need to tell gadget to release mouse capture
                        *pbPressed = FALSE;

                        pie->fHandled = true;
                    }
                    break;
            }
        }
    }
    return false;

}

BOOL CheckClick(Element* pe, InputEvent* pie, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci)
{
    return CheckClick(pe, pie, GBUTTON_LEFT, pbPressed, pbCaptured, pci);
}

BOOL CheckRepeatClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbActionDelay, HACTION* phAction, ACTIONPROC pfnActionCallback, ClickInfo* pci)
{
    BOOL bPressedOld = *pbPressed;
    BOOL bUnused;
    
    // use checkclick to update pressed state
    CheckClick(pe, pie, bButton, pbPressed, &bUnused, pci);
    BOOL bReturn = FALSE;

    if (bPressedOld != *pbPressed)
    {
        if (pie->nDevice == GINPUT_MOUSE)
        {
            if (pie->nCode == GMOUSE_DOWN)
            {
                pci->nCount = 1;
                pci->pt = ((MouseEvent*) pie)->ptClientPxl;
                pci->uModifiers = pie->uModifiers;
                *pbActionDelay = TRUE;
            }
        }
        else if (pie->nDevice == GINPUT_KEYBOARD)
        {
            if (pie->nCode == GKEY_DOWN)
            {
                pci->nCount = 1;
                pci->pt.x = -1;
                pci->pt.y = -1;
                pci->uModifiers = pie->uModifiers;
                *pbActionDelay = TRUE;
            }
        }

        bReturn = *pbActionDelay;

        // this is one reason these behaviors aren't ready for prime time;
        // what I need here is a handler for onpropertychanged of the 
        // pressed property since someone could programmatically reset
        // pressed and I would be unable to see that change and reset 
        // the timer appropriately
        if (bPressedOld)
        {
            // Clear timer
            if (*phAction)
                DeleteHandle(*phAction);

            *phAction = NULL;
        }
        else
        {
            DUIAssert(!*phAction, "An action should not be active");

            // Actions will fire subsequent events
            GMA_ACTION maa;
            ZeroMemory(&maa, sizeof(maa));
            maa.cbSize = sizeof(GMA_ACTION);
            maa.flDelay = *pbActionDelay ? (float).5 : 0;
            maa.flDuration = 0;
            maa.flPeriod = (float).05;
            maa.cRepeat = (UINT) -1;
            maa.pfnProc = pfnActionCallback;
            maa.pvData = pe;                

            *phAction = CreateAction(&maa);

            *pbActionDelay = FALSE;
        }
    }
    return bReturn;
}

BOOL CheckClick(Element* pe, InputEvent* pie, int bButton, BOOL* pbPressed, BOOL* pbCaptured, ClickInfo* pci)
{
    UNREFERENCED_PARAMETER(pe);

    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
            case GINPUT_MOUSE:
            {
                MouseEvent* pme = (MouseEvent*)pie;

                if (pme->bButton == bButton)
                {
                    switch (pme->nCode)
                    {
                        case GMOUSE_DOWN:
                            *pbPressed = TRUE;
                            *pbCaptured = TRUE;
                            pme->fHandled = true;
                            break;

                        case GMOUSE_DRAG:
                            *pbPressed = ((MouseDragEvent*) pme)->fWithin;
                            *pbCaptured = TRUE;
                            pme->fHandled = true;
                            break;

                        case GMOUSE_UP:
                            *pbPressed = FALSE;
                            *pbCaptured = FALSE;
                            pme->fHandled = true;
                            MouseClickEvent* pmce = (MouseClickEvent*) pme;
                            if (pmce->cClicks)
                            {
                                pci->nCount = pmce->cClicks;
                                pci->pt = pmce->ptClientPxl;
                                pci->uModifiers = pmce->uModifiers;
                                return TRUE;
                            }
                            break;
                    }
                }
            }
            break;

            case GINPUT_KEYBOARD:
            {
                // only do keyboard handling of click for left click
                if (bButton == GBUTTON_LEFT)
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pie;
                    //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                    switch (pke->ch)
                    {
                    case 0x20:  // Space
                        if (pke->nCode == GKEY_DOWN)
                        {
                            *pbPressed = TRUE;
                            pie->fHandled = true;
                        }
                        else if (pke->nCode == GKEY_UP)
                        {
                            pie->fHandled = true;

                            if (*pbPressed)
                            {
                                *pbPressed = FALSE;
                                pci->nCount = 1;
                                pci->pt.x = -1;
                                pci->pt.y = -1;
                                pci->uModifiers = pke->uModifiers;
                                return TRUE;
                            }
                        }
                        break;

                    case 0x0D:  // Enter
                        if (pke->nCode == GKEY_DOWN)
                        {
                            pie->fHandled = true;
                            pci->nCount = 1;
                            pci->pt.x = -1;
                            pci->pt.y = -1;
                            pci->uModifiers = pke->uModifiers;
                            return TRUE;
                        }
                        break;

                    case 0x1B:  // ESC
                        if (pke->nCode == GKEY_DOWN && *pbPressed)
                        {
                            // todo:  need to tell gadget to release mouse capture
                            *pbPressed = FALSE;

                            pie->fHandled = true;
                        }
                        break;
                    }
                }
            }
            break;
        }
    }
    return false;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\base\stdafxbase.cpp ===
/*
 * stdafxbase.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\button.cpp ===
/*
 * Button
 */

#include "stdafx.h"
#include "control.h"

#include "duibutton.h"

#include "Behavior.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireClickEvent(Button* peTarget, ClickInfo* pci);
extern inline void _FireContextEvent(Button* peTarget, ClickInfo* pci);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Button, Click)  // ButtonClickEvent struct
DefineClassUniqueID(Button, Context)  // ButtonContextEvent struct

////////////////////////////////////////////////////////
// Button

HRESULT Button::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    Button* pb = HNew<Button>();
    if (!pb)
        return E_OUTOFMEMORY;

    HRESULT hr = pb->Initialize(nActive);
    if (FAILED(hr))
    {
        pb->Destroy();
        return hr;
    }

    *ppElement = pb;

    return S_OK;
}

HRESULT Button::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    return S_OK;
}

void _FireClickEvent(Button* peTarget, ClickInfo* pci)
{
    //DUITrace("Click! <%x>\n", peTarget);

    // Fire click event
    ButtonClickEvent bce;
    bce.uidType = Button::Click;
    bce.nCount = pci->nCount;
    bce.uModifiers = pci->uModifiers;
    bce.pt = pci->pt;

    peTarget->FireEvent(&bce);  // Will route and bubble
}

void _FireContextEvent(Button* peTarget, ClickInfo* pci)
{
    //DUITrace("Click! <%x>\n", peTarget);

    // Fire click event
    ButtonContextEvent bce;
    bce.uidType = Button::Context;
    bce.uModifiers = pci->uModifiers;
    bce.pt = pci->pt;

    peTarget->FireEvent(&bce);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void Button::OnInput(InputEvent* pie)
{
    BOOL bPressed = GetPressed(); // Previous pressed state required for CheckClick
    BOOL bPressedBefore = bPressed; // Store previous state to optimize set since already getting value
    BOOL bCaptured = FALSE;
    ClickInfo ci;

    // First, watch for a click event
    BOOL bFire = CheckClick(this, pie, GBUTTON_LEFT, &bPressed, &bCaptured, &ci);

    if (bPressed != bPressedBefore)
    {
        if (bPressed)
            SetPressed(true);
        else
            RemoveLocalValue(PressedProp);
    }

    // Update mouse captured state
    if (bCaptured)
        SetCaptured(true);
    else
        RemoveLocalValue(CapturedProp);
    
    if (bFire) 
        _FireClickEvent(this, &ci);

    if (pie->fHandled)
        return;

    // Second, watch for a context event
    bFire = CheckContext(this, pie, &_bRightPressed, &ci);

    if (bFire)
        _FireContextEvent(this, &ci);

    if (pie->fHandled)
        return;

    Element::OnInput(pie);
}

void Button::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Accessible)) {
        //
        // When accessibility support for this button is turned ON,
        // make sure that its state reflects the appropriate information.
        //
        if (pvNew->GetBool()) {
            int nAccState = GetAccState();
            if (GetPressed()) {
                nAccState |= STATE_SYSTEM_PRESSED;
            } else {
                nAccState &= ~STATE_SYSTEM_PRESSED;
            }
            SetAccState(nAccState);
        }
    }
    else if (IsProp(Pressed)) {
        if (GetAccessible()) {
            int nAccState = GetAccState();
            if (pvNew->GetBool()) {
                nAccState |= STATE_SYSTEM_PRESSED;
            } else {
                nAccState &= ~STATE_SYSTEM_PRESSED;
            }
            SetAccState(nAccState);
        }
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

HRESULT Button::DefaultAction()
{
	//
	// Simulate that a keypress caused the click.
	//
	ClickInfo ci;
	ci.nCount = 1;
	ci.uModifiers = 0;
	ci.pt.x = -1;
	ci.pt.y = -1;

	_FireClickEvent(this, &ci);

	return S_OK;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Pressed property
static int vvPressed[] = { DUIV_BOOL, -1 };
static PropertyInfo impPressedProp = { L"Pressed", PF_Normal, 0, vvPressed, NULL, Value::pvBoolFalse };
PropertyInfo* Button::PressedProp = &impPressedProp;

// Captured property
static int vvCaptured[] = { DUIV_BOOL, -1 };
static PropertyInfo impCapturedProp = { L"Captured", PF_Normal, 0, vvCaptured, NULL, Value::pvBoolFalse };
PropertyInfo* Button::CapturedProp = &impCapturedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Button::PressedProp,
                                Button::CapturedProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Button::Class = NULL;

HRESULT Button::Register()
{
    return ClassInfo<Button,Element>::Register(L"Button", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\combobox.cpp ===
// Combobox.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duicombobox.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireSelectionEvent(Combobox* peTarget, int iOld, int iNew);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Combobox, SelectionChange)  // SelectionChangeEvent struct


HRESULT Combobox::Create(UINT nActive, Element** ppElement)
{
    *ppElement = NULL;

    Combobox* pe = HNew<Combobox>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pe;

    return S_OK;
}

HWND Combobox::CreateHWND(HWND hwndParent)
{
    int dwStyle = WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST;

    HWND hwndCombo = CreateWindowExW(0, L"ComboBox", NULL, dwStyle, 0, 0, 0, 0, hwndParent, (HMENU)1, NULL, NULL);

    return hwndCombo;
}

bool Combobox::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == CBN_SELENDOK )
        {
            HWND hwndCtrl = GetHWND();
            if (hwndCtrl)
                SetSelection((int) SendMessageW(hwndCtrl, CB_GETCURSEL, 0, 0));
            return true;
        }
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

void _FireSelectionEvent(Combobox* peTarget, int iOld, int iNew)
{

    // Fire selection event
    SelectionIndexChangeEvent sice;
    sice.uidType = Combobox::SelectionChange;
    sice.iOld = iOld;
    sice.iNew = iNew;

    peTarget->FireEvent(&sice);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
// Events passed to the base class will be mappend and sent to the HWND control
void Combobox::OnInput(InputEvent* pie)
{
    // Handle only when direct
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
                {
                    switch (pke->ch)
                    {
                    case VK_TAB:     // Has GKEY_CHAR equivalent
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
                      }
                }
                else if (pke->nCode == GKEY_CHAR) // Characters
                {
                    switch (pke->ch)
                    {
                    case 9:                 // TAB
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
                    }
                }
            }
            break;
        }
    }

    // Forward message to the HWND control
    HWNDHost::OnInput(pie);
}

BOOL Combobox::OnAdjustWindowSize(int x, int y, UINT uFlags)
{
    // Size of control is based on full expanded height. The actual height of
    // the non-dropdown is controled by the Combobox HWND

    HWND hwndCtrl = GetHWND();
    if (hwndCtrl)
    {
        int iCount = (int)SendMessageW(hwndCtrl, CB_GETCOUNT, 0, 0);
        int iHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, 0, 0);
        int iEditHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, (WPARAM)-1, 0);
        
        if(iCount != CB_ERR && iHeight!= CB_ERR && iEditHeight != CB_ERR)
        {
            y += (iCount * iHeight) + iEditHeight;
        }
    }
    
    return HWNDHost::OnAdjustWindowSize(x, y, uFlags);
}

void Combobox::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selection))
    {
        // Setup SelectionChange event
        SelectionIndexChangeEvent sce;
        sce.uidType = SelectionChange;
        sce.iOld = pvOld->GetInt();
        sce.iNew = pvNew->GetInt();
        HWND hwndCtrl = GetHWND();
        if (hwndCtrl)
            SendMessageW(hwndCtrl, CB_SETCURSEL, (WPARAM)sce.iNew, 0);

        // Fire bubbling event
        //DUITrace("SelectionChange! <%x>, O:%x N:%x\n", this, sce.peOld, sce.peNew);

        FireEvent(&sce);  // Will route and bubble
    }

    HWNDHost::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

int Combobox::AddString(LPCWSTR lpszString)
{
    HWND hwndCtrl = GetHWND();
    int iRet = CB_ERR;
    if (hwndCtrl)
    {
        iRet =  (int)SendMessageW(hwndCtrl, CB_ADDSTRING, 0, (LPARAM)lpszString);
        if(iRet != CB_ERR)
        {
            SyncRect(SGR_MOVE | SGR_SIZE, true);
        }
    }
    
    return iRet;
}

////////////////////////////////////////////////////////
// Rendering

SIZE Combobox::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(psrf);

    SIZE sizeDS = { dConstW, dConstH };

    // Combobox HWND height isn't set by SetWindowPos. Rather, the entire height (including
    // the drop down list) is controlled this way. The Combobox HWND sizes itself, we
    // can't control it. The Combobox Element content size is determined by querying
    // the Combobox HWND. The width will always be the constraint passed in.

    HWND hwndCtrl = GetHWND();
    if (hwndCtrl)
    {
        int iEditHeight = (int)SendMessageW(hwndCtrl, CB_GETITEMHEIGHT, (WPARAM)-1, 0);
        int iBorderSize = GetSystemMetrics(SM_CYEDGE) + 1;

        sizeDS.cy = iEditHeight + (2 * iBorderSize);
    }

    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Selection property
static int vvSelection[] = { DUIV_INT, -1 }; StaticValue(svDefaultSelection, DUIV_INT, -1);
static PropertyInfo impSelectionProp = { L"Selection", PF_Normal, 0, vvSelection, NULL, (Value*)&svDefaultSelection };
PropertyInfo* Combobox::SelectionProp = &impSelectionProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Combobox::SelectionProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Combobox::Class = NULL;

HRESULT Combobox::Register()
{
    return ClassInfo<Combobox,HWNDHost>::Register(L"Combobox", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\control.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_CONTROL_CONTROL_H_INCLUDED
#define DUI_CONTROL_CONTROL_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>

#endif // DUI_CONTROL_CONTROL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_CONTROL_PUBLISHED_H_INCLUDED
#define DUI_CONTROL_PUBLISHED_H_INCLUDED

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

#endif // DUI_CONTROL_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\edit.cpp ===
// Edit.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duiedit.h"

namespace DirectUI
{

// Internal helper
extern inline void _FireEnterEvent(Edit* peTarget);

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Edit, Enter)  // EditEnterEvent struct

////////////////////////////////////////////////////////
// Edit

HRESULT Edit::Create(UINT nActive, Element** ppElement)
{
    *ppElement = NULL;

    Edit* pe = HNew<Edit>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pe;

    return S_OK;
}

HWND Edit::CreateHWND(HWND hwndParent)
{
    int dwStyle = WS_CHILD | WS_VISIBLE | ES_PASSWORD | ES_AUTOHSCROLL;

    // Extra styles for multiline
    if (GetMultiline())
        dwStyle |= ES_MULTILINE | ES_WANTRETURN | WS_VSCROLL | WS_HSCROLL;

    HWND hwndEdit = CreateWindowExW(0, L"edit", NULL, dwStyle, 0, 0, 0, 0, hwndParent, (HMENU)1, NULL, NULL);

    if (hwndEdit)
        SendMessageW(hwndEdit, EM_SETPASSWORDCHAR, GetPasswordCharacter(), 0);

    return hwndEdit;
}

////////////////////////////////////////////////////////
// System events

void Edit::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(PasswordCharacter))
    {
        HWND hwndCtrl = GetHWND();
        if (hwndCtrl)
            SendMessageW(hwndCtrl, EM_SETPASSWORDCHAR, pvNew->GetInt(), 0);
    }
    else if (IsProp(Multiline))
    {
        if (GetHWND())
        {
            DUIAssertForce("Dynamic set of multiline for Edit controls not yet implemented");
        }
    }

    // Call base
    HWNDHost::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

HRESULT Edit::SetDirty(bool fDirty)
{
    HWND hwndCtrl = GetHWND();

    if (hwndCtrl)
    {
        bool fOld = (SendMessage(hwndCtrl, EM_GETMODIFY, 0, 0) != 0);
        if (fOld != fDirty)
            SendMessageW(hwndCtrl, EM_SETMODIFY, fDirty, 0);
    }

    // this actually has a return in it -- so no need to specify *return* here
    DUIQuickSetter(CreateBool(fDirty), Dirty);
}

////////////////////////////////////////////////////////
// Control notifications

bool Edit::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            // Reflect changes to HWND edit control text in Content property

            HWND hwndCtrl = GetHWND();
            DUIAssert(hwndCtrl, "Invalid hosted HWND control: NULL");

            int dLen = GetWindowTextLengthW(hwndCtrl);
            if (dLen)
            {
                // Have text in HWND, include null terminator
                dLen++;

                LPWSTR pszNew = (LPWSTR)HAlloc(dLen * sizeof(WCHAR));
                if (pszNew)
                {
                    GetWindowTextW(hwndCtrl, pszNew, dLen);
                    SetContentString(pszNew);
                    HFree(pszNew);
                }
            }
            else
            {
                // No text in HWND, remove content in Element
                RemoveLocalValue(ContentProp);
            }

            if (!GetDirty())
                SetDirty(SendMessage(hwndCtrl, EM_GETMODIFY, 0, 0) != 0);

            // Notification handled
            return true;
        }
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

UINT Edit::MessageCallback(GMSG* pGMsg)
{
    return HWNDHost::MessageCallback(pGMsg);
}

void _FireEnterEvent(Edit* peTarget)
{
    //DUITrace("Enter! <%x>\n", peTarget);

    // Fire click event
    EditEnterEvent eee;
    eee.uidType = Edit::Enter;

    peTarget->FireEvent(&eee);  // Will route and bubble
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
// Events passed to the base class will be mappend and sent to the HWND control
void Edit::OnInput(InputEvent* pie)
{
    // Handle only when direct
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                //DUITrace("KeyboardEvent <%x>: %d[%d]\n", this, pke->ch, pke->nCode);

                if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
                {
                    switch (pke->ch)
                    {
                    // Never forward
                    case VK_ESCAPE:  // Has GKEY_CHAR equivalent
                    case VK_F1:
                    case VK_F2:
                    case VK_F3:
                    case VK_F4:
                    case VK_F5:
                    case VK_F6:
                    case VK_F7:
                    case VK_F8:
                    case VK_F9:
                    case VK_F10:
                    case VK_F11:
                    case VK_F12:
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;
        
                    // Do not forward for single line edit
                    case VK_DOWN:     
                    case VK_UP:
                    case VK_RETURN:  // Has GKEY_CHAR equivalent
                    case VK_TAB:     // Has GKEY_CHAR equivalent
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        if (!GetMultiline())
                        {
                            Element::OnInput(pie);
                            return;
                        }
                        break;
                    }
                }
                else if (pke->nCode == GKEY_CHAR) // Characters
                {
                    switch (pke->ch)
                    {
                    // Never forward
                    case 27:                // ESC
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        Element::OnInput(pie);
                        return;

                    // Do not forward for single line edit
                    case 13:                // RETURN
                        // Fire ENTER event
                        _FireEnterEvent(this);

                        pie->fHandled = true;

                        if (!GetMultiline())  // Is multiline, pass to control
                            return;
                    
                        break;

                    // Do not forward for single line edit
                    case 9:                 // TAB
                        // Bypass HWNDHost::OnInput for these input events so they aren't forwarded
                        // to the HWND control. Element::OnInput will handle the events (keyboard nav)
                        if (!GetMultiline())
                        {
                            Element::OnInput(pie);
                            return;
                        }
                        break;
                    }
                }
            }
            break;
        }
    }

    // Forward message to the HWND control, input event will be marked as handled.
    // It will not bubble to parent
    HWNDHost::OnInput(pie);
}

////////////////////////////////////////////////////////
// Rendering

SIZE Edit::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(psrf);

    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    SIZE sizeDS = { dConstW, abs(GetFontSize()) };  // Font size may be negative

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Multiline property
static int vvMultiline[] = { DUIV_BOOL, -1 };
static PropertyInfo impMultilineProp = { L"Multiline", PF_Normal, 0, vvMultiline, NULL, Value::pvBoolFalse };
PropertyInfo* Edit::MultilineProp = &impMultilineProp;

// Password Character property
static int vvPasswordCharacter[] = { DUIV_INT, -1 };
static PropertyInfo impPasswordCharacterProp = { L"PasswordCharacter", PF_Normal|PF_Cascade, 0, vvPasswordCharacter, NULL, Value::pvIntZero };
PropertyInfo* Edit::PasswordCharacterProp = &impPasswordCharacterProp;

// Dirty property
static int vvDirty[] = { DUIV_BOOL, -1 };
static PropertyInfo impDirtyProp = { L"Dirty", PF_Normal, 0, vvDirty, NULL, Value::pvBoolFalse };
PropertyInfo* Edit::DirtyProp = &impDirtyProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Edit::MultilineProp,
                                Edit::PasswordCharacterProp,
                                Edit::DirtyProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Edit::Class = NULL;

HRESULT Edit::Register()
{
    return ClassInfo<Edit,HWNDHost>::Register(L"Edit", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\native.cpp ===
/*
 * Native
 */

#include "stdafx.h"
#include "control.h"

#include "duinative.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Top-level native HWND host of HWNDElement

HRESULT NativeHWNDHost::Create(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions, OUT NativeHWNDHost** ppHost)
{
    *ppHost = NULL;

    NativeHWNDHost* pnhh = HNew<NativeHWNDHost>();
    if (!pnhh)
        return E_OUTOFMEMORY;

    HRESULT hr = pnhh->Initialize(pszTitle, hWndParent, hIcon, dX, dY, dWidth, dHeight, iExStyle, iStyle, nOptions);
    if (FAILED(hr))
    {
        pnhh->Destroy();
        return hr;
    }

    *ppHost = pnhh;

    return S_OK;
}

HRESULT NativeHWNDHost::Initialize(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions)
{
    _pe = NULL;
    _hWnd = NULL;

    _nOptions = nOptions;

    // Make sure window class is registered
    WNDCLASSEXW wcex;

    // Register host window class, if needed
    wcex.cbSize = sizeof(wcex);

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"NativeHWNDHost", &wcex))
    {
        ZeroMemory(&wcex, sizeof(wcex));

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_GLOBALCLASS;
        wcex.hInstance = GetModuleHandleW(NULL);
        wcex.hIcon = hIcon;
        wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wcex.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        wcex.lpszClassName = L"NativeHWNDHost";
        wcex.lpfnWndProc = DefWindowProcW;

        if (RegisterClassExW(&wcex) == 0)
            return DUI_E_USERFAILURE;
    }

    _hWnd = CreateWindowExW(iExStyle, L"NativeHWNDHost", pszTitle, iStyle | WS_CLIPCHILDREN, dX, dY, dWidth, dHeight,
                            hWndParent, 0, NULL, NULL);

    if (!_hWnd)
        return DUI_E_USERFAILURE;

    SetWindowLongPtrW(_hWnd, GWLP_WNDPROC, (LONG_PTR)NativeHWNDHost::WndProc);
    SetWindowLongPtrW(_hWnd, GWLP_USERDATA, (LONG_PTR)this);

    // If top-level, initialize keyboard cue state, start all hidden
    if (!hWndParent)
        SendMessage(_hWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);

    return S_OK;
}

void NativeHWNDHost::Host(Element* pe)
{
    DUIAssert(!_pe && _hWnd, "Already hosting an Element");
    DUIAssert(pe->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "NativeHWNDHost must only host HWNDElements");

    _pe = pe;

    //
    // Mirror NativeHWNDHost window without mirroring any of its children.
    //
    if (pe->IsRTL())
        SetWindowLong(_hWnd, GWL_EXSTYLE, GetWindowLong(_hWnd, GWL_EXSTYLE) | WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
    
    RECT rc;
    GetClientRect(_hWnd, &rc);

    if(!(_nOptions & NHHO_HostControlsSize))
    {
        Element::StartDefer();
        _pe->SetWidth(rc.right - rc.left);
        _pe->SetHeight(rc.bottom - rc.top);
        Element::EndDefer();
    }
    else if(pe->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
    {
        // [msadek] , We want the host window to copy those attributes.
        // and to force size update.
        ((HWNDElement*)pe)->SetParentSizeControl(true);
        if((_nOptions & NHHO_ScreenCenter))
        {
            ((HWNDElement*)pe)->SetScreenCenter(true);        
        }
        ((HWNDElement*)pe)->OnGroupChanged(PG_AffectsBounds , true);
    }
}

LRESULT NativeHWNDHost::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE:
        {
            if (!(GetWindowLongPtrW(hWnd, GWL_STYLE) & WS_MINIMIZE))
            {
                NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
                if (pnhh)
                {
                    Element* pe = pnhh->GetElement();
                    if (pe)
                    {
                        DisableAnimations();
                        if(!(pnhh->_nOptions & NHHO_HostControlsSize))
                        {
                            Element::StartDefer();
                            pe->SetWidth(LOWORD(lParam));
                            pe->SetHeight(HIWORD(lParam));
                            Element::EndDefer();
                        }    
                        EnableAnimations();
                    }
                }
            }
        }
        break;

    case WM_CLOSE:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                if (!(pnhh->_nOptions & NHHO_IgnoreClose))
                    pnhh->DestroyWindow();  // Post an async-destroy

                // Do not destroy immediately
                return 0;
            }
        }
        break;

    case WM_DESTROY:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                if(!(pnhh->_nOptions & NHHO_NoSendQuitMessage))
                {
                    PostQuitMessage(0);
                }
                pnhh->_hWnd = NULL;

                if (pnhh->_nOptions & NHHO_DeleteOnHWNDDestroy)
                {
                    // Auto destroy instance of object
                    SetWindowLongPtrW(hWnd, GWLP_USERDATA, NULL);
                    pnhh->Destroy();
                }
            }    
        }
        break;

    case WM_SETFOCUS:
        {
            // Push focus to HWNDElement (won't set gadget focus to the HWNDElement, but
            // will push focus to the previous gadget with focus)
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                HWNDElement* phe = (HWNDElement*)pnhh->GetElement();
                if (phe && phe->GetHWND() && phe->CanSetFocus())
                    SetFocus(phe->GetHWND());
            }
        }
        break;

    case WM_SYSCOMMAND:
        // If ALT was pressed, show all keyboard cues
        if (wParam == SC_KEYMENU)
            SendMessage(hWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);
        break;

    // Messages to top-level window only, forward
    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_THEMECHANGED:
        {
            NativeHWNDHost* pnhh = (NativeHWNDHost*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
            if (pnhh)
            {
                HWNDElement* phe = (HWNDElement*)pnhh->GetElement();
                if (phe)
                    return SendMessageW(phe->GetHWND(), uMsg, wParam, lParam);
            }
        }
        break;

    case NHHM_ASYNCDESTROY:
        ::DestroyWindow(hWnd);
        return 0;
    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\progress.cpp ===
/*
 * Progress
 */

#include "stdafx.h"
#include "control.h"

#include "duiprogress.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Progress

HRESULT Progress::Create(Element** ppElement)
{
    *ppElement = NULL;

    Progress* pp = HNew<Progress>();
    if (!pp)
        return E_OUTOFMEMORY;

    HRESULT hr = pp->Initialize();
    if (FAILED(hr))
    {
        pp->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = pp;

    return S_OK;
}

////////////////////////////////////////////////////////
// Rendering overrides

void Progress::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);
    UNREFERENCED_PARAMETER(prcSkipBorder);

    // Paint all less content
    RECT rcContent;
    Element::Paint(hDC, prcBounds, prcInvalid, NULL, &rcContent);

    // Render progress content

    // Compute content bounds
    int dBlock = GetMaximum() - GetMinimum();
    if (dBlock > 0)
        dBlock = (rcContent.right - rcContent.left) / dBlock;

    if (IsRTL())
        rcContent.left = rcContent.right - (GetPosition() * dBlock);
    else
        rcContent.right = rcContent.left + (GetPosition() * dBlock);

    // Use foreground brush as bar fill
    HBRUSH hb = NULL;
    bool bDelete = true;
    BYTE dAlpha = 255;  // Opaque

    Value* pv = GetValue(ForegroundProp, PI_Specified); 
    switch (pv->GetType())
    {
    case DUIV_INT:
        bDelete = false;
        hb = GetStdColorBrushI(pv->GetInt());
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value, only solid colors supported
        {
            const Fill* pf = pv->GetFill();
            dAlpha = GetAValue(pf->ref.cr);
            if (dAlpha == 0)  // Transparent
                bDelete = false;
            else
                hb = CreateSolidBrush(~(255 << 24) & pf->ref.cr);
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills and per-pixel alpha unsupported
        {
            Graphic* pg = pv->GetGraphic();
            if (pg->BlendMode.dMode == GRAPHIC_AlphaConst)
                dAlpha = pg->BlendMode.dAlpha;
            if (dAlpha == 0)  // Transparent
                bDelete = false;
            else
                hb = CreatePatternBrush(GethBitmap(pv, IsRTL()));
        }
        break;
    }
    pv->Release();

    // Fill
    if (dAlpha)
    {
        if (dAlpha == 255)  // Normal fill for opaque
            FillRect(hDC, &rcContent, hb);
        else
            UtilDrawBlendRect(hDC, &rcContent, hb, dAlpha, 0, 0);
    }

    // Cleanup
    if (hb && bDelete)
        DeleteObject(hb);
}

SIZE Progress::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    // No content size
    SIZE size = { 0, 0 };
    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Position property
static int vvPosition[] = { DUIV_INT, -1 };
static PropertyInfo impPositionProp = { L"Position", PF_Normal, PG_AffectsDisplay, vvPosition, NULL, Value::pvIntZero };
PropertyInfo* Progress::PositionProp = &impPositionProp;

// Minimum property
static int vvMinimum[] = { DUIV_INT, -1 }; 
static PropertyInfo impMinimumProp = { L"Minimum", PF_Normal, PG_AffectsDisplay, vvMinimum, NULL, Value::pvIntZero };
PropertyInfo* Progress::MinimumProp = &impMinimumProp;

// Maximum property
static int vvMaximum[] = { DUIV_INT, -1 }; StaticValue(svDefaultMaximum, DUIV_INT, 1000);
static PropertyInfo impMaximumProp = { L"Maximum", PF_Normal, PG_AffectsDisplay, vvMaximum, NULL, (Value*)&svDefaultMaximum };
PropertyInfo* Progress::MaximumProp = &impMaximumProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Progress::PositionProp,
                                Progress::MinimumProp,
                                Progress::MaximumProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Progress::Class = NULL;

HRESULT Progress::Register()
{
    return ClassInfo<Progress,Element>::Register(L"Progress", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\hwndhost.cpp ===
// HWNDHost.cpp
//

#include "stdafx.h"
#include "control.h"

#include "duihwndhost.h"

/*
 * Order of Win32 focus messages:
 *
 * WM_ACTIVATE is only sent to top-level (focus is entering/leaving top-level window).
 *
 * When in WM_ACTIVATE(WA_INACTIVE) state
 *
 * If click, WM_ACTIVATE(WA_CLICKACTIVE) then WM_SETFOCUS on top level,
 *    WM_KILLFOCUS on top level, then WM_SETFOCUS on item clicked on.
 * If Alt-Tab, WM_ACTIVATE(WM_ACTIVE) then WM_SETFOCUS on top level.
 * If SetFocus, WM_ACTIVATE(WA_ACTIVE) then WM_SETFOCUS on top level, 
 *    WM_KILLFOCUS on top level, then WM_SETFOCUS on item specified.
 *
 * When in WM_ACTIVATE(WA_ACTIVE) state
 *
 * If click, WM_KILLFOCUS on current focused item, WM_SETFOCUS on item clicked on.
 * If Alt-Tab, WM_ACTIVATE(WM_INACTIVE) then WM_KILLFOCUS on current.
 * If SetFocus, WM_KILLFOCUS on current focused item, WM_SETFOCUS on item specified.
 */

namespace DirectUI
{

// Gadget input message to HWND input message mapping
const UINT HWNDHost::g_rgMouseMap[7][3] =
{
    // GBUTTON_NONE (0)  
    // GBUTTON_LEFT (1)  GBUTTON_RIGHT (2) GBUTTON_MIDDLE (3)
    {  WM_MOUSEMOVE,     WM_MOUSEMOVE,     WM_MOUSEMOVE    },  // GMOUSE_MOVE  (0)
    {  WM_LBUTTONDOWN,   WM_RBUTTONDOWN,   WM_MBUTTONDOWN  },  // GMOUSE_DOWN  (1)
    {  WM_LBUTTONUP,     WM_RBUTTONUP,     WM_MBUTTONUP    },  // GMOUSE_UP    (2)
    {  WM_MOUSEMOVE,     WM_MOUSEMOVE,     WM_MOUSEMOVE    },  // GMOUSE_DRAG  (3)
    {  WM_MOUSEHOVER,    WM_MOUSEHOVER,    WM_MOUSEHOVER   },  // GMOUSE_HOVER (4)
    {  WM_MOUSEWHEEL,    WM_MOUSEWHEEL,    WM_MOUSEWHEEL   },  // GMOUSE_WHEEL (5)
};

////////////////////////////////////////////////////////
// HWNDHost

HRESULT HWNDHost::Create(UINT nCreate, UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDHost* phh = HNew<HWNDHost>();
    if (!phh)
        return E_OUTOFMEMORY;

    HRESULT hr = phh->Initialize(nCreate, nActive);
    if (FAILED(hr))
    {
        phh->Destroy();
        return hr;
    }

    *ppElement = phh;

    return S_OK;
}

HRESULT HWNDHost::Initialize(UINT nCreate, UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    _nCreate = nCreate;
    _fHwndCreate = true;
    _hwndSink = NULL;
    _hwndCtrl = NULL;
    _pfnCtrlOrgProc = NULL;
    SetRectEmpty(&_rcBounds);
    _hFont = NULL;

    return S_OK;
}

HWND HWNDHost::CreateHWND(HWND hwndParent)
{
    UNREFERENCED_PARAMETER(hwndParent);

    DUIAssertForce("No HWND created by HWNDHost, must be overridden");

    return NULL;
}

HRESULT HWNDHost::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = HWNDHostAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

////////////////////////////////////////////////////////
// System events

// When hosted to a native HWND, parent HWND hierarchy (sink and ctrl) to it.
// On first call, create hierarchy
void HWNDHost::OnHosted(Element* peNewHost)
{
    DWORD dwExStyle = 0;

    Element::OnHosted(peNewHost);

    DUIAssert(peNewHost->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "HWNDHost only supports HWNDElement roots");

    HWND hwndRoot = ((HWNDElement*)peNewHost)->GetHWND();

    if (_fHwndCreate)
    {
        // Create hierarchy and attach subclass procs

        // Do not attempt creation on subsequent hosting calls
        _fHwndCreate = false;

        // Create control notification sink, register class if needed
        WNDCLASSEXW wcex;

        wcex.cbSize = sizeof(wcex);

        if (!GetClassInfoExW(GetModuleHandleW(NULL), L"CtrlNotifySink", &wcex))
        {
            ZeroMemory(&wcex, sizeof(wcex));

            wcex.cbSize = sizeof(WNDCLASSEX);
            wcex.style = CS_GLOBALCLASS;
            wcex.hInstance = GetModuleHandleW(NULL);
            wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
            wcex.lpszClassName = L"CtrlNotifySink";
            wcex.lpfnWndProc = DefWindowProc;

            if (RegisterClassExW(&wcex) == 0)
                return;
        }

        // Create sink
        if (IsRTL())
            dwExStyle |= WS_EX_LAYOUTRTL;

        _hwndSink = CreateWindowExW(dwExStyle, L"CtrlNotifySink", NULL, WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
                    0, 0, 0, 0, hwndRoot, NULL, NULL, NULL);
        DUIAssert(_hwndSink, "Adaptor notification sink creation failure.");
        if (!_hwndSink)
            return;

        // Subclass
        AttachWndProcW(_hwndSink, _SinkWndProc, this);

        // Create control
        _hwndCtrl = CreateHWND(_hwndSink);
        DUIAssert(_hwndCtrl, "Adaptor child creation failure.");
        if (!_hwndCtrl)
            return;

        // Get orginial window proc for forwarding messages
        _pfnCtrlOrgProc = (WNDPROC)GetWindowLongPtrW(_hwndCtrl, GWLP_WNDPROC);
        if (!_pfnCtrlOrgProc)
            return;

        // Subclass
        AttachWndProcW(_hwndCtrl, _CtrlWndProc, this);

        // Turn on style to start receiving adaptor messages
        SetGadgetStyle(GetDisplayNode(), GS_ADAPTOR, GS_ADAPTOR);

        // Synchronize the state of the HWND to the current state of Element
        SyncRect(SGR_MOVE | SGR_SIZE);
        SyncParent();
        SyncFont();
        SyncVisible();
        SyncText();
    }
    else if (_hwndSink)
    {
        // Parent HWND to native host
        SetParent(_hwndSink, hwndRoot);
    }
}

// Leaving native HWND container, parent sink to desktop
void HWNDHost::OnUnHosted(Element* peOldHost)
{
    Element::OnUnHosted(peOldHost);

    // Park HWND outside of root host
    if (_hwndSink)
    {
        DUIAssert(peOldHost->GetClassInfo()->IsSubclassOf(HWNDElement::Class), "HWNDHost only supports HWNDElement roots");

        // Hide window when unhosted, go to zero size
        SetRectEmpty(&_rcBounds);
        SetWindowPos(_hwndSink, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);

        SetParent(_hwndSink, NULL);
    }
}

void HWNDHost::OnDestroy()
{
    // Unlink Element and marked as destroyed
    Element::OnDestroy();

    // Destroy sink and control HWND.
    // Do not destroy control HWND directly since it may have been detached.
    // These windows may have already been destroyed by DestroyWindow. If so,
    // the handles will already be NULL.
    if (_hwndSink)
        DestroyWindow(_hwndSink);
        
    // Cleanup
    if (_hFont)
    {
        DeleteObject(_hFont);
        _hFont = NULL;
    }
}

void HWNDHost::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Match HWND control with changes in properties

    if (_hwndCtrl)
    {
        if (IsProp(FontFace) || IsProp(FontSize) || IsProp(FontWeight) || IsProp(FontStyle))
        {
            // Update font being used
            SyncFont();
        }
        else if (IsProp(Content))
        {
            // Relect content change into HWND control
            SyncText();
        }
        else if (IsProp(Visible))
        {
            // Update visible state
            SyncVisible();
        }
        if ((ppi == KeyFocusedProp) && (iIndex == PI_Local) && (pvNew->GetType() != DUIV_UNSET))
        {
            // Element received keyboard focus
            HWND hwndCurFocus = GetFocus();
            if (hwndCurFocus != _hwndCtrl)
            {
                // Control doesn't already have keyboard focus, start the cycle here
                SetFocus(_hwndCtrl);
            }

            // Base will set focus to the display node if needed
        }
    }

    // Call base
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

// All input messages to HWND control will be intercepted and mapped to DUser messages.
// These messages are then processed normally by the DirectUI event model. OnInput takes
// these messages and converts them back to HWND messages and forwards them to the HWND control
void HWNDHost::OnInput(InputEvent* pInput)
{
    // Map input events to Element to HWND control messages
    // When destroyed, HWND sink and control are gone. No need to do any mappings.
    // If detached, control original window proc is NULL.
    // All maps input messages are marked as handled and method will return
    if (pInput->nStage == GMF_DIRECT && _pfnCtrlOrgProc && !IsDestroyed())  // Handle when direct
    {
        switch (pInput->nDevice)
        {
        case GINPUT_MOUSE:
            {
                // When not forwarding mouse messages, no HWND mouse message conversion should take place
                if (!(_nCreate & HHC_NoMouseForward))
                {
                    MouseEvent* pme = (MouseEvent*)pInput;

                    // Check if can support mapping
                    if ((pme->nCode < GMOUSE_MOVE) || (pme->nCode > GMOUSE_WHEEL))
                    {
                        DUITrace("Gadget mouse message unsupported for HWND mapping: %d\n", pme->nCode);
                        break;
                    }

                    // Map button, (left shares none mapping)
                    int iButton;
                    if (pme->bButton == GBUTTON_NONE)
                        iButton = 0;
                    else
                        iButton = pme->bButton - 1;

                    if ((iButton < 0) || (iButton > 2)) 
                    {
                        DUITrace("Gadget mouse button unsupported for HWND mapping: %d\n", iButton);
                        break;
                    }

                    // Map message based on gadget message and button state
                    UINT nMsg = g_rgMouseMap[pme->nCode][iButton];

                    // Create lParam
                    // TODO markfi: subtract off inset of HWND due to border and padding
                    LPARAM lParam = (LPARAM)POINTTOPOINTS(pme->ptClientPxl);

                    // Create wParam
                    WPARAM wParam = NULL;
                    switch (pme->nCode)
                    {
                    case GMOUSE_DOWN:
                        // NOTE:  this is not actually truly accurate -- this 
                        // will cause down, up, down, dblclick instead of 
                        // down, up, dblclick, up
                        // I am leaving this as is for now -- if this causes problems, I'll fix it
                        //
                        // jeffbog
                        if (((MouseClickEvent*) pInput)->cClicks == 1) {
                            nMsg += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
                        }
                        // Fall through...

                    case GMOUSE_MOVE:
                    case GMOUSE_UP:
                    case GMOUSE_HOVER:
                        wParam = pme->nFlags;
                        break;

                    case GMOUSE_DRAG:
                        wParam = pme->nFlags;
                        // TODO: Need to compute the correct lParam
                        break;

                    case GMOUSE_WHEEL:
                        wParam = MAKEWPARAM((WORD)pme->nFlags, (WORD)(short)(((MouseWheelEvent*) pme)->sWheel));
                        break;
                    }

                    // Forward message
                    // Note: Mouse positions outside the control RECT is possible if using
                    // borders and/or padding
                    CallWindowProcW(_pfnCtrlOrgProc, _hwndCtrl, nMsg, wParam, lParam);

                    pInput->fHandled = true;
                }
            }
            return;

        case GINPUT_KEYBOARD:
            {
                // When not forwarding keyboard messages, no HWND keyboard message conversion should take place
                if (!(_nCreate & HHC_NoKeyboardForward))
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pInput;

                    // Check if can support mapping
                    if ((pke->nCode < GKEY_DOWN) || (pke->nCode > GKEY_SYSCHAR))
                    {
                        DUITrace("Gadget keyboard message unsupported for HWND mapping: %d\n", pke->nCode);
                        break;
                    }

                    // Map message based on gadget keyboard message
                    UINT nMsg = 0;
                    switch (pke->nCode)
                    {
                    case GKEY_DOWN:
                        nMsg = WM_KEYDOWN;
                        break;

                    case GKEY_UP:
                        nMsg = WM_KEYUP;
                        break;

                    case GKEY_CHAR:
                        nMsg = WM_CHAR;
                        break;

                    case GKEY_SYSDOWN:
                        nMsg = WM_SYSKEYDOWN;
                        break;

                    case GKEY_SYSUP:
                        nMsg = WM_SYSKEYUP;
                        break;

                    case GKEY_SYSCHAR:
                        nMsg = WM_SYSCHAR;
                        break;
                    }

                    // Map wParam
                    WPARAM wParam = (WPARAM)pke->ch;

                    // Map lParam
                    LPARAM lParam = MAKELPARAM(pke->cRep, pke->wFlags);

                    // Forward message
                    CallWindowProcW(_pfnCtrlOrgProc, _hwndCtrl, nMsg, wParam, lParam);

                    pInput->fHandled = true;
                }
            }
            return;
        }
    }

    Element::OnInput(pInput);
}

////////////////////////////////////////////////////////
// Rendering
//
// Need to prevent the "content" from being displayed, since it is actually 
// being rendered by the HWND.

void HWNDHost::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);

    RECT rcSkipContent;
    Element::Paint(hDC, prcBounds, prcInvalid, prcSkipBorder, &rcSkipContent);

    // Paint control
    if (_hwndCtrl && (_nCreate & HHC_SyncPaint))
        UpdateWindow(_hwndCtrl);
}


#ifdef GADGET_ENABLE_GDIPLUS

void HWNDHost::Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prcSkipBorder, Gdiplus::RectF* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcSkipContent);

    Gdiplus::RectF rcSkipContent;
    Element::Paint(pgpgr, prcBounds, prcInvalid, prcSkipBorder, &rcSkipContent);

    // Paint control
    if (_hwndCtrl && (_nCreate & HHC_SyncPaint))
        UpdateWindow(_hwndCtrl);
}

#endif // GADGET_ENABLE_GDIPLUS


////////////////////////////////////////////////////////
// Notifications from control

bool HWNDHost::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    UNREFERENCED_PARAMETER(nMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(plRet);

    // Call subclassed window proc
    return false;
}

////////////////////////////////////////////////////////
// Message callback override

UINT HWNDHost::MessageCallback(GMSG* pmsg)
{
    if (pmsg->hgadMsg == GetDisplayNode())
    {
        switch (pmsg->nMsg)
        {
        case GM_SYNCADAPTOR:
            {
                if (_hwndSink && _hwndCtrl)
                {
                    GMSG_SYNCADAPTOR* pmsgS = (GMSG_SYNCADAPTOR*)pmsg;
                    switch (pmsgS->nCode)
                    {
                    case GSYNC_RECT:
                    case GSYNC_XFORM:
                        //DUITrace("Adaptor RECT sync: <%x>\n", this);
                        SyncRect(SGR_MOVE | SGR_SIZE);
                        return DU_S_PARTIAL;

                    case GSYNC_STYLE:
                        SyncStyle();
                        return DU_S_PARTIAL;

                    case GSYNC_PARENT:
                        SyncParent();
                        return DU_S_PARTIAL;
                    }
                }
            }
        }
    }

    return DU_S_NOTHANDLED;
}

BOOL HWNDHost::OnAdjustWindowSize(int x, int y, UINT uFlags)
{
    return SetWindowPos(_hwndCtrl, NULL, 0, 0, x, y, uFlags);
}

void HWNDHost::Detach()
{
    if (_hwndCtrl)
    {
        // Unsubclass control window
        DetachWndProc(_hwndCtrl, _CtrlWndProc, this);

        // Clear our hFont from the control
        if (_hFont)
            SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)NULL, FALSE);

        // Act like it no longer exists
        _hwndCtrl = NULL;
        _pfnCtrlOrgProc = NULL;
    }
}

////////////////////////////////////////////////////////
// Match state of HWND control/sink to that of HWNDHost

void HWNDHost::SyncRect(UINT nChangeFlags, bool bForceSync)
{
    // Get size of gadget in container coordinates
    RECT rcConPxl;
    GetGadgetRect(GetDisplayNode(), &rcConPxl, SGR_CONTAINER);

    // See if rect really did change
    if (!EqualRect(&rcConPxl, &_rcBounds) || bForceSync)
    {
        if (!IsDestroyed() && GetVisible())
        {
            // Update bounds cache
            SetRect(&_rcBounds, rcConPxl.left, rcConPxl.top, rcConPxl.right, rcConPxl.bottom);

            // Map gadget flags to SWP flags
            UINT nSwpFlags = SWP_NOACTIVATE | SWP_NOZORDER;
            if (!(nChangeFlags & SGR_MOVE))
                nSwpFlags |= SWP_NOMOVE;

            if (!(nChangeFlags & SGR_SIZE))
                nSwpFlags |= SWP_NOSIZE;

            // Determine inset of sink and control based on border and padding of HWNDHost
            RECT rcSink = rcConPxl;

            Value* pvRect;

            const RECT* prc = GetBorderThickness(&pvRect);
            rcSink.left   += prc->left;
            rcSink.top    += prc->top;
            rcSink.right  -= prc->right;
            rcSink.bottom -= prc->bottom;
            pvRect->Release();

            prc = GetPadding(&pvRect);
            rcSink.left   += prc->left;
            rcSink.top    += prc->top;
            rcSink.right  -= prc->right;
            rcSink.bottom -= prc->bottom;
            pvRect->Release();

            // Bounds check
            if (rcSink.right < rcSink.left)
                rcSink.right = rcSink.left;

            if (rcSink.bottom < rcSink.top)
                rcSink.bottom = rcSink.top;

            SIZE sizeExt = { rcSink.right - rcSink.left, rcSink.bottom - rcSink.top };

            // Set sink HWND
            SetWindowPos(_hwndSink, NULL, rcSink.left, rcSink.top, sizeExt.cx, sizeExt.cy, nSwpFlags);

            // Set child HWND only if size changed
            if (nChangeFlags & SGR_SIZE)
            {
                nSwpFlags |= SWP_NOMOVE;
                OnAdjustWindowSize(sizeExt.cx, sizeExt.cy, nSwpFlags);
            }

            // Setup clipping region for sink/ctrl
            HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
            if (hrgn != NULL)
            {
                if (GetGadgetRgn(GetDisplayNode(), GRT_VISRGN, hrgn, 0))
                {
                    // Region is relative to container, offset for SetWindowRgn
                    // which requires the region relative to itself
                    // On success, system will own (and destroy) the region
                    OffsetRgn(hrgn, -rcConPxl.left, -rcConPxl.top);
                    if (!SetWindowRgn(_hwndSink, hrgn, TRUE))
                    {
                        DeleteObject(hrgn);
                    }
                }
                else
                {
                    DeleteObject(hrgn);
                }
            }
        }
    }
}

void HWNDHost::SyncParent()
{
    SyncRect(SGR_MOVE | SGR_SIZE);
}

void HWNDHost::SyncStyle()
{
    SyncRect(SGR_MOVE | SGR_SIZE);
}

void HWNDHost::SyncVisible()
{
    if (!IsDestroyed())
        ShowWindow(_hwndSink, GetVisible() ? SW_SHOW : SW_HIDE);
}

// Match HWND control's font to font properties of HWNDHost
void HWNDHost::SyncFont()
{
    if (!IsDestroyed())
    {
        Value* pvFFace;

        LPWSTR pszFamily = GetFontFace(&pvFFace);
        int dSize = GetFontSize();
        int dWeight = GetFontWeight();
        int dStyle = GetFontStyle();
        int dAngle = 0;

        if (_nCreate & HHC_CacheFont)
        {
            // Automatically cache font sent via WM_SETFONT

            // Destroy record first, if exists
            if (_hFont)
            {
                DeleteObject(_hFont);
                _hFont = NULL;
            }

            // Create new font
            LOGFONTW lf;
            ZeroMemory(&lf, sizeof(LOGFONT));

            lf.lfHeight = dSize;
            lf.lfWeight = dWeight;
            lf.lfItalic = (dStyle & FS_Italic) != 0;
            lf.lfUnderline = (dStyle & FS_Underline) != 0;
            lf.lfStrikeOut = (dStyle & FS_StrikeOut) != 0;
            lf.lfCharSet = DEFAULT_CHARSET;
            lf.lfQuality = DEFAULT_QUALITY;
            lf.lfEscapement = dAngle;
            lf.lfOrientation = dAngle;
            wcscpy(lf.lfFaceName, pszFamily);

            // Create
            _hFont = CreateFontIndirectW(&lf);

            pvFFace->Release();

            // Send to control
            SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)_hFont, TRUE);
        }
        else
        {
            // No font caching, WM_SETFONT handled expected to cache font

            FontCache* pfc = GetFontCache();
            if (pfc)
            {
                HFONT hFont = pfc->CheckOutFont(pszFamily, dSize, dWeight, dStyle, dAngle);
    
                SendMessageW(_hwndCtrl, WM_SETFONT, (WPARAM)hFont, TRUE);

                pfc->CheckInFont();
            }
        }
    }
}

// Match HWND control's text to content property of HWNDHost
void HWNDHost::SyncText()
{
    if (!IsDestroyed() && (_nCreate & HHC_SyncText))
    {
        // Hosted HWND content
        int dLen = GetWindowTextLengthW(_hwndCtrl) + 1;  // Including NULL terminator
        LPWSTR pszHWND = (LPWSTR)HAlloc(dLen * sizeof(WCHAR));
        if (pszHWND)
        {
            // HWND content
            GetWindowTextW(_hwndCtrl, pszHWND, dLen);

            // New Element content
            Value* pvNew;
            LPCWSTR pszNew = GetContentString(&pvNew);
            if (!pszNew)
                pszNew = L"";  // Convert NULL pointer to NULL content

            // Compare and update if different
            if (wcscmp(pszHWND, pszNew))
                SetWindowTextW(_hwndCtrl, pszNew);

            pvNew->Release();

            HFree(pszHWND);
        }
    }
}

////////////////////////////////////////////////////////
// Sink and control subclass procs

// Return value is whether to call overridden window proc
BOOL CALLBACK HWNDHost::_SinkWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    UNREFERENCED_PARAMETER(hwnd);

    HWNDHost* phh = (HWNDHost*)pThis;

    switch (nMsg)
    {
    case WM_COMMAND:
    case WM_NOTIFY:

        // Fire HWNDHost system event (direct only)
        return (phh->OnNotify(nMsg, wParam, lParam, plRet)) ? true : false;
    
    case WM_GETOBJECT:
        //
        // Refuse to give out any accessibility information for our sink window.
        //
        *plRet = 0;
        return TRUE;

    case WM_DESTROY:
        phh->_hwndSink = NULL;
        break;

    }

    return FALSE;  // Pass to subclassed window proc
}

// Intercept all messages to HWND control and convert them to gadget messages. These messages
// will surface as DirectUI events and will route and bubble. Upon reaching the HWNDHost,
// it will be converted back to a HWND message and conditionally sent

// Return value is whether to call overridden window proc (FALSE = call subclassed window proc)
BOOL CALLBACK HWNDHost::_CtrlWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    HWNDHost* phh = (HWNDHost*)pThis;

    switch (nMsg)
    {
    // Keyboard input, convert. Will be routed and bubbled
    case WM_KEYUP:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            return ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParam, plRet);

        break;

    // Mouse input, convert. Will be routed and bubbled
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
    case WM_MOUSEHOVER:
    case WM_MOUSEWHEEL:
    {
        if (!(phh->_nCreate & HHC_NoMouseForward))
        {
            // Convert mouse messages so coordinates are relative to root
            HWND hwndRoot = ::GetParent(phh->_hwndSink);

            POINT ptRoot;
            ptRoot.x = GET_X_LPARAM(lParam);
            ptRoot.y = GET_Y_LPARAM(lParam);
            MapWindowPoints(hwnd, hwndRoot, &ptRoot, 1);

            LPARAM lParamNew = (LPARAM)POINTTOPOINTS(ptRoot);

            return ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParamNew, plRet);
        }

        break;
    }

    // Map focus
    case WM_SETFOCUS:
        //DUITrace("HWNDHost, SetFocus()\n");
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            phh->SetKeyFocus();
        break;

    // Map lost focus
    case WM_KILLFOCUS:
        if (!(phh->_nCreate & HHC_NoKeyboardForward))
            ForwardGadgetMessage(phh->GetDisplayNode(), nMsg, wParam, lParam, plRet);
        break;

    case WM_GETOBJECT:
        {
            //
            // Make sure COM has been initialized on this thread!
            //
            ElTls * pet = (ElTls*) TlsGetValue(g_dwElSlot);
            DUIAssert(pet != NULL, "This is not a DUI thread!");
            if (pet == NULL) {
                *plRet = 0;
                return TRUE;
            }
            if (pet->fCoInitialized == false) {
                CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
                pet->fCoInitialized = true;
            }
    
            if (((DWORD)lParam) == OBJID_WINDOW) {
                //
                // The object ID is refering to ourselves.  Since we contain
                // an actually HWND, we want the system to provide most of
                // the IAccessible implementation.  However, we need to
                // do some special stuff, so we have to return our own
                // implementation wrapper.
                //
                IAccessible * pAccessible = NULL;
                HRESULT hr =  phh->GetAccessibleImpl(&pAccessible);
                if (SUCCEEDED(hr)) {
                    *plRet = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                    pAccessible->Release();
    
                    //
                    // We processed the message.  Don't pass to the subclassed window proc.
                    //
                    return TRUE;
                }
            } else {
                //
                // This is one of the "standard" object identifiers, such as:
                //
                // OBJID_ALERT 
                // OBJID_CARET 
                // OBJID_CLIENT 
                // OBJID_CURSOR 
                // OBJID_HSCROLL 
                // OBJID_MENU 
                // OBJID_SIZEGRIP 
                // OBJID_SOUND 
                // OBJID_SYSMENU 
                // OBJID_TITLEBAR 
                // OBJID_VSCROLL 
                //
                // Or it could be a private identifier of the control. 
                //
                // Just pass this on to the subclassed window proc.
                //
            }
        }
        break;

    case WM_DESTROY:
        phh->_hwndCtrl = NULL;
        phh->_pfnCtrlOrgProc = NULL;
        break;
        
    }

    return FALSE;  // Pass to subclassed window proc
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDHost::Class = NULL;

HRESULT HWNDHost::Register()
{
    return ClassInfo<HWNDHost,Element>::Register(L"HWNDHost", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\refpointelement.cpp ===
/*
 * RefPointElement
 */

#include "stdafx.h"
#include "control.h"

#include "duirefpointelement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// RefPointElement

HRESULT RefPointElement::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    RefPointElement* prpe = HNew<RefPointElement>();
    if (!prpe)
        return E_OUTOFMEMORY;

    HRESULT hr = prpe->Initialize(nActive);
    if (FAILED(hr))
    {
        prpe->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = prpe;

    return S_OK;
}

HRESULT RefPointElement::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    SetActive(nActive);

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

void RefPointElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Extent) || IsProp(ReferencePoint))
    {
        // Compute actual reference point
        Value* pvRef;
        const POINT* ppt = GetReferencePoint(&pvRef);

        Value* pvActRef;

        if (ppt)
        {
            // Reflect reference point
            pvActRef = pvRef;
        }
        else
        {
            // Default to center
            Value* pvExt;
            const SIZE* psizeExt = GetExtent(&pvExt);

            pvActRef = Value::CreatePoint(psizeExt->cx / 2, psizeExt->cy / 2);

            pvExt->Release();
        }

        // Set
        _SetValue(ActualReferencePointProp, PI_Local, pvActRef);

        if (!ppt)
            pvActRef->Release();

        pvRef->Release();
    }

    // Call base implementation
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

////////////////////////////////////////////////////////
// Reference point helpers

// Search for a reference point in a tree
RefPointElement* RefPointElement::Locate(Element* pe)
{
    DUIAssert(pe, "Illegal arguments");

    RefPointElement* peFound = NULL;
    Value* pv;

    // If this is an reference point Element, return
    if (pe->GetClassInfo()->IsSubclassOf(RefPointElement::Class))
        return (RefPointElement*)pe;

    // Search, DFS
    ElementList* peList = pe->GetChildren(&pv);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peFound = Locate(peList->GetItem(i));
            if (peFound)
                break;
        }
    }
    pv->Release();

    return peFound;
}

Element* RefPointElement::FindRefPoint(Element* pe, POINT* ppt)
{
    DUIAssert(pe && ppt, "Illegal arguments");

    RefPointElement* perFound = Locate(pe);

    if (perFound)
    {
        Value* pvPoint;

        const POINT* pptRef = perFound->GetActualReferencePoint(&pvPoint);
        pe->MapElementPoint(perFound, pptRef, ppt);

        pvPoint->Release();
    }

    return perFound;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// ReferencePoint property
static int vvReferencePoint[] = { DUIV_POINT, -1 };
static PropertyInfo impReferencePointProp = { L"ReferencePoint", PF_LocalOnly, 0, vvReferencePoint, NULL, Value::pvUnset };
PropertyInfo* RefPointElement::ReferencePointProp = &impReferencePointProp;

// ActualReferencePoint property
static int vvActualReferencePoint[] = { DUIV_POINT, -1 };
static PropertyInfo impActualReferencePointProp = { L"ActualReferencePoint", PF_Normal|PF_ReadOnly, PG_AffectsParentLayout, vvReferencePoint, NULL, Value::pvPointZero };
PropertyInfo* RefPointElement::ActualReferencePointProp = &impActualReferencePointProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                  RefPointElement::ReferencePointProp,
                                  RefPointElement::ActualReferencePointProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* RefPointElement::Class = NULL;

HRESULT RefPointElement::Register()
{
    return ClassInfo<RefPointElement,Element>::Register(L"RefPointElement", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\sources.inc ===
!IF 0

    DirectUI Control Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\behavior.cpp        \
        ..\button.cpp          \
        ..\edit.cpp            \
        ..\combobox.cpp        \
        ..\hwndhost.cpp        \
        ..\native.cpp          \
        ..\progress.cpp        \
        ..\refpointelement.cpp \
        ..\repeatbutton.cpp    \
        ..\scrollbar.cpp       \
        ..\scrollviewer.cpp    \
        ..\selector.cpp        \
        ..\thumb.cpp           \
        ..\viewer.cpp          \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxcontrol.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\repeatbutton.cpp ===
/*
 * RepeatButton
 */

#include "stdafx.h"
#include "control.h"

#include "duirepeatbutton.h"

#include "Behavior.h"

namespace DirectUI
{

// Inernal helper (defined in Button)
extern inline void _FireClickEvent(Button* peTarget, ClickInfo* pci);

////////////////////////////////////////////////////////
// Event types

// Fires 'ButtonClickEvent'

////////////////////////////////////////////////////////
// RepeatButton

HRESULT RepeatButton::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    RepeatButton* prb = HNew<RepeatButton>();
    if (!prb)
        return E_OUTOFMEMORY;

    HRESULT hr = prb->Initialize(nActive);
    if (FAILED(hr))
    {
        prb->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = prb;

    return S_OK;
}

HRESULT RepeatButton::Initialize(UINT nActive)
{
    HRESULT hr;

    // Initialize base
    hr = Button::Initialize(nActive);
    if (FAILED(hr))
        return hr;

    // Initialize
    _hAction = NULL;
    _fActionDelay = false;

    return S_OK;
}

////////////////////////////////////////////////////////
// Global action callback

void RepeatButton::_RepeatButtonActionCallback(GMA_ACTIONINFO* pmai)
{
    DUIAssert(pmai->pvData, "RepeatButton data should be non-NULL");

    //DUITrace("RepeatButton Action <%x>\n", pmai->pvData);

    // Fire click event
    if (!pmai->fFinished)
    {
        // todo -- pick some better values than this -- when behavior is made public, all we have to do is hold a ClickInfo as a 
        // data member on RepeatButton
        ClickInfo ci;
        ci.nCount = 1;
        ci.pt.x = -1;
        ci.pt.y = -1;
        ci.uModifiers = 0;
        _FireClickEvent((RepeatButton*) pmai->pvData, &ci);
    }
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void RepeatButton::OnInput(InputEvent* pie)
{
    BOOL bPressed = GetPressed(); // sucks to have to call GetPressed here because it's not always needed
    BOOL bPressedBefore = bPressed;
    ClickInfo ci;

    // First, watch for a click event
    BOOL bFire = CheckRepeatClick(this, pie, GBUTTON_LEFT, &bPressed, &_fActionDelay, &_hAction, _RepeatButtonActionCallback, &ci);

    if (bPressed != bPressedBefore)
    {
        if (bPressed)
            SetPressed(true);
        else
            RemoveLocalValue(PressedProp);
    }
    if (bFire) 
        _FireClickEvent(this, &ci);

    if (pie->fHandled)
        return;

    Element::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties

// Define class info with type and base type, set static class pointer
IClassInfo* RepeatButton::Class = NULL;

HRESULT RepeatButton::Register()
{
    return ClassInfo<RepeatButton,Button>::Register(L"RepeatButton", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\selector.cpp ===
/*
 * Selector
 */

#include "stdafx.h"
#include "control.h"

#include "duiselector.h"

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Selector, SelectionChange)  // SelectionChangeEvent struct

////////////////////////////////////////////////////////
// Selector

HRESULT Selector::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Selector* ps = HNew<Selector>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppElement = ps;

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

// Validation
void Selector::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selection))
    {
        // Setup SelectionChange event
        SelectionChangeEvent sce;
        sce.uidType = SelectionChange;
        sce.peOld = pvOld->GetElement();
        sce.peNew = pvNew->GetElement();

        // Update selected properties on elements
        if (sce.peOld)
            sce.peOld->RemoveLocalValue(SelectedProp);

        if (sce.peNew)
            sce.peNew->SetSelected(true);

        // Fire bubbling event
        //DUITrace("SelectionChange! <%x>, O:%x N:%x\n", this, sce.peOld, sce.peNew);

        FireEvent(&sce);  // Will route and bubble
    }
    else if (IsProp(Children))
    {
        // Check if child list change affects selection

        Element* peSel = GetSelection();
        if (peSel)
        {
            DUIAssert(pvOld->GetElementList()->GetIndexOf(peSel) != -1, "Stored selection invalid");

            // Children property (and Index) is updated before the Parent property of all the children.
            // As a result, this notification may happen before the Parent property
            // changes on the child. Use new array and index to determine if child is still in it
            ElementList* peList = pvNew->GetElementList();
            if ((peSel->GetIndex() == -1) || !peList || ((UINT)peSel->GetIndex() >= peList->GetSize()) ||
                (peList->GetItem(peSel->GetIndex()) != peSel))
            {
                // Item is no longer in list
                RemoveLocalValue(SelectionProp);
                peSel->RemoveLocalValue(SelectedProp);
            }
        }
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

// Pointer is only guaranteed good for the lifetime of the call
void Selector::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                if ((pke->nCode == GKEY_CHAR) && (pke->ch == VK_TAB))
                    // don't allow tab key to perform child navigation at this level
                    return;
            }
        }
    }

    Element::OnInput(pie);
}

void Selector::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    Element::OnKeyFocusMoved(peFrom, peTo);

    if (peTo && peTo->GetParent() == this)
    {
        SetSelection(peTo);
    }
}

// Generic eventing

void Selector::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if ((pEvent->nStage == GMF_DIRECT) || (pEvent->nStage == GMF_BUBBLED))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
        }
    }
    return Element::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// Hierarchy

Element* Selector::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    if (!peFrom)
    {
        Element* pe = GetSelection();
        if (pe)
            pe = pe->GetAdjacent(NULL, iNavDir, pnr, bKeyable);
        if (pe)
            return pe;
    }
    else if (iNavDir & NAV_LOGICAL)
    {
        return NULL;
    }

    return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Selection property
static int vvSelection[] = { DUIV_ELEMENTREF, -1 };
static PropertyInfo impSelectionProp = { L"Selection", PF_Normal, 0, vvSelection, NULL, Value::pvElementNull };
PropertyInfo* Selector::SelectionProp = &impSelectionProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Selector::SelectionProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Selector::Class = NULL;

HRESULT Selector::Register()
{
    return ClassInfo<Selector,Element>::Register(L"Selector", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\scrollviewer.cpp ===
/*
 * ScrollViewer
 */

#include "stdafx.h"
#include "control.h"

#include "duiscrollviewer.h"
#include "duininegridlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// ScrollViewer

HRESULT ScrollViewer::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ScrollViewer* psv = HNew<ScrollViewer>();
    if (!psv)
        return E_OUTOFMEMORY;

    HRESULT hr = psv->Initialize();
    if (FAILED(hr))
    {
        psv->Destroy();
        return E_OUTOFMEMORY;
    }

    *ppElement = psv;

    return S_OK;
}

HRESULT ScrollViewer::Initialize()
{
    _peVScroll = NULL;
    _peHScroll = NULL;
    _peViewer = NULL;
    NineGridLayout* pngl = NULL;

    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        goto Failed;
    
    // Create children
    hr = ScrollBar::Create(true, (Element**)&_peVScroll);
    if (FAILED(hr))
        goto Failed;

    hr = ScrollBar::Create(true, (Element**)&_peHScroll);
    if (FAILED(hr))
        goto Failed;

    hr = Viewer::Create((Element**)&_peViewer);
    if (FAILED(hr))
        goto Failed;

    hr = NineGridLayout::Create((Layout**)&pngl);
    if (FAILED(hr))
        goto Failed;

    StartDefer();

    // Setup state
    _peContent = NULL;

    SetActive(AE_Inactive);
    SetLayout(pngl);

    // Children state
    Element::Add(_peVScroll);

    _peHScroll->SetVertical(false);
    Element::Add(_peHScroll);

    Element::Add(_peViewer);
    _peViewer->AddListener(this);

    // For mouse wheel support
    SetActive(AE_Mouse);

    EndDefer();

    return S_OK;

Failed:

    if (_peVScroll)
    {
        _peVScroll->Destroy();
        _peVScroll = NULL;
    }

    if (_peHScroll)
    {
        _peHScroll->Destroy();
        _peHScroll = NULL;
    }

    if (_peViewer)
    {
        _peViewer->Destroy();
        _peViewer = NULL;
    }

    if (pngl)
    {
        pngl->Destroy();
        pngl = NULL;
    }

    return hr;
}

////////////////////////////////////////////////////////
// Generic eventing

void ScrollViewer::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == ScrollBar::Scroll)
        {
            // Scroll bar scrollevent
            ScrollEvent* se = (ScrollEvent*) pEvent;

            if (pEvent->peTarget == _peHScroll)
            {
                SetXOffset(se->dPos);
                _peViewer->SetXOffset(se->dPos);
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _peVScroll)
            {
                SetYOffset(se->dPos);
                _peViewer->SetYOffset(se->dPos);
                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Element::KeyboardNavigate)
        {
            // If receiving a keyboard navigate event, no child did anything with it.
            // Stop navigation from moving outside of scroll viewer. Also, adjust 
            // scrolling position to unsure non-keyfocusable items get shown
        
            KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*) pEvent;
            
            if (!(pkne->iNavDir & NAV_LOGICAL))
            {
                if (pkne->iNavDir == NAV_UP)
                    _peVScroll->PageUp();
                else if (pkne->iNavDir == NAV_DOWN)
                    _peVScroll->PageDown();
                else if (pkne->iNavDir == NAV_LEFT)
                    _peHScroll->PageUp();
                else if (pkne->iNavDir == NAV_RIGHT)
                    _peHScroll->PageDown();
            
                pEvent->fHandled = true;
                return;
            }
        }
    }

    Element::OnEvent(pEvent);
}

HRESULT ScrollViewer::Add(Element** ppe, UINT cCount)
{
    UINT cRun = 0;
    HRESULT hr;

    for (UINT i = 0; i < cCount; i++)
    {
        if ((ppe[i] != _peVScroll) && (ppe[i] != _peHScroll) && (ppe[i] != _peViewer))
        {
            hr = _peViewer->Add(ppe[i]);
            if (FAILED(hr))
                goto Failed;

            if (cRun)
            {
                hr = Element::Add(ppe + (i - cRun), cRun);
                if (FAILED(hr))
                    goto Failed;
            }

            cRun = 0;
        }
        else
            cRun++;
    }

    if (cRun)
    {
        hr = Element::Add(ppe + (cCount - cRun), cRun);
        if (FAILED(hr))
            goto Failed;
    }

    return S_OK;

Failed:
    
    return hr;
}

////////////////////////////////////////////////////////
// System events

// Validation
bool ScrollViewer::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

    // use the scrollbars as our "validators" for XOffset and YOffset values
    if (ppi == XOffsetProp)
    {
        int x = pvNew->GetInt();
        _peHScroll->SetPosition(x);
        int xNew = _peHScroll->GetPosition();
        if (x != xNew)
        {
            SetXOffset(xNew);
            return false;
        }
    }
    else if (ppi == YOffsetProp)
    {
        int y = pvNew->GetInt();
        _peVScroll->SetPosition(y);
        int yNew = _peVScroll->GetPosition();
        if (y != yNew)
        {
            SetYOffset(yNew);
            return false;
        }
    }
    return true;
}

void ScrollViewer::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(XOffset))
    {
        // the scrollbar is updated in the OnPropertyChanging -- so now we only need to update the viewer
        _peViewer->SetXOffset(pvNew->GetInt());
    }
    else if (IsProp(YOffset))
    {
        // the scrollbar is updated in the OnPropertyChanging -- so now we only need to update the viewer
        _peViewer->SetYOffset(pvNew->GetInt());
    }
    else if (IsProp(XScrollable))
    {
        bool fScrollable = pvNew->GetBool();
        _peViewer->SetXScrollable(fScrollable);
        CheckScroll(_peHScroll, fScrollable,      GetXBarVisibility());
        CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());
    }
    else if (IsProp(YScrollable))
    {
        bool fScrollable = pvNew->GetBool();
        _peViewer->SetYScrollable(fScrollable);
        CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
        CheckScroll(_peVScroll, fScrollable,      GetYBarVisibility());
    }
    else if (IsProp(YBarVisibility))
    {
        CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
        CheckScroll(_peVScroll, GetYScrollable(), pvNew->GetInt());
    }
    else if (IsProp(XBarVisibility))
    {
        CheckScroll(_peHScroll, GetXScrollable(), pvNew->GetInt());
        CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void ScrollViewer::OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (peFrom == _peViewer)
    {
        if (IsProp(Viewer::XOffset))
            SetXOffset(pvNew->GetInt());
        else if (IsProp(Viewer::YOffset))
            SetYOffset(pvNew->GetInt());
        else if (IsProp(Viewer::XScrollable))
            SetXScrollable(pvNew->GetBool());
        else if (IsProp(Viewer::YScrollable))
            SetYScrollable(pvNew->GetBool());
        else if (IsProp(Children))
        {
            ElementList* pelOld = pvOld->GetElementList();
            ElementList* pelNew = pvNew->GetElementList();

            if (pelOld)
                pelOld->GetItem(0)->RemoveListener(this);

            if (pelNew)
            {
                _peContent = pelNew->GetItem(0);
                _peContent->AddListener(this);
            }
        }
        else if (IsProp(Extent))
        {
            // Update scroller metrics (extent of viewer has changed due to a layout, make changes
            // to other ScrollViewer controls to reflect this which will cause another layout)
            // Before that happens, check if scroller is pinned (since position may change)
            bool fVPinned = false;
            bool fHPinned = false;

            int nPinning = GetPinning();

            if (nPinning & P_Vert)
                fVPinned = _peVScroll->IsPinned();
            if (nPinning & P_Horz)
                fHPinned = _peHScroll->IsPinned();

            const SIZE* psize = pvNew->GetSize();
            _peHScroll->SetPage(psize->cx);
            _peVScroll->SetPage(psize->cy);
            
            CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
            CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());

            if (fVPinned)
                _peVScroll->End();
            if (fHPinned)
                _peHScroll->End();
        }
    }
    else if (peFrom == _peContent)
    {
        if (IsProp(Extent))
        {
            // Update scroller metrics (extent of content has changed due to a layout, make changes
            // to other ScrollViewer controls to reflect this which will cause another layout)
            // Before that happens, check if scroller is pinned (since position may change)
            bool fVPinned = false;
            bool fHPinned = false;

            int nPinning = GetPinning();

            if (nPinning & P_Vert)
                fVPinned = _peVScroll->IsPinned();
            if (nPinning & P_Horz)
                fHPinned = _peHScroll->IsPinned();
                
            const SIZE* psize = pvNew->GetSize();
            _peHScroll->SetMaximum(psize->cx - 1);
            _peVScroll->SetMaximum(psize->cy - 1);
            Value* pvSize;
            psize =_peViewer->GetExtent(&pvSize);
            _peHScroll->SetPage(psize->cx);
            _peVScroll->SetPage(psize->cy);
            pvSize->Release();
            
            CheckScroll(_peHScroll, GetXScrollable(), GetXBarVisibility());
            CheckScroll(_peVScroll, GetYScrollable(), GetYBarVisibility());

            if (fVPinned)
                _peVScroll->End();
            if (fHPinned)
                _peHScroll->End();
        }
    }
}

void ScrollViewer::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
            case GINPUT_KEYBOARD:
                {
                    KeyboardEvent* pke = (KeyboardEvent*)pie;
                    switch (pke->nCode)
                    {
                    case GKEY_DOWN:
                        switch (pke->ch)
                        {
                            // todo:  support moving offset with these keys if the child is not key active
                            case VK_DOWN:
                            case VK_UP:
                            case VK_LEFT:
                            case VK_RIGHT:
                            case VK_HOME:
                            case VK_END:
                                pie->fHandled = true;
                                return;
                       }
                    }
                }
                break;

            case GINPUT_MOUSE:
                {
                    MouseEvent* pme = (MouseEvent*)pie;
                    if ((pme->nCode == GMOUSE_WHEEL) && GetYScrollable())
                    {
                        StartDefer();

                        int sWheel = ((MouseWheelEvent*)pme)->sWheel;
                        bool fUp =  sWheel > 0;
                        UINT nDelta = abs(sWheel) / WHEEL_DELTA;
                        UINT nMultiplier = 1;

                        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nMultiplier, FALSE);

                        if (nMultiplier == WHEEL_PAGESCROLL)
                        {
                            if (fUp)
                                _peVScroll->PageUp(nDelta);
                            else
                                _peVScroll->PageDown(nDelta);
                        }
                        else
                        {
                            if (fUp)
                                _peVScroll->LineUp(nDelta * nMultiplier);
                            else
                                _peVScroll->LineDown(nDelta * nMultiplier);
                        }

                        //DUITrace("SV: Wheel, Delta: %d, Multiplier: %d\n", nDelta, nMultiplier);

                        EndDefer();
                        
                        pme->fHandled = true;
                        return;
                    }
                }
                break;
        }
     }

    Element::OnInput(pie);
}

void ScrollViewer::CheckScroll(ScrollBar* psb, BOOL fScrollable, int iVisibility)
{
    if (!fScrollable)
    {
        psb->SetLayoutPos(LP_None);
        return;
    }

    fScrollable = psb->IsScrollable();
    if (iVisibility == BV_Always)
    {
        if (fScrollable)
            psb->RemoveLocalValue(EnabledProp);
        else
            psb->SetEnabled(false);

        psb->RemoveLocalValue(LayoutPosProp);
    }
    else if ((iVisibility == BV_AsNeeded) && fScrollable)
        psb->RemoveLocalValue(LayoutPosProp);
    else
        psb->SetLayoutPos(LP_None);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// XOffset property
static int vvXOffset[] = { DUIV_INT, -1 };
static PropertyInfo impXOffsetProp = { L"XOffset", PF_Normal, 0, vvXOffset, NULL, Value::pvIntZero };
PropertyInfo* ScrollViewer::XOffsetProp = &impXOffsetProp;

// YOffset property
static int vvYOffset[] = { DUIV_INT, -1 };
static PropertyInfo impYOffsetProp = { L"YOffset", PF_Normal, 0, vvYOffset, NULL, Value::pvIntZero };
PropertyInfo* ScrollViewer::YOffsetProp = &impYOffsetProp;

// XScrollable property
static int vvXScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impXScrollableProp = { L"XScrollable", PF_Normal, 0, vvXScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollViewer::XScrollableProp = &impXScrollableProp;

// YScrollable property
static int vvYScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impYScrollableProp = { L"YScrollable", PF_Normal, 0, vvYScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollViewer::YScrollableProp = &impYScrollableProp;

static EnumMap emVisibility[] = { { L"AsNeeded", BV_AsNeeded }, { L"Always", BV_Always }, { L"Never", BV_Never } };

// XBarVisibility property
static int vvXBarVisibility[] = { DUIV_INT, -1 }; StaticValue(svDefaultBarVisibility, DUIV_INT, BV_AsNeeded);  
static PropertyInfo impXBarVisibilityProp = { L"XBarVisibility", PF_Normal, 0, vvXBarVisibility, emVisibility, (Value*)&svDefaultBarVisibility };
PropertyInfo* ScrollViewer::XBarVisibilityProp = &impXBarVisibilityProp;

// YBarVisibility property
static int vvYBarVisibility[] = { DUIV_INT, -1 }; StaticValue(svDefaultYBarVisibility, DUIV_INT, 0);
static PropertyInfo impYBarVisibilityProp = { L"YBarVisibility", PF_Normal, 0, vvYBarVisibility, emVisibility, (Value*)&svDefaultBarVisibility };
PropertyInfo* ScrollViewer::YBarVisibilityProp = &impYBarVisibilityProp;

// Pinning property
static int vvPinning[] = { DUIV_INT, -1 };
static EnumMap emPinning[] = { { L"NoPin", P_None}, { L"PinHorz", P_Horz }, { L"PinVert", P_Vert } };
static PropertyInfo impPinningProp = { L"Pinning", PF_Normal | PF_Cascade, 0, vvPinning, emPinning, Value::pvIntZero };
PropertyInfo* ScrollViewer::PinningProp = &impPinningProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ScrollViewer::XOffsetProp,
                                ScrollViewer::YOffsetProp,
                                ScrollViewer::XScrollableProp,
                                ScrollViewer::YScrollableProp,
                                ScrollViewer::XBarVisibilityProp,
                                ScrollViewer::YBarVisibilityProp,
                                ScrollViewer::PinningProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ScrollViewer::Class = NULL;

HRESULT ScrollViewer::Register()
{
    return ClassInfo<ScrollViewer,Element>::Register(L"ScrollViewer", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\scrollbar.cpp ===
/*
 * ScrollBar
 */

#include "stdafx.h"
#include "control.h"

#include "duiscrollbar.h"

#include "duirepeatbutton.h"
#include "duithumb.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(ScrollBar, Scroll) // ScrollEvent

////////////////////////////////////////////////////////
// ScrollBar

HRESULT ScrollBar::Create(bool fBuildSubTree, OUT Element** ppElement)
{
    *ppElement = NULL;

    ScrollBar* psb = HNew<ScrollBar>();
    if (!psb)
        return E_OUTOFMEMORY;

    HRESULT hr = psb->Initialize(fBuildSubTree);
    if (FAILED(hr))
        return hr;

    *ppElement = psb;

    return S_OK;
}

HRESULT ScrollBar::Initialize(bool fBuildSubTree)
{
    HRESULT hr;

    for (int i = 0; i < SP_Count; i++)
        _peParts[i] = NULL;

    // Initialize base
    hr = Element::Initialize(EC_SelfLayout); // Normal display node creation, self-layout
    if (FAILED(hr))
        goto Failed;
    
    if (fBuildSubTree)
    {
        hr = RepeatButton::Create(AE_Mouse, &_peLineUp);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_pePageUp);
        if (FAILED(hr))
            goto Failed;

        hr = Thumb::Create(AE_Mouse, &_peThumb);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_pePageDown);
        if (FAILED(hr))
            goto Failed;

        hr = RepeatButton::Create(AE_Mouse, &_peLineDown);
        if (FAILED(hr))
            goto Failed;

        StartDefer();

        // Scroll bar settings
        SetActive(AE_Mouse);

        _fPinned = false;

        // Complete initialization of children
        _peLineUp->SetID(L"LineUp");
        _peLineUp->SetClass(L"Line");

        _pePageUp->SetID(L"PageUp");
        _pePageUp->SetClass(L"Page");

        _peThumb->SetID(L"Thumb");

        _pePageDown->SetID(L"PageDown");
        _pePageDown->SetClass(L"Page");

        _peLineDown->SetID(L"LineDown");
        _peLineDown->SetClass(L"Line");

        Add(_peParts, SP_Count);

        EndDefer();
    }

    return S_OK;

Failed:

    for (i = 0; i < SP_Count; i++)
    {
        if (_peParts[i])
        {
            _peParts[i]->Destroy();
            _peParts[i] = NULL;
        }
    }

    return hr;
}

bool ScrollBar::IsScrollable()
{
    int iMax = GetMaximum();
    int iMin = GetMinimum();

    int iDiff = iMax - iMin;

    if (iDiff <= 0)
        return false;

    int iPage = GetProportional() ? GetPage() : 1;

    return (iDiff + 1) > iPage;
}

////////////////////////////////////////////////////////
// Generic eventing


void ScrollBar::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*) pEvent;

            if (pbce->peTarget == _peLineUp)
                LineUp();
            else if (pbce->peTarget == _peLineDown)
                LineDown();
            else if (pbce->peTarget == _pePageUp)
                PageUp();
            else if (pbce->peTarget == _pePageDown)
                PageDown();

            pEvent->fHandled = true;
            return;
        }
        else if (pEvent->uidType == Thumb::Drag)
        {
            ThumbDragEvent* ptde = (ThumbDragEvent*)pEvent;

            if (ptde->peTarget == _peThumb && _cTrack)
            {
                Value* pvLocation;

                const POINT* ppt = _peThumb->GetLocation(&pvLocation);
                int posNew = GetVertical() ? (ppt->y + ptde->sizeDelta.cy) : (ppt->x + ptde->sizeDelta.cy);
                pvLocation->Release();
                int min = GetMinimum();
                long lEffectivePos = 0;

                if (posNew > _posTop)
                {
                    int max = GetMaximum();
                    long lEffectiveRange = (((long) max - min) + 1) - (GetProportional() ? GetPage() : 1);       

                    lEffectivePos = (((long) posNew - _posTop) * lEffectiveRange + _cTrack / 2) / _cTrack;

                    if (lEffectivePos > lEffectiveRange)
                        lEffectivePos = lEffectiveRange;
                }

                SetPosition(min + lEffectivePos);

                pEvent->fHandled = true;
                return;
            }
        }
    }
}

////////////////////////////////////////////////////////
// System events

// Validation
bool ScrollBar::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);

    if (ppi == PositionProp)
    {
        int dPos = pvNew->GetInt();

        int dMin = GetMinimum();

        if (dPos < dMin)
        {
            SetPosition(dMin);
            return false;
        }
        else
        {
            int dMax = GetMaximum();
            if (GetProportional())
            {
                dMax -= GetPage() - 1;
                if (dMax < dMin)
                    dMax = dMin;
            }
            if (dPos > dMax)        
            {
                SetPosition(dMax);
                return false;            
            }
        }
    }
    else if (ppi == PageProp)
    {
        int dPage = pvNew->GetInt();

        int dMax = GetMaximum() - GetMinimum() + 1;
        if (dPage > dMax)
        {
            SetPage(dMax);
            return false;
        }
    }

    return true;
}

void ScrollBar::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Position))
    {
        // Fire scroll event
        //DUITrace("Scroll Event <%x>: %d\n", this, pvNew->GetInt());

        ScrollEvent se;
        se.uidType = Scroll;
        se.dPos = pvNew->GetInt();

        // Scrollbar position is changing. Update the ScrollBar's "pinned state" (i.e.
        // bar at maximum position) only if the ScrollBar is in use
        if (GetLayoutPos() != LP_None)
        {
            int iPage = GetProportional() ? GetPage() : 1;
            _fPinned = (GetPosition() == (GetMaximum() - iPage + 1));
        }

        FireEvent(&se); // Will route and bubble
    }
    else if (IsProp(Vertical))
    {
        bool bVert = pvNew->GetBool();
        _peLineUp->SetID(bVert ? L"LineUp" : L"LineLeft");
        _pePageUp->SetID(bVert ? L"PageUp" : L"PageLeft");
        _peThumb->SetID(bVert ? L"Thumb" : L"HThumb");
        _pePageDown->SetID(bVert ? L"PageDown" : L"PageRight");
        _peLineDown->SetID(bVert ? L"LineDown" : L"LineRight");
    }
    else if (IsProp(Minimum))
    {
        int min = pvNew->GetInt();
        if (GetPosition() < min)
            SetPosition(min);
    }
    else if (IsProp(Maximum))
    {
        int max = pvNew->GetInt();

        if (GetProportional())
        {
            max -= GetPage() - 1;
            int min = GetMinimum();
            if (max < min)
                max = min;
        }

        if (GetPosition() > max)
            SetPosition(max);
    }
    else if (IsProp(Page))
    {
        int max = GetMaximum();

        if (GetProportional())
        {
            max -= pvNew->GetInt() - 1;
            int min = GetMinimum();
            if (max < min)
                max = min;
        }

        if (GetPosition() > max)
            SetPosition(max);
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

int ScrollBar::GetPageInc()
{
    int inc = GetPage();

    if (GetProportional())
        // if non-proportional, then page is the exact page amount; otherwise, we have to reduce the page by a line increment
        inc -= GetLine();

    return (inc > 0) ? inc : 1;
}

////////////////////////////////////////////////////////
// Self-layout methods

#define X 0
#define Y 1

void ScrollBar::_SelfLayoutDoLayout(int cx, int cy)
{
    bool bVertical = GetVertical();

    int iLen = bVertical ? 1 : 0;
    int iThick  = bVertical ? 0 : 1;

    int cRemaining = bVertical ? cy : cx;
    int cThick  = bVertical ? cx : cy;
    
    int c[2][SP_Count] = { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 } };

    for (int i = 0; i < SP_Count; i++)
        c[iThick][i] = cThick;

    // Get extents of line up and down
    c[iLen][SP_LineUp]   = ((int*) (_peLineUp->GetDesiredSize()))[iLen];
    c[iLen][SP_LineDown] = ((int*) (_peLineDown->GetDesiredSize()))[iLen];
    int cLineLen = c[iLen][SP_LineUp] + c[iLen][SP_LineDown];

    if (cLineLen > cRemaining)
    {
        c[iLen][SP_LineUp] = cRemaining / 2;
        c[iLen][SP_LineDown] = cRemaining - c[iLen][SP_LineUp];
        cRemaining = 0;
        _cTrack = 0;
    }
    else
    {
        // Get metrics of scroll bar
        bool bProportional = GetProportional();
        int dPos = GetPosition(); // dMin <= dPos <= (dMax - dPage)
        int dMin = GetMinimum();
        int dMax = GetMaximum();
        int dPage = bProportional ? GetPage() : 1;

        cRemaining -= cLineLen;

        int cRange = (dMax - dMin) + 1;

        int cThumb = 0;

        if (bProportional)
        {
            cThumb = (cRemaining * dPage) / cRange;
            if (cThumb < 8) // 4*CXEDGE
            {
                if (cRemaining < 8)
                    cThumb = cRemaining;
                else
                    cThumb = 8;
            }
        }
        else
            cThumb = cThick;

        _cTrack = cRemaining - cThumb;

        c[iLen][SP_Thumb] = cThumb;

        if (cRange == dPage)
            c[iLen][SP_PageUp] = 0;
        else
            c[iLen][SP_PageUp] = (int) ((((long) dPos - dMin) * _cTrack) / (cRange - dPage));

        c[iLen][SP_PageDown] = cRemaining - (c[iLen][SP_PageUp] + c[iLen][SP_Thumb]);
    }

    int pos[2] = { 0, 0 };

    // Check layout order
    int iOrder = GetOrder();

    for (int i = 0; i < SP_Count; i++)
    {
        int iPart = (iOrder & 0xF);
        iOrder = iOrder >> 4;

        if (iPart == SP_PageUp)
            _posTop = pos[iLen];

        _peParts[iPart]->_UpdateLayoutPosition(pos[X], pos[Y]);
        _peParts[iPart]->_UpdateLayoutSize(c[X][iPart], c[Y][iPart]);
        pos[iLen] += c[iLen][iPart];
    }
}

SIZE ScrollBar::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    bool bVertical = GetVertical();

    int iLength = bVertical ? 1 : 0;
    int iThick  = bVertical ? 0 : 1;

    int cRemaining[2];

    cRemaining[X] = cxConstraint;
    cRemaining[Y] = cyConstraint;

    SIZE size = { 0 };

    int cMaxThick = 0;
    int cTotalLength = 0;

    int cThick;
    int cLength;

    // Check layout order
    int iOrder = GetOrder();

    size = _peParts[SP_LineUp]->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);
    cMaxThick    = ((int*) &size)[iThick];
    cTotalLength = ((int*) &size)[iLength];
    size = _peParts[SP_LineDown]->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);
    cTotalLength += ((int*) &size)[iLength];
    cThick = ((int*) &size)[iThick];
    if (cMaxThick < cThick)
        cMaxThick = cThick;

    if (cTotalLength > cRemaining[iLength])
    {
        cTotalLength = cRemaining[iLength];
        cRemaining[iLength] = 0;
    }
    else
        cRemaining[iLength] -= cTotalLength;

    for (int i = 0; i < SP_Count; i++)
    {
        int iPart = iOrder & 0xF;
        iOrder = iOrder >> 4;

        if ((iPart == SP_LineUp) || (iPart == SP_LineDown))
            continue;

        size = _peParts[iPart]->_UpdateDesiredSize(cRemaining[X], cRemaining[Y], psrf);

        cThick  = ((int*) &size)[iThick];
        cLength = ((int*) &size)[iLength];

        if (cMaxThick < cThick)
            cMaxThick = cThick;

        cTotalLength += cLength;
        cRemaining[iLength] -= cLength;
    }

    if (bVertical)
    {
        size.cx = cMaxThick;
        size.cy = cTotalLength;
    }
    else
    {
        size.cx = cTotalLength;
        size.cy = cMaxThick;
    }

    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Position property
static int vvPosition[] = { DUIV_INT, -1 };
static PropertyInfo impPositionProp = { L"Position", PF_Normal, PG_AffectsLayout, vvPosition, NULL, Value::pvIntZero };
PropertyInfo* ScrollBar::PositionProp = &impPositionProp;

// Minimum property
static int vvMinimum[] = { DUIV_INT, -1 }; 
static PropertyInfo impMinimumProp = { L"Minimum", PF_Normal, PG_AffectsLayout, vvMinimum, NULL, Value::pvIntZero };
PropertyInfo* ScrollBar::MinimumProp = &impMinimumProp;

// Maximum property
static int vvMaximum[] = { DUIV_INT, -1 }; StaticValue(svDefaultMaximum, DUIV_INT, 1000);
static PropertyInfo impMaximumProp = { L"Maximum", PF_Normal, PG_AffectsLayout, vvMaximum, NULL, (Value*)&svDefaultMaximum };
PropertyInfo* ScrollBar::MaximumProp = &impMaximumProp;

// Page property
static int vvPage[] = { DUIV_INT, -1 }; StaticValue(svDefaultPage, DUIV_INT, 250);
static PropertyInfo impPageProp = { L"Page", PF_Normal, PG_AffectsLayout, vvPage, NULL, (Value*)&svDefaultPage };
PropertyInfo* ScrollBar::PageProp = &impPageProp;

// Line property
static int vvLine[] = { DUIV_INT, -1 }; StaticValue(svDefaultLine, DUIV_INT, 10);
static PropertyInfo impLineProp = { L"Line", PF_Normal, 0, vvLine, NULL, (Value*)&svDefaultLine };
PropertyInfo* ScrollBar::LineProp = &impLineProp;

// Vertical property
static int vvVertical[] = { DUIV_BOOL, -1 };
static PropertyInfo impVerticalProp = { L"Vertical", PF_Normal|PF_Cascade, PG_AffectsLayout|PG_AffectsDesiredSize, vvVertical, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollBar::VerticalProp = &impVerticalProp;

// Proportional property
static int vvProportional[] = { DUIV_BOOL, -1 };
static PropertyInfo impProportionalProp = { L"Proportional", PF_Normal|PF_Cascade, PG_AffectsLayout, vvProportional, NULL, Value::pvBoolTrue };
PropertyInfo* ScrollBar::ProportionalProp = &impProportionalProp;

// Order property
static int vvOrder[] = { DUIV_INT, -1 }; StaticValue(svDefaultOrder, DUIV_INT, SBO_Normal);
static EnumMap emOrder[] = { { L"Normal", SBO_Normal }, { L"ArrowsAtTop", SBO_ArrowsAtTop }, { L"ArrowsAtBottom", SBO_ArrowsAtBottom }, { NULL, 0 } };
static PropertyInfo impOrderProp = { L"Order", PF_Normal|PF_Cascade, PG_AffectsLayout, vvOrder, emOrder, (Value*)&svDefaultOrder };
PropertyInfo* ScrollBar::OrderProp = &impOrderProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ScrollBar::PositionProp,
                                ScrollBar::MinimumProp,
                                ScrollBar::MaximumProp,
                                ScrollBar::PageProp,
                                ScrollBar::LineProp,
                                ScrollBar::VerticalProp,
                                ScrollBar::ProportionalProp,
                                ScrollBar::OrderProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ScrollBar::Class = NULL;

HRESULT ScrollBar::Register()
{
    return ClassInfo<ScrollBar,Element>::Register(L"ScrollBar", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_CONTROL_STDAFX_H_INCLUDED
#define DUI_CONTROL_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_CONTROL_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\stdafxcontrol.cpp ===
/*
 * stdafxcontrol.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\core.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_CORE_CORE_H_INCLUDED
#define DUI_CORE_CORE_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>

#endif // DUI_CORE_CORE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\thumb.cpp ===
/*
 * Thumb
 */

#include "stdafx.h"
#include "control.h"

#include "duithumb.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Thumb, Drag) // ThumbDragEvent

////////////////////////////////////////////////////////
// Thumb

HRESULT Thumb::Create(UINT nActive, OUT Element** ppElement)
{
    *ppElement = NULL;

    Thumb* pt = HNew<Thumb>();
    if (!pt)
        return E_OUTOFMEMORY;

    HRESULT hr = pt->Initialize(nActive);
    if (FAILED(hr))
    {
        pt->Destroy();
        return hr;
    }

    *ppElement = pt;

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

// Pointer is only guaranteed good for the lifetime of the call
void Thumb::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        switch (pie->nDevice)
        {
        case GINPUT_MOUSE:
            {
                MouseEvent* pme = (MouseEvent*)pie;
                //DUITrace("MouseEvent: %d\n", pme->nCode);

                switch (pme->nCode)
                {
                case GMOUSE_UP:
                    // Override of base, no click fire on up, however
                    // mimic Button's behavior for state changes
                    if (GetPressed())  
                        RemoveLocalValue(PressedProp);
                    RemoveLocalValue(CapturedProp);

                    pie->fHandled = true;
                    return;

                case GMOUSE_DRAG:
                    // Fire thumb drag event
                    //DUITrace("Thumb drag <%x>: %d %d\n", this, pme->ptClientPxl.x, pme->ptClientPxl.y);

                    ThumbDragEvent tde;
                    tde.uidType = Thumb::Drag;
                    MapElementPoint(pme->peTarget, (POINT *) &((MouseDragEvent*) pme)->sizeDelta, (POINT *) &tde.sizeDelta);
                    if (IsRTL())
                    {
                        tde.sizeDelta.cx = -tde.sizeDelta.cx;
                    }
                    FireEvent(&tde); // Will route and bubble

                    // Pass to base
                    break;
                }
            }
            break;
        }
    }

    Button::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Thumb::Class = NULL;

HRESULT Thumb::Register()
{
    return ClassInfo<Thumb,Button>::Register(L"Thumb", NULL, 0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\expression.cpp ===
/*
 * Expression
 */

#include "stdafx.h"
#include "core.h"

#include "duiexpression.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Expression

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\control\viewer.cpp ===
/*
 * Viewer
 */

#include "stdafx.h"
#include "control.h"

#include "duiviewer.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Viewer

HRESULT Viewer::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Viewer* pvw = HNew<Viewer>();
    if (!pvw)
        return E_OUTOFMEMORY;

    HRESULT hr = pvw->Initialize();
    if (FAILED(hr))
        return hr;

    *ppElement = pvw;

    return S_OK;
}

HRESULT Viewer::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(EC_SelfLayout); // Normal display node, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    SetActive(AE_Inactive);

    return S_OK;
}

////////////////////////////////////////////////////////
// Generic eventing

void Viewer::OnEvent(Event* pEvent)
{
    Element::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// System events

void Viewer::OnInput(InputEvent* pie)
{
    Element::OnInput(pie);
}

// Validation
bool Viewer::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(iIndex);
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

    return true;
}

void Viewer::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

Element* Viewer::GetContent()
{
    Value* pv;
    ElementList* peList = GetChildren(&pv);

    if (!peList || !peList->GetSize())
    {
        pv->Release();
        return NULL;
    }

    Element* pe = peList->GetItem(0);
    pv->Release();
    return pe;
}

bool Viewer::InternalEnsureVisible(int x, int y, int cx, int cy)
{
    Element* peContent = GetContent();
    if (!peContent)
        return false;

    bool changed = false;

    Value* pvSize;
    Value* pvPoint;
    const POINT* pptContent = peContent->GetLocation(&pvPoint);
    const SIZE* psizeView = GetExtent(&pvSize);

    POINT ptContent;
    ptContent.x = pptContent->x;
    ptContent.y = pptContent->y;

    SIZE sizeView;
    sizeView.cx = psizeView->cx;
    sizeView.cy = psizeView->cy;
    POINT ptView = { 0, 0 };

    // check horizontal location
    int diff = (x + cx) - sizeView.cx;

    // if it fills the width, then don't scroll it horizontally
    if ((x > ptView.x) || (diff < 0))
    {
        // doesn't fill width -- adjust horizontal as necessary
        if (diff < 0)
            // the right side is ok
            diff = 0;
        else
            // the right side runs out the right side of the view
            ptView.x += diff;

        if (ptView.x > x)
            // the left side runs out the left side of the view
            diff -= ptView.x - x;

        if (diff != 0)
        {
            ptContent.x -= diff;
            x -= diff;
            changed = true;
        }
    }

    diff = (y + cy) - sizeView.cy;

    // if it fills the height, then don't scroll it vertically
    if ((y > ptView.y) || (diff < 0))
    {
        // doesn't fill height -- adjust vertical as necessary
        if (diff < 0)
            diff = 0;
        else
            ptView.y += diff;

        if (ptView.y > y)
            diff -= ptView.y - y;

        if (diff != 0)
        {
            ptContent.y -= diff;
            y -= diff;
            changed = true;
        }
    }

    if (changed)
    {
        StartDefer();
        SetXOffset(-ptContent.x);
        SetYOffset(-ptContent.y);
        Element::EnsureVisible(x, y, cx, cy);
        EndDefer();
    }

    pvPoint->Release();
    pvSize->Release();

    return changed;
}


bool Viewer::EnsureVisible(int x, int y, int cx, int cy)
{
    return InternalEnsureVisible(x, y, cx, cy);
}


////////////////////////////////////////////////////////
// Self-layout methods

void Viewer::_SelfLayoutDoLayout(int cx, int cy)
{
    Element* peContent = GetContent();
    if (peContent)
    {   
        // todo -- investigate why this isn't being called -- most probably because we're returning the same
        // desired size?
        const SIZE* psizeContent = peContent->GetDesiredSize();

        POINT ptContent;
        ptContent.x = GetXOffset();
        ptContent.y = GetYOffset();

        SIZE sizeContent;
        sizeContent.cx = psizeContent->cx;
        sizeContent.cy = psizeContent->cy;

        // make sure size at least covers container's bounds
        if (sizeContent.cx < cx)
            sizeContent.cx = cx;
        if (sizeContent.cy < cy)
            sizeContent.cy = cy;

        peContent->_UpdateLayoutSize(sizeContent.cx, sizeContent.cy);

        // now make sure location allows for content to cover container's bounds
        sizeContent.cx -= cx;
        sizeContent.cy -= cy;

        if (ptContent.x > sizeContent.cx)
            ptContent.x = sizeContent.cx;
        if (ptContent.y > sizeContent.cy)
            ptContent.y = sizeContent.cy;

        peContent->_UpdateLayoutPosition(-ptContent.x, -ptContent.y);
    }
}

SIZE Viewer::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    Element* peContent = GetContent();
    SIZE size = { 0, 0 };

    if (peContent)
    {
        size = peContent->_UpdateDesiredSize(
                    (GetXScrollable() ? INT_MAX : cxConstraint),
                    (GetYScrollable() ? INT_MAX : cyConstraint),
                    psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// XOffset property
static int vvXOffset[] = { DUIV_INT, -1 };
static PropertyInfo impXOffsetProp = { L"XOffset", PF_Normal, PG_AffectsLayout, vvXOffset, NULL, Value::pvIntZero };
PropertyInfo* Viewer::XOffsetProp = &impXOffsetProp;

// YOffset property
static int vvYOffset[] = { DUIV_INT, -1 };
static PropertyInfo impYOffsetProp = { L"YOffset", PF_Normal, PG_AffectsLayout, vvYOffset, NULL, Value::pvIntZero };
PropertyInfo* Viewer::YOffsetProp = &impYOffsetProp;

// XScrollable property
static int vvXScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impXScrollableProp = { L"XScrollable", PF_Normal, PG_AffectsDesiredSize, vvXScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* Viewer::XScrollableProp = &impXScrollableProp;

// YScrollable property
static int vvYScrollable[] = { DUIV_BOOL, -1 };
static PropertyInfo impYScrollableProp = { L"YScrollable", PF_Normal, PG_AffectsDesiredSize, vvYScrollable, NULL, Value::pvBoolTrue };
PropertyInfo* Viewer::YScrollableProp = &impYScrollableProp;


////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                Viewer::XOffsetProp,
                                Viewer::YOffsetProp,
                                Viewer::XScrollableProp,
                                Viewer::YScrollableProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* Viewer::Class = NULL;

HRESULT Viewer::Register()
{
    return ClassInfo<Viewer,Element>::Register(L"Viewer", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\accessibility.cpp ===
/*
 * Accessibility support
 */

#include "stdafx.h"
#include "core.h"

#include "DUIError.h"
#include "DUIElement.h"
#include "DUIHost.h"
#include "DUIHWNDHost.h"
#include "DUIAccessibility.h"
#include "DUINavigation.h"

typedef HRESULT (*PfnAccessibleChildCallback)(DirectUI::Element * peAccessible, void * pRawData);
HRESULT ForAllAccessibleChildren(DirectUI::Element * pe, PfnAccessibleChildCallback pfnCallback, void * pRawData)
{
    HRESULT hr = S_OK;

    //
    // Validate the input parameters.
    //
    if (pe == NULL || pfnCallback == NULL) {
        return E_INVALIDARG;
    }


    DirectUI::Value* pvChildren = NULL;
    DirectUI::ElementList* pel = NULL;
    
    //
    // The basic idea is to spin through all of our children, and count
    // them if they are accessible.  However, if a child is not 
    // accessible, we must "count through" them.  In other words, we ask
    // all unaccessible children if they have accessible children
    // themselves.  The reason is that even actual great-great-great 
    // grandchildren must be considered a direct "accessible child" if
    // their parent chain is not accessible up to us.
    //
    pel = pe->GetChildren(&pvChildren);
    if (pel)
    {
        DirectUI::Element* peChild = NULL;
        UINT i = 0;
        UINT iMax = pel->GetSize();

        for (i = 0; i < iMax && (hr == S_OK); i++)
        {
            peChild = pel->GetItem(i);

            if (peChild->GetAccessible()) {
                hr = pfnCallback(peChild, pRawData);
            } else {
                hr = ForAllAccessibleChildren(peChild, pfnCallback, pRawData);
            }
        }
    }
    pvChildren->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
struct GetAccessibleChildCountData
{
    GetAccessibleChildCountData() : count(0) {}
    
    UINT count;
};

HRESULT GetAccessibleChildCountCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetAccessibleChildCountData * pData = (GetAccessibleChildCountData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Simply increase the count.
    //
    pData->count++;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct GetAccessibleChildByIndexData
{
    GetAccessibleChildByIndexData(UINT i) : index(i), pe(NULL) {}
    
    UINT index;
    DirectUI::Element * pe;
} ;

HRESULT GetAccessibleChildByIndexCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetAccessibleChildByIndexData * pData = (GetAccessibleChildByIndexData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (pData->index == 0) {
        //
        // We found the accessible child being searched for.  Return S_FALSE to
        // stop walking our list of children, since we're done.
        //
        pData->pe = peAccessible;
        return S_FALSE;
    } else {
        //
        // We weren't looking for this child.  Decrement our count and check
        // the next one.
        //
        pData->index--;
        return S_OK;
    }
}

///////////////////////////////////////////////////////////////////////////////
struct GetFirstAccessibleChildData
{
    GetFirstAccessibleChildData() : peFirst(NULL) {}

    DirectUI::Element * peFirst;
};

HRESULT GetFirstAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetFirstAccessibleChildData * pData = (GetFirstAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Uh, we're the first one!  Return S_FALSE to stop walking over the
    // accessible children since we are done.
    //
    pData->peFirst = peAccessible;
    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
struct GetPrevAccessibleChildData
{
    GetPrevAccessibleChildData(DirectUI::Element * p) : peStart(p), pePrev(NULL), fFound(false) {}

    DirectUI::Element * peStart;
    DirectUI::Element * pePrev;
    bool fFound;
};

HRESULT GetPrevAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetPrevAccessibleChildData * pData = (GetPrevAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (peAccessible == pData->peStart) {
        //
        // We reached the element we were supposed to start from.  The
        // previous element already stored its pointer in our data.
        // Simply indicate that we are done and then return S_FALSE to stop
        // walking over the accessible children since we are done.
        //
        pData->fFound = true;
        return S_FALSE;
    } else {
        //
        // We may be the previous element, but we don't know for sure.  So,
        // store our pointer in the data just in case.
        //
        pData->pePrev = peAccessible;
        return S_OK;
    }
}

///////////////////////////////////////////////////////////////////////////////
struct GetNextAccessibleChildData
{
    GetNextAccessibleChildData(DirectUI::Element * p) : peStart(p), peNext(NULL) {}

    DirectUI::Element * peStart;
    DirectUI::Element * peNext;
};

HRESULT GetNextAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetNextAccessibleChildData * pData = (GetNextAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    if (pData->peStart == NULL) {
        //
        // This is the one for us to return!  Return S_FALSE to stop walking
        // the accessible children since we are done.
        //
        pData->peNext = peAccessible;
        return S_FALSE;
    } else if (peAccessible == pData->peStart) {
        //
        // We found the starting element.  The next one will be the one
        // we want to return.  Set peStart to NULL to indicate that next
        // time we should set peNext and return.
        //
        pData->peStart = NULL;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct GetLastAccessibleChildData
{
    GetLastAccessibleChildData() : peLast(NULL) {}

    DirectUI::Element * peLast;
};

HRESULT GetLastAccessibleChildCB(DirectUI::Element * peAccessible, void * pRawData)
{
    GetLastAccessibleChildData * pData = (GetLastAccessibleChildData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL) {
        return E_FAIL;
    }

    //
    // Keep over-writting the last pointer.  The last element will win.
    //
    pData->peLast = peAccessible;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
struct CollectAllAccessibleChildrenData
{
    CollectAllAccessibleChildrenData() : pel(NULL)
    {
        DirectUI::ElementList::Create(0, true, &pel);
    }

    ~CollectAllAccessibleChildrenData()
    {
        if (pel != NULL) {
            pel->Destroy();
        }
    }

    DirectUI::ElementList * pel;
};

HRESULT CollectAllAccessibleChildrenCB(DirectUI::Element * peAccessible, void * pRawData)
{
    CollectAllAccessibleChildrenData * pData = (CollectAllAccessibleChildrenData *) pRawData;

    //
    // Validate the input parameters.
    //
    if (peAccessible == NULL || pData == NULL || pData->pel == NULL) {
        return E_FAIL;
    }

    //
    // Add this element to the collection.
    //
    pData->pel->Add(peAccessible);
    return S_OK;
}

namespace DirectUI
{

void NotifyAccessibilityEvent(IN DWORD dwEvent, Element * pe)
{
    //
    // Check to see if anyone cares about this event.
    //
    if (true) { //IsWinEventHookInstalled(dwEvent)) {
        HWND hwndRoot = NULL;
        DWORD dwTicket = 0;

		//
		// Don't fire accessibility events from an HWNDHost element.  We rely
		// on the window it hosts to fire the events.  If we both do, 
		// accessibility tools can get confused.
		//
        if (pe->GetClassInfo()->IsSubclassOf(HWNDHost::Class)) {
        	return;
       	}

        //
        // Get a handle to the host window for this element.  This is
        // what we will pass to NotifyWinEvent.  We have specialized
        // handlers in the host window that can respond to accessibility
        // requests.
        //
        Element * peRoot = pe->GetRoot();
        if (peRoot == NULL) {
            //
            // We can't send any notifications if there isn't a root HWND.
            // This can happen on occasion: during startup, for instance.
            // So we don't Assert or anything, we just bail.
            //
            return;
        }

        if (!peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class)) {
            DUIAssert(FALSE, "Error: Cannot announce an accessibility event for an unhosted element!");
            return;
        }
        hwndRoot = ((HWNDElement*)peRoot)->GetHWND();
        if (hwndRoot == NULL) {
            DUIAssert(FALSE, "Error: The root HWNDElement doesn't have a HWND! Eh?");
            return;
        }

        //
        // Get the cross-process identity of the element.
        //
        dwTicket = GetGadgetTicket(pe->GetDisplayNode());
        if (dwTicket == 0) {
            DUIAssert(FALSE, "Failed to retrieve a ticket for a gadget!");
            return;
        }

        //
        // Just use the NotifyWinEvent API to broadcast this event.
        //
        // DUITrace("NotifyWinEvent(dwEvent:%x, hwndRoot:%p, dwTicket:%x, CHILDID_SELF)\n", dwEvent, hwndRoot, dwTicket);
        NotifyWinEvent(dwEvent, hwndRoot, dwTicket, CHILDID_SELF);
    }
}

HRESULT DuiAccessible::Create(Element * pe, DuiAccessible ** ppDA)
{
    DUIAssert(pe != NULL, "DuiAccessible created for a NULL element!");

    DuiAccessible * pda;

    *ppDA = NULL;

    pda = HNew<DuiAccessible>();
    if (!pda)
        return E_OUTOFMEMORY;

    //
    // Note: this is a weak reference - in other words, we don't hold a
    // reference on it.  The element is responsible for calling Disconnect()
    // before it evaporates to make sure that this pointer remains valid.
    //
    pda->Initialize(pe);

    *ppDA = pda;

    return S_OK;
}

DuiAccessible::~DuiAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pe == NULL, "~DuiAccessible called while still connected to an element!");

    //
    // We should only get destroyed when all of our references have been
    // released!
    //
    DUIAssert(_cRefs == 0, "~DuiAccessible called with outstanding references!");
}

HRESULT DuiAccessible::Disconnect()
{
    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pe != NULL, "DuiAccessible::Disconnect called when already disconnected!");
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // We can no longer access the element!
    //
    _pe = NULL;

    //
    // Forcibly disconnect all external (remote) clients.
    //
    return CoDisconnectObject((IUnknown*)(IDispatch*)(IAccessible*)this, 0);
}

STDMETHODIMP_(ULONG) DuiAccessible::AddRef()
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) DuiAccessible::Release()
{
    if (0 == InterlockedDecrement(&_cRefs)) {
        HDelete<DuiAccessible>(this);
        return 0;
    } else {
        return _cRefs;
    }
}

STDMETHODIMP DuiAccessible::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    //
    // Initialize and validate the out parameter(s).
    //
    if (ppvObj != NULL) {
        *ppvObj = NULL;
    } else {
        return E_POINTER;
    }

    //
    // Return interface pointers to interfaces that we know we support.
    //
    if (riid == __uuidof(IUnknown)) {
        *ppvObj = (LPVOID*)(IUnknown*)(IDispatch*)(IAccessible*)this;
    } else if (riid == __uuidof(IDispatch)) {
        *ppvObj = (LPVOID*)(IDispatch*)(IAccessible*)this;
    } else if (riid == __uuidof(IAccessible)) {
        *ppvObj = (LPVOID*)(IAccessible*)this;
    } else {
        return E_NOINTERFACE;
    }
    
    //
    // The interface we hand out has to be referenced.
    //
    AddRef();

    return S_OK;
}

STDMETHODIMP DuiAccessible::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(rgszNames);
    UNREFERENCED_PARAMETER(cNames);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(rgdispid);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetTypeInfoCount(UINT *pctinfo)
{
    UNREFERENCED_PARAMETER(pctinfo);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    UNREFERENCED_PARAMETER(itinfo);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(pptinfo);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Invoke(DISPID dispidMember,
                                   REFIID riid,
                                   LCID lcid,
                                   WORD wFlags,
                                   DISPPARAMS *pdispparams,
                                   VARIANT *pvarResult,
                                   EXCEPINFO *pexcepinfo,
                                   UINT *puArgErr)
{
    UNREFERENCED_PARAMETER(dispidMember);
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(wFlags);
    UNREFERENCED_PARAMETER(pdispparams);
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);
    UNREFERENCED_PARAMETER(puArgErr);

    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::accSelect(long flagsSelect, VARIANT varChild)
{
    UNREFERENCED_PARAMETER(flagsSelect);
    UNREFERENCED_PARAMETER(varChild);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::accLocation(long *pxLeft,
                                        long *pyTop,
                                        long *pcxWidth,
                                        long *pcyHeight,
                                        VARIANT varChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pxLeft != NULL) {
        *pxLeft = 0;
    }
    if (pyTop != NULL) {
        *pyTop = 0;
    }
    if (pcxWidth != NULL) {
        *pcxWidth = 0;
    }
    if (pcyHeight != NULL) {
        *pcyHeight = 0;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pxLeft == NULL || pyTop == NULL || pcxWidth == NULL || pcyHeight == NULL) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the bounds of the element in screen coordinates.  Screen 
    // coordinates are the same as coordinates relative to the desktop.
    //
    RECT rcLocation;
    GetGadgetRect(_pe->GetDisplayNode(), &rcLocation, SGR_DESKTOP);

    //
    // TODO:
    // These are the coordinates of the rectangle relative to the desktop.
    // However, what we really need to return is the bounding box of the
    // gadget.  Currently, rotated gadgets will report wierd results.
    //
    *pxLeft = rcLocation.left;
    *pyTop = rcLocation.top;
    *pcxWidth = rcLocation.right - rcLocation.left;
    *pcyHeight = rcLocation.bottom - rcLocation.top;

    return hr;
}

STDMETHODIMP DuiAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarEndUpAt != NULL) {
        VariantInit(pvarEndUpAt);
    }
    if (V_VT(&varStart) != VT_I4 || V_I4(&varStart) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarEndUpAt == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    Element * peFound = NULL;

    switch (navDir) {
    case NAVDIR_FIRSTCHILD:
        {
            GetFirstAccessibleChildData data;

            hr = ForAllAccessibleChildren(_pe, GetFirstAccessibleChildCB, (void*) &data);
            if SUCCEEDED(hr)
            {
                peFound = data.peFirst;
                hr = S_OK;
            }
        }
        break;

    case NAVDIR_LASTCHILD:
        {
            GetLastAccessibleChildData data;

            hr = ForAllAccessibleChildren(_pe, GetLastAccessibleChildCB, (void*) &data);
            if SUCCEEDED(hr)
            {
                peFound = data.peLast;
                hr = S_OK;
            }
        }
        break;

    case NAVDIR_NEXT:
        {
            GetNextAccessibleChildData data(_pe);
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, GetNextAccessibleChildCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    peFound = data.peNext;
                    hr = S_OK;
                }
            }
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            GetPrevAccessibleChildData data(_pe);
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, GetPrevAccessibleChildCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    peFound = data.pePrev;
                    hr = S_OK;
                }
            }
        }
        break;

    case NAVDIR_LEFT:
    case NAVDIR_RIGHT:
    case NAVDIR_UP:
    case NAVDIR_DOWN:
        {
            //
            // Collect all of the accessible children into a list.
            //
            CollectAllAccessibleChildrenData data;
            Element * peParent = GetAccessibleParent(_pe);

            if (peParent == NULL) {
                hr = E_FAIL;
            } else {
                hr = ForAllAccessibleChildren(peParent, CollectAllAccessibleChildrenCB, (void*) &data);
                if SUCCEEDED(hr)
                {
                    //
                    // Convert the IAccessible navigation direction value into
                    // an equivalent DUI navigation direction value.
                    //
                    switch (navDir) {
                    case NAVDIR_LEFT:
                        navDir = NAV_LEFT;
                        break;

                    case NAVDIR_RIGHT:
                        navDir = NAV_RIGHT;
                        break;

                    case NAVDIR_UP:
                        navDir = NAV_UP;
                        break;

                    case NAVDIR_DOWN:
                        navDir = NAV_DOWN;
                        break;
                    }

                    //
                    // Now navigate in the requested direction among the
                    // collection of accessible peers.
                    //
                    peFound = DuiNavigate::Navigate(_pe, data.pel, navDir);
                    hr = S_OK;
                }
            }
            
        }
        break;

    default:
        return E_FAIL;
    }


    //
    // If we found an appropriate accessible element, return its IDispatch
    // interface.
    //
    if (peFound != NULL) {
        IDispatch * pDispatch = NULL;

        hr = GetDispatchFromElement(peFound, &pDispatch);
        if (SUCCEEDED(hr)) {
            V_VT(pvarEndUpAt) = VT_DISPATCH;
            V_DISPATCH(pvarEndUpAt) = pDispatch;
        }
    }

    return hr;
}

STDMETHODIMP DuiAccessible::accHitTest(long x, long y, VARIANT *pvarChildAtPoint)
{
    //
    // Initialize output and validate input parameters.
    //
    if (pvarChildAtPoint != NULL) {
        VariantInit(pvarChildAtPoint);
    }
    if (pvarChildAtPoint == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }
    
    //
    // Get the root element.
    //
    HWND hwndRoot = NULL;
    Element * peRoot = _pe->GetRoot();
    if (peRoot == NULL) {
        //
        // No root!  We have no idea how to translate the screen coordinates
        // through all of our display tree transformations.  We have to bail.
        //
        return E_FAIL;
    }

    if (!peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class)) {
        DUIAssert(FALSE, "Error: Cannot hit test an unhosted element!");
        return E_FAIL;
    }

    hwndRoot = ((HWNDElement*)peRoot)->GetHWND();
    if (hwndRoot == NULL) {
        DUIAssert(FALSE, "Error: The root HWNDElement doesn't have a HWND! Eh?");
        return E_FAIL;
    }

    //
    // Convert the screen coordinates into coordinates relative to the root.
    // There are no complicated transformations yet.
    //
    POINT ptRoot;
    ptRoot.x = x;
    ptRoot.y = y;
    ScreenToClient(hwndRoot, &ptRoot);

    //
    // Translate the coordinates relative to the root into coordinates
    // relative to us.  There could be complicated transforms!
    //
    POINT ptElement;
    ptElement.x = ptRoot.x;
    ptElement.y = ptRoot.y;
    MapGadgetPoints(peRoot->GetDisplayNode(), _pe->GetDisplayNode(), &ptElement, 1);
        
    //
    // Now try and find our immediate child under this point.
    //
    Element * peChild = NULL;
    HGADGET hgadChild = FindGadgetFromPoint(_pe->GetDisplayNode(), ptElement, GS_VISIBLE, NULL);
    if (hgadChild) {
        peChild = ElementFromGadget(hgadChild);
        if (peChild != NULL && peChild != _pe) {
            Element * pe = peChild;
            peChild = NULL;

            //
            // We found some element buried deep in the tree that is under
            // the point. Now look up the tree for the immediate accessible
            // child of the original element (if any).
            //
            for (; pe != NULL && pe != _pe; pe = pe->GetParent()) {
                if (pe->GetAccessible()) {
                    peChild = pe;
                }
            }

            //
            // If we didn't find an accessible element between the element
            // under the point and us, then we get the hit test ourselves.
            //
            if (peChild == NULL) {
                peChild = _pe;
            }
        }
    }


    if (peChild == _pe) {
        //
        // The point wasn't over any of our immediate accessible children,
        // but it was over us.
        //
        V_VT(pvarChildAtPoint) = VT_I4;
        V_I4(pvarChildAtPoint) = CHILDID_SELF;
        return S_OK;
    }else if (peChild != NULL) {
        HRESULT hr = S_OK;
        IDispatch * pDispatch = NULL;

        hr = GetDispatchFromElement(peChild, &pDispatch);
        if (SUCCEEDED(hr)) {
            V_VT(pvarChildAtPoint) = VT_DISPATCH;
            V_DISPATCH(pvarChildAtPoint) = pDispatch;
        }

        return hr;
    } else {
        //
        // Evidently, the point wasn't even over us!
        //
        return S_FALSE;
    }
}

STDMETHODIMP DuiAccessible::accDoDefaultAction(VARIANT varChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Perform the default action on the element.
    // Do not call directly, queue for async invokation.
    //
    hr = _pe->QueueDefaultAction();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accChild(VARIANT varChildIndex, IDispatch **ppdispChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispChild != NULL) {
        *ppdispChild = NULL;
    }
    if (V_VT(&varChildIndex) != VT_I4) {
        return E_INVALIDARG;
    }
    if (V_I4(&varChildIndex) == 0) {
        //
        // We are expecting a 1-based index.
        //
        return E_INVALIDARG;
    }
    if (ppdispChild == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    GetAccessibleChildByIndexData data(V_I4(&varChildIndex) - 1);
    hr = ForAllAccessibleChildren(_pe, GetAccessibleChildByIndexCB, (void*) &data);
    if (SUCCEEDED(hr))
    {
        if (data.pe != NULL) {
            hr = GetDispatchFromElement(data.pe, ppdispChild);
        } else {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispParent != NULL) {
        *ppdispParent = NULL;
    }
    if (ppdispParent == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Once we found our "accessible parent", get its IAccessible
    // implementation and then query that for IDispatch.
    //
    Element * peParent = GetAccessibleParent(_pe);
    if (peParent != NULL) {
        hr = GetDispatchFromElement(peParent, ppdispParent);
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accChildCount(long *pChildCount)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pChildCount != NULL) {
        *pChildCount = 0;
    }
    if (pChildCount == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    GetAccessibleChildCountData data;
    hr = ForAllAccessibleChildren(_pe, GetAccessibleChildCountCB, (void*) &data);
    if SUCCEEDED(hr)
    {
        *pChildCount = data.count;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accName(VARIANT varChild, BSTR * pbstrName)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrName != NULL) {
        *pbstrName = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrName == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccName property.
    //
    Value* pvAccName = NULL;
    LPWSTR wstrAccName = _pe->GetAccName(&pvAccName);
    if (NULL != wstrAccName) {
        *pbstrName = SysAllocString(wstrAccName);
        if (*pbstrName == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccName->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::put_accName(VARIANT varChild, BSTR szName)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(szName);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accValue(VARIANT varChild, BSTR * pbstrValue)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrValue != NULL) {
        *pbstrValue = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrValue == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccValue property.
    //
    Value* pvAccValue = NULL;
    LPWSTR wstrAccValue = _pe->GetAccValue(&pvAccValue);
    if (NULL != wstrAccValue) {
        *pbstrValue = SysAllocString(wstrAccValue);
        if (*pbstrValue == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccValue->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::put_accValue(VARIANT varChild, BSTR pszValue)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszValue);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrDescription != NULL) {
        *pbstrDescription = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrDescription == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccDesc property.
    //
    Value* pvAccDescription = NULL;
    LPWSTR wstrAccDescription = _pe->GetAccDesc(&pvAccDescription);
    if (NULL != wstrAccDescription) {
        *pbstrDescription = SysAllocString(wstrAccDescription);
        if (*pbstrDescription == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccDescription->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszKeyboardShortcut);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarRole != NULL) {
        VariantInit(pvarRole);
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarRole == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the AccRole property.
    //
    V_VT(pvarRole) = VT_I4;
    V_I4(pvarRole) = _pe->GetAccRole();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarState != NULL) {
        VariantInit(pvarState);
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pvarState == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return the AccState property.
    //
    V_VT(pvarState) = VT_I4;
    V_I4(pvarState) = _pe->GetAccState();

    return hr;
}

STDMETHODIMP DuiAccessible::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pszHelp);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
    UNREFERENCED_PARAMETER(pszHelpFile);
    UNREFERENCED_PARAMETER(varChild);
    UNREFERENCED_PARAMETER(pidTopic);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accFocus(VARIANT *pvarFocusChild)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pvarFocusChild != NULL) {
        VariantInit(pvarFocusChild);
    }
    if (pvarFocusChild == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    if (_pe->GetKeyFocused() && (_pe->GetActive() & AE_Keyboard)) {
        V_VT(pvarFocusChild) = VT_I4;
        V_I4(pvarFocusChild) = CHILDID_SELF;
    } else {
        V_VT(pvarFocusChild) = VT_EMPTY;
    }

    return hr;
}

STDMETHODIMP DuiAccessible::get_accSelection(VARIANT *pvarSelectedChildren)
{
    UNREFERENCED_PARAMETER(pvarSelectedChildren);
    
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::get_accDefaultAction(VARIANT varChild, BSTR * pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (pbstrDefaultAction != NULL) {
        *pbstrDefaultAction = NULL;
    }
    if (V_VT(&varChild) != VT_I4 || V_I4(&varChild) != CHILDID_SELF) {
        return E_FAIL;
    }
    if (pbstrDefaultAction == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // Return a BSTR version of the AccDefAction property.
    //
    Value* pvAccDefAction = NULL;
    LPWSTR wstrAccDefAction = _pe->GetAccDefAction(&pvAccDefAction);
    if (NULL != wstrAccDefAction) {
        *pbstrDefaultAction = SysAllocString(wstrAccDefAction);
        if (*pbstrDefaultAction == NULL) {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_FAIL;
    }
    pvAccDefAction->Release();

    return hr;
}

STDMETHODIMP DuiAccessible::Next(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched)
{
    UNREFERENCED_PARAMETER(celt);
    UNREFERENCED_PARAMETER(rgvar);
    UNREFERENCED_PARAMETER(pceltFetched);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Next!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Skip(unsigned long celt)
{
    UNREFERENCED_PARAMETER(celt);
    
    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Skip!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Reset()
{
    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Reset!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::Clone(IEnumVARIANT ** ppenum)
{
    UNREFERENCED_PARAMETER(ppenum);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IEnumVARIANT.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::Clone!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::GetWindow(HWND * phwnd)
{
    UNREFERENCED_PARAMETER(phwnd);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IOleWindow.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::GetWindow!  Should never happen!");
    return E_NOTIMPL;
}

STDMETHODIMP DuiAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    UNREFERENCED_PARAMETER(fEnterMode);

    //
    // Supposedly, this will never be called, because our QI refuses to
    // admit that we support IOleWindow.
    //
    DUIAssert(FALSE, "Calling DuiAccessible::ContextSensitiveHelp!  Should never happen!");
    return E_NOTIMPL;
}

Element * DuiAccessible::GetAccessibleParent(Element * pe)
{
    //
    // Scan up our ancestors looking for a parent, grandparent, great-grandparent, etc
    // that is Accessible.  This is our "accessible parent".
    //
    Element * peParent = NULL;
    for(peParent = pe->GetParent(); peParent != NULL; peParent = peParent->GetParent())
    {
        if (peParent->GetAccessible()) {
            break;
        }
    }

    return peParent;
}

HRESULT DuiAccessible::GetDispatchFromElement(Element * pe, IDispatch ** ppDispatch)
{
    HRESULT hr = S_OK;

    //
    // Validate the input parameters and initialize the output parameters.
    //
    if (ppDispatch != NULL) {
        *ppDispatch = NULL;
    }
    if (pe == NULL || ppDispatch == NULL) {
        return E_INVALIDARG;
    }

    //
    // Only return an IDispatch interface to the element if it is accessible.
    //
    if (!pe->GetAccessible()) {
        return E_FAIL;
    }

    IAccessible * pAccessible = NULL;
    hr = pe->GetAccessibleImpl(&pAccessible);
    if (SUCCEEDED(hr)) {
        hr = pAccessible->QueryInterface(__uuidof(IDispatch), (LPVOID*) ppDispatch);
        pAccessible->Release();
    }

    return hr;
}

HRESULT HWNDElementAccessible::Create(HWNDElement * pe, DuiAccessible ** ppDA)
{
    HRESULT hr;

    HWNDElementAccessible* phea;

    *ppDA = NULL;

    phea = HNew<HWNDElementAccessible>();
    if (!phea)
        return E_OUTOFMEMORY;

    hr = phea->Initialize(pe);
    if (FAILED(hr))
    {
        phea->Release();
        goto Failure;
    }

    *ppDA = phea;

    return S_OK;

Failure:

    return hr;
}

HRESULT HWNDElementAccessible::Initialize(HWNDElement * pe)
{
    HRESULT hr = S_OK;

    //
    // Initialize base
    //
    
    DuiAccessible::Initialize(pe);

    _pParent = NULL;


    //
    // Use the "window" piece of the current HWND as our accessibility parent.
    // We will take over the "client" piece of this same window. In accessibility,
    // the "client" piece is a child of the "window" piece, even of the same HWND.
    //
    hr = AccessibleObjectFromWindow(pe->GetHWND(),
                                    (DWORD)OBJID_WINDOW,
                                    __uuidof(IAccessible),
                                    (void**)&_pParent);

    DUIAssert(SUCCEEDED(hr), "HWNDElementAccessible failed!");

    return hr;
}

HWNDElementAccessible::~HWNDElementAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pParent == NULL, "~HWNDElementAccessible called while still connected to an element!");
}

HRESULT HWNDElementAccessible::Disconnect()
{
    HRESULT hr = S_OK;

    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pParent != NULL, "HWNDElementAccessible::Disconnect called when already disconnected!");

    //
    // Release our reference to our parent window's IAccessible.
    //
    if (_pParent != NULL) {
        _pParent->Release();
        _pParent = NULL;
    }

    //
    // Continue disconnecting.
    //
    hr = DuiAccessible::Disconnect();

    return S_OK;
}

STDMETHODIMP HWNDElementAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = S_OK;

    //
    // Initialize output and validate input parameters.
    //
    if (ppdispParent != NULL) {
        *ppdispParent = NULL;
    }
    if (ppdispParent == NULL ) {
        return E_POINTER;
    }

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pParent == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // We maintain a pointer to the IAccessible interface of our parent window.
    // Now we simply QI it for IDispatch.
    //
    hr = _pParent->QueryInterface(__uuidof(IDispatch), (LPVOID*) ppdispParent);

    return hr;
}


HRESULT HWNDHostAccessible::Create(HWNDHost * pe, DuiAccessible ** ppDA)
{
    HRESULT hr;

    HWNDHostAccessible* phha;

    *ppDA = NULL;

    phha = HNew<HWNDHostAccessible>();
    if (!phha)
        return E_OUTOFMEMORY;

    hr = phha->Initialize(pe);
    if (FAILED(hr))
    {
        phha->Release();
        goto Failure;
    }

    *ppDA = phha;

    return S_OK;

Failure:

    return hr;
}
    

HRESULT HWNDHostAccessible::Initialize(HWNDHost * pe)
{
    HRESULT hr = S_OK;

    //
    // Initialize base
    //
    
    DuiAccessible::Initialize(pe);

    _pCtrl = NULL;
    _pEnum = NULL;
    _pOleWindow = NULL;

    //
    // Get the control HWND.
    //
    HWND hwndCtrl = pe->GetHWND();
    if (hwndCtrl != NULL) {
        hr = CreateStdAccessibleObject(hwndCtrl, OBJID_WINDOW, __uuidof(IAccessible), (void**) &_pCtrl);
    } else {
        hr = E_FAIL;
    }

    //
    // Check to see if the control supports IEnumVariant.
    //
    if (SUCCEEDED(hr)) {
        hr = _pCtrl->QueryInterface(__uuidof(IEnumVARIANT), (LPVOID*) &_pEnum);
    }

    //
    // Check to see if the control supports IOleWindow.
    //
    if (SUCCEEDED(hr)) {
        hr = _pCtrl->QueryInterface(__uuidof(IOleWindow), (LPVOID*) &_pOleWindow);
    }

    DUIAssert(SUCCEEDED(hr), "HWNDHostAccessible failed!");

    return hr;
}

HWNDHostAccessible::~HWNDHostAccessible()
{
    //
    // Supposedly some element holds a reference to us.  We should only ever
    // get completely released if they call Disconnect().
    //
    DUIAssert(_pCtrl == NULL, "~HWNDHostAccessible called while still connected to an element!");
}

HRESULT HWNDHostAccessible::Disconnect()
{
    HRESULT hr = S_OK;

    //
    // Supposedly some element holds a reference to us.
    //
    DUIAssert(_pCtrl != NULL, "HWNDHostAccessible::Disconnect called when already disconnected!");

    //
    // Release our reference to our control window's IAccessible.
    //
    if (_pCtrl != NULL) {
        _pCtrl->Release();
        _pCtrl = NULL;
    }

    //
    // Release our reference to our control window's IEnumVARIANT.
    //
    if (_pEnum != NULL) {
        _pEnum->Release();
        _pEnum = NULL;
    }

    //
    // Release our reference to our control window's IOleWindow.
    //
    if (_pOleWindow != NULL) {
        _pOleWindow->Release();
        _pOleWindow = NULL;
    }

    //
    // Continue disconnecting.
    //
    hr = DuiAccessible::Disconnect();

    return S_OK;
}
    
STDMETHODIMP HWNDHostAccessible::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    //
    // Initialize and validate the out parameter(s).
    //
    if (ppvObj != NULL) {
        *ppvObj = NULL;
    } else {
        return E_POINTER;
    }

    //
    // This is an attempt to have "smart" support for IEnumVARIANT and
    // IOleWindow.  We only admit we support these interfaces if our
    // control window does.
    //
    if (riid == __uuidof(IEnumVARIANT)) {
        if (_pEnum != NULL) {
            *ppvObj = (LPVOID*)(IEnumVARIANT*)(DuiAccessible*)this;
        } else {
            return E_NOINTERFACE;
        }
    } else if (riid == __uuidof(IOleWindow)) {
        if (_pOleWindow != NULL) {
            *ppvObj = (LPVOID*)(IOleWindow*)(DuiAccessible*)this;
        } else {
            return E_NOINTERFACE;
        }
    } else {
        return DuiAccessible::QueryInterface(riid, ppvObj);
    }
    
    //
    // The interface we hand out has to be referenced.
    //
    AddRef();

    return S_OK;
}

STDMETHODIMP HWNDHostAccessible::accSelect(long flagsSelect, VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accSelect(flagsSelect, varChild);
}

STDMETHODIMP HWNDHostAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}

STDMETHODIMP HWNDHostAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // We only delegate the FirstChild and LastChild navigation directions to
    // the window.  Spatial and logical navigation is handled by us, because
    // we have to be able to navigate to non-HWND siblings of this element.
    //
    if (V_VT(&varStart) == VT_I4 && V_I4(&varStart) == CHILDID_SELF) {
        switch (navDir) {
        case NAVDIR_NEXT:
        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
        case NAVDIR_UP:
        case NAVDIR_DOWN:
            return DuiAccessible::accNavigate(navDir, varStart, pvarEndUpAt);

        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
        default:
            return _pCtrl->accNavigate(navDir, varStart, pvarEndUpAt);
        }
    } else {
        return _pCtrl->accNavigate(navDir, varStart, pvarEndUpAt);
    }
}

STDMETHODIMP HWNDHostAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarChildAtPoint)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accHitTest(xLeft, yTop, pvarChildAtPoint);
}

STDMETHODIMP HWNDHostAccessible::accDoDefaultAction(VARIANT varChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->accDoDefaultAction(varChild);
}

STDMETHODIMP HWNDHostAccessible::get_accChild(VARIANT varChildIndex, IDispatch **ppdispChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accChild(varChildIndex, ppdispChild);
}

STDMETHODIMP HWNDHostAccessible::get_accParent(IDispatch **ppdispParent)
{
    HRESULT hr = DuiAccessible::get_accParent(ppdispParent);

    return hr;
}

STDMETHODIMP HWNDHostAccessible::get_accChildCount(long *pChildCount)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accChildCount(pChildCount);
}

STDMETHODIMP HWNDHostAccessible::get_accName(VARIANT varChild, BSTR *pszName)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accName(varChild, pszName))) {
        return hr;
    }    
    
    return _pCtrl->get_accName(varChild, pszName);
}

STDMETHODIMP HWNDHostAccessible::put_accName(VARIANT varChild, BSTR szName)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->put_accName(varChild, szName);
}

STDMETHODIMP HWNDHostAccessible::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accValue(varChild, pszValue))) {
        return hr;
    }    
    
    return _pCtrl->get_accValue(varChild, pszValue);
}

STDMETHODIMP HWNDHostAccessible::put_accValue(VARIANT varChild, BSTR pszValue)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->put_accValue(varChild, pszValue);
}

STDMETHODIMP HWNDHostAccessible::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
    HRESULT hr;

    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    // Give the host element the first chance
    if (SUCCEEDED(hr = DuiAccessible::get_accDescription(varChild, pszDescription))) {
        return hr;
    }    
    
    return _pCtrl->get_accDescription(varChild, pszDescription);
}

STDMETHODIMP HWNDHostAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}

STDMETHODIMP HWNDHostAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accRole(varChild, pvarRole);
}

STDMETHODIMP HWNDHostAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accState(varChild, pvarState);
}

STDMETHODIMP HWNDHostAccessible::get_accHelp(VARIANT varChild, BSTR *pszHelp)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accHelp(varChild, pszHelp);
}

STDMETHODIMP HWNDHostAccessible::get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}

STDMETHODIMP HWNDHostAccessible::get_accFocus(VARIANT *pvarFocusChild)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accFocus(pvarFocusChild);
}

STDMETHODIMP HWNDHostAccessible::get_accSelection(VARIANT *pvarSelectedChildren)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accSelection(pvarSelectedChildren);
}

STDMETHODIMP HWNDHostAccessible::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pCtrl->get_accDefaultAction(varChild, pszDefaultAction);
}

STDMETHODIMP HWNDHostAccessible::Next(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Next(celt, rgvar, pceltFetched);
}

STDMETHODIMP HWNDHostAccessible::Skip(unsigned long celt)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Skip(celt);
}

STDMETHODIMP HWNDHostAccessible::Reset()
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pEnum->Reset();
}

STDMETHODIMP HWNDHostAccessible::Clone(IEnumVARIANT ** ppenum)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pEnum == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    //
    // This is a problem.
    //
    // We can only ever have one DuiAccessible connected to an Element at a
    // time.  This is because the Element is responsible for disconnecting
    // the DuiAccessible object when it is getting destroyed.  And since
    // IEnumVARIANT is implemented on DuiAccessible directly, we can't
    // create a separate instance of jsut the enumerator, but would have to
    // create a new instance of DuiAccessible itself.  Which means we can't
    // connect it to the element without disconnecting the other one or
    // risking a bogus pointer if the element ever gets deleted.
    //
    // Dang!
    //
    // We try to cheat and just return a clone of our control window's
    // IEnumVARIANT.  Hopefully, the client will not try to QI it back
    // to an IAccessible, because that will then circumvent our
    // implementation.
    //
    return _pEnum->Clone(ppenum);
}

STDMETHODIMP HWNDHostAccessible::GetWindow(HWND * phwnd)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pOleWindow == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pOleWindow->GetWindow(phwnd);
}

STDMETHODIMP HWNDHostAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    //
    // Validate internal state.
    //
    if (_pe == NULL || _pCtrl == NULL || _pOleWindow == NULL) {
        return E_FAIL;
    }

    //
    // Only return accessible information if the element is still marked as
    // being accessible.
    //
    if (!_pe->GetAccessible()) {
        return E_FAIL;
    }

    return _pOleWindow->ContextSensitiveHelp(fEnterMode);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\element.cpp ===
/*
 * Element
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duiaccessibility.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Element

// Per-thread Element slot (initialized on main thread)
DWORD g_dwElSlot = (DWORD)-1;

#if DBG
// Process-wide Element count
LONG g_cElement = 0;
#endif

////////////////////////////////////////////////////////
// Event types

DefineClassUniqueID(Element, KeyboardNavigate)  // KeyboardNavigateEvent struct

void NavReference::Init(Element* pe, RECT* prc)
{
    cbSize = sizeof(NavReference);
    this->pe = pe;
    this->prc = prc;
}

HRESULT Element::Create(UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    Element* pe = HNew<Element>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nCreate);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

HRESULT Element::Initialize(UINT nCreate)
{
    HRESULT hr;

    _pvmLocal = NULL;
    _hgDisplayNode = NULL;

    // Accessibility
    _pDuiAccessible = NULL;

    // Listeners
    _ppel = NULL;

#if DBG
    // Store owner context and side-by-side instance for multithreading
    owner.hCtx = GetContext();
    owner.dwTLSSlot = g_dwElSlot;
#endif
    
    // Local storage
    hr = BTreeLookup<Value*>::Create(false, &_pvmLocal);
    if (FAILED(hr))
        goto Failed;

    // Defer table and index information
    _iGCSlot = -1;
    _iGCLPSlot = -1;
    _iPCTail = -1;
    _iIndex = -1;

    // Lifetime and native hosting flags
    _fBit.bDestroyed = false;
    _fBit.bHosted = false;

    // Indirect VE cache
    _fBit.bNeedsDSUpdate = false;
    _fBit.fNeedsLayout = LC_Pass;
    _fBit.bHasChildren = false;
    _fBit.bHasLayout = false;
    _fBit.bHasBorder = false;
    _fBit.bHasPadding = false;
    _fBit.bHasMargin = false;
    _fBit.bHasContent = false;
    _fBit.bDefaultCAlign = true;
    _fBit.bWordWrap = false;
    _fBit.bHasAnimation = false;
    _fBit.bDefaultCursor = true;
    _fBit.bDefaultBorderColor = true;
    _fBit.bDefaultForeground = true;
    _fBit.bDefaultFontWeight = true;
    _fBit.bDefaultFontStyle = true;

    // Self layout set
    _fBit.bSelfLayout = (nCreate & EC_SelfLayout) != 0;

    // Initialize cached and local property values to default (defaults are static, no ref counting)
    // Although LocalOnly and TriLevel properties don't use the 'default' value during
    // lookup, must do one-time initialization of these cached values using the default value

    // Local values
    _fBit.bLocKeyWithin = KeyWithinProp->pvDefault->GetBool();
    _fBit.bLocMouseWithin = MouseWithinProp->pvDefault->GetBool();
    _peLocParent = ParentProp->pvDefault->GetElement();
    _ptLocPosInLayt = *(PosInLayoutProp->pvDefault->GetPoint());
    _sizeLocSizeInLayt = *(SizeInLayoutProp->pvDefault->GetSize());
    _sizeLocLastDSConst = *(LastDSConstProp->pvDefault->GetSize());
    _sizeLocDesiredSize = *(DesiredSizeProp->pvDefault->GetSize());

    // Cached VE values
    _fBit.fSpecActive = ActiveProp->pvDefault->GetInt();
    _fBit.bSpecSelected = SelectedProp->pvDefault->GetBool();;
    _fBit.bSpecKeyFocused = KeyFocusedProp->pvDefault->GetBool();
    _fBit.bSpecMouseFocused = MouseFocusedProp->pvDefault->GetBool();
    _fBit.bCmpVisible = VisibleProp->pvDefault->GetBool();
    _fBit.bSpecVisible = VisibleProp->pvDefault->GetBool();;
    _fBit.nSpecDirection = DirectionProp->pvDefault->GetInt();
    _fBit.bSpecAccessible = AccessibleProp->pvDefault->GetBool();
    _fBit.bSpecEnabled = EnabledProp->pvDefault->GetBool();
    _dSpecLayoutPos = LayoutPosProp->pvDefault->GetInt();
    _pvSpecSheet = SheetProp->pvDefault;
    _atomSpecID = IDProp->pvDefault->GetAtom();
    _dSpecAlpha = AlphaProp->pvDefault->GetInt();

    // Create display node (gadget)
    if (!(nCreate & EC_NoGadgetCreate))
    {
        _hgDisplayNode = CreateGadget(NULL, GC_SIMPLE, _DisplayNodeCallback, this);
        if (!_hgDisplayNode)
        {
            hr = GetLastError();
            goto Failed;
        }

        SetGadgetMessageFilter(_hgDisplayNode, NULL, GMFI_PAINT|GMFI_CHANGESTATE, 
                GMFI_PAINT|GMFI_CHANGESTATE|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_INPUTKEYBOARD|GMFI_CHANGERECT|GMFI_CHANGESTYLE);

        SetGadgetStyle(_hgDisplayNode, 
//                GS_RELATIVE,
                GS_RELATIVE|GS_OPAQUE,
                GS_RELATIVE|GS_HREDRAW|GS_VREDRAW|GS_OPAQUE|GS_VISIBLE|GS_KEYBOARDFOCUS|GS_MOUSEFOCUS);
    }

#if DBG
    // Track Element count
    InterlockedIncrement(&g_cElement);
#endif

    return S_OK;

Failed:

    if (_pvmLocal)
    {
        _pvmLocal->Destroy();
        _pvmLocal = NULL;
    }

    if (_hgDisplayNode)
    {
        DeleteHandle(_hgDisplayNode);
        _hgDisplayNode = NULL;
    }

    return hr;
}

// Value destroy
void _ReleaseValue(void* ppi, Value* pv)
{
    UNREFERENCED_PARAMETER(ppi);

    pv->Release();
}

Element::~Element()
{
    //
    // Break our link to the accessibility object!
    //
    if (_pDuiAccessible != NULL) {
        _pDuiAccessible->Disconnect();
        _pDuiAccessible->Release();
        _pDuiAccessible = NULL;
    }

    // Free storage
    if (_pvmLocal)
        _pvmLocal->Destroy();
}

// Element is about to be destroyed
void Element::OnDestroy()
{
    DUIAssert(!_fBit.bDestroyed, "OnDestroy called more than once");

    // Match Element/Gadget hierarchies immediately

    // Display node is being destroyed, prepare for the final destruction method
    _fBit.bDestroyed = true;

    // Manually mark parent as NULL, unless this is the root of the
    // destruction. If so, it was removed normally to allow property updates.
    // Update parent's child list as well
    Element* peParent = GetParent();
    if (peParent)
    {
        // Destruction code, relies on pre-Remove of Elements (other half in Element::Destroy)

        // Unparent, parent is destroyed prior to this call
        DUIAssert(peParent->IsDestroyed(), "Parent should already be destroyed");

        // Manual parent update. Cached, inherited VE values are no longer valid due to
        // this manual unparenting. The only cached-inherited value this could be
        // destructive to is the property sheet. This pointer may no longer be valid.
        // Since destruction order only guarantees destroy "final" occurs after
        // destroy "start" of subtree, a child may have a cached property sheet that
        // is not valid. So, the property sheet Value is cached and ref counted (the
        // content (pointer) is not cached directly -- unlike all other cached values)
        _peLocParent = NULL;

        // Manual parent child update
        Value** ppv = peParent->_pvmLocal->GetItem(ChildrenProp);  // No ref count
        DUIAssert(ppv, "Parent/child destruction mismatch");

        ElementList* peList = (*ppv)->GetElementList();

        DUIAssert((*ppv)->GetElementList()->GetItem(GetIndex()) == this, "Parent/child index mismatch");

        // If this is the only child, destroy the list, otherwise, remove the item
        if (peList->GetSize() == 1)
        {
            // Release first since pointer may change when value is removed
            // since data structure is changing
            (*ppv)->Release();
            peParent->_pvmLocal->Remove(ChildrenProp);
        }
        else
        {
            peList->MakeWritable();
            peList->Remove(GetIndex());
            peList->MakeImmutable();

            // Update remaining child indicies, if necessary
            if (GetIndex() < (int)peList->GetSize())
            {
                for (UINT i = GetIndex(); i < peList->GetSize(); i++)
                    peList->GetItem(i)->_iIndex--;
            }

            // The parent's layout may now have invalid "ignore child" indicies for
            // absolute and none layout information. Do not update since not visible
            // and not unstable
#if DBG
            // Ensure all indicies were property sequenced
            for (UINT s = 0; s < peList->GetSize(); s++)
                DUIAssert(peList->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a manual child remove failed");
#endif
        }

        // Parent's child list was manually updated in order to quickly tear down
        // the tree (no formal property change). Normally, a change of children would cause
        // an OnAdd/OnRemove for the parent's layout. This notification happens in direct
        // result of an OnPropertyChange of children. Force an OnRemove now to keep
        // state up-to-date.
        Value* pvLayout;
        Layout* pl = peParent->GetLayout(&pvLayout);
        if (pl)
        {
            Element* peRemoving = this;
            pl->OnRemove(peParent, &peRemoving, 1);
        }
        pvLayout->Release();

        // Update index
        _iIndex = -1;
    }

    // Remove listeners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];

        IElementListener** ppelOld = _ppel;
        _ppel = NULL;

        for (UINT_PTR i = 1; i <= cListeners; i++)
            ppelOld[i]->OnListenerDetach(this);

        HFree(ppelOld);
    }
}

////////////////////////////////////////////////////////
// End deferring

void Element::_FlushDS(Element* pe, DeferCycle* pdc)
{
    // Locate all nodes that require a Desired Size update in a tree. Mark all nodes above these
    // queued nodes as needing a Desired Size update as well. Then, call UpdateDesiredSize with 
    // specfied value constraints on node that has no parent/non-absolute (a "DS Root").
    // DFS from root happens by layouts having to call UpdateDesiredSize on all non-absolute children

    int dLayoutPos;

    Value* pvChildren;

    ElementList* pel = pe->GetChildren(&pvChildren);
    
    if (pel)
    {
        Element* peChild;
        for (UINT i = 0; i < pel->GetSize(); i++)
        {
            peChild = pel->GetItem(i);

            dLayoutPos = peChild->GetLayoutPos();

            if (dLayoutPos != LP_Absolute)
                _FlushDS(peChild, pdc);
        }
    }

    // Returning from children (if any), if this is a "DS Root", call UpdateDesiredSize to
    // cause a DFS (2nd pass) to compute desired size
    Element* peParent = pe->GetParent();

    dLayoutPos = pe->GetLayoutPos();
    
    if (!peParent || dLayoutPos == LP_Absolute)
    {
        // Roots get their specified size
        int dWidth = pe->GetWidth();
        int dHeight = pe->GetHeight();

        // Reuse DC for renderer during update
        // Use NULL handle since may not be visible (no display node)
        // Have constraints at DS Root, update desired size of children

        HDC hDC = GetDC(NULL);

        {
#ifdef GADGET_ENABLE_GDIPLUS
            Gdiplus::Graphics gpgr(hDC);
            GpSurface srf(&gpgr);
            pe->_UpdateDesiredSize((dWidth == -1) ? INT_MAX : dWidth, (dHeight == -1) ? INT_MAX : dHeight, &srf);
#else
            DCSurface srf(hDC);
            pe->_UpdateDesiredSize((dWidth == -1) ? INT_MAX : dWidth, (dHeight == -1) ? INT_MAX : dHeight, &srf);
#endif
        }

        ReleaseDC(NULL, hDC);
    }
    else
    {
        // Not a DS Root, mark parent as needing DS update if this node needs it
        if (pe->_fBit.bNeedsDSUpdate)
            peParent->_fBit.bNeedsDSUpdate = true;
    }

    pvChildren->Release();
}

void Element::_FlushLayout(Element* pe, DeferCycle* pdc)
{
    // Perform a DFS on a tree and Layout nodes if they have a Layout queued. As laying out,
    // childrens' size and position may change. If size changes (Extent), a layout is queued
    // on that child. Children will lay out during the same pass of the tree as a result (1-pass)

    Value* pv;

    if (pe->_fBit.fNeedsLayout)
    {
        DUIAssert(pe->_fBit.fNeedsLayout == LC_Normal, "Optimized layout bit should have been cleared before the flush");  // Must not be LC_Optimize

        pe->_fBit.fNeedsLayout = LC_Pass;

        Value* pvLayout;
        Layout* pl = pe->GetLayout(&pvLayout);

        if (pe->IsSelfLayout() || pl)
        {
            const SIZE* ps = pe->GetExtent(&pv);
            int dLayoutW = ps->cx;
            int dLayoutH = ps->cy;
            pv->Release();

            // Box model, subtract off border and padding from total extent
            const RECT* pr = pe->GetBorderThickness(&pv);  // Border thickness
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();

            pr = pe->GetPadding(&pv);  // Padding
            dLayoutW -= pr->left + pr->right;
            dLayoutH -= pr->top + pr->bottom;
            pv->Release();

            // Higher priority border and padding may cause layout size to go negative
            if (dLayoutW < 0)
                dLayoutW = 0;

            if (dLayoutH < 0)
                dLayoutH = 0;

            if (pe->IsSelfLayout())  // Self layout gets precidence
            {
                pe->_SelfLayoutDoLayout(dLayoutW, dLayoutH);
            }
            else
            {
                pl->DoLayout(pe, dLayoutW, dLayoutH);
            }
        }

        pvLayout->Release();
    }

    // Layout non-absolute children (all non-Root children). If a child has a layout
    // position of none, set its size and position to zero and skip
    int dLayoutPos;
    Value* pvList;
    ElementList* peList = pe->GetChildren(&pvList);

    if (peList)
    {
        Element* peChild;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peChild = peList->GetItem(i);

            dLayoutPos = peChild->GetLayoutPos();
            
            if (dLayoutPos == LP_None)
            {
                peChild->_UpdateLayoutPosition(0, 0);
                peChild->_UpdateLayoutSize(0, 0);
            }
            else if (dLayoutPos != LP_Absolute)
                _FlushLayout(peChild, pdc);
        }
    }

    pvList->Release();
}

SIZE Element::_UpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    // Given constraints, return what size Element would like to be (and cache information).
    // Returned size is no larger than constraints passed in

    SIZE sizeDesired;

    DUIAssert(cxConstraint >= 0 && cyConstraint >= 0, "Constraints must be greater than or equal to zero");
    bool bChangedConst = (_sizeLocLastDSConst.cx != cxConstraint) || (_sizeLocLastDSConst.cy != cyConstraint);
    Value* pv;

    if (_fBit.bNeedsDSUpdate || bChangedConst)
    {
        _fBit.bNeedsDSUpdate = false;

        if (bChangedConst)
        {
            Value* pvOld = Value::CreateSize(_sizeLocLastDSConst.cx, _sizeLocLastDSConst.cy);
            pv = Value::CreateSize(cxConstraint, cyConstraint);

            _PreSourceChange(LastDSConstProp, PI_Local, pvOld, pv);

            _sizeLocLastDSConst.cx = cxConstraint;
            _sizeLocLastDSConst.cy = cyConstraint;

            _PostSourceChange();

            pvOld->Release();
            pv->Release();
        }
        
        // Update desired size cache since it was marked as dirty or a new constraint is being used
        int cxSpecified = GetWidth();
        if (cxSpecified > cxConstraint)
            cxSpecified = cxConstraint;

        int cySpecified = GetHeight(); 
        if (cySpecified > cyConstraint)
            cySpecified = cyConstraint;

        sizeDesired.cx = (cxSpecified == -1) ? cxConstraint : cxSpecified;
        sizeDesired.cy = (cySpecified == -1) ? cyConstraint : cySpecified;

        // KEY POINT:  One would think that, at this point, if a size is specified for both the width and height,
        // then there is no need to go through the rest of the work here to ask what the desired size for the 
        // element is.  Looking at the math here, that is completely true.  The key is that the "get desired size"
        // calls below have the side effect of recursively caching the desired sizes of the descendants of this
        // element.
        //
        // A perf improvement going forward would be allowing the specified width and height case to bail early,
        // and have the computing and caching of descendant desired sizes happening as needed at a later point.


        // Initial DS is spec value if unconstrained (auto). If constrained and spec value is "auto",
        // dimension can be constrained or lesser value. If constrained and spec value is larger, use constraint
        
        // Adjusted constrained dimensions for passing to renderer/layout
        int cxClientConstraint = sizeDesired.cx;
        int cyClientConstraint = sizeDesired.cy;

        // Get constrained desired size of border and padding (box model)
        SIZE sizeNonContent;

        const RECT* pr = GetBorderThickness(&pv); // Border thickness
        sizeNonContent.cx = pr->left + pr->right;
        sizeNonContent.cy = pr->top + pr->bottom;
        pv->Release();

        pr = GetPadding(&pv); // Padding
        sizeNonContent.cx += pr->left + pr->right;
        sizeNonContent.cy += pr->top + pr->bottom;
        pv->Release();

        cxClientConstraint -= sizeNonContent.cx;
        if (cxClientConstraint < 0)
        {
            sizeNonContent.cx += cxClientConstraint;
            cxClientConstraint = 0;
        }

        cyClientConstraint -= sizeNonContent.cy;
        if (cyClientConstraint < 0)
        {
            sizeNonContent.cy += cyClientConstraint;
            cyClientConstraint = 0;
        }

        SIZE sizeContent;

        // Get content constrained desired size

        if (IsSelfLayout()) // Element has self-layout, use it
            sizeContent = _SelfLayoutUpdateDesiredSize(cxClientConstraint, cyClientConstraint, psrf);
        else // No self-layout, check for external layout
        {
            Layout* pl = GetLayout(&pv);

            if (pl)
                sizeContent = pl->UpdateDesiredSize(this, cxClientConstraint, cyClientConstraint, psrf);
            else // No layout, ask renderer
                sizeContent = GetContentSize(cxClientConstraint, cyClientConstraint, psrf);

            pv->Release();
        }

        // validate content desired size
        // 0 <= cx <= cxConstraint
        // 0 <= cy <= cyConstraint
        if (sizeContent.cx < 0)
        {
            sizeContent.cx = 0;
            DUIAssertForce("Out-of-range value:  Negative width for desired size.");
        }
        else if (sizeContent.cx > cxClientConstraint)
        {
            sizeContent.cx = cxClientConstraint;
            DUIAssertForce("Out-of-range value:  Width greater than constraint for desired size.");
        }

        if (sizeContent.cy < 0)
        {
            sizeContent.cy = 0;
            DUIAssertForce("Out-of-range value:  Negative height for desired size.");
        }
        else if (sizeContent.cy > cyClientConstraint)
        {
            sizeContent.cy = cyClientConstraint;
            DUIAssertForce("Out-of-range value:  Height greater than constraint for desired size.");
        }

        // New desired size is sum of border/padding and content dimensions if auto,
        // or if was auto and constrained, use sum if less
        if (cxSpecified == -1)
        {
            int cxSum = sizeNonContent.cx + sizeContent.cx;
            if (cxSum < sizeDesired.cx)
                sizeDesired.cx = cxSum;
        }

        if (cySpecified == -1)
        {
            int cySum = sizeNonContent.cy + sizeContent.cy;
            if (cySum < sizeDesired.cy)
                sizeDesired.cy = cySum;
        }

        Value* pvOld = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);
        pv = Value::CreateSize(sizeDesired.cx, sizeDesired.cy);

        _PreSourceChange(DesiredSizeProp, PI_Local, pvOld, pv);

        _sizeLocDesiredSize = sizeDesired;

        _PostSourceChange();

        pvOld->Release();
        pv->Release();
    }
    else
        // Desired size doesn't need to be updated, return current
        sizeDesired = *GetDesiredSize();

    return sizeDesired;
}

// Called within a Layout cycle
void Element::_UpdateLayoutPosition(int dX, int dY)
{
#if DBG
    // _UpdateLayoutPosition is only valid inside a layout cycle

    // Per-thread storage
    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
    DUIAssert(pdc, "Defer cycle table doesn't exist");

    DUIAssert(pdc->cPCEnter == 0, "_UpdateLayoutPosition must only be used within DoLayout");
#endif

    // Cached value
    if (_ptLocPosInLayt.x != dX || _ptLocPosInLayt.y != dY)
    {
        Value* pvOld = Value::CreatePoint(_ptLocPosInLayt.x, _ptLocPosInLayt.y);
        Value* pvNew = Value::CreatePoint(dX, dY);

        _PreSourceChange(PosInLayoutProp, PI_Local, pvOld, pvNew);

        _ptLocPosInLayt.x = dX;
        _ptLocPosInLayt.y = dY;

        _PostSourceChange();  // Will never queue a Layout GPC due to a change in PosInLayout

        pvOld->Release();
        pvNew->Release();
    }
}

// Called within a Layout cycle
void Element::_UpdateLayoutSize(int dWidth, int dHeight)
{
#if DBG
    // _UpdateLayoutSize is only valid inside a layout cycle.
    // Optimized layout Q requires a call from outsize any OnPropertyChanged since
    // the _PostSourceChange must queue GPCs (outter-most) so that "affects-layout"
    // may be cancelled

    // Per-thread storage
    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
    DUIAssert(pdc, "Defer cycle table doesn't exist");

    DUIAssert(pdc->cPCEnter == 0, "_UpdateLayoutSize must only be used within DoLayout");
    DUIAssert(dWidth >= 0 && dHeight >= 0, "New child size must be greater than or equal to zero");
#endif

    if (_sizeLocSizeInLayt.cx != dWidth || _sizeLocSizeInLayt.cy != dHeight)
    {
        _StartOptimizedLayoutQ();
        //DUITrace("Optimized Layout Q for <%x>\n"), this);

        // Cached value
        Value* pvOld = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);
        Value* pvNew = Value::CreateSize(dWidth, dHeight);

        _PreSourceChange(SizeInLayoutProp, PI_Local, pvOld, pvNew);

        _sizeLocSizeInLayt.cx = dWidth;
        _sizeLocSizeInLayt.cy = dHeight;

        _PostSourceChange();

        pvOld->Release();
        pvNew->Release();

        _EndOptimizedLayoutQ();
    }
}

////////////////////////////////////////////////////////
// Self-layout methods (must be overridden if was created with EC_SelfLayout)

void Element::_SelfLayoutDoLayout(int dWidth, int dHeight)
{
    UNREFERENCED_PARAMETER(dWidth);
    UNREFERENCED_PARAMETER(dHeight);

    DUIAssertForce("Must override");
}

SIZE Element::_SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    DUIAssertForce("Must override");

    SIZE size = { 0, 0 };

    return size;
}

////////////////////////////////////////////////////////
// Generic eventing

// pEvent target and handled fields set this method automatically
// Full will route and bubble
void Element::FireEvent(Event* pEvent, bool fFull)
{
    DUIAssert(pEvent, "Invalid parameter: NULL");

    // Package generic event into a gadget message and send to target (self)
    GMSG_DUIEVENT gmsgEv;
    gmsgEv.cbSize = sizeof(GMSG_DUIEVENT);
    gmsgEv.nMsg = GM_DUIEVENT;
    gmsgEv.hgadMsg = GetDisplayNode();  // this

    // Auto-initialize fields
    pEvent->peTarget = this;
    pEvent->fHandled = false;

    gmsgEv.pEvent = pEvent;

    DUserSendEvent(&gmsgEv, fFull ? SGM_FULL : 0);
}

HRESULT Element::QueueDefaultAction()
{
    // Package generic event into a gadget message and post to target (self)
    EventMsg gmsg;
    gmsg.cbSize = sizeof(GMSG);
    gmsg.nMsg = GM_DUIACCDEFACTION;
    gmsg.hgadMsg = GetDisplayNode();  // this

    return DUserPostEvent(&gmsg, 0);  // Direct
}

void Element::OnEvent(Event* pEvent)
{
    if ((pEvent->nStage == GMF_BUBBLED) || (pEvent->nStage == GMF_DIRECT))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            Element* peTo = NULL;

            NavReference nr;
            nr.Init(pEvent->peTarget, NULL);

            Element* peFrom = (pEvent->peTarget == this) ? this : GetImmediateChild(pEvent->peTarget);

            // todo:  leverage from DCD navigation
            // Three cases:
            // 1) Directional navigation: Call Control's getNearestDirectional.
            // 2) Logical forward navigation: Call getAdjacent. Nav'ing into the guy.
            // 3) Logical backward navigation: Return null, 'cause we'll want to go
            //    up a level. We're nav'ing back OUT of the guy.
            peTo = GetAdjacent(peFrom, ((KeyboardNavigateEvent*) pEvent)->iNavDir, &nr, true);

            if (peTo)
            {
                peTo->SetKeyFocus();
                pEvent->fHandled = true;
                return;
            }    
        }
    }

    // Inform listeners for all stages
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedEvent(this, pEvent);

            if (pEvent->fHandled)
                break;
        }
    }
}

////////////////////////////////////////////////////////
// System input event

// Pointer is only guaranteed good for the lifetime of the call
void Element::OnInput(InputEvent* pie)
{
    // Handle direct and unhandled bubbled events
    if (pie->nStage == GMF_DIRECT)
    {
        switch (pie->nDevice)
        {
        case GINPUT_KEYBOARD:
            {
                KeyboardEvent* pke = (KeyboardEvent*)pie;
                int iNavDir = -1;

                switch (pke->nCode)
                {
                case GKEY_DOWN:
                    switch (pke->ch)
                    {
                        case VK_DOWN:   iNavDir = NAV_DOWN;     break;
                        case VK_UP:     iNavDir = NAV_UP;       break;
                        case VK_LEFT:   iNavDir = (!IsRTL()) ? NAV_LEFT : NAV_RIGHT; break;
                        case VK_RIGHT:  iNavDir = (!IsRTL()) ? NAV_RIGHT : NAV_LEFT; break;
                        case VK_HOME:   iNavDir = NAV_FIRST;    break;   // todo:  check for ctrl modifier
                        case VK_END:    iNavDir = NAV_LAST;     break;   // todo:  check for ctrl modifier
                        case VK_TAB:    pke->fHandled = true;   return;  // eat the down -- we'll handle this one on GKEY_CHAR
                    }
                    break;

                /*
                case GKEY_UP:
                    return;
                */            

                case GKEY_CHAR:
                    if (pke->ch == VK_TAB)
                        iNavDir = (pke->uModifiers & GMODIFIER_SHIFT) ? NAV_PREV : NAV_NEXT;
                    break;
                }

                if (iNavDir != -1)
                {
                    DUIAssert(pie->peTarget->GetKeyWithin(), "Key focus should still be in this child");

                    KeyboardNavigateEvent kne;
                    kne.uidType = Element::KeyboardNavigate;
                    kne.peTarget = pie->peTarget;
                    kne.iNavDir = iNavDir;

                    pie->peTarget->FireEvent(&kne);  // Will route and bubble
                    pie->fHandled = true;
                    return;
                }
                break;
            }
        }
    }

    // Inform listeners for all stages
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedInput(this, pie);

            if (pie->fHandled)
                break;
        }
    }
}

void Element::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    UNREFERENCED_PARAMETER(peFrom);

    Element* peParent = peTo;

    while (peParent)
    {
        if (peParent == this)
            break;
        peParent = peParent->GetParent();
    }

    if (peParent == this)
    {
        if (!GetKeyWithin())
        {
            _PreSourceChange(KeyWithinProp, PI_Local, Value::pvBoolFalse, Value::pvBoolTrue);
            _fBit.bLocKeyWithin = true;
            _PostSourceChange();
        }
    }
    else // (peParent == NULL)
    {
        if (GetKeyWithin())
        {
            _PreSourceChange(KeyWithinProp, PI_Local, Value::pvBoolTrue, Value::pvBoolFalse);
            _fBit.bLocKeyWithin = false;
            _PostSourceChange();
        }
    }
}

void Element::OnMouseFocusMoved(Element* peFrom, Element* peTo)
{
    UNREFERENCED_PARAMETER(peFrom);

    Element* peParent = peTo;

    while (peParent)
    {
        if (peParent == this)
            break;
        peParent = peParent->GetParent();
    }

    if (peParent == this)
    {
        if (!GetMouseWithin())
        {
            _PreSourceChange(MouseWithinProp, PI_Local, Value::pvBoolFalse, Value::pvBoolTrue);
            _fBit.bLocMouseWithin = true;
            _PostSourceChange();
        }
    }
    else // (peParent == NULL)
    {
        if (GetMouseWithin())
        {
            _PreSourceChange(MouseWithinProp, PI_Local, Value::pvBoolTrue, Value::pvBoolFalse);
            _fBit.bLocMouseWithin = false;
            _PostSourceChange();
        }
    }
}

////////////////////////////////////////////////////////
// Hosting system event callbacks and retrieval

// Now being hosted by a native root, fire event on children as well
void Element::OnHosted(Element* peNewHost)
{
    DUIAssert(!IsHosted(), "OnHosted event fired when already hosted");

    _fBit.bHosted = true;

    //DUITrace("Hosted: <%x,%S>\n", this, GetClassInfo()->GetName());

    Value* pv;
    ElementList* peList = GetChildren(&pv);
    if (peList)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->OnHosted(peNewHost);
    pv->Release();
}

// No longer being hosted by a native root, fire event on children as well
void Element::OnUnHosted(Element* peOldHost)
{
    DUIAssert(IsHosted(), "OnUnhosted event fired when already un-hosted");

    _fBit.bHosted = false;

    //DUITrace("UnHosted: <%x,%S>\n", this, GetClassInfo()->GetName());

    Value* pv;
    ElementList* peList = GetChildren(&pv);
    if (peList)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->OnUnHosted(peOldHost);
    pv->Release();
}

////////////////////////////////////////////////////////
// Element tree methods

HRESULT Element::Add(Element* pe)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Add(&pe, 1);
}

HRESULT Element::Add(Element** ppe, UINT cCount)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    Value* pv;
    ElementList* pel = GetChildren(&pv);

    HRESULT hr = Insert(ppe, cCount, (pel) ? pel->GetSize() : 0);

    pv->Release();

    return hr;
}

// Insertion at end of list requires iInsIndex equal to size of list
HRESULT Element::Insert(Element* pe, UINT iInsertIdx)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Insert(&pe, 1, iInsertIdx);
}

// insert to same parent, after current location in childlist, causes a fault
// i.e. child at index 0, inserted again at index 1, indices are off
// fix:
//   int iInsertionIndex = iInsertIdx;
//   for (i = 0; i < cCount; i++)
//   {
//       Element* pe = ppe[i];
//       if ((pe->GetParent() == this) && (pe->GetIndex < iInsertIdx))
//           iInsertionIndex--;
//   }
//

// Insertion at end of list requires iInsIndex equal to size of list
HRESULT Element::Insert(Element** ppe, UINT cCount, UINT iInsertIdx)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    HRESULT hr;

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvOldList = NULL;
    Value* pvNewList = NULL;
    Value* pvNewParent = NULL;
    bool fEndDeferOnFail = false;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvOldList);

    DUIAssert(iInsertIdx <= ((pelOld) ? pelOld->GetSize() : 0), "Invalid insertion index");

    // Create new Children list
    hr = (pelOld) ? pelOld->Clone(&pelNew) : ElementList::Create(cCount, false, &pelNew);
    if (FAILED(hr))
        goto Failed;

    UINT i;

    // Allocate space in list
    // TODO: Bulk insert
    for (i = 0; i < cCount; i++)
    {
        hr = pelNew->Insert(iInsertIdx + i, NULL);  // Items will be set later
        if (FAILED(hr))
            goto Failed;
    }

    // New child list value
    pvNewList = Value::CreateElementList(pelNew);
    if (!pvNewList)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // New parent value
    pvNewParent = Value::CreateElementRef(this);
    if (!pvNewParent)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // Update tree
    StartDefer();

    // If fail after this point, make sure to do an EndDefer
    fEndDeferOnFail = true;

    // Children must be removed from previous parent (if has one)
    for (i = 0; i < cCount; i++)
    {
        if (ppe[i]->GetParent())
        {
            hr = ppe[i]->GetParent()->Remove(ppe[i]);
            if (FAILED(hr))
                goto Failed;
        }
    }

    pelNew->MakeWritable();
    for (i = 0; i < cCount; i++)
    {
        DUIAssert(ppe[i] != this, "Cannot set parent to self");
        DUIAssert(ppe[i]->GetIndex() == -1, "Child's index must be reset to -1 before it's inserted");

        // TODO: Bulk insert
        pelNew->SetItem(iInsertIdx + i, ppe[i]);
        ppe[i]->_iIndex = iInsertIdx + i;
    }
    pelNew->MakeImmutable();

    // Update remaining indicies
    for (i = iInsertIdx + cCount; i < pelNew->GetSize(); i++)
        pelNew->GetItem(i)->_iIndex = i;

    // Set children list (it is read-only, use internal set since property is Normal type)
    // Partial fail means Value was set but dependency sync/notifications were incomplete
    hr = _SetValue(ChildrenProp, PI_Local, pvNewList, true);
    if (FAILED(hr) && (hr != DUI_E_PARTIAL))
    {
        // Re-sequence indicies of children since failed to change from original child list
        for (i = 0; i < pelOld->GetSize(); i++)
            pelOld->GetItem(i)->_iIndex = i;
            
        goto Failed;
    }

#if DBG
    // Ensure all indicies were property sequenced
    for (UINT s = 0; s < pelNew->GetSize(); s++)
        DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child insert failed");
#endif

    pvOldList->Release();
    pvNewList->Release();

    // Set child's parent (it is read-only, set value directly since property is LocalOnly type)
    // Operation will not fail to set correct parent (member on Element)
    for (i = 0; i < cCount; i++)
    {
        DUIAssert(!ppe[i]->GetParent(), "Child's parent should be NULL before its parent is set");  // Should be NULL

        ppe[i]->_PreSourceChange(ParentProp, PI_Local, Value::pvElementNull, pvNewParent);

        ppe[i]->_peLocParent = this;

        ppe[i]->_PostSourceChange();
    }
    pvNewParent->Release();

    EndDefer();

    return S_OK;

Failed:

    if (pvOldList)
    {
        pvOldList->Release();
        pvOldList = NULL;
    }

    if (pvNewList)
    {
        pvNewList->Release();
        pvNewList = NULL;
    }
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList
    pelNew = NULL;

    if (pvNewParent)
    {
        pvNewParent->Release();
        pvNewParent = NULL;
    }

    if (fEndDeferOnFail)
        EndDefer();

    return hr;
}

HRESULT Element::Add(Element* pe, CompareCallback lpfnCompare)
{
    UNREFERENCED_PARAMETER(pe);
    UNREFERENCED_PARAMETER(lpfnCompare);

    Value* pvChildren;
    ElementList* pel = GetChildren(&pvChildren);

    UINT i = 0;
    if (pel)
    {
        // simple linear search right now -- can easily make into a binary search
        while (i < pel->GetSize())
        {
            Element* peCheck = pel->GetItem(i);
            if (lpfnCompare(&pe, &peCheck) < 0)
                break;
            i++;
        }
    }

    pvChildren->Release();

    return Insert(pe, i);
}

HRESULT Element::SortChildren(CompareCallback lpfnCompare)
{
    HRESULT hr;

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvList = NULL;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvList);

    if (!pelOld || (pelOld->GetSize() <= 1))
    {
        pvList->Release();
        return S_OK;
    }

    // Create new Children list
    hr = pelOld->Clone(&pelNew);
    if (FAILED(hr))
        goto Failed;

    pvList->Release();

    // New child list value
    pvList = Value::CreateElementList(pelNew);
    if (!pvList)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    // Update tree
    StartDefer();

    pelNew->Sort(lpfnCompare);

    for (UINT i = 0; i < pelNew->GetSize(); i++)
        ((Element*) pelNew->GetItem(i))->_iIndex = i;

    // Set children list (it is read-only, use internal set since property is Normal type)
    _SetValue(ChildrenProp, PI_Local, pvList, true);

#if DBG
    // Ensure all indicies were property sequenced
    for (UINT s = 0; s < pelNew->GetSize(); s++)
        DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child insert failed");
#endif

    pvList->Release();

    EndDefer();

    return S_OK;

Failed:

    if (pvList)
        pvList->Release();
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList

    return hr;
}

HRESULT Element::Remove(Element* pe)
{
    DUIAssert(pe, "Invalid parameter: NULL");

    return Remove(&pe, 1);
}

HRESULT Element::RemoveAll()
{
    HRESULT hr = S_OK;

    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    if (peList)
    {
        peList->MakeWritable();
        hr = Remove(peList->GetItemPtr(0), peList->GetSize());  // Access list directly
        peList->MakeImmutable();
    }

    pvChildren->Release();

    return hr;
}

HRESULT Element::Remove(Element** ppe, UINT cCount)
{
    DUIAssert(ppe, "Invalid parameter: NULL");

    HRESULT hr;

    Value* pvOld;
    int iLowest = INT_MAX;
    int iIndex = -1;
    bool fEndDeferOnFail = false;

    // Get current Children list
    ElementList* pelOld = GetChildren(&pvOld);

    DUIAssert(pelOld, "Element has no children");

    // Values to free on failure
    ElementList* pelNew = NULL;
    Value* pvNew = NULL;

    // Create new Children list (copy old)
    hr = pelOld->Clone(&pelNew);
    if (FAILED(hr))
        goto Failed;

    // Update list, remove Elements and track lowest index changed

    UINT i;
    for (i = 0; i < cCount; i++)
    {
        //DUITrace("Normal Remove of: <%x>\n", ppe[i]);

        DUIAssert(ppe[i] != this, "Cannot set parent to self");
        DUIAssert(ppe[i]->GetParent() == this, "Not a child of this Element");

        // GetIndex() is valid for Elements with indicies less than the smallest index removed
        if (ppe[i]->GetIndex() < iLowest)
        {
            iIndex = ppe[i]->GetIndex();  // Faster lookup
            iLowest = iIndex;
        }
        else
            iIndex = pelNew->GetIndexOf(ppe[i]);
                    
        pelNew->Remove(iIndex);
    }

    // If all the children were removed, make list NULL
    if (!pelNew->GetSize())
    {
        pelNew->Destroy();
        pelNew = NULL;
        pvNew = Value::pvElListNull;
    }
    else
    {
        pvNew = Value::CreateElementList(pelNew);
        if (!pvNew)
        {
            hr = E_OUTOFMEMORY;
            goto Failed;
        }
    }

    // Update indicies of children removed
    for (i = 0; i < cCount; i++)
        ppe[i]->_iIndex = -1;
    
    // Update tree
    StartDefer();

    // If fail after this point, make sure to do an EndDefer
    fEndDeferOnFail = true;

    // Reset child indicies of remaining children starting at lowest index changed
    if (pelNew)
    {
        for (i = iLowest; i < pelNew->GetSize(); i++)
            pelNew->GetItem(i)->_iIndex = i;

        // Set children list (it is read-only, use internal set since property is Normal type)
        // Partial fail means Value was set but dependency sync/notifications were incomplete        
        hr = _SetValue(ChildrenProp, PI_Local, pvNew, true);
    }
    else
    {
        // No children, remove local value
        hr = _RemoveLocalValue(ChildrenProp);
    }

    if (FAILED(hr) && (hr != DUI_E_PARTIAL))
    {
        // Re-sequence indicies of children since failed to change from original child list
        for (i = 0; i < pelOld->GetSize(); i++)
            pelOld->GetItem(i)->_iIndex = i;
    
        goto Failed;
    }

#if DBG
    // Ensure all indicies were property sequenced
    if (pelNew)
    {
        for (UINT s = 0; s < pelNew->GetSize(); s++)
            DUIAssert(pelNew->GetItem(s)->GetIndex() == (int)s, "Index resequencing resulting from a child remove failed");
    }
#endif

    pvOld->Release();
    pvNew->Release();

    // Set child parent to NULL (it is read-only, set value directly since property is LocalOnly type)
    // Operation will not fail to set correct parent (member on Element)
    for (i = 0; i < cCount; i++)
    {
        pvOld = ppe[i]->GetValue(ParentProp, PI_Local);

        DUIAssert(pvOld->GetElement(), "Child's old parent when inserting should be NULL");

        ppe[i]->_PreSourceChange(ParentProp, PI_Local, pvOld, Value::pvElementNull);

        ppe[i]->_peLocParent = NULL;

        ppe[i]->_PostSourceChange();

        pvOld->Release();
    }

    EndDefer();

    return S_OK;

Failed:
    
    if (pvOld)
    {
        pvOld->Release();
        pvOld = NULL;
    }

    if (pvNew)
    {
        pvNew->Release();
        pvNew = NULL;
    }
    else
        pelNew->Destroy(); // Release on Value-owner will automatically destroy the ElementList
    pelNew = NULL;

    if (fEndDeferOnFail)
        EndDefer();

    return hr;
}

// Destroy this Element. Must not use delete operator to destroy Elements.
// A delayed destroy uses a posted message to delay the actual DeleteHandle.
// Care must be taken to not pump messages when notifications may be pending
// (i.e. in a defer cycle).
//
// If an Element is destroyed with pending notifications, the notifications
// will be lost.
//
// Deferred destruction allows:
//   1) Calling destroy on self within a callback on the Element
//   2) Processing of all nofictaions before destruction (as long
//      as messages aren't pumped within a defer cycle)

HRESULT Element::Destroy(bool fDelayed)
{
    HRESULT hr = S_OK;

    // Check to see what type of destruction is allowed. If the Element's Initialize
    // succeeds, a standard destruction is used (since a display node exits -- all
    // destruction is driven by the Gadget). However, if Element's Initialize fails,
    // then no display node is available. Direct deletion is then required.
    if (!GetDisplayNode())
    {
        // Destruction is immidiate, regardless of fDelayed if no
        // display node is present
        HDelete<Element>(this);
        return S_OK;
    }

    // New destruction code, relies on pre-Remove of Elements (other half in Element::OnDestroy)
    // Root of destruction, remove from parent (if exists)
    Element* peParent = GetParent();
    if (peParent)
        hr = peParent->Remove(this);

    if (fDelayed)
    {
        // Async-invoke the DeleteHandle so that and pending
        // defer cycle can complete
        EventMsg gmsg;
        gmsg.cbSize = sizeof(GMSG);
        gmsg.nMsg = GM_DUIASYNCDESTROY;
        gmsg.hgadMsg = GetDisplayNode();  // this

        DUserPostEvent(&gmsg, 0);
    }
    else
    {
        // Destroy immediately, do not allow multiple destroys on an Element
        if (!IsDestroyed())
            DeleteHandle(GetDisplayNode());
    }

    return hr;
}

HRESULT Element::DestroyAll()
{
    HRESULT hr = S_OK;

    // Get list of all children
    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    if (peList)
    {
        // Remove all children (roots of destruction)
        // Will do a bulk remove instead of relying on the Remove called from Destroy
        hr = RemoveAll();

        if (FAILED(hr))
            goto Failed;

        // All children have been removed, however, we still have a list of children.
        // Mark them for destruction (this call will aways succeed since all have been removed)
        for (UINT i = 0; i < peList->GetSize(); i++)
            peList->GetItem(i)->Destroy();    
    }

Failed:

    pvChildren->Release();

    return hr;
}

// Locate descendent based on ID
Element* Element::FindDescendent(ATOM atomID)
{
    DUIAssert(atomID, "Invalid parameter");

    // Check this Element
    if (GetID() == atomID)
        return this;

    // No match, check children
    Element* peMatch = NULL;

    Value* pvList;
    ElementList* peList = GetChildren(&pvList);

    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            if ((peMatch = peList->GetItem(i)->FindDescendent(atomID)) != NULL)
                break;
        }
    }

    pvList->Release();    

    return peMatch;
}

// Map a point in client coordinated from a Element to this
void Element::MapElementPoint(Element* peFrom, const POINT* pptFrom, POINT* pptTo)
{
    DUIAssert(peFrom && pptFrom && pptTo, "Invalid parameter: NULL");

    if (peFrom == this)
    {
        *pptTo = *pptFrom;
        return;
    }

    RECT rcTo;
    RECT rcFrom;
    GetGadgetRect(peFrom->GetDisplayNode(), &rcFrom, SGR_CONTAINER);
    GetGadgetRect(GetDisplayNode(), &rcTo, SGR_CONTAINER);
    pptTo->x = (rcFrom.left + pptFrom->x) - rcTo.left;
    pptTo->y = (rcFrom.top + pptFrom->y) - rcTo.top;
}

// Give this keyboard focus and ensure it is visible
void Element::SetKeyFocus()
{
    // TODO: Resolve possibility that setting property may not result in SetGadgetFocus happen
    // on this (i.e. check for 'Enabled' when available)
    if (GetVisible() && GetEnabled() && (GetActive() & AE_Keyboard))
        _SetValue(KeyFocusedProp, PI_Local, Value::pvBoolTrue);
}

// Locate direct descendant that is an ancestor of the given Element
Element* Element::GetImmediateChild(Element* peFrom)
{
    if (!peFrom)
        return NULL;

    Element* peParent = peFrom->GetParent();

    while (peParent != this)
    {
        if (!peParent)
            return NULL;

        peFrom = peParent;
        peParent = peParent->GetParent();
    }

    return peFrom;
}

bool Element::IsDescendent(Element* pe)
{
    if (!pe)
        return false;

    Element* peParent = pe;

    while ((peParent != this) && (peParent != NULL))
        peParent = peParent->GetParent();

    return (peParent != NULL);
}

//
// GetAdjacent is used to locate a physically neighboring element given a "starting" element.
// It is used most commonly for directional navigation of keyboard focus, but it is general purpose
// enough to be used for other applications.
//
// peFrom vs. pnr->pe -- this is definitely redundant -- peFrom is really just a convenience that narrows it down
// to self, immediate child, or *else*
//
// logical uses peFrom
// directional uses peFrom & optionally pnr->pe
//
// DISCUSS -- an "approval" callback instead of bKeyableOnly, to make it even more general purpose
//            we can still do some trick for bKeyableOnly for perf reasons (if we find perf to be a problem here)
//         -- should we continue to use event bubbling for *completing* getadjacent in the cases where it's
//            outside the scope of this element?  Or should we build GetAdjacent to go up (in addition to down,
//            which it's already doing) the element chain as needed to find the adjacent element
// 
//
// peFrom:
//   NULL -- meaning we're navigating from something outside element's scope -- peer, parent, etc.
//   this -- meaning we're navigating from this element itself
//   immediate child -- meaning we're navigation from one of this element's children
//
// pnr:
//   pe:
//     NULL -- we're navigating from space (i.e. outside this Element hierarchy)
//     element -- we're navigating from this exact element
//   prc:
//     rect -- use described rectangle, in reference element's coordinates
//     NULL -- use entire bounding rectangle for reference element
//
Element* Element::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    if (!GetVisible() || (GetLayoutPos() == LP_None))
        // don't dig down into invisible or non-laid out elements
        return NULL;

    // todo -- we *still* need to think about the implications of this;
    // the bigger question is, do we ignore a zero sized guy for keyfocus?
    // also, since a zero size element is going to happen when you've compressed the window (i.e. not enough room to 
    // fit all items), then it may be odd that keynav is behaving differently based on the size of the window
    // (i.e. you hit the right arrow three times, but based on whether one guy in the middle is zero size or not,
    // you may end up at a different element
    // - jeffbog 08/21/00
    Value* pvExtent;
    SIZE const* psize = GetExtent(&pvExtent);
    bool bZeroSize = (!psize->cx || !psize->cy);
    pvExtent->Release();

    if (bZeroSize)
        return NULL;

    // this element can be a valid choice if it's keyboard focusable or if we don't care about whether or not the element
    // is keyboard focusable (as indicated by the bKeyableOnly flag)
    bool bCanChooseSelf = !bKeyableOnly || (GetEnabled() && ((GetActive() & AE_Keyboard) != 0));
    int  bForward = (iNavDir & NAV_FORWARD);

    if (!peFrom && bCanChooseSelf && (bForward || !(iNavDir & NAV_LOGICAL)))
        return this;

    Element* peTo = GA_NOTHANDLED;
    bool bReallyRelative = (peFrom && (iNavDir & NAV_RELATIVE));


    Value* pvLayout;
    Layout* pl = GetLayout(&pvLayout);
    
    if (pl)
        // jeffbog todo:  investigate whether or not this only needs to be called for directional navigation
        peTo = pl->GetAdjacent(this, peFrom, iNavDir, pnr, bKeyableOnly);

    pvLayout->Release();

    if (peTo == GA_NOTHANDLED)
    {
        // default processing
        peTo = NULL;

        Value* pvChildren;
        ElementList* pelChildren = GetChildren(&pvChildren);

        UINT uChild = 0;
        UINT cChildren = 0;
        if (pelChildren)
        {
            cChildren = pelChildren->GetSize();
            int iInc = bForward ? 1 : -1;
            UINT uStop = bForward ? cChildren : ((UINT)-1);

            if (bReallyRelative)
            {
                if (peFrom == this)
                    uChild = bForward ? 0 : ((UINT)-1);
                else
                    uChild = peFrom->GetIndex() + iInc;
            }
            else
                // absolute (or null "from" -- which is the equivalent of absolute)
                uChild = bForward ? 0 : cChildren - 1;

            // was GetFirstKeyable -- keeping boxed for now just in case we want to factor it back out for reuse
            // peTo = GetFirstKeyable(iNavDir, prcReference, bKeyableOnly, uChild);
            for (UINT u = uChild; u != uStop; u += iInc)
            {        
                Element* peWalk = pelChildren->GetItem(u);

                peWalk = peWalk->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                if (peWalk)
                {
                    peTo = peWalk;
                    break;
                }
            }
        }
        pvChildren->Release();
    }
  
    if ((iNavDir & NAV_LOGICAL) && !peTo)
    {
        if ((peFrom != this) && !bForward && bCanChooseSelf)
            return this;
    }

    return peTo;
}

// Retrieve first child with 'KeyWithin' property set to true
Element* Element::GetKeyWithinChild()
{
    Value* pv;

    ElementList* pelChildren = GetChildren(&pv);
    if (!pelChildren)
    {
        pv->Release();
        return NULL;
    }

    UINT cChildren = pelChildren->GetSize();
    DUIAssert(cChildren, "Zero children even though a child list exists");

    Element* peWalk = NULL;
    for (UINT u = 0; u < cChildren; u++)
    {
        peWalk = pelChildren->GetItem(u);
        if (peWalk->GetKeyWithin())
            break;
    }

    pv->Release();

    return peWalk;
}

// Retrieve first child with 'MouseWithin' property set to true
Element* Element::GetMouseWithinChild()
{
    Value* pv;

    ElementList* pelChildren = GetChildren(&pv);
    if (!pelChildren)
    {
        pv->Release();
        return NULL;
    }

    UINT cChildren = pelChildren->GetSize();
    DUIAssert(cChildren, "Zero children even though a child list exists");

    Element* peWalk = NULL;
    for (UINT u = 0; u < cChildren; u++)
    {
        peWalk = pelChildren->GetItem(u);
        if (peWalk->GetMouseWithin())
            break;
    }

    pv->Release();

    return peWalk;
}

// Ensure child is not obstructed
bool Element::EnsureVisible()
{
    // todo:  before passing to parent, have to clip this rectangle
    // also, should check visibility -- duh
    Value* pvSize;
    const SIZE* psize = GetExtent(&pvSize);
    bool bRet = EnsureVisible(0, 0, psize->cx, psize->cy);
    pvSize->Release();

    return bRet;
}

bool Element::EnsureVisible(UINT uChild)
{
    // todo:  before passing to parent, have to clip this rectangle
    // also, should check visibility -- duh
    Value* pvChildren;
    Value* pvSize;
    Value* pvPoint;

    ElementList* pelChildren = GetChildren(&pvChildren);

    if (!pelChildren || (uChild >= pelChildren->GetSize()))
    {
        pvChildren->Release();
        return false;
    }

    Element* pe = pelChildren->GetItem(uChild);

    const POINT* ppt = pe->GetLocation(&pvPoint);
    const SIZE* psize = pe->GetExtent(&pvSize);

    bool bChanged = EnsureVisible(ppt->x, ppt->y, psize->cx, psize->cy);

    pvPoint->Release();
    pvSize->Release();
    pvChildren->Release();

    return bChanged;
}

// Ensure region of Element is not obstructed
bool Element::EnsureVisible(int x, int y, int cx, int cy)
{
    Element* peParent = GetParent();

    if (peParent)
    {
        Value* pv;
        const POINT* ppt = GetLocation(&pv);
        
        bool bChanged = peParent->EnsureVisible(ppt->x + x, ppt->y + y, cx, cy);

        pv->Release();

        return bChanged;
    }

    return false;
}

// Passed Animation value for this describes the animation to invoke
void Element::InvokeAnimation(int dAni, UINT nTypeMask)
{
    // Get duration
    float flDuration = 0.0f;
    switch (dAni & ANI_SpeedMask)
    {
    case ANI_VeryFast:
        flDuration = 0.15f;
        break;

    case ANI_Fast:  
        flDuration = 0.35f;
        break;

    case ANI_MediumFast:
        flDuration = 0.50f;
        break;

    case ANI_Medium:
        flDuration = 0.75f;
        break;

    case ANI_MediumSlow:
        flDuration = 1.10f;
        break;

    case ANI_Slow:
        flDuration = 1.50f;
        break;

    case ANI_DefaultSpeed:
    default:
        flDuration = 0.75f;
        break;
    }

    // Get delay
    float flDelay = 0.0f;
    switch (dAni & ANI_DelayMask)
    {
    case ANI_DelayShort:  
        flDelay = 0.25f;
        break;

    case ANI_DelayMedium:
        flDelay = 0.75f;
        break;

    case ANI_DelayLong:
        flDelay = 1.50f;
        break;
    }

    InvokeAnimation(dAni & nTypeMask, dAni & ANI_InterpolMask, flDuration, flDelay);
}

// Animate display node to match current Element state
void Element::InvokeAnimation(UINT nTypes, UINT nInterpol, float flDuration, float flDelay, bool fPushToChildren)
{
    IInterpolation* piip = NULL;

    if (nInterpol == ANI_DefaultInterpol)
        nInterpol = ANI_Linear;
    BuildInterpolation(nInterpol, 0, __uuidof(IInterpolation), (void**)&piip);

    if (piip == NULL)
        return;

    // Start Bounds type animations
    if (nTypes & ANI_BoundsType)
    {
        // Get requested bounds type animation
        UINT nType = nTypes & ANI_BoundsType;

        // Retrieve final size
        Value* pvLoc;
        Value* pvExt;

        const POINT* pptLoc = GetLocation(&pvLoc);
        const SIZE* psizeExt = GetExtent(&pvExt);

        // Create rect animation
        GANI_RECTDESC descRect;
        ZeroMemory(&descRect, sizeof(descRect));
        descRect.cbSize         = sizeof(descRect);
        descRect.act.flDuration = flDuration;
        descRect.act.flDelay    = flDelay;
        descRect.act.dwPause    = (DWORD) -1;
        descRect.hgadChange     = GetDisplayNode();
        descRect.pipol          = piip;
        descRect.ptEnd          = *pptLoc;
        descRect.sizeEnd        = *psizeExt;

        // Rect animations override position and size animations
        if (nType == ANI_Rect)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Rectangle Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_RectH)
        {
            IAnimation * pian = NULL;
            RECT rcCur;
            GetGadgetRect(GetDisplayNode(), &rcCur, SGR_PARENT);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.ptStart.x    = rcCur.left;
            descRect.ptStart.y    = pptLoc->y;
            descRect.sizeStart.cx = rcCur.right - rcCur.left;
            descRect.sizeStart.cy = psizeExt->cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_RectV)
        {
            IAnimation * pian = NULL;
            RECT rcCur;
            GetGadgetRect(GetDisplayNode(), &rcCur, SGR_PARENT);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.ptStart.x    = pptLoc->x;
            descRect.ptStart.y    = rcCur.top;
            descRect.sizeStart.cx = psizeExt->cx;
            descRect.sizeStart.cy = rcCur.bottom - rcCur.top;

            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_Position)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_MOVE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Position Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_Size)
        {
            IAnimation * pian = NULL;
            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: Size Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_SizeH)
        {
            IAnimation * pian = NULL;
            SIZE sizeCur;
            GetGadgetSize(GetDisplayNode(), &sizeCur);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.sizeStart.cx = sizeCur.cx;
            descRect.sizeStart.cy = psizeExt->cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeH Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }
        else if (nType == ANI_SizeV)
        {
            IAnimation * pian = NULL;
            SIZE sizeCur;
            GetGadgetSize(GetDisplayNode(), &sizeCur);

            descRect.nAniFlags = ANIF_USESTART;
            descRect.sizeStart.cx = psizeExt->cx;
            descRect.sizeStart.cy = sizeCur.cy;

            descRect.nChangeFlags = SGR_PARENT | SGR_SIZE;
            BuildAnimation(ANIMATION_RECT, 0, &descRect, __uuidof(IAnimation), (void **) &pian);
            if (pian)
                pian->Release();
            //DUITrace("DUI: SizeV Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
        }

        pvLoc->Release();
        pvExt->Release();
    }

    // Start Alpha type animations
    if (nTypes & ANI_AlphaType)
    {
        // Retrieve final alpha level
        int dAlpha = GetAlpha();

        // Create alpha animation
        GANI_ALPHADESC descAlpha;
        ZeroMemory(&descAlpha, sizeof(descAlpha));
        descAlpha.cbSize            = sizeof(descAlpha);
        descAlpha.act.flDuration    = flDuration;
        descAlpha.act.flDelay       = flDelay;
        descAlpha.act.dwPause       = (DWORD) -1;
        descAlpha.hgadChange        = GetDisplayNode();
        descAlpha.pipol             = piip;
        descAlpha.flEnd             = (float)dAlpha / 255.0f;
        descAlpha.fPushToChildren   = fPushToChildren ? TRUE : FALSE;
        descAlpha.nOnComplete       = GANI_ALPHACOMPLETE_OPTIMIZE;

        IAnimation * pian = NULL;
        BuildAnimation(ANIMATION_ALPHA, 0, &descAlpha, __uuidof(IAnimation), (void **) &pian);
        if (pian)
            pian->Release();
        //DUITrace("DUI: Alpha Animation start for <%x> (%S)\n", this, GetClassInfo()->GetName());
    }

    if (piip)
        piip->Release();
}


void Element::StopAnimation(UINT nTypes)
{
    IAnimation* pian;
    
    if (nTypes & ANI_BoundsType)
    {
        pian = NULL;
        GetGadgetAnimation(GetDisplayNode(), ANIMATION_RECT, __uuidof(IAnimation), (void**)&pian);
        if (pian != NULL)
            pian->SetTime(IAnimation::tDestroy);
    }

    if (nTypes & ANI_AlphaType)
    {
        pian = NULL;
        GetGadgetAnimation(GetDisplayNode(), ANIMATION_ALPHA, __uuidof(IAnimation), (void**)&pian);
        if (pian != NULL)
            pian->SetTime(IAnimation::tDestroy);
    }

    //DUITrace("DUI: Animation Cancelled for <%x> (%S)\n", this, GetClassInfo()->GetName());
}


////////////////////////////////////////////////////////
// Element Listeners

HRESULT Element::AddListener(IElementListener* pel)
{
    DUIAssert(pel, "Invalid listener: NULL");

    IElementListener** ppNewList;
    UINT_PTR cListeners;

    // Add listener to list
    if (_ppel)
    {
        cListeners = (UINT_PTR)_ppel[0] + 1;
        ppNewList = (IElementListener**)HReAllocAndZero(_ppel, sizeof(IElementListener*) * (cListeners + 1));
    }
    else
    {
        cListeners = 1;
        ppNewList = (IElementListener**)HAllocAndZero(sizeof(IElementListener*) * (cListeners + 1));
    }

    if (!ppNewList)
        return E_OUTOFMEMORY;

    _ppel = ppNewList;
    _ppel[0] = (IElementListener*)cListeners;

    _ppel[(UINT_PTR)(*_ppel)] = pel;

    // Callback
    pel->OnListenerAttach(this);

    return S_OK;
}

void Element::RemoveListener(IElementListener* pel)
{
    DUIAssert(pel, "Invalid listener: NULL");

    if (!_ppel)
        return;

    // Locate listener
    bool fFound = false;

    UINT_PTR cListeners = (UINT_PTR)_ppel[0];

    for (UINT_PTR i = 1; i <= cListeners; i++)
    {
        if (fFound) // Once found, use the remaining iterations to move the indices down by one
            _ppel[i-1] = _ppel[i]; 
        else if (_ppel[i] == pel)
            fFound = true;
    }

    // If listener was found, remove    
    if (fFound)
    {
        // Callback
        pel->OnListenerDetach(this);

        cListeners--;
        
        if (!cListeners)
        {
            HFree(_ppel);
            _ppel = NULL;
        }
        else
        {
            // Trim list
            IElementListener** ppNewList;
            ppNewList = (IElementListener**)HReAllocAndZero(_ppel, sizeof(IElementListener*) * (cListeners + 1));

            // If allocation failed, keep old list
            if (ppNewList)
                _ppel = ppNewList;

            // Set new count (one less)
            _ppel[0] = (IElementListener*)cListeners;
        }
    }
}

////////////////////////////////////////////////////////
// Global Gadget callback

// Per-instance callback
UINT Element::MessageCallback(GMSG* pgMsg)
{
    UNREFERENCED_PARAMETER(pgMsg);

    return DU_S_NOTHANDLED;
}

HRESULT Element::_DisplayNodeCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    //DUITrace("Gad<%x>, El<%x>\n", pGMsg->hgadCur, pvCur);

    Element* pe = (Element*)pvCur;

#if DBG
    // Check for callback reentrancy
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (petls)
    {
        petls->cDNCBEnter++;
        //if (petls->cDNCBEnter > 1)
        //    DUITrace("_DisplayNodeCallback() entered %d times. (El:<%x> GMsg:%d)\n", petls->cDNCBEnter, pe, pGMsg->nMsg);
    }
#endif

    // Allow for override of messages
    HRESULT nRes = pe->MessageCallback(pGMsg);
    
    if (nRes != DU_S_COMPLETE)
    {
        switch (pGMsg->nMsg)
        {
        case GM_DESTROY:
            {
                GMSG_DESTROY* pDestroy = (GMSG_DESTROY*)pGMsg;
                if (pDestroy->nCode == GDESTROY_START)
                {
                    // On a "destroy start" remove Element from parent
                    pe->OnDestroy();
                }
                else if (pDestroy->nCode == GDESTROY_FINAL)
                {
                    // Last message received, destroy Element
                    DUIAssert(pe->IsDestroyed(), "Element got final destroy message but isn't marked as destroyed");

                    // Ensure no children exist for this Element. All children should have received
                    // a "destroy start" before the parent receives "destroy finish"
#if DBG
                    Value* pv;
                    DUIAssert(!pe->GetChildren(&pv), "Child count should be zero for final destroy");
                    pv->Release();
#endif
                    Value* pvLayout;
                    Layout* pl = pe->GetLayout(&pvLayout);
                    if (pl)
                        pl->Detach(pe);
                    pvLayout->Release();
                    // Clear all values currently being stored
                    pe->_pvmLocal->Enum(_ReleaseValue);

                    // Clear ref-counted cache
                    pe->_pvSpecSheet->Release();

                    // Remove Element from all applicable defer tables, if within defer cycle
                    DeferCycle* pdc = GetDeferObject();
                    if (pdc && pdc->cEnter > 0) // Check if active
                    {
                        // Remove possible pending root operations
                        pdc->pvmUpdateDSRoot->Remove(pe, false, true);
                        pdc->pvmLayoutRoot->Remove(pe, false, true);

                        // Remove pending group notifications (normal)
                        if (pe->_iGCSlot != -1)
                        {
                            DUIAssert((int)pdc->pdaGC->GetSize() > pe->_iGCSlot, "Queued group changes expected");
                            GCRecord* pgcr = pdc->pdaGC->GetItemPtr(pe->_iGCSlot);
                            pgcr->pe = NULL;  // Ignore record
                            DUITrace("Element <%x> group notifications ignored due to deletion\n", pe);
                        }

                        // Remove pending group notifications (low priority)
                        if (pe->_iGCLPSlot != -1)
                        {
                            DUIAssert((int)pdc->pdaGCLP->GetSize() > pe->_iGCLPSlot, "Queued low-pri group changes expected");
                            GCRecord* pgcr = pdc->pdaGCLP->GetItemPtr(pe->_iGCLPSlot);
                            pgcr->pe = NULL;  // Ignore record
                            DUITrace("Element <%x> low-pri group notifications ignored due to deletion\n", pe);
                        }

                        // Remove pending property notifications
                        if (pe->_iPCTail != -1)
                        {
                            DUIAssert((int)pdc->pdaPC->GetSize() > pe->_iPCTail, "Queued property changes expected");

                            PCRecord* ppcr;
                            int iScan = pe->_iPCTail;
                            while (iScan >= pdc->iPCPtr)
                            {
                                ppcr = pdc->pdaPC->GetItemPtr(iScan);
                                if (!ppcr->fVoid)
                                {
                                    // Free record
                                    ppcr->fVoid = true;
                                    ppcr->pvOld->Release();
                                    ppcr->pvNew->Release();
                                }

                                // Walk back to previous record
                                iScan = ppcr->iPrevElRec;
                            }
                            DUITrace("Element <%x> property notifications ignored due to deletion\n", pe);
                        }
                    }
                    else
                    {
                        DUIAssert(pe->_iGCSlot == -1, "Invalid group notification state for destruction");
                        DUIAssert(pe->_iGCLPSlot == -1, "Invalid low-pri group notification state for destruction");
                        DUIAssert(pe->_iPCTail == -1, "Invalid property notification state for destruction");
                    }

#if DBG
                    // Track element count
                    InterlockedDecrement(&g_cElement);
#endif

                    HDelete<Element>(pe);
                }
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_PAINT:  // Painting (box model)
            {
                // Direct message
                DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "'Current' and 'About' gadget doesn't match even though message is direct");
                GMSG_PAINT* pmsgP = (GMSG_PAINT*)pGMsg;
                DUIAssert(pmsgP->nCmd == GPAINT_RENDER, "Invalid painting command");

                switch (pmsgP->nSurfaceType)
                {
                case GSURFACE_HDC:
                    {
                        GMSG_PAINTRENDERI* pmsgR = (GMSG_PAINTRENDERI*)pmsgP;
                        pe->Paint(pmsgR->hdc, pmsgR->prcGadgetPxl, pmsgR->prcInvalidPxl, NULL, NULL);
                    }
                    break;

#ifdef GADGET_ENABLE_GDIPLUS
                case GSURFACE_GPGRAPHICS:
                    {
                        GMSG_PAINTRENDERF* pmsgR = (GMSG_PAINTRENDERF*)pmsgP;
                        pe->Paint(pmsgR->pgpgr, pmsgR->prcGadgetPxl, pmsgR->prcInvalidPxl, NULL, NULL);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS

                default:
                    DUIAssertForce("Unknown rendering surface");
                }
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_CHANGESTATE:  // Gadget state changed
            {
                // Full message

                // Only allow direct and bubbled change state messages, ignore routed
                if (GET_EVENT_DEST(pGMsg) == GMF_ROUTED)
                    break;

                GMSG_CHANGESTATE* pSC = (GMSG_CHANGESTATE*)pGMsg;

                // Retrieve corresponding Elements of state change
                Element* peSet = NULL;
                Element* peLost = NULL;

                GMSG_DUIGETELEMENT gmsgGetEl;
                ZeroMemory(&gmsgGetEl, sizeof(GMSG_DUIGETELEMENT));

                gmsgGetEl.cbSize = sizeof(GMSG_DUIGETELEMENT);
                gmsgGetEl.nMsg = GM_DUIGETELEMENT;

                if (pSC->hgadSet)
                {
                    gmsgGetEl.hgadMsg = pSC->hgadSet;

                    DUserSendEvent(&gmsgGetEl, false);
                    peSet = gmsgGetEl.pe;
                }
        
                if (pSC->hgadLost)
                {
                    gmsgGetEl.hgadMsg = pSC->hgadLost;

                    DUserSendEvent(&gmsgGetEl, false);
                    peLost = gmsgGetEl.pe;
                }

                // Handle by input type
                switch (pSC->nCode)
                {
                case GSTATE_KEYBOARDFOCUS:  // Track focus, map to Focused read-only property

                    // Set keyboard focus state only on direct messages (will be inherited)
                    if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    {
                        if (pSC->nCmd == GSC_SET)
                        {
                            // Gaining focus
                            // State change may be as a result of SetKeyFocus (which sets the Keyboard focus
                            // property resulting in a call to SetGadgetFocus, resulting in the state change) or it may
                            // come from DUser. This property may already be set, if so, it's ignored
                            DUIAssert(pe == peSet, "Incorrect keyboard focus state");
                            if (!pe->GetKeyFocused())
                                pe->_SetValue(KeyFocusedProp, PI_Local, Value::pvBoolTrue);  // Came from system, update property
                            pe->EnsureVisible();
                        }
                        else
                        {
                            // Losing focus
                            DUIAssert(pe->GetKeyFocused() && (pe == peLost), "Incorrect keyboard focus state");
                            pe->_RemoveLocalValue(KeyFocusedProp);
                        }
                    }
                    else if (pSC->nCmd == GSC_LOST)
                    {
                        // Eat the lost part of this chain once we've hit a common ancestor -- 
                        // from this common ancestor up, we will only react to the set part of this chain;
                        // this will remove the duplicate notifications that occur from the common ancestor
                        // up otherwise
                        //
                        // We are eating the lost, not the set, because the lost happens first, and the ancestors
                        // should be told after the both the lost chain and set chain has run up from below them
                        //
                        // We only have to check set because we are receiving the lost, hence, we know peLost
                        // is a descendent
                        if (pe->GetImmediateChild(peSet))
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }

                    // Fire system event (direct and bubble)
                    pe->OnKeyFocusMoved(peLost, peSet);

                    nRes = DU_S_PARTIAL;
                    break;

                case GSTATE_MOUSEFOCUS:

                    // Set keyboard focus state only on direct messages (will be inherited)
                    if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    {
                        // Set mouse focus state (will be inherited)
                        if (pSC->nCmd == GSC_SET)
                        {
                            DUIAssert(!pe->GetMouseFocused() && (pe == peSet), "Incorrect mouse focus state");
                            pe->_SetValue(MouseFocusedProp, PI_Local, Value::pvBoolTrue);
                        }
                        else
                        {
                            DUIAssert(pe->GetMouseFocused() && (pe == peLost), "Incorrect mouse focus state");
                            pe->_RemoveLocalValue(MouseFocusedProp);
                        }
                    }
                    else if (pSC->nCmd == GSC_LOST)
                    {
                        // See comments for key focus
                        if (pe->GetImmediateChild(peSet))
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }

                    // Fire system event
                    pe->OnMouseFocusMoved(peLost, peSet);

                    nRes = DU_S_PARTIAL;
                    break;
                }
            }
            break;

        case GM_INPUT:  // User input
            {
                // Full message
                GMSG_INPUT* pInput = (GMSG_INPUT*)pGMsg;

                // This is a bubbled message, gadgets that receive it might not be the target (find it)
                Element* peTarget;

                if (GET_EVENT_DEST(pGMsg) == GMF_DIRECT)  // in Direct stage
                    peTarget = pe;
                else
                    peTarget = ElementFromGadget(pInput->hgadMsg);  // Query gadget for Element this message is about (target)

                // Map to an input event and call OnInput
                switch (pInput->nDevice)
                {
                case GINPUT_MOUSE:  // Mouse message
                    {
                        MouseEvent* pme = NULL;
                        union
                        {
                            MouseEvent      me;
                            MouseDragEvent  mde;
                            MouseClickEvent mce;
                            MouseWheelEvent mwe;
                        };

                        switch (pInput->nCode)
                        {
                        case GMOUSE_DRAG:
                            {
                                GMSG_MOUSEDRAG* pMouseDrag = (GMSG_MOUSEDRAG*) pInput;
                                mde.sizeDelta = pMouseDrag->sizeDelta;
                                mde.fWithin = pMouseDrag->fWithin;
                                pme = &mde;
                            }
                            break;

                        case GMOUSE_WHEEL:
                            mwe.sWheel = ((GMSG_MOUSEWHEEL*) pInput)->sWheel;
                            pme = &mwe;
                            break;

                        case GMOUSE_UP:
                        case GMOUSE_DOWN:
                            mce.cClicks = ((GMSG_MOUSECLICK*) pInput)->cClicks;
                            pme = &mce;
                            break;

                        default:
                            pme = &me;
                            break;
                        }

                        GMSG_MOUSE* pMouse = (GMSG_MOUSE*) pInput;

                        pme->peTarget = peTarget;
                        pme->fHandled = false;
                        pme->nStage = GET_EVENT_DEST(pMouse);
                        pme->nDevice = pMouse->nDevice;
                        pme->nCode = pMouse->nCode;
                        pme->ptClientPxl = pMouse->ptClientPxl;
                        pme->bButton = pMouse->bButton;
                        pme->nFlags = pMouse->nFlags;
                        pme->uModifiers = pMouse->nModifiers;

                        // Fire system event
                        pe->OnInput(pme);

                        if (pme->fHandled)
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }
                    break;

                case GINPUT_KEYBOARD:  // Keyboard message
                    {
                        GMSG_KEYBOARD* pKbd = (GMSG_KEYBOARD*)pGMsg;

                        KeyboardEvent ke;
                        ke.peTarget = peTarget;
                        ke.fHandled = false;
                        ke.nStage = GET_EVENT_DEST(pKbd);
                        ke.nDevice = pKbd->nDevice;
                        ke.nCode = pKbd->nCode;
                        ke.ch = pKbd->ch;
                        ke.cRep = pKbd->cRep;
                        ke.wFlags = pKbd->wFlags;
                        ke.uModifiers = pKbd->nModifiers;

                        // Fire system event
                        pe->OnInput(&ke);

                        if (ke.fHandled)
                        {
                            nRes = DU_S_COMPLETE;
                            break;
                        }
                    }
                    break;
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY* pQ = (GMSG_QUERY*)pGMsg;
                switch (pQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC* pQD = (GMSG_QUERYDESC*)pGMsg;

                        // Name
                        Value* pv = pe->GetValue(ContentProp, PI_Specified);
                        WCHAR szContent[128];

                        if (pe->GetID())
                        {
                            WCHAR szID[128];
                            szID[0] = NULL;

                            GetAtomNameW(pe->GetID(), szID, DUIARRAYSIZE(szID));
                            _snwprintf(pQD->szName, DUIARRAYSIZE(pQD->szName), L"[%s] %s", szID, pv->ToString(szContent, DUIARRAYSIZE(szContent)));
                            *(pQD->szName + (DUIARRAYSIZE(pQD->szName) - 1)) = NULL;
                        }
                        else
                        {
                            pv->ToString(pQD->szName, DUIARRAYSIZE(pQD->szName));
                        }

                        pv->Release();

                        // Type
                        wcsncpy(pQD->szType, pe->GetClassInfo()->GetName(), DUIARRAYSIZE(pQD->szType));
                        *(pQD->szType + (DUIARRAYSIZE(pQD->szType) - 1)) = NULL;

                        nRes = DU_S_COMPLETE;
                    }
                    break;

                case GQUERY_DETAILS:
                    {
                        GMSG_QUERYDETAILS* pQDT = (GMSG_QUERYDETAILS*)pGMsg;
                        if (pQDT->nType == GQDT_HWND)
                            QueryDetails(pe, (HWND)pQDT->hOwner);
                    }
                    break;
                }
            }
            break;

        case GM_DUIEVENT:  // Generic DUI event
            {
                // Possible full message
                GMSG_DUIEVENT* pDUIEv = (GMSG_DUIEVENT*)pGMsg;

                // Set what stage this is (routed, direct, or bubbled)
                pDUIEv->pEvent->nStage = GET_EVENT_DEST(pGMsg);

                // Call handler (target and rest of struct set by FireEvent)
                pe->OnEvent(pDUIEv->pEvent);

                if (pDUIEv->pEvent->fHandled)
                {
                    nRes = DU_S_COMPLETE;
                    break;
                }
            }
            break;

        case GM_DUIGETELEMENT:  // Gadget query for Element pointer
            {
                // Direct message
                DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "Must only be a direct message");

                GMSG_DUIGETELEMENT* pGetEl = (GMSG_DUIGETELEMENT*)pGMsg;
                pGetEl->pe = pe;
            }
            nRes = DU_S_COMPLETE;
            break;

        case GM_DUIACCDEFACTION:  // Async invokation
            // Direct message
            DUIAssert(GET_EVENT_DEST(pGMsg) == GMF_DIRECT, "Must only be a direct message");
            pe->DefaultAction();
            nRes = DU_S_COMPLETE;
            break;

        case GM_DUIASYNCDESTROY:
            // Direct message
            // Do not allow multiple destroys on an Element
            if (!pe->IsDestroyed())
                DeleteHandle(pe->GetDisplayNode());
            nRes = DU_S_COMPLETE;
            break;
        }
    }

#if DBG
    // Check for callback reentrancy
    if (petls)
        petls->cDNCBEnter--;
#endif

    return nRes;
}

HRESULT Element::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = DuiAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

HRESULT Element::DefaultAction()
{
    return S_OK;
}

////////////////////////////////////////////////////////
// Element helpers

Element* ElementFromGadget(HGADGET hGadget)
{
    // Get Element from gadget
    GMSG_DUIGETELEMENT gmsgGetEl;
    ZeroMemory(&gmsgGetEl, sizeof(GMSG_DUIGETELEMENT));

    gmsgGetEl.cbSize = sizeof(GMSG_DUIGETELEMENT);
    gmsgGetEl.nMsg = GM_DUIGETELEMENT;
    gmsgGetEl.hgadMsg = hGadget;

    DUserSendEvent(&gmsgGetEl, false);

    return gmsgGetEl.pe;
}

////////////////////////////////////////////////////////
// Property definitions

// Element's PropertyInfo index values need to be known at compile-time for optimization. These values
// are set automatically for all other Element-derived objects. Set and maintain values manually
// and ensure match with _PIDX_xxx defines. These system-defined properties will be referred to by this value.
// Class and Global index scope are the same for Element

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, NULL, (Value*)&svDefault!!!, _PIDX_MustSet, _PIDX_MustSet };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Parent property
static int vvParent[] = { DUIV_ELEMENTREF, -1 };
static PropertyInfo impParentProp = { L"Parent", PF_LocalOnly|PF_ReadOnly, PG_AffectsDesiredSize|PG_AffectsLayout, vvParent, NULL, Value::pvElementNull, _PIDX_Parent, _PIDX_Parent };
PropertyInfo* Element::ParentProp = &impParentProp;

// Children property
static int vvChildren[] = { DUIV_ELLIST, -1 };
static PropertyInfo impChildrenProp = { L"Children", PF_Normal|PF_ReadOnly, PG_AffectsDesiredSize|PG_AffectsLayout, vvChildren, NULL, Value::pvElListNull, _PIDX_Children, _PIDX_Children };
PropertyInfo* Element::ChildrenProp = &impChildrenProp;

// Visibile property (Computed value cached)
static int vvVisible[] = { DUIV_BOOL, -1 };
static PropertyInfo impVisibleProp = { L"Visible", PF_TriLevel|PF_Cascade|PF_Inherit, 0, vvVisible, NULL, Value::pvBoolFalse, _PIDX_Visible, _PIDX_Visible };
PropertyInfo* Element::VisibleProp = &impVisibleProp;

// Width property
static int vvWidth[] = { DUIV_INT, -1 }; StaticValue(svDefaultWidth, DUIV_INT, -1);
static PropertyInfo impWidthProp = { L"Width", PF_Normal|PF_Cascade, PG_AffectsDesiredSize, vvWidth, NULL, (Value*)&svDefaultWidth, _PIDX_Width, _PIDX_Width };
PropertyInfo* Element::WidthProp = &impWidthProp;

// Height property
static int vvHeight[] = { DUIV_INT, -1 }; StaticValue(svDefaultHeight, DUIV_INT, -1);
static PropertyInfo impHeightProp = { L"Height", PF_Normal|PF_Cascade, PG_AffectsDesiredSize, vvHeight, NULL, (Value*)&svDefaultHeight, _PIDX_Height, _PIDX_Height };
PropertyInfo* Element::HeightProp = &impHeightProp;

// X property
static int vvX[] = { DUIV_INT, -1 };
static PropertyInfo impXProp = { L"X", PF_Normal, 0, vvX, NULL, Value::pvIntZero, _PIDX_X, _PIDX_X };
PropertyInfo* Element::XProp = &impXProp;

// Y property
static int vvY[] = { DUIV_INT, -1 };
static PropertyInfo impYProp = { L"Y", PF_Normal, 0, vvY, NULL, Value::pvIntZero, _PIDX_Y, _PIDX_Y };
PropertyInfo* Element::YProp = &impYProp;

// Location property
static int vvLocation[] = { DUIV_POINT, -1 };
static PropertyInfo impLocationProp = { L"Location", PF_LocalOnly|PF_ReadOnly, PG_AffectsBounds, vvLocation, NULL, Value::pvPointZero, _PIDX_Location, _PIDX_Location };
PropertyInfo* Element::LocationProp = &impLocationProp;

// Extent property
static int vvExtent[] = { DUIV_SIZE, -1 };
static PropertyInfo impExtentProp = { L"Extent", PF_LocalOnly|PF_ReadOnly, PG_AffectsLayout|PG_AffectsBounds, vvExtent, NULL, Value::pvSizeZero, _PIDX_Extent, _PIDX_Extent };
PropertyInfo* Element::ExtentProp = &impExtentProp;

// PosInLayout property
static int vvPosInLayout[] = { DUIV_POINT, -1 };
static PropertyInfo impPosInLayoutProp = { L"PosInLayout", PF_LocalOnly|PF_ReadOnly, 0, vvPosInLayout, NULL, Value::pvPointZero, _PIDX_PosInLayout, _PIDX_PosInLayout };
PropertyInfo* Element::PosInLayoutProp = &impPosInLayoutProp;

// SizeInLayout property
static int vvSizeInLayout[] = { DUIV_SIZE, -1 };
static PropertyInfo impSizeInLayoutProp = { L"SizeInLayout", PF_LocalOnly|PF_ReadOnly, 0, vvSizeInLayout, NULL, Value::pvSizeZero, _PIDX_SizeInLayout, _PIDX_SizeInLayout };
PropertyInfo* Element::SizeInLayoutProp = &impSizeInLayoutProp;

// DesiredSize property
static int vvDesiredSize[] = { DUIV_SIZE, -1 };
static PropertyInfo impDesiredSizeProp = { L"DesiredSize", PF_LocalOnly|PF_ReadOnly, PG_AffectsLayout|PG_AffectsParentLayout, vvDesiredSize, NULL, Value::pvSizeZero, _PIDX_DesiredSize, _PIDX_DesiredSize };
PropertyInfo* Element::DesiredSizeProp = &impDesiredSizeProp;

// LastDSConst property
static int vvLastDSConst[] = { DUIV_INT, -1 };
static PropertyInfo impLastDSConstProp = { L"LastDSConst", PF_LocalOnly|PF_ReadOnly, 0, vvLastDSConst, NULL, Value::pvSizeZero, _PIDX_LastDSConst, _PIDX_LastDSConst };
PropertyInfo* Element::LastDSConstProp = &impLastDSConstProp;

// Layout property
static int vvLayout[] = { DUIV_LAYOUT, -1 };
static PropertyInfo impLayoutProp = { L"Layout", PF_Normal, PG_AffectsDesiredSize|PG_AffectsLayout, vvLayout, NULL, Value::pvLayoutNull, _PIDX_Layout, _PIDX_Layout };
PropertyInfo* Element::LayoutProp = &impLayoutProp;

// LayoutPos property
static int vvLayoutPos[] = { DUIV_INT, -1 };  StaticValue(svDefaultLayoutPos, DUIV_INT, LP_Auto);
static PropertyInfo impLayoutPosProp = { L"LayoutPos", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsParentLayout, vvLayoutPos, NULL, (Value*)&svDefaultLayoutPos, _PIDX_LayoutPos, _PIDX_LayoutPos };
PropertyInfo* Element::LayoutPosProp = &impLayoutPosProp;

// BorderThickness property
static int vvBorderThickness[] = { DUIV_RECT, -1 };
static PropertyInfo impBorderThicknessProp = { L"BorderThickness", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvBorderThickness, NULL, Value::pvRectZero, _PIDX_BorderThickness, _PIDX_BorderThickness };
PropertyInfo* Element::BorderThicknessProp = &impBorderThicknessProp;

// BorderStyle property
static int vvBorderStyle[] = { DUIV_INT, -1 };
static EnumMap emBorderStyle[] = { { L"Solid", BDS_Solid }, { L"Raised", BDS_Raised }, { L"Sunken", BDS_Sunken }, { L"Rounded", BDS_Rounded }, { NULL, 0 } };
static PropertyInfo impBorderStyleProp = { L"BorderStyle", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvBorderStyle, emBorderStyle, Value::pvIntZero, _PIDX_BorderStyle, _PIDX_BorderStyle };
PropertyInfo* Element::BorderStyleProp = &impBorderStyleProp;

// BorderColor property
static int vvBorderColor[] = { DUIV_INT /*Std Color*/, DUIV_FILL, -1 }; StaticValue(svDefaultBorderColor, DUIV_INT, SC_Black);
static PropertyInfo impBorderColorProp = { L"BorderColor", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvBorderColor, NULL, (Value*)&svDefaultBorderColor, _PIDX_BorderColor, _PIDX_BorderColor };
PropertyInfo* Element::BorderColorProp = &impBorderColorProp;

// Padding property
static int vvPadding[] = { DUIV_RECT, -1 };
static PropertyInfo impPaddingProp = { L"Padding", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvPadding, NULL, Value::pvRectZero, _PIDX_Padding, _PIDX_Padding };
PropertyInfo* Element::PaddingProp = &impPaddingProp;

// Margin property
static int vvMargin[] = { DUIV_RECT, -1 };
static PropertyInfo impMarginProp = { L"Margin", PF_Normal|PF_Cascade, PG_AffectsParentDesiredSize|PG_AffectsParentLayout, vvMargin, NULL, Value::pvRectZero, _PIDX_Margin, _PIDX_Margin };
PropertyInfo* Element::MarginProp = &impMarginProp;

// Foreground property
static int vvForeground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 }; StaticValue(svDefaultForeground, DUIV_INT, SC_Black);
static PropertyInfo impForegroundProp = { L"Foreground", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvForeground, NULL, (Value*)&svDefaultForeground, _PIDX_Foreground, _PIDX_Foreground };
PropertyInfo* Element::ForegroundProp = &impForegroundProp;

// Background property
#ifdef GADGET_ENABLE_GDIPLUS                                    
static int vvBackground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 };
static PropertyInfo impBackgroundProp = { L"Background", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvBackground, NULL, Value::pvColorTrans, _PIDX_Background, _PIDX_Background };
#else
static int vvBackground[] = { DUIV_INT /*Std Color*/, DUIV_FILL, DUIV_GRAPHIC, -1 }; StaticValue(svDefaultBackground, DUIV_INT, SC_White);
static PropertyInfo impBackgroundProp = { L"Background", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvBackground, NULL, (Value*)&svDefaultBackground, _PIDX_Background, _PIDX_Background };
#endif // GADGET_ENABLE_GDIPLUS                                    
PropertyInfo* Element::BackgroundProp = &impBackgroundProp;

// Content property
static int vvContent[] = { DUIV_STRING, DUIV_GRAPHIC, DUIV_FILL, -1 };
static PropertyInfo impContentProp = { L"Content", PF_Normal|PF_Cascade, PG_AffectsDesiredSize|PG_AffectsDisplay, vvContent, NULL, Value::pvStringNull, _PIDX_Content, _PIDX_Content };
PropertyInfo* Element::ContentProp = &impContentProp;

// FontFace property
static int vvFontFace[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultFontFace, DUIV_STRING, (void*)L"Arial");
static PropertyInfo impFontFaceProp = { L"FontFace", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontFace, NULL, (Value*)&svDefaultFontFace, _PIDX_FontFace, _PIDX_FontFace };
PropertyInfo* Element::FontFaceProp = &impFontFaceProp;

// FontSize property
static int vvFontSize[] = { DUIV_INT, -1 }; StaticValue(svDefaultFontSize, DUIV_INT, 20);
static PropertyInfo impFontSizeProp = { L"FontSize", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontSize, NULL, (Value*)&svDefaultFontSize, _PIDX_FontSize, _PIDX_FontSize };
PropertyInfo* Element::FontSizeProp = &impFontSizeProp;

// FontWeight property
static int vvFontWeight[] = { DUIV_INT, -1 }; StaticValue(svDefaultFontWeight, DUIV_INT, FW_Normal);
static EnumMap emFontWeight[] = { { L"DontCare", FW_DontCare}, { L"Thin", FW_Thin }, { L"ExtraLight", FW_ExtraLight }, { L"Light", FW_Light }, { L"Normal", FW_Normal }, 
                                  { L"Medium", FW_Medium }, { L"SemiBold", FW_SemiBold }, { L"Bold", FW_Bold }, { L"ExtraBold", FW_ExtraBold }, { L"Heavy", FW_Heavy }, { NULL, 0 } };
static PropertyInfo impFontWeightProp = { L"FontWeight", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDesiredSize|PG_AffectsDisplay, vvFontWeight, emFontWeight, (Value*)&svDefaultFontWeight, _PIDX_FontWeight, _PIDX_FontWeight };
PropertyInfo* Element::FontWeightProp = &impFontWeightProp;

// FontStyle property
static int vvFontStyle[] = { DUIV_INT, -1 };
static EnumMap emFontStyle[] = { { L"None", FS_None }, { L"Italic", FS_Italic }, { L"Underline", FS_Underline }, { L"StrikeOut", FS_StrikeOut }, { L"Shadow", FS_Shadow }, { NULL, 0 } };
static PropertyInfo impFontStyleProp = { L"FontStyle", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvFontStyle, emFontStyle, Value::pvIntZero /*FS_None*/, _PIDX_FontStyle, _PIDX_FontStyle };
PropertyInfo* Element::FontStyleProp = &impFontStyleProp;

// Active property
static int vvActive[] = { DUIV_INT, -1 }; 
static EnumMap emActive[] = { { L"Inactive", AE_Inactive }, { L"Mouse", AE_Mouse }, { L"Keyboard", AE_Keyboard }, { L"MouseAndKeyboard", AE_MouseAndKeyboard }, { NULL, 0 } };
static PropertyInfo impActiveProp = { L"Active", PF_Normal, 0, vvActive, emActive, Value::pvIntZero /*AE_Inactive*/, _PIDX_Active, _PIDX_Active };
PropertyInfo* Element::ActiveProp = &impActiveProp;

// ContentAlign property
static int vvContentAlign[] = { DUIV_INT, -1 };
static EnumMap emContentAlign[] = { { L"TopLeft", CA_TopLeft }, { L"TopCenter", CA_TopCenter }, { L"TopRight", CA_TopRight },
                                    { L"MiddleLeft", CA_MiddleLeft }, { L"MiddleCenter", CA_MiddleCenter }, { L"MiddleRight", CA_MiddleRight }, 
                                    { L"BottomLeft", CA_BottomLeft }, { L"BottomCenter", CA_BottomCenter }, { L"BottomRight", CA_BottomRight },
                                    { L"WrapLeft", CA_WrapLeft }, { L"WrapCenter", CA_WrapCenter }, { L"WrapRight", CA_WrapRight },
                                    { L"EndEllipsis", CA_EndEllipsis }, { L"FocusRect", CA_FocusRect }, { NULL, 0 } };
#ifdef GADGET_ENABLE_GDIPLUS                                    
static PropertyInfo impContentAlignProp = { L"ContentAlign", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvContentAlign, emContentAlign, Value::pvIntZero /*CA_TopLeft*/, _PIDX_ContentAlign, _PIDX_ContentAlign };
#else
static PropertyInfo impContentAlignProp = { L"ContentAlign", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsDisplay, vvContentAlign, emContentAlign, Value::pvIntZero /*CA_TopLeft*/, _PIDX_ContentAlign, _PIDX_ContentAlign };
#endif // GADGET_ENABLE_GDIPLUS                                    
PropertyInfo* Element::ContentAlignProp = &impContentAlignProp;

// KeyFocused property
static int vvKeyFocused[] = { DUIV_BOOL, -1 };
static PropertyInfo impKeyFocusedProp = { L"KeyFocused", PF_Normal|PF_ReadOnly|PF_Inherit /*Conditional inherit*/, 0, vvKeyFocused, NULL, Value::pvBoolFalse, _PIDX_KeyFocused, _PIDX_KeyFocused };
PropertyInfo* Element::KeyFocusedProp = &impKeyFocusedProp;

// KeyWithin property
static int vvKeyWithin[] = { DUIV_BOOL, -1 };
static PropertyInfo impKeyWithinProp = { L"KeyWithin", PF_LocalOnly|PF_ReadOnly, 0, vvKeyWithin, NULL, Value::pvBoolFalse, _PIDX_KeyWithin, _PIDX_KeyWithin };
PropertyInfo* Element::KeyWithinProp = &impKeyWithinProp;

// MouseFocused property
static int vvMouseFocused[] = { DUIV_BOOL, -1 }; 
static PropertyInfo impMouseFocusedProp = { L"MouseFocused", PF_Normal|PF_ReadOnly|PF_Inherit /*Conditional inherit*/, 0, vvMouseFocused, NULL, Value::pvBoolFalse, _PIDX_MouseFocused, _PIDX_MouseFocused };
PropertyInfo* Element::MouseFocusedProp = &impMouseFocusedProp;

// MouseWithin property
static int vvMouseWithin[] = { DUIV_BOOL, -1 };
static PropertyInfo impMouseWithinProp = { L"MouseWithin", PF_LocalOnly|PF_ReadOnly, 0, vvMouseWithin, NULL, Value::pvBoolFalse, _PIDX_MouseWithin, _PIDX_MouseWithin };
PropertyInfo* Element::MouseWithinProp = &impMouseWithinProp;

// Class property
static int vvClass[] = { DUIV_STRING, -1 };
static PropertyInfo impClassProp = { L"Class", PF_Normal, 0, vvClass, NULL, Value::pvStringNull, _PIDX_Class, _PIDX_Class };
PropertyInfo* Element::ClassProp = &impClassProp;

// ID property
static int vvID[] = { DUIV_ATOM, -1 };
static PropertyInfo impIDProp = { L"ID", PF_Normal, 0, vvID, NULL, Value::pvAtomZero, _PIDX_ID, _PIDX_ID };
PropertyInfo* Element::IDProp = &impIDProp;

// Sheet property
static int vvSheet[] = { DUIV_SHEET, -1 };
static PropertyInfo impSheetProp = { L"Sheet", PF_Normal|PF_Inherit, 0, vvSheet, NULL, Value::pvSheetNull, _PIDX_Sheet, _PIDX_Sheet };
PropertyInfo* Element::SheetProp = &impSheetProp;

// Selected property
static int vvSelected[] = { DUIV_BOOL, -1 };
static PropertyInfo impSelectedProp = { L"Selected", PF_Normal|PF_Inherit, 0, vvSelected, NULL, Value::pvBoolFalse, _PIDX_Selected, _PIDX_Selected };
PropertyInfo* Element::SelectedProp = &impSelectedProp;

// Alpha property
static int vvAlpha[] = { DUIV_INT, -1 }; StaticValue(svDefaultAlpha, DUIV_INT, 255 /*Opaque*/);
static PropertyInfo impAlphaProp = { L"Alpha", PF_Normal|PF_Cascade, PG_AffectsDisplay, vvAlpha, NULL, (Value*)&svDefaultAlpha, _PIDX_Alpha, _PIDX_Alpha };
PropertyInfo* Element::AlphaProp = &impAlphaProp;

// Animation property
static int vvAnimation[] = { DUIV_INT, -1 };
static EnumMap emAnimation[] = { { L"Linear", ANI_Linear }, { L"Log", ANI_Log }, { L"Exp", ANI_Exp }, { L"S", ANI_S }, 
                                 { L"DelayShort", ANI_DelayShort }, { L"DelayMedium", ANI_DelayMedium }, { L"DelayLong", ANI_DelayLong },
                                 { L"Alpha", ANI_Alpha }, { L"Position", ANI_Position }, { L"Size", ANI_Size }, { L"SizeH", ANI_SizeH }, { L"SizeV", ANI_SizeV }, { L"Rectangle", ANI_Rect }, { L"RectangleH", ANI_RectH }, { L"RectangleV", ANI_RectV }, { L"Scale", ANI_Scale },
                                 { L"VeryFast", ANI_VeryFast }, { L"Fast", ANI_Fast }, { L"MediumFast", ANI_MediumFast }, { L"MediumSlow", ANI_MediumSlow }, { L"Medium", ANI_Medium },
                                 { L"MediumSlow", ANI_MediumSlow }, { L"Slow", ANI_Fast }, { L"VerySlow", ANI_VerySlow }, { NULL, 0 } };
static PropertyInfo impAnimationProp = { L"Animation", PF_Normal|PF_Cascade, 0, vvAnimation, emAnimation, Value::pvIntZero, _PIDX_Animation, _PIDX_Animation };
PropertyInfo* Element::AnimationProp = &impAnimationProp;

// Cursor property
static int vvCursor[] = { DUIV_INT, DUIV_CURSOR, -1 };
static EnumMap emCursor[] = { { L"Arrow", CUR_Arrow }, { L"Hand", CUR_Hand }, { L"Help", CUR_Help }, 
                              { L"No", CUR_No }, { L"Wait", CUR_Wait }, { L"SizeAll", CUR_SizeAll },
                              { L"SizeNESW", CUR_SizeNESW }, { L"SizeNS", CUR_SizeNS }, { L"SizeNWSE", CUR_SizeNWSE },
                              { L"SizeWE", CUR_SizeWE }, { NULL, 0 } };
static PropertyInfo impCursorProp = { L"Cursor", PF_Normal|PF_Inherit|PF_Cascade, 0, vvCursor, emCursor, Value::pvIntZero /*CUR_Arrow*/, _PIDX_Cursor, _PIDX_Cursor };
PropertyInfo* Element::CursorProp = &impCursorProp;

// Direction property
static int vvDirection[] = { DUIV_INT, -1 }; StaticValue(svDefaultDirection, DUIV_INT, 0);
static EnumMap emDirection[] = { { L"LTR", DIRECTION_LTR }, { L"RTL", DIRECTION_RTL } };
static PropertyInfo impDirectionProp = { L"Direction", PF_Normal|PF_Cascade|PF_Inherit, PG_AffectsLayout|PG_AffectsDisplay, vvDirection, emDirection, (Value*)&svDefaultDirection, _PIDX_Direction, _PIDX_Direction };
PropertyInfo* Element::DirectionProp = &impDirectionProp;

// Accessible property
static int vvAccessible[] = { DUIV_BOOL, -1 };
static PropertyInfo impAccessibleProp = { L"Accessible", PF_Normal|PF_Cascade, 0, vvAccessible, NULL, Value::pvBoolFalse, _PIDX_Accessible, _PIDX_Accessible };
PropertyInfo* Element::AccessibleProp = &impAccessibleProp;

// AccRole property
static int vvAccRole[] = { DUIV_INT, -1 };
static PropertyInfo impAccRoleProp = { L"AccRole", PF_Normal|PF_Cascade, 0, vvAccRole, NULL, Value::pvIntZero, _PIDX_AccRole, _PIDX_AccRole };
PropertyInfo* Element::AccRoleProp = &impAccRoleProp;

// AccState property
static int vvAccState[] = { DUIV_INT, -1 };
static PropertyInfo impAccStateProp = { L"AccState", PF_Normal|PF_Cascade, 0, vvAccState, NULL, Value::pvIntZero, _PIDX_AccState, _PIDX_AccState };
PropertyInfo* Element::AccStateProp = &impAccStateProp;

// AccName property
static int vvAccName[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccName, DUIV_STRING, (void*)L"");
static PropertyInfo impAccNameProp = { L"AccName", PF_Normal|PF_Cascade, 0, vvAccName, NULL, (Value*)&svDefaultAccName, _PIDX_AccName, _PIDX_AccName };
PropertyInfo* Element::AccNameProp = &impAccNameProp;

// AccDesc property
static int vvAccDesc[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccDesc, DUIV_STRING, (void*)L"");
static PropertyInfo impAccDescProp = { L"AccDesc", PF_Normal|PF_Cascade, 0, vvAccDesc, NULL, (Value*)&svDefaultAccDesc, _PIDX_AccDesc, _PIDX_AccDesc };
PropertyInfo* Element::AccDescProp = &impAccDescProp;

// AccValue property
static int vvAccValue[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccValue, DUIV_STRING, (void*)L"");
static PropertyInfo impAccValueProp = { L"AccValue", PF_Normal|PF_Cascade, 0, vvAccValue, NULL, (Value*)&svDefaultAccValue, _PIDX_AccValue, _PIDX_AccValue };
PropertyInfo* Element::AccValueProp = &impAccValueProp;

// AccDefAction property
static int vvAccDefAction[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultAccDefAction, DUIV_STRING, (void*)L"");
static PropertyInfo impAccDefActionProp = { L"AccDefAction", PF_Normal|PF_Cascade, 0, vvAccDefAction, NULL, (Value*)&svDefaultAccDefAction, _PIDX_AccDefAction, _PIDX_AccDefAction };
PropertyInfo* Element::AccDefActionProp = &impAccDefActionProp;

// Shortcut property
static int vvShortcut[] = { DUIV_INT, -1 };
static PropertyInfo impShortcutProp = { L"Shortcut", PF_Normal|PF_Cascade, PG_AffectsDesiredSize | PG_AffectsDisplay, vvShortcut, NULL, Value::pvIntZero, _PIDX_Shortcut, _PIDX_Shortcut };
PropertyInfo* Element::ShortcutProp = &impShortcutProp;

// Enabled property
static int vvEnabled[] = { DUIV_BOOL, -1 };
static PropertyInfo impEnabledProp = { L"Enabled", PF_Normal|PF_Cascade|PF_Inherit, 0, vvEnabled, NULL, Value::pvBoolTrue, _PIDX_Enabled, _PIDX_Enabled };
PropertyInfo* Element::EnabledProp = &impEnabledProp;

////////////////////////////////////////////////////////
// ClassInfo

// ClassInfo to name mapping
BTreeLookup<IClassInfo*>* Element::pciMap = NULL;

// Class properties 
static PropertyInfo* _aPI[] = {
                                 Element::ParentProp,            // DS, Layt, Disp
                                 Element::WidthProp,             // DS
                                 Element::HeightProp,            // DS
                                 Element::ChildrenProp,          // DS, Layt, Disp
                                 Element::VisibleProp,           // Disp
                                 Element::LocationProp,          // Disp, Bnds
                                 Element::ExtentProp,            // Layt, Disp, Bnds
                                 Element::XProp,                 //
                                 Element::YProp,                 //
                                 Element::PosInLayoutProp,       //
                                 Element::SizeInLayoutProp,      //
                                 Element::DesiredSizeProp,       // Layt, LaytP, Disp
                                 Element::LastDSConstProp,       //
                                 Element::LayoutProp,            // DS, Layt, Disp
                                 Element::LayoutPosProp,         // DS, LaytP
                                 Element::BorderThicknessProp,   // DS, Disp
                                 Element::BorderStyleProp,       // Disp
                                 Element::BorderColorProp,       // Disp
                                 Element::PaddingProp,           // DS, Disp
                                 Element::MarginProp,            // DS, Layt, Disp
                                 Element::ForegroundProp,        // Disp
                                 Element::BackgroundProp,        // Disp
                                 Element::ContentProp,           // DS, Disp
                                 Element::FontFaceProp,          // DS, Disp
                                 Element::FontSizeProp,          // DS, Disp
                                 Element::FontWeightProp,        // Disp
                                 Element::FontStyleProp,         // Disp
                                 Element::ActiveProp,            //
                                 Element::ContentAlignProp,      // Disp
                                 Element::KeyFocusedProp,        //
                                 Element::KeyWithinProp,         //
                                 Element::MouseFocusedProp,      //
                                 Element::MouseWithinProp,       //
                                 Element::ClassProp,             //
                                 Element::IDProp,                //
                                 Element::SheetProp,             //
                                 Element::SelectedProp,          //
                                 Element::AlphaProp,             // Disp
                                 Element::AnimationProp,         //
                                 Element::CursorProp,            //
                                 Element::DirectionProp,         // Layt, Disp
                                 Element::AccessibleProp,        //
                                 Element::AccRoleProp,           //
                                 Element::AccStateProp,          //
                                 Element::AccNameProp,           //
                                 Element::AccDescProp,           //
                                 Element::AccValueProp,          //
                                 Element::AccDefActionProp,      //
                                 Element::ShortcutProp,          // DS, Disp
                                 Element::EnabledProp,           //
                              };

// Element has a specialized IClassInfo implemention since it has no base class
// and it's properties are manually initialized to known values for optimization.
// All other Element-derived classes use ClassInfo<C,B>
class ElementClassInfo : public IClassInfo
{
public:
    // Registration (cannot unregister -- will be registered until UnInitProcess is called)
    static HRESULT Register(PropertyInfo** ppPI, UINT cPI)
    {
        HRESULT hr;
    
        // If class mapping doesn't exist, registration fails 
        if (!Element::pciMap)
            return E_FAIL;

        // Check for entry in mapping, if exists, ignore registration
        if (!Element::pciMap->GetItem((void*)L"Element"))
        {
            // Never been registered, create class info entry
            hr = Create(ppPI, cPI, &Element::Class);
            if (FAILED(hr))
                return hr;
        
            hr = Element::pciMap->SetItem((void*)L"Element", Element::Class);
            if (FAILED(hr))
                return hr;
        }

        return S_OK;
    }

    static HRESULT Create(PropertyInfo** ppPI, UINT cPI, IClassInfo** ppCI)
    {
        *ppCI = NULL;

        ElementClassInfo* peci = HNew<ElementClassInfo>();
        if (!peci)
            return E_OUTOFMEMORY;

        // Setup state
        peci->_ppPI = ppPI; 
        peci->_cPI = cPI;

        // Setup property ownership
        for (UINT i = 0; i < cPI; i++)
        {
            // Index and global index are manually coded
            ppPI[i]->_pciOwner = peci;
        }

        *ppCI = peci;

        //DUITrace("RegDUIClass[0]: 'Element', %d ClassProps\n", cPI);

        return S_OK;
    }

    void Destroy() { HDelete<ElementClassInfo>(this); }

    HRESULT CreateInstance(OUT Element** ppElement) { return Element::Create(0, ppElement); };
    PropertyInfo* EnumPropertyInfo(UINT nEnum) { return (nEnum < _cPI) ? _ppPI[nEnum] : NULL; }
    UINT GetPICount() { return _cPI; }
    UINT GetGlobalIndex() { return 0; } // Reserved by Element
    IClassInfo* GetBaseClass() { return NULL; }
    LPCWSTR GetName() { return L"Element"; }
    bool IsValidProperty(PropertyInfo* ppi) { return ppi->_pciOwner == this; }
    bool IsSubclassOf(IClassInfo* pci) { return pci == this; }

    ElementClassInfo() { }
    virtual ~ElementClassInfo() { }

private:
    PropertyInfo** _ppPI;
    UINT _cPI;
};

// Process wide zero-based consecutive unique ClassInfo and PropertyInfo counters.
// Element is manually set and reserves class index 0 and property indicies 0 through 
// _PIDX_TOTAL-1. These values are used by ClassInfo<C,B> constructors during process
// initialization (these constructor calls are synchronous).

// Initialized on main thread
UINT g_iGlobalCI = 1;
UINT g_iGlobalPI = _PIDX_TOTAL;

// Define class info with type and base type, init static class pointer
IClassInfo* Element::Class = NULL;

HRESULT Element::Register()
{
    return ElementClassInfo::Register(_aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\host.cpp ===
/*
 * Host
 */

#include "stdafx.h"
#include "core.h"

#include "duihost.h"
#include "duiaccessibility.h"
#include "duibutton.h" // todo:  not needed when we switch to using DoDefaultAction for shortcuts


namespace DirectUI
{

////////////////////////////////////////////////////////
// Native surface hosts

////////////////////////////////////////////////////////
// HWNDElement

// HWNDElements are used to host Elements in HWNDs. An HWND parent is provided at
// creation time. This parent cannot be NULL.

// All Element methods are valid. If the native parent is destroyed (DestroyWindow),
// this Element will be destroyed

// HWNDElement cannot be created via the parser (non-optional first parameter)

// Required for ClassInfo (always fails)
HRESULT HWNDElement::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);

    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");

    return E_NOTIMPL;
}

HRESULT HWNDElement::Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDElement* phe = HNew<HWNDElement>();
    if (!phe)
        return E_OUTOFMEMORY;

    HRESULT hr = phe->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        phe->Destroy();
        return hr;
    }

    *ppElement = phe;

    return S_OK;
}

HRESULT HWNDElement::Initialize(HWND hParent, bool fDblBuffer, UINT nCreate)
{
    HRESULT hr;
    static int RTLOS = -1;

    _hWnd = NULL;
    _hgDisplayNode = NULL;
    _hPal = NULL;
    _wUIState = 0;
    WNDCLASSEXW wcex;
    LRESULT lr = 0;

    // Do base class initialization
    hr = Element::Initialize(nCreate | EC_NoGadgetCreate);  // Will create gadget here
    if (FAILED(hr))
        goto Failed;

    // Register host window class, if needed
    // Winproc will be replaced upon creation
    wcex.cbSize = sizeof(wcex);

    if (!GetClassInfoExW(GetModuleHandleW(NULL), L"DirectUIHWND", &wcex))
    {
        ZeroMemory(&wcex, sizeof(wcex));

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_GLOBALCLASS;
        wcex.hInstance = GetModuleHandleW(NULL);
        wcex.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
        wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wcex.lpszClassName = L"DirectUIHWND";
        wcex.lpfnWndProc = DefWindowProc;
        wcex.cbWndExtra = sizeof(HWNDElement*);

        if (RegisterClassExW(&wcex) == 0)
        {
            hr = DUI_E_USERFAILURE;
            goto Failed;
        }
    }

    // Create HWND
    _hWnd = CreateWindowExW(0, L"DirectUIHWND", NULL, WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                            0, 0, 0, 0, hParent, 0, GetModuleHandleW(NULL), 0);
    if (!_hWnd)
    {
        hr = DUI_E_USERFAILURE;
        goto Failed;
    }

    // Store pointer to the Element in HWND and subclass
    SetWindowLongPtrW(_hWnd, GWLP_WNDPROC, (LONG_PTR)HWNDElement::StaticWndProc);
    SetWindowLongPtrW(_hWnd, 0, (LONG_PTR)this);

    // Inherit keyboard cues UI state from HWND parent
    lr = SendMessageW(hParent, WM_QUERYUISTATE, 0, 0);
    _wUIState = LOWORD(lr);

    // Check if we are running on a Localized or not?
    if (RTLOS == -1)
    {
        LANGID langID = GetUserDefaultUILanguage();

        RTLOS = DIRECTION_LTR;

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            LCID iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's Verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */
            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
                /* Let's Verify the bits we have a BiDi UI locale */
                if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
                    RTLOS = DIRECTION_RTL;
        }
    }

    if (RTLOS == DIRECTION_RTL) 
    {
        SetDirection(DIRECTION_RTL);

        // Turn off mirroring on us.
        SetWindowLongPtrW(_hWnd, GWL_EXSTYLE, GetWindowLongPtrW(_hWnd, GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL);
    }

    // Mirror with Element constructor, however, account for buffering and mouse filtering
    // (must always allow all mouse messages for the root display node)

    _hgDisplayNode = CreateGadget(_hWnd, GC_HWNDHOST, _DisplayNodeCallback, this);
    if (!_hgDisplayNode)
    {
        hr = GetLastError();
        goto Failed;
    }

    SetGadgetMessageFilter(_hgDisplayNode, NULL, 
            GMFI_PAINT|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_CHANGESTATE,
            GMFI_PAINT|GMFI_INPUTMOUSE|GMFI_INPUTMOUSEMOVE|GMFI_CHANGESTATE|GMFI_INPUTKEYBOARD|GMFI_CHANGERECT|GMFI_CHANGESTYLE);

    SetGadgetStyle(_hgDisplayNode, 
            GS_RELATIVE|GS_OPAQUE|((fDblBuffer)?GS_BUFFERED:0),
            GS_RELATIVE|GS_HREDRAW|GS_VREDRAW|GS_VISIBLE|GS_KEYBOARDFOCUS|GS_OPAQUE|GS_BUFFERED);

#ifdef GADGET_ENABLE_GDIPLUS
    //
    // If using GDI+, we want to enable state at the top and use this for the entire tree
    //

    SetGadgetStyle(_hgDisplayNode, GS_DEEPPAINTSTATE, GS_DEEPPAINTSTATE);
#endif

    // Use palette if on palettized device
    if (IsPalette())
    {
        HDC hDC = GetDC(NULL);
        _hPal = CreateHalftonePalette(hDC);
        ReleaseDC(NULL, hDC);

        if (!_hPal)
        {
            hr = DU_E_OUTOFGDIRESOURCES;
            goto Failed;
        }
    }

    ROOT_INFO ri;
    ZeroMemory(&ri, sizeof(ri));

#ifdef GADGET_ENABLE_GDIPLUS
    // Mark as using GDI+ surfaces

    ri.cbSize   = sizeof(ri);
    ri.nMask    = GRIM_SURFACE;
    ri.nSurface = GSURFACE_GPGRAPHICS;

#else // GADGET_ENABLE_GDIPLUS
    // For GDC, need to setup a palette and surface info

    ri.cbSize = sizeof(ri);
    ri.nMask = GRIM_SURFACE | GRIM_PALETTE;
    ri.nSurface = GSURFACE_HDC;
    ri.hpal = _hPal;

#endif // GADGET_ENABLE_GDIPLUS

    SetGadgetRootInfo(_hgDisplayNode, &ri);

    // Manually set native hosted flag
    MarkHosted();

    return S_OK;

Failed:

    if (_hWnd)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }

    if (_hgDisplayNode)
    {
        DeleteHandle(_hgDisplayNode);
        _hgDisplayNode = NULL;
    }

    if (_hPal)
    {
        DeleteObject(_hPal);
        _hPal = NULL;
    }

    return hr;
}

// HWNDElement is about to be destroyed
void HWNDElement::OnDestroy()
{
    // Fire unhosted event
    OnUnHosted(GetRoot());

    // Remove reference to this
    SetWindowLongPtrW(_hWnd, 0, NULL);

    // Cleanup
    if (_hPal)
    {
        DeleteObject(_hPal);
        _hPal = NULL;
    }

    // Call base
    Element::OnDestroy();
}

void HWNDElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    switch (iIndex)
    {
    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Active:
            // HWND Element is always mouse active
            switch (pvNew->GetInt())
            {
            case AE_Inactive:
                SetGadgetMessageFilter(GetDisplayNode(), NULL, 0, GMFI_INPUTKEYBOARD);
                SetGadgetStyle(GetDisplayNode(), 0, GS_KEYBOARDFOCUS);
                break;

            case AE_Keyboard:
            case AE_MouseAndKeyboard:   
                SetGadgetMessageFilter(GetDisplayNode(), NULL, GMFI_INPUTKEYBOARD, GMFI_INPUTKEYBOARD);
                SetGadgetStyle(GetDisplayNode(), GS_KEYBOARDFOCUS, GS_KEYBOARDFOCUS);
                break;
            }
            // No call on base
            return;

        case _PIDX_Alpha:
            // Alpha unsuppored on HWNDElement, No call on base
            return;

        case _PIDX_Visible:
            // Set HWND's visibility, base impl will set gadget visibility
            // Follow specified value, computed will reflect true state
            LONG dStyle = GetWindowLongW(_hWnd, GWL_STYLE);
            if (pvNew->GetBool())
                dStyle |= WS_VISIBLE;
            else
                dStyle &= ~WS_VISIBLE;
            SetWindowLongW(_hWnd, GWL_STYLE, dStyle);
            break;
        }
        break;
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void HWNDElement::OnGroupChanged(int fGroups, bool bLowPri)
{
    if (bLowPri && (fGroups & PG_AffectsBounds))
    {
        // Handle bounds change since will need to use SetWindowPos
        // rather than SetGadgetRect for HWND gadgets
        Value* pvLoc;
        Value* pvExt;

        const POINT* pptLoc = GetLocation(&pvLoc);
        const SIZE* psizeExt = GetExtent(&pvExt);

        SetWindowPos(_hWnd, NULL, pptLoc->x, pptLoc->y, psizeExt->cx, psizeExt->cy, SWP_NOACTIVATE);
        if(_bParentSizeControl)
        {
            HWND hwnd = ::GetParent(_hWnd);
            if(hwnd)
            {
                RECT rect;
                rect.left = pptLoc->x;
                rect.top = pptLoc->y;
                rect.right = psizeExt->cx + pptLoc->x;
                rect.bottom = psizeExt->cy + pptLoc->y;
                
                LONG Style = GetWindowLong(hwnd, GWL_STYLE);
                LONG ExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
                AdjustWindowRectEx(&rect, Style, FALSE, ExStyle);
                int iWindowWidth = rect.right - rect.left;
                int iWindowHeight = rect.bottom - rect.top;

                if(_bScreenCenter)
                {
                    rect.left = (GetSystemMetrics(SM_CXSCREEN) - iWindowWidth) /2;
                    rect.top = (GetSystemMetrics(SM_CYSCREEN) - iWindowHeight) /2;                
                }
            
                SetWindowPos(hwnd, NULL, rect.left, rect.top, iWindowWidth, iWindowHeight, SWP_NOACTIVATE);
            }

        }

        pvLoc->Release();
        pvExt->Release();

        // Clear affects bounds group so base doesn't do set bounds
        fGroups &= ~PG_AffectsBounds;
    }

    // Call base
    Element::OnGroupChanged(fGroups, bLowPri);
}

HRESULT HWNDElement::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    HRESULT hr = S_OK;

    //
    // Initialize and validate the out parameter(s).
    //
    if (ppAccessible != NULL) {
        *ppAccessible = NULL;
    } else {
        return E_INVALIDARG;
    }

    //
    // If this element is not marked as accessible, refuse to give out its
    // IAccessible implementation!
    //
    if (GetAccessible() == false) {
        return E_FAIL;
    }

    //
    // Create an accessibility implementation connected to this element if we
    // haven't done so already.
    //
    if (_pDuiAccessible == NULL) {
        hr = HWNDElementAccessible::Create(this, &_pDuiAccessible);
        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    // Ask the existing accessibility implementation for a pointer to the
    // actual IAccessible interface.
    //
    hr = _pDuiAccessible->QueryInterface(__uuidof(IAccessible), (LPVOID*)ppAccessible);
    if (FAILED(hr)) {
        return hr;
    }

    DUIAssert(SUCCEEDED(hr) && _pDuiAccessible != NULL && *ppAccessible != NULL, "Accessibility is broken!");
    return hr;
}

void HWNDElement::ShowUIState(bool fUpdateAccel, bool fUpdateFocus)
{
    WORD wFlags = 0;
    
    // Setup "hide" bits to clear
    if (fUpdateAccel)
        wFlags |= UISF_HIDEACCEL;
    if (fUpdateFocus)
        wFlags |= UISF_HIDEFOCUS;

    // If the bits to be cleared are already 0, ignore
    // Otherwise, notify change
    if ((GetUIState() & wFlags) != 0)
    {
        SendMessageW(GetHWND(), WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, wFlags), 0);
    }
}

// algorithm
// 1) start from the root
// 2) find the first element with this shortcut, and save it
// 3) continue search for all other elements with this shortcut
// 4) if another element is found, set the multiple flag
// 5) if an element is found that has keyboard focus, then we want to choose the next one
//    found to match after that, so set the use next flag
// 6) bail when end of tree is hit, or when a match is found and the next flag is set
// 
BOOL FindShortcut(WCHAR ch, Element* pe, Element** ppeFound, BOOL* pfMultiple, BOOL* pfUseNext)
{
    WCHAR wcShortcut = (WCHAR) pe->GetShortcut();
    if (wcShortcut)
    {
        if ((wcShortcut >= 'a') && (wcShortcut <= 'z'))
            wcShortcut -= 32;
        
        // if it has focus, skip it.
        if (wcShortcut == ch)
        {
            Element* peFound = pe;
            while (peFound && !(peFound->GetActive() & AE_Keyboard))
                peFound = peFound->GetParent();
            if (!peFound)
            {
                peFound = pe->GetParent();
                if (peFound)
                    peFound = peFound->GetAdjacent(pe, NAVDIR_NEXT, NULL, true);
            }
            if (peFound && (peFound != *ppeFound))
            {
                if (*ppeFound)
                    *pfMultiple = TRUE;
                else
                    // only save the first one
                    *ppeFound = peFound;

                if (*pfUseNext)
                {
                    // keyboard focus was on last match, so treat this one as the match
                    *ppeFound = peFound;
                    return TRUE;
                }

                *pfUseNext = peFound->GetKeyFocused();
            }
        }
    }
    
    Value* pv;
    ElementList* peList = pe->GetChildren(&pv);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            if (FindShortcut(ch, peList->GetItem(i), ppeFound, pfMultiple, pfUseNext))
            {
                pv->Release();
                return TRUE;
            }
        }
    }
    pv->Release();
    return FALSE;
}

Element* HWNDElement::GetKeyFocusedElement()
{
    HGADGET hgad = GetGadgetFocus();
    if (!hgad)
        return NULL;

    return ElementFromGadget(hgad);  // Query gadget for Element this message is about (target)
}

void HWNDElement::OnEvent(Event* pEvent)
{
    if ((pEvent->nStage == GMF_BUBBLED) || (pEvent->nStage == GMF_DIRECT))
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            Element::OnEvent(pEvent);
            if (!pEvent->fHandled && GetWrapKeyboardNavigate())
            {
                KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*) pEvent;

                if ((pkne->iNavDir & NAV_LOGICAL) && (pkne->iNavDir & NAV_RELATIVE))
                {
                    Element* peSave = pEvent->peTarget;
                    pEvent->peTarget = NULL;
                    Element::OnEvent(pEvent);
                    pEvent->peTarget = peSave;
                }
            }
            return;
        }
    }
    else if (pEvent->nStage == GMF_ROUTED)
    {
        if (pEvent->uidType == Element::KeyboardNavigate)
        {
            // A keyboard navigate is happening within the tree, active focus cues
            ShowUIState(false, true);
        }
    }

    Element::OnEvent(pEvent);
}

void HWNDElement::OnInput(InputEvent* pie)
{
    if ((pie->nDevice == GINPUT_KEYBOARD) && (pie->nStage == GMF_ROUTED) && (pie->uModifiers & GMODIFIER_ALT) && (pie->nCode == GKEY_SYSCHAR))
    {
         WCHAR ch = (WCHAR) ((KeyboardEvent*)pie)->ch;
         if (ch > ' ')
         {
             if ((ch >= 'a') && (ch <= 'z'))
                 ch -= 32;

             Element* peFound = NULL;
             BOOL fMultipleFound = FALSE;
             BOOL fUseNext = FALSE;
             FindShortcut(ch, this, &peFound, &fMultipleFound, &fUseNext);
             if (peFound)
             {
                 // todo: there is one outstanding issue here -- selector, on setting key focus, will 
                 // select that item -- we need a way where, if fMultipleFound, we give it focus without
                 // giving is selection.  But removing that behavior from selector wrecks all other uses of 
                 // selector when clicking in it or keying to it will give focus and select, as expected
                 peFound->SetKeyFocus();
                 // todo:  when we have DoDefaultAction working, change the following conditional and code to:
                 //  if (!fMultipleFound)
                 //      peFound->DoDefaultAction();
                 if (!fMultipleFound && peFound->GetClassInfo()->IsSubclassOf(Button::Class))
                 {
                     // make a click happen
                     ButtonClickEvent bce;
                     bce.uidType = Button::Click;
                     bce.nCount = 1;
                     bce.uModifiers = 0;
                     bce.pt.x = 0;
                     bce.pt.y = 0;

                     peFound->FireEvent(&bce);  // Will route and bubble
                 }
                     
                     
                 pie->fHandled = true;
                 return;
             }
         }
    }
    Element::OnInput(pie);
}


Element* HWNDElement::ElementFromPoint(POINT* ppt)
{
    DUIAssert(ppt, "Invalid parameter: NULL\n");

    Element* pe = NULL;

    HGADGET hgad = FindGadgetFromPoint(GetDisplayNode(), *ppt, GS_VISIBLE | GS_ENABLED, NULL);

    if (hgad) // Get Element from gadget
        pe = ElementFromGadget(hgad);

    return pe;        
}

// Async flush working set
void HWNDElement::FlushWorkingSet()
{
    if (_hWnd)
    {
        PostMessage(_hWnd, HWEM_FLUSHWORKINGSET, 0, 0);
    }
}

LRESULT CALLBACK HWNDElement::StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Get context
    HWNDElement* phe = (HWNDElement*)GetWindowLongPtrW(hWnd, 0);
    if (!phe)
        return DefWindowProcW(hWnd, uMsg, wParam, lParam);

    return phe->WndProc(hWnd, uMsg, wParam, lParam);
}



// note, keep same order as enums from Element.w
// CUR_Arrow, CUR_Hand, CUR_Help, CUR_No, CUR_Wait, CUR_SizeAll, CUR_SizeNESW, CUR_SizeNS, CUR_SizeNWSE, CUR_SizeWE
static LPSTR lprCursorMap[] = { IDC_ARROW, IDC_HAND, IDC_HELP, IDC_NO, IDC_WAIT, IDC_SIZEALL, IDC_SIZENESW, IDC_SIZENS, IDC_SIZENWSE, IDC_SIZEWE };

LRESULT HWNDElement::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SETCURSOR:
        {
            // Get position at time of message (convert to HWNDElement coordinates)
            DWORD dwPos = GetMessagePos();
            POINT ptCur = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
            ScreenToClient(hWnd, &ptCur);

            // Locate Element
            Element* pe = ElementFromPoint(&ptCur);
            if (pe)
            {
                if (!pe->IsDefaultCursor())
                {
                    // Not using default cursor (arrow)
                    HCURSOR hCursor = NULL;

                    Value* pvCursor = pe->GetValue(CursorProp, PI_Specified);

                    if (pvCursor->GetType() == DUIV_INT)
                    {
                        int iCursor = pvCursor->GetInt();
                        // this check isn't necessary if he validates against the enums when setting
                        if ((iCursor >= 0) && (iCursor < CUR_Total))
                            hCursor = LoadCursorW(NULL, MAKEINTRESOURCEW(lprCursorMap[iCursor]));
                        else
                            hCursor = pvCursor->GetCursor()->hCursor;
                    }
                    else
                    {
                        DUIAssert(pvCursor->GetType() == DUIV_CURSOR, "Expecting Cursor type");

                        hCursor = pvCursor->GetCursor()->hCursor;
                    }

                    pvCursor->Release();

                    if (hCursor)
                        ::SetCursor(hCursor);

                    return TRUE;
                }
            }
        }
        break;  // Use default cursor (arrow)

    case WM_PALETTECHANGED:
        {
            if (_hPal && (HWND)wParam == hWnd)
                break;
        }
        // Fall through

    case WM_QUERYNEWPALETTE:
        {
            if (_hPal)
            {
                HDC hDC = GetDC(hWnd);

                HPALETTE hOldPal = SelectPalette(hDC, _hPal, FALSE);
                UINT iMapped = RealizePalette(hDC);

                SelectPalette(hDC, hOldPal, TRUE);
                RealizePalette(hDC);

                ReleaseDC(hWnd, hDC);

                if (iMapped)
                    InvalidateRect(hWnd, NULL, TRUE);

                return iMapped;
            }
        }
        break;

    case WM_DISPLAYCHANGE:
        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case HWEM_FLUSHWORKINGSET:
        // Flush working set
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1);
        return 0;

    case WM_UPDATEUISTATE:
        {
            // State of keyboard cues have changed

            // Cache new value
            WORD wOldUIState = _wUIState;
            switch (LOWORD(wParam))
            {
                case UIS_SET:
                    _wUIState |= HIWORD(wParam);
                    break;

                case UIS_CLEAR:
                    _wUIState &= ~(HIWORD(wParam));
                    break;
            }

            if (wOldUIState != _wUIState)
            {
                // Refresh tree
                InvalidateGadget(GetDisplayNode());
            }
        }
        break;

    case WM_SYSCHAR:
        // to prevent the beep that you get from doing Alt+char when you don't have a menu or menu item with that
        // mnemonic -- I need to think this one through -- jeffbog
        if (wParam != ' ')
            return 0;
        break;

    case WM_CONTEXTMENU:
        // Default processing (DefWindowProc) of this message is to pass it to the parent.
        // Since controls will create and fire a context menu events as a result of keyboard
        // and mouse input, this message should not be passed to the parent.
        // However, if the message originated on a child HWND (Adaptors, which are outside
        // the DirectUI world), allow it to be passed to parent.
        if ((HWND)wParam == hWnd)
            return 0;
        break;

    case WM_GETOBJECT:
        {
            LRESULT lResult = 0;

            //
            // Make sure COM has been initialized on this thread!
            //
            ElTls * pet = (ElTls*) TlsGetValue(g_dwElSlot);
            DUIAssert(pet != NULL, "This is not a DUI thread!");
            if (pet == NULL) {
                return 0;
            }
            if (pet->fCoInitialized == false) {
                CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
                pet->fCoInitialized = true;
            }

            if (((DWORD)lParam) == OBJID_CLIENT) {
                //
                // The object ID is refering to ourselves.  Since we are
                // actually an HWND, the system would normally provide
                // the IAccessible implementation.  However, we need to
                // do some special stuff, so we have to return our own
                // implementation.
                //
                IAccessible * pAccessible = NULL;
                HRESULT hr =  GetAccessibleImpl(&pAccessible);
                if (SUCCEEDED(hr)) {
                    lResult = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                    pAccessible->Release();
                }
            } else if (((long)lParam) > 0 ) {
                //
                // The object ID is one of our internal ticket identifiers.
                // Decode the element that the caller wants an IAccessible
                // interface for.  Then return a peer implementation of
                // IAccessible that is connected to the specified element.
                //
                HGADGET hgad = LookupGadgetTicket((DWORD)lParam);
                if (hgad != NULL) {
                    Element * pe = ElementFromGadget(hgad);
                    if (pe != NULL) {
                        IAccessible * pAccessible = NULL;
                        HRESULT hr =  pe->GetAccessibleImpl(&pAccessible);
                        if (SUCCEEDED(hr)) {
                            lResult = LresultFromObject(__uuidof(IAccessible), wParam, pAccessible);
                            pAccessible->Release();
                        }
                    }
                }
            } else {
                //
                // This is one of the "standard" object identifiers, such as:
                //
                // OBJID_ALERT 
                // OBJID_CARET 
                // OBJID_CLIENT 
                // OBJID_CURSOR 
                // OBJID_HSCROLL 
                // OBJID_MENU 
                // OBJID_SIZEGRIP 
                // OBJID_SOUND 
                // OBJID_SYSMENU 
                // OBJID_TITLEBAR 
                // OBJID_VSCROLL 
                //
                // None of these are supported on an HWNDElement.
                //
            }


            return lResult;
        }
    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}

// WrapKeyboardNavigate property
static int vvWrapKeyboardNavigate[] = { DUIV_BOOL, -1 };
static PropertyInfo impWrapKeyboardNavigateProp = { L"WrapKeyboardNavigate", PF_Normal, 0, vvWrapKeyboardNavigate, NULL, Value::pvBoolTrue };
PropertyInfo* HWNDElement::WrapKeyboardNavigateProp = &impWrapKeyboardNavigateProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                HWNDElement::WrapKeyboardNavigateProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDElement::Class = NULL;

HRESULT HWNDElement::Register()
{
    return ClassInfo<HWNDElement,Element>::Register(L"HWNDElement", _aPI, DUIARRAYSIZE(_aPI));
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\navigation.cpp ===
/*
 * Spatial navigation support
 */

#include "stdafx.h"
#include "core.h"

#include "DUIError.h"
#include "DUIElement.h"
#include "DUINavigation.h"

LONG ScoreConsideredElement(RECT * prcFrom,
                            DirectUI::Element * peFrom,
                            DirectUI::Element * peConsider,
                            int nNavDir)
{
    if (peConsider == NULL) {
        return -1;
    }

    //
    // Get the coordinates of the element being considered and map them into
    // coordinates relative to the element we are navigating from.
    //
    // TODO: This won't work well with rotated gadgets.  Either use a
    // bounding box, or support true intersections.
    //
    RECT rcConsider;
    GetGadgetRect(peConsider->GetDisplayNode(), &rcConsider, SGR_CLIENT);
    MapGadgetPoints(peConsider->GetDisplayNode(), peFrom->GetDisplayNode(), (POINT*)&rcConsider, 2);

    //
    // Do not consider elements who don't intersect the region formed by
    // extending our paralell extents.  If going left or right, extend our
    // top and bottom boundaries horizontally.  An element must intersect
    // that area to be considered.  Do a symetric calculation for up and down.
    //
    switch (nNavDir) {
    case NAV_LEFT:
    case NAV_RIGHT:
        if (rcConsider.bottom < prcFrom->top ||
            rcConsider.top > prcFrom->bottom) {
            return -1;
        }
        break;

    case NAV_UP:
    case NAV_DOWN:
        if (rcConsider.right < prcFrom->left ||
            rcConsider.left > prcFrom->right) {
            return -1;
        }
        break;
    }

    //
    // Do not consider elements that either overlap us or are "behind"
    // us relative to the direction we are navigating.  In other words,
    // do not consider an element unless it is completely in the
    // direction we are navigating.
    //
    //
    switch (nNavDir) {
    case NAV_LEFT:
        if (rcConsider.right > prcFrom->left) {
            return -1;
        }
        break;

    case NAV_RIGHT:
        if (rcConsider.left < prcFrom->right) {
            return -1;
        }
        break;

    case NAV_UP:
        if (rcConsider.bottom > prcFrom->top) {
            return -1;
        }
        break;

    case NAV_DOWN:
        if (rcConsider.top < prcFrom->bottom) {
            return -1;
        }
        break;
    }

    //
    // Finally!  This is an element we should consider.  Assign it a score
    // based on how close it is to us.  Smaller is better, 0 is best, negative
    // scores are invalid.
    //
    switch (nNavDir) {
    case NAV_LEFT:
        return prcFrom->left - rcConsider.right;

    case NAV_RIGHT:
        return rcConsider.left - prcFrom->right;

    case NAV_UP:
        return prcFrom->top - rcConsider.bottom;

    case NAV_DOWN:
        return rcConsider.top - prcFrom->bottom;
    }
    
    return -1;
}

namespace DirectUI
{

//
// The standard algorithm for spatial navigation.
//
// This is not the final algorithm, but a quick starting point.  Initially,
// we only support the 4 primary directions LEFT, UP, RIGHT, and DOWN.
//
// Simply choose the element with the closest opposite edge in the
// direction specified.  Only consider elements that intersets the
// paralell dimensions of the starting element.
//
// For example, if going RIGHT look for an element with a LEFT edge nearest
// to us.
//
// Confused?  Don't worry, its gonna change.
//
Element * DuiNavigate::Navigate(Element * peFrom, ElementList * pelConsider, int nNavDir)
{
    //
    // Validate the input parameters.
    //
    if (peFrom == NULL || pelConsider == NULL) {
        return NULL;
    }
    if (nNavDir != NAV_LEFT && nNavDir != NAV_UP && nNavDir != NAV_RIGHT && nNavDir != NAV_DOWN) {
        return NULL;
    }

    //
    // Get the dimensions of the element we are navidating from.
    //
    RECT rcFrom;
    GetGadgetRect(peFrom->GetDisplayNode(), &rcFrom, SGR_CLIENT);

    Element * peBestScore = NULL;
    Element * peConsider = NULL;
    LONG lBestScore = -1, lScore = -1;
    UINT i;
    UINT iMax = pelConsider->GetSize();

    //
    // Work through the list of elements that we were told to consider.
    // Assign each of them a score, such that smaller scores are better,
    // a score of 0 is best, and negative scores are invalid.  A negative
    // score means that the element should not even be considered an
    // option for navigating in the specified direction.
    //
    for (i = 0; i < iMax; i++) {
        peConsider = pelConsider->GetItem(i);
        lScore = ScoreConsideredElement(&rcFrom, peFrom, peConsider, nNavDir);
        if (lScore >= 0 && (lBestScore < 0 || lScore < lBestScore)) {
            lBestScore = lScore;
            peBestScore = peConsider;
        }
    }

    //
    // Return the element with the best score.
    //
    return peBestScore;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\proxy.cpp ===
/*
 * Proxy
 */

#include "stdafx.h"
#include "core.h"

#include "duiproxy.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Proxy

// Use for synchronous thread-safe cross-thread access

// It is safe to act on Element hierarchies from other threads via a proxy
// that was created in this same thread. The proxy's methods will invoke
// only when all other processing within the thread is complete. Hence,
// access to the callee (the proxy and any Element in the thread) will be
// synchronized and thread-safe. The proxy can provide synchronous or
// asynchronous type calls for the caller.

Proxy::Proxy()
{
    _hgSync = CreateGadget(NULL, GC_MESSAGE, SyncCallback, this);
}

Proxy::~Proxy()
{
    if (_hgSync)
        DeleteHandle(_hgSync);
}

////////////////////////////////////////////////////////
// Caller Invoke

void Proxy::Invoke(UINT nType, void* pData)
{
    // Package proxy message
    GMSG_PROXYINVOKE gmsgPI;
    gmsgPI.cbSize = sizeof(GMSG_PROXYINVOKE);
    gmsgPI.nMsg = GM_PROXYINVOKE;
    gmsgPI.hgadMsg = _hgSync;

    // Initialize custom fields
    gmsgPI.nType = nType;
    gmsgPI.pData = pData;

    // Invoke
    DUserSendEvent(&gmsgPI, 0);  // Direct message
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke (override)

void Proxy::OnInvoke(UINT nType, void* pData)
{
    UNREFERENCED_PARAMETER(nType);
    UNREFERENCED_PARAMETER(pData);
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke

HRESULT Proxy::SyncCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);

    switch (pGMsg->nMsg)
    {
    case GM_PROXYINVOKE:

        // Direct message only
        DUIAssertNoMsg(GET_EVENT_DEST(pGMsg) == GMF_DIRECT);
        
        // Marshalled
        Proxy* pProxy = (Proxy*)pvCur;
        GMSG_PROXYINVOKE* pPI = (GMSG_PROXYINVOKE*)pGMsg;

        // Invoke callback sink
        pProxy->OnInvoke(pPI->nType, pPI->pData);        

        return DU_S_COMPLETE;
    }

    return DU_S_NOTHANDLED;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_CORE_PUBLISHED_H_INCLUDED
#define DUI_CORE_PUBLISHED_H_INCLUDED

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

#endif // DUI_CORE_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\property.cpp ===
/*
 * Property
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duithread.h"
#include "duiaccessibility.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Property system of Element

#if DBG

// GetValue instrumentation class
class GVTrack
{
public:
    // Hash key
    class Key
    {
    public:
        Key() { _ppi = NULL; _iIndex = -1; };
        Key(PropertyInfo* ppi, int iIndex) { _ppi = ppi; _iIndex = iIndex; }
        operator =(Key k) { _ppi = k._ppi; _iIndex = k._iIndex; }
        BOOL operator ==(Key k) { return _ppi == k._ppi && _iIndex == k._iIndex; }
        operator INT_PTR() { return (INT_PTR)_ppi | _iIndex; }

        LPCWSTR GetPIName() { return _ppi->szName; }
        int GetIndex() { return _iIndex; }

    private:
        PropertyInfo* _ppi;
        int _iIndex;
    };

    // Methods
    GVTrack() { ValueMap<Key,int>::Create(3371, &_pvmGetValTrack); _cGV = 0; _cGVUpdateCache = 0; ZeroMemory(_cGVSpecSource, sizeof(_cGVSpecSource)); _fTrack = true; }
    static void GetValueProfileCB(Key k, int cQueries) { DUITrace("GV(%S[%d]): \t\t%d\n", k.GetPIName(), k.GetIndex(), cQueries); }

    void Count(PropertyInfo* ppi, int iIndex, bool fCacheUpdate) 
    {
        if (_fTrack)
        {
            Key k(ppi, iIndex);  
            int* pCount = _pvmGetValTrack->GetItem(k, false);
            int cCount = pCount ? *pCount : 0;
            cCount++;
            _pvmGetValTrack->SetItem(k, cCount, false);

            _cGV++;

            if (fCacheUpdate)
                _cGVUpdateCache++;
        }
    }

    void CountSpecSource(UINT iFrom) { _cGVSpecSource[iFrom]++; }

    void DumpMetrics() { if (_fTrack) { DUITrace(">> Total GV calls: %d, w/updatecache: %d.\nSpecified sources: L:%d, SS:%d, I:%d, D:%d\n", 
        _cGV, _cGVUpdateCache, _cGVSpecSource[0], _cGVSpecSource[1], _cGVSpecSource[2], _cGVSpecSource[3] ); _pvmGetValTrack->Enum(GetValueProfileCB); } }
    void EnableTracking(bool fEnable) { _fTrack = fEnable; }

private:
    ValueMap<Key,int>* _pvmGetValTrack;
    UINT _cGV;
    UINT _cGVUpdateCache;
    UINT _cGVSpecSource[4]; // 0 Local, 1 Style Sheet, 2 Inherted, 3 Default
    bool _fTrack;
};

//GVTrack g_gvt;

// API call count
UINT g_cGetDep = 0;
UINT g_cGetVal = 0;
UINT g_cOnPropChg = 0;

/*
class GVCache
{
public:
    // Hash key
    class Key
    {
    public:
        Key() { _pe = NULL; _ppi = NULL; _iIndex = -1; };
        Key(Element* pe, PropertyInfo* ppi, int iIndex) { _pe = pe; _ppi = ppi; _iIndex = iIndex; }
        operator =(Key k) { _pe = k._pe; _ppi = k._ppi; _iIndex = k._iIndex; }
        BOOL operator ==(Key k) { return _pe == k._pe && _ppi == k._ppi && _iIndex == k._iIndex; }
        operator INT_PTR() { return ((INT_PTR)_pe & 0xFFFF0000) | ((INT_PTR)_ppi & 0xFFFF) | _iIndex; }

    private:
        Element* _pe;
        PropertyInfo* _ppi;
        int _iIndex;
    };

    // Methods
    GVCache() { ValueMap<Key,Value*>::Create(3371, &_pvmCache); }
    static void GVCacheCB(Key k, Value* pv) { k; pv; }

    Value* Read(Key k)
    {
        Value** ppv = _pvmCache->GetItem(k, false);
        if (ppv)
        {
            (*ppv)->AddRef();
            return *ppv;
        }

        return NULL;
    }

    void Write(Key k, Value* pv)
    {
        pv->AddRef();
        _pvmCache->SetItem(k, pv, false);
    }

private:
    ValueMap<Key,Value*>* _pvmCache;
};

GVCache g_gvc;
*/

#endif

// Start defer initiates the defer cycle. Upon reentrancy, simply updates a count and returns
void Element::StartDefer()
{
    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
        return;

    pdc->cEnter++;
}

// EndDefer will return on a reentrancy. The "outter-most" EndDefer will empty the defer table
// queues in priority order. This priority is:
//    Normal Priority Group Property Changes (Affects DS/Layout, Affects Parent DS/Layout)
//    Update Desired Size of Q'ed roots (updates DesiredSize property)
//    Layout of Q'ed roots (invokes _UpdateLayoutSize, _UpdateLayoutPosition)
//    Low Priority Group Property Changes (Bounds, Invalidation)
//
// The outter-most EndDefer will happen outside any OnPropertyChange notification
void Element::EndDefer()
{
    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
        return;

    DUIAssert(pdc->cEnter, "Mismatched StartDefer and EndDefer");
    DUIAssert(pdc->cEnter == 1 ? !pdc->fFiring : true, "Mismatched StartDefer and EndDefer");

    // Outter most defer call, fire all events
    if (pdc->cEnter == 1)
    {
#if DBG
        //g_gvt.DumpMetrics();
        //g_gvt.EnableTracking(false);
#endif

        pdc->fFiring = true;

        // Complete defer cycle
        bool fDone = false;
        while (!fDone)
        {
            // Fire group changed notifications
            if (pdc->iGCPtr + 1 < (int)pdc->pdaGC->GetSize())
            {
                pdc->iGCPtr++;

                // Null Element means it has been deleted with pending group notifications
                GCRecord* pgcr = pdc->pdaGC->GetItemPtr(pdc->iGCPtr);
                if (pgcr->pe)
                {
                    pgcr->pe->_iGCSlot = -1;  // No pending group changes

                    // Fire
                    pgcr->pe->OnGroupChanged(pgcr->fGroups, false);
                }
            }
            else
            {
                // Check for trees needing desired size updated
                Element** ppe = pdc->pvmUpdateDSRoot->GetFirstKey();
                if (ppe)
                {
                    //DUITrace("Updating Desired Size: Root<%x>\n", *ppe);

                    //StartBlockTimer();

                    _FlushDS(*ppe, pdc);

                    pdc->pvmUpdateDSRoot->Remove(*ppe, false, true);

                    //StopBlockTimer();
                    //TCHAR buf[81];
                    //_stprintf(buf, L"UpdateDS time: %dms\n", BlockTime());
                    // OutputDebugStringW(buf);

                    //DUITrace("Update Desired Size complete.\n");
                }
                else
                {
                    ppe = pdc->pvmLayoutRoot->GetFirstKey();
                    if (ppe)
                    {
                        //DUITrace("Laying out: Root<%x>\n", *ppe);

                        //StartBlockTimer();

                        _FlushLayout(*ppe, pdc);

                        pdc->pvmLayoutRoot->Remove(*ppe, false, true);

                        //StopBlockTimer();
                        // TCHAR buf[81];
                        //_stprintf(buf, L"  Layout time: %dms\n", BlockTime());
                        // OutputDebugStringW(buf);

                        //DUITrace("Layout complete.\n");
                    }
                    else
                    {
                        // Fire group changed notifications
                        if (pdc->iGCLPPtr + 1 < (int)pdc->pdaGCLP->GetSize())
                        {
                            pdc->iGCLPPtr++;

                            // Null Element means it has been deleted with pending low-pri group notifications
                            GCRecord* pgcr = pdc->pdaGCLP->GetItemPtr(pdc->iGCLPPtr);
                            if (pgcr->pe)
                            {
                                pgcr->pe->_iGCLPSlot = -1;  // No pending low pri group changes

                                // Fire
                                pgcr->pe->OnGroupChanged(pgcr->fGroups, true);
                            }
                        }
                        else
                            fDone = true;
                    }
                }
            }
        }

        // Reset for next cycle
        DUIAssert(pdc->fFiring, "Incorrect state for end of defer cycle");

        pdc->Reset();

        DUIAssert(pdc->pvmLayoutRoot->IsEmpty(), "Defer cycle ending with pending layouts");
        DUIAssert(pdc->pvmUpdateDSRoot->IsEmpty(), "Defer cycle ending with pending update desired sizes");
    }

    // Complete cycle
    pdc->cEnter--;
}

// _PreSourceChange is called when the property engine is about to exit steady state
// (a Value changed). As a reasult, this method will determine the scope of influence
// of this change, coalesce duplicate records, and then store the values of those
// that may be affected.
//
// The scope of influence (dependency tree) is determined _using GetDependencies().
// A list is built and traversed in a BFS manner which describes which values
// must be updated first. The order guarantees state is updated in the correct order.
//
// _PreSourceChange will always run despite the PC rentrancy count
HRESULT Element::_PreSourceChange(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    //DUITrace(">>> Scanning for dependencies...\n");
    HRESULT hr;

    // If any failure occurs during a dependency Q, track. Will recover and return partial error
    bool fDepFailure = false;

    DepRecs dr = { 0 };

    int iPCPreSync = 0;
    int iPreSyncLength = 0;
    int iPCSrcRoot = 0;

    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
    {
        hr = DUI_E_NODEFERTABLE;
        goto Failed;
    }

    DUIAssert(!pdc->cPCEnter ? pdc->iPCPtr == -1 : true, "PropertyChange index pointer should have 'reset' value on first pre source change");

    pdc->cPCEnter++;

    // Record this property change
    PCRecord* ppcr;
    
    hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr))
        goto Failed;

    ppcr->fVoid = false;
    ppcr->pe = this; ppcr->ppi = ppi; ppcr->iIndex = iIndex;

    // Track last record for this element instance
    // If this is first record in cycle, iPrevElRec will be -1. Coalecsing
    // lookups (which uses this) will not go past the first record
    ppcr->iPrevElRec = ppcr->pe->_iPCTail;
    ppcr->pe->_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    pvOld->AddRef();
    ppcr->pvOld = pvOld;

    pvNew->AddRef();
    ppcr->pvNew = pvNew;

    // Append list of all steady state values from the dependency graph this source affects.
    // Do so in a BFS manner as to get direct dependents first
    iPCPreSync = pdc->pdaPC->GetIndexPtr(ppcr);
    iPCSrcRoot = iPCPreSync;

    DUIAssert((int)iPCPreSync == pdc->iPCSSUpdate, "Record should match index of post-update starting point");

    while (iPCPreSync < (int)pdc->pdaPC->GetSize())  // Size may change during iteration
    {
        // Get property changed record
        ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        // Get all dependencies of this source (append to end of list) and track in this record.
        if (FAILED(ppcr->pe->_GetDependencies(ppcr->ppi, ppcr->iIndex, &dr, iPCSrcRoot, pdc)))
            fDepFailure = true;

        // GetDependencies may have added records which may have caused the da to move in memory,
        // so recompute pointer to record (if no new records, this AddPtr may have caused a move, do anyway)
        //if (pdc->pdaPC->WasMoved())
            ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        // Track position of dependent records
        ppcr->dr = dr;
    
        iPCPreSync++;
    }

    // Coalesce and store SS before source change
    int iScan;
    int iLastDup;

    // Reset pre-sync index
    iPCPreSync = pdc->iPCSSUpdate + 1;  // Start after root source change
    iPreSyncLength = (int)pdc->pdaPC->GetSize();  // Size will not change during iteration

    while (iPCPreSync < iPreSyncLength)
    {
        // Coalecse and void duplicates
        ppcr = pdc->pdaPC->GetItemPtr(iPCPreSync);

        if (!ppcr->fVoid)
        {
            PCRecord* ppcrChk;

            // Search only records that refer to this record's element instance
            // Walk backwards from tail of element's record set (tracked by element) to
            // this, scanning for matches
            iScan = ppcr->pe->_iPCTail;
            iLastDup = -1;

            DUIAssert(iPCPreSync <= ppcr->pe->_iPCTail, "Element property change tail index mismatch");

            while (iScan != iPCPreSync)
            {
                ppcrChk = pdc->pdaPC->GetItemPtr(iScan);

                if (!ppcrChk->fVoid)
                {
                    // Check for match
                    if (ppcrChk->iIndex == ppcr->iIndex && 
                        ppcrChk->ppi == ppcr->ppi)
                    {
                        DUIAssert(ppcrChk->pe == ppcr->pe, "Property change record does not match with current lookup list");

                        if (iLastDup == -1)
                        {
                            // Found the last duplicate, track. Will not be voided
                            iLastDup = iScan;
                        }
                        else
                        {
                            // Found a duplicate between last and initial record, void
                            // it and all dependencies on it
                            _VoidPCNotifyTree(iScan, pdc);
                        }

                        DUIAssert(iScan <= ppcr->pe->_iPCTail, "Coalescing pass went past property change lookup list");
                    }
                }

                // Walk back
                iScan = ppcrChk->iPrevElRec;
            }

            // No duplicates found, get presync SS value for record
            if (iLastDup == -1)
            {
                // Get old value
                DUIAssert(!ppcr->pvOld, "Old value shouldn't be available when storing pre SS sync values");
                ppcr->pvOld = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex, NULL);  // Use ref count
            }
            else
            {
                // Duplicates found, void this record. Keep last record. All sources before it
                // will be brought back to steady state before it (in PostSourceChange)
                _VoidPCNotifyTree(iPCPreSync, pdc);
            }
        }

        iPCPreSync++;
    }

    DUIAssert(iPCPreSync == (int)pdc->pdaPC->GetSize(), "Index pointer and actual property change array size mismatch");

    return fDepFailure ? DUI_E_PARTIAL : S_OK;

Failed:

    // On a total failure, there is no dependency tree. Reentrancy is set if defer object was available
    return hr;
}

// _PostSourceChange takes the list of dependencies and old values created in _PreSourceChange
// and retrieves all the new values (and, in the cases of the value remaining the same, will
// void the PC record and all dependencies of that record).
//
// The value state is now back to steady state of this point (GetValue will return the value set).
//
// Only the "outter-most" _PostSourceChange continues at this point (all other's return). _PostSourceChange
// will continue to queue up GPC's based on the properties changed, and finally fires OnPropertyChanged().
//
// OnPropertyChanged() events are guaranteed to be in the order of sets. However, it is not guaranteed
// that an OnPropertyChanged() will be called right after a set happens. If another set happens
// within an OnPropertyChanged(), the event will be deferred until the outter-most _PostSourceChange
// processes the notification.
HRESULT Element::_PostSourceChange()
{
    HRESULT hr;

    // If any failure occurs during a group Q, track. Will recover and return partial error
    bool fGrpQFailure = false;

    int cSize = 0;

    // Per-thread storage
    DeferCycle* pdc = GetDeferObject();
    if (!pdc)
    {
        hr = DUI_E_NODEFERTABLE;
        goto Failed;
    }

    StartDefer();

    PCRecord* ppcr;

    // Source change happened, dependent values (cached) need updating.
    // Go through records, get new value, and compare with old. If different, void

    // TODO: Change to bool
    UpdateCache uc;
    ZeroMemory(&uc, sizeof(UpdateCache));

    // iPCSSUpdate holds the starting index of a group of records that needs post processing
    // (get new values, compare and void if needed)
    cSize = (int)pdc->pdaPC->GetSize();
    while (pdc->iPCSSUpdate < cSize)  // Size constant during iteration
    {
        ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCSSUpdate);

        if (!ppcr->fVoid)  // Items may have been voided by below
        {
            DUIAssert(ppcr->pvOld, "Non-voided items should have a valid 'old' value during SS update (PostSourceChange)");

            if (!ppcr->pvNew)
            {
                // Retrieve new value (Element/Property/Index will be back to SS)
                ppcr->pvNew = ppcr->pe->GetValue(ppcr->ppi, ppcr->iIndex, &uc);
            }

            // If new value hasn't changed, void this and all dependent notifications
            if (ppcr->pvOld->IsEqual(ppcr->pvNew))
            {
                _VoidPCNotifyTree(pdc->iPCSSUpdate, pdc);
            }
        }

        pdc->iPCSSUpdate++;
    }

    // Back to steady state at this point

    // First entered PostSourceChange is responsible for voiding duplicate property change records,
    // logging group changes, and firing property changes.
    //
    // OnPropertyChanged is fired when values (sources and dependents) are at steady state (SS)
    if (pdc->cPCEnter == 1)
    {
        while (pdc->iPCPtr + 1 < (int)pdc->pdaPC->GetSize())  // Size may change during iteration
        {
            pdc->iPCPtr++;

            // Coalecse and void duplicates
            ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

            if (!ppcr->fVoid)
            {
                // Log property groups only if retrieval index
                if ((ppcr->ppi->fFlags & PF_TypeBits) == ppcr->iIndex)
                {
                    GCRecord* pgcr;

                    int fGroups = ppcr->ppi->fGroups;

                    // If layout optimization is set on the Element, don't queue a layout GPC
                    // (which will, when fired, mark it as needing layout and queue another
                    // layout cycle). Rather, clear the layout GPC bit since the layout will be
                    // forced to happen within the current layout cycle
                    if (ppcr->pe->_fBit.fNeedsLayout == LC_Optimize)
                        fGroups &= ~PG_AffectsLayout;

                    // Record normal priority group changes
                    if (fGroups & PG_NormalPriMask)
                    {
                        if (ppcr->pe->_iGCSlot == -1)  // No GC record
                        {
                            hr = pdc->pdaGC->AddPtr(&pgcr);
                            if (FAILED(hr))
                                fGrpQFailure = true;
                            else
                            {
                                pgcr->pe = ppcr->pe;
                                pgcr->fGroups = 0;
                                ppcr->pe->_iGCSlot = pdc->pdaGC->GetIndexPtr(pgcr);
                            }
                        }
                        else                           // Has GC record
                        {
                            pgcr = pdc->pdaGC->GetItemPtr(ppcr->pe->_iGCSlot);
                        }

                        // Mark groups that have changed for later async group notifications
                        pgcr->fGroups |= fGroups;
                    }

                    // Record low priority group changes
                    if (fGroups & PG_LowPriMask)
                    {
                        if (ppcr->pe->_iGCLPSlot == -1)  // No GC record
                        {
                            hr = pdc->pdaGCLP->AddPtr(&pgcr);
                            if (FAILED(hr))
                                fGrpQFailure = true;
                            else
                            {
                                pgcr->pe = ppcr->pe;
                                pgcr->fGroups = 0;
                                ppcr->pe->_iGCLPSlot = pdc->pdaGCLP->GetIndexPtr(pgcr);
                            }
                        }
                        else                             // Has Low Pri GC record
                        {
                            pgcr = pdc->pdaGCLP->GetItemPtr(ppcr->pe->_iGCLPSlot);
                        }

                        // Mark groups that have changed for later async group notifications
                        pgcr->fGroups |= fGroups;
                    }
                }

                // Property change notification
                ppcr->pe->OnPropertyChanged(ppcr->ppi, ppcr->iIndex, ppcr->pvOld, ppcr->pvNew);

                // OnPropertyChanged may have added record which may have caused the da to move in memory,
                // so recompute pointer to record
                //if (pdc->pdaPC->WasMoved())
                    ppcr = pdc->pdaPC->GetItemPtr(pdc->iPCPtr);

                // Done with notification record
                ppcr->pvOld->Release();
                ppcr->pvNew->Release();
                ppcr->fVoid = true;
            }

            // Reset PC tail index if this is the last notification for this Element
            if (pdc->iPCPtr == ppcr->pe->_iPCTail)
                ppcr->pe->_iPCTail = -1;

        }

        // Reset PC List
        pdc->iPCPtr = -1;
        pdc->iPCSSUpdate = 0;
        pdc->pdaPC->Reset();
    }

    pdc->cPCEnter--;

    EndDefer(); 

    return fGrpQFailure ? DUI_E_PARTIAL : S_OK;

Failed:

    // Lack of a defer object will result in a total failure. In this case, _PreSourceChange would have
    // failed as well. As a result, there is no dependency tree to destroy
    return hr;
}

void Element::_VoidPCNotifyTree(int iPCPos, DeferCycle* pdc)
{
    PCRecord* ppcr = pdc->pdaPC->GetItemPtr(iPCPos);

    ppcr->fVoid = true;
    if (ppcr->pvOld)
        ppcr->pvOld->Release();
    if (ppcr->pvNew)
        ppcr->pvNew->Release();

    // Void subtree
    for (int i = 0; i < ppcr->dr.cDepCnt; i++)
    {
        _VoidPCNotifyTree(ppcr->dr.iDepPos + i, pdc);
    }
}

//#define _AddDependency(e, p, i) { ppcr = pdc->pdaPC->AddPtr(); ppcr->fVoid = false; \
//                                 ppcr->pe = e; ppcr->ppi = p; ppcr->iIndex = i;  \
//                                 ppcr->pvOld = NULL; ppcr->pvNew = NULL;         \
//                                 if (!pdr->cDepCnt) pdr->iDepPos = pdc->pdaPC->GetIndexPtr(ppcr); pdr->cDepCnt++; }
//#define _AddDependency(e, p, i)
void Element::_AddDependency(Element* pe, PropertyInfo* ppi, int iIndex, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    HRESULT hr;
    PCRecord* ppcr;

    hr = pdc->pdaPC->AddPtr(&ppcr);
    if (FAILED(hr))
    {
        *phr = hr;  // Only set on a failure
        return;
    }

    ppcr->fVoid = false;
    ppcr->pe = pe; ppcr->ppi = ppi; ppcr->iIndex = iIndex;

    // Track last record for this element instance
    ppcr->iPrevElRec = pe->_iPCTail;
    pe->_iPCTail = pdc->pdaPC->GetIndexPtr(ppcr);

    ppcr->pvOld = NULL; ppcr->pvNew = NULL;
    if (!pdr->cDepCnt)
        pdr->iDepPos = pe->_iPCTail;
    pdr->cDepCnt++;
}

// _GetDependencies stores a database of dependencies (all nodes and directed edges).
// It forms the dependency graph. It will store all dependents of the provided source
// in the dependency list (via PCRecords).
//
// _GetDependencies will attempt to predict the outcome of _PostSourceChange of
// various properties. This greatly reduces the number of calls to GetValue and
// _GetDependencies. The prediction relies on already stored cached values on
// Elements. It optimizes dependencies of inherited and cascaded properties.
HRESULT Element::_GetDependencies(PropertyInfo* ppi, int iIndex, DepRecs* pdr, int iPCSrcRoot, DeferCycle* pdc)
{
    // In the event of a failure of adding a dependency, adding of dependencies will continue
    // and no work is undone. A failure will still be reported

    // Track failures, report the last failure
    HRESULT hr = S_OK;

#if DBG
    g_cGetDep++;
#endif

    pdr->iDepPos = -1;
    pdr->cDepCnt = 0;

    // Get Specified IVE extension dependencies via PropertySheet. Only retrieval indicies are allowed
    if (iIndex == RetIdx(ppi))
    {
        PropertySheet* pps = GetSheet();
        if (pps)
            pps->GetSheetDependencies(this, ppi, pdr, pdc, &hr);
    }

    switch (iIndex)
    {
    case PI_Local:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            {
                _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
                _AddDependency(this, ExtentProp, PI_Local, pdr, pdc, &hr);
                _AddDependency(this, VisibleProp, PI_Computed, pdr, pdc, &hr);

                // Inherited values might change
                PropertyInfo* ppiScan;
                UINT nEnum = 0;
                PCRecord* ppcrRoot = pdc->pdaPC->GetItemPtr(iPCSrcRoot);

                Element* peParent = NULL;
                if (ppcrRoot->ppi == ParentProp)
                    peParent = ppcrRoot->pvNew->GetElement();

                IClassInfo* pci = GetClassInfo();
                while ((ppiScan = pci->EnumPropertyInfo(nEnum++)) != NULL)
                {
                    if (ppiScan->fFlags & PF_Inherit)
                    {
                        // Optimization

                        // Heavy operation. Be smart about what to inherit. If the value
                        // is the same as the parent's, there is no reason to add this
                        // as a dependency. However, in most cases, values aren't cached,
                        // so it's not known whether the source change will in fact change
                        // this.

                        // In cases where the value is known to be cached, we can check now
                        // of the value will really change without doing it in the PostSourceChange.
                        // As a result, node syncs may be eliminated.

                        // It is possible for this optimization to predict incorrectly.
                        // That may happen if the source change (in this case, the parent
                        // property) is the source of another property that this property
                        // is dependent on. The extra property may affect the VE. If it does,
                        // it doesn't matter since this property change will be coalesced
                        // into the latest like property change and voided out.

                        if (peParent)
                        {
                            switch (ppiScan->_iGlobalIndex)
                            {
                            case _PIDX_KeyFocused:
                                if (peParent->_fBit.bSpecKeyFocused == _fBit.bSpecKeyFocused)
                                    continue;
                                break;

                            case _PIDX_MouseFocused:
                                if (peParent->_fBit.bSpecMouseFocused == _fBit.bSpecMouseFocused)
                                    continue;
                                break;
 
                            case _PIDX_Direction:
                                if (peParent->_fBit.nSpecDirection == _fBit.nSpecDirection)
                                    continue;
                                break;

                            case _PIDX_Enabled:
                                if (peParent->_fBit.bSpecEnabled == _fBit.bSpecEnabled)
                                    continue;
                                break;

                            case _PIDX_Selected:
                                if (peParent->_fBit.bSpecSelected == _fBit.bSpecSelected)
                                    continue;
                                break;

                            case _PIDX_Cursor:
                                if (peParent->_fBit.bDefaultCursor && _fBit.bDefaultCursor)
                                    continue;
                                break;

                            case _PIDX_Visible:
                                if (peParent->_fBit.bSpecVisible == _fBit.bSpecVisible)
                                    continue;
                                break;

                            case _PIDX_ContentAlign:
                                if (peParent->IsDefaultCAlign() && IsDefaultCAlign())
                                    continue;
                                break;

                            case _PIDX_Sheet:
                                if (peParent->GetSheet() == GetSheet())
                                    continue;
                                break;

                            case _PIDX_BorderColor:
                                if (peParent->_fBit.bDefaultBorderColor && _fBit.bDefaultBorderColor)
                                    continue;
                                break;

                            case _PIDX_Foreground:
                                if (peParent->_fBit.bDefaultForeground && _fBit.bDefaultForeground)
                                    continue;
                                break;

                            case _PIDX_FontWeight:
                                if (peParent->_fBit.bDefaultFontWeight && _fBit.bDefaultFontWeight)
                                    continue;
                                break;

                            case _PIDX_FontStyle:
                                if (peParent->_fBit.bDefaultFontStyle && _fBit.bDefaultFontStyle)
                                    continue;
                                break;
                            }
                        }

                        // If the value changing is currently being stored locally
                        // on this Element, it is known that a change of the source will not
                        // affect it.
                        if (_pvmLocal->GetItem(ppiScan))
                            continue;
                    
                        _AddDependency(this, ppiScan, PI_Specified, pdr, pdc, &hr);
                    }
                }
            }
            break;

        case _PIDX_PosInLayout:
            _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
            break;

        case _PIDX_SizeInLayout:
        case _PIDX_DesiredSize:
            _AddDependency(this, ExtentProp, PI_Local, pdr, pdc, &hr);
            break;
        }

        // Default general dependencies on this (Local flag)
        if ((ppi->fFlags & PF_TypeBits) != PF_LocalOnly)
        {
            _AddDependency(this, ppi, PI_Specified, pdr, pdc, &hr);  // Specified is dependent for Normal and TriLevel
        }
        break;

    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Active:
        case _PIDX_Enabled:
            _AddDependency(this, KeyFocusedProp, PI_Specified, pdr, pdc, &hr);
            _AddDependency(this, MouseFocusedProp, PI_Specified, pdr, pdc, &hr);
            break;

        case _PIDX_X:
        case _PIDX_Y:
            _AddDependency(this, LocationProp, PI_Local, pdr, pdc, &hr);
            break;

        case _PIDX_Padding:
        case _PIDX_BorderThickness:
            {
                // Affects content offset (Location of all children)
                Value* pv;
                ElementList* peList = GetChildren(&pv);

                if (peList)
                {
                    for (UINT i = 0; i < peList->GetSize(); i++)
                    {
                        _AddDependency(peList->GetItem(i), LocationProp, PI_Local, pdr, pdc, &hr);
                    }
                }

                pv->Release();
            }
            break;

        case _PIDX_Sheet:
            {
                // Specified values change
                PropertySheet* pps = NULL;
                PCRecord* ppcrRoot = pdc->pdaPC->GetItemPtr(iPCSrcRoot);
            
                // Optimization

                // This sheet is either being inherited or set locally
                
                // If it's inherited, it's as a result of a new parent or a value being
                // set on an ancestor and propagating down. In either case, as it's
                // propagating down, if an Element already has a sheet set locally,
                // the inheritance will end. So, if it made it here, this is the
                // new property sheet that will be used with this Element (i.e.
                // PostSourceChange will result in a different value)

                // If it's being set locally, the result is the same.

                // A prediction can be made if the source of the change (root) is
                // known. If not, assume any property can change. An unknown source
                // occurs if the sheet is dependent on something other than a parent
                // change or an inherited local sheet set. If a style sheet is going
                // to 'unset', it's not known if the resulting source will become
                // null or a valid inherit from a further ancestor. It can also happen
                // if the sheet property is set to anything other than a known value
                // expression.
                bool fKnownRoot = false;

                if (ppcrRoot->ppi == SheetProp && ppcrRoot->pvNew->GetType() == DUIV_SHEET)
                {
                    pps = ppcrRoot->pvNew->GetPropertySheet();
                    fKnownRoot = true;
                }
                else if (ppcrRoot->ppi == ParentProp)
                {
                    if (ppcrRoot->pvNew->GetElement())
                        pps = ppcrRoot->pvNew->GetElement()->GetSheet();
                    fKnownRoot = true;
                }

                if (fKnownRoot)
                {
                    // Get scope in influence from new and current (old) property sheet.
                    // Any duplicates will be coalesed out

                    // New sheet contribution
                    if (pps)
                        pps->GetSheetScope(this, pdr, pdc, &hr);

                    // Old (current) cached sheet
                    PropertySheet* ppsCur = GetSheet();
                    if (ppsCur)
                        ppsCur->GetSheetScope(this, pdr, pdc, &hr);
                }
                else
                {
                    PropertyInfo* ppiScan;
                    UINT nEnum = 0;

                    IClassInfo* pci = GetClassInfo();
                    while ((ppiScan = pci->EnumPropertyInfo(nEnum++)) != NULL)
                    {
                        if (ppiScan->fFlags & PF_Cascade)
                        {
                            _AddDependency(this, ppiScan, PI_Specified, pdr, pdc, &hr);
                        }
                    }
                }
            }
            break;
        }

        // Inherited dependencies
        if (ppi->fFlags & PF_Inherit)
        {
            Value* pv;
            ElementList* peList = GetChildren(&pv);

            if (peList)
            {
                Element* peChild;
                for (UINT i = 0; i < peList->GetSize(); i++)
                {
                    peChild = peList->GetItem(i);
                    if (peChild->GetClassInfo()->IsValidProperty(ppi))  // Will never ask for an unsupported property
                    {
                        // Optimization
                        
                        // If a local value is set, inheritance doesn't matter
                        if (peChild->_pvmLocal->GetItem(ppi))
                            continue;

                        _AddDependency(peChild, ppi, PI_Specified, pdr, pdc, &hr);
                    }
                }
            }

            pv->Release();
        }

        // Default general dependencies on this (Normal flag)
        if ((ppi->fFlags & PF_TypeBits) == PF_TriLevel)
        {
            _AddDependency(this, ppi, PI_Computed, pdr, pdc, &hr);  // Computed is dependent for TriLevel
        }
        break;

    case PI_Computed:
        // Specific dependencies
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Visible:
            Value* pv;
            ElementList* peList = GetChildren(&pv);

            if (peList)
            {
                // All Elements have the Visible property
                Element* peChild;
                for (UINT i = 0; i < peList->GetSize(); i++)
                {
                    peChild = peList->GetItem(i);
                    _AddDependency(peChild, VisibleProp, PI_Computed, pdr, pdc, &hr);
                }
            }
            
            pv->Release();
            break;
        }
        break;

    default:
        DUIAssertForce("Invalid index in GetDependencies");
        break;
    }

    return hr;
}

Value* Element::GetValue(PropertyInfo* ppi, int iIndex, UpdateCache* puc)
{
    // Validate
    DUIContextAssert(this);
    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(IsValidAccessor(ppi, iIndex, false), "Unsupported Get on property");

#if DBG
    g_cGetVal++;

    //g_gvt.Count(ppi, iIndex, puc ? true : false);
#endif

    Value* pv;

    pv = Value::pvUnset;

    switch (iIndex)
    {
    case PI_Local:
        // Local/Read-only properties (either cached or unchangable expressions)
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            pv = (_peLocParent) ? Value::CreateElementRef(_peLocParent) : ParentProp->pvDefault;  // Use ref count
            break;

        case _PIDX_PosInLayout:
            pv = Value::CreatePoint(_ptLocPosInLayt.x, _ptLocPosInLayt.y);  // Use ref count
            break;

        case _PIDX_SizeInLayout:
            pv = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);  // Use ref count
            break;

        case _PIDX_DesiredSize:
            pv = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);  // Use ref count
            break;

        case _PIDX_LastDSConst:
            pv = Value::CreateSize(_sizeLocLastDSConst.cx, _sizeLocLastDSConst.cy);  // Use ref count
            break;

        case _PIDX_Location:
            {
                Element* peParent = GetParent();
                int dLayoutPos = GetLayoutPos();

                if (peParent && dLayoutPos != LP_Absolute)
                {
                    // Box model, add in border/padding
                    int dX;
                    int dY;

                    // Get position in layout
                    dX = _ptLocPosInLayt.x;
                    dY = _ptLocPosInLayt.y;

                    // Add on parent's border and padding
                    const RECT* pr = peParent->GetBorderThickness(&pv);  // Border thickness
                    dX += IsRTL() ? pr->right : pr->left;
                    dY += pr->top;
                    pv->Release();

                    pr = peParent->GetPadding(&pv);  // Padding
                    dX += IsRTL() ? pr->right : pr->left;
                    dY += pr->top;
                    pv->Release();

                    pv = Value::CreatePoint(dX, dY);  // Use ref count
                }
                else
                {
                    pv = Value::CreatePoint(GetX(), GetY());
                }
            }
            break;

        case _PIDX_Extent:
            {
                Element* peParent = GetParent();
                int dLayoutPos = GetLayoutPos();

                if (peParent && dLayoutPos != LP_Absolute)
                {
                    pv = Value::CreateSize(_sizeLocSizeInLayt.cx, _sizeLocSizeInLayt.cy);
                }
                else
                {
                    pv = Value::CreateSize(_sizeLocDesiredSize.cx, _sizeLocDesiredSize.cy);
                }
            }
            break;

        case _PIDX_KeyWithin:
            pv = _fBit.bLocKeyWithin ? Value::pvBoolTrue : Value::pvBoolFalse;
            break;

        case _PIDX_MouseWithin:
            pv = _fBit.bLocMouseWithin ? Value::pvBoolTrue : Value::pvBoolFalse;
            break;

        default:
            {
QuickLocalLookup:
                // Default get for Local, Normal, and TriLevel properties
                Value** ppv = _pvmLocal->GetItem(ppi);
                if (ppv)
                {
                    pv = *ppv;
                    pv->AddRef();
                }
            }
            break;
        }

        // On failure, set to Unset
        if (pv == NULL)
            pv = Value::pvUnset;

        // Check if was called as a result of a Specified lookup
        if (iIndex != PI_Local)
            goto QuickLocalLookupReturn;

        break;

    case PI_Specified:
        {
            // Try to get based on cached (or partial cached) value (if updating cache, fall though, do
            // get normally, and cache value at the end)
            if (!puc)
            {
                // Return cached values instead of doing lookup (cannot create values for
                // cached values that will be deleted by the value if no longer referenced)
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_Children:
                    if (!HasChildren())
                        pv = ChildrenProp->pvDefault;
                    break;

                case _PIDX_Layout:
                    if (!HasLayout())
                        pv = LayoutProp->pvDefault;
                    break;

                case _PIDX_BorderThickness:
                    if (!HasBorder())
                        pv = BorderThicknessProp->pvDefault;
                    break;

                case _PIDX_Padding:
                    if (!HasPadding())
                        pv = PaddingProp->pvDefault;
                    break;

                case _PIDX_Margin:
                    if (!HasMargin())
                        pv = MarginProp->pvDefault;
                    break;

                case _PIDX_Content:
                    if (!HasContent())
                        pv = ContentProp->pvDefault;
                    break;

                case _PIDX_ContentAlign:
                    if (IsDefaultCAlign())
                        pv = ContentAlignProp->pvDefault;
                    break;

                case _PIDX_LayoutPos:
                    pv = Value::CreateInt(_dSpecLayoutPos);  // Use ref count
                    break;

                case _PIDX_Active:
                    pv = Value::CreateInt(_fBit.fSpecActive);  // Use ref count
                    break;

                case _PIDX_Selected:
                    pv = Value::CreateBool(_fBit.bSpecSelected);  // Use ref count
                    break;

                case _PIDX_KeyFocused:
                    pv = Value::CreateBool(_fBit.bSpecKeyFocused);  // Use ref count
                    break;

                case _PIDX_MouseFocused:
                    pv = Value::CreateBool(_fBit.bSpecMouseFocused);  // Use ref count
                    break;

                case _PIDX_Animation:
                    if (!HasAnimation())
                        pv = AnimationProp->pvDefault;
                    break;

                case _PIDX_Cursor:
                    if (IsDefaultCursor())
                        pv = CursorProp->pvDefault;
                    break;

                case _PIDX_Direction:
                    pv = Value::CreateInt(_fBit.nSpecDirection);  // Use ref count
                    break;

                case _PIDX_Accessible:
                    pv = Value::CreateBool(_fBit.bSpecAccessible);  // Use ref count
                    break;

                case _PIDX_Enabled:
                    pv = Value::CreateBool(_fBit.bSpecEnabled);  // Use ref count
                    break;

                case _PIDX_Visible:
                    pv = Value::CreateBool(_fBit.bSpecVisible);  // Use ref count
                    break;

                case _PIDX_BorderColor:
                    if (_fBit.bDefaultBorderColor)
                        pv = BorderColorProp->pvDefault;
                    break;

                case _PIDX_Foreground:
                    if (_fBit.bDefaultForeground)
                        pv = ForegroundProp->pvDefault;
                    break;

                case _PIDX_FontWeight:
                    if (_fBit.bDefaultFontWeight)
                        pv = FontWeightProp->pvDefault;
                    break;

                case _PIDX_FontStyle:
                    if (_fBit.bDefaultFontStyle)
                        pv = FontStyleProp->pvDefault;
                    break;

                case _PIDX_Alpha:
                    pv = Value::CreateInt(_dSpecAlpha);  // Use ref count
                    break;
                }

                // On cache Value creation failure, set to Unset
                if (pv == NULL)
                    pv = Value::pvUnset;

            }

            // Default get for Normal, and TriLevel properties
QuickSpecifiedLookup:
            // Try for local value
            if (pv->GetType() == DUIV_UNSET)
            {
                goto QuickLocalLookup;
            }

QuickLocalLookupReturn:
            // Try for cascaded PropertySheet value if applicable
            if (pv->GetType() == DUIV_UNSET)
            {
                if (ppi->fFlags & PF_Cascade)
                {
                    PropertySheet* pps = GetSheet();
                    if (pps)
                        pv = pps->GetSheetValue(this, ppi);
                }
            }

            // Try to inherit value if applicable
            if (pv->GetType() == DUIV_UNSET)
            {
                bool bNoInherit = false;

                // Conditional inherit of the mouse focused property
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_KeyFocused:
                    bNoInherit = (!GetEnabled() || (GetActive() & AE_Keyboard));
                    break;

                case _PIDX_MouseFocused:
                    bNoInherit = (!GetEnabled() || (GetActive() & AE_Mouse));
                    break;
                }

                // No need to release static value 'Unset'
                if ((ppi->fFlags & PF_Inherit) && !bNoInherit)
                {
                    Element* peParent = GetParent();
                    if (peParent)
                    {
                        if (peParent->GetClassInfo()->IsValidProperty(ppi))  // Will never ask for an unsupported property
                        {
                            pv = peParent->GetValue(ppi, PI_Specified, NULL);  // Use ref count
                        }
                    }
                    else
                    {
                        pv = Value::pvUnset;  // No ref count on static value
                    }
                }
            }

            // Use default value
            if (pv->GetType() == DUIV_UNSET)
            {
                // No need to release static value 'Unset'
                pv = ppi->pvDefault;
                pv->AddRef();
            }

            // On failure, set to default value
            if (pv == NULL)
                pv = ppi->pvDefault;

            // Check if was called as a result of a Computed lookup
            if (iIndex != PI_Specified)
                goto QuickSpecifiedLookupReturn;

            // Update cached values
            if (puc)
            {
                switch (ppi->_iGlobalIndex)
                {
                case _PIDX_LayoutPos:
                    _dSpecLayoutPos = pv->GetInt();
                    break;

                case _PIDX_Active:
                    _fBit.fSpecActive = pv->GetInt();
                    break;

                case _PIDX_Children:
                    _fBit.bHasChildren = (pv->GetElementList() != NULL);
                    break;

                case _PIDX_Layout:
                    _fBit.bHasLayout = (pv->GetLayout() != NULL);
                    break;

                case _PIDX_BorderThickness:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasBorder = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Padding:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasPadding = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Margin:
                    {
                        const RECT* pr = pv->GetRect();
                        _fBit.bHasMargin = (pr->left || pr->top || pr->right || pr->bottom);
                    }
                    break;

                case _PIDX_Content:
                    _fBit.bHasContent = ((pv->GetType() != DUIV_STRING) || (pv->GetString() != NULL));
                    break;

                case _PIDX_ContentAlign:
                    _fBit.bDefaultCAlign = (pv->GetInt() == 0); // TopLeft, no ellipsis, no focus rect
                    _fBit.bWordWrap = (((pv->GetInt()) & 0xC) == 0xC);  // Word wrap bits
                    break;

                case _PIDX_Sheet:
                    _pvSpecSheet->Release();
                    pv->AddRef();
                    _pvSpecSheet = pv;
                    break;

                case _PIDX_Selected:
                    _fBit.bSpecSelected = pv->GetBool();
                    break;

                case _PIDX_ID:
                    _atomSpecID = pv->GetAtom();
                    break;

                case _PIDX_KeyFocused:
                    _fBit.bSpecKeyFocused = pv->GetBool();
                    break;

                case _PIDX_MouseFocused:
                    _fBit.bSpecMouseFocused = pv->GetBool();
                    break;

                case _PIDX_Animation:
                    _fBit.bHasAnimation = ((pv->GetInt() & ANI_TypeMask) != ANI_None);
                    break;

                case _PIDX_Cursor:
                    _fBit.bDefaultCursor = ((pv->GetType() == DUIV_INT) && (pv->GetInt() == 0));
                    break;

                case _PIDX_Direction:
                    _fBit.nSpecDirection = pv->GetInt();
                    break;

                case _PIDX_Accessible:
                    _fBit.bSpecAccessible = pv->GetBool();
                    break;

                case _PIDX_Enabled:
                    _fBit.bSpecEnabled = pv->GetBool();
                    break;

                case _PIDX_Visible:
                    _fBit.bSpecVisible = pv->GetBool();
                    break;

                case _PIDX_BorderColor:
                    _fBit.bDefaultBorderColor = pv->IsEqual(BorderColorProp->pvDefault);
                    break;

                case _PIDX_Foreground:
                    _fBit.bDefaultForeground = pv->IsEqual(ForegroundProp->pvDefault);
                    break;

                case _PIDX_FontWeight:
                    _fBit.bDefaultFontWeight = pv->IsEqual(FontWeightProp->pvDefault);
                    break;

                case _PIDX_FontStyle:
                    _fBit.bDefaultFontStyle = pv->IsEqual(FontStyleProp->pvDefault);
                    break;

                case _PIDX_Alpha:
                    _dSpecAlpha = pv->GetInt();
                    break;
                }
            }
        }

        break;

    case PI_Computed:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Visible:
            if (puc)
            {
                goto QuickSpecifiedLookup;

QuickSpecifiedLookupReturn:

                _fBit.bCmpVisible = pv->GetBool();

                pv->Release();

                if (_fBit.bCmpVisible)
                {
                    Element* peParent = GetParent();
                    if (peParent)
                    {
                        _fBit.bCmpVisible = peParent->GetVisible(); 
                    }
                }
            }

            pv = (_fBit.bCmpVisible) ? Value::pvBoolTrue : Value::pvBoolFalse;  // No ref count on static values
            break;

        default:
            // Default get for TriLevel properties
            pv = GetValue(ppi, PI_Specified, NULL);  // Use ref count
            break;
        }

        // On failure, set to default value
        if (pv == NULL)
            pv = ppi->pvDefault;

        break;

    default:
        DUIAssertForce("Invalid index for GetValue");
        break;
    }

    DUIAssert(pv != NULL, "Return value from GetValue must never be NULL");
    DUIAssert(iIndex != PI_Local ? pv != Value::pvUnset : true, "Specified and Computed values must never be 'Unset'");

    return pv;
}

// Elements can always set a value for any valid PropertyInfo
HRESULT Element::SetValue(PropertyInfo* ppi, int iIndex, Value* pv)
{
    return _SetValue(ppi, iIndex, pv, false);
}

// Internal SetValue. Used by ReadOnly properties that want to use generic storage.
// All other local values that want to use specific storage must call Pre/PostSourceChange
// directly since a switch statement is intentionally left out of _SetValue for maximum perf.
HRESULT Element::_SetValue(PropertyInfo* ppi, int iIndex, Value* pv, bool fInternalCall)
{
    // Validate
    DUIContextAssert(this);
    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(fInternalCall ? true : IsValidAccessor(ppi, iIndex, true), "Unsupported Set on property");
    DUIAssert(IsValidValue(ppi, pv), "Invalid value for property");

    // Set
    DUIAssert(iIndex == PI_Local, "Can set Local values only");

    HRESULT hr = S_OK;

    // Partial fail in SetValue means that not all dependents are synced and/or 
    // notifications are fired, but Value was set
    bool fPartialFail = false;  

    Value* pvOld = GetValue(ppi, PI_Local, NULL);

    // No set on equivalent values
    if (!pvOld->IsEqual(pv))
    {
        // No call to OnPropertyChanging if an internal call
        if (fInternalCall || OnPropertyChanging(ppi, iIndex, pvOld, pv))
        {
            if (FAILED(_PreSourceChange(ppi, iIndex, pvOld, pv)))
                fPartialFail = true;  // Not all PC records could be queued, continue

            // Set value
            hr = _pvmLocal->SetItem(ppi, pv);
            if (SUCCEEDED(hr))
            {
                // Storing new value, ref new and release for local reference
                pv->AddRef();
                pvOld->Release();
            }

            if (FAILED(_PostSourceChange()))
                fPartialFail = true; // Not all GPC records could be queued
        }
    }

    // Release for GetValue
    pvOld->Release();

    if (FAILED(hr))
        return hr;
    else
        return fPartialFail ? DUI_E_PARTIAL : S_OK;
}

bool Element::OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Inform listeners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT i = 1; i <= cListeners; i++)
        {
            // Callback
            if (!_ppel[i]->OnListenedPropertyChanging(this, ppi, iIndex, pvOld, pvNew))
                return false;
        }
    }

    return true;
}

// Property changes may not happen immediately after a value is set. If a SetValue happens
// during another SetValue (meaning, a set in an OnPropertyChanged), the notification 
// will be delayed until the outter-most SetValue continues firing the notifications
void Element::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
#if DBG
    //WCHAR szvOld[81];
    //WCHAR szvNew[81];

    //DUITrace("PC: <%x> %S[%d] O:%S N:%S\n", this, ppi->szName, iIndex, pvOld->ToString(szvOld, DUIARRAYSIZE(szvOld)), pvNew->ToString(szvNew, DUIARRAYSIZE(szvNew)));
    
    g_cOnPropChg++;
#endif

    switch (iIndex)
    {
    case PI_Local:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Parent:
            {
                Element* peNewParent = pvNew->GetElement();
                Element* peOldParent = pvOld->GetElement();
                Element* peNewRoot = NULL;
                Element* peOldRoot = NULL;
                HGADGET hgParent = NULL;

                Element* pThis = this;  // Need pointer to this
                Value* pv;

                if (peOldParent) // Unparenting
                {
                    // Inform parent's layout that this is being removed
                    Layout* pl = peOldParent->GetLayout(&pv);

                    if (pl)
                        pl->OnRemove(peOldParent, &pThis, 1);

                    pv->Release();

                    // Parent display node
                    hgParent = NULL;

                    peOldRoot = peOldParent->GetRoot();
                }

                if (peNewParent) // Parenting
                {
                    // No longer a "Root", remove possible Q for UpdateDS and Layout
                    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
                    DUIAssert(pdc, "Defer cycle table doesn't exit");

                    pdc->pvmUpdateDSRoot->Remove(this, false, true);
                    pdc->pvmLayoutRoot->Remove(this, false, true);

                    // Inform parent's layout that this is being added
                    Layout* pl = peNewParent->GetLayout(&pv);

                    if (pl)
                        pl->OnAdd(peNewParent, &pThis, 1);

                    pv->Release();

                    // Parent display node
                    hgParent = peNewParent->GetDisplayNode();

                    peNewRoot = peNewParent->GetRoot();
                }

                SetGadgetParent(GetDisplayNode(), hgParent, NULL, GORDER_TOP);

                // Fire native hosted events
                if (peOldRoot != peNewRoot)
                {
                    if (peOldRoot)
                    {
                        //DUITrace("OnUnHosted: <%x> Old<%x>\n", this, peOldRoot);
                        OnUnHosted(peOldRoot);
                    }

                    if (peNewRoot)
                    {
                        //DUITrace("OnHosted: <%x> New<%x>\n", this, peNewRoot);
                        OnHosted(peNewRoot);
                    }
                }
            }
            break;

        case _PIDX_KeyFocused:
            if (pvNew->GetType() != DUIV_UNSET)
            {
                DUIAssert(pvNew->GetBool(), "Expecting a boolean TRUE\n");

                // May already have keyboard focus if came from system
                if (GetGadgetFocus() != GetDisplayNode())
                    SetGadgetFocus(GetDisplayNode());
            }
            break;
        }
        break;

    case PI_Specified:
        switch (ppi->_iGlobalIndex)
        {
        case _PIDX_Layout:
            {
                Value* pvChildren;
                ElementList* peList = GetChildren(&pvChildren);

                Layout* pl;

                // Detach from old
                pl = pvOld->GetLayout();
                if (pl)
                {
                    // Remove all children from Layout (external layouts only)
                    if (peList)
                    {
                        peList->MakeWritable();
                        pl->OnRemove(this, peList->GetItemPtr(0), peList->GetSize());
                        peList->MakeImmutable();
                    }

                    pl->Detach(this);
                }

                // Attach to new
                pl = pvNew->GetLayout();
                if (pl)
                {
                    pl->Attach(this);

                    // Add all children to Layout (external layouts only)
                    if (peList)
                    {
                        peList->MakeWritable();
                        pl->OnAdd(this, peList->GetItemPtr(0), peList->GetSize());
                        peList->MakeImmutable();
                    }
                }

                pvChildren->Release();
            }
            break;

        case _PIDX_LayoutPos:
            {
                // If no longer a "Root", remove possible Q for UpdateDS and Layout
                if (pvNew->GetInt() != LP_Absolute)
                {
                    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;
                    DUIAssert(pdc, "Defer cycle table doesn't exist");

                    pdc->pvmUpdateDSRoot->Remove(this, false, true);
                    pdc->pvmLayoutRoot->Remove(this, false, true);
                }

                // Inform parent layout (if any) of change
                Element* peParent = GetParent();
                if (peParent)
                {
                    Value* pv;
                    Layout* pl = peParent->GetLayout(&pv);

                    // Inform layout of layoutpos only for external layouts
                    if (pl)
                        pl->OnLayoutPosChanged(peParent, this, pvOld->GetInt(), pvNew->GetInt());

                    pv->Release();
                }
            }
            break;

        case _PIDX_Visible:
            // Follow specified value, computed will reflect true state
            SetGadgetStyle(GetDisplayNode(), pvNew->GetBool() ? GS_VISIBLE : 0, GS_VISIBLE);
            break;

        case _PIDX_Enabled:
        case _PIDX_Active:
        {
            BOOL fEnabled;
            int  iActive;
            if (ppi->_iGlobalIndex == _PIDX_Enabled)
            {
                fEnabled = pvNew->GetBool();
                iActive = GetActive();
            }
            else
            {
                fEnabled = GetEnabled();
                iActive = pvNew->GetInt();
            }

            int iFilter =  0;
            int iStyle = 0;
            if (fEnabled)
            {
                if (iActive & AE_Keyboard)
                {
                    iFilter |= GMFI_INPUTKEYBOARD;
                    iStyle |= GS_KEYBOARDFOCUS;
                }
                if (iActive & AE_Mouse)
                {
                    iFilter |= GMFI_INPUTMOUSE;
                    iStyle |= GS_MOUSEFOCUS;
                }
            }
            SetGadgetMessageFilter(GetDisplayNode(), NULL, iFilter, GMFI_INPUTKEYBOARD|GMFI_INPUTMOUSE);
            SetGadgetStyle(GetDisplayNode(), iStyle, GS_KEYBOARDFOCUS|GS_MOUSEFOCUS);
            break;
        }
        case _PIDX_Alpha:
            {
                // Check for alpha animation, start if necessary if alpha animation type
                // Allow animation to update gadget alpha level
                int dAni;
                if (HasAnimation() && ((dAni = GetAnimation()) & ANI_AlphaType) && IsAnimationsEnabled())
                {
                    // Invoke only "alpha" type animations now
                    InvokeAnimation(dAni, ANI_AlphaType);
                }
                else
                    SetGadgetOpacity(GetDisplayNode(), (BYTE)pvNew->GetInt());
            }
            break;

        case _PIDX_Background:
            {
                bool fOpaque = true;

                // Update Opaque style based on background transparency
                if (pvNew->GetType() == DUIV_FILL)
                {
                    const Fill* pf = pvNew->GetFill();
                    if (pf->dType == FILLTYPE_Solid && GetAValue(pf->ref.cr) != 255)
                        fOpaque = false;
                }
                else if (pvNew->GetType() == DUIV_GRAPHIC)
                {
                    Graphic* pg = pvNew->GetGraphic();
                    if (pg->BlendMode.dMode == GRAPHIC_AlphaConst || 
                        pg->BlendMode.dMode == GRAPHIC_AlphaConstPerPix ||
                        pg->BlendMode.dMode == GRAPHIC_NineGridAlphaConstPerPix)
                        fOpaque = false;
                }

                SetGadgetStyle(GetDisplayNode(), (fOpaque)?GS_OPAQUE:0, GS_OPAQUE);
            }

            // Fall though

        case _PIDX_Content:
        case _PIDX_ContentAlign:
        case _PIDX_Padding:
        case _PIDX_BorderThickness:
            {
                Value* pvBG = NULL;
                Value* pvContent = NULL;

                // Update H and V Gadget Redraw based on values of these properties
                bool fHRedraw = false;
                bool fVRedraw = false;

                // Borders
                if (HasBorder())
                {
                    fHRedraw = true;
                    fVRedraw = true;

                    goto SetRedrawStyle;  // Full redraw in both directions
                }

                if (HasContent())
                {
                    // Padding
                    if (HasPadding())
                    {
                        fHRedraw = true;
                        fVRedraw = true;

                        goto SetRedrawStyle;  // Full redraw in both directions
                    }

                    // Alignment                
                    int dCA = GetContentAlign();

                    int dCAHorz = (dCA & 0x3);       // Horizontal content align
                    int dCAVert = (dCA & 0xC) >> 2;  // Vertical content align

                    if (dCAHorz != 0 || dCAVert == 0x3)  // HRedraw if 'center', 'right', or 'wrap'
                        fHRedraw = true;

                    if (dCAVert != 0)  // VRedraw if 'middle', 'bottom', or 'wrap'
                        fVRedraw = true;

                    if (fHRedraw && fVRedraw)
                        goto SetRedrawStyle;  // Full redraw in both directions

                    // Image and fill content may be shrinked if paint area is smaller than image
                    pvContent = GetValue(ContentProp, PI_Specified);  // Released later
                    if (pvContent->GetType() == DUIV_GRAPHIC || pvContent->GetType() == DUIV_FILL)
                    {
                        fHRedraw = true;
                        fVRedraw = true;

                        goto SetRedrawStyle;  // Full redraw in both directions
                    }
                }

                // Background
                pvBG = GetValue(BackgroundProp, PI_Specified);  // Released later

                if (pvBG->GetType() == DUIV_FILL && pvBG->GetFill()->dType != FILLTYPE_Solid)
                {
                    fHRedraw = true;
                    fVRedraw = true;
                    goto SetRedrawStyle;
                }

                if (pvBG->GetType() == DUIV_GRAPHIC)
                {
                    Graphic * pgr = pvBG->GetGraphic();
                    if (pgr->BlendMode.dImgType == GRAPHICTYPE_EnhMetaFile)
                    {
                        fHRedraw = true;
                        fVRedraw = true;
                        goto SetRedrawStyle;
                    }
                    if ((pgr->BlendMode.dImgType == GRAPHICTYPE_Bitmap) ||
#ifdef GADGET_ENABLE_GDIPLUS                    
                        (pgr->BlendMode.dImgType == GRAPHICTYPE_GpBitmap) ||
#endif GADGET_ENABLE_GDIPLUS
                        0)
                    {
                        BYTE dMode = pgr->BlendMode.dMode;
                        if ((dMode == GRAPHIC_Stretch) || (dMode == GRAPHIC_NineGrid) || (dMode == GRAPHIC_NineGridTransColor)) 
                        {
                            fHRedraw = true;
                            fVRedraw = true;
                            goto SetRedrawStyle;
                        }
                    }
                }

SetRedrawStyle:
                SetGadgetStyle(GetDisplayNode(), ((fHRedraw)?GS_HREDRAW:0) | ((fVRedraw)?GS_VREDRAW:0), GS_HREDRAW|GS_VREDRAW);

                if (pvBG)
                    pvBG->Release();
                if (pvContent)
                    pvContent->Release();
            }
            break;

        case _PIDX_KeyFocused:
            {
                if (GetAccessible()) {
                    if (GetActive() & AE_Keyboard) {
                        int nAccState = GetAccState();
                        if (pvNew->GetBool()) {
                            nAccState |= STATE_SYSTEM_FOCUSED;
                            NotifyAccessibilityEvent(EVENT_OBJECT_FOCUS, this);
                        } else {
                            nAccState &= ~STATE_SYSTEM_FOCUSED;
                        }
                        SetAccState(nAccState);
                    }
                }
            }
            break;

        case _PIDX_Animation:
            {
                // If old animation value contained an animation type and the replacement
                // animation does not, stop the animation
            
                if ((pvOld->GetInt() & ANI_BoundsType) && !(pvNew->GetInt() & ANI_BoundsType))
                    StopAnimation(ANI_BoundsType);

                if ((pvOld->GetInt() & ANI_AlphaType) && !(pvNew->GetInt() & ANI_AlphaType))
                    StopAnimation(ANI_AlphaType);
            }
            break;

        case _PIDX_Accessible:
            {
                //
                // When accessibility support for this element is turned ON,
                // make sure that its state reflects the appropriate information.
                //
                if (pvNew->GetBool()) {
                    if (GetActive() & AE_Keyboard) {
                        int nAccState = GetAccState();
                        if (GetKeyFocused()) {
                            nAccState |= STATE_SYSTEM_FOCUSED;
                            NotifyAccessibilityEvent(EVENT_OBJECT_FOCUS, this);
                        } else {
                            nAccState &= ~STATE_SYSTEM_FOCUSED;
                        }
                        SetAccState(nAccState);
                    }
                }
            }
            break;

        case _PIDX_AccRole:
            {
                /*
                 * Note: Supposedly, the role of a UI element doesn't change
                 * at run time.  Doing so may confuse accessibility tools.
                 * Correspondingly, there is no defined Accessibility event
                 * to announce that the role changed.  So doing so will only
                 * result in a new role being returned from future calls to
                 * IAccessible::get_accRole().
                 */
            }
            break;

        case _PIDX_AccState:
            {
                /*
                 * When the state of an accessible component changes, we send
                 * the EVENT_OBJECT_STATECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_STATECHANGE, this);
                }
            }
            break;

        case _PIDX_AccName:
            {
                /*
                 * When the name of an accessible component changes, we send
                 * the EVENT_OBJECT_NAMECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_NAMECHANGE, this);
                }
            }
            break;

        case _PIDX_AccDesc:
            {
                /*
                 * When the description of an accessible component changes, we send
                 * the EVENT_OBJECT_DESCRIPTIONCHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_DESCRIPTIONCHANGE, this);
                }
            }
            break;

        case _PIDX_AccValue:
            {
                /*
                 * When the value of an accessible component changes, we send
                 * the EVENT_OBJECT_VALUECHANGE notification.
                 */
                if (GetAccessible()) {
                    NotifyAccessibilityEvent(EVENT_OBJECT_VALUECHANGE, this);
                }
            }
            break;
        }
        break;

    case PI_Computed:
        break;
    }

    // Inform lisnteners
    if (_ppel)
    {
        UINT_PTR cListeners = (UINT_PTR)_ppel[0];
        for (UINT_PTR i = 1; i <= cListeners; i++)
        {
            // Callback
            _ppel[i]->OnListenedPropertyChanged(this, ppi, iIndex, pvOld, pvNew);
        }
    }
}

void Element::OnGroupChanged(int fGroups, bool bLowPri)
{
#if DBG
/*
    TCHAR szGroups[81];
    *szGroups = 0;
    if (fGroups & PG_AffectsDesiredSize)
        _tcscat(szGroups, L"D");
    if (fGroups & PG_AffectsParentDesiredSize)
        _tcscat(szGroups, L"pD");
    if (fGroups & PG_AffectsLayout)
        _tcscat(szGroups, L"L");
    if (fGroups & PG_AffectsParentLayout)
        _tcscat(szGroups, L"pL");
    if (fGroups & PG_AffectsDisplay)
        _tcscat(szGroups, L"P");
    if (fGroups & PG_AffectsBounds)
        _tcscat(szGroups, L"B");
    DUITrace("GC: <%x> %s LowPri:%d (%d)\n", this, szGroups, bLowPri, fGroups);
*/
#endif

    DeferCycle* pdc = ((ElTls*)TlsGetValue(g_dwElSlot))->pdc;

    DUIAssert(pdc, "Defer cycle table doesn't exist");

    if (bLowPri)  // Low priority groups
    {
        // All low pri's use Extent

        // Affects Native Window Bounds
        if (fGroups & PG_AffectsBounds)
        {
            // Check for position animation, start if necessary if size, position, or
            // rect animation, allow animation to set gadget rect
            int dAni;
            if (HasAnimation() && ((dAni = GetAnimation()) & ANI_BoundsType) && IsAnimationsEnabled())
            {
                // Invoke only "bounds" type animations now
                InvokeAnimation(dAni, ANI_BoundsType);
            }
            else
            {
                Value* pvLoc;
                Value* pvExt;

                const POINT* pptLoc = GetLocation(&pvLoc);
                const SIZE* psizeExt = GetExtent(&pvExt);

                // Verify the coordinates do not wrap. If they do, don't call SetGadgetRect.
                if (((pptLoc->x + psizeExt->cx) >= pptLoc->x) && ((pptLoc->y + psizeExt->cy) >= pptLoc->y))
                {
                    // PERF: SGR_NOINVALIDATE exists for perf, needs to be evaluated
                    SetGadgetRect(GetDisplayNode(), pptLoc->x, pptLoc->y, psizeExt->cx, psizeExt->cy, /*SGR_NOINVALIDATE|*/SGR_PARENT|SGR_MOVE|SGR_SIZE);
                }

                pvLoc->Release();
                pvExt->Release();
            }
        }

        // Affects Display
        if (fGroups & PG_AffectsDisplay)
        {
            // Gadget needs painting
            InvalidateGadget(GetDisplayNode());
        }
     }
    else  // Normal priority groups
    {
        // Affects Desired Size or Affects Layout
        if (fGroups & (PG_AffectsDesiredSize | PG_AffectsLayout))
        {
            // Locate Layout/DS root and queue tree as needing a layout pass
            // Root doesn't have parent or is absolute positioned
            Element* peRoot;
            Element* peClimb = this; // Start condition
            int dLayoutPos;
            do
            {
                peRoot = peClimb;

                peClimb = peRoot->GetParent(); 
                dLayoutPos = peRoot->GetLayoutPos(); 

            } while (peClimb && dLayoutPos != LP_Absolute);

            DUIAssert(peRoot, "Root not located for layout/update desired size bit set");

            if (fGroups & PG_AffectsDesiredSize)
            {
                _fBit.bNeedsDSUpdate = true;
                pdc->pvmUpdateDSRoot->SetItem(peRoot, 1, true);
            }
            
            if (fGroups & PG_AffectsLayout)
            {
                _fBit.fNeedsLayout = LC_Normal;
                pdc->pvmLayoutRoot->SetItem(peRoot, 1, true);
            }
        }

        // Affects Parent's Desired Size or Affects Parent's Layout
        if (fGroups & (PG_AffectsParentDesiredSize | PG_AffectsParentLayout))
        {
            // Locate Layout/DS root and queue tree as needing a layout pass
            // Root doesn't have parent or is absolute positioned
            Element* peRoot;
            Element* peClimb = this; // Start condition
            Element* peParent = NULL;
            int dLayoutPos;
            do
            {
                peRoot = peClimb;

                peClimb = peRoot->GetParent(); 
                if (peClimb && !peParent)
                    peParent = peClimb;

                dLayoutPos = peRoot->GetLayoutPos(); 

            } while (peClimb && dLayoutPos != LP_Absolute);

            DUIAssert(peRoot, "Root not located for parent layout/update desired size bit set");

            if (peParent)
            {
                if (fGroups & PG_AffectsParentDesiredSize)
                {
                    peParent->_fBit.bNeedsDSUpdate = true;
                    pdc->pvmUpdateDSRoot->SetItem(peRoot, 1, true);
                }

                if (fGroups & PG_AffectsParentLayout)
                {
                    peParent->_fBit.fNeedsLayout = LC_Normal;
                    pdc->pvmLayoutRoot->SetItem(peRoot, 1, true);
                }
            }
        }
    }
}

////////////////////////////////////////////////////////
// Checks

// Determine if the Get or Set operation is valid based on the property flags
bool Element::IsValidAccessor(PropertyInfo* ppi, int iIndex, bool bSetting)
{
    if (bSetting)  // SetValue
    {
        if ((iIndex != PI_Local) || (ppi->fFlags & PF_ReadOnly))
            return false;
    }
    else           // GetValue
    {
        if (iIndex > (ppi->fFlags & PF_TypeBits))
            return false;
    }

    return true;
}

// Check if value type matches a type acceptable for PropertyInfo
bool Element::IsValidValue(PropertyInfo* ppi, Value* pv)
{
    bool bValid = false;
    if (ppi->pValidValues && ppi && pv)
    {
        int i = 0;
        int vv;
        while ((vv = ppi->pValidValues[i++]) != -1)
        {
            if (pv->GetType() == vv)
            {
                bValid = true;
                break;
            }
        }
    }

    return bValid;
}

////////////////////////////////////////////////////////
// Additional property methods

// Elements can always remove a value for any valid PropertyInfo
HRESULT Element::RemoveLocalValue(PropertyInfo* ppi)
{
    return _RemoveLocalValue(ppi, false);
}

// Internal SetValue. Used by ReadOnly properties that want to use generic storage.
// All other local values that want to use specific storage must call Pre/PostSourceChange
// directly since a switch statement is intentionally left out of _RemoveLocalValue for maximum perf.
HRESULT Element::_RemoveLocalValue(PropertyInfo* ppi, bool fInternalCall)
{
    UNREFERENCED_PARAMETER(fInternalCall);

    DUIAssert(GetClassInfo()->IsValidProperty(ppi), "Unsupported property");
    DUIAssert(fInternalCall ? true : IsValidAccessor(ppi, PI_Local, true), "Cannot remove local value for read-only property");

    // Partial fail in SetValue means that not all dependents are synced and/or 
    // notifications are fired, but Value was set
    bool fPartialFail = false;

    Value** ppv = _pvmLocal->GetItem(ppi);
    if (ppv)
    {
        Value* pv = *ppv;  // Make copy in case it moves

        if (FAILED(_PreSourceChange(ppi, PI_Local, pv, Value::pvUnset)))
            fPartialFail = true;  // Not all PC records could be queued, continue

        // Remove Value, never fails
        _pvmLocal->Remove(ppi);

        // Old value removed, release for local reference
        pv->Release();

        if (FAILED(_PostSourceChange()))
            fPartialFail = true;  // Not all GPC records could be queued
    }

    return fPartialFail ? DUI_E_PARTIAL : S_OK;
}

////////////////////////////////////////////////////////
// DeferCycle: Per-thread deferring information

HRESULT DeferCycle::Create(DeferCycle** ppDC)
{
    *ppDC = NULL;

    DeferCycle* pdc = HNew<DeferCycle>();
    if (!pdc)
        return E_OUTOFMEMORY;

    HRESULT hr = pdc->Initialize();
    if (FAILED(hr))
    {
        pdc->Destroy();
        return hr;
    }

    *ppDC = pdc;

    return S_OK;
}

HRESULT DeferCycle::Initialize()
{
    // Defer cycle state
    cEnter = 0;
    cPCEnter = 0;

    iGCPtr = -1;
    iGCLPPtr = -1;
    iPCPtr = -1;
    iPCSSUpdate = 0;

    fFiring = false;

    // Defer cycle tables
    pvmUpdateDSRoot = NULL;
    pvmLayoutRoot = NULL;
    pdaPC = NULL;
    pdaGC = NULL;
    pdaGCLP = NULL;

    HRESULT hr;

    hr = ValueMap<Element*,BYTE>::Create(11, &pvmUpdateDSRoot);   // Update desired size trees pending
    if (FAILED(hr))
        goto Failed;

    hr = ValueMap<Element*,BYTE>::Create(11, &pvmLayoutRoot);     // Layout trees pending
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<PCRecord>::Create(32, false, &pdaPC);       // Property changed database
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<GCRecord>::Create(32, false, &pdaGC);       // Group changed database
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<GCRecord>::Create(32, false, &pdaGCLP);     // Low priority group changed database
    if (FAILED(hr))
        goto Failed;

    return S_OK;

Failed:

    if (pvmUpdateDSRoot)
    {
        pvmUpdateDSRoot->Destroy();
        pvmUpdateDSRoot = NULL;
    }
    if (pvmLayoutRoot)
    {
        pvmLayoutRoot->Destroy();
        pvmLayoutRoot = NULL;
    }
    if (pdaPC)
    {
        pdaPC->Destroy();
        pdaPC = NULL;
    }
    if (pdaGC)
    {
        pdaGC->Destroy();
        pdaGC = NULL;
    }
    if (pdaGCLP)
    {
        pdaGCLP->Destroy();
        pdaGCLP = NULL;
    }

    return hr;
}

DeferCycle::~DeferCycle()
{
    if (pdaGCLP)
        pdaGCLP->Destroy();
    if (pdaGC)
        pdaGC->Destroy();
    if (pdaPC)
        pdaPC->Destroy();
    if (pvmLayoutRoot)
        pvmLayoutRoot->Destroy();
    if (pvmUpdateDSRoot)
        pvmUpdateDSRoot->Destroy();
}

void DeferCycle::Reset()
{
    // Return to initial state for reuse
    fFiring = false;

    iGCPtr = -1;
    if (pdaGC)
        pdaGC->Reset();

    iGCLPPtr = -1;
    if (pdaGCLP)
        pdaGCLP->Reset();
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\layout.cpp ===
/*
 * Layout
 */

#include "stdafx.h"
#include "core.h"

#include "duilayout.h"

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Base layout

// Not shareable by default

////////////////////////////////////////////////////////
// Callbacks from clients

HRESULT Layout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    Layout* pl = HNew<Layout>();
    if (!pl)
        return E_OUTOFMEMORY;

    pl->Initialize();

    *ppLayout = pl;

    return S_OK;
}

void Layout::Initialize()
{
    _peClient = NULL;
    _pdaIgnore = NULL;
    SetCacheDirty();
}

Layout::~Layout()
{
    if (_pdaIgnore)
        _pdaIgnore->Destroy();
}

void Layout::UpdateLayoutRect(Element* pec, int cxContainer, int cyContainer, Element* peChild, int xElement, int yElement, int cxElement, int cyElement)
{
    UNREFERENCED_PARAMETER(cyContainer);

    if (pec->IsRTL())
        xElement = cxContainer - (xElement + cxElement);

    peChild->_UpdateLayoutPosition(xElement, yElement);
    peChild->_UpdateLayoutSize(cxElement, cyElement);
}

void Layout::DoLayout(Element* pec, int dWidth, int dHeight)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(dWidth);
    UNREFERENCED_PARAMETER(dHeight);
}

SIZE Layout::UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(dConstW);
    UNREFERENCED_PARAMETER(dConstH);
    UNREFERENCED_PARAMETER(psrf);

    SIZE sizeDS;

    ZeroMemory(&sizeDS, sizeof(SIZE));

    return sizeDS;
}

// Helper: Sort Ignore list by index
int __cdecl _IdxCompare(const void* pA, const void* pB)
{
    if ((*((Element**)pA))->GetIndex() == (*((Element**)pB))->GetIndex())
        return 0;
    else if ((*((Element**)pA))->GetIndex() < (*((Element**)pB))->GetIndex())
        return -1;
    else
        return 1;
}

// Layout callbacks happen as a result of OnPropertyChanges, these events
// are deferred if sets happen within an OnPropertyChange (in which case,
// the outter-most set fires the events). A return to steady state happens
// after every set (however, as stated, the events are deferred).
//
// This means that these callbacks may happen as changes happen to the
// context, or after all the changes happen. This is taken into account
// when determining if Elements should be ingored for layout.
//
// May have been Added or Removed as a result of an OnPropertyChanged().
// If this is the case, parent and layout pos state will be updated
// before the events come in (which will call these methods). Both
// methods will update the ignore list (if was not called from OnPropertyChanged(),
// only one method would update the ignore list). All events to update
// the Layout's ignore state will complete before control is returned

// TODO: Investigate using b-search for GetIndexOf is list already sorted
void Layout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    UNREFERENCED_PARAMETER(pec);

    int dLayoutPos;
    bool fReSort = false;

    for (UINT i = 0; i < cCount; i++)
    {
        dLayoutPos = ppeAdd[i]->GetLayoutPos();

        // Check if should ignore
        if (dLayoutPos == LP_Absolute || dLayoutPos == LP_None)
        {
            // Create ignore list if needed
            if (!_pdaIgnore)
                DynamicArray<Element*>::Create(0, false, &_pdaIgnore);

            if (_pdaIgnore && _pdaIgnore->GetIndexOf(ppeAdd[i]) == -1)
            {
                _pdaIgnore->Add(ppeAdd[i]);
                fReSort = true;
            }
        }
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();
}

void Layout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    UNREFERENCED_PARAMETER(pec);

    int dLayoutPos;
    bool fReSort = false;

    for (UINT i = 0; i < cCount; i++)
    {
        dLayoutPos = ppeRemove[i]->GetLayoutPos();

        // Check if was ignored
        if (dLayoutPos == LP_Absolute || dLayoutPos == LP_None)
        {
            DUIAssert(_pdaIgnore, "Layout ignore list unavailable in remove");

            if (_pdaIgnore)
            {
                int dIgnIdx = _pdaIgnore->GetIndexOf(ppeRemove[i]);
                if (dIgnIdx != -1)
                {
                    _pdaIgnore->Remove(dIgnIdx);
                    fReSort = true;
                }
            }
        }
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();
}

void Layout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    UNREFERENCED_PARAMETER(pec);

    DUIAssert(dOldLP != dNewLP, "Should not be receiving layout pos change if old and new are the same");

    //DUITrace("LayoutPos Change!\n");

    //DUITrace("Currently being ignored:\n");
    //for (UINT i = 0; i < _daIgnore.GetSize(); i++)
    //    DUITrace("%d\n", _daIgnore.GetItem(i)->GetIndex());

    bool fReSort = false;

    // Check if was ignored
    if (dOldLP == LP_Absolute || dOldLP == LP_None)
    {
        DUIAssert(_pdaIgnore, "Layout ignore list unavailable in remove");

        if (_pdaIgnore)
        {
            int dIgnIdx = _pdaIgnore->GetIndexOf(peChanged);
            if (dIgnIdx != -1)
            {
                _pdaIgnore->Remove(dIgnIdx);
                fReSort = true;
            }
        }
    }

    // Check if should ignore
    if (dNewLP == LP_Absolute || dNewLP == LP_None)
    {
        // Create ignore list if needed
        if (!_pdaIgnore)
            DynamicArray<Element*>::Create(0, false, &_pdaIgnore);

        if (_pdaIgnore && _pdaIgnore->GetIndexOf(peChanged) == -1)
            _pdaIgnore->Add(peChanged);
            fReSort = true;
    }

    // List must stay sorted by Element index for mapping lookup
    if (fReSort)
        _pdaIgnore->Sort(_IdxCompare);

    SetCacheDirty();

    //DUITrace("Now being ignored:\n");
    //for (UINT i = 0; i < _daIgnore.GetSize(); i++)
    //    DUITrace("%d\n", _daIgnore.GetItem(i)->GetIndex());
}

void Layout::Attach(Element* pec)
{
    DUIAssert(!_peClient, "Multiple clients not yet supported");

    _peClient = pec;

    SetCacheDirty();
}

void Layout::Detach(Element* pec)
{
    UNREFERENCED_PARAMETER(pec);

    _peClient = NULL;

    if (_pdaIgnore)
        _pdaIgnore->Reset();

    SetCacheDirty();
}

////////////////////////////////////////////////////////
// Client query methods (omits absolute children)

UINT Layout::GetLayoutChildCount(Element* pec)
{
    Value* pv;

    ElementList* peList = pec->GetChildren(&pv);

    // Less absolute children
    UINT dCount = 0;
    if (peList)
    {
        dCount = peList->GetSize();
        if (_pdaIgnore)
            dCount -= _pdaIgnore->GetSize();
    }

    pv->Release();

    return dCount;
}

int Layout::GetLayoutIndexFromChild(Element* pec, Element* peChild)
{
    UNREFERENCED_PARAMETER(pec);

    DUIAssert(peChild->GetParent() == pec, "Not a child of specified parent");

    int iLayoutIdx = peChild->GetIndex();

    if (_pdaIgnore && _pdaIgnore->GetSize())
    {   
        UINT i = 0;
        while (i < _pdaIgnore->GetSize() && _pdaIgnore->GetItem(i)->GetIndex() <= iLayoutIdx)
        {
            i++;
        }

        iLayoutIdx -= i;
    }

    return iLayoutIdx;
}

Element* Layout::GetChildFromLayoutIndex(Element* pec, int iLayoutIdx, ElementList* peList)
{
    Value* pvChildren = NULL;

    // If no child list supplied, get
    if (!peList)
        peList = pec->GetChildren(&pvChildren);

    int iIndex = iLayoutIdx;

    if (_pdaIgnore && _pdaIgnore->GetSize())
    {
        UINT i = 0;
        while (i < _pdaIgnore->GetSize() && _pdaIgnore->GetItem(i)->GetIndex() <= iIndex)
        {
            iIndex++;
            i++;
        }
    }

    Element* peChild = NULL;

    if ((UINT)iIndex < peList->GetSize())
        peChild = peList->GetItem(iIndex);

    if (pvChildren)
        pvChildren->Release();

    return peChild;
}

Element* Layout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    UNREFERENCED_PARAMETER(pec);
    UNREFERENCED_PARAMETER(peFrom);
    UNREFERENCED_PARAMETER(iNavDir);
    UNREFERENCED_PARAMETER(pnr);
    UNREFERENCED_PARAMETER(bKeyable);

    return GA_NOTHANDLED;
}

BOOL NavScoring::TrackScore(Element* pe, Element* peChild)
{
    Value* pvValue;
    POINT const* ppt = pe->GetLocation(&pvValue);
    int iCheckLow = ((int const*) ppt)[iBaseIndex];
    pvValue->Release();
    SIZE const* psize = pe->GetExtent(&pvValue);
    int iCheckHigh = iCheckLow + ((int const* ) psize)[iBaseIndex];
    pvValue->Release();

    if (iCheckLow < iLow)
        iCheckLow = iLow;

    if (iCheckHigh > iHigh)
        iCheckHigh = iHigh;
    
    int iCheckScore = iCheckHigh - iCheckLow;

    if (iCheckScore > iHighScore)
    {
        iHighScore = iCheckScore;
        peWinner = peChild ? peChild : pe;

        return (iCheckScore > iMajorityScore);
    }

    return FALSE;
}

BOOL NavScoring::Try(Element* peChild, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

    return (peTo) ? TrackScore(peChild, peTo) : FALSE;
}

void NavScoring::Init(Element* peRelative, int iNavDir, NavReference const* pnr)
{
    Element* peRef;
    RECT* prcRef;

    if (pnr)
    {
        peRef = pnr->pe;
        prcRef = pnr->prc;
    }
    else
    {
        peRef = peRelative;
        prcRef = NULL;
    }

    RECT rc;

    if (prcRef)
        rc = *prcRef;
    else
    {
        Value* pvExtent;
        SIZE const* psize = peRef->GetExtent(&pvExtent);

        rc.left   = 0;
        rc.top    = 0;
        rc.right  = psize->cx;
        rc.bottom = psize->cy;
        pvExtent->Release();
    }

    if (peRelative != peRef)
    {
        POINT pt = { 0, 0 };
        peRelative->MapElementPoint(peRef, &pt, &pt);
        rc.top    += pt.y;
        rc.left   += pt.x;
        rc.bottom += pt.y;
        rc.right  += pt.x;
    }

    iBaseIndex = (iNavDir & NAV_VERTICAL) ? 0 : 1;

    iLow  = ((int*) &rc) [iBaseIndex];
    iHigh = ((int*) &rc) [iBaseIndex + 2];
    iMajorityScore = (iHigh - iLow + 1) / 2;
    iHighScore = 0;
    peWinner = NULL;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\render.cpp ===
/*
 * Render
 */

#include "stdafx.h"
#include "core.h"

#include "duielement.h"
#include "duihost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Element rendering (box model)

inline void _ReduceBounds(LPRECT prcTarget, LPCRECT prcAmount)
{
    prcTarget->left += prcAmount->left;

    if (prcTarget->left > prcTarget->right)
        prcTarget->left = prcTarget->right;
    else
    {
        prcTarget->right -= prcAmount->right;

        if (prcTarget->right < prcTarget->left)
            prcTarget->right = prcTarget->left;
    }

    prcTarget->top += prcAmount->top;

    if (prcTarget->top > prcTarget->bottom)
        prcTarget->top = prcTarget->bottom;
    else
    {
        prcTarget->bottom -= prcAmount->bottom;
      
        if (prcTarget->bottom < prcTarget->top)
            prcTarget->bottom = prcTarget->top;    
    }
}

#ifdef GADGET_ENABLE_GDIPLUS

inline void _ReduceBounds(Gdiplus::RectF* prcTarget, LPCRECT prcAmount)
{
    RECT rcTemp;
    rcTemp.left     = (long)prcTarget->X;
    rcTemp.top      = (long)prcTarget->Y;
    rcTemp.right    = (long)(prcTarget->X + prcTarget->Width);
    rcTemp.bottom   = (long)(prcTarget->Y + prcTarget->Height);

    _ReduceBounds(&rcTemp, prcAmount);

    prcTarget->X     = (float)rcTemp.left;
    prcTarget->Y     = (float)rcTemp.top;
    prcTarget->Width = (float)(rcTemp.right - rcTemp.left);
    prcTarget->Height= (float)(rcTemp.bottom - rcTemp.top);
}

inline const Gdiplus::RectF Convert(const RECT* prc)
{
    Gdiplus::RectF rc(
        (float)prc->left, 
        (float)prc->top,
        (float)(prc->right - prc->left),
        (float)(prc->bottom - prc->top));

    return rc;
}

#endif // GADGET_ENABLE_GDIPLUS

inline void _Fill(HDC hDC, HBRUSH hb, int left, int top, int right, int bottom)
{
    RECT rc;
    SetRect(&rc, left, top, right, bottom);
    FillRect(hDC, &rc, hb);
}

void MapRect(Element* pel, const RECT* prc, RECT* prcOut)
{
    if (pel->IsRTL())
    {
        prcOut->left = prc->right;
        prcOut->right = prc->left;
    }
    else
    {
        prcOut->left = prc->left;
        prcOut->right = prc->right;
    }
    prcOut->top = prc->top;
    prcOut->bottom = prc->bottom;
}

int MapAlign(Element* pel, int iAlign)
{
    if (pel->IsRTL())
    {
        if ((iAlign & 0x3) == 0x0) // Left
            iAlign |= 0x2; // Right
        else if ((iAlign & 0x3) == 0x2) // Right
            iAlign &= ~0x2; // Left
    }

    return iAlign;
}

#ifdef GADGET_ENABLE_GDIPLUS

inline void _Fill(Gdiplus::Graphics * pgpgr, Gdiplus::Brush * pgpbr, 
        float left, float top, float right, float bottom)
{
    pgpgr->FillRectangle(pgpbr, left, top, right - left, bottom - top);
}

void _SetupStringFormat(Gdiplus::StringFormat* psf, Element* pel)
{
    // Align
    int dCAlign = MapAlign(pel, pel->GetContentAlign());

    switch (dCAlign & 0x3)  // Lower 2 bits
    {
    case 0x0:   // Left
        psf->SetAlignment(Gdiplus::StringAlignmentNear);
        break;

    case 0x1:   // Center
        psf->SetAlignment(Gdiplus::StringAlignmentCenter);
        break;

    case 0x2:   // Right
        psf->SetAlignment(Gdiplus::StringAlignmentFar);
        break;
    }

    switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
    {
    case 0x0:  // Top
        psf->SetLineAlignment(Gdiplus::StringAlignmentNear);
        break;

    case 0x1:  // Middle
        psf->SetLineAlignment(Gdiplus::StringAlignmentCenter);
        break;

    case 0x2:  // Bottom
        psf->SetLineAlignment(Gdiplus::StringAlignmentFar);
        break;
    }
}


int GetGpFontStyle(Element * pel)
{
    int nRawStyle = pel->GetFontStyle();
    int nWeight = pel->GetFontWeight();
    int nFontStyle = 0;

    if (nWeight <= FW_MEDIUM) {
        // Regular

        if ((nRawStyle & FS_Italic) != 0) {
            nFontStyle = Gdiplus::FontStyleItalic;
        } else {
            nFontStyle = Gdiplus::FontStyleRegular;
        }
    } else {
        // Bold

        if ((nRawStyle & FS_Italic) != 0) {
            nFontStyle = Gdiplus::FontStyleBoldItalic;
        } else {
            nFontStyle = Gdiplus::FontStyleBold;
        }
    }

    if ((nRawStyle & FS_Underline) != 0) {
        nFontStyle |= Gdiplus::FontStyleUnderline;
    } 
    
    if ((nRawStyle & FS_StrikeOut) != 0) {
        nFontStyle |= Gdiplus::FontStyleStrikeout;
    }

    return nFontStyle;
}


inline float GetGpFontHeight(Element * pel)
{
    float flSize = (float) pel->GetFontSize();
    return flSize * 72.0f / 96.0f;
}


#endif // GADGET_ENABLE_GDIPLUS

#define LIGHT       0.5
#define VERYLIGHT   0.8
#define DARK        -0.3
#define VERYDARK    -0.75

// 1 >= fIllum >= -1
inline COLORREF _AdjustBrightness(COLORREF cr, double fIllum)
{
    double r, g, b;

    r = (double)GetRValue(cr);
    g = (double)GetGValue(cr);
    b = (double)GetBValue(cr);

    if (fIllum > 0.0)
    {
        r += (255.0 - r) * fIllum;
        g += (255.0 - g) * fIllum;
        b += (255.0 - b) * fIllum;
    }
    else
    {
        r += r * fIllum;
        g += g * fIllum;
        b += b * fIllum;
    }

    return RGB((int)r, (int)g, (int)b);
}

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Color _AdjustBrightness(Gdiplus::Color cr, double fIllum)
{
    double r, g, b;

    r = (double)cr.GetR();
    g = (double)cr.GetG();
    b = (double)cr.GetB();

    if (fIllum > 0.0)
    {
        r += (255.0 - r) * fIllum;
        g += (255.0 - g) * fIllum;
        b += (255.0 - b) * fIllum;
    }
    else
    {
        r += r * fIllum;
        g += g * fIllum;
        b += b * fIllum;
    }

    return Gdiplus::Color(cr.GetA(), (BYTE)r, (BYTE)g, (BYTE)b);
}

inline Gdiplus::Color AdjustAlpha(Gdiplus::Color cr, BYTE bAlphaLevel)
{
    int aa1 = cr.GetA();
    int aa2 = bAlphaLevel;

    DUIAssert((aa1 <= 255) && (aa2 >= 0), "Ensure valid nA alpha");
    DUIAssert((aa2 <= 255) && (aa2 >= 0), "Ensure valid nB alpha");

    int aaaa = aa1 * aa2 + 0x00FF;
    
    return Gdiplus::Color((BYTE) (aaaa >> 8), cr.GetR(), cr.GetG(), cr.GetB());
}


class AlphaBitmap
{
public:
    AlphaBitmap(Gdiplus::Bitmap * pgpbmp, BYTE bAlphaLevel)
    {
        DUIAssert(pgpbmp != NULL, "Must have a valid bitmap");
        
        m_fDelete       = FALSE;
        m_pgpbmpSrc     = pgpbmp;
        m_bAlphaLevel   = bAlphaLevel;
    }

    ~AlphaBitmap()
    {
        if (m_fDelete) {
            delete m_pgpbmpAlpha;  // Allocated by GDI+ (cannot use HDelete)
        }
    }

    operator Gdiplus::Bitmap *()
    {
        //
        // Create the alpha bitmap on the first request.  This avoids creating
        // the bitmap if it will never be used.
        //
        // When the alpha bitmap has been created, we no longer need the source 
        // bitmap.  By setting this to NULL, we signal that the alpha bitmap is 
        // 'valid' and we won't recompute it.
        //
        
        if (m_pgpbmpSrc != NULL) {
            if (m_bAlphaLevel < 5) {
                //
                // Completely transparent, so nothing to draw.  This is okay, as 
                // Graphics::DrawImage() properly checks if the Image is NULL.
                //

                m_pgpbmpAlpha = NULL;
                m_pgpbmpSrc = NULL;
            } else if (m_bAlphaLevel >= 250) {
                //
                // No alpha being applied, so just use the original bitmap
                //

                m_pgpbmpAlpha = m_pgpbmpSrc;
                m_pgpbmpSrc = NULL;
            } else {
                //
                // Need to build a new bitmap and multiply in the constant 
                // alpha.  We create a 32-bit _P_ARGB bitmap because we can
                // premultiply the alpha channel into the R, G, and B channels
                // more efficiently here than GDI+ can do later, and the work
                // needs to get done.
                //

                Gdiplus::PixelFormat gppf = PixelFormat32bppPARGB;
                Gdiplus::Rect rc(0, 0, (int) m_pgpbmpSrc->GetWidth(), (int) m_pgpbmpSrc->GetHeight());
                m_pgpbmpAlpha = m_pgpbmpSrc->Clone(rc, gppf);

                if (m_pgpbmpAlpha != NULL) {
                    m_fDelete = TRUE;

                    Gdiplus::BitmapData bd;
                    if (m_pgpbmpAlpha->LockBits(&rc, Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeWrite, 
                            gppf, &bd) == Gdiplus::Ok) {

                        BYTE *pRow = (BYTE*) bd.Scan0;
                        DWORD *pCol;
                        Gdiplus::ARGB c;
                        for (int y = 0; y < rc.Height; y++, pRow += bd.Stride) {
                            pCol = (DWORD *) pRow;
                            for (int x = 0; x < rc.Width; x++, pCol++) {
                                //
                                // NOTE: This code is taken from GDI+ and is 
                                // optimized to premultiply a constant alpha
                                // level.
                                //
                                
                                c = *pCol;
                                if ((c & 0xff000000) != 0x00000000) {
                                    Gdiplus::ARGB _00aa00gg = (c >> 8) & 0x00ff00ff;
                                    Gdiplus::ARGB _00rr00bb = (c & 0x00ff00ff);

                                    Gdiplus::ARGB _aaaagggg = _00aa00gg * m_bAlphaLevel + 0x00ff00ff;
                                    _aaaagggg += ((_aaaagggg >> 8) & 0x00ff00ff);

                                    Gdiplus::ARGB _rrrrbbbb = _00rr00bb * m_bAlphaLevel + 0x00ff00ff;
                                    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

                                    c = (_aaaagggg & 0xff00ff00) |
                                           ((_rrrrbbbb >> 8) & 0x00ff00ff);
                                } else {
                                    c = 0;
                                }

                                *pCol = c;
                            }
                        }

                        m_pgpbmpAlpha->UnlockBits(&bd);
                    } else {
                        DUIAssertForce("Unable to lock bits of GpBitmap");
                    }
                    m_pgpbmpSrc = NULL;
                }
            }
        }
        
        return m_pgpbmpAlpha;
    }

protected:
            Gdiplus::Bitmap * 
                        m_pgpbmpSrc;
            Gdiplus::Bitmap * 
                        m_pgpbmpAlpha;
            BOOL        m_fDelete;
            BYTE        m_bAlphaLevel;
};


#endif // GADGET_ENABLE_GDIPLUS

#define ModCtrl  0
#define ModAlt   1
#define ModShift 2
#define ModCount 3

static LPWSTR lpszMods[ModCount] = { L"Ctrl", L"Alt", L"Shift" };
static int maxMod = -1;


// Length (in characters) of modifier strings + ' ' + '(' + 3 chars for '+' after
// each modifier + 1 char for mnemonic + ')'. (I.e "Test (Ctrl+Alt+Shift+O)")
// Covers both the size of the postpended help string, or the added '&' (whichever is used).
int GetMaxMod()
{
    if (maxMod == -1)
        maxMod = (int) (wcslen(lpszMods[ModCtrl]) + wcslen(lpszMods[ModAlt]) + wcslen(lpszMods[ModShift]) + 7);

    return maxMod;
}


void BuildRenderString(LPWSTR pszSrc, LPWSTR pszDst, WCHAR wcShortcut, BOOL* pfUnderline)
{
    BOOL fAllowUnderline = *pfUnderline;
    *pfUnderline = FALSE;

    if ((wcShortcut >= 'a') && (wcShortcut <= 'z'))
        wcShortcut -= 32;

    while (*pszSrc)                    
    {
        WCHAR wc = *pszSrc++;
        if (fAllowUnderline && !*pfUnderline)
        {
            if ((wc - (((wc >= 'a') && (wc <= 'z')) ? 32 : 0)) == wcShortcut)
            {
                *pszDst++ = '&';
                *pfUnderline = TRUE;
            }
        }
        *pszDst++ = wc;
    }

    if (!*pfUnderline)
    {
        *pszDst++ = ' ';
        *pszDst++ = '(';
        if (0)
        {
            LPWSTR pszMod = lpszMods[ModCtrl];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        if (1)
        {
            LPWSTR pszMod = lpszMods[ModAlt];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        if (0)
        {
            LPWSTR pszMod = lpszMods[ModShift];
            while (*pszMod)
                *pszDst++ = *pszMod++;
            *pszDst++ = '+';
        }
        *pszDst++ = wcShortcut;
        *pszDst++ = ')';
    }

    *pszDst = 0;
}
                
inline int _MaxClip(int dNew, int dMax)
{
    return (dNew > dMax) ? dMax : dNew;
}


//
// GDI Rendering
//

// NULL prBorder or prPadding means all-zero sided
// If prcSkipBorder is non-NULL, don't render border, rather, set inner border edges (where the
// background begins) in provided rectangle (thickness is prcBounds and *prcSkipBorder difference)
// If prcSkipContent is non-NULL, don't render content, rather, set content bounds in provided rectangle
void Element::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    //DUITrace(L"Paint <%x>", this);

    RECT rcPaint = *prcBounds;
    HBRUSH hb;
    bool fDelete;

    // Retrieve all rendering parameters and adjust for RTL if needed

    // Background Value
    Value* pvBackgnd = GetValue(BackgroundProp, PI_Specified);

    // Border thickness
    RECT rcBorder;
    SetRectEmpty(&rcBorder);

    if (HasBorder())
    {
        Value* pvBorder = GetValue(BorderThicknessProp, PI_Specified, NULL);
        MapRect(this, pvBorder->GetRect(), &rcBorder);
        pvBorder->Release();
    }

    // Padding thickness
    RECT rcPadding;
    SetRectEmpty(&rcPadding);

    if (HasPadding())
    {
        // Get non-zero padding
        Value* pvPadding = GetValue(PaddingProp, PI_Specified, NULL);
        MapRect(this, pvPadding->GetRect(), &rcPadding);
        pvPadding->Release();
    }

    //
    // Draw border
    // Skip if requested
    //

    // The following restrictions apply:
    //
    //   Only solid colors supported in border rendering
    //   Border rendering skipped if nine-grid background rendering is used

    if (!prcSkipBorder)
    {
        // Before rendering border, check if background type is nine-grid.
        // If so, skip. Border rendering will happen during background painting pass
        if ((pvBackgnd->GetType() != DUIV_GRAPHIC) ||
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGrid) &&
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGridTransColor) &&
            (pvBackgnd->GetGraphic()->BlendMode.dMode != GRAPHIC_NineGridAlphaConstPerPix))
        {
            COLORREF crBase = 0;  // Base color for raised and sunken painting
            RECT rcLessBD;

            // Get border color (Value) (alpha not yet impl)
            hb = NULL;
            fDelete = true;

            // Get border style
            int dBDStyle = GetBorderStyle();

            Value* pvBdrColor = GetValue(BorderColorProp, PI_Specified); 
            switch (pvBdrColor->GetType())
            {
            case DUIV_INT:
                fDelete = false;
                hb = BrushFromEnumI(pvBdrColor->GetInt());
                if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                    crBase = ColorFromEnumI(pvBdrColor->GetInt());
                break;

            case DUIV_FILL:
                {
                    const Fill* pf = pvBdrColor->GetFill();  // Only solid colors supported
                    if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                        hb = CreateSolidBrush(RemoveAlpha(pf->ref.cr));
                    else
                    {
                        crBase = RemoveAlpha(pf->ref.cr);
                        hb = CreateSolidBrush(crBase);
                    }
                }
                break;
            }
            pvBdrColor->Release();

            // Get rect less border
            rcLessBD = rcPaint;
            _ReduceBounds(&rcLessBD, &rcBorder);

            RECT rc;
            switch (dBDStyle)
            {
            case BDS_Solid:  // Solid border
                _Fill(hDC, hb, rcPaint.left, rcLessBD.top, rcLessBD.left, rcLessBD.bottom);    // left
                _Fill(hDC, hb, rcPaint.left, rcPaint.top, rcPaint.right, rcLessBD.top);        // top
                _Fill(hDC, hb, rcLessBD.right, rcLessBD.top, rcPaint.right, rcLessBD.bottom);  // right
                _Fill(hDC, hb, rcPaint.left, rcLessBD.bottom, rcPaint.right, rcPaint.bottom);  // bottom
                /*
                // Paint via clipping
                ElTls* pet = (ElTls*)TlsGetValue(g_dwElSlot);  // Per-thread regions for drawing
                SetRectRgn(pet->hClip0, rcLessBD.left, rcLessBD.top, rcLessBD.right, rcLessBD.bottom);
                SetRectRgn(pet->hClip1, rcPaint.left, rcPaint.top, rcPaint.right, rcPaint.bottom);
                CombineRgn(pet->hClip1, pet->hClip1, pet->hClip0, RGN_DIFF);
                SelectClipRgn(hDC, pet->hClip1);
                FillRect(hDC, &rcPaint, hb);
                SelectClipRgn(hDC, NULL);
                */
                break;

            case BDS_Rounded:   // Rounded rectangle
                //
                // TODO: Implement RoundRect in GDI.  This is more than calling 
                // GDI's RoundRect() since we are using a brush and need to be able to specify
                // a thickness.  To accomplish this, probably build a temporary pen.
                //

                DUIAssertForce("Rounded style not yet supported with GDI");
                break;

            case BDS_Raised:    // Raised border
            case BDS_Sunken:    // Sunken border
                {
                    // Find where etch begins
                    SetRect(&rc, rcBorder.left / 2, rcBorder.top / 2, rcBorder.right / 2, rcBorder.bottom / 2);
                    RECT rcEtch = rcPaint;
                    _ReduceBounds(&rcEtch, &rc);

                    // Create other intensity brushes
                    HBRUSH hbOLT;  // Brush for outter left and top
                    HBRUSH hbORB;  // Brush for outter right and bottom
                    HBRUSH hbILT;  // Brush for inner left top
                    HBRUSH hbIRB;  // Brush for inner right and bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        hbOLT = hb;
                        hbORB = CreateSolidBrush(_AdjustBrightness(crBase, VERYDARK));
                        hbILT = CreateSolidBrush(_AdjustBrightness(crBase, VERYLIGHT));
                        hbIRB = CreateSolidBrush(_AdjustBrightness(crBase, DARK));
                    }
                    else
                    {
                        hbOLT = CreateSolidBrush(_AdjustBrightness(crBase, VERYDARK));
                        hbORB = CreateSolidBrush(_AdjustBrightness(crBase, VERYLIGHT));
                        hbILT = CreateSolidBrush(_AdjustBrightness(crBase, DARK));
                        hbIRB = hb;
                    }

                    // Paint etches
                    _Fill(hDC, hbOLT, rcPaint.left, rcPaint.top, rcEtch.left, rcEtch.bottom);       // Outter left
                    _Fill(hDC, hbOLT, rcEtch.left, rcPaint.top, rcEtch.right, rcEtch.top);          // Outter top
                    _Fill(hDC, hbORB, rcEtch.right, rcPaint.top, rcPaint.right, rcPaint.bottom);    // Outter right
                    _Fill(hDC, hbORB, rcPaint.left, rcEtch.bottom, rcEtch.right, rcPaint.bottom);   // Outter bottom
                    _Fill(hDC, hbILT, rcEtch.left, rcEtch.top, rcLessBD.left, rcLessBD.bottom);     // Inner left
                    _Fill(hDC, hbILT, rcLessBD.left, rcEtch.top, rcLessBD.right, rcLessBD.top);     // Inner top 
                    _Fill(hDC, hbIRB, rcLessBD.right, rcEtch.top, rcEtch.right, rcEtch.bottom);     // Inner right
                    _Fill(hDC, hbIRB, rcEtch.left, rcLessBD.bottom, rcLessBD.right, rcEtch.bottom); // Inner bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        if (hbORB)
                            DeleteObject(hbORB);
                        if (hbILT)
                            DeleteObject(hbILT);
                        if (hbIRB)
                            DeleteObject(hbIRB);
                    }
                    else
                    {
                        if (hbOLT)
                            DeleteObject(hbOLT);
                        if (hbORB)
                            DeleteObject(hbORB);
                        if (hbILT)
                            DeleteObject(hbILT);
                    }
                }
                break;
            }

            // Cleanup
            if (hb && fDelete)
                DeleteObject(hb);

            // New rectangle for painting background
            rcPaint = rcLessBD;
        }
        else
        {
            // Border rendering manually skipped, reduce painting rect by borders
            _ReduceBounds(&rcPaint, &rcBorder);
        }
    }
    else
    {
        // Skipping border render due to outside request, reduce bounds, copy into
        // provided rect, and continue
        _ReduceBounds(&rcPaint, &rcBorder);
        *prcSkipBorder = rcPaint;
    }

    //
    // Draw background
    //

    // All graphic types are used as fills except those marked as stretched, nine-grid and metafiles, 
    // they are drawn to fit.
    //
    // The following restrictions apply:
    //
    //   Icons are not supported in background
    //   Metafiles automaticlly stretch to fit
    //   GRAPHIC_TransColor and GRAPHIC_TrandColorAuto Bitmaps unsupported
    //   GRAPHIC_NoBlend and GRAPHIC_EntireAlpha fill via tiling, per-pixel alpha ignored

    hb = NULL;
    fDelete = true;
    BYTE dAlpha = 255;  // Opaque
    const Fill* pfGradient = NULL;

    switch (pvBackgnd->GetType())
    {
    case DUIV_INT:
        fDelete = false;
        hb = BrushFromEnumI(pvBackgnd->GetInt());
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value
        {
            const Fill* pf = pvBackgnd->GetFill();
            switch (pf->dType)
            {
            case FILLTYPE_Solid:
                dAlpha = GetAValue(pf->ref.cr);
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
                    hb = CreateSolidBrush(RemoveAlpha(pf->ref.cr));
                break;

            case FILLTYPE_HGradient:
            case FILLTYPE_VGradient:
            case FILLTYPE_TriHGradient:
            case FILLTYPE_TriVGradient:
                pfGradient = pvBackgnd->GetFill();
                fDelete = false;
                break;

            case FILLTYPE_DrawFrameControl:
                DrawFrameControl(hDC, &rcPaint, pf->fillDFC.uType, pf->fillDFC.uState);
                dAlpha = 0;  // Bypass fill
                fDelete = false;
                break;

            case FILLTYPE_DrawThemeBackground:
                DrawThemeBackground(pf->fillDTB.hTheme, hDC, pf->fillDTB.iPartId, pf->fillDTB.iStateId, &rcPaint, &rcPaint);
                dAlpha = 0;  // Bypass fill
                fDelete = false;
                break;
            }
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills unsupported
        {
            Graphic* pg = pvBackgnd->GetGraphic();
            
            switch (pg->BlendMode.dImgType)
            {
            case GRAPHICTYPE_Bitmap:
                {
                    switch (pg->BlendMode.dMode)
                    {
                    case GRAPHIC_Stretch:
                        {
                            // Render immediately, no brush is created
                            HBITMAP hbmSrc = GethBitmap(pvBackgnd, IsRTL());
                            HDC hdcSrc = CreateCompatibleDC(hDC);
                            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcSrc, hbmSrc);
                            int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);

                            StretchBlt(hDC, rcPaint.left, rcPaint.top, rcPaint.right - rcPaint.left, rcPaint.bottom - rcPaint.top,
                                       hdcSrc, 0, 0, pg->cx, pg->cy, SRCCOPY);

                            SetStretchBltMode(hDC, nSBMOld);
                            SelectObject(hdcSrc, hbmOld);
                            DeleteDC(hdcSrc);

                            dAlpha = 0;  // Bypass fill
                        }
                        break;

                    case GRAPHIC_NineGrid:
                    case GRAPHIC_NineGridTransColor:
                    case GRAPHIC_NineGridAlphaConstPerPix:
                        {
                            // Render immediately, no brush is created, stretch to bounds
                            NGINFO ng;
                            ZeroMemory(&ng, sizeof(ng));

                            int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);

                            ng.dwSize = sizeof(ng);
                            ng.hdcDest = hDC;
                            ng.eImageSizing = ST_STRETCH;
                            ng.hBitmap = GethBitmap(pvBackgnd, IsRTL());
                            SetRect(&ng.rcSrc, 0, 0, pg->cx, pg->cy);
                            SetRect(&ng.rcDest, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom);
                            CopyRect(&ng.rcClip, &ng.rcDest);
                            //CopyRect(&ng.rcClip, prcInvalid);
                            ng.iSrcMargins[0] = ng.iDestMargins[0] = rcBorder.left;
                            ng.iSrcMargins[1] = ng.iDestMargins[1] = rcBorder.right;
                            ng.iSrcMargins[2] = ng.iDestMargins[2] = rcBorder.top;
                            ng.iSrcMargins[3] = ng.iDestMargins[3] = rcBorder.bottom;

                            if (pg->BlendMode.dMode == GRAPHIC_NineGridTransColor)
                            {
                                ng.dwOptions = DNG_TRANSPARENT;
                                ng.crTransparent = RGB(pg->BlendMode.rgbTrans.r, pg->BlendMode.rgbTrans.g, pg->BlendMode.rgbTrans.b);
                            }
                            else if (pg->BlendMode.dMode == GRAPHIC_NineGridAlphaConstPerPix)
                            {
                                ng.dwOptions = DNG_ALPHABLEND;
                                ng.AlphaBlendInfo.BlendOp = AC_SRC_OVER;
                                ng.AlphaBlendInfo.BlendFlags = 0;
                                ng.AlphaBlendInfo.SourceConstantAlpha = pg->BlendMode.dAlpha;
                                ng.AlphaBlendInfo.AlphaFormat = AC_SRC_ALPHA;
                            }

                            DrawNineGrid(&ng);

                            SetStretchBltMode(hDC, nSBMOld);

                            dAlpha = 0;  // Bypass fill
                        }
                        break;

                    case GRAPHIC_AlphaConst:
                        // Update Alpha value (was initialized to 255: opaque)
                        dAlpha = pg->BlendMode.dAlpha;

                        // If transparent , do not create a bitmap brush for tiling
                        if (dAlpha == 0)
                        {
                            fDelete = false;
                            break;
                        }

                        // Fall though

                    default:
                        // Create a patterned brush
                        hb = CreatePatternBrush(GethBitmap(pvBackgnd, IsRTL()));
                        break;
                    }
                }
                break;

            case GRAPHICTYPE_EnhMetaFile:
                {
                    // Render immediately, no brush is created
                    PlayEnhMetaFile(hDC, GethEnhMetaFile(pvBackgnd, IsRTL()), &rcPaint);
                    dAlpha = 0;  // Bypass fill
                }
                break;

#ifdef GADGET_ENABLE_GDIPLUS
            case GRAPHICTYPE_GpBitmap:
                break;
#endif
            }
        }
        break;
    }

    // Fill using either a gradient or a supplied fill brush
    // Any stretch-based fill has already occured and will force
    // dAlpha to be 0 so that this step is bypassed

    if (!pfGradient)
    {
        if (dAlpha)  // No fill if 0 opacity
        {
            // Use intersection of invalid rect with background fill area
            // (stored in rcPaint) as new fill area
            RECT rcFill;
            IntersectRect(&rcFill, prcInvalid, &rcPaint);

            if (dAlpha == 255)  // Normal fill for opaque
                FillRect(hDC, &rcFill, hb);
            else
                UtilDrawBlendRect(hDC, &rcFill, hb, dAlpha, 0, 0);
        }
    }
    else
    {
        // Gradient background fill
        TRIVERTEX vert[2];
        GRADIENT_RECT gRect;

        vert[0].x = rcPaint.left;
        vert[0].y = rcPaint.top;
        vert[1].x = rcPaint.right;
        vert[1].y = rcPaint.bottom; 

        int i = IsRTL() ? 1 : 0;

        // first vertex
        vert[i].Red   = (USHORT)(GetRValue(pfGradient->ref.cr) << 8);
        vert[i].Green = (USHORT)(GetGValue(pfGradient->ref.cr) << 8);
        vert[i].Blue  = (USHORT)(GetBValue(pfGradient->ref.cr) << 8);
        vert[i].Alpha = (USHORT)(GetAValue(pfGradient->ref.cr) << 8);

        i = 1 - i;

        // second vertex
        vert[i].Red   = (USHORT)(GetRValue(pfGradient->ref.cr2) << 8);
        vert[i].Green = (USHORT)(GetGValue(pfGradient->ref.cr2) << 8);
        vert[i].Blue  = (USHORT)(GetBValue(pfGradient->ref.cr2) << 8);
        vert[i].Alpha = (USHORT)(GetAValue(pfGradient->ref.cr2) << 8);

        gRect.UpperLeft  = 0;
        gRect.LowerRight = 1;

        GradientFill(hDC, vert, 2, &gRect, 1, (pfGradient->dType == FILLTYPE_HGradient) ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V);
    }

    // Clean up brush, if exists
    if (hb && fDelete)
        DeleteObject(hb);

    //
    // Reduce by padding
    //

    _ReduceBounds(&rcPaint, &rcPadding);

    //
    // Content
    //

    // The following restrictions apply:
    //
    //   Only solid colors supported for foreground rendering (graphics unsupported)
    //   
    //   Border rendering skipped if nine-grid background rendering is used
    //   All icons, metafiles, and bimaps (of bitmaps: GRAPHIC_NoBlend,
    //       GRAPHIC_EntireAlpha, GRAPHIC_TransColor, GRAPHIC_TransColorAuto supported)
    //   If destination is smaller than image size, it will be shrinked in all cases

    // Skip content drawing if requested
    if (!prcSkipContent)
    {
        // Draw content (if exists)

        // Get content alignment and map
        int dCAlign = MapAlign(this, GetContentAlign());

        // Render focus rect if requested and if Element is active
        if ((dCAlign & CA_FocusRect) && (GetActive() & AE_Keyboard))
        {
            // Check if should display this keyboard cue
            Element* peRoot = GetRoot();
            if (peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
            {
                if (((HWNDElement*)peRoot)->ShowFocus())
                {
                    RECT rcFocus = rcPaint;
                    
                    int xInset = min(rcPadding.left / 2, rcPadding.right / 2);
                    int yInset = min(rcPadding.top / 2, rcPadding.bottom / 2);
                    
                    rcFocus.left = rcPaint.left - rcPadding.left + xInset; rcFocus.right = rcPaint.right + rcPadding.right - xInset;
                    rcFocus.top  = rcPaint.top - rcPadding.top + yInset;   rcFocus.bottom = rcPaint.bottom + rcPadding.bottom - yInset;
                    
                    IntersectRect(&rcFocus, &rcFocus, prcBounds);
                    DrawFocusRect(hDC, &rcFocus);
                }
            }
        }

        // Foreground is only used during text content rendering (graphics are ignored)
        if (HasContent())
        {
            Value* pvContent = GetValue(ContentProp, PI_Specified);
            switch (pvContent->GetType())
            {
            case DUIV_STRING:
                {
                    LPWSTR pszContent = pvContent->GetString(); 
                    WCHAR wcShortcut = (WCHAR) GetShortcut();
                    BOOL fUnderline = FALSE;
                    if (wcShortcut)
                    {
                        LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                        fUnderline = TRUE;
                        BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                        pszContent = pszNew;
                    }

                    HFONT hFont = NULL;
                    HFONT hOldFont = NULL;

                    int dFontSize = GetFontSize();

                    FontCache* pfc = GetFontCache();
                    if (pfc)
                    {
                        Value* pvFFace;
                        hFont = pfc->CheckOutFont(GetFontFace(&pvFFace), 
                                                  dFontSize, 
                                                  GetFontWeight(), 
                                                  GetFontStyle(),
                                                  0);
                        pvFFace->Release();
                    }

                    if (hFont)
                        hOldFont = (HFONT)SelectObject(hDC, hFont);

                    // Set foreground (graphic is unsupported)
                    Value* pvFore = GetValue(ForegroundProp, PI_Specified); 
                    switch (pvFore->GetType())
                    {
                    case DUIV_INT:
                        // Auto-map if using palettes (PALETTERGB)
                        SetTextColor(hDC, NearestPalColor(ColorFromEnumI(pvFore->GetInt())));
                        break;

                    case DUIV_FILL:
                        // Auto-map if using palettes (PALETTERGB)
                        SetTextColor(hDC, NearestPalColor(RemoveAlpha(pvFore->GetFill()->ref.cr)));  // Map out any Alpha channel, solid colors only
                        break;
                    }
                    pvFore->Release();

                    // Never draw font backgrounds
                    SetBkMode(hDC, TRANSPARENT);

                    // Compensate for font overhang. Clipping rectangle is wider than
                    // painting rectangle (by 1/6 height of font for each side)
                    
                    // NOTE: Since DrawText doesn't allow for a clipping rectangle that's
                    // different than the drawing rectangle, this overhang compension
                    // only works for ExtTextOut (i.e. no wrapping or underlining)
                    RECT rcClip = rcPaint;

                    dFontSize = abs(dFontSize); // Need magnitude

                    RECT rcOverhang;
                    SetRect(&rcOverhang, dFontSize / 6, 0, dFontSize / 6, 0);
                    
                    _ReduceBounds(&rcPaint, &rcOverhang);
                    
                    // Output text
                    // Use faster method if not word wrapping, no prefix chars, and no ellipsis, and not vertically centered
                    if (!IsWordWrap() && !fUnderline && !(dCAlign & CA_EndEllipsis) && (((dCAlign & 0xC) >> 2) != 0x1))
                    {
                        // Setup alignment
                        UINT fMode = 0;
                        int x = 0;
                        int y = 0;
                        
                        switch (dCAlign & 0x3)  // Lower 2 bits
                        {
                        case 0x0:   // Left
                            fMode |= TA_LEFT;
                            x = rcPaint.left;
                            break;
                
                        case 0x1:   // Center
                            fMode |= TA_CENTER;
                            x = (rcPaint.left + rcPaint.right) / 2;
                            break;

                        case 0x2:   // Right
                            fMode |= TA_RIGHT;
                            x = rcPaint.right;
                            break;
                        }
                        
                        switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                        {
                        case 0x0:  // Top
                            fMode |= TA_TOP;
                            y = rcPaint.top;
                            break;

                        case 0x1:  // Middle
                            // Only option is TA_BASELINE, which isn't
                            // accurate for centering vertically
                            break;

                        case 0x2:  // Bottom
                            fMode |= TA_BOTTOM;
                            y = rcPaint.bottom;
                            break;
                        }

                        UINT fOldMode = SetTextAlign(hDC, fMode);

                        ExtTextOutW(hDC, x, y, ETO_CLIPPED | (IsRTL() ? ETO_RTLREADING : 0), &rcClip, pszContent, (UINT)wcslen(pszContent), NULL);

                        // Restore
                        SetTextAlign(hDC, fOldMode);
                    }
                    else
                    {
                        UINT dFlags = fUnderline ? 0 : DT_NOPREFIX;

                        if (IsRTL())
                            dFlags |= DT_RTLREADING;

                        if (dCAlign & CA_EndEllipsis)
                            dFlags |= DT_END_ELLIPSIS;

                        switch (dCAlign & 0x3)  // Lower 2 bits
                        {
                        case 0x0:   // Left
                            dFlags |= DT_LEFT;
                            break;
                
                        case 0x1:   // Center
                            dFlags |= DT_CENTER;
                            break;

                        case 0x2:   // Right
                            dFlags |= DT_RIGHT;
                            break;
                        }

                        switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                        {
                        case 0x0:  // Top
                            dFlags |= (DT_TOP | DT_SINGLELINE);
                            break;

                        case 0x1:  // Middle
                            dFlags |= (DT_VCENTER | DT_SINGLELINE);
                            break;

                        case 0x2:  // Bottom
                            dFlags |= (DT_BOTTOM | DT_SINGLELINE);
                            break;

                        case 0x3:  // Wrap
                            dFlags |= DT_WORDBREAK;
                            break;
                        }

                        //DUITrace("DrawText (%S), x:%d y:%d cx:%d cy:%d\n", pszContent, rcPaint.left, rcPaint.top, 
                        //    rcPaint.right - rcPaint.left, rcPaint.bottom - rcPaint.top);
                
                        DrawTextW(hDC, pszContent, -1, &rcPaint, dFlags);
                    }
     
                    if (hOldFont)
                        SelectObject(hDC, hOldFont);
                    if (pfc)
                        pfc->CheckInFont();
                }
                break;

            case DUIV_GRAPHIC:
            case DUIV_FILL:
                {
                    SIZE sizeContent;

                    if (pvContent->GetType() == DUIV_GRAPHIC)
                    {
                        // DUIV_GRAPHIC
                        Graphic* pgContent = pvContent->GetGraphic();
                        sizeContent.cx = pgContent->cx;
                        sizeContent.cy = pgContent->cy;
                    }
                    else
                    {
                        // DUIV_FILL
                        const Fill* pfContent = pvContent->GetFill();
                        GetThemePartSize(pfContent->fillDTB.hTheme, hDC, pfContent->fillDTB.iPartId, pfContent->fillDTB.iStateId, NULL, TS_TRUE, &sizeContent);
                    }

                    // Clipped image size, shrink when desintation is smaller than image size
                    SIZE sizeDest;
                    sizeDest.cx = _MaxClip(rcPaint.right - rcPaint.left, sizeContent.cx);
                    sizeDest.cy = _MaxClip(rcPaint.bottom - rcPaint.top, sizeContent.cy);

                    // Adjust top/left offset based on content alignment. Bottom/right is not
                    // changed (sizeDest will be used when rendering)

                    switch (dCAlign & 0x3)  // Lower 2 bits
                    {
                    case 0x0:   // Left
                        break;

                    case 0x1:   // Center
                        rcPaint.left += (rcPaint.right - rcPaint.left - sizeDest.cx) / 2;
                        break;

                    case 0x2:   // Right
                        rcPaint.left = rcPaint.right - sizeDest.cx;
                        break;
                    }

                    switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                    {
                    case 0x0:  // Top
                        break;

                    case 0x1:  // Middle
                        rcPaint.top += (rcPaint.bottom - rcPaint.top - sizeDest.cy) / 2;
                        break;

                    case 0x2:  // Bottom
                        rcPaint.top = rcPaint.bottom - sizeDest.cy;
                        break;

                    case 0x3:  // Wrap
                        break;
                    }

                    // Draw
                    if (pvContent->GetType() == DUIV_GRAPHIC)
                    {
                        // DUIV_GRAPHIC
                    
                        Graphic* pgContent = pvContent->GetGraphic();

                        switch (pgContent->BlendMode.dImgType)
                        {
                        case GRAPHICTYPE_Bitmap:
                            {
                                // Draw bitmap
                                HDC hMemDC = CreateCompatibleDC(hDC);
                                SelectObject(hMemDC, GethBitmap(pvContent, IsRTL()));

                                switch (pgContent->BlendMode.dMode)
                                {
                                case GRAPHIC_NoBlend:
                                    if ((sizeDest.cx == pgContent->cx) && (sizeDest.cy == pgContent->cy))
                                        BitBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, SRCCOPY);
                                    else
                                    {
                                        int nSBMOld = SetStretchBltMode(hDC, COLORONCOLOR);
                                        StretchBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy, SRCCOPY);
                                        SetStretchBltMode(hDC, nSBMOld);
                                    }
                                    break;

                                case GRAPHIC_AlphaConst:
                                case GRAPHIC_AlphaConstPerPix:
                                    {
                                        BLENDFUNCTION bf = { static_cast<BYTE>(AC_SRC_OVER), 0, static_cast<BYTE>(pgContent->BlendMode.dAlpha), (pgContent->BlendMode.dMode == GRAPHIC_AlphaConstPerPix) ? static_cast<BYTE>(AC_SRC_ALPHA) : static_cast<BYTE>(0) };
                                        AlphaBlend(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy, bf);
                                    }
                                    break;

                                case GRAPHIC_TransColor:
                                    TransparentBlt(hDC, rcPaint.left, rcPaint.top, sizeDest.cx, sizeDest.cy, hMemDC, 0, 0, pgContent->cx, pgContent->cy,
                                                   RGB(pgContent->BlendMode.rgbTrans.r, pgContent->BlendMode.rgbTrans.g, pgContent->BlendMode.rgbTrans.b));
                                    break;
                                }

                                DeleteDC(hMemDC);
                            }
                            break;

                        case GRAPHICTYPE_Icon:
                            // Draw icon, always shink for destinations that are smaller than image size
                            // Zero width/height denotes draw actual size, don't draw in this case
                            if (sizeDest.cx && sizeDest.cy)
                                DrawIconEx(hDC, rcPaint.left, rcPaint.top, GethIcon(pvContent, IsRTL()), sizeDest.cx, sizeDest.cy, 0, NULL, DI_NORMAL);
                            break;

                        case GRAPHICTYPE_EnhMetaFile:
                            // Draw enhanced metafile

                            // Adjust rest of painting bounds since API doesn't take width/height
                            rcPaint.right = rcPaint.left + sizeDest.cx;
                            rcPaint.bottom = rcPaint.top + sizeDest.cy;
                            
                            PlayEnhMetaFile(hDC, GethEnhMetaFile(pvContent, IsRTL()), &rcPaint);
                            break;

#ifdef GADGET_ENABLE_GDIPLUS
                        case GRAPHICTYPE_GpBitmap:
                            DUIAssertForce("GDI+ bitmaps not yet supported in a GDI tree");
                            break;
#endif // GADGET_ENABLE_GDIPLUS
                        }
                    }
                    else
                    {
                        // DUIV_FILL

                        // Adjust rest of painting bounds since API doesn't take width/height
                        rcPaint.right = rcPaint.left + sizeDest.cx;
                        rcPaint.bottom = rcPaint.top + sizeDest.cy;
                        
                        const Fill* pfContent = pvContent->GetFill();
                        DrawThemeBackground(pfContent->fillDTB.hTheme, hDC, pfContent->fillDTB.iPartId, pfContent->fillDTB.iStateId, &rcPaint, &rcPaint);
                    }
                }
                break;
            }

            pvContent->Release();
        }
    }
    else
    {
        *prcSkipContent = rcPaint;
    }

    // Clean up
    pvBackgnd->Release();
}


//
// GDI+ Rendering
//

#ifdef GADGET_ENABLE_GDIPLUS

struct NGINFOGP
{
    Gdiplus::Graphics * pgpgr;
    Gdiplus::Bitmap *   pgpbmp;
    Gdiplus::RectF      rcDest;
    Gdiplus::RectF      rcSrc;
    RECT                rcMargins;
    SIZINGTYPE          eImageSizing;
    BYTE                bAlphaLevel;
    DWORD               dwOptions;                // subset DrawNineGrid() option flags
};

void StretchNGSection(Gdiplus::Graphics * pgpgr, Gdiplus::Bitmap * pgpbmp,
        const Gdiplus::RectF & rcDest, const Gdiplus::RectF & rcSrc)
{
    if ((rcSrc.Width > 0) && (rcSrc.Height > 0))
    {
        pgpgr->DrawImage(pgpbmp, rcDest, rcSrc.X, rcSrc.Y, rcSrc.Width, rcSrc.Height, Gdiplus::UnitPixel);
    }
}

void CheapDrawNineGrid(NGINFOGP * png)
{
    DUIAssert(png->pgpgr != NULL, "Must have valid Graphics");
    DUIAssert(png->pgpbmp != NULL, "Must have valid Graphics");
    DUIAssert(png->eImageSizing == ST_STRETCH, "Only support stretching");

    // Sources margins
    float lw1, rw1, th1, bh1;
    lw1 = (float) png->rcMargins.left;
    rw1 = (float) png->rcMargins.right;
    th1 = (float) png->rcMargins.top;
    bh1 = (float) png->rcMargins.bottom;

    // Destination margins
    float lw2, rw2, th2, bh2;
    lw2 = (float) png->rcMargins.left;
    rw2 = (float) png->rcMargins.right;
    th2 = (float) png->rcMargins.top;
    bh2 = (float) png->rcMargins.bottom;

    const Gdiplus::RectF & rcSrc = png->rcSrc;
    const Gdiplus::RectF & rcDest = png->rcDest;

    if ((lw1 < 0) || (rw1 < 0) || (th1 < 0) || (bh1 < 0))   // not valid
    {
        DUIAssertForce("Illegal parameters");
        return;
    }

    // Setup an alpha bitmap
    BYTE bAlphaLevel;
    if ((png->dwOptions & DNG_ALPHABLEND) != 0)
        bAlphaLevel = png->bAlphaLevel;
    else
        bAlphaLevel = 255;
    AlphaBitmap bmpAlpha(png->pgpbmp, bAlphaLevel);

    // Optimize when only need to draw the center
    if ((lw1 == 0) && (rw1 == 0) && (th1 == 0) && (bh1 == 0))
    {
        StretchNGSection(png->pgpgr, bmpAlpha, png->rcDest, png->rcSrc);
        return;
    }

    // Draw left side
    if (lw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = lw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = lw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

    // Draw the right side
    if (rw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X + rcSrc.Width - rw1;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = rw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X + rcDest.Width - rw2;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = rw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

    float mw1 = rcSrc.Width - lw1 - rw1;
    float mw2 = rcDest.Width - lw2 - rw2;
    
    if (mw1 > 0)
    {
        Gdiplus::RectF rcSUL, rcSML, rcSLL;
        Gdiplus::RectF rcDUL, rcDML, rcDLL;

        rcSUL.X         = rcSrc.X + lw1;
        rcSUL.Y         = rcSrc.Y;
        rcSUL.Width     = mw1;
        rcSUL.Height    = th1;

        rcSML.X         = rcSUL.X;
        rcSML.Y         = rcSrc.Y + th1;
        rcSML.Width     = rcSUL.Width;
        rcSML.Height    = rcSrc.Height - th1 - bh1;
        
        rcSLL.X         = rcSUL.X;
        rcSLL.Y         = rcSrc.Y + rcSrc.Height - bh1;
        rcSLL.Width     = rcSUL.Width;
        rcSLL.Height    = bh1;

        rcDUL.X         = rcDest.X + lw2;
        rcDUL.Y         = rcDest.Y;
        rcDUL.Width     = mw2;
        rcDUL.Height    = th2;

        rcDML.X         = rcDUL.X;
        rcDML.Y         = rcDest.Y + th2;
        rcDML.Width     = rcDUL.Width;
        rcDML.Height    = rcDest.Height - th2 - bh2;
        
        rcDLL.X         = rcDUL.X;
        rcDLL.Y         = rcDest.Y + rcDest.Height - bh2;
        rcDLL.Width     = rcDUL.Width;
        rcDLL.Height    = bh2;

        StretchNGSection(png->pgpgr, bmpAlpha, rcDUL, rcSUL);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDML, rcSML);
        StretchNGSection(png->pgpgr, bmpAlpha, rcDLL, rcSLL);
    }

}


void GetGpBrush(int c, BYTE bAlphaLevel, Gdiplus::Brush ** ppgpbr, bool * pfDelete)
{
    //
    // We don't cache GDI+ brushes for the system colors, so we need to create 
    // them here.  We also need to account for the alpha-level, so we can't
    // always use the cached brushes.
    //

    Gdiplus::Brush * pgpbr;
    bool fDelete;
    
    if (IsOpaque(bAlphaLevel))
    {
        if (IsSysColorEnum(c)) 
        {
            pgpbr = new Gdiplus::SolidBrush(ConvertSysColorEnum(c));
            fDelete = true;
        }
        else
        {
            pgpbr = GetStdColorBrushF(c);
            fDelete = false;
        }
    }
    else
    {
        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(ColorFromEnumF(c), bAlphaLevel));
        fDelete = true;
    }

    *ppgpbr = pgpbr;
    *pfDelete = fDelete;
}


void Element::Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prcSkipBorder, Gdiplus::RectF* prcSkipContent)
{
    UNREFERENCED_PARAMETER(prcInvalid);

    Gdiplus::RectF rcPaint = *prcBounds;
    Gdiplus::Brush * pgpbr;
    bool fDelete;
    Value* pv;

    //
    // Setup deep state to use when rendering the tree
    //

    if (IsRoot()) 
    {
        pgpgr->SetTextRenderingHint(Gdiplus::TextRenderingHintAntiAlias);
    }


    // Border thickness
    RECT rcBorder;
    SetRectEmpty(&rcBorder);
    if (HasBorder())
    {
        Value* pvBorder = GetValue(BorderThicknessProp, PI_Specified, NULL);
        MapRect(this, pvBorder->GetRect(), &rcBorder);
        pvBorder->Release();
    }


    //
    // Compute the constant alpha level that will be used when rendering this 
    // sub-tree.
    //
    
    float flAlphaLevel = GetTreeAlphaLevel();
    BYTE bAlphaLevel = (BYTE) (flAlphaLevel * 255.0f);
    if (IsTransparent(bAlphaLevel)) {
        //
        // Completely transparent, so nothing to draw
        //

        goto CleanUp;
    }


    // Draw border (if exists)
    if (!prcSkipBorder)
    {
        if (HasBorder())
        {
            Gdiplus::Color crBase = 0;  // Base color for raised and sunken painting

            // Get border color (Value) (alpha not yet impl)
            pgpbr = NULL;
            fDelete = true;

            // Get border style
            int dBDStyle = GetBorderStyle();

            pv = GetValue(BorderColorProp, PI_Specified); 
            switch (pv->GetType())
            {
            case DUIV_INT:
                GetGpBrush(pv->GetInt(), bAlphaLevel, &pgpbr, &fDelete);
                if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                    crBase = ColorFromEnumF(pv->GetInt());
                break;

            case DUIV_FILL:
                {
                    const Fill* pf = pv->GetFill();  // Only solid colors supported
                    if ((dBDStyle == BDS_Raised) || (dBDStyle == BDS_Sunken))
                        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(Convert(pf->ref.cr), bAlphaLevel));
                    else
                    {
                        crBase = Convert(pf->ref.cr);
                        pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(crBase, bAlphaLevel));
                    }
                }
                break;
            }
            pv->Release();

            // Get rect less border
            Gdiplus::RectF rcLessBD = rcPaint;
            _ReduceBounds(&rcLessBD, &rcBorder);

            float flLessX2  = rcLessBD.X + rcLessBD.Width;
            float flLessY2  = rcLessBD.Y + rcLessBD.Height;
            float flPaintX2 = rcPaint.X + rcPaint.Width;
            float flPaintY2 = rcPaint.Y + rcPaint.Height;


            switch (dBDStyle)
            {
            case BDS_Solid:     // Solid border
                _Fill(pgpgr, pgpbr, rcPaint.X, rcLessBD.Y, rcLessBD.X, flLessY2); // left
                _Fill(pgpgr, pgpbr, rcPaint.X, rcPaint.Y, flPaintX2, rcLessBD.Y); // top
                _Fill(pgpgr, pgpbr, flLessX2, rcLessBD.Y, flPaintX2, flLessY2);   // right
                _Fill(pgpgr, pgpbr, rcPaint.X, flLessY2, flPaintX2, flPaintY2);   // bottom
                break;

            case BDS_Rounded:   // Rounded rectangle
                {
                    //
                    // Setup rendering mode
                    //

                    Gdiplus::SmoothingMode gpsm = pgpgr->GetSmoothingMode();
                    pgpgr->SetSmoothingMode(Gdiplus::SmoothingModeHighQuality);

                    Gdiplus::SizeF sizePen((float) rcBorder.left, (float) rcBorder.top);
                    Gdiplus::SizeF sizeCornerEdge(sizePen.Width + 1.0f, sizePen.Height + 1.0f);
                    Gdiplus::SizeF sizeCornerShadow(sizePen.Width + 3.0f, sizePen.Height + 3.0f);


                    //
                    // Draw shadow
                    //

                    Gdiplus::Color crShadow(40, 0, 0, 0);
                    Gdiplus::SolidBrush gpbrShadow(AdjustAlpha(crShadow, bAlphaLevel));
                    Gdiplus::RectF rcShadow;
                    rcShadow.X      = rcPaint.X + (float) rcBorder.left;
                    rcShadow.Y      = rcPaint.Y + (float) rcBorder.top;
                    rcShadow.Width  = rcPaint.Width - (float) rcBorder.left - 1.0f;
                    rcShadow.Height = rcPaint.Height - (float) rcBorder.top - 1.0f;

                    DUser::RenderUtil::FillRoundRect(pgpgr, &gpbrShadow, rcShadow, sizeCornerShadow);

                    
                    //
                    // Draw border
                    //

                    Gdiplus::Pen gppen(pgpbr, min(sizePen.Width, sizePen.Height));
                    DUser::RenderUtil::DrawRoundRect(pgpgr, &gppen, rcLessBD, sizeCornerEdge, DUser::RenderUtil::baOutside);


                    //
                    // Clean-up
                    //

                    pgpgr->SetSmoothingMode(gpsm);
                }
                break;

            case BDS_Raised:    // Raised border
            case BDS_Sunken:    // Sunken border
                {
                    // Find where etch begins
                    RECT rc;
                    SetRect(&rc, rcBorder.left / 2, rcBorder.top / 2, rcBorder.right / 2, rcBorder.bottom / 2);
                    Gdiplus::RectF rcEtch = rcPaint;
                    _ReduceBounds(&rcEtch, &rc);

                    // Create other intensity brushes
                    Gdiplus::Brush * pgpbrOLT;  // Brush for outter left and top
                    Gdiplus::Brush * pgpbrORB;  // Brush for outter right and bottom
                    Gdiplus::Brush * pgpbrILT;  // Brush for inner left top
                    Gdiplus::Brush * pgpbrIRB;  // Brush for inner right and bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        pgpbrOLT = pgpbr;
                        pgpbrORB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYDARK), bAlphaLevel));
                        pgpbrILT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYLIGHT), bAlphaLevel));
                        pgpbrIRB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, DARK), bAlphaLevel));
                    }
                    else
                    {
                        pgpbrOLT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYDARK), bAlphaLevel));
                        pgpbrORB = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, VERYLIGHT), bAlphaLevel));
                        pgpbrILT = new Gdiplus::SolidBrush(AdjustAlpha(_AdjustBrightness(crBase, DARK), bAlphaLevel));
                        pgpbrIRB = pgpbr;
                    }

                    // Paint etches
                    float flEtchX2  = rcEtch.X + rcEtch.Width;
                    float flEtchY2  = rcEtch.Y + rcEtch.Height;

                    _Fill(pgpgr, pgpbrOLT, rcPaint.X, rcPaint.Y, rcEtch.X, flEtchY2);   // Outter left
                    _Fill(pgpgr, pgpbrOLT, rcEtch.X, rcPaint.Y, flEtchX2, rcEtch.Y);    // Outter top
                    _Fill(pgpgr, pgpbrORB, flEtchX2, rcPaint.Y, flPaintX2, flPaintY2);  // Outter right
                    _Fill(pgpgr, pgpbrORB, rcPaint.X, flEtchY2, flEtchX2, flPaintY2);   // Outter bottom
                    _Fill(pgpgr, pgpbrILT, rcEtch.X, rcEtch.Y, rcLessBD.X, flLessY2);   // Inner left
                    _Fill(pgpgr, pgpbrILT, rcLessBD.X, rcEtch.Y, flLessX2, rcLessBD.Y); // Inner top 
                    _Fill(pgpgr, pgpbrIRB, flLessX2, rcEtch.Y, flEtchX2, flEtchY2);     // Inner right
                    _Fill(pgpgr, pgpbrIRB, rcEtch.X, flLessY2, flLessX2, flEtchY2);     // Inner bottom

                    if (dBDStyle == BDS_Raised)
                    {
                        if (pgpbrORB)
                            delete pgpbrORB;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrILT)
                            delete pgpbrILT;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrIRB)
                            delete pgpbrIRB;  // Allocated by GDI+ (cannot use HDelete)
                    }
                    else
                    {
                        if (pgpbrOLT)
                            delete pgpbrOLT;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrORB)
                            delete pgpbrORB;  // Allocated by GDI+ (cannot use HDelete)
                        if (pgpbrILT)
                            delete pgpbrILT;  // Allocated by GDI+ (cannot use HDelete)
                    }
                }
                break;
            }

            // Cleanup
            if (pgpbr && fDelete)
                delete pgpbr;  // Allocated by GDI+ (cannot use HDelete)

            // New rectangle for painting background
            rcPaint = rcLessBD;
        }
    }
    else
    {
        // Skipping border render, reduce bounds, copy into provided rect, and continue
        if (HasBorder())
        {
            // Get non-zero border
            Value* pvBrdr = GetValue(BorderThicknessProp, PI_Specified, NULL);

            _ReduceBounds(&rcPaint, pvBrdr->GetRect());
            *prcSkipBorder = rcPaint;

            pvBrdr->Release();
        }
        else
        {
            // No border thickness
            *prcSkipBorder = rcPaint;
        }
    }

    // Draw background

    // All graphic types are used as fills except metafiles, they are drawn to fit
    // Icons are not supported in backgrounds
    // TODO: Convert value-based fill logic into a helper function
    pgpbr = NULL;
    fDelete = true;
    BYTE dAlpha = 255;  // Opaque
    const Fill* pfGradient = NULL;

    pv = GetValue(BackgroundProp, PI_Specified); 

    switch (pv->GetType())
    {
    case DUIV_INT:
        GetGpBrush(pv->GetInt(), bAlphaLevel, &pgpbr, &fDelete);
        break;

    case DUIV_FILL:  // Only non-standard colors can have alpha value
        {
            const Fill* pf = pv->GetFill();
            if (pf->dType == FILLTYPE_Solid)
            {
                dAlpha = GetAValue(pf->ref.cr);
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
                {
                    Gdiplus::Color cr(dAlpha, GetRValue(pf->ref.cr),
                            GetGValue(pf->ref.cr), GetBValue(pf->ref.cr));
                    pgpbr = new Gdiplus::SolidBrush(AdjustAlpha(cr, bAlphaLevel));
                }
            }
            else  // Gradient
            {
                pfGradient = pv->GetFill();
                fDelete = false;
            }
        }
        break;

    case DUIV_GRAPHIC:  // Graphic background transparent color fills unsupported
        {
            Graphic* pg = pv->GetGraphic();

            switch (pg->BlendMode.dImgType)
            {
            case GRAPHICTYPE_Bitmap:
                if (pg->BlendMode.dMode == GRAPHIC_AlphaConst)
                    dAlpha = pg->BlendMode.dAlpha;
                if (dAlpha == 0)  // Transparent
                    fDelete = false;
                else
#if 0                
                    hb = CreatePatternBrush(GethBitmap(pv, IsRTL()));
#else
                {
                    // TODO: Support texture brushes
                    // Need to support loading Gdiplus::Bitmap.
                }
#endif
                break;

            case GRAPHICTYPE_EnhMetaFile:
                // Render immediately, no brush is created
#if 0
                PlayEnhMetaFile(hDC, GethEnhMetaFile(pv, IsRTL()), &rcPaint);
#else
                // TODO: Support rendering metafiles
#endif
                dAlpha = 0;  // Bypass fill
                break;

            case GRAPHICTYPE_GpBitmap:
                switch (pg->BlendMode.dMode)
                {
                case GRAPHIC_NineGrid:
                case GRAPHIC_NineGridTransColor:
                    {
                        NGINFOGP ng;
                        ng.pgpgr = pgpgr;
                        ng.eImageSizing = ST_STRETCH;
                        ng.dwOptions = DNG_ALPHABLEND;
                        ng.pgpbmp = GetGpBitmap(pv, IsRTL());
                        ng.rcDest = *prcBounds;
                        ng.rcSrc = Gdiplus::RectF(0, 0, pg->cx, pg->cy);
                        ng.rcMargins = rcBorder;
                        ng.bAlphaLevel = bAlphaLevel;
                        CheapDrawNineGrid(&ng);
                    }
                    break;

                case GRAPHIC_Stretch:
                    {
                        Gdiplus::Bitmap * pgpbmp = GetGpBitmap(pv, IsRTL());
                        pgpgr->DrawImage(AlphaBitmap(pgpbmp, bAlphaLevel), rcPaint);
                    }
                    break;

                case GRAPHIC_AlphaConst:
                    break;

                default:
                    // Create a patterned brush
                    pgpbr = new Gdiplus::TextureBrush(AlphaBitmap(GetGpBitmap(pv, IsRTL()), bAlphaLevel));
                    fDelete = true;
                }
                break;
            }
        }
        break;
    }

    // Fill
    if (!pfGradient)
    {
        if (dAlpha)  // No fill if 0 opacity
        {
            //
            // Not every background mode will build a brush (such as 
            // GRAPHIC_Stretch).  We need to detect this.
            //

            if (pgpbr != NULL) {
                // Use intersection of invalid rect with background fill area
                // (stored in rcPaint) as new fill area
                Gdiplus::RectF rcFill;
                Gdiplus::RectF::Intersect(rcFill, *prcInvalid, rcPaint);
                pgpgr->FillRectangle(pgpbr, rcFill);
            }
        }
    }
    else if ((pfGradient->dType == FILLTYPE_HGradient) || (pfGradient->dType == FILLTYPE_VGradient))
    {
        Gdiplus::RectF lineRect(rcPaint);
        Gdiplus::Color cr1(Convert(pfGradient->ref.cr));
        Gdiplus::Color cr2(Convert(pfGradient->ref.cr2));

        Gdiplus::LinearGradientMode gplgm;
        switch (pfGradient->dType)
        {
        case FILLTYPE_HGradient:
            gplgm = Gdiplus::LinearGradientModeHorizontal;
            break;

        case FILLTYPE_VGradient:
            gplgm = Gdiplus::LinearGradientModeVertical;
            break;

        default:
            DUIAssertForce("Unknown gradient type");
            gplgm = Gdiplus::LinearGradientModeHorizontal;
        }

        Gdiplus::LinearGradientBrush gpbr(lineRect, AdjustAlpha(cr1, bAlphaLevel), AdjustAlpha(cr2, bAlphaLevel), gplgm);
        pgpgr->FillRectangle(&gpbr, rcPaint);
    } 
    else if ((pfGradient->dType == FILLTYPE_TriHGradient) || (pfGradient->dType == FILLTYPE_TriVGradient))
    {
        Gdiplus::RectF lineRect1, lineRect2;
        Gdiplus::Color cr1(Convert(pfGradient->ref.cr));
        Gdiplus::Color cr2(Convert(pfGradient->ref.cr2));
        Gdiplus::Color cr3(Convert(pfGradient->ref.cr3));

        float flHalfWidth = rcPaint.Width / 2 + 0.5f;
        float flHalfHeight = rcPaint.Height / 2 + 0.5f;

        Gdiplus::LinearGradientMode gplgm;
        switch (pfGradient->dType)
        {
        case FILLTYPE_TriHGradient:
            gplgm = Gdiplus::LinearGradientModeHorizontal;
            
            lineRect1.X         = rcPaint.X;
            lineRect1.Y         = rcPaint.Y;
            lineRect1.Width     = flHalfWidth;
            lineRect1.Height    = rcPaint.Height;
            lineRect2.X         = lineRect1.X + flHalfWidth;
            lineRect2.Y         = lineRect1.Y;
            lineRect2.Width     = rcPaint.Width - flHalfWidth;
            lineRect2.Height    = lineRect1.Height;
            break;

        case FILLTYPE_TriVGradient:
            gplgm = Gdiplus::LinearGradientModeVertical;

            lineRect1.X         = rcPaint.X;
            lineRect1.Y         = rcPaint.Y;
            lineRect1.Width     = rcPaint.Width;
            lineRect1.Height    = flHalfHeight;
            lineRect2.X         = lineRect1.X;
            lineRect2.Y         = lineRect1.Y + flHalfHeight;
            lineRect2.Width     = lineRect1.Width;
            lineRect2.Height    = rcPaint.Height - flHalfHeight;
            break;

        default:
            DUIAssertForce("Unknown gradient type");
            gplgm = Gdiplus::LinearGradientModeHorizontal;
        }

        Gdiplus::LinearGradientBrush gpbr1(lineRect1, AdjustAlpha(cr1, bAlphaLevel), AdjustAlpha(cr2, bAlphaLevel), gplgm);
        Gdiplus::LinearGradientBrush gpbr2(lineRect2, AdjustAlpha(cr2, bAlphaLevel), AdjustAlpha(cr3, bAlphaLevel), gplgm);
        pgpgr->FillRectangle(&gpbr1, lineRect1);
        pgpgr->FillRectangle(&gpbr2, lineRect2);
    } 

    if (fDelete && (pgpbr != NULL))
        delete pgpbr;  // Allocated by GDI+ (cannot use HDelete)

    pv->Release();

    // Reduce by padding
    if (HasPadding())
    {
        // Get non-zero padding
        Value* pvPad = GetValue(PaddingProp, PI_Specified, NULL);
        RECT rcPadding;
        MapRect(this, pvPad->GetRect(), &rcPadding);

        _ReduceBounds(&rcPaint, &rcPadding);

        // Done with value
        pvPad->Release();
    }

    // Skip content drawing if requested
    if (!prcSkipContent)
    {
        // Draw content (if exists)

        // Foreground is only used during text content rendering (graphics are ignored)
        if (HasContent())
        {
            Value* pvContent = GetValue(ContentProp, PI_Specified);
            if (pvContent->GetType() == DUIV_STRING)
            {
                LPWSTR pszContent = pvContent->GetString(); 
                WCHAR wcShortcut = (WCHAR) GetShortcut();
                BOOL fUnderline = FALSE;
                if (wcShortcut)
                {
                    LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                    BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                    pszContent = pszNew;
                }


                Value* pvFFace;
                BOOL fShadow = GetFontStyle() & FS_Shadow;

                // TEMPORARY: Properly determine the font
                Gdiplus::Font gpfnt(GetFontFace(&pvFFace), GetGpFontHeight(this), GetGpFontStyle(this), Gdiplus::UnitPoint);
                pvFFace->Release();

                Gdiplus::Color crText;

                // Set foreground (graphic is unsupported)
                Value* pvFore = GetValue(ForegroundProp, PI_Specified); 
                switch (pvFore->GetType())
                {
                case DUIV_INT:
                    // Auto-map if using palettes (PALETTERGB)
                    crText = ColorFromEnumF(pvFore->GetInt());
                    break;

                case DUIV_FILL:
                    // Auto-map if using palettes (PALETTERGB)
                    crText = Convert(pvFore->GetFill()->ref.cr);
                    break;

                default:
                    crText = Gdiplus::Color(0, 0, 0);
                }
                pvFore->Release();

                Gdiplus::SolidBrush gpbr(AdjustAlpha(crText, bAlphaLevel));
                int cch = (int) wcslen(pszContent);

                // Output text
                Gdiplus::StringFormat gpsf(0);
                Gdiplus::StringFormat * pgpsf = NULL;
                if (!IsDefaultCAlign())
                {
                    pgpsf = &gpsf;
                    _SetupStringFormat(pgpsf, this);
                }
                
                if (fShadow)
                {
                    Gdiplus::RectF rcShadow = rcPaint;
                    rcShadow.Offset(2, 2);
                    Gdiplus::SolidBrush gpbrShadow(AdjustAlpha(Gdiplus::Color(60, 0, 0, 0), bAlphaLevel));
                    pgpgr->DrawString(pszContent, cch, &gpfnt, rcShadow, pgpsf, &gpbrShadow);
                }
                pgpgr->DrawString(pszContent, cch, &gpfnt, rcPaint, pgpsf, &gpbr);
            }
            else  // DUIV_GRAPHIC
            {
                Graphic* pgContent = pvContent->GetGraphic();

                // TODO: Stretching

                // Clipped image size
                int dImgWidth = _MaxClip((int) rcPaint.Width, pgContent->cx);
                int dImgHeight = _MaxClip((int) rcPaint.Height, pgContent->cy);

                // Compute alignment
                int dCAlign = MapAlign(this, GetContentAlign());

                switch (dCAlign & 0x3)  // Lower 2 bits
                {
                case 0x0:   // Left
                    break;

                case 0x1:   // Center
                    rcPaint.X += (rcPaint.Width - dImgWidth) / 2;
                    break;

                case 0x2:   // Right
                    rcPaint.X = (rcPaint.X + rcPaint.Width) - dImgWidth;
                    break;
                }

                switch ((dCAlign & 0xC) >> 2)  // Upper 2 bits
                {
                case 0x0:  // Top
                    break;

                case 0x1:  // Middle
                    rcPaint.Y += (rcPaint.Height - dImgHeight) / 2;
                    break;

                case 0x2:  // Bottom
                    rcPaint.Y = (rcPaint.Y + rcPaint.Height) - dImgHeight;
                    break;

                case 0x3:  // Wrap
                    break;
                }

                switch (pgContent->BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    // TODO: Rendering HBITMAP's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_Icon:
                    // TODO: Rendering HICONS's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    // TODO: Rendering HEMF's using GDI+ is not yet supported
                    break;

                case GRAPHICTYPE_GpBitmap:
                    switch (pgContent->BlendMode.dMode)
                    {
                    case GRAPHIC_NoBlend:
                        pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel),
                                rcPaint.X, rcPaint.Y, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel);
                        break;

                    case GRAPHIC_AlphaConst:
                        // TODO: Alpha-blend the image, per-pixel alpha not yet impl
                        pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel),
                                rcPaint.X, rcPaint.Y, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel);
                        break;

                    case GRAPHIC_TransColor:
                        {
                            Gdiplus::ImageAttributes gpia;
                            Gdiplus::Color cl(pgContent->BlendMode.rgbTrans.r, pgContent->BlendMode.rgbTrans.g, pgContent->BlendMode.rgbTrans.b);
                            Gdiplus::RectF rc(rcPaint.X, rcPaint.Y, (float) dImgWidth, (float) dImgHeight);

                            gpia.SetColorKey(cl, cl);
                            pgpgr->DrawImage(AlphaBitmap(GetGpBitmap(pvContent, IsRTL()), bAlphaLevel), 
                                    rc, 0.0f, 0.0f, (float) dImgWidth, (float) dImgHeight, Gdiplus::UnitPixel, &gpia);
                        }
                        break;
                    }

                    break;
                }
            }

            pvContent->Release();
        }
    }
    else
    {
        *prcSkipContent = rcPaint;
    }

CleanUp:
    ;
}

#endif // GADGET_ENABLE_GDIPLUS

SIZE Element::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    // Size returned must not be greater than constraints. -1 constraint is "auto"
    // Returned size must be >= 0

    SIZE sizeDS;
    ZeroMemory(&sizeDS, sizeof(SIZE));

    // Get content extent, if exists
    if (HasContent())
    {
        Value* pvContent = GetValue(ContentProp, PI_Specified);
        switch (pvContent->GetType())
        {
        case DUIV_STRING:
            {
                LPWSTR pszContent = pvContent->GetString(); 
                WCHAR wcShortcut = (WCHAR) GetShortcut();
                BOOL fUnderline = FALSE;
                if (wcShortcut)
                {
                    LPWSTR pszNew = (LPWSTR) _alloca((wcslen(pszContent) + GetMaxMod() + 1) * sizeof(WCHAR));

                    fUnderline = TRUE;
                    BuildRenderString(pszContent, pszNew, wcShortcut, &fUnderline);
                    pszContent = pszNew;
                }


                Value* pvFFace;

                switch (psrf->GetType())
                {
                case Surface::stDC:
                    {
                        HDC hDC = CastHDC(psrf);
                        HFONT hFont = NULL;
                        HFONT hOldFont = NULL;
                        FontCache* pfc = GetFontCache();

                        int dFontSize = GetFontSize();

                        if (pfc)
                        {
                            hFont = pfc->CheckOutFont(GetFontFace(&pvFFace), 
                                                      dFontSize, 
                                                      GetFontWeight(), 
                                                      GetFontStyle(),
                                                      0);
                            pvFFace->Release();
                        }

                        if (hFont)
                            hOldFont = (HFONT)SelectObject(hDC, hFont);

                        // Get size
                        dFontSize = abs(dFontSize);  // Need magnitude

                        // Overhang correction
                        int dOverhang = (dFontSize / 6) + (dFontSize / 6);  // Make sure rounding is correct for render
                        
                        // Can use faster method as long as we aren't word wrapping or underlining
                        // Alignment and ellipsis ignored (are not relevant to dimension calculations)
                        if (!IsWordWrap() && !fUnderline)
                        {
                            GetTextExtentPoint32W(hDC, pszContent, (int)wcslen(pszContent), &sizeDS);
                        }
                        else
                        {
                            // Adjust for overhang correction
                            RECT rcDS = { 0, 0, dConstW - dOverhang, dConstH };

                            // DrawText returns infinite height if the width is 0 -- make width 1 so that we don't get infinite height
                            if (rcDS.right <= 0)
                                rcDS.right = 1;

                            UINT dFlags = DT_CALCRECT;
                            dFlags |= (fUnderline) ? 0 : DT_NOPREFIX;
                            dFlags |= (IsWordWrap()) ? DT_WORDBREAK : 0;

                            DrawTextW(hDC, pszContent, -1, &rcDS, dFlags);
                            sizeDS.cx = rcDS.right;
                            sizeDS.cy = rcDS.bottom;
                        }

                        // Add on additional width to all text (1/6 font height per size) to compensate
                        // for font overhang, when rendering, this additional space will not be used
                        sizeDS.cx += dOverhang;

                        //DUITrace("String DS (%S), WC:%d: %d,%d\n", pszContent, dConstW, sizeDS.cx, sizeDS.cy);
     
                        if (hOldFont)
                            SelectObject(hDC, hOldFont);
                        if (pfc)
                            pfc->CheckInFont();
                    }
                    break;

#ifdef GADGET_ENABLE_GDIPLUS
                case Surface::stGdiPlus:
                    {
                        Gdiplus::Graphics* pgpgr = CastGraphics(psrf);
                        Gdiplus::Font gpfnt(GetFontFace(&pvFFace), GetGpFontHeight(this), GetGpFontStyle(this), Gdiplus::UnitPoint);
                        pvFFace->Release();

                        int cch = (int)wcslen(pszContent);
                        Gdiplus::StringFormat gpsf(0);
                        _SetupStringFormat(&gpsf, this);

                        if (!IsWordWrap())
                        {
                            Gdiplus::PointF pt;
                            Gdiplus::RectF rcBounds;

                            pgpgr->MeasureString(pszContent, cch, &gpfnt, pt, &gpsf, &rcBounds);
                            sizeDS.cx = ((long)rcBounds.Width) + 1;
                            sizeDS.cy = ((long)rcBounds.Height) + 1;
                        }
                        else 
                        {
                            Gdiplus::SizeF sizeTemp((float)dConstW, (float)dConstH);
                            Gdiplus::SizeF sizeBounds;

                            // DrawText returns infinite height if the width is 0 -- make width 1 so that we don't get infinite height
                            if (dConstW == 0)
                                sizeTemp.Width = 1.0f;

                            pgpgr->MeasureString(pszContent, cch, &gpfnt, sizeTemp, &gpsf, &sizeBounds);
                            sizeDS.cx = ((long)sizeBounds.Width) + 1;
                            sizeDS.cy = ((long)sizeBounds.Height) + 1;
                        }
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS

                default:
                    DUIAssertForce("Unknown surface type");
                }
            }
            break;

        case DUIV_GRAPHIC:
            {
                Graphic* pgContent = pvContent->GetGraphic();
                sizeDS.cx = pgContent->cx;
                sizeDS.cy = pgContent->cy;
            }
            break;

        case DUIV_FILL:
            {
                if (psrf->GetType() == Surface::stDC)
                {
                    // Theme-based fills have a desired size
                    const Fill* pf = pvContent->GetFill();
                    if (pf->dType == FILLTYPE_DrawThemeBackground)
                    {
                        GetThemePartSize(pf->fillDTB.hTheme, CastHDC(psrf), pf->fillDTB.iPartId, pf->fillDTB.iStateId, NULL, TS_TRUE, &sizeDS);
                    }
                }
            }
            break;
        }
        
        pvContent->Release();
    }

    if (sizeDS.cx > dConstW)
        sizeDS.cx = dConstW;

    if (sizeDS.cy > dConstH)
        sizeDS.cy = dConstH;

    return sizeDS;
}

float Element::GetTreeAlphaLevel()
{
    float flAlpha = 1.0f;
    
    Element * peCur = this;
    while (peCur != NULL)
    {
        float flCur = (peCur->GetAlpha() / 255.0f);
        flAlpha = flAlpha * flCur;
        peCur = peCur->GetParent();
    }

    return flAlpha;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\sheet.cpp ===
/*
 * Sheet
 */

#include "stdafx.h"
#include "core.h"

#include "duisheet.h"

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// PropertySheet

HRESULT PropertySheet::Create(OUT PropertySheet** ppSheet)
{
    *ppSheet = NULL;

    PropertySheet* ps = HNew<PropertySheet>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppSheet = ps;

    return S_OK;
}

HRESULT PropertySheet::Initialize()
{
    HRESULT hr;
    
    _pdaSharedCond = NULL;
    _pDB = NULL;
    _pCIIdxMap = NULL;

    hr = DynamicArray<Cond*>::Create(0, false, &_pdaSharedCond);
    if (FAILED(hr))
        goto Failed;

    // Pointer to an array of Records, indexed by unique class index
    _pDB = (Record*)HAllocAndZero(g_iGlobalCI * sizeof(Record));
    if (!_pDB)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    _pCIIdxMap = (IClassInfo**)HAlloc(g_iGlobalCI * sizeof(IClassInfo*));
    if (!_pCIIdxMap)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    
    _uRuleId = 0;
    _fImmutable = false;

    return S_OK;

Failed:

    if (_pdaSharedCond)
    {
        _pdaSharedCond->Destroy();
        _pdaSharedCond = NULL;
    }

    if (_pCIIdxMap)
    {
        HFree(_pCIIdxMap);
        _pCIIdxMap = NULL;
    }

    if (_pDB)
    {
        HFree(_pDB);
        _pDB = NULL;
    }

    return hr;
}

PropertySheet::~PropertySheet()
{
    //DUITrace("Destroying PS: <%x>\n", this);

    UINT i;

    // Scan for entries
    if (_pDB)
    {
        PIData* ppid;
        Cond* pc;
        UINT p;
        UINT c;
        for (i = 0; i < g_iGlobalCI; i++)
        {
            // Free PIData
            if (_pDB[i].ppid)
            {
                DUIAssert(_pCIIdxMap[i], "No ClassInfo from global index map");

                // Scan PIDatas (one per propertyinfo for class)
                for (p = 0; p < _pCIIdxMap[i]->GetPICount(); p++)
                {
                    ppid = _pDB[i].ppid + p;
                
                    // Free condition maps
                    if (ppid->pCMaps)
                    {
                        // Release all held values in maps
                        for (c = 0; c < ppid->cCMaps; c++)
                        {
                            // Conditional values used in conditional map
                            pc = ppid->pCMaps[c].pConds;
                            while (pc->ppi && pc->pv)  // Release all values in conditionals
                            {
                                pc->pv->Release();
                                pc++;
                            }
                            
                            // Conditional Map value
                            ppid->pCMaps[c].pv->Release();  // Value cannot be NULL (AddRule)
                        }

                        HFree(ppid->pCMaps);
                    }

                    // Free dependents propertyinfo list
                    if (ppid->pDeps)
                        HFree(ppid->pDeps);
                } 

                // Free PIData array for class type
                HFree(_pDB[i].ppid);
            }

            // Free scope list
            if (_pDB[i].ss.pDeps)
                HFree(_pDB[i].ss.pDeps);
        }

        // Free PIData pointer array
        HFree(_pDB);
    }

    if (_pCIIdxMap)
        HFree(_pCIIdxMap);

    // Free shared conditional arrays
    if (_pdaSharedCond)
    {
        for (i = 0; i < _pdaSharedCond->GetSize(); i++)
            HFree(_pdaSharedCond->GetItem(i));

        _pdaSharedCond->Destroy();
    }
}

////////////////////////////////////////////////////////
// Rule addition and helpers

// Helper: Get the unique class-relative index of property
inline UINT _GetClassPIIndex(PropertyInfo* ppi)
{
    IClassInfo* pciBase = ppi->_pciOwner->GetBaseClass();
    return (pciBase ? pciBase->GetPICount() : 0) + ppi->_iIndex;
}

// Helper: Duplicate conditionals of rule, including zero terminator
inline Cond* _CopyConds(Cond* pConds)
{
    if (!pConds)
        return NULL;

    // Count
    UINT c = 0;
    while (pConds[c].ppi && pConds[c].pv)  // Either with NULL value marks terminator
        c++;

    // Copy terminator
    c++;

    Cond* pc = (Cond*)HAlloc(c * sizeof(Cond));
    if (pc)
        CopyMemory(pc, pConds, c * sizeof(Cond));

    return pc;  // Must be freed with HFree
}

// Helper: Compute specificity of conditionals given rule id that it appears in
// pConds may be NULL (no conditions)
// RuleID clipped to 16-bit
inline UINT _ComputeSpecif(Cond* pConds, IClassInfo* pci, UINT uRuleId)
{   
    UNREFERENCED_PARAMETER(pci);

    DUIAssert(pci, "Univeral rules unsupported");

    // Clip to 8-bits
    BYTE cId = 0;   // Id property count
    BYTE cAtt = 0;  // Property count

    // Count properties
    if (pConds)
    {
        Cond* pc = pConds;
        while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
        {
            if (pc->ppi == Element::IDProp)
                cId++;

            cAtt++;

            pc++;
        }
    }

    // Build specificity
    return (cId << 24) | (cAtt << 16) | (USHORT)uRuleId;
}

// Helper: Add entry in Conditional to Value mapping list at specified PIData
// pConds is not duplicated, Value will be AddRef'd. pConds may be NULL (no conditions)
inline HRESULT _AddCondMapping(PIData* ppid, Cond* pConds, UINT uSpecif, Value* pv)
{
    // Increase list by one
    if (ppid->pCMaps)
    {
        //pr->pCMaps = (CondMap*)HReAlloc(pr->pCMaps, (pr->cCMaps + 1) * sizeof(CondMap));
        CondMap* pNewMaps = (CondMap*)HReAlloc(ppid->pCMaps, (ppid->cCMaps + 1) * sizeof(CondMap));
        if (!pNewMaps)
            return E_OUTOFMEMORY;

        ppid->pCMaps = pNewMaps;
    }
    else
    {
        ppid->pCMaps = (CondMap*)HAlloc((ppid->cCMaps + 1) * sizeof(CondMap));
        if (!ppid->pCMaps)
            return E_OUTOFMEMORY;
    }

    // Move to new map
    CondMap* pcm = ppid->pCMaps + ppid->cCMaps;

    // Set entry

    // Conditionals
    pcm->pConds = pConds;

    Cond* pc = pConds;
    while (pc->ppi && pc->pv)  // Add ref all values in conditionals
    {
        pc->pv->AddRef();
        pc++;
    }

    // Value (add ref)
    pcm->pv = pv;
    pcm->pv->AddRef();

    // Specificity
    pcm->uSpecif = uSpecif;

    ppid->cCMaps++;

    return S_OK;
}

// Helper: Checks if a given propertyinfo exists in a propertyinfo array
// pPIList may be NULL
inline bool _IsPIInList(PropertyInfo* ppi, PropertyInfo** pPIList, UINT cPIList)
{
    if (!pPIList)
        return false;

    for (UINT i = 0; i < cPIList; i++)
        if (ppi == pPIList[i])
            return true;

    return false;
}

// Helper: Add entries in Dependency list at specified dependency list
// All PropertyInfos in declarations will be added to list (pDecls must be non-NULL, NULL terminated)
inline HRESULT _AddDeps(DepList* pdl, Decl* pDecls)
{
    Decl* pd = pDecls;
    while (pd->ppi && pd->pv)  // Either with NULL value marks terminator
    {
        if (!_IsPIInList(pd->ppi, pdl->pDeps, pdl->cDeps))
        {
            // Increase list by one
            if (pdl->pDeps)
            {
                //pdl->pDeps = (PropertyInfo**)HReAlloc(pdl->pDeps, (pdl->cDeps + 1) * sizeof(PropertyInfo*));
                PropertyInfo** pNewDeps = (PropertyInfo**)HReAlloc(pdl->pDeps, (pdl->cDeps + 1) * sizeof(PropertyInfo*));
                if (!pNewDeps)
                    return E_OUTOFMEMORY;

                pdl->pDeps = pNewDeps;
            }
            else
            {
                pdl->pDeps = (PropertyInfo**)HAlloc((pdl->cDeps + 1) * sizeof(PropertyInfo*));
                if (!pdl->pDeps)
                    return E_OUTOFMEMORY;
            }
            
            // Move to new entry
            PropertyInfo** pppi = pdl->pDeps + pdl->cDeps;

            // Set entry
            *pppi = pd->ppi;

            pdl->cDeps++;
        }

        pd++;
    }

    return S_OK;
}

// Setup database for constant time lookups, conditionals and declarations are NULL terminated
// pConds and pDecls may be NULL
HRESULT PropertySheet::AddRule(IClassInfo* pci, Cond* pConds, Decl* pDecls)
{
    DUIAssert(pci, "Invalid parameter: NULL");

    DUIAssert(!_fImmutable, "PropertySheet has been made immutable");

    HRESULT hr;
    bool fPartial = false;
    UINT uSpecif = 0;

    // Members that can result in failure
    Cond* pCondsDup = NULL;

    // Get PIData array based on class index
    PIData* ppid = _pDB[pci->GetGlobalIndex()].ppid;
    DepList* pss = &(_pDB[pci->GetGlobalIndex()].ss);

    // Create PIData list for this type if doesn't exist (one per PropertyInfo for class)
    if (!ppid)
    {
        ppid = (PIData*)HAllocAndZero(pci->GetPICount() * sizeof(PIData));
        if (!ppid)
        {
            hr = E_OUTOFMEMORY;
            goto Failed;
        }

        _pDB[pci->GetGlobalIndex()].ppid = ppid;
        _pCIIdxMap[pci->GetGlobalIndex()] = pci;  // Track matching IClassInfo
    }

    // Setup GetValue quick lookup data structure and sheet property scope

    // Duplicate conditionals for this rule and track pointer (instead of
    // ref counting) for shared usage by every property in this rule for lookup

    pCondsDup = _CopyConds(pConds);
    if (!pCondsDup)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    pConds = pCondsDup;
    
    _pdaSharedCond->Add(pConds);

    // Get specificity
    uSpecif = _ComputeSpecif(pConds, pci, _uRuleId);

    // For every property in declaration list, store a direct mapping between each conditional
    // and the value for the property in the rule that will be used if condition is true.
    // Also, store a list of all properties that this sheet affects (property scope)
    if (pDecls)
    {
        Decl* pd = pDecls;
        while (pd->ppi && pd->pv)  // Either with NULL value marks terminator
        {
            // GetValue table
            DUIAssert(pci->IsValidProperty(pd->ppi), "Invalid property for class type");
            DUIAssert(pd->ppi->fFlags & PF_Cascade, "Property cannot be used in a Property Sheet declaration");
            DUIAssert(Element::IsValidValue(pd->ppi, pd->pv), "Invalid value type for property");

            hr = _AddCondMapping(ppid + _GetClassPIIndex(pd->ppi), pConds, uSpecif, pd->pv);
            if (FAILED(hr))
                fPartial = true;

            pd++;
        }

        // Property scope list
        hr = _AddDeps(pss, pDecls);
        if (FAILED(hr))
            fPartial = true;
    }

    // Setup GetDependencies quick lookup data structure

    // Go through each conditional of rule and PIData all properties (declarations)
    // it affects due to a change
    if (pConds && pDecls)
    {
        Cond* pc = pConds;
        while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
        {
            DUIAssert(pci->IsValidProperty(pc->ppi), "Invalid property for class type");
            DUIAssert(Element::IsValidValue(pc->ppi, pc->pv), "Invalid value type for property");

            hr = _AddDeps(ppid + _GetClassPIIndex(pc->ppi), pDecls);
            if (FAILED(hr))
                fPartial = true;

            pc++;
        }
    }

    // Increment for next rule
    _uRuleId++;

    return (fPartial) ? DUI_E_PARTIAL : S_OK;

Failed:

    if (pCondsDup)
        HFree(pCondsDup);

    return hr;
}

// Helper: Sort Condition Maps by specificity
int __cdecl _CondMapCompare(const void* pA, const void* pB)
{
    if (((CondMap*)pA)->uSpecif == ((CondMap*)pB)->uSpecif)
        return 0;
    else if (((CondMap*)pA)->uSpecif > ((CondMap*)pB)->uSpecif)
        return -1;
    else
        return 1;
}

void PropertySheet::MakeImmutable()
{
    if (!_fImmutable)
    {
        // Lock sheet
        _fImmutable = true;

        // Sort all conditional maps by specificity
        PIData* ppid;
        UINT p;

        for (UINT i = 0; i < g_iGlobalCI; i++)
        {
            if (_pDB[i].ppid)
            {
                DUIAssert(_pCIIdxMap[i], "No ClassInfo from global index map");

                // Scan PIDatas (one per propertyinfo for class)
                for (p = 0; p < _pCIIdxMap[i]->GetPICount(); p++)
                {
                    ppid = _pDB[i].ppid + p;
                
                    if (ppid->pCMaps)
                    {
                        // Sort
                        qsort(ppid->pCMaps, ppid->cCMaps, sizeof(CondMap), _CondMapCompare);
                    }
                } 
            }
        }
    }
}

////////////////////////////////////////////////////////
// Getting values

// ppi is assumed to be Specified index
Value* PropertySheet::GetSheetValue(Element* pe, PropertyInfo* ppi)
{
    //DUITrace("Querying PS: <%x>\n", this);

    // Get pointer to PIData
    PIData* ppid = _pDB[pe->GetClassInfo()->GetGlobalIndex()].ppid;

    if (ppid)
    {
        // One or more rules exists for this class, jump to the PIData that matches this property
        ppid += _GetClassPIIndex(ppi);

        // Scan conditional-maps for this property (in specificity order) for match
        Cond* pc;
        bool bRes;
        Value* pv;

        for (UINT i = 0; i < ppid->cCMaps; i++)
        {
            bRes = true;  // Assume success

            pc = ppid->pCMaps[i].pConds;
            if (pc)  // Array of conditions for this rule
            {
                // pc is NULL terminated
                while (pc->ppi && pc->pv)  // Either with NULL value marks terminator
                {
                    // Optimize for frequently used values
                    switch (pc->ppi->_iGlobalIndex)
                    {
                    case _PIDX_ID:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetID() == pc->pv->GetAtom()) : (pe->GetID() != pc->pv->GetAtom());
                        break;

                    case _PIDX_MouseFocused:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetMouseFocused() == pc->pv->GetBool()) : (pe->GetMouseFocused() != pc->pv->GetBool());
                        break;

                    case _PIDX_Selected:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetSelected() == pc->pv->GetBool()) : (pe->GetSelected() != pc->pv->GetBool());
                        break;

                    case _PIDX_KeyFocused:
                        bRes = (pc->nLogOp == PSLO_Equal) ? (pe->GetKeyFocused() == pc->pv->GetBool()) : (pe->GetKeyFocused() != pc->pv->GetBool());
                        break;

                    default:
                        {
                        pv = pe->GetValue(pc->ppi, RetIdx(pc->ppi));

                        // Check if false
                        switch (pc->nLogOp)
                        {
                        case PSLO_Equal:
                            bRes = pv->IsEqual(pc->pv);
                            break;

                        case PSLO_NotEqual:
                            bRes = !pv->IsEqual(pc->pv);
                            break;

                        default:
                            DUIAssertForce("Unsupported PropertySheet rule operation");
                            break;
                        }

                        pv->Release();
                        }
                        break;
                    }

                    if (!bRes)  // A condition return false, this rule doesn't apply
                        break;

                    pc++;
                }
            }

            if (bRes)
            {
                // This rule's condition array passed, return value associated with this rule's condmap
                ppid->pCMaps[i].pv->AddRef(); // AddRef for return
                return ppid->pCMaps[i].pv;
            }

            // Rule conditionals didn't match, continue
        }
    }

    // No match
    return Value::pvUnset;
}

////////////////////////////////////////////////////////
// Getting Dependencies

// ppi is assumed to be Retrieval index
void PropertySheet::GetSheetDependencies(Element* pe, PropertyInfo* ppi, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    // Get pointer to PIData
    PIData* ppid = _pDB[pe->GetClassInfo()->GetGlobalIndex()].ppid;

    if (ppid)
    {
        // One or more rules exists for this class, jump to the PIData that matches this property
        ppid += _GetClassPIIndex(ppi);

        // Add all dependents, always Specified index dependencies
        for (UINT i = 0; i < ppid->cDeps; i++)
        {
            Element::_AddDependency(pe, ppid->pDeps[i], PI_Specified, pdr, pdc, phr);
        }
    }
}

////////////////////////////////////////////////////////
// Getting Sheet's scope of influence

// ppi is assumed to be Retrieval index
void PropertySheet::GetSheetScope(Element* pe, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr)
{
    // Get sheet scope struct
    DepList* pss = &(_pDB[pe->GetClassInfo()->GetGlobalIndex()].ss);

    if (pss->pDeps)
    {
        // Add all dependents, always Specified index dependencies
        for (UINT i = 0; i < pss->cDeps; i++)
        {
            Element::_AddDependency(pe, pss->pDeps[i], PI_Specified, pdr, pdc, phr);
        }
    }
}

} // namespace "DirectUI"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\sources.inc ===
!IF 0

    DirectUI Core Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
	..\accessibility.cpp  \
        ..\element.cpp        \
        ..\expression.cpp     \
        ..\host.cpp           \
        ..\layout.cpp         \
        ..\navigation.cpp     \
        ..\property.cpp       \
        ..\proxy.cpp          \
        ..\render.cpp         \
        ..\sheet.cpp          \
        ..\thread.cpp         \
        ..\value.cpp          \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxcore.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\stdafxcore.cpp ===
/*
 * stdafxcore.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_CORE_STDAFX_H_INCLUDED
#define DUI_CORE_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_CORE_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\value.cpp ===
/*
 * Value
 */

#include "stdafx.h"
#include "core.h"

#include "duivalue.h"

#include "duielement.h"
#include "duisheet.h"
#include "duilayout.h"
#include "duiexpression.h"

namespace DirectUI
{

BOOL FlipIcon(HICON hIcon, HICON *phAltIcon);
BOOL FlipBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy);

////////////////////////////////////////////////////////
// Value (immutable with reference count)

Value* Value::CreateInt(int dValue)
{

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_INT;
        pv->_intVal = dValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateBool(bool bValue)
{
    // No need for AddRef of global static objects
    return (bValue) ? Value::pvBoolTrue : Value::pvBoolFalse;
}

Value* Value::CreateElementRef(Element* peValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ELEMENTREF;
        pv->_peVal = peValue;
        pv->_cRef = 1;
    }

    return pv;
}

// Pointer stored, will be deleted on value destruction, made immutable on create
Value* Value::CreateElementList(ElementList* peListValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ELLIST;
        if (peListValue)
            peListValue->MakeImmutable();  // Cannot modify
        pv->_peListVal = peListValue;      // List stored directly
        pv->_cRef = 1;
    }

    return pv;
}

// String is duplicated and freed on value destruction
Value* Value::CreateString(LPCWSTR pszValue, HINSTANCE hResLoad)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_STRING;

        // Assume string to use is one passed in
        LPCWSTR psz = pszValue;

        // If an instance handle in provided, assume loading from resource
        WCHAR szRes[256];
        if (hResLoad)
        {
            ZeroMemory(&szRes, sizeof(szRes));

#if DBG
            int cRead = 0;
            cRead = LoadStringW(hResLoad, (WORD)pszValue, szRes, DUIARRAYSIZE(szRes));
            DUIAssert(cRead, "Could not locate string resource");
#else
            LoadStringW(hResLoad, (WORD)pszValue, szRes, DUIARRAYSIZE(szRes));
#endif
            // Map to resource string
            psz = szRes;
        }

        // Duplicate string and store
        if (psz)
        {
            pv->_pszVal = (LPWSTR)HAlloc((wcslen(psz) + (SIZE_T)1) * sizeof(WCHAR));
            if (pv->_pszVal)
                wcscpy(pv->_pszVal, psz);  // String duplicated and stored
        }
        else
            pv->_pszVal = NULL;

        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreatePoint(int x, int y)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_POINT;
        pv->_ptVal.x = x;
        pv->_ptVal.y = y;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateSize(int cx, int cy)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_SIZE;
        pv->_sizeVal.cx = cx;
        pv->_sizeVal.cy = cy;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateRect(int left, int top, int right, int bottom)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_RECT;
        SetRect(&pv->_rectVal, left, top, right, bottom);
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_Solid;
        pv->_fillVal.ref.cr = cr;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr0, COLORREF cr1, BYTE dType)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = dType;
        pv->_fillVal.ref.cr = cr0;
        pv->_fillVal.ref.cr2 = cr1;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateColor(COLORREF cr0, COLORREF cr1, COLORREF cr2, BYTE dType)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = dType;
        pv->_fillVal.ref.cr = cr0;
        pv->_fillVal.ref.cr2 = cr1;
        pv->_fillVal.ref.cr3 = cr2;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateDFCFill(UINT uType, UINT uState)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_DrawFrameControl;
        pv->_fillVal.fillDFC.uType = uType;
        pv->_fillVal.fillDFC.uState = uState;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateDTBFill(HTHEME hTheme, int iPartId, int iStateId)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal.dType = FILLTYPE_DrawThemeBackground;
        pv->_fillVal.fillDTB.hTheme = hTheme;
        pv->_fillVal.fillDTB.iPartId = iPartId;
        pv->_fillVal.fillDTB.iStateId = iStateId;
        pv->_cRef = 1;
    }

    return pv;
}
    
Value* Value::CreateFill(const Fill & clrSrc)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_FILL;
        pv->_fillVal = clrSrc;
        pv->_cRef = 1;
    }

    return pv;
}


// Pointer stored, will be deleted on value destruction
Value* Value::CreateLayout(Layout* plValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_LAYOUT;
        pv->_plVal = plValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateGraphic(HBITMAP hBitmap, BYTE dBlendMode, UINT dBlendValue, bool bFlip, bool bRTL)
{
    DUIAssert(hBitmap, "Invalid bitmap: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    if (dBlendMode == GRAPHIC_AlphaConstPerPix || dBlendMode == GRAPHIC_NineGridAlphaConstPerPix)
    {
        // Attempt to pre-multiply bitmap if it's a 32-bpp image with a non-zero alpha channel overall.
        // A new bitmap is created on success.
        HBITMAP hAlphaBMP = ProcessAlphaBitmapI(hBitmap);

        // Destroy original bitmap, new process bitmap is in hAlphaBMP
        DeleteObject(hBitmap);

        // Successful processing of a 32bpp alpha image results in a non-NULL hAlphaBMP, this is
        // the bitmap to be used. It's a DIB.
        hBitmap = hAlphaBMP;

        DUIAssert(hBitmap, "Unable to process alpha bitmap");
    }

    if (!hBitmap)
    {
        return NULL;
    }

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hBitmap;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_Bitmap;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_graphicVal.hAltImage = NULL;

        if (pv->_graphicVal.hImage)
        {
            BITMAP bm;
            GetObjectW(pv->_graphicVal.hImage, sizeof(BITMAP), &bm);
            pv->_graphicVal.cx = (USHORT)bm.bmWidth;
            pv->_graphicVal.cy = (USHORT)bm.bmHeight;
        }

        pv->_graphicVal.BlendMode.dMode = dBlendMode;

        switch (dBlendMode)
        {
        case GRAPHIC_NoBlend:
            pv->_graphicVal.BlendMode.dAlpha = 0;       // Unused
            break;

        case GRAPHIC_AlphaConst:
        case GRAPHIC_AlphaConstPerPix:
        case GRAPHIC_NineGridAlphaConstPerPix:
            pv->_graphicVal.BlendMode.dAlpha = (BYTE)dBlendValue;
            break;

        case GRAPHIC_TransColor:
            if (dBlendValue == (UINT)-1 && pv->_graphicVal.hImage)
            {
                // Automatically choose transparent color
                HDC hMemDC = CreateCompatibleDC(NULL);
                if (hMemDC)
                {
                    HBITMAP hOldBm = (HBITMAP)SelectObject(hMemDC, pv->_graphicVal.hImage);
                    dBlendValue = GetPixel(hMemDC, 0, 0);
                    SelectObject(hMemDC, hOldBm);
                    DeleteDC(hMemDC);
                }
            }
            // Fall through

        case GRAPHIC_NineGridTransColor:
            pv->_graphicVal.BlendMode.rgbTrans.r = GetRValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.g = GetGValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.b = GetBValue(dBlendValue);
            break;
        }

        pv->_cRef = 1;
    }

    return pv;
}

#ifdef GADGET_ENABLE_GDIPLUS

Value* Value::CreateGraphic(Gdiplus::Bitmap * pgpbmp, BYTE dBlendMode, UINT dBlendValue, bool bFlip, bool bRTL)
{
    DUIAssert(pgpbmp, "Invalid bitmap: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = pgpbmp;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_GpBitmap;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_graphicVal.hAltImage = NULL;


        if (pv->_graphicVal.hImage)
        {
            pv->_graphicVal.cx = (USHORT)pgpbmp->GetWidth();
            pv->_graphicVal.cy = (USHORT)pgpbmp->GetHeight();
        }

        pv->_graphicVal.BlendMode.dMode = dBlendMode;

        switch (dBlendMode)
        {
        case GRAPHIC_NoBlend:
            pv->_graphicVal.BlendMode.dAlpha = 0;       // Unused
            break;

        case GRAPHIC_AlphaConst:
        case GRAPHIC_AlphaConstPerPix:
            pv->_graphicVal.BlendMode.dAlpha = (BYTE)dBlendValue;
            break;

        case GRAPHIC_TransColor:
            if (dBlendValue == (UINT)-1 && pv->_graphicVal.hImage)
            {
                // Automatically choose transparent color
                Gdiplus::Color cl;
                pgpbmp->GetPixel(0, 0, &cl);
                dBlendValue = cl.ToCOLORREF();
            }
            // Fall through
        case GRAPHIC_NineGridTransColor:
            pv->_graphicVal.BlendMode.rgbTrans.r = GetRValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.g = GetGValue(dBlendValue);
            pv->_graphicVal.BlendMode.rgbTrans.b = GetBValue(dBlendValue);
            break;
        }
        pv->_cRef = 1;
    }

    return pv;
}

#endif // GADGET_ENABLE_GDIPLUS

Value* Value::CreateGraphic(HICON hIcon, bool bFlip, bool bRTL)
{
    DUIAssert(hIcon, "Invalid icon: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

#ifdef GADGET_ENABLE_GDIPLUS

    Gdiplus::Bitmap * pgpbmp = Gdiplus::Bitmap::FromHICON(hIcon);
    if (pgpbmp == NULL) {
        DUIAssertForce("Unable to create GpBitmap from HICON");
        return NULL;
    }

#endif // GADGET_ENABLE_GDIPLUS

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
#ifdef GADGET_ENABLE_GDIPLUS

        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = pgpbmp;
        pv->_graphicVal.hAltImage = NULL;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_GpBitmap;
        pv->_graphicVal.cx = (USHORT)pgpbmp->GetWidth();
        pv->_graphicVal.cy = (USHORT)pgpbmp->GetHeight();

        DeleteObject(hIcon);

#else // GADGET_ENABLE_GDIPLUS

        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hIcon;
        pv->_graphicVal.hAltImage = NULL;
        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_Icon;

        if (pv->_graphicVal.hImage)
        {
            ICONINFO ii;
            GetIconInfo((HICON)pv->_graphicVal.hImage, &ii);

            BITMAP bm;
            GetObjectW(ii.hbmColor, sizeof(BITMAP), &bm);
            pv->_graphicVal.cx = (USHORT)bm.bmWidth;
            pv->_graphicVal.cy = (USHORT)bm.bmHeight;

            DeleteObject(ii.hbmMask);
            DeleteObject(ii.hbmColor);
        }

#endif // GADGET_ENABLE_GDIPLUS

        pv->_graphicVal.BlendMode.dMode = 0;
        pv->_graphicVal.BlendMode.dAlpha = 0;
        pv->_graphicVal.BlendMode.bFlip = bFlip;
        pv->_graphicVal.BlendMode.bRTLGraphic = bRTL;
        pv->_graphicVal.BlendMode.bFreehImage = true;
        pv->_cRef = 1;
    }
#ifdef GADGET_ENABLE_GDIPLUS
    else
    {
        delete pgpbmp;  // Allocated by GDI+ (cannot use HDelete)
    }
#endif // GADGET_ENABLE_GDIPLUS

    return pv;
}

Value* Value::CreateGraphic(HENHMETAFILE hEnhMetaFile, HENHMETAFILE hAltEnhMetaFile)
{
    DUIAssert(hEnhMetaFile, "Invalid metafile: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_GRAPHIC;
        pv->_graphicVal.hImage = hEnhMetaFile;
        pv->_graphicVal.hAltImage = hAltEnhMetaFile;
        pv->_graphicVal.BlendMode.bFlip = true;
        pv->_graphicVal.BlendMode.bRTLGraphic = false;

        if (pv->_graphicVal.hImage)
        {
            ENHMETAHEADER emh;
            GetEnhMetaFileHeader((HENHMETAFILE)pv->_graphicVal.hImage, sizeof(ENHMETAHEADER), &emh);

            pv->_graphicVal.cx = (USHORT)emh.rclBounds.right;
            pv->_graphicVal.cy = (USHORT)emh.rclBounds.bottom;
        }

        pv->_graphicVal.BlendMode.dImgType = GRAPHICTYPE_EnhMetaFile;
        pv->_graphicVal.BlendMode.dMode = 0;
        pv->_graphicVal.BlendMode.dAlpha = 0;
        pv->_graphicVal.BlendMode.bFreehImage = false;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateGraphic(LPCWSTR pszBMP, BYTE dBlendMode, UINT dBlendValue, USHORT cx, USHORT cy, HINSTANCE hResLoad, bool bFlip, bool bRTL)
{
    DUIAssert(pszBMP, "Invalid bitmap name: NULL");

#ifdef GADGET_ENABLE_GDIPLUS

    Gdiplus::Bitmap * pgpbmp;
    if (FAILED(LoadDDBitmap(pszBMP, hResLoad, cx, cy, PixelFormat32bppPARGB, &pgpbmp)))
    {
        DUIAssert(pgpbmp, "Unable to load bitmap");
        return NULL;
    }

    Value* pv = CreateGraphic(pgpbmp, dBlendMode, dBlendValue, bFlip, bRTL);

    if (!pv)
        delete pgpbmp;  // Allocated by GDI+ (cannot use HDelete)

    return pv;

#else // GADGET_ENABLE_GDIPLUS

    // If an instance handle in provided, assume loading from resource

    HBITMAP hBitmap;

    // If loading a bitmap with the per pixel alpha mode, always load as a DIB
    if (dBlendMode == GRAPHIC_AlphaConstPerPix || dBlendMode == GRAPHIC_NineGridAlphaConstPerPix)
    {
        hBitmap = (HBITMAP)LoadImageW(hResLoad, pszBMP, IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION | (hResLoad ? 0 : LR_LOADFROMFILE));       
    }
    else
    {
        // All other types load as a converted device dependent bitmap
        hBitmap = LoadDDBitmap(pszBMP, hResLoad, cx, cy);
    }

    if (!hBitmap)
    {
        DUIAssertForce("Unable to load bitmap");
        return NULL;
    }

    Value* pv = CreateGraphic(hBitmap, dBlendMode, dBlendValue, bFlip, bRTL);

    if (!pv)
        DeleteObject(hBitmap);

    return pv;

#endif
}

Value* Value::CreateGraphic(LPCWSTR pszICO, USHORT cxDesired, USHORT cyDesired, HINSTANCE hResLoad, bool bFlip, bool bRTL)
{
    DUIAssert(pszICO, "Invalid icon name: NULL");

    // If an instance handle in provided, assume loading from resource
    HICON hIcon = (HICON)LoadImageW(hResLoad, pszICO, IMAGE_ICON, cxDesired, cyDesired, hResLoad ? 0 : LR_LOADFROMFILE);
    if (!hIcon)
    {
        DUIAssert(hIcon, "Unable to load icon");
        return NULL;
    }

    Value* pv = CreateGraphic(hIcon, bFlip, bRTL);

    if (!pv)
        DestroyIcon(hIcon);

    return pv;
}

// Pointer stored, will be deleted on value destruction
Value* Value::CreatePropertySheet(PropertySheet* ppsValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_SHEET;
        if (ppsValue)
            ppsValue->MakeImmutable();
        pv->_ppsVal = ppsValue;
        pv->_cRef = 1;
    }

    return pv;
}

// Pointer stored, will be deleted on value destruction
Value* Value::CreateExpression(Expression* pexValue)
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_EXPR;
        pv->_pexVal = pexValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateAtom(LPCWSTR pszValue)
{
    DUIAssert(pszValue, "Invalid string: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_ATOM;
        pv->_atomVal = AddAtomW(pszValue);
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateCursor(HCURSOR hValue)
{
    DUIAssert(hValue, "Invalid cursor: NULL");

    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return NULL;
#endif

    Value* pv = (Value*)psba->Alloc();
    if (pv)
    {
        pv->_dType = DUIV_CURSOR;
        pv->_cursorVal.hCursor = hValue;
        pv->_cRef = 1;
    }

    return pv;
}

Value* Value::CreateCursor(LPCWSTR pszValue)
{
    DUIAssert(pszValue, "Invalid cursor: NULL");

    return CreateCursor(LoadCursorFromFileW(pszValue));
}

// AddRef/Release are inline, extra 0th release logic isn't
void Value::_ZeroRelease()
{
    SBAlloc* psba = GetSBAllocator();
#if 0
    if (!psba)
        return;
#endif

    // Destroy this and any additional memory
    switch (_dType)
    {
    case DUIV_ELLIST:
        if (_peListVal)
            _peListVal->Destroy();
        break;

    case DUIV_STRING:
        if (_pszVal)
            HFree(_pszVal);
        break;

    case DUIV_LAYOUT:
        if (_plVal)
            _plVal->Destroy();
        break;

    case DUIV_GRAPHIC:
        switch (_graphicVal.BlendMode.dImgType)
        {
        case GRAPHICTYPE_Bitmap:
            if (_graphicVal.hImage)
                DeleteObject(_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DeleteObject(_graphicVal.hAltImage);
            break;
        
        case GRAPHICTYPE_Icon:
            if (_graphicVal.hImage)
                DestroyIcon((HICON)_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DestroyIcon((HICON)_graphicVal.hAltImage);
            break;

        case GRAPHICTYPE_EnhMetaFile:
            if (_graphicVal.hImage)
                DeleteEnhMetaFile((HENHMETAFILE)_graphicVal.hImage);
            if (_graphicVal.hAltImage)
                DeleteEnhMetaFile((HENHMETAFILE)_graphicVal.hAltImage);
            break;

#ifdef GADGET_ENABLE_GDIPLUS
        case GRAPHICTYPE_GpBitmap:
            if (_graphicVal.hImage)
                delete (Gdiplus::Bitmap *)_graphicVal.hImage;  // Allocated by GDI+ (cannot use HDelete)
            if (_graphicVal.hAltImage)
                delete (Gdiplus::Bitmap *)_graphicVal.hAltImage;  // Allocated by GDI+ (cannot use HDelete)
            break;
#endif // GADGET_ENABLE_GDIPLUS
        }

        break;

    case DUIV_SHEET:
        if (_ppsVal)
            _ppsVal->Destroy();
        break;

    case DUIV_EXPR:
        if (_pexVal)
            _pexVal->Destroy();
        break;

    case DUIV_ATOM:
        if (_atomVal)
            DUIVerify(DeleteAtom(_atomVal) == 0, "Atom value not found");
        break;
    }                

    psba->Free(this);
}

// Equality
bool Value::IsEqual(Value* pv)
{
    if (pv == this)
        return true;

    if (_dType == pv->_dType)
    {
        switch (_dType)
        {
        case DUIV_INT:
            return _intVal == pv->_intVal;
        case DUIV_BOOL:
            return _boolVal == pv->_boolVal;
        case DUIV_ELEMENTREF:
            return _peVal == pv->_peVal;
        case DUIV_ELLIST:
            if (_peListVal)
                return _peListVal->IsEqual(pv->_peListVal);
            else if (!pv->_peListVal)
                return true;
            break;
        case DUIV_STRING:
            if (_pszVal && pv->_pszVal)
                return wcscmp(_pszVal, pv->_pszVal) == 0;
            else if (!_pszVal && !pv->_pszVal)
                return true;
            break;
        case DUIV_POINT:
            return _ptVal.x == pv->_ptVal.x && _ptVal.y == pv->_ptVal.y;
        case DUIV_SIZE:
            return _sizeVal.cx == pv->_sizeVal.cx && _sizeVal.cy == pv->_sizeVal.cy;
        case DUIV_RECT:
            return EqualRect(&_rectVal, &pv->_rectVal) != 0;
        case DUIV_FILL:
            {
                bool fRes = true;  // Assume true
                
                if (_fillVal.dType == pv->_fillVal.dType)
                {
                    switch (_fillVal.dType)
                    {
                    case FILLTYPE_DrawFrameControl:
                        fRes = (_fillVal.fillDFC.uType == pv->_fillVal.fillDFC.uType) &&
                               (_fillVal.fillDFC.uState == pv->_fillVal.fillDFC.uState);
                        break;

                    case FILLTYPE_DrawThemeBackground:
                        fRes = (_fillVal.fillDTB.hTheme == pv->_fillVal.fillDTB.hTheme) &&
                               (_fillVal.fillDTB.iPartId == pv->_fillVal.fillDTB.iPartId) &&
                               (_fillVal.fillDTB.iStateId == pv->_fillVal.fillDTB.iStateId);
                        break;

                    case FILLTYPE_TriHGradient:
                    case FILLTYPE_TriVGradient:
                        // Check third color ref
                        fRes = _fillVal.ref.cr3 == pv->_fillVal.ref.cr3;
                        
                        // Fall through to check rest of structure

                    default:
                        if (fRes)
                        {
                            fRes = (_fillVal.ref.cr == pv->_fillVal.ref.cr) && 
                                   (_fillVal.ref.cr2 == pv->_fillVal.ref.cr2);
                        }
                        break;
                    }
                }
                else
                    fRes = false;

                return fRes;
            }
         case DUIV_LAYOUT:
            return _plVal == pv->_plVal;
        case DUIV_GRAPHIC:
            return (_graphicVal.hImage    == pv->_graphicVal.hImage) &&   // Same handle means equal
                   (_graphicVal.hAltImage == pv->_graphicVal.hAltImage);  // Same handle means equal
        case DUIV_SHEET:
            return _ppsVal == pv->_ppsVal;
        case DUIV_EXPR:
            return _pexVal == pv->_pexVal;
        case DUIV_ATOM:
            return _atomVal == pv->_atomVal;
        case DUIV_CURSOR:
            return _cursorVal.hCursor == pv->_cursorVal.hCursor;  // Same handles means equal

        default:  // All other types content match doesn't apply
            return true;
        }
    }

    return false;
}

// Conversion
LPWSTR Value::ToString(LPWSTR psz, UINT c)
{
    DUIAssert(psz && c, "Invalid parameters");

    switch (_dType)
    {
    case DUIV_UNAVAILABLE:
        wcsncpy(psz, L"Unavail", c);
        break;
    case DUIV_UNSET:
        wcsncpy(psz, L"Unset", c);
        break;
    case DUIV_NULL:
        wcsncpy(psz, L"Null", c);
        break;
    case DUIV_INT:
        _snwprintf(psz, c, L"%d", _intVal);
        break;
    case DUIV_BOOL:
        _snwprintf(psz, c, L"%s", (_boolVal) ? L"True" : L"False");
        break;
    case DUIV_ELEMENTREF:
        _snwprintf(psz, c, L"El<0x%p>", _peVal);
        break;
    case DUIV_ELLIST:
        _snwprintf(psz, c, L"ElList<%d>", (_peListVal) ? _peListVal->GetSize() : 0);
        break;
    case DUIV_STRING:
        if (_pszVal)
            _snwprintf(psz, c, L"'%s'", _pszVal);
        else
            wcsncpy(psz, L"'(null)'", c);
        break;
    case DUIV_POINT:
        _snwprintf(psz, c, L"Pt<%d,%d>", _ptVal.x, _ptVal.y);
        break;
    case DUIV_SIZE:
        _snwprintf(psz, c, L"Size<%d,%d>", _sizeVal.cx, _sizeVal.cy);
        break;
    case DUIV_RECT:
        _snwprintf(psz, c, L"Rect<%d,%d,%d,%d>", _rectVal.left, _rectVal.top, _rectVal.right, _rectVal.bottom);
        break;
    case DUIV_FILL:
        {
            switch (_fillVal.dType)
            {
            case FILLTYPE_Solid:
                _snwprintf(psz, c, L"ARGB<%d,%d,%d,%d>", GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr));
                break;

            case FILLTYPE_HGradient:
            case FILLTYPE_VGradient:
                _snwprintf(psz, c, L"ARGB0<%d,%d,%d,%d>,ARGB1<%d,%d,%d,%d>", 
                    GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr),
                    GetAValue(_fillVal.ref.cr2), GetRValue(_fillVal.ref.cr2), GetGValue(_fillVal.ref.cr2), GetBValue(_fillVal.ref.cr2));
                break;

            case FILLTYPE_TriHGradient:
            case FILLTYPE_TriVGradient:
                _snwprintf(psz, c, L"ARGB0<%d,%d,%d,%d>,ARGB1<%d,%d,%d,%d>,ARGB2<%d,%d,%d,%d>", 
                    GetAValue(_fillVal.ref.cr), GetRValue(_fillVal.ref.cr), GetGValue(_fillVal.ref.cr), GetBValue(_fillVal.ref.cr),
                    GetAValue(_fillVal.ref.cr2), GetRValue(_fillVal.ref.cr2), GetGValue(_fillVal.ref.cr2), GetBValue(_fillVal.ref.cr2),
                    GetAValue(_fillVal.ref.cr3), GetRValue(_fillVal.ref.cr3), GetGValue(_fillVal.ref.cr3), GetBValue(_fillVal.ref.cr3));
                break;

            case FILLTYPE_DrawFrameControl:
                _snwprintf(psz, c, L"DFCFill<T:%d,S:%d>", _fillVal.fillDFC.uType, _fillVal.fillDFC.uState);
                break;

            case FILLTYPE_DrawThemeBackground:
                _snwprintf(psz, c, L"DTBFill<H:0x%p,P:%d,S:%d>", _fillVal.fillDTB.hTheme, _fillVal.fillDTB.iPartId, _fillVal.fillDTB.iStateId);
                break;

            default:
                wcsncpy(psz, L"Unknown Fill Type", c);
                break;
            }
        }                
        break;
    case DUIV_LAYOUT:
        _snwprintf(psz, c, L"Layout<0x%p>", _plVal);
        break;
    case DUIV_GRAPHIC:
        _snwprintf(psz, c, L"Graphic<0x%p>", _graphicVal.hImage);
        break;
    case DUIV_SHEET:
        _snwprintf(psz, c, L"Sheet<0x%p>", _ppsVal);
        break;
    case DUIV_EXPR:
        _snwprintf(psz, c, L"Expr<0x%p>", _pexVal);
        break;
    case DUIV_ATOM:
        _snwprintf(psz, c, L"ATOM<%d>", _atomVal);
        break;
    case DUIV_CURSOR:
        _snwprintf(psz, c, L"Cursor<0x%p>", _cursorVal.hCursor);
        break;

    default:
        wcsncpy(psz, L"<ToString Unavailable>", c);
        break;
    }

    // Auto-terminate
    *(psz + (c - 1)) = NULL;

    return psz;
}

LPVOID Value::GetImage(bool bGetRTL)
{
    DUIAssert(_dType == DUIV_GRAPHIC, "Invalid value type");

    DUIAssert((_graphicVal.hImage != _graphicVal.hAltImage), "hImage and hAltImage can not be equal!!!");

    if (!_graphicVal.BlendMode.bFlip)
        return _graphicVal.hImage;
    else
    {
        if (_graphicVal.BlendMode.bRTLGraphic != bGetRTL)
        {
            if (_graphicVal.hAltImage == NULL)
            {
                switch (_graphicVal.BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    FlipBitmap((HBITMAP)_graphicVal.hImage, (HBITMAP *)&_graphicVal.hAltImage);
                    break;
        
                case GRAPHICTYPE_Icon:
                    FlipIcon((HICON)_graphicVal.hImage, (HICON *)&_graphicVal.hAltImage);
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    DUIAssertForce("We do not Flip EnhancedMetaFiles you have to provide a flied one");
                    break;
#ifdef GADGET_ENABLE_GDIPLUS
                case GRAPHICTYPE_GpBitmap:
                    {
                        Gdiplus::Bitmap *pgpBitmap = (Gdiplus::Bitmap *)_graphicVal.hImage;
                        Gdiplus::Rect rect(0, 0, pgpBitmap->GetWidth(), pgpBitmap->GetHeight());
                        _graphicVal.hAltImage = pgpBitmap->Clone(rect, PixelFormatDontCare);
                        ((Gdiplus::Bitmap *)_graphicVal.hAltImage)->RotateFlip(Gdiplus::RotateNoneFlipX);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS
                }

                DUIAssert(_graphicVal.hAltImage, "Could not create hAltImage");

                if (_graphicVal.BlendMode.bFreehImage && _graphicVal.hAltImage)
                {
                    switch (_graphicVal.BlendMode.dImgType)
                    {
                    case GRAPHICTYPE_Bitmap:
                        if (_graphicVal.hImage)
                            DeleteObject(_graphicVal.hImage);
                        break;

                    case GRAPHICTYPE_Icon:
                        if (_graphicVal.hImage)
                            DestroyIcon((HICON)_graphicVal.hImage);
                        break;

#ifdef GADGET_ENABLE_GDIPLUS
                    case GRAPHICTYPE_GpBitmap:
                        if (_graphicVal.hImage)
                            delete (Gdiplus::Bitmap *)_graphicVal.hImage;  // Allocated by GDI+ (cannot use HDelete)
                        break;
#endif // GADGET_ENABLE_GDIPLUS
                    }
                    _graphicVal.hImage = NULL;
                }
            }
            return _graphicVal.hAltImage;
        }
        else
        {
            _graphicVal.BlendMode.bFreehImage = false;
            
            if (_graphicVal.hImage == NULL)
            {
                DUIAssertForce("The same image is used for LTR and RTL");
                
                //Get hImage by flipping hAltImage.

                switch (_graphicVal.BlendMode.dImgType)
                {
                case GRAPHICTYPE_Bitmap:
                    FlipBitmap((HBITMAP)_graphicVal.hAltImage, (HBITMAP *)&_graphicVal.hImage);
                    break;
        
                case GRAPHICTYPE_Icon:
                    FlipIcon((HICON)_graphicVal.hAltImage, (HICON *)&_graphicVal.hImage);
                    break;

                case GRAPHICTYPE_EnhMetaFile:
                    DUIAssertForce("We do not Flip EnhancedMetaFiles you have to provide a flied one");
                    break;
#ifdef GADGET_ENABLE_GDIPLUS
                case GRAPHICTYPE_GpBitmap:
                    {
                        Gdiplus::Bitmap *pgpAltBitmap = (Gdiplus::Bitmap *)_graphicVal.hAltImage;
                        Gdiplus::Rect rect(0, 0, pgpAltBitmap->GetWidth(), pgpAltBitmap->GetHeight());
                        _graphicVal.hImage = pgpAltBitmap->Clone(rect, PixelFormatDontCare);
                        ((Gdiplus::Bitmap *)_graphicVal.hImage)->RotateFlip(Gdiplus::RotateNoneFlipX);
                    }
                    break;
#endif // GADGET_ENABLE_GDIPLUS
                }
            }

            DUIAssert(_graphicVal.hImage, "hImage is NULL.");
            
            return _graphicVal.hImage;
        }
    }
}

#define CHECK(EXPR) \
    { if(!(EXPR)) { goto Error; } }

BOOL FlipBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy)
{
    BOOL    bRet = FALSE;
    BOOL	bBltOK = FALSE;
    HBITMAP	hbmCopy = NULL;
    HBITMAP	hbmOldSrc = NULL;
    HBITMAP	hbmOldDst = NULL;
    HDC     hdcSrc = NULL;
    HDC     hdcDst = NULL;
    HDC     hdcScreen = NULL;
    int     cBytes = 0;

    BITMAP bm;
    ::ZeroMemory(&bm, sizeof(bm));

    *phbmCopy = NULL;

    // Base the DC and bitmaps on the screen so that any low fidelity bitmaps
    // will be upgraded to the screen's color depth. For example, a 16 bit color
    // bitmap copied for a 24 bit color screen will upgrade the bitmap to 24
    // bit color.

    hdcScreen = GetDC(NULL);
    CHECK(NULL != hdcScreen);

    // Need a memory DC for the source bitmap

    hdcSrc = CreateCompatibleDC(hdcScreen);
    CHECK(NULL != hdcSrc);

    // Use a memory DC to generate the copy bitmap

    hdcDst = CreateCompatibleDC(hdcScreen);
    CHECK(NULL != hdcDst);

    // Get the BITMAP structure for the source to determine its height and width
    
    cBytes = ::GetObject (hbmSrc, sizeof(BITMAP), &bm);
    CHECK(0 != cBytes);

    // Create an empty bitmap in the destination DC

    hbmCopy = ::CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
    CHECK(NULL != hbmCopy);

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmSrc));
    hbmOldDst = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmCopy));
    
    bBltOK = ::StretchBlt(hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, bm.bmWidth-1, 0, -bm.bmWidth, bm.bmHeight, SRCCOPY);

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmOldSrc));
    hbmCopy = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmOldDst));

    if (bBltOK) {
        *phbmCopy = hbmCopy;
        hbmCopy = NULL;
        bRet = TRUE;
    }

Error:
    if (NULL != hbmCopy)
    {
        DeleteObject(hbmCopy);
    }

    if (NULL != hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    if (NULL != hdcSrc)
    {
        DeleteDC(hdcSrc);
    }

    if (NULL != hdcDst)
    {
        DeleteDC(hdcDst);
    }

    return(bRet);
}

BOOL FlipIcon(HICON hIcon, HICON *phAltIcon)
{
    BOOL bRet = FALSE;
    ICONINFO ii;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmColor = NULL;

    if(hIcon && phAltIcon && GetIconInfo(hIcon, &ii))
    {
        hbmMask = ii.hbmMask;
        hbmColor = ii.hbmColor;
        *phAltIcon = NULL;

        if (FlipBitmap(hbmMask, &ii.hbmMask) &&
            FlipBitmap(hbmColor, &ii.hbmColor))
        {
            *phAltIcon = CreateIconIndirect(&ii);
            bRet = TRUE;
        }

        if (hbmMask)
            DeleteObject(hbmMask);

        if (hbmColor)
            DeleteObject(hbmColor);
        
        if (ii.hbmMask && (ii.hbmMask != hbmMask))
            DeleteObject(ii.hbmMask);

        if (ii.hbmColor && (ii.hbmColor != hbmColor))
            DeleteObject(ii.hbmColor);

    }

    return bRet;
}

// Common values
StaticValue(svUnavailable, DUIV_UNAVAILABLE, 0);
StaticValue(svNull, DUIV_NULL, 0);
StaticValue(svUnset, DUIV_UNSET, 0);
StaticValue(svElementNull, DUIV_ELEMENTREF, NULL);
StaticValue(svElListNull, DUIV_ELLIST, NULL);
StaticValue(svBoolTrue, DUIV_BOOL, true);
StaticValue(svBoolFalse, DUIV_BOOL, false);
StaticValue(svStringNull, DUIV_STRING, NULL);
StaticValue2(svPointZero, DUIV_POINT, 0, 0);
StaticValue2(svSizeZero, DUIV_SIZE, 0, 0);
StaticValue4(svRectZero, DUIV_RECT, 0, 0, 0, 0);
StaticValue(svIntZero, DUIV_INT, 0);
StaticValue(svLayoutNull, DUIV_LAYOUT, NULL);
StaticValue(svSheetNull, DUIV_SHEET, NULL);
StaticValue(svExprNull, DUIV_EXPR, NULL);
StaticValue(svAtomZero, DUIV_ATOM, 0);
StaticValue(svCursorNull, DUIV_CURSOR, NULL);
StaticValueColorSolid(svColorTrans, ARGB(0,0,0,0));

Value* Value::pvUnavailable = (Value*)&svUnavailable;
Value* Value::pvNull        = (Value*)&svNull;
Value* Value::pvUnset       = (Value*)&svUnset;
Value* Value::pvElementNull = (Value*)&svElementNull;
Value* Value::pvElListNull  = (Value*)&svElListNull;
Value* Value::pvBoolTrue    = (Value*)&svBoolTrue;
Value* Value::pvBoolFalse   = (Value*)&svBoolFalse;
Value* Value::pvStringNull  = (Value*)&svStringNull;
Value* Value::pvPointZero   = (Value*)&svPointZero;
Value* Value::pvSizeZero    = (Value*)&svSizeZero;
Value* Value::pvRectZero    = (Value*)&svRectZero;
Value* Value::pvIntZero     = (Value*)&svIntZero;
Value* Value::pvLayoutNull  = (Value*)&svLayoutNull;
Value* Value::pvSheetNull   = (Value*)&svSheetNull;
Value* Value::pvExprNull    = (Value*)&svExprNull;
Value* Value::pvAtomZero    = (Value*)&svAtomZero;
Value* Value::pvCursorNull  = (Value*)&svCursorNull;
Value* Value::pvColorTrans  = (Value*)&svColorTrans;

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\core\thread.cpp ===
/*
 * Thread methods, local storage
 */

#include "stdafx.h"
#include "core.h"

#include "duithread.h"

#include "duielement.h"
#include "duihost.h"

namespace DirectUI
{

#if DBG
// Value small block leak detector
class LeakDetect : public ISBLeak
{
    void AllocLeak(void* pBlock)
    {
        Value* pv = (Value*)pBlock;
        WCHAR sz[2048];
        DUITrace(">> DUIValue Leak! Type: %d, Value: %S, Refs: %d\n", pv->GetType(), pv->ToString(sz, sizeof(sz) / sizeof(WCHAR)), pv->GetRefCount());
    };
};
LeakDetect* g_pldValue = NULL;
#endif

////////////////////////////////////////////////////////
// Initialization and cleanup

BOOL g_fStandardMessaging = FALSE;

inline BOOL IsWhistler()
{
    OSVERSIONINFO ovi;
    ZeroMemory(&ovi, sizeof(ovi));
    ovi.dwOSVersionInfoSize = sizeof(ovi);

    DUIVerify(GetVersionEx(&ovi), "Must always be able to get the version");
    return (ovi.dwMajorVersion >= 5) && (ovi.dwMinorVersion >= 1);
}

// Global locks
// Global parser lock (for yyparse, can only parse 1 Parser context at a time)
Lock* g_plkParser = NULL;

// Application startup/shutdown code (run once)
// This and class registration must be synchronized on a single thread

UINT g_cInitProcessRef = 0;

void ClassMapCleanupCB(void* pKey, IClassInfo* pci)
{
    UNREFERENCED_PARAMETER(pKey);

    //DUITrace("FreeDUIClass: '%S'\n", pci->GetName());
    pci->Destroy();
}

HRESULT InitProcess()
{
    HRESULT hr;

    if (g_cInitProcessRef > 0)
    {
        g_cInitProcessRef++;
        return S_OK;
    }

    // If running on Whistler, use DirectUser's "Standard" messaging mode.
    g_fStandardMessaging = IsWhistler();
    g_iGlobalCI = 1;
    g_iGlobalPI = _PIDX_TOTAL;

    // DirectUI process heap
    g_hHeap = HeapCreate(0, 256 * 1024, 0);
    if (!g_hHeap)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // Thread slot
    g_dwElSlot = TlsAlloc();
    if (g_dwElSlot == -1)
    {
        hr = DU_E_OUTOFKERNELRESOURCES;
        goto Failure;
    }

    // ClassInfo mapping list
    hr = BTreeLookup<IClassInfo*>::Create(true, &Element::pciMap);  // Key is string
    if (FAILED(hr))
        goto Failure;

    // Controls registration
    hr = RegisterAllControls();
    if (FAILED(hr))
        goto Failure;

    // Locks
    g_plkParser = HNew<Lock>();
    if (!g_plkParser)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

#if DBG
    // Leak detection
    g_pldValue = HNew<LeakDetect>();
    if (!g_pldValue)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }
#endif

    g_cInitProcessRef = 1;

    //DUITrace("DUI: Process startup <%x>\n", GetCurrentProcessId());

    return S_OK;

Failure:

#if DBG
    if (g_pldValue)
    {
        HDelete<LeakDetect>(g_pldValue);
        g_pldValue = NULL;
    }
#endif

    if (g_plkParser)
    {
        HDelete<Lock>(g_plkParser);
        g_plkParser = NULL;
    }

    if (Element::pciMap)
    {
        Element::pciMap->Enum(ClassMapCleanupCB);
    
        Element::pciMap->Destroy();
        Element::pciMap = NULL;
    }

    if (g_dwElSlot != -1)
    {
        TlsFree(g_dwElSlot);
        g_dwElSlot = (DWORD)-1;
    }

    if (g_hHeap)
    {
        HeapDestroy(g_hHeap);
        g_hHeap = NULL;
    }

    return hr;
}

HRESULT UnInitProcess()
{
    if (g_cInitProcessRef == 0)
    {
        DUIAssertForce("Mismatched InitProcess/UnInitProcess");
        return E_FAIL;
    }

    if (g_cInitProcessRef > 1)
    {
        g_cInitProcessRef--;
        return S_OK;
    }

#if DBG
    HDelete<LeakDetect>(g_pldValue);
    g_pldValue = NULL;
#endif

    HDelete<Lock>(g_plkParser);
    g_plkParser = NULL;

    // Run through all registered IClassInfo's and destroy
    Element::pciMap->Enum(ClassMapCleanupCB);

    Element::pciMap->Destroy();
    Element::pciMap = NULL;

    TlsFree(g_dwElSlot);
    g_dwElSlot = (DWORD)-1;

    HeapDestroy(g_hHeap);
    g_hHeap = NULL;

    g_cInitProcessRef = 0;

    //DUITrace("DUI: Process shutdown <%x>\n", GetCurrentProcessId());

    return S_OK;
}

#ifdef GADGET_ENABLE_GDIPLUS
long g_fInitGdiplus = FALSE;
#endif

// DirectUI Element data structures are setup per-context, however, context
// affinity cannot be enforced. A new context is created per thread
// initialization. The application must ensure that only a single thread
// is allowed to access Elements in it's context.
HRESULT InitThread()
{
    HRESULT hr;
    ElTls* pet = NULL;

    // Check if process initialized correctly
    if (g_dwElSlot == -1)
    {
        hr = E_FAIL;
        goto Failure;
    }

    // Check if this is a reentrant init
    pet = (ElTls*)TlsGetValue(g_dwElSlot);
    if (pet)
    {
        pet->cRef++;
        return S_OK;
    }

    // Allocate a new context per thread
    pet = (ElTls*)HAllocAndZero(sizeof(ElTls));
    if (!pet)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    TlsSetValue(g_dwElSlot, pet);

    // Small block allocator
#if DBG
    hr = SBAlloc::Create(sizeof(Value), 48, (ISBLeak*)g_pldValue, &pet->psba);
#else
    hr = SBAlloc::Create(sizeof(Value), 48, NULL, &pet->psba);
#endif
    if (FAILED(hr))
        goto Failure;

    // Defer cycle table
    hr = DeferCycle::Create(&pet->pdc);
    if (FAILED(hr))
        goto Failure;

    // Font cache
    hr = FontCache::Create(8, &pet->pfc);
    if (FAILED(hr))
        goto Failure;

    pet->cRef = 1;
    pet->fCoInitialized = false;  // Initially, the thread has not been initialized for COM
    pet->dEnableAnimations = 0;   // Enable animations by default (0 means active)

    // Initialize DirectUser context
    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize = sizeof(ig);
    ig.nThreadMode = IGTM_SEPARATE;
    ig.nMsgMode = g_fStandardMessaging ? IGMM_STANDARD : IGMM_ADVANCED;
    ig.nPerfMode = IGPM_BLEND;

    pet->hCtx = InitGadgets(&ig);
    if (!pet->hCtx)
    {
        hr = GetLastError();
        goto Failure;
    }

    // DirectUser optional components
#ifdef GADGET_ENABLE_GDIPLUS
    if (InterlockedExchange(&g_fInitGdiplus, TRUE) == FALSE) {
        if (!InitGadgetComponent(IGC_GDIPLUS)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Failure;
        }
    }
#endif // GADGET_ENABLE_GDIPLUS


    //DUITrace("DUI: Thread startup <%x|%x:%x>\n", GetCurrentThreadId(), pet->hCtx, g_dwElSlot);  

    return S_OK;

Failure:
    // Failure to fully init thread, back out

    // Destroy per context objects
    if (pet)
    {
        if (pet->pfc)
            pet->pfc->Destroy();
        if (pet->pdc)
            pet->pdc->Destroy();
        if (pet->hCtx)
            DeleteHandle(pet->hCtx);

        HFree(pet);

        TlsSetValue(g_dwElSlot, NULL);
    }

    return hr;
}

HRESULT UnInitThread()
{
    // Check if process initialized correctly
    if (g_dwElSlot == -1)
        return E_FAIL;

    ElTls* pet = (ElTls*)TlsGetValue(g_dwElSlot);

    // Check if this thread has been previously initialized
    if (pet == NULL)
        return DU_E_GENERIC;

    // Check for reentrant uninits
    pet->cRef--;

    if (pet->cRef > 0)
        return S_OK;

    //DUITrace("DUI: Thread shutdown <%x|%x:%x>\n", GetCurrentThreadId(), pet->hCtx, g_dwElSlot);

    // DirectUser context
    DeleteHandle(pet->hCtx);

    // Uninitialize COM if it was previously initialized for this thread
    // (was not automatically initialized on init of thread)
    if (pet->fCoInitialized)
        CoUninitialize();

    // Font cache
    pet->pfc->Destroy();

    // Defer cycle
    pet->pdc->Destroy();

    // Small block allocator
    pet->psba->Destroy();

    HFree(pet);

    TlsSetValue(g_dwElSlot, NULL);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Message pump

void StartMessagePump()
{
    MSG msg;

    // Flush working set
    SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1);

    if (g_fStandardMessaging) 
    {
        while (GetMessageW(&msg, 0, 0, 0) != 0)
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
    else
    {
        while (GetMessageExW(&msg, 0, 0, 0) != 0)
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
}

void StopMessagePump()
{
    PostQuitMessage(0);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\borderlayout.cpp ===
/*
 * BorderLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiborderlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// BorderLayout

struct MARGINFLAGS
{
    bool bLeft   : 1;
    bool bTop    : 1;
    bool bRight  : 1;
    bool bBottom : 1;
};

HRESULT BorderLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT BorderLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    BorderLayout* pbl = HNew<BorderLayout>();
    if (!pbl)
        return E_OUTOFMEMORY;

    pbl->Initialize();

    *ppLayout = pbl;

    return S_OK;
}

void BorderLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _peClientPos = NULL;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void BorderLayout::DoLayout(Element* pec, int cx, int cy)
{
    UINT cChildren = GetLayoutChildCount(pec);

    int x = 0;
    int y = 0;
    int xChild;
    int yChild;
    int cxOrg = cx;
    int cyOrg = cy;
 
    if (cChildren == 0)
        return;

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    RECT rcMargin = { 0 };
    MARGINFLAGS mfSet = { false, false, false, false };
    
    for (UINT i = 0; (i < cChildren) && ((cx > 0) || (cy > 0)); i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        if (peChild == _peClientPos)
            // come back to it after all of the others have been laid out
            continue;

        int iLayoutPos = peChild->GetLayoutPos(); 

        xChild = x;
        yChild = y;
        SIZE sizeChild = *(peChild->GetDesiredSize()); 

        Value* pv;
        const RECT* prcChildMargin = peChild->GetMargin(&pv); 

        if ((iLayoutPos == BLP_Left) || (iLayoutPos == BLP_Right))
        {
            sizeChild.cy = cy;

            if (iLayoutPos == BLP_Left)
            {
                if (mfSet.bLeft)
                {
                    int iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                    if (iMargin > cx)
                        iMargin = cx;

                    xChild += iMargin;
                    x += iMargin;
                    cx -= iMargin;
                }

                rcMargin.left = prcChildMargin->right;
                mfSet.bLeft = true;
            }
            else // (iLayoutPos == BLP_Right)
            {
                if (mfSet.bRight)
                {
                    cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                    if (cx < 0)
                        cx = 0;
                }

                rcMargin.right = prcChildMargin->left;
                mfSet.bRight = true;
            }

            if (mfSet.bTop)
            {
                int iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                if (iMargin > sizeChild.cy)
                    iMargin = sizeChild.cy;

                yChild += iMargin;
                sizeChild.cy -= iMargin;
            }

            if (mfSet.bBottom)
            {
                sizeChild.cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                if (sizeChild.cy < 0)
                    sizeChild.cy = 0;
            }

            if (sizeChild.cx > cx)
            {
                sizeChild.cx = cx;
                cx = 0;
            }
            else
                cx -= sizeChild.cx;

            if (iLayoutPos == BLP_Left)
                x += sizeChild.cx;
            else // (iLayoutPos == BLP_Right)
                xChild += cx;  // child's width has already been subtracted off of cx
        }                    
        else // ((iLayoutPos == BLP_Top) || (iLayoutPos == BLP_Bottom))
        {
            sizeChild.cx = cx;

            if (iLayoutPos == BLP_Top)
            {
                if (mfSet.bTop)
                {
                    int iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                    if (iMargin > cy)
                        iMargin = cy;

                    yChild += iMargin;
                    y += iMargin;
                    cy -= iMargin;
                }

                rcMargin.top = prcChildMargin->bottom;
                mfSet.bTop = true;
            }
            else // (iLayoutPos == BLP_Bottom)
            {
                if (mfSet.bBottom)
                {
                    cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                    if (cy < 0)
                        cy = 0;
                }

                rcMargin.bottom = prcChildMargin->top;
                mfSet.bBottom = true;
            }

            if (mfSet.bLeft)
            {
                int iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                if (iMargin > sizeChild.cx)
                    iMargin = sizeChild.cx;

                xChild += iMargin;
                sizeChild.cx -= iMargin;
            }

            if (mfSet.bRight)
            {
                sizeChild.cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                if (sizeChild.cx < 0)
                    sizeChild.cx = 0;
            }

            if (sizeChild.cy > cy)
            {
                sizeChild.cy = cy;
                cy = 0;
            }
            else
                cy -= sizeChild.cy;


            if (iLayoutPos == BLP_Top)
                y += sizeChild.cy;
            else // (iLayoutPos == BLP_Bottom)
                yChild += cy; // child's height has already been subtracted off of cy
        }

        pv->Release();

        UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, xChild, yChild, sizeChild.cx, sizeChild.cy);
    }

    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
    }

    if (_peClientPos)
    {
        peChild = _peClientPos;

        if ((cx == 0) && (cy == 0))
        {
            UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
        }
        else
        {
            Value* pv;
            const RECT *prcChildMargin = peChild->GetMargin(&pv); 

            int iMargin;

            if (mfSet.bLeft)
            {
                iMargin = (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
                if (iMargin > cx)
                    iMargin = cx;
                x += iMargin;
                cx -= iMargin;
            }

            if (mfSet.bTop)
            {
                iMargin = (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;
                if (iMargin > cy)
                    iMargin = cy;
                y += iMargin;
                cy -= iMargin;
            }

            if (mfSet.bRight)
            {
                cx -= (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;
                if (cx < 0)
                    cx = 0;
            }

            if (mfSet.bBottom)
            {
                cy -= (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;
                if (cy < 0)
                    cy = 0;
            }

            pv->Release();

            UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, x, y, cx, cy);
        }
    }

    pvChildren->Release();
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE BorderLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    // sizeRemaining will shrink to represent remaining width and height as each child is calculated.
    // So, when sizeRemaining reaches zero, we've run out of space.
    // Note that this requires zero in both dimensions, as a zero in one dimension does not mean that we will 
    // always end up with zero remaining in the other dimension.
    UINT cChildren = GetLayoutChildCount(pec);

    // meanwhile, _sizeDesired will grow to represent size needed to layout children
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;

    SIZE sizeRemaining = { cxConstraint, cyConstraint };

    // sizeMax is the way that we determine if a dimension of a child is going to push out the desired size in that dimension;
    SIZE sizeMax = { 0, 0 };

    if (cChildren == 0)
        return _sizeDesired;

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    RECT rcMargin = { 0 };
    MARGINFLAGS mfSet = { false, false, false, false };
    
    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called
    for (UINT i = 0; i < cChildren; i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        if (peChild == _peClientPos)
            // come back to it after all of the others have been laid out
            continue;

        int iLayoutPos = peChild->GetLayoutPos(); 

        SIZE sizeChild = peChild->_UpdateDesiredSize(sizeRemaining.cx, sizeRemaining.cy, psrf);

        Value* pv;
        const RECT *prcChildMargin = peChild->GetMargin(&pv); 

        switch (iLayoutPos)
        {
            case BLP_Left:
                if (mfSet.bLeft)
                    sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;

                rcMargin.left = prcChildMargin->right;
                mfSet.bLeft = true;
                break;

            case BLP_Top:
                if (mfSet.bTop)
                    sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

                rcMargin.top = prcChildMargin->bottom;
                mfSet.bTop = true;
                break;

            case BLP_Right:
                if (mfSet.bRight)
                    sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

                rcMargin.right = prcChildMargin->left;
                mfSet.bRight = true;
                break;

            case BLP_Bottom:
                if (mfSet.bBottom)
                    sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

                rcMargin.bottom = prcChildMargin->top;
                mfSet.bBottom = true;
                break;

        }

        if ((iLayoutPos == BLP_Left) || (iLayoutPos == BLP_Right))
        {
            // vertically oriented element
            if (mfSet.bTop)
                sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

            if (mfSet.bBottom)
                sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

            if (sizeChild.cx > sizeRemaining.cx)
            {
                sizeChild.cx = sizeRemaining.cx;
                sizeRemaining.cx = 0;
            }
            else
                sizeRemaining.cx -= sizeChild.cx;
                
            sizeMax.cx -= sizeChild.cx;
            if (sizeMax.cx < 0)
            {
                _sizeDesired.cx += -sizeMax.cx;
                sizeMax.cx = 0;
            }

            int iDiff = sizeChild.cy - sizeMax.cy;
            if (iDiff > 0)
            {
                _sizeDesired.cy += iDiff;
                sizeMax.cy = sizeChild.cy;
            }
        }
        else
        {
            // horizontally oriented element
            if (mfSet.bLeft)
                sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;
            if (mfSet.bRight)
                sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

            if (sizeChild.cy > sizeRemaining.cy)
            {
                sizeChild.cy = sizeRemaining.cy;
                sizeRemaining.cy = 0;
            }
            else
                sizeRemaining.cy -= sizeChild.cy;

            sizeMax.cy -= sizeChild.cy;
            if (sizeMax.cy < 0)
            {
                _sizeDesired.cy += -sizeMax.cy;
                sizeMax.cy = 0;
            }

            int iDiff = sizeChild.cx - sizeMax.cx;
            if (iDiff > 0)
            {
                _sizeDesired.cx += iDiff;
                sizeMax.cx = sizeChild.cx;
            }
        }

        pv->Release();

        if ((sizeRemaining.cx == 0) && (sizeRemaining.cy == 0))
            // we can't fit anything else, we're done
            break;
    }

    if (i == cChildren)
    {
        SIZE sizeChild;

        // there was space for the client -- add him in
        if (_peClientPos)
        {
            peChild = _peClientPos;
            sizeChild = peChild->_UpdateDesiredSize(sizeRemaining.cx, sizeRemaining.cy, psrf);

            Value* pv;
            const RECT *prcChildMargin = peChild->GetMargin(&pv); 

            if (mfSet.bLeft)
                sizeChild.cx += (rcMargin.left > prcChildMargin->left) ? rcMargin.left : prcChildMargin->left;

            if (mfSet.bTop)
                sizeChild.cy += (rcMargin.top > prcChildMargin->top) ? rcMargin.top : prcChildMargin->top;

            if (mfSet.bRight)
                sizeChild.cx += (rcMargin.right > prcChildMargin->right) ? rcMargin.right : prcChildMargin->right;

            if (mfSet.bBottom)
                sizeChild.cy += (rcMargin.bottom > prcChildMargin->bottom) ? rcMargin.bottom : prcChildMargin->bottom;

            pv->Release();
        }
        else
        {
            // no client -- treat residual margins as the size of the client

            if (mfSet.bLeft || mfSet.bRight)
            {
                if (mfSet.bLeft && mfSet.bRight)
                    sizeChild.cx = (rcMargin.left > rcMargin.right) ? rcMargin.left : rcMargin.right;
                else if (mfSet.bLeft)
                    sizeChild.cx = rcMargin.left;
                else // (mfSet.bRight)
                    sizeChild.cx = rcMargin.right;
            }
            else
                sizeChild.cx = 0;

            if (mfSet.bTop || mfSet.bBottom)
            {
                if (mfSet.bTop && mfSet.bBottom)
                    sizeChild.cy = (rcMargin.top > rcMargin.bottom) ? rcMargin.top : rcMargin.bottom;
                else if (mfSet.bTop)
                    sizeChild.cy = rcMargin.top;
                else // (mfSet.bBottom)
                    sizeChild.cy = rcMargin.bottom;
            }
            else
                sizeChild.cy = 0;
        }

        // no further need for sizeRemaining -- so don't bother updating here
        //sizeRemaining.cx -= sizeChild.cx;
        //sizeRemaining.cy -= sizeChild.cy;

        int iDiff = sizeChild.cx - sizeMax.cx;
        if (iDiff > 0)
            _sizeDesired.cx += iDiff;

        iDiff = sizeChild.cy - sizeMax.cy;
        if (iDiff > 0)
            _sizeDesired.cy += iDiff;
    }

    pvChildren->Release();

    if (_sizeDesired.cx > cxConstraint)
        _sizeDesired.cx = cxConstraint;

    if (_sizeDesired.cy > cyConstraint)
        _sizeDesired.cy = cyConstraint;

    return _sizeDesired;
}

void BorderLayout::SetClient(Element* pe)
{
    if (_peClientPos)
    {
        // throw exception -- there can only be one client
    }
    _peClientPos = pe;
}

void BorderLayout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
    {
        if (ppeAdd[i]->GetLayoutPos() == BLP_Client)
            SetClient(ppeAdd[i]);
    }

    Layout::OnAdd(pec, ppeAdd, cCount);
}

void BorderLayout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
    {
        if (ppeRemove[i] == _peClientPos)
            _peClientPos = NULL;
    }

    Layout::OnRemove(pec, ppeRemove, cCount);
}

void BorderLayout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    if (peChanged == _peClientPos)
        _peClientPos = NULL;
    else if (dNewLP == BLP_Client)
        SetClient(peChanged);

    Layout::OnLayoutPosChanged(pec, peChanged, dOldLP, dNewLP);
}


Element* BorderLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        UINT cChildren = GetLayoutChildCount(pec);

        Element* peChild;
        Element* peMatch = NULL;
        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        //
        // there are two scenarios that all navigations boil down to for this layout:
        //  (1) tunneling into the border layout
        //  (2) crawling out of the border layout
        //
        // The second scenario is the easier of the two, because there is no need to check the reference rectangle for 
        // maximal overlap (because, by virtue of the subtractive rects algorithm used by this layout, all peers encountered
        // while crawling out of the border layout will cover at least the entire side of the child being navigated from).
        // So, as soon as we find a child positioned in the direction of the navigation, we're done.
        //
        // The first scenario is not that lucky.  When tunneling in, it is entirely possible that there will be multiple 
        // children sharing an adjacent side in the direction of the navigation.  So, as we encounter children positioned in
        // the direction of the navigation, we have to save off the child with the highest overlap score.  In the end, the
        // child with the highest score wins.
        //

        bool bTunnel = false;
        int iFromLayoutPos = 0;
        int iStart = -1;

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            bTunnel = true;

            switch (iNavDir)
            {
                case NAV_UP:    iFromLayoutPos = BLP_Bottom; break;
                case NAV_DOWN:  iFromLayoutPos = BLP_Top;    break;
                case NAV_LEFT:  iFromLayoutPos = BLP_Right;  break;
                case NAV_RIGHT: iFromLayoutPos = BLP_Left;   break;
            }
        }
        else
        {
            iFromLayoutPos = peFrom->GetLayoutPos();

            if (iFromLayoutPos == BLP_Client)
                iStart = cChildren;
            else
            {
                iStart = GetLayoutIndexFromChild(pec, peFrom);

                switch (iFromLayoutPos)
                {
                    case BLP_Top:    bTunnel = (iNavDir == NAV_DOWN);  break;
                    case BLP_Left:   bTunnel = (iNavDir == NAV_RIGHT); break;
                    case BLP_Bottom: bTunnel = (iNavDir == NAV_UP);    break;
                    case BLP_Right:  bTunnel = (iNavDir == NAV_LEFT);  break;
                }
            }
        }

        if (bTunnel)
        {
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            bool bIgnoreClient = false;
            bool bFoundLateral = false;
            int iOpposingPos = 0;
            Element* peLastOpposing = NULL;

            switch (iFromLayoutPos)
            {
                case BLP_Top:    iOpposingPos = BLP_Bottom; break;
                case BLP_Bottom: iOpposingPos = BLP_Top;    break;
                case BLP_Right:  iOpposingPos = BLP_Left;   break;
                case BLP_Left:   iOpposingPos = BLP_Right;  break;
            }

            for (UINT i = (iStart + 1); i < cChildren; i++)
            {
                peChild = GetChildFromLayoutIndex(pec, i, peList);

                if (peChild == _peClientPos)
                    continue;

                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                if (!peTo)
                    continue;

                int iLayoutPos = peChild->GetLayoutPos();

                if (!bFoundLateral && (iLayoutPos == iFromLayoutPos))
                {
                    // optimization -- if the first peer we encounter takes up the entire side, then there is no need to go any further
                    ns.peWinner = peTo;
                    bIgnoreClient = true;
                    break;
                }

                if (iLayoutPos == iOpposingPos)
                    peLastOpposing = peTo;
                else
                {
                    if (ns.TrackScore(peChild, peTo))
                    {
                        bIgnoreClient = true;
                        break;
                    }

                    bFoundLateral = true;
                }

                if (iLayoutPos == iFromLayoutPos)
                {
                    // optimization -- once we've encountered a peer in the same layout position, we don't need to check any further because
                    // we have found all peers that cover that side
                    bIgnoreClient = true;
                    break;
                }
            }

            if (!bIgnoreClient)
            {
                if (_peClientPos)
                {
                    Element* peTo = _peClientPos->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                    // one goofy behavior here is that, if the client is not visible because it's zero sized, we actually pick one
                    // of the lateral neighbors instead of the opposing neighbor, even if the opposing neighbor is the winner
                    if (peTo)
                        ns.TrackScore(_peClientPos, peTo);
                }

                if (!ns.peWinner)
                {
                    if (!peLastOpposing && (iStart > 0))
                    {
                        UINT i = iStart;

                        while ((i > 0) && !peLastOpposing)
                        {
                            peChild = GetChildFromLayoutIndex(pec, --i, peList);
                            if (peChild->GetLayoutPos() == iOpposingPos)
                                peLastOpposing = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                        }
                    }

                    ns.peWinner = peLastOpposing;
                }
            }
            peMatch = ns.peWinner;
        }
        else // crawl
        {
            for (UINT i = iStart; (i > 0) && !peMatch;)
            {
                peChild = GetChildFromLayoutIndex(pec, --i, peList);

                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                if (!peTo)
                    continue;

                switch (peChild->GetLayoutPos())
                {
                    case BLP_Top:    if (iNavDir == NAV_UP)    peMatch = peTo; break;
                    case BLP_Left:   if (iNavDir == NAV_LEFT)  peMatch = peTo; break;
                    case BLP_Bottom: if (iNavDir == NAV_DOWN)  peMatch = peTo; break;
                    case BLP_Right:  if (iNavDir == NAV_RIGHT) peMatch = peTo; break;
                }
            }
        }

        pvChildren->Release();
        return peMatch;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, bKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\filllayout.cpp ===
/*
 * FillLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duifilllayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// FillLayout

////////////////////////////////////////////////////////
// Parser callback (static)

HRESULT FillLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT FillLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    FillLayout* pfl = HNew<FillLayout>();
    if (!pfl)
        return E_OUTOFMEMORY;

    pfl->Initialize();

    *ppLayout = pfl;

    return S_OK;
}

void FillLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    rcMargin.left   = 0;
    rcMargin.top    = 0;
    rcMargin.right  = 0;
    rcMargin.bottom = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void FillLayout::DoLayout(Element* pec, int cx, int cy)
{
    int x = rcMargin.left;
    int y = rcMargin.top;
    cx -= rcMargin.left + rcMargin.right;
    cy -= rcMargin.top + rcMargin.bottom;

    int xAdj;
    int yAdj;
    int cxAdj;
    int cyAdj;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    const SIZE* pDS;
    int dLP;

    for (UINT u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);

        xAdj = x;
        yAdj = y;
        cxAdj = cx;
        cyAdj = cy;

        dLP = peChild->GetLayoutPos();
        if (dLP != LP_Auto)
        {
            pDS = peChild->GetDesiredSize();
            switch (dLP)
            {
            case FLP_Right:
                xAdj = x + cx - pDS->cx;
                // Fall through

            case FLP_Left:
                cxAdj = pDS->cx;
                break;

            case FLP_Bottom:
                yAdj = y + cy - pDS->cy;
                // Fall through

            case FLP_Top:
                cyAdj = pDS->cy;
                break;
            }
        }

        if (xAdj < 0)
            xAdj = 0;
        if (yAdj < 0)
            yAdj = 0;

        if (cxAdj < 0)
            cxAdj = 0;
        if (cyAdj < 0)
            cyAdj = 0;
        
        peChild->_UpdateLayoutPosition(xAdj, yAdj);
        peChild->_UpdateLayoutSize(cxAdj, cyAdj);
    }
    
    pvChildren->Release();
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE FillLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT u;
    Element* peChild;

    rcMargin.left   = -INT_MAX;
    rcMargin.top    = -INT_MAX;
    rcMargin.right  = -INT_MAX;
    rcMargin.bottom = -INT_MAX;

    for (u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);
        Value* pvMargin;
        const RECT* prcChildMargin = peChild->GetMargin(&pvMargin); 

        if (rcMargin.left   < prcChildMargin->left  )   rcMargin.left   = prcChildMargin->left;
        if (rcMargin.top    < prcChildMargin->top   )   rcMargin.top    = prcChildMargin->top;
        if (rcMargin.right  < prcChildMargin->right )   rcMargin.right  = prcChildMargin->right;
        if (rcMargin.bottom < prcChildMargin->bottom)   rcMargin.bottom = prcChildMargin->bottom;

        pvMargin->Release();
    }

    if (rcMargin.left   < 0)    rcMargin.left   = 0;
    if (rcMargin.top    < 0)    rcMargin.top    = 0;
    if (rcMargin.right  < 0)    rcMargin.right  = 0;
    if (rcMargin.bottom < 0)    rcMargin.bottom = 0;

    cxConstraint -= rcMargin.left + rcMargin.right;
    cyConstraint -= rcMargin.top + rcMargin.bottom;

    SIZE sizeMax = { 0, 0 };

    for (u = 0 ; u < cChildren; u++)
    {
        peChild = GetChildFromLayoutIndex(pec, u, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        if (sizeMax.cx < sizeChild.cx)
            sizeMax.cx = sizeChild.cx;

        if (sizeMax.cy < sizeChild.cy)
            sizeMax.cy = sizeChild.cy;
    }

    pvChildren->Release();

    sizeMax.cx += rcMargin.left + rcMargin.right;
    sizeMax.cy += rcMargin.top + rcMargin.bottom;
    return sizeMax;
}

Element* FillLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
            return NULL;
        else if (!peFrom)
        {
            UINT cChildren = GetLayoutChildCount(pec);

            Value* pvChildren;
            ElementList* peList = pec->GetChildren(&pvChildren); 

            UINT u;
            Element* peChild;

            for (u = 0 ; u < cChildren; u++)
            {
                peChild = GetChildFromLayoutIndex(pec, u, peList);
                Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                if (peTo)
                {
                    pvChildren->Release();
                    return peTo;
                }
            }

            pvChildren->Release();
        }
        // else -- when navigating from inside, we always return NULL since only one item within you is navigable
        // so just fall through to NULL here

        return NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\gridlayout.cpp ===
/*
 * Gridlayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duigridlayout.h"

namespace DirectUI
{

#define GetColumnFromIndex(cCols, i)  (i % cCols)
#define GetRowFromIndex(cCols, i)     (i / cCols)

////////////////////////////////////////////////////////
// GridLayout

#define CALCCOLS 0x00000001
#define CALCROWS 0x00000002

HRESULT GridLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 2:
        hr = Create(pParams[0], pParams[1], &pl);
        break;

    default:
        hr = Create(1, 1, &pl);
    }
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT GridLayout::Create(int iRows, int iCols, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    GridLayout* pgl = HNew<GridLayout>();
    if (!pgl)
        return E_OUTOFMEMORY;

    pgl->Initialize(iRows, iCols);

    *ppLayout = pgl;

    return S_OK;
}

// Not shareable by default

void GridLayout::Initialize(int iRows, int iCols)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _uRows = 0;
    _uCols = 0;
    _fBits = 0;
    _arRowMargins = NULL;
    _arColMargins = NULL;

    if (iRows == -1)
    {
        _fBits |= CALCROWS;
        if (iCols == -1)
        {
            DUIAssertForce("Cannot specify -1 for both the number of rows and the number of columns");
            _uRows = 1;
        }
    }
    else if (iRows <= 0)
    {
        DUIAssertForce("Number of rows cannot be zero or negative.");
        _uRows = 1;
    }
    else
        _uRows = (UINT) iRows;

    if (iCols == -1)
        _fBits |= CALCCOLS;
    else if (iCols <= 0)
    {
        DUIAssertForce("Number of columns cannot be zero or negative.");
        _uCols = 1;
    }
    else
        _uCols = (UINT) iCols;
}

GridLayout::~GridLayout()
{
    if (_arColMargins)
        HFree(_arColMargins);

    if (_arRowMargins)
        HFree(_arRowMargins);
}

////////////////////////////////////////////////////////
// Callbacks from clients

void GridLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (IsCacheDirty())
        return;

    Element* peChild;
    int cxOrg = cx;
    int cyOrg = cy;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT i = 0;

    UINT rows = GetCurrentRows(cChildren);
    UINT cols = GetCurrentCols(cChildren);

    if (!rows || !cols || ((rows > 1) && !_arRowMargins) || ((cols > 1) && !_arColMargins))
    {
        pvChildren->Release();
        return;
    }

    for (UINT r = 0; r < (rows - 1); r++)
    {
        cy -= _arRowMargins[r];
        if (cy < 0)
        {
            cy = 0;
            break;
        }
    }

    for (UINT c = 0; c < (cols - 1); c++)
    {
        cx -= _arColMargins[c];
        if (cx < 0)
        {
            cx = 0;
            break;
        }
    }

    UINT* xCols = (UINT*)HAllocAndZero(sizeof(UINT) * (cols + 1));
    if (!xCols)
    {
        pvChildren->Release();
        return;
    }

    for (c = 0; c <= cols; c++)
        xCols[c] = (cx * c) / cols;

    int yRow = 0;
    int yMarginOffset = 0;

    for (r = 0; r < rows; r++)
    {
        int yNextRow = (cy * (r + 1)) / rows;
        int xMarginOffset = 0;

        for (c = 0; c < cols; c++)
        {
            if (i < cChildren)
            {
                peChild = GetChildFromLayoutIndex(pec, i, peList);

                UpdateLayoutRect(pec, cxOrg, cyOrg, peChild, xCols[c] + xMarginOffset, yRow + yMarginOffset, xCols[c+1] - xCols[c], yNextRow - yRow);
                if (c < (cols - 1))
                    xMarginOffset += _arColMargins[c];
            }

            i++;
        }
        yRow = yNextRow;
        if (r < (rows - 1))
            yMarginOffset += _arRowMargins[r];
    }

    HFree(xCols);
    
    pvChildren->Release();
}

SIZE GridLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    SetCacheDirty();

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    UINT rows = GetCurrentRows(cChildren);
    UINT cols = GetCurrentCols(cChildren);

    if (_arColMargins)
    {
        HFree(_arColMargins);
        _arColMargins = NULL;
    }

    if (_arRowMargins)
    {
        HFree(_arRowMargins);
        _arRowMargins = NULL;
    }

    if (!rows || !cols)
    {
        pvChildren->Release();
        SIZE s = { 0, 0 };
        return s;
    }

    if (cols > 1)
    {
        _arColMargins = (int*)HAllocAndZero(sizeof(int) * (cols - 1));
        if (!_arColMargins)
        {
            pvChildren->Release();
            SIZE s = { 0, 0 };
            return s;
        }
    }

    if (rows > 1)
    {
        _arRowMargins = (int*)HAllocAndZero(sizeof(int) * (rows - 1));
        if (!_arRowMargins)
        {
            pvChildren->Release();
            SIZE s = { 0, 0 };
            return s;
        }
    }

    UINT r;
    UINT c;
    UINT i = 0;

    if (cChildren == 0)
        goto EndMarginLoop;

    for (c = 0; c < (cols - 1); c++)
        _arColMargins[c] = -INT_MAX;


    for (r = 0; r < rows; r++)
    {
        if (r < (rows - 1))
            _arRowMargins[r] = -INT_MAX;

        for (c = 0; c < cols; c++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            Value* pv;
            const RECT* prcChildMargin = peChild->GetMargin(&pv); 
            if ((c > 0) && (_arColMargins[c - 1] < prcChildMargin->left))
                _arColMargins[c - 1] = prcChildMargin->left;
            if ((c < (cols - 1)) && (_arColMargins[c] < prcChildMargin->right))
                _arColMargins[c] = prcChildMargin->right;
            if ((r > 0) && (_arRowMargins[r - 1] < prcChildMargin->top))
                _arRowMargins[r - 1] = prcChildMargin->top;
            if ((r < (rows - 1)) && (_arRowMargins[r] < prcChildMargin->bottom))
                _arRowMargins[r] = prcChildMargin->bottom;
            pv->Release();

            i++;

            if (i == cChildren)
            {
                if (r == 0)
                {
                    while (c < (cols - 1))
                        _arColMargins[c++] = 0;
                }
                goto EndMarginLoop;                
            }
        }
    }

EndMarginLoop:
    SIZE sizeDesired = { 0, 0 };

    for (r = 0; r < (rows - 1); r++)
    {
        sizeDesired.cy += _arRowMargins[r];
        cyConstraint -= _arRowMargins[r];
        if (cyConstraint < 0)
        {
            sizeDesired.cy -= cyConstraint;
            cyConstraint = 0;
            break;
        }
    }
    for (c = 0; c < (cols - 1); c++)
    {
        sizeDesired.cx += _arColMargins[c];
        cxConstraint -= _arColMargins[c];
        if (cxConstraint < 0)
        {
            sizeDesired.cx += cxConstraint;
            cxConstraint = 0;
            break;
        }
    }

    UINT* cxCols = (UINT*)HAllocAndZero(sizeof(UINT) * cols);
    UINT* cyRows = (UINT*)HAllocAndZero(sizeof(UINT) * rows);

    UINT* cxColConstraints = (UINT*)HAllocAndZero(sizeof(UINT) * cols);

    if (!cxCols || !cyRows || !cxColConstraints)
    {
        if (cxCols)
            HFree(cxCols);
        if (cyRows)
            HFree(cyRows);
        if (cxColConstraints)
            HFree(cxColConstraints);

        pvChildren->Release();
        SIZE s = { 0, 0 };
        return s;
    }

    i = 0;

    int cx = cxConstraint / cols;
    cxColConstraints[0] = cx;
    for (c = 1; c < cols; c++)
    {
        cxColConstraints[c] = (int) ((((__int64) cxConstraint * (c + 1)) / cols)) - cx;
        cx += cxColConstraints[c];
    }

    int cy = cyConstraint / rows;
    int cyRowConstraint = cy;

    for (r = 0; r < rows; r++)
    {
        for (c = 0; c < cols; c++)
        {
            if (i == cChildren)
            {
                if (rows == 1)
                {
                    while (c < cols)
                        cxCols[c++] = 0;
                }
                goto EndLoop;                
            }

            peChild = GetChildFromLayoutIndex(pec, i, peList);
            SIZE sizeChild = peChild->_UpdateDesiredSize(cxColConstraints[c], cyRowConstraint, psrf);

            if (cxCols[c] < (UINT) sizeChild.cx)
                cxCols[c] = (UINT) sizeChild.cx;
            if (cyRows[r] < (UINT) sizeChild.cy)
                cyRows[r] = (UINT) sizeChild.cy;

            i++;
        }
        cyRowConstraint = (int) ((((__int64) cyConstraint * (r + 2)) / rows)) - cy;
        cy += cyRowConstraint;
    }

EndLoop:
    int nMax = 0;
    UINT cyMax = 0;
    for (r = 0; r < rows; r++)
    {
        if (cyMax < cyRows[r])
        {
            cyMax = cyRows[r];
            nMax = 1;
        }
        else if (cyMax == cyRows[r])
            nMax++;
    }
    
    cy = ((cyMax - 1) * rows) + nMax;
    int cyMaxDesired = cyMax * rows;

    while (cy < cyMaxDesired)
    {
        int nRunMax = nMax;
        UINT cyRun = cy / rows;
        UINT cySum = cyRun;
        for (UINT r = 0; r < rows; r++)
        {
            if (cyRows[r] == cyMax)
            {
                if (cyRun < cyMax)
                    break;

                if (--nRunMax == 0)
                    break;
            }
            UINT cyNext = (int) ((((__int64) cy * (r + 2)) / rows));
            cyRun = cyNext - cySum;
            cySum = cyNext;
        }
        if (nRunMax == 0)
            break;
        cy++;
    }


    nMax = 0;
    UINT cxMax = 0;
    for (c = 0; c < cols; c++)
    {
        if (cxMax < cxCols[c])
        {
            cxMax = cxCols[c];
            nMax = 1;
        }
        else if (cxMax == cxCols[c])
            nMax++;
    }
    
    cx = ((cxMax - 1) * cols) + nMax;
    int cxMaxDesired = cxMax * cols;

    while (cx < cxMaxDesired)
    {
        int nRunMax = nMax;
        UINT cxRun = cx / cols;
        UINT cxSum = cxRun;
        for (UINT c = 0; c < cols; c++)
        {
            if (cxCols[c] == cxMax)
            {
                if (cxRun < cxMax)
                    break;

                if (--nRunMax == 0)
                    break;
            }
            UINT cxNext = (int) ((((__int64) cx * (c + 2)) / cols));
            cxRun = cxNext - cxSum;
            cxSum = cxNext;
        }
        if (nRunMax == 0)
            break;
        cx++;
    }

    HFree(cxColConstraints);
    HFree(cxCols);
    HFree(cyRows);

    pvChildren->Release();

    DUIAssert(cx <= cxConstraint, "Desired width is over constraint");
    DUIAssert(cy <= cyConstraint, "Desired width is over constraint");

    sizeDesired.cx += cx;
    sizeDesired.cy += cy;

    ClearCacheDirty();

    return sizeDesired;
}

UINT GridLayout::GetCurrentRows(Element* pec)
{
    return (_fBits & CALCROWS) ? GetCurrentRows(GetLayoutChildCount(pec)) : _uRows;
}

UINT GridLayout::GetCurrentRows(int c)
{
    if (_fBits & CALCROWS)
        return (_uCols == 1) ? c : (c + (_uCols - 1)) / _uCols;
    return _uRows;
}

UINT GridLayout::GetCurrentCols(Element* pec)
{
    return (_fBits & CALCCOLS) ? GetCurrentCols(GetLayoutChildCount(pec)) : _uCols;
}

UINT GridLayout::GetCurrentCols(int c)
{
    if (_fBits & CALCCOLS)
        return (_uRows == 1) ? c : (c + (_uRows - 1)) / _uRows;
    return _uCols;
}

Element* GridLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        int cChildren = GetLayoutChildCount(pec);

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            int cCols = GetCurrentCols(cChildren);
            int cRows = GetCurrentRows(cChildren);

            int cOuter, cInner;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = (cCols * cRows) - 1;
            }

            if (iNavDir & NAV_VERTICAL)
            {
                cOuter = cRows;
                cInner = cCols;
            }
            else
            {
                cOuter = cCols;
                cInner = cRows;

                iInc *= cCols;
            }

            for (int i = 0; i < cOuter; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < cInner; j++, iTile += iInc)
                {
                    if (iTile >= cChildren)
                        continue;

                    if (ns.Try(GetChildFromLayoutIndex(pec, iTile, peList), iNavDir, pnr, fKeyableOnly))
                        break;
                }

                if (ns.peWinner)
                {
                    pvChildren->Release();
                    return ns.peWinner;
                }

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * cCols;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            pvChildren->Release();

            return NULL;
        }
        else // we're navigating from a child within container
        {
            int i = GetLayoutIndexFromChild(pec, peFrom);
            int iInc;
            int iEnd;
            int cCols = GetCurrentCols(cChildren);

            if (iNavDir & NAV_VERTICAL)
            {
                iInc = cCols;
                int iRow = GetRowFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + (((GetCurrentRows(cChildren) - 1) - iRow) * cCols);
                else
                    iEnd = i - (iRow * cCols);
            }
            else
            {
                iInc = 1;
                int iCol = GetColumnFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + ((cCols - 1) - iCol);
                else
                    iEnd = i - iCol;
            }

            if (!(iNavDir & NAV_FORWARD))
                iInc *= -1;

            if (i != iEnd)
            {
                do 
                {
                    i += iInc;

                    Element* peChild = GetChildFromLayoutIndex(pec, i, peList);
                    if (!peChild)
                        continue;

                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

                    if (peTo)
                    {
                        pvChildren->Release();
                        return peTo;
                    }
                }
                while (i != iEnd);
            }
        }

        pvChildren->Release();
        return NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\layout.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_LAYOUT_H_INCLUDED
#define DUI_LAYOUT_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>

#endif // DUI_LAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_LAYOUT_PUBLISHED_H_INCLUDED
#define DUI_LAYOUT_PUBLISHED_H_INCLUDED

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

#endif // DUI_LAYOUT_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\flowlayout.cpp ===
/*
 * FlowLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiflowlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// flow layout

SIZE FlowLayout::g_sizeZero = { 0, 0 };

// ----------------------------------------------------------------------------------------------------------------
//
//  method overview:
//    public:
//      DoLayout          -- responsible for doing all of the alignment work and placing the elements
//      HitTest           -- simply calls superclass for now
//      UpdateDesiredSize -- simply calls BuildCacheInfo
// 
//    protected:
//      BuildCacheInfo    -- the workhorse of this layout -- builds up the line array and per-line element arrays
//
// ----------------------------------------------------------------------------------------------------------------

HRESULT FlowLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 1:
        hr = Create(pParams[0] ? true : false, ALIGN_TOP, ALIGN_LEFT, ALIGN_CENTER, &pl);
        break;

    case 2:
        hr = Create(pParams[0] ? true : false, pParams[1], ALIGN_LEFT, ALIGN_CENTER, &pl);
        break;

    case 3:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], ALIGN_CENTER, &pl);
        break;

    case 4:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], pParams[3], &pl);
        break;

    default:
        hr = Create(true, ALIGN_TOP, ALIGN_LEFT, ALIGN_CENTER, &pl);
    }

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT FlowLayout::Create(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    FlowLayout* pfl = HNew<FlowLayout>();
    if (!pfl)
        return E_OUTOFMEMORY;

    pfl->Initialize(fWrap, uYAlign, uXLineAlign, uYLineAlign);

    *ppLayout = pfl;

    return S_OK;
}

void FlowLayout::Initialize(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _fWrap = fWrap;
    _uXLineAlign = uXLineAlign;
    _uYLineAlign = uYLineAlign;
    _uYAlign = uYAlign;
    _arLines = NULL;
    _cLines = 0;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
    _sizeLastConstraint.cx = 0;
    _sizeLastConstraint.cy = 0;
}

FlowLayout::~FlowLayout()
{
    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].arxElement)
                HFree(_arLines[k].arxElement);
        }

        HFree(_arLines);
    }
}

////////////////////////////////////////////////////////
// Callbacks from clients

void FlowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (!_cLines || IsCacheDirty())
        return;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    LINE* plCur = _arLines + (_cLines - 1);

    int yStart = 0;
    int cyContent = 0;

    if (_uYAlign != ALIGN_TOP)
    {
        cyContent = plCur->y + plCur->cy;
        int cyDelta = cy - cyContent;

        if (_uYAlign == ALIGN_CENTER)
            yStart = cyDelta / 2;
        else if (_uYAlign == ALIGN_BOTTOM)
            yStart = cyDelta;
    }

    plCur = _arLines;
    UINT i = 0;

    for (UINT uLine = 0; uLine < _cLines; uLine++)
    {
        int xStart = 0;

        if (_uXLineAlign == ALIGN_CENTER)
            xStart = (cx - plCur->cx) / 2;
        else if (_uXLineAlign == ALIGN_RIGHT)
            xStart = cx - plCur->cx;

        int yLine = plCur->y;
        int cyLine = plCur->cy;

        if ((_uYAlign == ALIGN_JUSTIFY) && (cyContent < cy))
        {
            if (!cyContent)
            {
                // zero desired height -- so spread equally among lines
                yLine = cy * uLine / _cLines;
                cyLine = (cy * (uLine + 1) / _cLines) - yLine;
            }
            else
            {
                cyLine = cyLine * cy / cyContent;
                yLine  = yLine  * cy / cyContent;
            }
        }

        int xElement;
        int yElement;
        
        for (UINT uElement = 0; uElement < plCur->cElements; uElement++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
    
            SIZE size = *(peChild->GetDesiredSize());

            //xElement = (uElement == 0) ? 0 : plCur->arxElement[uElement - 1];
            xElement = 0;
            if (uElement != 0 && plCur->arxElement)
                xElement = plCur->arxElement[uElement - 1];

            yElement = 0;
            if (_uYLineAlign == ALIGN_CENTER)
                yElement = (cyLine - size.cy) / 2;
            else if (_uYLineAlign == ALIGN_BOTTOM)
                yElement = cyLine - size.cy;
            else if (_uYLineAlign == ALIGN_JUSTIFY)
                size.cy = cyLine;

            if ((_uXLineAlign == ALIGN_JUSTIFY) && (plCur->cx < (UINT) cx))
            {
                size.cx  = plCur->cx ? (size.cx  * cx / plCur->cx) : 0;
                xElement = plCur->cx ? (xElement * cx / plCur->cx) : 0;
            }

            xElement += xStart;
            yElement += yStart + yLine;

            // constrain it to bounds of layout (0,0)-(cx,cy)
            if (xElement < 0)
            {
                size.cx += xElement;
                xElement = 0;
                if (size.cx < 0)
                    size.cx = 0;
            }
            
            if ((xElement + size.cx) > cx)
            {
                size.cx = cx - xElement;
                if (size.cx < 0)
                    size.cx = 0;
            }

            if (yElement < 0)
            {
                size.cy += yElement;
                yElement = 0;
                if (size.cy < 0)
                    size.cy = 0;
            }

            if ((yElement + size.cy) > cy)
            {
                size.cy = cy - yElement;
                if (size.cy < 0)
                    size.cy = 0;
            }

            UpdateLayoutRect(pec, cx, cy, peChild, xElement, yElement, size.cx, size.cy);

            i++;
        }
        plCur++;
    }

    // this code is only ever hit when the line array does not include all layout elements in the container;
    // currently, this only happens when wrapping is off.
    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cx, cy, peChild, 0, 0, 0, 0);
    }

    pvChildren->Release();
}

SIZE FlowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    return BuildCacheInfo(pec, cxConstraint, cyConstraint, psrf, false);
}
        
SIZE FlowLayout::BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize)
{
    UNREFERENCED_PARAMETER(fRealSize);

    SetCacheDirty();

    /*
    if (_arLines != NULL)
    {
        // check to make sure we really have to recalc

        if (cxConstraint == sizeLastConstraint.cx)
            // if cxConstraint doesn't change, then the calculation stays the same
            return _sizeDesired;
    }
    */

    // I'm saving previous constraints to be able to optimize this stage.
    // When I get flags coming into UpdateDesiredSize, I can get rid of this.
    _sizeLastConstraint.cx = cxConstraint;
    _sizeLastConstraint.cy = cyConstraint;

    UINT cChildren = GetLayoutChildCount(pec);

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called

    int cyCur = 0;
    int cxCur = 0;
    UINT i = 0;

    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].arxElement)
                HFree(_arLines[k].arxElement);
        }

        HFree(_arLines);
    }

    _cLines = 0;

    // Allocate space for the data for the initial line
    _arLines = (LINE*)HAllocAndZero(sizeof(LINE) * 1);
    if (!_arLines)
    {
        pvChildren->Release();
        return g_sizeZero;
    }

    int cxMax = 0;

    int cxRealConstraint = cxConstraint;

    int iLeftMargin;
    int iTopMargin;
    int iRightMargin;
    int iBottomMargin;

    int iLineTopMargin = 0;
    int iLineBottomMargin = 0;

    int iPrevLineBottomMargin = 0;

    while (i < cChildren)
    {
        cxCur = 0;
        int cyMax;
        int iMargin = 0;

        _cLines++;
        if (_cLines > 1)
        {
            // Allocate space for the data for subsequent lines (space for the first line was alloc'ed outside of this loop
            LINE* arNewLines = (LINE*)HReAllocAndZero(_arLines, sizeof(LINE) * _cLines);
            if (!arNewLines)
            {
                HFree(_arLines);
                _arLines = NULL;
                pvChildren->Release();
                return g_sizeZero;
            }

            _arLines = arNewLines;
        }

        // Initialize line computation with information from first element on line 
        LINE* plCur = _arLines + (_cLines - 1);

        peChild = GetChildFromLayoutIndex(pec, i, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        Value* pv;
        const RECT* prect = peChild->GetMargin(&pv); 
        iLeftMargin   = prect->left;
        iTopMargin    = prect->top;
        iRightMargin  = prect->right;
        iBottomMargin = prect->bottom;
        pv->Release();
        
        plCur->y = cyCur;

        plCur->cElements = 1;
        plCur->iStart = i;
        plCur->arxElement = NULL;

        if (_fWrap)
        {
            // potential for more lines -- keep track of max top and bottom margins for this line
            if (_cLines > 1)
            {
                if ((_uYLineAlign == ALIGN_TOP) || (_uYLineAlign == ALIGN_JUSTIFY))
                    // iLineTopMargin is a running total of max top margin
                    iLineTopMargin = iTopMargin;
                else if (_uYLineAlign == ALIGN_CENTER)
                    // iLineTopMargin is a running total of max thickness / 2 + top margin (add one because of rounding error only for top)
                    iLineTopMargin = ((sizeChild.cy + 1) / 2) + iTopMargin;
                else // _uYLineAlign == ALIGN_BOTTOM
                    // iLineTopMargin is a running total of max thickness + top margin
                    iLineTopMargin = sizeChild.cy + iTopMargin;
            }

            if ((_uYLineAlign == ALIGN_BOTTOM) || (_uYLineAlign == ALIGN_JUSTIFY))
                // iLineBottomMargin is a running total of max bottom margin
                iLineBottomMargin = iBottomMargin;
            else if (_uYLineAlign == ALIGN_CENTER)
                // iLineBottomMargin is a running total of max thickness / 2 + bottom margin
                iLineBottomMargin = (sizeChild.cy / 2) + iBottomMargin;
            else // _uYLineAlign == ALIGN_TOP
                // iLineBottomMargin is a running total of max thickness + bottom margin
                iLineBottomMargin = sizeChild.cy + iBottomMargin;
        }

        cyMax = sizeChild.cy;
        cxCur += sizeChild.cx;
        iMargin = iRightMargin;

        // step to next element
        i++;

        // Line loop -- loop until we go beyond length of line
        while (i < cChildren)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

            const RECT* prect = peChild->GetMargin(&pv);
            iLeftMargin   = prect->left;
            iTopMargin    = prect->top;
            iRightMargin  = prect->right;
            iBottomMargin = prect->bottom;
            pv->Release();

            // use the max margin value between the right margin of the preceding element and
            // the left margin of this element
            if (iMargin < iLeftMargin)
                iMargin = iLeftMargin;

            if (_fWrap && (cxCur + iMargin + sizeChild.cx > cxRealConstraint))
                // we're wrapping and we went beyond length of line -- break out of this loop
                break;

            if (plCur->cElements == 1)
            {
                plCur->arxElement = (UINT*)HAllocAndZero(sizeof(UINT));
                if (!plCur->arxElement)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }
            }
            else
            {
                UINT* pNew = (UINT*)HReAllocAndZero(plCur->arxElement, sizeof(UINT) * plCur->cElements);
                if (!pNew)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }

                plCur->arxElement = pNew;
            }

            plCur->arxElement[plCur->cElements - 1] = cxCur + iMargin;
            plCur->cElements++;

            // keep track of the maximum thickness of the elements on this line
            if (cyMax < sizeChild.cy)
                cyMax = sizeChild.cy;

            cxCur += iMargin + sizeChild.cx;

            if (_fWrap)
            {
                // potential for more lines -- keep track of max top and bottom margins for this line
                if (_cLines > 1)
                {
                    // keep track of the maximum top or left margin on this line
                    if ((_uYLineAlign == ALIGN_TOP) || (_uYLineAlign == ALIGN_JUSTIFY))
                        // iLineTopMargin is a running total of max top or left margin
                        iMargin = iTopMargin;
                    else if (_uYLineAlign == ALIGN_CENTER)
                        // iLineTopMargin is a running total of max thickness / 2 + top or left margin (add one because of rounding error only for top/left)
                        iMargin = ((sizeChild.cy + 1) / 2) + iTopMargin;
                    else // _uYLineAlign == ALIGN_BOTTOM
                        // iLineTopMargin is a running total of max thickness + top or left margin
                        iMargin = sizeChild.cy + iTopMargin;

                    if (iLineTopMargin < iMargin)
                        iLineTopMargin = iMargin;
                }

                // keep track of the maximum bottom or right margin on this line
                if ((_uYLineAlign == ALIGN_BOTTOM) || (_uYLineAlign == ALIGN_JUSTIFY))
                    // iLineBottomMargin is a running total of max bottom or right margin
                    iMargin = iBottomMargin;
                else if (_uYLineAlign == ALIGN_CENTER)
                    // iLineBottomMargin is a running total of max thickness / 2 + bottom or right margin
                    iMargin = (sizeChild.cy / 2) + iBottomMargin;
                else // _uYLineAling == ALIGN_TOP
                    // iLineBottomMargin is a running total of max thickness + bottom or right margin
                    iMargin = sizeChild.cy + iBottomMargin;

                if (iLineBottomMargin < iMargin)
                    iLineBottomMargin = iMargin;
            }

            iMargin = iRightMargin;
            i++;
        }

        if (cxMax < cxCur)
            cxMax = cxCur;

        if (_fWrap)
        {
            // adjust margin running totals to reflect residual margin --
            // the bummer here is that we have to nuke negative margins because otherwise we're messed up
            if (_uYLineAlign == ALIGN_CENTER)
            {
                iLineTopMargin -= (cyMax + 1) / 2;
                if (iLineTopMargin < 0)
                    iLineTopMargin = 0;

                iLineBottomMargin -= cyMax / 2;
                if (iLineBottomMargin < 0)
                    iLineBottomMargin = 0;
            }
            else if (_uYLineAlign == ALIGN_BOTTOM)
            {
                iLineTopMargin -= cyMax;
                if (iLineTopMargin < 0)
                    iLineTopMargin = 0;
            }
            else if (_uYLineAlign == ALIGN_TOP)
            {
                iLineBottomMargin -= cyMax;
                if (iLineBottomMargin < 0)
                    iLineBottomMargin = 0;
            }

            if (_cLines > 1)
            {
                // account for margins between lines

                if (iPrevLineBottomMargin < iLineTopMargin)
                    iPrevLineBottomMargin = iLineTopMargin;

                // iPrevLineBottomMargin is now the max margin between the previous line and this line
                plCur->y += iPrevLineBottomMargin;
                cyCur += iPrevLineBottomMargin;
            }

            // save off this line's bottom margin to compare with the next line's resulting top margin
            iPrevLineBottomMargin = iLineBottomMargin;
        }

        cyCur += cyMax;

        plCur->cx = cxCur;
        plCur->cy = cyMax;
    }

    _sizeDesired.cx = (cxMax < cxConstraint) ? cxMax : cxConstraint;
    _sizeDesired.cy = (cyCur < cyConstraint) ? cyCur : cyConstraint;

    pvChildren->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

int FlowLayout::GetLine(Element* pec, Element* pe)
{
    int iChild = GetLayoutIndexFromChild(pec, pe);

    if (iChild >= 0)
    {
        UINT uChild = (UINT) iChild;

        for (UINT i = 0; i < _cLines; i++)
        {
            LINE* pLine = _arLines + i;
            if (uChild < (pLine->iStart + pLine->cElements))
                return i;
        }
    }
    return -1;
}

Element* FlowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        if (!_cLines || IsCacheDirty())
            return NULL;

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        NavScoring ns;

        ns.Init(pec, iNavDir, pnr);

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            bool fForward = ((iNavDir & NAV_FORWARD) != 0);

            if (iNavDir & NAV_VERTICAL)
            {
                int l = fForward ? 0 : (_cLines - 1);
                LINE* pLine = _arLines + l;
                while (!ns.peWinner)
                {
                    for (UINT i = 0; i < pLine->cElements; i++)
                    {
                        if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }

                    if (fForward)
                    {
                        l++;
                        if ((UINT) l == _cLines)
                            break;

                        pLine++;
                    }
                    else
                    {
                        if (pLine == _arLines)
                            break;
                        pLine--;
                    }
                }
            }
            else
            {
                UINT uOffset = 0;

                while (!ns.peWinner)
                {
                    BOOL fFoundOne = FALSE;

                    for (UINT l = 0; l < _cLines; l++)
                    {
                        LINE* pLine = _arLines + l;
                        int i = pLine->iStart;

                        if (uOffset >= pLine->cElements)
                            continue;

                        fFoundOne = TRUE;

                        if (fForward)
                            i += uOffset;
                        else
                            i += pLine->cElements - (uOffset + 1);
                        
                        if (ns.Try(GetChildFromLayoutIndex(pec, i, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }
                    if (!fFoundOne)
                        break;

                    uOffset++;
                }
            }
        }
        else // we're navigating from child within container
        {
            int iLine = GetLine(pec, peFrom);

            switch (iNavDir)
            {
                case NAV_UP:
                    while (iLine > 0)
                    {
                        iLine--;
                        LINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_DOWN:
                    while (iLine < (int) (_cLines - 1))
                    {
                        iLine++;
                        LINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_LEFT:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    while (i > (int) _arLines[iLine].iStart)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, --i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }

                case NAV_RIGHT:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    int iMax = (int) (_arLines[iLine].iStart + _arLines[iLine].cElements - 1);
                    while (i < iMax)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, ++i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }
            }
        }

        pvChildren->Release();

        return ns.peWinner ? ns.peWinner : NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\sources.inc ===
!IF 0

    DirectUI Layout Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\borderlayout.cpp       \
        ..\filllayout.cpp         \
        ..\flowlayout.cpp         \
        ..\gridlayout.cpp         \
        ..\ninegridlayout.cpp     \
        ..\rowlayout.cpp          \
        ..\verticalflowlayout.cpp \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxlayout.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\ninegridlayout.cpp ===
/*
 * NineGridLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duininegridlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// NineGridLayout

////////////////////////////////////////////////////////
// Parser callback (static)

HRESULT NineGridLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    UNREFERENCED_PARAMETER(dNumParams);
    UNREFERENCED_PARAMETER(pParams);

    Layout* pl = NULL;
    HRESULT hr = Create(&pl);
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT NineGridLayout::Create(OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    NineGridLayout* pngl = HNew<NineGridLayout>();
    if (!pngl)
        return E_OUTOFMEMORY;

    pngl->Initialize();

    *ppLayout = pngl;

    return S_OK;
}

void NineGridLayout::Initialize()
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    for (UINT i = 0; i < 9; i++)
        _peTiles[i] = NULL;

    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
}

////////////////////////////////////////////////////////
// Callbacks from clients

// Perform layout
void NineGridLayout::DoLayout(Element* pec, int cx, int cy)
{
    UNREFERENCED_PARAMETER(pec);

    // we use the same number of slots for the starting locations for the elements, but in fact we are not using any of the margin slots;
    // duh!
    int start[NumDims][NumSlots];
    int i,j;


    // determine length of center slots
    for (i = 0; i < NumDims; i++)
    {
        int cRemaining = (i == X) ? cx : cy;

        for (int j = 0; j < NumSlots; j++)
        {
            if (j == Center)
                continue;

            cRemaining -= _length[i][j];
        }

        if (cRemaining < 0)
            // we hit less than zero when we have margins, which are not calculated with 
            // constraints in mind, that sum greater than the element's size
            cRemaining = 0;

        _length[i][Center] = cRemaining;
    }

    // set the start positions by adding the previous slot's  start and length
    for (i = 0; i < NumDims; i++)
    {
        start[i][0] = 0;

        for (j = 1; j < NumSlots; j++)
                start[i][j] = start[i][j-1] + _length[i][j-1];
    }

    
    int iX = 1;
    int iY = 1;

    // loop through the tiles and set the position and size for each occupied cell
    for (i = 0; i < NumCells; i++)
    {
        if (_peTiles[i])
        {
            UpdateLayoutRect(pec, cx, cy, _peTiles[i], start [X][iX], start [Y][iY], _length[X][iX], _length[Y][iY]);
        }

        iX += 2;
        if (iX >= NumSlots)
        {
            iX = 1;
            iY += 2;
        }
    }
}    
 

// Return desired size of this Layout (-1 is auto-size constraint)
// Value returned must not be larger than constraints passed in
// UpdateDesiredSize is called on children to report constrained desired size
SIZE NineGridLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(pec);

    int i,j;

    // initialize all margin lengths to smallest int and all cell lengths to 0
    for (i = 0; i < NumDims; i++)
    {
        for (j = 0; j < NumSlots; j += 2)
        {
            _length[i][j]   = -INT_MAX;
            if ((j + 1) < NumSlots)
                _length[i][j+1] = 0;
        }
    }

    int iY = 1;
    int iX = 1;
    i = 0;
    // scan margins and find the largest margin for each margin slot
    while (i < NumCells)
    {
        if (_peTiles[i])
        {
            Value* pvMargin;
            const RECT* prc = _peTiles[i]->GetMargin(&pvMargin);

            if (_length[X][iX - 1] < prc->left)
                _length[X][iX - 1] = prc->left;
            if (_length[X][iX + 1] < prc->right)
                _length[X][iX + 1] = prc->right;
            if (_length[Y][iY - 1] < prc->top)
                _length[Y][iY - 1] = prc->top;
            if (_length[Y][iY + 1] < prc->bottom)
                _length[Y][iY + 1] = prc->bottom;

            pvMargin->Release();
        }

        i++;
        if (!(i % CellsPerRow))
        {
            iY += 2;
            iX = 1;
        }
        else
            iX += 2;
    }

    int cRemaining[NumDims];

    cRemaining[X] = cxConstraint;
    cRemaining[Y] = cyConstraint;

    // reduce remaining width and height by margin lengths;
    // if any margins are still set to smallest int, then no elements were using that margin, so reset margin length to 0
    for (i = 0; i < NumDims; i++)
    {
        for (j = 0; j < NumSlots; j += 2)
        {
            if (_length[i][j] == -INT_MAX)
                _length[i][j] = 0;
            else
                cRemaining[i] -= _length[i][j];
        }
    }

    int iOrder[NumCells] =  { NGLP_Top, NGLP_Left, NGLP_Bottom, NGLP_Right, NGLP_TopLeft, NGLP_TopRight, NGLP_BottomLeft, NGLP_BottomRight, NGLP_Client };

    for (i = 0; i < NumCells; i++)
    {
        int iTile = iOrder[i];

        if (_peTiles[iTile])
        {
            iY = ((iTile / CellsPerRow) * 2) + 1;
            iX = ((iTile % CellsPerRow) * 2) + 1;

            // add back in the longest length for that slot since this element is actually constrained by not only the remaining size, but
            // also the size currently being set aside for that slot
            cRemaining[X] += _length[X][iX];
            cRemaining[Y] += _length[Y][iY];

            SIZE sizeChild = _peTiles[iTile]->_UpdateDesiredSize(cRemaining[X], cRemaining[Y], psrf);

            // check for longest length for given slot
            if (_length[X][iX] < sizeChild.cx)
                _length[X][iX] = sizeChild.cx;
            if (_length[Y][iY] < sizeChild.cy)
                _length[Y][iY] = sizeChild.cy;

            // remove longest length for that slot to set us up for the next pass (i.e. to undo what was done above when we added it back in;
            // the only difference is that it may have changed to a larger value becuase of this element's desired size -- in which case
            // we'd reduce the remaining size by more than we incresed it above -- which is exactly the behavior we want
            cRemaining[X] -= _length[X][iX];
            cRemaining[Y] -= _length[Y][iY];
        }
    }

    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;

    for (i = 0; i < NumDims; i++)
        for (j = 0; j < NumSlots; j++)
            ((int*) &_sizeDesired)[i] += _length[i][j];

    if (_sizeDesired.cx > cxConstraint)
        _sizeDesired.cx = cxConstraint;

    if (_sizeDesired.cy > cyConstraint)
        _sizeDesired.cy = cyConstraint;

    return _sizeDesired;
}

void NineGridLayout::_UpdateTileList(int iTile, Element* pe)
{
    if ((iTile >= 0) && (iTile < NumCells))
    {
        if (pe)
        {
            DUIAssert(_peTiles[iTile] == NULL, "There can only be one element in each layout position for Nine Grid Layout");
        }
        _peTiles[iTile] = pe;
    }
}

void NineGridLayout::OnAdd(Element* pec, Element** ppeAdd, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
        _UpdateTileList(ppeAdd[i]->GetLayoutPos(), ppeAdd[i]);

    Layout::OnAdd(pec, ppeAdd, cCount);
}

void NineGridLayout::OnRemove(Element* pec, Element** ppeRemove, UINT cCount)
{
    for (UINT i = 0; i < cCount; i++)
        _UpdateTileList(ppeRemove[i]->GetLayoutPos(), NULL);

    Layout::OnRemove(pec, ppeRemove, cCount);
}

void NineGridLayout::OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP)
{
    _UpdateTileList(dOldLP, NULL);
    _UpdateTileList(dNewLP, peChanged);

    Layout::OnLayoutPosChanged(pec, peChanged, dOldLP, dNewLP);
}

Element* NineGridLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
            return NULL;
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = NumCells - 1;
            }

            if (!(iNavDir & NAV_VERTICAL))
                iInc *= 3;

            for (int i = 0; i < 3; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < 3; j++, iTile += iInc)
                {
                    Element* peChild = _peTiles[iTile];

                    if (!peChild)
                        continue;

                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);

                    if (!peTo)
                        continue;

                    if (ns.TrackScore(peChild, peTo))
                        break;
                }

                if (ns.peWinner)
                    return ns.peWinner;

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * 3;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            return NULL;
        }
        else
        {
            int iLayoutPos = peFrom->GetLayoutPos();
            int iPos[2] = { -1, -1 };

            switch (iLayoutPos)
            {
                case NGLP_Left:
                    switch (iNavDir)
                    {
                        case NAV_RIGHT:  iPos[0] = NGLP_Client;      iPos[1] = NGLP_Right; break;
                        case NAV_UP:     iPos[0] = NGLP_TopLeft;     break;
                        case NAV_DOWN:   iPos[0] = NGLP_BottomLeft;  break;
                    }
                    break;

                case NGLP_Top:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Client;      iPos[1] = NGLP_Bottom; break;
                        case NAV_LEFT:   iPos[0] = NGLP_TopLeft;     break;
                        case NAV_RIGHT:  iPos[0] = NGLP_TopRight;    break;
                    }
                    break;

                case NGLP_Right:
                    switch (iNavDir)
                    {
                        case NAV_LEFT:   iPos[0] = NGLP_Client;      iPos[1] = NGLP_Left; break;
                        case NAV_UP:     iPos[0] = NGLP_TopRight;    break;
                        case NAV_DOWN:   iPos[0] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_Bottom:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Client;      iPos[1] = NGLP_Top; break;
                        case NAV_LEFT:   iPos[0] = NGLP_BottomLeft;  break;
                        case NAV_RIGHT:  iPos[0] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_Client:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Top;         break;
                        case NAV_DOWN:   iPos[0] = NGLP_Bottom;      break;
                        case NAV_LEFT:   iPos[0] = NGLP_Left;        break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Right;       break;
                    }
                    break;

                case NGLP_TopLeft:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Left;        iPos[1] = NGLP_BottomLeft; break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Top;         iPos[1] = NGLP_TopRight;   break;
                    }
                    break;

                case NGLP_TopRight:
                    switch (iNavDir)
                    {
                        case NAV_DOWN:   iPos[0] = NGLP_Right;       iPos[1] = NGLP_BottomRight; break;
                        case NAV_LEFT:   iPos[0] = NGLP_Top;         iPos[1] = NGLP_TopLeft;     break;
                    }
                    break;

                case NGLP_BottomLeft:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Left;        iPos[1] = NGLP_TopLeft;     break;
                        case NAV_RIGHT:  iPos[0] = NGLP_Bottom;      iPos[1] = NGLP_BottomRight; break;
                    }
                    break;

                case NGLP_BottomRight:
                    switch (iNavDir)
                    {
                        case NAV_UP:     iPos[0] = NGLP_Right;       iPos[1] = NGLP_TopRight;   break;
                        case NAV_LEFT:   iPos[0] = NGLP_Bottom;      iPos[1] = NGLP_BottomLeft; break;
                    }
                    break;
            }

            for (int i = 0; i < 2; i++)
            {
                if (iPos[i] == -1)
                    return NULL;

                Element* peTile = _peTiles[iPos[i]];
                if (peTile)
                {
                    Element* peTo = peTile->GetAdjacent(NULL, iNavDir, pnr, bKeyableOnly);
                    if (peTo)
                        return peTo;
                }
            }

            return NULL;
        }
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, bKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_LAYOUT_STDAFX_H_INCLUDED
#define DUI_LAYOUT_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_LAYOUT_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\rowlayout.cpp ===
/*
 * RowLayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiRowLayout.h"

namespace DirectUI
{

//
// NOTE: RowLayout is NOT yet thread-safe (access to _arPairs).
// Do not use it in applications where more than one thread uses RowLayout.
//

////////////////////////////////////////////////////////
// RowLayout

struct idLayoutPair
{
    int id;
    RowLayout* prl;
    Value* pv;
};

static DynamicArray<idLayoutPair>* _arPairs = NULL;

//
// for now, we are tracking all instances of RowLayout, using an integer id as a parameter to signal *collaboration*
// i.e. 5 elements that want the same instance of RowLayout will pass the same id in their instantiation calls
//
// ideally, the parser will give us this functionality with:
// <RowLayout res:id=foo res:shared=true />
//
// <Element Layout=res:foo />
// <Element Layout=res:foo />
//
HRESULT RowLayout::InternalCreate(UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout)
{
    *ppLayout = NULL;

    RowLayout* prl = HNew<RowLayout>();

    if (!prl)
        return E_OUTOFMEMORY;

    prl->Initialize(uXAlign, uYAlign);

    *ppLayout = prl;

    return S_OK;
}

HRESULT RowLayout::Create(int dNumParams, int* pParams, OUT Value** ppValue)  // For parser
{
    int idShare = (dNumParams) ? pParams[0] : -1;

    if (idShare >= 0)
    {
        int cPairs = 0;
        if (_arPairs)
            cPairs = _arPairs->GetSize();
        for (int i = 0; i < cPairs; i++)
        {
            idLayoutPair idlp = _arPairs->GetItem(i);
            if (idlp.id == idShare)
            {
                *ppValue = idlp.pv;
                (*ppValue)->AddRef();
                return S_OK;
            }
        }

        if (!_arPairs)
        {
            DynamicArray<idLayoutPair>::Create(0, false, &_arPairs);
            if (!_arPairs)
                return E_OUTOFMEMORY;
        }
    }

    Layout* pl;
    UINT uXAlign = ALIGN_LEFT;
    UINT uYAlign = ALIGN_TOP;
    if (dNumParams > 1)
    {
        uXAlign = (UINT) pParams[1];
        if (dNumParams > 2)
            uYAlign = (UINT) pParams[2];
    }
    HRESULT hr = InternalCreate(uXAlign, uYAlign, &pl);

    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }

    if (idShare >= 0)
    {
        idLayoutPair idlp;
        idlp.id = idShare;
        idlp.prl = (RowLayout*) pl;
        idlp.pv = *ppValue;
        _arPairs->Add(idlp);
    }

    return S_OK;
}

HRESULT RowLayout::Create(int idShare, UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout)
{
    if (idShare >= 0)
    {
        int cPairs = _arPairs ? _arPairs->GetSize() : 0;
        for (int i = 0; i < cPairs; i++)
        {
            idLayoutPair idlp = _arPairs->GetItem(i);
            if (idlp.id == idShare)
            {
                *ppLayout = idlp.prl;
                return S_OK;
            }
        }

        *ppLayout = NULL;


        if (!_arPairs)
        {
            DynamicArray<idLayoutPair>::Create(0, false, &_arPairs);
            if (!_arPairs)
                return E_OUTOFMEMORY;
        }
    }

    Layout* pl;
    HRESULT hr = InternalCreate(uXAlign, uYAlign, &pl);

    if (FAILED(hr))
        return hr;

    if (idShare >= 0)
    {
        idLayoutPair idlp;
        idlp.id = idShare;
        idlp.prl = (RowLayout*) pl;
        idlp.pv = NULL;
        _arPairs->Add(idlp);
    }

    *ppLayout = pl;

    return S_OK;
}

void RowLayout::Initialize(UINT uXAlign, UINT uYAlign)
{
    // Initialize base
    Layout::Initialize();    

    _uXAlign = uXAlign;
    _uYAlign = uYAlign;

    _fRecalc = TRUE;
    _arpeClients = NULL;
    _arxCols = NULL;
    _cCols = 0;
}

RowLayout::~RowLayout()
{
    if (_arpeClients)
        _arpeClients->Destroy();
    // how do we know when to destroy _arPairs?
    //    if (_arPairs->GetSize() == 0)
    //        _arPairs->Destroy();
}

// todo: use a dynamic array -- for arPairs as well
void RowLayout::Attach(Element* pec)
{
    if (!_arpeClients)
    {
        DynamicArray<Element*>::Create(0, false, &_arpeClients);
        if (!_arpeClients)
            return; //todo -- should return an hresult of E_OUTOFMEMORY;
    }

    DUIAssert(_arpeClients->GetIndexOf(pec) == -1, "this client is already attached to this layout");

    _arpeClients->Add(pec);
}

void RowLayout::Detach(Element* pec)
{
    if (_arpeClients)
    {
        int dIgnIdx = _arpeClients->GetIndexOf(pec);
        if (dIgnIdx != -1)
            _arpeClients->Remove(dIgnIdx);
    }

    // todo: _pdaIgnore -- has to be per use
}

////////////////////////////////////////////////////////
// Callbacks from clients

void RowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (IsCacheDirty())
        return;

    _fRecalc = TRUE;
    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    int cxRemaining = cx;
    int xLeft = 0;
    int xRight;
    for (UINT i = 0; i < cChildren; i++)
    {
        peChild = GetChildFromLayoutIndex(pec, i, peList);

        int cxCol;
        if (cxRemaining)
        {
            xRight = _arxCols[i];
            cxCol = xRight - xLeft;
            if (cxCol > cxRemaining)
                cxCol = cxRemaining;

            cxRemaining -= cxCol;
        }
        else
        {
            cxCol = 0;
            xRight = xLeft;
        }
        SIZE size = *(peChild->GetDesiredSize());
        int yChild = 0;
        int xChild = xLeft;
        int cyChild;
        if (_uXAlign != ALIGN_JUSTIFY)
        {
            if (_uXAlign != ALIGN_LEFT)
            {
                int xDelta = cxCol - size.cx;
                if (_uXAlign == ALIGN_RIGHT)
                    xChild += xDelta;
                else
                    xChild += xDelta / 2;
            }
            cxCol = size.cx;
        }
        if (_uYAlign != ALIGN_JUSTIFY)
        {
            if (_uXAlign != ALIGN_LEFT)
            {
                int yDelta = cy - size.cy;
                if (_uXAlign == ALIGN_RIGHT)
                    yChild += yDelta;
                else
                    yChild += yDelta / 2;
            }
            cyChild = size.cy;
        }
        else
            cyChild = cy;


        UpdateLayoutRect(pec, cx, cy, peChild, xChild, yChild, cxCol, cyChild);
        xLeft = xRight;
    }

    pvChildren->Release();
}

struct ClientInfo
{
    UINT cElements;
    ElementList* pel;   
    Value* pvValue;
    Element* peCur;
    int cyMax;
};

// for first column, loop through all clients
//   collect left margin and right margin
// 
// for each column after the first column, loop through all clients
// collect information on the max left margin and the max right margin
// move xRight = xLeft 
//
// i'm thinking that i need to calc right margin as i go -- but that's not true
// because all I'll do is subtract off the left margin, and if there's no room left
// then that means that the next component just doesn't show up -- translation: the
// right margin only matters when there's an element on the right
//

SIZE RowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    SetCacheDirty();

    if (!_fRecalc)
    {
        SIZE size = _sizeDesired;
        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;

        ClearCacheDirty();
            
        return size;
    }

    _fRecalc = FALSE;

    UINT uOldCols = _cCols;
    _cCols = 0;

    int iThisClient = -1;

    UINT cClients = (UINT) _arpeClients->GetSize();
    ClientInfo* arci = (ClientInfo*) _alloca(sizeof(ClientInfo) * cClients);

    for (UINT i = 0; i < cClients; i++)
    {
        Element* peClient = _arpeClients->GetItem(i);
        if (peClient == pec)
            iThisClient = i;

        // GLCC is returning -1 here -- bogus !
        int cElements = GetLayoutChildCount(peClient);
        if ((int) _cCols < cElements)
            _cCols = cElements;
        arci[i].cElements = cElements;
        arci[i].pel = peClient->GetChildren(&(arci[i].pvValue));
        arci[i].cyMax = 0;
    }

    if ((uOldCols != _cCols) || !_arxCols)
    {
        if (_arxCols)
            HFree(_arxCols);
        _arxCols = (UINT*) HAllocAndZero(sizeof(UINT) * _cCols);

        if (!_arxCols)
        {
            SIZE size = {0,0};
            return size;
        }
    }

    int xLeft = -INT_MAX;
    int xRight = -INT_MAX;

    int x = 0;

    for (UINT col = 0; col < _cCols; col++)
    {
        for (i = 0; i < cClients; i++)
        {
            if (arci[i].cElements > col)
            {
                Element* peChild = GetChildFromLayoutIndex(_arpeClients->GetItem(i), col, arci[i].pel);
                arci[i].peCur = peChild;
                
                Value* pv;
                const RECT* prcChildMargin = peChild->GetMargin(&pv); 
                if (xLeft < prcChildMargin->left)
                    xLeft = prcChildMargin->left;
                if (xRight < prcChildMargin->right)
                    xRight = prcChildMargin->right;
                pv->Release();
            }
            else
                arci[i].peCur = NULL; 
        }

        if (col > 0)
        {
            if (xLeft > cxConstraint)
                xLeft = cxConstraint;

            x += xLeft;
            cxConstraint -= xLeft;

            _arxCols[col - 1] = x;
        }

        int cx = 0;
        for (i = 0; i < cClients; i++)
        {
            Element* peCur = arci[i].peCur;
            if (peCur)
            {
                SIZE sizeChild = peCur->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

                if (arci[i].cyMax < sizeChild.cy)
                    arci[i].cyMax = sizeChild.cy;
            
                if (cx < sizeChild.cx)
                    cx = sizeChild.cx;
            }
        }

        if (cx > cxConstraint)
            cx = cxConstraint;

        x += cx;
        cxConstraint -= cx;

        xLeft = xRight;
        xRight = -INT_MAX;
    }

    _arxCols[col - 1] = x;

    _sizeDesired.cx = x;
    _sizeDesired.cy = arci[iThisClient].cyMax;

    for (i = 0; i < cClients; i++)
        arci[i].pvValue->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

Element* RowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
/*
        int cChildren = GetLayoutChildCount(pec);

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            NavScoring ns;

            ns.Init(pec, iNavDir, pnr);

            int iInc = 1;
            int iStart = 0;

            int cCols = GetCurrentCols(cChildren);
            int cRows = GetCurrentRows(cChildren);

            int cOuter, cInner;

            if (!(iNavDir & NAV_FORWARD))
            {
                iInc = -1;
                iStart = (cCols * cRows) - 1;
            }

            if (iNavDir & NAV_VERTICAL)
            {
                cOuter = cRows;
                cInner = cCols;
            }
            else
            {
                cOuter = cCols;
                cInner = cRows;

                iInc *= cCols;
            }

            for (int i = 0; i < cOuter; i++)
            {
                int iTile = iStart;
                for (int j = 0; j < cInner; j++, iTile += iInc)
                {
                    if (iTile >= cChildren)
                        continue;

                    if (ns.Try(GetChildFromLayoutIndex(pec, iTile, peList), iNavDir, pnr, fKeyableOnly))
                        break;
                }

                if (ns.peWinner)
                {
                    pvChildren->Release();
                    return ns.peWinner;
                }

                if (iNavDir & NAV_VERTICAL)
                    iStart += iInc * cCols;
                else
                    iStart += (iNavDir & NAV_FORWARD) ? 1 : -1;
            }

            pvChildren->Release();

            return NULL;
        }
        else // we're navigating from a child within container
        {
            int i = GetLayoutIndexFromChild(pec, peFrom);
            int iInc;
            int iEnd;
            int cCols = GetCurrentCols(cChildren);

            if (iNavDir & NAV_VERTICAL)
            {
                iInc = cCols;
                int iRow = GetRowFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + (((GetCurrentRows(cChildren) - 1) - iRow) * cCols);
                else
                    iEnd = i - (iRow * cCols);
            }
            else
            {
                iInc = 1;
                int iCol = GetColumnFromIndex(cCols, i);

                if (iNavDir & NAV_FORWARD)
                    iEnd = i + ((cCols - 1) - iCol);
                else
                    iEnd = i - iCol;
            }

            if (!(iNavDir & NAV_FORWARD))
                iInc *= -1;

            if (i != iEnd)
            {
                do 
                {
                    i += iInc;

                    Element* peChild = GetChildFromLayoutIndex(pec, i, peList);
                    Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);

                    if (peTo)
                    {
                        pvChildren->Release();
                        return peTo;
                    }
                }
                while (i != iEnd);
            }
        }

        pvChildren->Release();
*/
        return NULL;
    }
    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\stdafxlayout.cpp ===
/*
 * stdafxlayout.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\layout\verticalflowlayout.cpp ===
/*
 * Verticalflowlayout
 */

#include "stdafx.h"
#include "layout.h"

#include "duiverticalflowlayout.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// vertical flow layout

SIZE VerticalFlowLayout::g_sizeZero = { 0, 0 };

// ----------------------------------------------------------------------------------------------------------------
//
//  method overview:
//    public:
//      DoLayout          -- responsible for doing all of the alignment work and placing the elements
//      UpdateDesiredSize -- simply calls BuildCacheInfo
// 
//    protected:
//      BuildCacheInfo    -- the workhorse of this layout -- builds up the line array and per-line element arrays
//
// ----------------------------------------------------------------------------------------------------------------

HRESULT VerticalFlowLayout::Create(int dNumParams, int* pParams, Value** ppValue)  // For parser
{
    Layout* pl = NULL;
    HRESULT hr;
    switch (dNumParams)
    {
    case 1:
        hr = Create(pParams[0] ? true : false, ALIGN_LEFT, ALIGN_CENTER, ALIGN_TOP, &pl);
        break;

    case 2:
        hr =  Create(pParams[0] ? true : false, pParams[1], ALIGN_CENTER, ALIGN_TOP, &pl);
        break;

    case 3:
        hr = Create(pParams[0] ? true : false, pParams[1], pParams[2], ALIGN_TOP, &pl);
        break;

    case 4:
        hr =  Create(pParams[0] ? true : false, pParams[1], pParams[2], pParams[3], &pl);
        break;

    default:
        hr = Create(true, ALIGN_LEFT, ALIGN_CENTER, ALIGN_TOP, &pl);
    }
    
    if (FAILED(hr))
        return hr;

    *ppValue = Value::CreateLayout(pl);
    if (!*ppValue)
    {
        pl->Destroy();
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT VerticalFlowLayout::Create(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign, Layout** ppLayout)
{
    *ppLayout = NULL;

    VerticalFlowLayout* pvfl = HNew<VerticalFlowLayout>();
    if (!pvfl)
        return E_OUTOFMEMORY;

    pvfl->Initialize(fWrap, uXAlign, uXLineAlign, uYLineAlign);

    *ppLayout = pvfl;

    return S_OK;
}

void VerticalFlowLayout::Initialize(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign)
{
    // Initialize base
    Layout::Initialize();    

    // Initialize
    _fWrap = fWrap;
    _uXLineAlign = uXLineAlign;
    _uYLineAlign = uYLineAlign;
    _uXAlign = uXAlign;
    _arLines = NULL;
    _cLines = 0;
    _sizeDesired.cx = 0;
    _sizeDesired.cy = 0;
    _sizeLastConstraint.cx = 0;
    _sizeLastConstraint.cy = 0;
}

VerticalFlowLayout::~VerticalFlowLayout()
{
    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].aryElement)
                HFree(_arLines[k].aryElement);
        }

        HFree(_arLines);
    }
}

////////////////////////////////////////////////////////
// Callbacks from clients

void VerticalFlowLayout::DoLayout(Element* pec, int cx, int cy)
{
    if (!_cLines || IsCacheDirty())
        return;

    Element* peChild;
    UINT cChildren = GetLayoutChildCount(pec);

    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    VLINE *plCur = _arLines + (_cLines - 1);

    int xStart = 0;
    int cxContent = 0;

    if (_uXAlign != ALIGN_LEFT)
    {
        cxContent = plCur->x + plCur->cx;
        int cxDelta = cx - cxContent;

        if (_uXAlign == ALIGN_CENTER)
            xStart = cxDelta / 2;
        else if (_uXAlign == ALIGN_RIGHT)
            xStart = cxDelta;
    }

    plCur = _arLines;
    UINT i = 0;

    for (UINT uLine = 0; uLine < _cLines; uLine++)
    {
        int yStart = 0;

        if (_uYLineAlign == ALIGN_CENTER)
            yStart = (cy - plCur->cy) / 2;
        else if (_uYLineAlign == ALIGN_BOTTOM)
            yStart = cy - plCur->cy;

        int xLine = plCur->x;
        int cxLine = plCur->cx;

        if ((_uXAlign == ALIGN_JUSTIFY) && (cxContent < cx))
        {
            if (!cxContent)
            {
                // zero desired width -- so spread equally among lines
                xLine = cx * uLine / _cLines;
                cxLine = (cx * (uLine + 1) / _cLines) - xLine;
            }
            else
            {
                cxLine = cxLine * cx / cxContent;
                xLine  = xLine  * cx / cxContent;
            }
        }

        int xElement;
        int yElement;
        
        for (UINT uElement = 0; uElement < plCur->cElements; uElement++)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
    
            SIZE size = *(peChild->GetDesiredSize());

            //yElement = (uElement == 0) ? 0 : plCur->aryElement[uElement - 1];
            yElement = 0;
            if (uElement != 0 && plCur->aryElement)
                yElement = plCur->aryElement[uElement - 1];

            xElement = 0;
            if (_uXLineAlign == ALIGN_CENTER)
                xElement = (cxLine - size.cx) / 2;
            else if (_uXLineAlign == ALIGN_RIGHT)
                xElement = cxLine - size.cx;
            else if (_uXLineAlign == ALIGN_JUSTIFY)
                size.cx = cxLine;

            if ((_uYLineAlign == ALIGN_JUSTIFY) && (plCur->cy < (UINT) cy))
            {
                size.cy  = plCur->cy ? (size.cy  * cy / plCur->cy) : 0;
                yElement = plCur->cy ? (yElement * cy / plCur->cy) : 0;
            }

            xElement += xStart + xLine;
            yElement += yStart;

            // constrain it to bounds of layout (0,0)-(cx,cy)
            if (xElement < 0)
            {
                size.cx += xElement;
                xElement = 0;
                if (size.cx < 0)
                    size.cx = 0;
            }
            
            if ((xElement + size.cx) > cx)
            {
                size.cx = cx - xElement;
                if (size.cx < 0)
                    size.cx = 0;
            }

            if (yElement < 0)
            {
                size.cy += yElement;
                yElement = 0;
                if (size.cy < 0)
                    size.cy = 0;
            }

            if ((yElement + size.cy) > cy)
            {
                size.cy = cy - yElement;
                if (size.cy < 0)
                    size.cy = 0;
            }

            UpdateLayoutRect(pec, cx, cy, peChild, xElement, yElement, size.cx, size.cy);

            i++;
        }
        plCur++;
    }

    // this code is only ever hit when the line array does not include all layout elements in the container;
    // currently, this only happens when wrapping is off.
    while (i < cChildren)
    {
        peChild = GetChildFromLayoutIndex(pec, i++, peList);
        UpdateLayoutRect(pec, cx, cy, peChild, 0, 0, 0, 0);
    }

    pvChildren->Release();
}

SIZE VerticalFlowLayout::UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf)
{
    return BuildCacheInfo(pec, cxConstraint, cyConstraint, psrf, false);
}
        
SIZE VerticalFlowLayout::BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize)
{
    UNREFERENCED_PARAMETER(fRealSize);

    SetCacheDirty();

    /*
    if (_arLines != NULL)
    {
        // check to make sure we really have to recalc

        if (cxConstraint == sizeLastConstraint.cx)
            // if cxConstraint doesn't change, then the calculation stays the same
            return _sizeDesired;
    }
    */
    // I'm saving previous constraints to be able to optimize this stage.
    // When I get flags coming into UpdateDesiredSize, I can get rid of this.
    _sizeLastConstraint.cx = cxConstraint;
    _sizeLastConstraint.cy = cyConstraint;

    UINT cChildren = GetLayoutChildCount(pec);

    Element* peChild;
    Value* pvChildren;
    ElementList* peList = pec->GetChildren(&pvChildren); 

    // Check all children for maximum desired size
    // All childrens' UpdateDesiredSize method must be called

    int cxCur = 0;
    int cyCur = 0;
    UINT i = 0;

    if (_arLines)
    {
        for (UINT k = 0; k < _cLines; k++)
        {
            if (_arLines[k].aryElement)
                HFree(_arLines[k].aryElement);
        }

        HFree(_arLines);
    }

    _cLines = 0;

    // Allocate space for the data for the initial line
    _arLines = (VLINE*)HAllocAndZero(sizeof(VLINE) * 1);
    if (!_arLines)
    {
        pvChildren->Release();
        return g_sizeZero;
    }

    int cyMax = 0;

    int cyRealConstraint = cyConstraint;

    int iLeftMargin;
    int iTopMargin;
    int iRightMargin;
    int iBottomMargin;

    int iLineLeftMargin = 0;
    int iLineRightMargin = 0;

    int iPrevLineRightMargin = 0;

    while (i < cChildren)
    {
        cyCur = 0;
        int cxMax;
        int iMargin = 0;

        _cLines++;
        if (_cLines > 1)
        {
            // Allocate space for the data for subsequent lines (space for the first line was alloc'ed outside of this loop
            VLINE* arNewLines = (VLINE*)HReAllocAndZero(_arLines, sizeof(VLINE) * _cLines);
            if (!arNewLines)
            {
                pvChildren->Release();
                HFree(_arLines);
                _arLines = NULL;
                return g_sizeZero;
            }

            _arLines = arNewLines;
        }

        // Initialize line computation with information from first element on line 
        VLINE *plCur = _arLines + (_cLines - 1);

        peChild = GetChildFromLayoutIndex(pec, i, peList);
        SIZE sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

        Value* pv;
        const RECT* prect = peChild->GetMargin(&pv); 
        iLeftMargin   = prect->left;
        iTopMargin    = prect->top;
        iRightMargin  = prect->right;
        iBottomMargin = prect->bottom;
        pv->Release();
        
        plCur->x = cxCur;

        plCur->cElements = 1;
        plCur->iStart = i;
        plCur->aryElement = NULL;

        if (_fWrap)
        {
            // potential for more lines -- keep track of max left and right margins for this line
            if (_cLines > 1)
            {
                if ((_uXLineAlign == ALIGN_LEFT) || (_uXLineAlign == ALIGN_JUSTIFY))
                    // iLineLeftMargin is a running total of max left margin
                    iLineLeftMargin = iLeftMargin;
                else if (_uXLineAlign == ALIGN_CENTER)
                    // iLineLeftMargin is a running total of max thickness / 2 + left margin
                    // (add one because of rounding error only for left)
                    iLineLeftMargin = ((sizeChild.cx + 1) / 2) + iLeftMargin;
                else // _uXLineAlign == ALIGN_RIGHT
                    // iLineLeftMargin is a running total of max thickness + left margin
                    iLineLeftMargin = sizeChild.cx + iLeftMargin;
            }

            if ((_uXLineAlign == ALIGN_RIGHT) || (_uXLineAlign == ALIGN_JUSTIFY))
                // iLineRightMargin is a running total of max right margin
                iLineRightMargin = iRightMargin;
            else if (_uXLineAlign == ALIGN_CENTER)
                // iLineRightMargin is a running total of max thickness / 2 + right margin
                iLineRightMargin = (sizeChild.cx / 2) + iRightMargin;
            else // _uXLineAlign == ALIGN_LEFT
                // iLineRightMargin is a running total of max thickness + right margin
                iLineRightMargin = sizeChild.cx + iRightMargin;
        }

        cxMax = sizeChild.cx;
        cyCur += sizeChild.cy;
        iMargin = iBottomMargin;

        // step to next element
        i++;

        // Line loop -- loop until we go beyond length of line
        while (i < cChildren)
        {
            peChild = GetChildFromLayoutIndex(pec, i, peList);
            sizeChild = peChild->_UpdateDesiredSize(cxConstraint, cyConstraint, psrf);

            const RECT* prect = peChild->GetMargin(&pv); 
            iLeftMargin   = prect->left;
            iTopMargin    = prect->top;
            iRightMargin  = prect->right;
            iBottomMargin = prect->bottom;
            pv->Release();

            // use the max margin value between the bottom margin of the preceding element and
            // the top margin of this element
            if (iMargin < iTopMargin)
                iMargin = iTopMargin;

            if (_fWrap && (cyCur + iMargin + sizeChild.cy > cyRealConstraint))
                // we're wrapping and we went beyond length of line -- break out of this loop
                break;

            if (plCur->cElements == 1)
            {
                plCur->aryElement = (UINT*)HAllocAndZero(sizeof(UINT));
                if (!plCur->aryElement)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }
            }
            else
            {
                UINT* pNew = (UINT*)HReAllocAndZero(plCur->aryElement, sizeof(UINT) * plCur->cElements);
                if (!pNew)
                {
                    pvChildren->Release();
                    return g_sizeZero;
                }

                plCur->aryElement = pNew;
            }

            plCur->aryElement[plCur->cElements - 1] = cyCur + iMargin;
            plCur->cElements++;

            // keep track of the maximum thickness of the elements on this line
            if (cxMax < sizeChild.cx)
                cxMax = sizeChild.cx;

            cyCur += iMargin + sizeChild.cy;

            if (_fWrap)
            {
                // potential for more lines -- keep track of max top and bottom margins for this line
                if (_cLines > 1)
                {
                    // keep track of the maximum left margin on this line
                    if ((_uXLineAlign == ALIGN_LEFT) || (_uXLineAlign == ALIGN_JUSTIFY))
                        // iLineLeftMargin is a running total of max left margin
                        iMargin = iLeftMargin;
                    else if (_uXLineAlign == ALIGN_CENTER)
                        // iLineLeftMargin is a running total of max thickness / 2 + left margin
                        // (add one because of rounding error only for left)
                        iMargin = ((sizeChild.cx + 1) / 2) + iLeftMargin;
                    else // _uXLineAlign == ALIGN_RIGHT
                        // iLineTopMargin is a running total of max thickness + left margin
                        iMargin = sizeChild.cx + iLeftMargin;

                    if (iLineLeftMargin < iMargin)
                        iLineLeftMargin = iMargin;
                }

                // keep track of the maximum right margin on this line
                if ((_uXLineAlign == ALIGN_RIGHT) || (_uXLineAlign == ALIGN_JUSTIFY))
                    // iLineRightMargin is a running total of max right margin
                    iMargin = iRightMargin;
                else if (_uXLineAlign == ALIGN_CENTER)
                    // iLineRightMargin is a running total of max thickness / 2 + right margin
                    iMargin = (sizeChild.cx / 2) + iRightMargin;
                else // _uXLineAlign == ALIGN_LEFT
                    // iLineRightMargin is a running total of max thickness + right margin
                    iMargin = sizeChild.cx + iRightMargin;

                if (iLineRightMargin < iMargin)
                    iLineRightMargin = iMargin;
            }

            iMargin = iBottomMargin;
            i++;
        }

        if (cyMax < cyCur)
            cyMax = cyCur;

        if (_fWrap)
        {
            // adjust margin running totals to reflect residual margin --
            // the bummer here is that we have to nuke negative margins because otherwise we're messed up
            if (_uXLineAlign == ALIGN_CENTER)
            {
                iLineLeftMargin -= (cxMax + 1) / 2;
                if (iLineLeftMargin < 0)
                    iLineLeftMargin = 0;

                iLineRightMargin -= cxMax / 2;
                if (iLineRightMargin < 0)
                    iLineRightMargin = 0;
            }
            else if (_uXLineAlign == ALIGN_RIGHT)
            {
                iLineLeftMargin -= cxMax;
                if (iLineLeftMargin < 0)
                    iLineLeftMargin = 0;
            }
            else if (_uXLineAlign == ALIGN_LEFT)
            {
                iLineRightMargin -= cxMax;
                if (iLineRightMargin < 0)
                    iLineRightMargin = 0;
            }

            if (_cLines > 1)
            {
                // account for margins between lines

                if (iPrevLineRightMargin < iLineLeftMargin)
                    iPrevLineRightMargin = iLineLeftMargin;

                // iPrevLineRightMargin is now the max margin between the previous line and this line
                plCur->x += iPrevLineRightMargin;
                cxCur += iPrevLineRightMargin;
            }

            // save off this line's right margin to compare with the next line's resulting left margin
            iPrevLineRightMargin = iLineRightMargin;
        }

        cxCur += cxMax;

        plCur->cy = cyCur;
        plCur->cx = cxMax;
    }

    _sizeDesired.cy = (cyMax < cyConstraint) ? cyMax : cyConstraint;
    _sizeDesired.cx = (cxCur < cxConstraint) ? cxCur : cxConstraint;

    pvChildren->Release();

    ClearCacheDirty();

    return _sizeDesired;
}

int VerticalFlowLayout::GetLine(Element* pec, Element* pe)
{
    int iChild = GetLayoutIndexFromChild(pec, pe);

    if (iChild >= 0)
    {
        UINT uChild = (UINT) iChild;

        for (UINT i = 0; i < _cLines; i++)
        {
            VLINE* pLine = _arLines + i;
            if (uChild < (pLine->iStart + pLine->cElements))
                return i;
        }
    }
    return -1;
}

Element* VerticalFlowLayout::GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly)
{
    // This is the most common outer check -- normally, a layout manager will only provide specialized work for
    // directional navgation; logical navigation will fall through to the default implementation
    if (!(iNavDir & NAV_LOGICAL))
    {
        if (!_cLines || IsCacheDirty())
            return NULL;

        Value* pvChildren;
        ElementList* peList = pec->GetChildren(&pvChildren); 

        NavScoring ns;

        ns.Init(pec, iNavDir, pnr);

        // This is the second most common outer check -- there tends to be three common codepaths for handling directional
        // navigation:
        //    1) the navigation is occurring from the container itself, in which case the rule for directional navigation
        //       is that if the container is focusable, then you can't directionally navigate to inside this container --
        //       you use the tab key to step inside the container
        //    2) the navigation is occurring from outside the container, in which case we're tunnelling in from one of the 
        //       side of the container
        //    3) the navigation is occurring from a child within the container, in which case we're moving to a sibling (or
        //       hitting a side of the container
        if (peFrom == pec)
        {
            pvChildren->Release();
            return NULL;
        }
        else if (!peFrom)
        {
            // navigation coming from outside -- run through the children in the appropriate order depending on the direction
            bool fForward = ((iNavDir & NAV_FORWARD) != 0);

            if (!(iNavDir & NAV_VERTICAL))
            {
                int l = fForward ? 0 : (_cLines - 1);
                VLINE* pLine = _arLines + l;
                while (!ns.peWinner)
                {
                    for (UINT i = 0; i < pLine->cElements; i++)
                    {
                        if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }

                    if (fForward)
                    {
                        l++;
                        if ((UINT) l == _cLines)
                            break;

                        pLine++;
                    }
                    else
                    {
                        if (pLine == _arLines)
                            break;
                        pLine--;
                    }
                }
            }
            else
            {
                UINT uOffset = 0;
                
                while (!ns.peWinner)
                {
                    BOOL fFoundOne = FALSE;

                    for (UINT l = 0; l < _cLines; l++)
                    {
                        VLINE* pLine = _arLines + l;
                        int i = pLine->iStart;

                        if (uOffset >= pLine->cElements)
                            continue;

                        fFoundOne = TRUE;

                        if (fForward)
                            i += uOffset;
                        else
                            i += pLine->cElements - (uOffset + 1);
                        
                        if (ns.Try(GetChildFromLayoutIndex(pec, i, peList), iNavDir, pnr, fKeyableOnly))
                            break;
                    }
                    if (!fFoundOne)
                        break;

                    uOffset++;
                }
            }
        }
        else // we're navigating from child within container
        {
            int iLine = GetLine(pec, peFrom);

            switch (iNavDir)
            {
                case NAV_LEFT:
                    while (iLine > 0)
                    {
                        iLine--;
                        VLINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_RIGHT:
                    while (iLine < (int) (_cLines - 1))
                    {
                        iLine++;
                        VLINE* pLine = _arLines + iLine;
                        for (UINT i = 0; i < pLine->cElements; i++)
                        {
                            if (ns.Try(GetChildFromLayoutIndex(pec, i + pLine->iStart, peList), iNavDir, pnr, fKeyableOnly))
                                break;
                        }

                        if (ns.peWinner)
                            break;
                    }
                    break;

                case NAV_UP:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    while (i > (int) _arLines[iLine].iStart)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, --i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }

                case NAV_DOWN:
                {
                    int i = GetLayoutIndexFromChild(pec, peFrom);
                    int iMax = (int) (_arLines[iLine].iStart + _arLines[iLine].cElements - 1);
                    while (i < iMax)
                    {
                        Element* peChild = GetChildFromLayoutIndex(pec, ++i, peList);
                        Element* peTo = peChild->GetAdjacent(NULL, iNavDir, pnr, fKeyableOnly);
                        if (peTo)
                        {
                            pvChildren->Release();
                            return peTo;
                        }
                    }
                    break;
                }
            }
        }

        pvChildren->Release();

        return ns.peWinner ? ns.peWinner : NULL;
    }

    return Layout::GetAdjacent(pec, peFrom, iNavDir, pnr, fKeyableOnly);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\makefile.inc ===
#
# Parser generation
#

Parse.cpp: parse.y
    set bison_simple=$(PARSERTOOLS)\Bison.skl 
    $(PARSERTOOLS)\bison -l -o$@ -d $**

Scan.cpp: scan.l
    $(PARSERTOOLS)\flex -B -L -o$@ -S$(PARSERTOOLS)\flex.skl $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_PARSER_PUBLISHED_H_INCLUDED
#define DUI_PARSER_PUBLISHED_H_INCLUDED

#include "duiparserobj.h"

#endif // DUI_PARSER_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\parser.cpp ===
/*
 * Parser
 */

/*
 * Parser tree instantiation and Value creation is one pass. Nodes are marked as "fixup"
 * if names cannot be resolved until more information is known (i.e. PropertyInfo's cannot
 * be known until the Element Class is known)
 */

// The parser deals with UNICODE input only
// Scan.c and Parse.c will always be built UNICODE enabled

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"

#define DIRECTUIPP_IGNORESYSDEF
#include "directuipp.h"  // Duplicate system defines ignored

namespace DirectUI
{

////////////////////////////////////////////////////////
// Control library class registration (process init)

HRESULT RegisterAllControls()
{
    HRESULT hr;
    
    // Create all ClassInfos for DirectUI controls. These
    // objects will be referenced by each class. A ClassInfo
    // mapping will be established as well

    // Any failure will cause process initialization to fail

    hr = Element::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Button::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Combobox::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Edit::Register();
    if (FAILED(hr))
        goto Failure;

    hr = HWNDElement::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = HWNDHost::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Progress::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = RefPointElement::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = RepeatButton::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = ScrollBar::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = ScrollViewer::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Selector::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Thumb::Register();
    if (FAILED(hr))
        goto Failure;
        
    hr = Viewer::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}

////////////////////////////////////////////////////////
// Parser tables

// For LayoutPos values only
EnumTable _et[] =  { 
                        { L"auto",               -1 },
                        { L"absolute",           LP_Absolute },
                        { L"none",               LP_None },
                        { L"left",               BLP_Left },
                        { L"top",                BLP_Top },
                        { L"right",              BLP_Right },
                        { L"bottom",             BLP_Bottom },
                        { L"client",             BLP_Client },
                        { L"ninetopleft",        NGLP_TopLeft },
                        { L"ninetop",            NGLP_Top },
                        { L"ninetopright",       NGLP_TopRight },
                        { L"nineleft",           NGLP_Left },
                        { L"nineclient",         NGLP_Client },
                        { L"nineright",          NGLP_Right },
                        { L"ninebottomleft",     NGLP_BottomLeft },
                        { L"ninebottom",         NGLP_Bottom },
                        { L"ninebottomright",    NGLP_BottomRight },
                   };

LayoutTable _lt[] = {
                        { L"borderlayout",       BorderLayout::Create },
                        { L"filllayout",         FillLayout::Create },
                        { L"flowlayout",         FlowLayout::Create },
                        { L"gridlayout",         GridLayout::Create },
                        { L"ninegridlayout",     NineGridLayout::Create },
                        { L"rowlayout",          RowLayout::Create },
                        { L"verticalflowlayout", VerticalFlowLayout::Create },
                    };

SysColorTable _sct[] = {
                        { L"activeborder",       COLOR_ACTIVEBORDER },
                        { L"activecaption",      COLOR_ACTIVECAPTION },
                        { L"appworkspace",       COLOR_APPWORKSPACE },
                        { L"background",         COLOR_BACKGROUND },
                        { L"buttonface",         COLOR_BTNFACE },
                        { L"buttonhighlight",    COLOR_BTNHIGHLIGHT },
                        { L"buttonshadow",       COLOR_BTNSHADOW },
                        { L"buttontext",         COLOR_BTNTEXT },
                        { L"captiontext",        COLOR_CAPTIONTEXT },
                        { L"GradientActiveCaption", COLOR_GRADIENTACTIVECAPTION },
                        { L"GradientInactiveCaption", COLOR_GRADIENTINACTIVECAPTION },
                        { L"graytext",           COLOR_GRAYTEXT },
                        { L"highlight",          COLOR_HIGHLIGHT },
                        { L"highlighttext",      COLOR_HIGHLIGHTTEXT },
                        { L"HotLight",           COLOR_HOTLIGHT },
                        { L"inactiveborder",     COLOR_INACTIVEBORDER },
                        { L"inactivecaption",    COLOR_INACTIVECAPTION },
                        { L"inactivecaptiontext", COLOR_INACTIVECAPTIONTEXT },
                        { L"infobackground",     COLOR_INFOBK },
                        { L"infotext",           COLOR_INFOTEXT },
                        { L"menu",               COLOR_MENU },
                        { L"menutext",           COLOR_MENUTEXT },
                        { L"scrollbar",          COLOR_SCROLLBAR },
                        { L"threeddarkshadow",   COLOR_3DDKSHADOW },
                        { L"threedface",         COLOR_3DFACE },
                        { L"threedhighlight",    COLOR_3DHIGHLIGHT },
                        { L"threedlightshadow",  COLOR_3DLIGHT },
                        { L"threedshadow",       COLOR_3DSHADOW },
                        { L"window",             COLOR_WINDOW },
                        { L"windowframe",        COLOR_WINDOWFRAME },
                        { L"windowtext",         COLOR_WINDOWTEXT },
                    };

////////////////////////////////////////////////////////
// Current parser context that Flex and Bison act on
// This variable also acts as a threading lock

Parser* Parser::g_pParserCtx = NULL;
HDC Parser::g_hDC = NULL;
int Parser::g_nDPI = 0;
bool Parser::g_fParseAbort = false;
HRESULT Parser::g_hrParse;

// Flex/Bison methods and global variables
int yyparse();
BOOL yyrestart(FILE* yyin);
void yy_delete_current_buffer();  // Custom, defined in scan.l

extern int yylineno;

// Used to force an error in the parser and terminate
void CallbackParseError(LPCWSTR pszError, LPCWSTR pszToken);

////////////////////////////////////////////////////////
// Construction

// Parse input (single byte buffer)
HRESULT Parser::Create(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pBuffer, cCharCount, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pBuffer, cCharCount, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;
    *_szDrive = 0;
    *_szPath = 0;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }
   
    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    HRESULT hr = _ParseBuffer(pBuffer, cCharCount);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

// Parser based on a resource (resource type must be "UIFile")
HRESULT Parser::Create(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(uRCID, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(uRCID, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;
    *_szDrive = 0;
    *_szPath = 0;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }

    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    // Locate resource
    WCHAR szID[41];
    swprintf(szID, L"#%u", uRCID);

    HRESULT hr;

    // Assuming 0th contains UI file resource
    HINSTANCE hInstUI = static_cast<HINSTANCE>(_pHList[0]);

    HRSRC hResInfo = FindResourceW(hInstUI, szID, L"UIFile");
    DUIAssert(hResInfo, "Unable to locate resource");

    if (hResInfo)
    {
        HGLOBAL hResData = LoadResource(hInstUI, hResInfo);
        DUIAssert(hResData, "Unable to load resource");

        if (hResData)
        {
            const CHAR* pBuffer = (const CHAR*)LockResource(hResData);
            DUIAssert(pBuffer, "Resource could not be locked");

            hr = _ParseBuffer(pBuffer, SizeofResource(hInstUI, hResInfo) / sizeof(CHAR));
            if (FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

// Parser input file
HRESULT Parser::Create(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pFile, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Create(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    Parser* pp = HNew<Parser>();
    if (!pp)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pp->Initialize(pFile, pHList, pfnErrorCB);
    if (FAILED(hr))
    {
        pp->Destroy();
        return hr;
    }

    *ppParser = pp;

    return S_OK;
}

HRESULT Parser::Initialize(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB)
{
    // Set state
    _pHList = pHList;

    if (!_pHList)
    {
        _hDefault = NULL;
        _pHList = &_hDefault;
    }

    // Setup callback
    _fParseError = false;
    _pfnErrorCB = pfnErrorCB;

    HRESULT hr;
    HANDLE hFile = NULL;
    DWORD dwBytesRead = 0;
    int dBufChars = 0;

    // Values to free on failure
    LPSTR pParseBuffer = NULL;

    OFSTRUCT of = { 0 };
    of.cBytes = sizeof(OFSTRUCT);

    hFile = CreateFileW(pFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        _ParseError(L"Could not open file", pFile, -1);
        return S_OK;
    }

    // Save the path to the file being parsed for resolution of all paths
    // specified in the file being parsed
    LPWSTR pszLastSlash = 0;
    LPWSTR pszColon = 0;
    LPWSTR pszWalk = _szDrive;

    wcscpy(_szDrive, pFile);

    // find the first colon and the last slash in the path
    while (*pszWalk)
    {
        if (!pszColon && (*pszWalk == ':'))
            pszColon = pszWalk;
        else if ((*pszWalk == '\\') || (*pszWalk == '/'))
            pszLastSlash = pszWalk;
        pszWalk++;
    }

    SSIZE_T iOffset;
    if (pszColon)
    {
        wcscpy(_szPath, pszColon + 1);
        *(pszColon + 1) = 0;
        iOffset = pszLastSlash - (pszColon + 1);
    }
    else
    {
        wcscpy(_szPath, _szDrive);
        *_szDrive = 0;
        iOffset = pszLastSlash - _szDrive;
    }

    // pszLastSlash is now a relative to the beginning of the path
    if (iOffset >= 0)
        *(_szPath + iOffset + 1) = 0; // there was a slash, strip off everything after that slash
    else                              
        *_szPath = 0;  // there was no slash or colon, so there is no path

    // Read file straight into buffer (single-byte)
    DWORD dwSize = GetFileSize(hFile, NULL);
    pParseBuffer = (LPSTR)HAlloc(dwSize);
    if (!pParseBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    dBufChars = dwSize / sizeof(CHAR);

    ReadFile(hFile, (void*)pParseBuffer, dwSize, &dwBytesRead, NULL);
    DUIAssert(dwSize == dwBytesRead, "Unable to buffer entire file");

    CloseHandle(hFile);
    hFile = NULL;

    // Parse
    hr = _ParseBuffer(pParseBuffer, dBufChars);
    if (FAILED(hr))
        goto Failed;

    // Free buffer
    HFree(pParseBuffer);

    return S_OK;

Failed:

    if (hFile)
        CloseHandle(hFile);

    if (pParseBuffer)
        HFree(pParseBuffer);

    return hr;
}

void Parser::_DestroyTables()
{
    // Free non-node, non-temp parse tree memory (stored by nodes)
    if (_pdaMemTrack)
    {
        for (UINT i = 0; i < _pdaMemTrack->GetSize(); i++)
            HFree(_pdaMemTrack->GetItem(i));
        _pdaMemTrack->Reset();

        _pdaMemTrack->Destroy();
        _pdaMemTrack = NULL;
    }

    // Free all nodes
    if (_pdaNodeMemTrack)
    {
        Node* pn;
        for (UINT i = 0; i < _pdaNodeMemTrack->GetSize(); i++)
        {
            pn = _pdaNodeMemTrack->GetItem(i);

            // Do any node-specific cleanup
            switch (pn->nType)
            {
            case NT_ValueNode:
                if(((ValueNode*)pn)->nValueType == VNT_Normal)
                    ((ValueNode*)pn)->pv->Release();
                break;

            case NT_ElementNode:
                if (((ElementNode*)pn)->pvContent)
                    ((ElementNode*)pn)->pvContent->Release();
                break;            

            case NT_SheetNode:
                if (((SheetNode*)pn)->pvSheet)
                    ((SheetNode*)pn)->pvSheet->Release();
                break;
            }

            // Free node
            HFree(pn);
        }

        _pdaNodeMemTrack->Destroy();
        _pdaNodeMemTrack = NULL;
    }

    // Clear rest of tables
    if (_pdaTempMemTrack)
    {
        _pdaTempMemTrack->Destroy();
        _pdaTempMemTrack = NULL;
    }

    if (_pdaSheetList)
    {
        _pdaSheetList->Destroy();
        _pdaSheetList = NULL;
    }

    if (_pdaElementList)
    {
        _pdaElementList->Destroy();
        _pdaElementList = NULL;
    }
}

// Free parser state
Parser::~Parser()
{
    _DestroyTables();
}

HRESULT Parser::_ParseBuffer(const CHAR* pBuffer, int cCharCount)
{
    // Create tables
    _pdaElementList = NULL;
    _pdaSheetList = NULL;
    _pdaNodeMemTrack = NULL;
    _pdaMemTrack = NULL;
    _pdaTempMemTrack = NULL;

    HRESULT hr;

    hr = DynamicArray<ElementNode*>::Create(0, false, &_pdaElementList);  // Root Element list
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<SheetNode*>::Create(0, false, &_pdaSheetList);      // Sheet list
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Node*>::Create(0, false, &_pdaNodeMemTrack);        // Parser nodes
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<void*>::Create(0, false, &_pdaMemTrack);            // Parser node extra memory
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<void*>::Create(0, false, &_pdaTempMemTrack);        // Temp parse-time only memory
    if (FAILED(hr))
        goto Failed;

    // Global lock of parser (one Parser as context per parse)
    g_plkParser->Enter();

    // Set global bison/flex context to this
    g_pParserCtx = this;
    g_hDC = GetDC(NULL);
    g_nDPI = g_hDC ? GetDeviceCaps(g_hDC, LOGPIXELSY) : 0;
    g_fParseAbort = false;

    // Set parse buffer pointer to buffer passed in
    _pInputBuf = pBuffer;
    _dInputChars = cCharCount;
    _dInputPtr = 0;

    g_hrParse = S_OK;  // Track abnormal errors during parse

    // Reset the scanner (will create default (current) buffer)
    if (!yyrestart(NULL))
        g_hrParse = DU_E_GENERIC;  // Internal scanner error

    // Do parse if yyrestart was successful
    if (SUCCEEDED(g_hrParse))
    {
        if (yyparse()) // Non-zero on error
        {
            // A production callback will have already set the appropriate HRESULT
            // If an internal scanning/parser or syntax error occurred, the result code will
            // not have set. Set it manually
            if (SUCCEEDED(g_hrParse))
                g_hrParse = DU_E_GENERIC;
        }
    }

    // Free the default (current) scanning buffer
    yy_delete_current_buffer();
    yylineno = 1;

    // Done with parser lock
    if (g_hDC)
        ReleaseDC(NULL, g_hDC);
    Parser::g_pParserCtx = NULL;

    // Unlock parser
    g_plkParser->Leave();

    // Free temporary parser-time allocations (strings and Flex/Bison allocations)
    for (UINT i = 0; i < _pdaTempMemTrack->GetSize(); i++)
        HFree(_pdaTempMemTrack->GetItem(i));
    _pdaTempMemTrack->Reset();

    if (FAILED(g_hrParse))
    {
        hr = g_hrParse;
        goto Failed;
    }

    return S_OK;

Failed:

    _fParseError = true;

    _DestroyTables();

    return hr;
}

// Input
int Parser::_Input(CHAR* pBuffer, int cMaxChars)
{
    if (_dInputPtr == _dInputChars)
        return 0;  // EOF

    int cCharsRead;

    if (_dInputPtr + cMaxChars > _dInputChars)
    {
        cCharsRead = _dInputChars - _dInputPtr;
    }
    else
    {
        cCharsRead = cMaxChars;
    }

    CopyMemory(pBuffer, _pInputBuf + _dInputPtr, sizeof(CHAR) * cCharsRead);

    _dInputPtr += cCharsRead;

    return cCharsRead;
}

////////////////////////////////////////////////////////
// Parser/scanner memory allocation (parse pass (temp) and parser lifetime)

// Memory allocation tracking for tree Nodes
void* Parser::_TrackNodeAlloc(SIZE_T s)
{
    Node* pm = (Node*)HAlloc(s);

    if (pm)
        _pdaNodeMemTrack->Add(pm);

    return pm;
}

void Parser::_UnTrackNodeAlloc(Node* pm)
{
    int i = _pdaNodeMemTrack->GetIndexOf(pm);
    if (i != -1)
        _pdaNodeMemTrack->Remove(i);
}

// Memory allocation tracking for Node extra dynamic state
void* Parser::_TrackAlloc(SIZE_T s)
{
    Node* pm = (Node*)HAlloc(s);

    if (pm)
        _pdaMemTrack->Add(pm);

    return pm;
}

// Memory allocation tracking for temporary memory used during parse
// This includes all string values (those in double quotes) from the scanner and
// all identifiers to be fixed up (propertyinfo's and enums) as well as memory
// required by the scanner/parser (such as params list build up)
void* Parser::_TrackTempAlloc(SIZE_T s)
{
    void* pm = HAlloc(s);

    if (pm)
        _pdaTempMemTrack->Add(pm);

    return pm;
}

void Parser::_TrackTempAlloc(void* pm)
{
    _pdaTempMemTrack->Add(pm);
}

void* Parser::_TrackTempReAlloc(void* pm, SIZE_T s)
{
    // Attempt to realloc
    void* pnew = HReAlloc(pm, s);
    if (pnew)
    {
        // Update tracking if moved
        if (pm != pnew)
        {
            _UnTrackTempAlloc(pm);

            _pdaTempMemTrack->Add(pnew);
        }
    }

    return pnew;
}

void Parser::_UnTrackTempAlloc(void* pm)
{
    int i = _pdaTempMemTrack->GetIndexOf(pm);
    if (i != -1)
        _pdaTempMemTrack->Remove(i);
}

////////////////////////////////////////////////////////
// Error condition, called only during parse (construction)

void Parser::_ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR sz[101];
    _snwprintf(sz, DUIARRAYSIZE(sz), L"DUIParserFailure: %s '%s' %d\n", pszError, pszToken, dLine);
    sz[DUIARRAYSIZE(sz)-1] = NULL;  // Clip
    
    OutputDebugStringW(sz);
    
    // Use callback if provided
    if (_pfnErrorCB)
        _pfnErrorCB(pszError, pszToken, dLine);
}

////////////////////////////////////////////////////////
// Parse Tree Node creation callbacks

// All values passed to callbacks are only guaranteed good
// for the lifetime of the callback

// Parser callback to create Values (if possible)
ValueNode* Parser::_CreateValueNode(BYTE nValueType, void* pData)
{
    ValueNode* pvn = (ValueNode*)_TrackNodeAlloc(sizeof(ValueNode));
    if (!pvn)
    {
        g_hrParse = E_OUTOFMEMORY;
        goto Failure;
    }

    ZeroMemory(pvn, sizeof(ValueNode));

    // Store node type and specifiec ValueNode type
    pvn->nType = NT_ValueNode;
    pvn->nValueType = nValueType;

    switch (nValueType)
    {
    case VNT_Normal:
        if (!pData)
        {
            CallbackParseError(L"Value creation failed", L"");
            goto Failure;
        }
        pvn->pv = (Value*)pData;  // Use ref count
        break;

    case VNT_LayoutCreate:
        {
        LayoutCreate* plc = (LayoutCreate*)pData;

        // Get layout creation information
        PLAYTCREATE pfnLayoutHold = ConvertLayout(plc->pszLayout);

        if (!pfnLayoutHold)
        {
            CallbackParseError(L"Unknown Layout:", plc->pszLayout);
            goto Failure;  // Unknown layout
        }

        pvn->lc.pfnLaytCreate = pfnLayoutHold;
        pvn->lc.dNumParams = plc->dNumParams;

        // Duplicate parameters for Parser lifetime storage
        if (pvn->lc.dNumParams)
        {
            pvn->lc.pParams = (int*)_TrackAlloc(sizeof(int) * pvn->lc.dNumParams);
            if (!pvn->lc.pParams)
            {
                g_hrParse = E_OUTOFMEMORY;
                goto Failure;
            }
            CopyMemory(pvn->lc.pParams, plc->pParams, sizeof(int) * pvn->lc.dNumParams);
        }
        }
        break;

    case VNT_SheetRef:
        // Store ResID
        pvn->psres = (LPWSTR)_TrackAlloc((wcslen((LPWSTR)pData) + 1) * sizeof(WCHAR));
        if (!pvn->psres)
        {
            g_hrParse = E_OUTOFMEMORY;
            goto Failure;
        }
        wcscpy(pvn->psres, (LPWSTR)pData);
        break;

    case VNT_EnumFixup:
        // Store temp tracked list of enumeration strings for later fixup
        pvn->el = *((EnumsList*)pData);
        break;
    }

    return pvn;

Failure:

    // Failure creating Value node, parser will abort and free all parser tables.
    // Make sure this node isn't in the table

    if (pvn)
    {
        _UnTrackNodeAlloc(pvn);
        HFree(pvn);
    }

    return NULL;
}

// Parser callback to create Property/Value pair nodes (requires fixup)
// If a logical operation is provided, an AttribNode is created instead (subclass of PropValPairNode)
PropValPairNode* Parser::_CreatePropValPairNode(LPCWSTR pszProperty, ValueNode* pvn, UINT* pnLogOp)
{
    PropValPairNode* ppvpn = (PropValPairNode*)_TrackNodeAlloc((!pnLogOp) ? sizeof(PropValPairNode) : sizeof(AttribNode));
    if (!ppvpn)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(ppvpn, (!pnLogOp) ? sizeof(PropValPairNode) : sizeof(AttribNode));

    // Store node type and specific PropValPairNode type
    ppvpn->nType = NT_PropValPairNode;
    ppvpn->nPropValPairType = PVPNT_Fixup;  // Type is always fixup from parser

    // Copy property string from parser (parse phase-only alloc)
    ppvpn->pszProperty = (LPWSTR)_TrackTempAlloc((wcslen(pszProperty) + 1) * sizeof(WCHAR));
    if (!ppvpn->pszProperty)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    wcscpy(ppvpn->pszProperty, pszProperty);

    // Store value
    ppvpn->pvn = pvn;

    if (pnLogOp)
        ((AttribNode*)ppvpn)->nLogOp = *pnLogOp;

    return ppvpn;
}

// Parser callback to create Rule nodes (will fixup PropertyInfo's and Enum values)
RuleNode* Parser::_CreateRuleNode(LPCWSTR pszClass, AttribNode* pCondNodes, PropValPairNode* pDeclNodes)
{
    RuleNode* prn = (RuleNode*)_TrackNodeAlloc(sizeof(RuleNode));
    if (!prn)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(prn, sizeof(RuleNode));

    // Store node type
    prn->nType = NT_RuleNode;

    // Set Rule-specific members, resolve Element class
    prn->pCondNodes = pCondNodes;
    prn->pDeclNodes = pDeclNodes;

    prn->pci = ConvertElement(pszClass);

    if (!prn->pci)
    {
        CallbackParseError(L"Unknown element type:", pszClass);
        return NULL;
    }

    // Fixup PropertyInfo's of conditionals
    PropValPairNode* ppvpn = pCondNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, prn->pci, true))
            return NULL;

        ppvpn = ppvpn->pNext;
    }

    // Fixup PropertyInfo's of declarations
    ppvpn = pDeclNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, prn->pci, true))
            return NULL;

        // Make sure this property can be used in a declaration
        if (!(ppvpn->ppi->fFlags & PF_Cascade))
        {
            CallbackParseError(L"Property cannot be used in a Property Sheet declaration:", ppvpn->pszProperty);
            return NULL;
        }

        ppvpn = ppvpn->pNext;
    }

    return prn;
}

// Parser callback to create Element nodes (will fixup PropertyInfo's and Enum values)
ElementNode* Parser::_CreateElementNode(StartTag* pst, Value* pvContent)
{
    ElementNode* pen = (ElementNode*)_TrackNodeAlloc(sizeof(ElementNode));
    if (!pen)
    {
        g_hrParse = E_OUTOFMEMORY;
        return NULL;
    }
    ZeroMemory(pen, sizeof(ElementNode));

    // Store node type
    pen->nType = NT_ElementNode;

    // Set Element-specific members, resolve Element class
    pen->pPVNodes = pst->pPVNodes;
    pen->pvContent = pvContent;  // Use ref count
    pen->pszResID = NULL;

    pen->pci = ConvertElement(pst->szTag);

    if (!pen->pci)
    {
        CallbackParseError(L"Unknown element type:", pst->szTag);
        return NULL;
    }

    // Fixup PropertyInfo's of this Element
    PropValPairNode* ppvpn = pst->pPVNodes;
    while (ppvpn)
    {
        DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

        // Fixup node
        if (!_FixupPropValPairNode(ppvpn, pen->pci, false))
            return NULL;

        ppvpn = ppvpn->pNext;
    }

    // Store ResID if available
    if (pst->szResID[0])
    {
        pen->pszResID = (LPWSTR)_TrackAlloc((wcslen(pst->szResID) + 1) * sizeof(WCHAR));
        if (!pen->pszResID)
        {
            g_hrParse = E_OUTOFMEMORY;
            return NULL;
        }
        wcscpy(pen->pszResID, pst->szResID);
    }

    return pen;
}

// Parser callback to create Sheet nodes
SheetNode* Parser::_CreateSheetNode(LPCWSTR pszResID, RuleNode* pRuleNodes)
{
    HRESULT hr;
    SheetNode* psn = NULL;
    PropertySheet* pps = NULL;
    RuleNode* pRuleNode = NULL;

    // Values to free on failure
    DynamicArray<Cond>* _pdaConds = NULL;
    DynamicArray<Decl>* _pdaDecls = NULL;

    psn = (SheetNode*)_TrackNodeAlloc(sizeof(SheetNode));
    if (!psn)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    ZeroMemory(psn, sizeof(SheetNode));

    // Store node type
    psn->nType = NT_SheetNode;

    // Set Sheet-specific members
    psn->pRules = pRuleNodes;

    // ResID isn't optional
    DUIAssert(*pszResID, "Sheet resource ID must be provided");
    psn->pszResID = (LPWSTR)_TrackAlloc((wcslen(pszResID) + 1) * sizeof(WCHAR));
    if (!psn->pszResID)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    wcscpy(psn->pszResID, pszResID);

    // Sheets are values, create and hold
    hr = PropertySheet::Create(&pps);
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Cond>::Create(4, false, &_pdaConds);
    if (FAILED(hr))
        goto Failed;

    hr = DynamicArray<Decl>::Create(4, false, &_pdaDecls);
    if (FAILED(hr))
        goto Failed;

    // Add rules
    pRuleNode = pRuleNodes;
    AttribNode* pCondNode;
    PropValPairNode* pDeclNode;
    Cond* pCond;
    Decl* pDecl;
    while (pRuleNode)
    {
        _pdaConds->Reset();
        _pdaDecls->Reset();

        // Build conditional array
        pCondNode = pRuleNode->pCondNodes;
        while (pCondNode)
        {
            hr = _pdaConds->AddPtr(&pCond);
            if (FAILED(hr))
                goto Failed;

            pCond->ppi = pCondNode->ppi;
            pCond->nLogOp = pCondNode->nLogOp;
            pCond->pv = pCondNode->pvn->pv;

            pCondNode = (AttribNode*)pCondNode->pNext;
        }

        // Insert conditionals terminator
        hr = _pdaConds->AddPtr(&pCond);
        if (FAILED(hr))
            goto Failed;

        pCond->ppi = NULL;
        pCond->nLogOp = 0;
        pCond->pv = NULL;

        // Build declarations array
        pDeclNode = pRuleNode->pDeclNodes;
        while (pDeclNode)
        {
            hr = _pdaDecls->AddPtr(&pDecl);
            if (FAILED(hr))
                goto Failed;

            pDecl->ppi = pDeclNode->ppi;
            pDecl->pv = pDeclNode->pvn->pv;

            pDeclNode = pDeclNode->pNext;
        }

        // Insert declarations terminator
        hr = _pdaDecls->AddPtr(&pDecl);
        if (FAILED(hr))
            goto Failed;

        pDecl->ppi = NULL;
        pDecl->pv = NULL;

        // DynamicArrays are contiguous in memory, pass pointer to first to AddRule
        hr = pps->AddRule(pRuleNode->pci, _pdaConds->GetItemPtr(0), _pdaDecls->GetItemPtr(0));
        if (FAILED(hr))
            goto Failed;

        // Next rule
        pRuleNode = pRuleNode->pNext;
    }

    // Create value, marks sheet as immutable
    psn->pvSheet = Value::CreatePropertySheet(pps); // Use ref count
    if (!psn->pvSheet)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    _pdaConds->Destroy();
    _pdaDecls->Destroy();

    return psn;

Failed:

    if (_pdaConds)
        _pdaConds->Destroy();
    if (_pdaDecls)
        _pdaDecls->Destroy();

    g_hrParse = hr;

    return NULL;
}

//  GetPath will resolve a relative path against the path for the file 
//  currently being parsed.  Absolute paths are not altered.
//  For example, if c:\wazzup\foo.ui is being parsed:
//   a) a path of c:\dude\wazzup.bmp is specfied in foo.ui
//       GetPath would return the unaltered path of c:\dude\wazzup.bmp
//   b) a path of \wazzup\b.bmp is specified in foo.ui
//       GetPath would resolve the drive letter, but leave the rest of the
//       path as is, returning c:\wazzup\b.bmp
//   c) a path of ..\images\bar.bmp is specified in foo.ui
//       GetPath would resolve that to c:\wazzup\..\images\bar.bmp
//
//  pIn -- path specified in file being parsed
//  pOut -- pIn resolved against path to file being parsed

void Parser::GetPath(LPCWSTR pIn, LPWSTR pOut)
{
    LPCWSTR pszWalk = pIn;

    // walk through pIn, stopping when either a colon, backslash, or forward slash
    // is encountered (and, obviously, stopping at the end of the string)
    while (*pszWalk && (*pszWalk != ':') && (*pszWalk != '\\') && (*pszWalk != '/'))
        pszWalk++;

    if (*pszWalk == ':')
        // a colon was found -- the path is absolute; return it as is
        wcscpy(pOut, pIn);
    else if (*pszWalk && (pszWalk == pIn))
        // a slash as the first character was encountered -- the path is absolute within the drive, but relative
        // to the drive of the the parsed file; prepend the parsed file drive to the path passed in
        swprintf(pOut, L"%s%s", _szDrive, pIn);
    else
        // the path is relative; prepend the parsed file drive and path to the path passed in
        swprintf(pOut, L"%s%s%s", _szDrive, _szPath, pIn);
}

// Helper: Fixup PropValPairNode
// bRestrictVal limits valid values to VNT_Normal only
bool Parser::_FixupPropValPairNode(PropValPairNode* ppvpn, IClassInfo* pci, bool bRestrictVal)
{
    int dScan;
    PropertyInfo* ppi;

    DUIAssert(ppvpn->nPropValPairType == PVPNT_Fixup, "PVPair must still require a fixup at this point");

    // Check if this property (string) exists on the provided element type
    dScan = 0;
    while ((ppi = pci->EnumPropertyInfo(dScan++)) != NULL)
    {
        // Fixup property pointers and check for valid types
        if (!_wcsicmp(ppi->szName, ppvpn->pszProperty))
        {
            // Fixup
            ppvpn->nPropValPairType = PVPNT_Normal; // Convert node type
            ppvpn->ppi = ppi;  // Original string is temp tracked
            break;
        }
    }

    // Check if fixup happened, if not, error
    if (ppvpn->nPropValPairType != PVPNT_Normal)
    {
        CallbackParseError(L"Invalid property:", ppvpn->pszProperty);
        return false;
    }

    // TODO: Fixup Value enumerations based on PropertyInfo
    if (ppvpn->pvn->nValueType == VNT_EnumFixup)
    {
        int nTotal = 0;
        int nEnum;

        for (int i = 0; i < ppvpn->pvn->el.dNumParams; i++)
        {
            if (!ConvertEnum(ppvpn->pvn->el.pEnums[i], &nEnum, ppvpn->ppi))
            {
                CallbackParseError(L"Invalid enumeration value:", ppvpn->pvn->el.pEnums[i]);
                return false;
            }

            nTotal |= nEnum;
        }

        ppvpn->pvn->pv = Value::CreateInt(nTotal);
        if (!ppvpn->pvn->pv)
        {
            g_hrParse = E_OUTOFMEMORY;
            return NULL;
        }
        ppvpn->pvn->nValueType = VNT_Normal;
    }

    // Make sure value type matches property (special cases for deferred creation values)
    bool bValidVal = false;
    switch (ppvpn->pvn->nValueType)
    {
    case VNT_Normal:
        if (Element::IsValidValue(ppvpn->ppi, ppvpn->pvn->pv))
            bValidVal = true;
        break;

    case VNT_LayoutCreate:
        if (!bRestrictVal && ppvpn->ppi == Element::LayoutProp)
            bValidVal = true;
        break;

    case VNT_SheetRef:  
        if (!bRestrictVal && ppvpn->ppi == Element::SheetProp)
            bValidVal = true;
        break;
    }

    if (!bValidVal)
    {
        CallbackParseError(L"Invalid value type for property in conditional:", ppvpn->ppi->szName);
        return false;
    }

    // All fixups and checks successful
    DUIAssert(ppvpn->ppi, "PVPair fixup's property resolution failed");

    return true;
}


// Enum conversion callback
bool Parser::ConvertEnum(LPCWSTR pszEnum, int* pEnum, PropertyInfo* ppi)
{
    // Map enum string to integer value based using property's enummap
    if (ppi->pEnumMaps)
    {
        EnumMap* pem = ppi->pEnumMaps;
        while (pem->pszEnum)
        {
            if (!_wcsicmp(pem->pszEnum, pszEnum))
            {
                *pEnum = pem->nEnum;

                return true;
            }

            pem++;
        }
    }

    // Enum not located, special case for other values
    switch (ppi->_iGlobalIndex)
    {
    case _PIDX_Foreground:
    case _PIDX_Background:
    case _PIDX_BorderColor:
        {
            // Check if it's a standard color
            UINT nColorCheck = FindStdColor(pszEnum);
            if (nColorCheck != (UINT)-1)
            {
                // Match found
                *pEnum = nColorCheck;
                return true;
            }

            // No match, check if it's a system color
            for (int i = 0; i < sizeof(_sct) / sizeof(SysColorTable); i++)
            {
                if (!_wcsicmp(_sct[i].pszSysColor, pszEnum))
                {
                    // Match found. Since it's a system color, offset index by
                    // system color base so it can be identified as a system color
                    *pEnum = MakeSysColorEnum(_sct[i].nSysColor);
                    return true;
                }
            }
        }
        break;

    case _PIDX_LayoutPos:
        // Check parser table for layout pos values
        for (int i = 0; i < sizeof(_et) / sizeof(EnumTable); i++)
        {
            if (!_wcsicmp(_et[i].pszEnum, pszEnum))
            {
                *pEnum = _et[i].nEnum;
                return true;
            }
        }
        break;
    }

    // Could find no match
    return false;
}

PLAYTCREATE Parser::ConvertLayout(LPCWSTR pszLayout)
{
    for (int i = 0; i < sizeof(_lt) / sizeof(LayoutTable); i++)
    {
        if (!_wcsicmp(_lt[i].pszLaytType, pszLayout))
        {
            return _lt[i].pfnLaytCreate;
        }
    }

    // Could find no match
    return NULL;
}

IClassInfo* Parser::ConvertElement(LPCWSTR pszElement)
{
    IClassInfo** ppci = Element::pciMap->GetItem((void*)pszElement);
    if (!ppci)
        return NULL;

    return *ppci;
}

// System metric integers
int Parser::_QuerySysMetric(int idx)
{
    int iMetric = 0;

    if (idx < 0)
    {
        // DSM_* custom DUI system define mappings
        if (DSM_NCMIN <= idx && idx <= DSM_NCMAX)
        {
            NONCLIENTMETRICSW ncm;
            ncm.cbSize = sizeof(ncm);

            SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE);
        
            switch (idx)
            {
            case DSM_CAPTIONFONTSIZE:
                iMetric = ncm.lfCaptionFont.lfHeight;
                break;

            case DSM_CAPTIONFONTWEIGHT:
                iMetric = ncm.lfCaptionFont.lfWeight;
                break;
            
            case DSM_CAPTIONFONTSTYLE:
                if (ncm.lfCaptionFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfCaptionFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfCaptionFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
                
            case DSM_MENUFONTSIZE:
                iMetric = ncm.lfMenuFont.lfHeight;
                break;
                
            case DSM_MENUFONTWEIGHT:
                iMetric = ncm.lfMenuFont.lfWeight;
                break;
                
            case DSM_MENUFONTSTYLE:
                if (ncm.lfMenuFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfMenuFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfMenuFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_MESSAGEFONTSIZE:
                iMetric = ncm.lfMessageFont.lfHeight;
                break;

            case DSM_MESSAGEFONTWEIGHT:
                iMetric = ncm.lfMessageFont.lfWeight;
                break;

            case DSM_MESSAGEFONTSTYLE:
                if (ncm.lfMessageFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfMessageFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfMessageFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_SMCAPTIONFONTSIZE:
                iMetric = ncm.lfSmCaptionFont.lfHeight;
                break;

            case DSM_SMCAPTIONFONTWEIGHT:
                iMetric = ncm.lfSmCaptionFont.lfWeight;
                break;

            case DSM_SMCAPTIONFONTSTYLE:
                if (ncm.lfSmCaptionFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfSmCaptionFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfSmCaptionFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;

            case DSM_STATUSFONTSIZE:
                iMetric = ncm.lfStatusFont.lfHeight;
                break;
                
            case DSM_STATUSFONTWEIGHT:
                iMetric = ncm.lfStatusFont.lfWeight;
                break;

            case DSM_STATUSFONTSTYLE:
                if (ncm.lfStatusFont.lfItalic)
                    iMetric |= FS_Italic;
                if (ncm.lfStatusFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (ncm.lfStatusFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
            }
        }
        else if (DSM_ICMIN <= idx && idx <= DSM_ICMAX)
        {
            ICONMETRICSW icm;
            icm.cbSize = sizeof(icm);

            SystemParametersInfoW(SPI_GETICONMETRICS, sizeof(icm), &icm, FALSE);

            switch (idx)
            {
            case DSM_ICONFONTSIZE:
                iMetric = icm.lfFont.lfHeight;
                break;

            case DSM_ICONFONTWEIGHT:
                iMetric = icm.lfFont.lfWeight;
                break;
            
            case DSM_ICONFONTSTYLE:
                if (icm.lfFont.lfItalic)
                    iMetric |= FS_Italic;
                if (icm.lfFont.lfUnderline)
                    iMetric |= FS_Underline;
                if (icm.lfFont.lfStrikeOut)
                    iMetric |= FS_StrikeOut;
                break;
            }            
        }
    }
    else
    {
        // SM_* system defines
        iMetric = GetSystemMetrics(idx);
    }

    return iMetric;
}

// System metric strings
// Pointer returned is a system metric pointer, it will be valid after return
LPCWSTR Parser::_QuerySysMetricStr(int idx, LPWSTR psz, UINT c)
{
    LPCWSTR pszMetric = L"";

    // DSM_* custom DUI system define mappings
    if (DSMS_NCMIN <= idx && idx <= DSMS_NCMAX)
    {
        NONCLIENTMETRICSW ncm;
        ncm.cbSize = sizeof(ncm);

        SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE);
    
        switch (idx)
        {
        case DSMS_CAPTIONFONTFACE:
            pszMetric = ncm.lfCaptionFont.lfFaceName;
            break;

        case DSMS_MENUFONTFACE:
            pszMetric = ncm.lfMenuFont.lfFaceName;
            break;
            
        case DSMS_MESSAGEFONTFACE:
            pszMetric = ncm.lfMessageFont.lfFaceName;
            break;

        case DSMS_SMCAPTIONFONTFACE:
            pszMetric = ncm.lfSmCaptionFont.lfFaceName;
            break;

        case DSMS_STATUSFONTFACE:
            pszMetric = ncm.lfStatusFont.lfFaceName;
            break;
        }
    }
    else if (DSMS_ICMIN <= idx && idx <= DSMS_ICMAX)
    {
        ICONMETRICSW icm;
        icm.cbSize = sizeof(icm);

        SystemParametersInfoW(SPI_GETICONMETRICS, sizeof(icm), &icm, FALSE);

        switch (idx)
        {
        case DSMS_ICONFONTFACE:
            pszMetric = icm.lfFont.lfFaceName;
            break;
        }            
    }

    wcsncpy(psz, pszMetric, c);

    // Auto-terminate (in event source was longer than destination)
    *(psz + (c - 1)) = NULL;

    // Return string passed in for convienence
    return psz;
}

// Instantiate an element by resource ID
// If a substitute is provided, don't create a new node. Rather, the use substitute, set
// properties on it and create all content within it. Substitute must support the same
// properties as the type defined in the UI file
// Returns NULL if resid is not found, or if cannot create Element (if not substituting)
HRESULT Parser::CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement)
{
    HRESULT hr = S_OK;

    Element* pe = NULL;

    Element::StartDefer();

    // TODO: Implement DFS search for resource ID, for now, just toplevel
    ElementNode* pen;
    for (UINT i = 0; i < _pdaElementList->GetSize(); i++)
    {
        pen = _pdaElementList->GetItem(i);

        if (pen->pszResID)
        {
            if (!_wcsicmp(pen->pszResID, pszResID))
            {
                hr = _InstantiateElementNode(pen, peSubstitute, NULL, &pe);
                break;
            }
        }
    }

    Element::EndDefer();

    *ppElement = pe;

    return hr;
}

// Find a property sheet by resource ID (returned as Value, ref counted)
Value* Parser::GetSheet(LPCWSTR pszResID)
{
    SheetNode* psn;
    for (UINT i = 0; i < _pdaSheetList->GetSize(); i++)
    {
        psn = _pdaSheetList->GetItem(i);

        DUIAssert(psn->pszResID, "Sheet resource ID required");  // Must have a resid

        if (!_wcsicmp(psn->pszResID, pszResID))
        {
            psn->pvSheet->AddRef();
            return psn->pvSheet;
        }
    }

    return NULL;
}

// Locate resource ID by Value. Pointer returned is guaranteed good as
// long as Parser is valid
LPCWSTR Parser::ResIDFromSheet(Value* pvSheet)
{
    SheetNode* psn;
    for (UINT i = 0; i < _pdaSheetList->GetSize(); i++)
    {
        psn = _pdaSheetList->GetItem(i);

        if (psn->pvSheet == pvSheet)
            return psn->pszResID;
    }

    return NULL;
}

// Returns NULL if can't instantiate Element. If using substitution,
// reutrn value is substituted Element
HRESULT Parser::_InstantiateElementNode(ElementNode* pen, Element* peSubstitute, Element* peParent, OUT Element** ppElement)
{
    *ppElement = NULL;

    HRESULT hr;
    PropValPairNode* ppvpn = NULL;
    ElementNode* pChild = NULL;
    Element* peChild = NULL;

    // Values to free on failure
    Element* pe = NULL;

    if (!peSubstitute)
    {
        hr = pen->pci->CreateInstance(&pe);
        if (FAILED(hr))
            goto Failed;
    }
    else
        // Substitute
        pe = peSubstitute;

    DUIAssert(pe, "Invalid Element: NULL");

    // Set properties
    ppvpn = pen->pPVNodes;
    while (ppvpn)
    {
        // Set property value
        switch (ppvpn->pvn->nValueType)
        {
        case VNT_Normal:
            // Value already created
            pe->SetValue(ppvpn->ppi, PI_Local, ppvpn->pvn->pv);
            break;

        case VNT_LayoutCreate:
            {
            // Value that needs to be created (layout)
            Value* pv;
            hr = ppvpn->pvn->lc.pfnLaytCreate(ppvpn->pvn->lc.dNumParams, ppvpn->pvn->lc.pParams, &pv);
            if (FAILED(hr))
                goto Failed;

            pe->SetValue(ppvpn->ppi, PI_Local, pv);
            pv->Release();  // Must release since must not be held by parse tree
            }
            break;

        case VNT_SheetRef:
            {
            // Value already created, but is referenced by id (resid) since it was defined
            // in another part of the document and can be shared, search for it
            Value* pv = GetSheet(ppvpn->pvn->psres);
            if (!pv)
            {
                hr = E_OUTOFMEMORY;
                goto Failed;
            }

            pe->SetValue(ppvpn->ppi, PI_Local, pv);
            pv->Release();  // Must release since must not be held by parse tree
            }
            break;
        }

        ppvpn = ppvpn->pNext;
    }

    // Create children and parent to this element
    pChild = pen->pChild;

    if (peParent)
        peParent->Add(pe);

    while (pChild)
    {
        hr = _InstantiateElementNode(pChild, NULL, pe, &peChild);
        if (FAILED(hr))
            goto Failed;

        pChild = pChild->pNext;
    }

    // Set content
    if (pen->pvContent)
        pe->SetValue(Element::ContentProp, PI_Local, pen->pvContent);

    *ppElement = pe;

    // ContainerCleanup: call ppElement->OnLoadedFromResource() right here -- handing a resource dictionary 

    return S_OK;

Failed:

    // Destroying Element will release and free all values and children
    if (pe)
        pe->Destroy();

    return hr;
}

// Given a tree, will replace all occurances of a particular style sheet with
// another. ReplaceSheets will walk to every Element, check to see if it
// has a local sheet set on it. If it does, it will try to match the
// sheet value pointer to one of the sheets being held by Parser pFrom. When
// a match is found, it'll use the resid to locate the corresponding sheet
// in Parser pTo. If found, it'll reset the Sheet on the Element with this
// new value.
HRESULT Parser::ReplaceSheets(Element* pe, Parser* pFrom, Parser* pTo)
{
    Element::StartDefer();

    HRESULT hrPartial = S_FALSE;  // Will resume on failure, assume success false
    HRESULT hr;

    // Check if Element has a local sheet set on it (will be pvUnset if none)
    Value* pvSheet = pe->GetValue(Element::SheetProp, PI_Local);
    LPCWSTR pszResID;
    
    if (pvSheet->GetType() == DUIV_SHEET)
    {
        // Found local sheet, try locate in "from" Parser list
        pszResID = pFrom->ResIDFromSheet(pvSheet);

        if (pszResID)
        {
            // Found sheet in "from" parser and have unique resid.
            // Try to match to "to" parser.

            Value* pvNewSheet = pTo->GetSheet(pszResID);
            if (pvNewSheet)
            {
                // Found equivalent sheet in "to" parser, set
                hr = pe->SetValue(Element::SheetProp, PI_Local, pvNewSheet);
                if (FAILED(hr))
                    hrPartial = hr;
            
                pvNewSheet->Release();

                if (SUCCEEDED(hrPartial))
                    hrPartial = S_OK;
            }
        }
    }

    pvSheet->Release();
    
    // Do same for all children
    Value* pvChildren;
    ElementList* peList = pe->GetChildren(&pvChildren);
    Element* pec;
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            pec = peList->GetItem(i);

            hr = ReplaceSheets(pec, pFrom, pTo);
            if ((FAILED(hr) || (hr == S_FALSE)) && SUCCEEDED(hrPartial))
                hrPartial = hr;
        }
    }

    pvChildren->Release();

    Element::EndDefer();

    return hrPartial;
}


} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\parse.cpp.h ===
typedef union
{
    // Temporary data returned from tokens (lexer) and productions (parser)
    int num;                    // Stored by lexer (YYINT) and inter-production data transfer
    WCHAR ident[MAXIDENT];      // Stored by lexer (YYIDENT)
    LPWSTR str;                 // Tracked pointer with quotes stripped (YYSTRING)

    EnumsList el;               // Inter-production data transfer
    ParamsList pl;              // Inter-production data transfer
    StartTag st;                // Inter-production data transfer
    COLORREF cr;                // Inter-production data transfer
    HANDLE h;                   // Inter-production data transfer

    ValueNode* pvn;             // NT_ValueNode
    PropValPairNode* ppvpn;     // NT_PropValPairNode
    ElementNode* pen;           // NT_ElementNode
    AttribNode* pan;            // NT_AttribNode
    RuleNode* prn;              // NT_RuleNode
    SheetNode* psn;             // NT_SheetNode
} YYSTYPE;
#define	YYIDENT	258
#define	YYINT	259
#define	YYSTRING	260
#define	YYSHEET	261
#define	YYSHEETREF	262
#define	YYRECT	263
#define	YYPOINT	264
#define	YYRGB	265
#define	YYARGB	266
#define	YYGRADIENT	267
#define	YYGRAPHIC	268
#define	YYDFC	269
#define	YYDTB	270
#define	YYTRUE	271
#define	YYFALSE	272
#define	YYRESID	273
#define	YYATOM	274
#define	YYRCSTR	275
#define	YYRCBMP	276
#define	YYRCINT	277
#define	YYRCCHAR	278
#define	YYPT	279
#define	YYRP	280
#define	YYSYSMETRIC	281
#define	YYSYSMETRICSTR	282
#define	YYHANDLEMAP	283


extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\query.cpp ===
/*
 * Query
 */

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"

namespace DirectUI
{

#ifdef DBG

char* g_arMarkupLines[] = {
    "<style resid=mainss>",
        "element { background: argb(0,0,0,0); }",
    "</style>",
    "<style resid=headerss>",
        "element [id=atom(header)] { foreground: white; background: cornflowerblue; fontsize: 16pt; fontstyle: italic; borderthickness: rect(0,0,0,1); padding: rect(3,3,3,3); contentalign: topleft | endellipsis; }",
        "element [id=atom(subheader)] { foreground: white; background: firebrick; fontsize: 10pt; fontweight: bold; borderthickness: rect(0,0,0,1); padding: rect(3,3,3,3); contentalign: topleft | endellipsis; }",
    "</style>",
    "<style resid=tabless>",
        "element { background:gainsboro; fontsize: 10pt; }"
        "element [id=atom(propertytitle)] { background: gainsboro; contentalign: topright | endellipsis; borderthickness: rect(2,2,2,2); bordercolor: gainsboro; padding: rect(2,2,2,2); fontstyle: italic; borderstyle: raised; }",
        "element [id=atom(valuetitle)] { background: gainsboro; borderthickness: rect(2,2,2,2); bordercolor: gainsboro; padding: rect(2,2,2,2); fontweight: bold; borderstyle: raised; contentalign: topleft | endellipsis; }",
        "element [id=atom(property)] {background: oldlace; contentalign: topright | endellipsis; fontstyle: italic; borderthickness: rect(0,0,1,1); padding: rect(2,2,2,2); }",
        "element [id=atom(value)] { background: white; contentalign: wrapleft; fontweight: bold; borderthickness: rect(0,0,0,1); padding: rect(2,2,2,2); }",
    "</style>",
    "<style resid=scrollerss>",
        "scrollbar { layoutpos: ninebottom; }",
        "scrollbar [vertical] { layoutpos: nineright; }",
        "viewer { layoutpos: nineclient; }",
        "thumb { background: dfc(4, 0x0010); }",
        "repeatbutton [id=atom(lineup)] { background: dfc(3, 0x0000); width: sysmetric(2); height: sysmetric(20); }",
        "repeatbutton [id=atom(lineup)][pressed] { background: dfc(3, 0x0000 | 0x0200); }",
        "repeatbutton [id=atom(linedown)] { background: dfc(3, 0x0001); width: sysmetric(2); height: sysmetric(20); }",
        "repeatbutton [id=atom(linedown)][pressed] { background: dfc(3, 0x0001 | 0x0200); }",
        "repeatbutton [class=\"Page\"] { background: scrollbar; }",
        "repeatbutton [class=\"Page\"][pressed] { background: buttonshadow; }",
    "</style>",
    "<element resid=main sheet=styleref(mainss) layout=borderlayout()>",
        "<element id=atom(header) sheet=styleref(headerss) layoutpos=top/>",
        "<element id=atom(subheader) sheet=styleref(headerss) layoutpos=top/>",
        "<scrollviewer sheet=styleref(scrollerss) layoutpos=client xscrollable=false>",
            "<element id=atom(table) sheet=styleref(tabless) layoutpos=top layout=verticalflowlayout(0,3,3,0)>",
                "<element layout=gridlayout(1,2)>",
                    "<element id=atom(propertytitle)>\"Property\"</element>",
                    "<element id=atom(valuetitle)>\"Value\"</element>",
                "</element>",
            "</element>",
        "</scrollviewer>",
    "</element>",
    "<element resid=item layout=gridlayout(1,2)>",
        "<element id=atom(property)/>",
        "<element id=atom(value)/>",
    "</element>",
};

#endif // DBG

void QueryDetails(Element* pe, HWND hParent)
{
    UNREFERENCED_PARAMETER(pe);
    UNREFERENCED_PARAMETER(hParent);

#ifdef DBG

    HRESULT hr;
    int cBufSize = 0;
    LPSTR pBuf = NULL;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    HWNDElement* phe = NULL;
    bool fEndDeferOnFail = false;
    Element* peTable = NULL;
    Element* peHold = NULL;
    Element* peHold1 = NULL;
    WCHAR szTemp[256];
    IClassInfo* pci = NULL;
    PropertyInfo* ppi = NULL;
    int nEnum = 0;
    Value* pv = NULL;

    // Create buffer for parser based on markup
    for (int i = 0; i < DUIARRAYSIZE(g_arMarkupLines); i++)
        cBufSize += (int)strlen(g_arMarkupLines[i]);

    // Buffer is single byte
    pBuf = (LPSTR)HAlloc(cBufSize + 1);
    if (!pBuf)
        goto Failure;
    *pBuf = 0;

    for (i = 0; i < DUIARRAYSIZE(g_arMarkupLines); i++)
        strcat(pBuf, g_arMarkupLines[i]);
    
    // Parse buffer, not loading resources
    hr = Parser::Create(pBuf, cBufSize, GetModuleHandle(NULL), NULL, &pParser);
    if (FAILED(hr))
        goto Failure;

    // Done with buffer
    HFree(pBuf);
    pBuf = NULL;

    // Create host (will auto-destroy when HWND is destroyed)
    NativeHWNDHost::Create(L"Element Details...", hParent, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 
        360, 540, 0, WS_OVERLAPPEDWINDOW, NHHO_NoSendQuitMessage | NHHO_DeleteOnHWNDDestroy, &pnhh);
    if (!pnhh)
        goto Failure;

    Element::StartDefer();
    fEndDeferOnFail = true;

    // Create root
    HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);
    if (!phe)
        goto Failure;

    // Create tree using parser (via substituation)
    hr = pParser->CreateElement(L"main", phe, &peHold);
    if (FAILED(hr))
        goto Failure;

    // Get element class
    pci = pe->GetClassInfo();

    // Populate header
    peHold = phe->FindDescendent(StrToID(L"header"));
    if (!peHold)
        goto Failure;

    if (pe->GetID())
    {
        WCHAR szID[128];
        GetAtomNameW(pe->GetID(), szID, DUIARRAYSIZE(szID));
        _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"%s [%s]", pci->GetName(), szID);
    }
    else
        _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"%s", pci->GetName());
    *(szTemp + (DUIARRAYSIZE(szTemp) - 1)) = NULL;
    
    peHold->SetContentString(szTemp);

    // Populate sub-header
    peHold = phe->FindDescendent(StrToID(L"subheader"));
    if (!peHold)
        goto Failure;

    _snwprintf(szTemp, DUIARRAYSIZE(szTemp), L"Address: 0x%p", pe);

    peHold->SetContentString(szTemp);

    // Get table for populating
    peTable = phe->FindDescendent(StrToID(L"table"));
    if (!peTable)
        goto Failure;
            
    // Enumerate properties
    while ((ppi = pci->EnumPropertyInfo(nEnum++)) != NULL)
    {
        hr = pParser->CreateElement(L"item", NULL, &peHold);
        if (FAILED(hr))
            goto Failure;

        // Set property string
        peHold1 = peHold->FindDescendent(StrToID(L"property"));
        if (!peHold1)
            goto Failure;

        peHold1->SetContentString(ppi->szName);

        // Set value string
        peHold1 = peHold->FindDescendent(StrToID(L"value"));
        if (!peHold1)
            goto Failure;

        pv = pe->GetValue(ppi, RetIdx(ppi));
        pv->ToString(szTemp, DUIARRAYSIZE(szTemp));
        pv->Release();
        
        peHold1->SetContentString(szTemp);

        // Add to table
        peTable->Add(peHold);        
    }

    pnhh->Host(phe);

    // Set visible
    phe->SetVisible(true);

    Element::EndDefer();

    // Done with parser
    pParser->Destroy();
    pParser = NULL;

    pnhh->ShowWindow(SW_NORMAL);

    return;
   
Failure:

    if (fEndDeferOnFail)
        Element::EndDefer();

    if (pParser)
        pParser->Destroy();

    if (pBuf)
        HFree(pBuf);

    if (pnhh)
        pnhh->DestroyWindow();  // This will destroy pnhh and remaining subtree

#endif // DBG

    return;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\parser.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_PARSER_PARSER_H_INCLUDED
#define DUI_PARSER_PARSER_H_INCLUDED

#pragma once

#include <DUIBaseP.h>
#include <DUIUtilP.h>
#include <DUICoreP.h>
#include <DUILayoutP.h>
#include <DUIControlP.h>

#endif // DUI_PARSER_PARSER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_PARSER_STDAFX_H_INCLUDED
#define DUI_PARSER_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_PARSER_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\scan.cpp ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

////////////////////////////
// DirectUI

#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"
namespace DirectUI 
{ 
#include "parse.cpp.h"
}

#pragma warning (push,3)
#pragma warning (disable:4244)
#pragma warning (disable:4102)

#define YY_NEVER_INTERACTIVE 1

////////////////////////////

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

//
// DirectUI: Modified to prop fatal (abnormal) execution information:
//
// yylex (-1) 
// yy_get_next_buffer (EOB_ACT_FATAL_ERROR) <yylex (-1), yyinput (EOF)>
// yyinput (EOF) <yyinput (EOF)>
// yyunput (FALSE) <no callers>
// yy_create_buffer (NULL) <yyrestart (FALSE), yylex (-1), yy_set_interactive (no callers), yy_set_bol (no callers)>
// yy_scan_buffer (NULL) <yy_scan_bytes (NULL)>
// yy_scan_bytes (NULL) <yy_scan_string (NULL)>
// yy_push_state (FALSE) <no callers>
// yy_pop_state (FALSE) <no callers>
//

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
//#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

////////////////////////////
// DirectUI
namespace DirectUI
{
////////////////////////////

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_FATAL_ERROR -1  // DirectUI
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *      yyless( 5 );
 *  else
 *      do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        *yy_cp = yy_hold_char; \
        YY_RESTORE_YY_MORE_OFFSET \
        yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        } \
    while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */

////////////////////////////
// DirectUI

typedef SIZE_T yy_size_t;
//typedef unsigned int yy_size_t;

////////////////////////////

struct yy_buffer_state
    {
    FILE *yy_input_file;

    char *yy_ch_buf;        /* input buffer */
    char *yy_buf_pos;       /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
    };

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;      /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;     /* whether we need to initialize */
static int yy_start = 0;    /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

BOOL yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

// DirectUI: Not used. Error info not propped
#define yy_set_interactive(is_interactive) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_is_interactive = is_interactive; \
    }

// DirectUI: Not used. Error info not propped
#define yy_set_bol(at_bol) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_at_bol = at_bol; \
    }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)


#define YY_USES_REJECT
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern int yylineno;
int yylineno = 1;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
    yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
    yy_hold_char = *yy_cp; \
    *yy_cp = '\0'; \
    yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 37
#define YY_END_OF_BUFFER 38
static yyconst short int yy_acclist[175] =
    {   0,
       38,   32,   37,   31,   32,   37,   31,   37,   32,   37,
       32,   37,   32,   37,   32,   37,   27,   32,   37,   27,
       32,   37,   26,   32,   37,   26,   32,   37,   26,   32,
       37,   26,   32,   37,   26,   32,   37,   26,   32,   37,
       26,   32,   37,   26,   32,   37,   26,   32,   37,   26,
       32,   37,   34,   37,   34,   37,   36,   37,   35,   37,
       31,   30,   28,   27,    1,    2,   26,   26,   26,   26,
       26,   26,   26,   26,   26,   21,   26,   26,   26,   26,
       22,   26,   26,   26,   26,   33,   29,   26,   26,   11,
       26,   12,   26,   26,   26,   26,   26,   26,   26,   26,

       26,   26,   26,    7,   26,   26,   26,   26,    8,   26,
       16,   26,   26,   26,   26,   26,   26,   26,   26,   26,
       26,    6,   26,   26,   26,   26,   13,   26,   14,   26,
       26,   26,   26,    5,   26,   18,   26,   26,   19,   26,
       17,   26,   15,   26,    3,   26,   26,   26,   26,   26,
       20,   26,   26,   26,   26,   10,   26,   26,   26,   26,
        9,   26,   26,    4,   26,   26,   25,   26,   23,   26,
       26,   26,   24,   26
    } ;

static yyconst short int yy_accept[126] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    2,    4,    7,
        9,   11,   13,   15,   17,   20,   23,   26,   29,   32,
       35,   38,   41,   44,   47,   50,   53,   55,   57,   59,
       61,   62,   62,   63,   64,   65,   66,   67,   67,   68,
       69,   70,   71,   72,   73,   74,   75,   76,   78,   79,
       80,   81,   83,   84,   85,   86,   87,   88,   89,   90,
       92,   94,   95,   96,   97,   98,   99,  100,  101,  102,
      103,  104,  106,  107,  108,  109,  111,  113,  114,  115,
      116,  117,  118,  119,  120,  121,  122,  124,  125,  126,
      127,  129,  131,  132,  133,  134,  136,  138,  139,  141,

      143,  145,  147,  148,  149,  150,  151,  153,  154,  155,
      156,  158,  159,  160,  161,  163,  164,  166,  167,  169,
      171,  172,  173,  175,  175
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
        1,    6,    1,    1,    7,    1,    8,    9,   10,   10,
       10,   10,   10,   10,   10,   10,   10,    1,    1,    1,
        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
       17,   18,   19,   20,   20,   21,   22,   23,   24,   25,
       20,   26,   27,   28,   29,   20,   20,   30,   31,   20,
        1,    1,    1,    1,    1,    1,   11,   12,   13,   14,

       15,   16,   17,   18,   19,   20,   20,   21,   22,   23,
       24,   25,   20,   26,   27,   28,   29,   20,   20,   30,
       31,   20,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[32] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3
    } ;

static yyconst short int yy_base[131] =
    {   0,
        0,    0,  145,  144,  146,  145,  147,  152,   30,   32,
      142,    0,   27,   32,   32,   34,   19,    0,   23,  134,
      118,  132,   22,   39,   27,  116,  152,  133,  152,  152,
       46,  136,  152,    0,   50,  152,  152,    0,    0,  122,
      114,  124,  124,  114,  123,  110,  113,    0,   53,   40,
      119,    0,   99,  102,   99,  152,    0,  115,  104,    0,
        0,   98,   43,  110,  100,  100,  103,   97,   91,   90,
       98,    0,   95,   93,   99,    0,    0,   98,   93,   93,
       89,   81,   83,   96,   78,   79,    0,   90,   88,   87,
        0,    0,   86,   81,   84,    0,    0,   72,    0,    0,

        0,   71,   68,   72,   81,   71,    0,   77,   53,   50,
        0,   66,   60,   56,    0,   49,    0,   60,    0,   44,
       42,   43,    0,  152,   80,   83,   86,   61,   88,   59
    } ;

static yyconst short int yy_def[131] =
    {   0,
      124,    1,  125,  125,  126,  126,  124,  124,  124,  124,
      127,  128,  124,  124,  124,  124,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  124,  124,  124,  124,
      124,  127,  124,  128,  124,  124,  124,  130,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  124,  130,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,

      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,    0,  124,  124,  124,  124,  124,  124
    } ;

static yyconst short int yy_nxt[184] =
    {   0,
        8,    9,   10,   11,   12,    8,   13,   14,   15,   16,
       17,   18,   18,   19,   18,   20,   21,   22,   18,   18,
       18,   18,   18,   18,   23,   24,   25,   26,   18,   18,
       18,   31,   31,   31,   31,   35,   35,   36,   42,   37,
       35,   35,   35,   35,   40,   47,   41,   31,   31,   48,
       43,   49,   70,   50,   53,   51,   79,   54,   35,   35,
       57,   38,   34,   52,   66,   67,   71,   80,  123,  122,
      121,   68,  120,  119,  118,  117,  116,  115,  114,   69,
       27,   27,   27,   29,   29,   29,   32,   32,   32,   39,
       39,  113,  112,  111,  110,  109,  108,  107,  106,  105,

      104,  103,  102,  101,  100,   99,   98,   97,   96,   95,
       94,   93,   92,   91,   90,   89,   88,   87,   86,   85,
       84,   83,   82,   81,   78,   77,   76,   75,   74,   73,
       72,   65,   64,   63,   62,   61,   60,   59,   58,   33,
       56,   55,   46,   45,   44,   33,  124,   30,   30,   28,
       28,    7,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124
    } ;

static yyconst short int yy_chk[184] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    9,    9,   10,   10,   13,   13,   14,   19,   14,
       15,   15,   16,   16,   17,   23,   17,   31,   31,   23,
       19,   24,   50,   24,   25,   24,   63,   25,   35,   35,
      130,   15,  128,   24,   49,   49,   50,   63,  122,  121,
      120,   49,  118,  116,  114,  113,  112,  110,  109,   49,
      125,  125,  125,  126,  126,  126,  127,  127,  127,  129,
      129,  108,  106,  105,  104,  103,  102,   98,   95,   94,

       93,   90,   89,   88,   86,   85,   84,   83,   82,   81,
       80,   79,   78,   75,   74,   73,   71,   70,   69,   68,
       67,   66,   65,   64,   62,   59,   58,   55,   54,   53,
       51,   47,   46,   45,   44,   43,   42,   41,   40,   32,
       28,   26,   22,   21,   20,   11,    7,    6,    5,    4,
        3,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
      124,  124,  124
    } ;

static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static char *yy_full_match;
static int yy_lp;
#define REJECT \
{ \
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yy_full_match; /* restore poss. backed-over text */ \
++yy_lp; \
goto find_rule; \
}
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#define INITIAL 0
/* FLEX */
/*
 * Scanner is single-byte
 * All strings and identifiers will be converted for storage to Unicode at this stage
 */

void yyerror(LPCSTR s);

#define YY_INPUT(buf, result, n) result = Parser::g_pParserCtx->_Input(buf, n)
#define YY_FATAL_ERROR(msg)      { yytext = "<ScannerFailure>"; yylineno = 0; yyerror(msg); }

// Defined in Flex.skl so that is at top of file
/*
#include "stdafx.h"
#include "parser.h"

#include "duiparserobj.h"
namespace DirectUI
{ 
#include "parse.cpp.h"
}

#pragma warning (push,3)
#pragma warning (disable:4244)
#pragma warning (disable:4102)

#define YY_NEVER_INTERACTIVE 1
*/

// Helper functions
LPWSTR UniDupString(LPSTR ps);

#define CUSTOMALLOC     HAlloc
#define CUSTOMREALLOC   HReAlloc
#define CUSTOMFREE      HFree

#define ppc             Parser::g_pParserCtx

#define COMMENT 1

#define INLINECOMMENT 2


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static BOOL yyunput YY_PROTO(( int c, char *buf_ptr ));  // DirectUI: Can fail, FALSE on failure
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static BOOL yy_push_state YY_PROTO(( int new_state ));  // DirectUI: Can fail, FALSE on failure
#endif
#ifndef YY_NO_POP_STATE
static BOOL yy_pop_state YY_PROTO(( void ));  // DirectUI: Can fail, FALSE on failure
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

//// YY_INPUT redefined by DirectUI

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( BOOL* pfRes ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

// DirectUI: yylex (YY_DECL), out param used as success code (yyterminate() called on failure)

YY_DECL
    {
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;

    *pfRes = TRUE;  // DirectUI: Init success out param




    if ( yy_init )
        {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if ( ! yy_start )
            yy_start = 1;   /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( ! yy_current_buffer )
            {
            yy_current_buffer =
                yy_create_buffer( yyin, YY_BUF_SIZE );
            if ( ! yy_current_buffer )  // DirectUI
                {
                *pfRes = FALSE;
                yyterminate();  // Failure
                }
            }

        yy_load_buffer_state();
        }

    while ( 1 )     /* loops until end-of-file is reached */
        {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

		yy_current_state = yy_start;
		yy_state_ptr = yy_state_buf;
		*yy_state_ptr++ = yy_current_state;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 125 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			*yy_state_ptr++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_current_state != 124 );

yy_find_action:
		yy_current_state = *--yy_state_ptr;
		yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[yy_lp];
					{
					yy_full_match = yy_cp;
					break;
					}
				}
			--yy_cp;
			yy_current_state = *--yy_state_ptr;
			yy_lp = yy_accept[yy_current_state];
			}

        YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					++yylineno;
			}

do_action:  /* This label is used only to access EOF actions. */


        switch ( yy_act )
    { /* beginning of action switch */
case 1:
YY_RULE_SETUP
{ BEGIN COMMENT; }
	YY_BREAK
case 2:
YY_RULE_SETUP
{ BEGIN INLINECOMMENT; }
	YY_BREAK
case 3:
YY_RULE_SETUP
{ return YYSHEET; }
	YY_BREAK
case 4:
YY_RULE_SETUP
{ return YYSHEETREF; }
	YY_BREAK
case 5:
YY_RULE_SETUP
{ return YYPOINT; }
	YY_BREAK
case 6:
YY_RULE_SETUP
{ return YYRECT; }
	YY_BREAK
case 7:
YY_RULE_SETUP
{ return YYRGB; }
	YY_BREAK
case 8:
YY_RULE_SETUP
{ return YYARGB; }
	YY_BREAK
case 9:
YY_RULE_SETUP
{ return YYGRADIENT; }
	YY_BREAK
case 10:
YY_RULE_SETUP
{ return YYGRAPHIC; }
	YY_BREAK
case 11:
YY_RULE_SETUP
{ return YYDFC; }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ return YYDTB; }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ return YYTRUE; }
	YY_BREAK
case 14:
YY_RULE_SETUP
{ return YYFALSE; }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ return YYRESID; }
	YY_BREAK
case 16:
YY_RULE_SETUP
{ return YYATOM; }
	YY_BREAK
case 17:
YY_RULE_SETUP
{ return YYRCSTR; }
	YY_BREAK
case 18:
YY_RULE_SETUP
{ return YYRCBMP; }
	YY_BREAK
case 19:
YY_RULE_SETUP
{ return YYRCINT; }
	YY_BREAK
case 20:
YY_RULE_SETUP
{ return YYRCCHAR; }
	YY_BREAK
case 21:
YY_RULE_SETUP
{ return YYPT; }
	YY_BREAK
case 22:
YY_RULE_SETUP
{ return YYRP; }
	YY_BREAK
case 23:
YY_RULE_SETUP
{
                                   return YYSYSMETRIC;
                                 }
	YY_BREAK
case 24:
YY_RULE_SETUP
{
                                   return YYSYSMETRICSTR;
                                 }
	YY_BREAK
case 25:
YY_RULE_SETUP
{
                                   return YYHANDLEMAP;
                                 }
	YY_BREAK
case 26:
YY_RULE_SETUP
{
                                    MultiByteToWideChar(DUI_CODEPAGE, 0, yytext, -1, yylval.ident, MAXIDENT);
                                    return YYIDENT;
                                 }
	YY_BREAK
case 27:
YY_RULE_SETUP
{
                                    yylval.num = atoi(yytext);
                                    return YYINT; 
                                 }
	YY_BREAK
case 28:
YY_RULE_SETUP
{
                                    yylval.num = strtol(yytext + 1, NULL, 16);
                                    return YYINT; 
                                 }
	YY_BREAK
case 29:
YY_RULE_SETUP
{
                                    yylval.num = strtol(yytext + 2, NULL, 16);
                                    return YYINT; 
                                 }
	YY_BREAK
case 30:
YY_RULE_SETUP
{
                                    yylval.str = UniDupString(yytext);
                                    return YYSTRING;
                                 }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 32:
YY_RULE_SETUP
{ return *yytext; }
	YY_BREAK
case 33:
YY_RULE_SETUP
{ BEGIN 0; }
	YY_BREAK
case 34:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 35:
YY_RULE_SETUP
{ BEGIN 0; }
	YY_BREAK
case 36:
YY_RULE_SETUP
{ ; }
	YY_BREAK
case 37:
YY_RULE_SETUP
ECHO;
	YY_BREAK
			case YY_STATE_EOF(INITIAL):
			case YY_STATE_EOF(COMMENT):
			case YY_STATE_EOF(INLINECOMMENT):
				yyterminate();

    case YY_END_OF_BUFFER:
        {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_hold_char;
        YY_RESTORE_YY_MORE_OFFSET

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
            {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between yy_current_buffer and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yy_n_chars = yy_current_buffer->yy_n_chars;
            yy_current_buffer->yy_input_file = yyin;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
            }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans( yy_current_state );

            yy_bp = yytext_ptr + YY_MORE_ADJ;

            if ( yy_next_state )
                {
                /* Consume the NUL. */
                yy_cp = ++yy_c_buf_p;
                yy_current_state = yy_next_state;
                goto yy_match;
                }

            else
                {
				yy_cp = yy_c_buf_p;
                goto yy_find_action;
                }
            }

        else switch ( yy_get_next_buffer() )
            {
            case EOB_ACT_END_OF_FILE:
                {
                yy_did_buffer_switch_on_eof = 0;

                if ( yywrap() )
                    {
                    /* Note: because we've taken care in
                     * yy_get_next_buffer() to have set up
                     * yytext, we can now set up
                     * yy_c_buf_p so that if some total
                     * hoser (like flex itself) wants to
                     * call the scanner after we return the
                     * YY_NULL, it'll still work - another
                     * YY_NULL will get returned.
                     */
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                    yy_act = YY_STATE_EOF(YY_START);
                    goto do_action;
                    }

                else
                    {
                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
                    }
                break;
                }

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p =
                    yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_match;

            case EOB_ACT_LAST_MATCH:
                yy_c_buf_p =
                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;

            case EOB_ACT_FATAL_ERROR:
                *pfRes = FALSE;  // DirectUI                
                yyterminate();
            }
        break;
        }

    default:
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--no action found" );
        *pfRes = FALSE;  // DirectUI
        yyterminate();
    } /* end of action switch */

        } /* end of scanning one token */
    } /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_FATAL_ERROR  // DirectUI (-1)
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
    {
    register char *dest = yy_current_buffer->yy_ch_buf;
    register char *source = yytext_ptr;
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        {
        YY_FATAL_ERROR(
        "fatal flex scanner internal error--end of buffer missed" );
        return EOB_ACT_FATAL_ERROR;  // DirectUI
        }

    if ( yy_current_buffer->yy_fill_buffer == 0 )
        { /* Don't try to fill the buffer, so this is an EOF. */
        if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
            {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
            }

        else
            {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
            }
        }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_current_buffer->yy_n_chars = yy_n_chars = 0;

    else
        {
        int num_to_read =
            yy_current_buffer->yy_buf_size - number_to_move - 1;

        while ( num_to_read <= 0 )
            { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
            return EOB_ACT_FATAL_ERROR;
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset =
                (int) (yy_c_buf_p - b->yy_ch_buf);

            if ( b->yy_is_our_buffer )
                {
                int new_size = b->yy_buf_size * 2;

                if ( new_size <= 0 )
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc( (void *) b->yy_ch_buf,
                             b->yy_buf_size + 2 );
                }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if ( ! b->yy_ch_buf )
                {
                YY_FATAL_ERROR(
                "fatal error - scanner input buffer overflow" );
                return EOB_ACT_FATAL_ERROR;
                }

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size -
                        number_to_move - 1;
#endif
            }

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
            yy_n_chars, num_to_read );

        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    if ( yy_n_chars == 0 )
        {
        if ( number_to_move == YY_MORE_ADJ )
            {
            ret_val = EOB_ACT_END_OF_FILE;
            if ( ! yyrestart( yyin ) )  // DirectUI: Can fail
                return EOB_ACT_FATAL_ERROR;
            }

        else
            {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status =
                YY_BUFFER_EOF_PENDING;
            }
        }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
    }


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
    {
    register yy_state_type yy_current_state;
    register char *yy_cp;

	yy_current_state = yy_start;
	yy_state_ptr = yy_state_buf;
	*yy_state_ptr++ = yy_current_state;

    for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        {
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 125 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		*yy_state_ptr++ = yy_current_state;
        }

    return yy_current_state;
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
    {
    register int yy_is_jam;

	register YY_CHAR yy_c = 1;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 125 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 124);
	if ( ! yy_is_jam )
		*yy_state_ptr++ = yy_current_state;

    return yy_is_jam ? 0 : yy_current_state;
    }


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static BOOL yyunput( int c, register char *yy_bp )
#else
static BOOL yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
    {
    // DirectUI: Returns BOOL, FALSE on failure
    
    register char *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        register int number_to_move = yy_n_chars + 2;
        register char *dest = &yy_current_buffer->yy_ch_buf[
                    yy_current_buffer->yy_buf_size + 2];
        register char *source =
                &yy_current_buffer->yy_ch_buf[number_to_move];

        while ( source > yy_current_buffer->yy_ch_buf )
            *--dest = *--source;

        yy_cp += (int) (dest - source);
        yy_bp += (int) (dest - source);
        yy_current_buffer->yy_n_chars =
            yy_n_chars = yy_current_buffer->yy_buf_size;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
            {
            YY_FATAL_ERROR( "flex scanner push-back overflow" );
            return FALSE;
            }
        }

    *--yy_cp = (char) c;

	if ( c == '\n' )
		--yylineno;

    yytext_ptr = yy_bp;
    yy_hold_char = *yy_cp;
    yy_c_buf_p = yy_cp;

    return TRUE;
    }
#endif  /* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
    {
    // DirectUI: Return EOF (-1) on error
    
    int c;

    *yy_c_buf_p = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* This was really a NUL. */
            *yy_c_buf_p = '\0';

        else
            { /* need more input */
            int offset = yy_c_buf_p - yytext_ptr;
            ++yy_c_buf_p;

            switch ( yy_get_next_buffer() )
                {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    if ( ! yyrestart( yyin ) )  // DirectUI: Return on failure
                        return EOF;

                    /* fall through */

                case EOB_ACT_END_OF_FILE:
                    {
                    if ( yywrap() )
                        return EOF;

                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();  // DirectUI: Return EOF on failure
#else
                    return input();
#endif
                    }

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext_ptr + offset;
                    break;

                case EOB_ACT_FATAL_ERROR:
                    return EOF;
                }
            }
        }

    c = *(unsigned char *) yy_c_buf_p;  /* cast for 8-bit char's */
    *yy_c_buf_p = '\0'; /* preserve yytext */
    yy_hold_char = *++yy_c_buf_p;

	if ( c == '\n' )
		++yylineno;

    return c;
    }


#ifdef YY_USE_PROTOS
BOOL yyrestart( FILE *input_file )
#else
BOOL yyrestart( input_file )
FILE *input_file;
#endif
    {
    // DirectUI: Return BOOL, FALSE on failure
    
    if ( ! yy_current_buffer )
        {
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
        if (! yy_current_buffer )  // DirectUI
            return FALSE;  // Failure
        }

    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();

    return TRUE;
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
        {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
    {
    // DirectUI: NULL on allocation error
    
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
    if ( ! b->yy_ch_buf )
        {
        yy_flex_free(b);  // DirectUI: Free initial alloc
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_is_our_buffer = 1;

    yy_init_buffer( b, file );

    return b;
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
    {
    if ( ! b )
        return;

    if ( b == yy_current_buffer )
        yy_current_buffer = (YY_BUFFER_STATE) 0;

    if ( b->yy_is_our_buffer )
        yy_flex_free( (void *) b->yy_ch_buf );

    yy_flex_free( (void *) b );
    }


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


    {
    yy_flush_buffer( b );

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = 0;
#else
    b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
    }


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    if ( ! b )
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if ( b == yy_current_buffer )
        yy_load_buffer_state();
    }


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
    {
    // DirectUI: Return NULL on error
    
    YY_BUFFER_STATE b;

    if ( size < 2 ||
         base[size-2] != YY_END_OF_BUFFER_CHAR ||
         base[size-1] != YY_END_OF_BUFFER_CHAR )
        /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
        return NULL;  // DirectUI
        }

    b->yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer( b );

    return b;
    }
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
    {
    // DirectUI: Can return NULL (props yy_scan_bytes value)
    
    int len;
    for ( len = 0; yy_str[len]; ++len )
        ;

    return yy_scan_bytes( yy_str, len );
    }
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
    {
    // DirectUI: Return NULL on error
    
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = (char *) yy_flex_alloc( n );
    if ( ! buf )
        {
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
        return NULL;
        }

    for ( i = 0; i < len; ++i )
        buf[i] = bytes[i];

    buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer( buf, n );
    if ( ! b )
        {
        yy_flex_free(buf);  // DirectUI: Free previous alloc on failure
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        return NULL;
        }

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
    }
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static BOOL yy_push_state( int new_state )
#else
static BOOL yy_push_state( new_state )
int new_state;
#endif
    {
    // DirectUI: Return FALSE on error
    
    if ( yy_start_stack_ptr >= yy_start_stack_depth )
        {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof( int );

        if ( ! yy_start_stack )
            yy_start_stack = (int *) yy_flex_alloc( new_size );

        else
            yy_start_stack = (int *) yy_flex_realloc(
                    (void *) yy_start_stack, new_size );

        if ( ! yy_start_stack )
            {
            YY_FATAL_ERROR(
            "out of memory expanding start-condition stack" );
            return FALSE;  // DirectUI
            }
        }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
    }
#endif


#ifndef YY_NO_POP_STATE
static BOOL yy_pop_state()
    {
    // DirectUI: Returns BOOL, FALSE on failure
    
    if ( --yy_start_stack_ptr < 0 )
        {
        YY_FATAL_ERROR( "start-condition stack underflow" );
        return FALSE;  // DirectUI
        }

    BEGIN(yy_start_stack[yy_start_stack_ptr]);

    return TRUE;
    }
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
    {
    return yy_start_stack[yy_start_stack_ptr - 1];
    }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
    {
    (void) fprintf( stderr, "%s\n", msg );
    //exit( YY_EXIT_FAILURE );  // DirectUI: Never exit process
    }



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        yytext[yyleng] = yy_hold_char; \
        yy_c_buf_p = yytext + n; \
        yy_hold_char = *yy_c_buf_p; \
        *yy_c_buf_p = '\0'; \
        yyleng = n; \
        } \
    while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
    {
    register int i;
    for ( i = 0; i < n; ++i )
        s1[i] = s2[i];
    }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
    {
    register int n;
    for ( n = 0; s[n]; ++n )
        ;

    return n;
    }
#endif

////////////////////////////
// DirectUI
#ifndef CUSTOMALLOC
#define CUSTOMALLOC malloc
#endif
////////////////////////////

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
    {
    return (void *) CUSTOMALLOC ( size );
    }

////////////////////////////
// DirectUI
#ifndef CUSTOMREALLOC
#define CUSTOMREALLOC realloc
#endif
////////////////////////////

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
    {
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void *) CUSTOMREALLOC ( (char *) ptr, size );
    }

////////////////////////////
// DirectUI
#ifndef CUSTOMFREE
#define CUSTOMFREE free
#endif
////////////////////////////


#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
    {
    CUSTOMFREE ( ptr );
    }

#if YY_MAIN
int main()
    {
    yylex();
    return 0;
    }
#endif

////////////////////////////
// DirectUI
} // namespace DirectUI
////////////////////////////


namespace DirectUI
{

int yywrap()
{
    return 1;
}

LPWSTR UniDupString(LPSTR ps)
{
    // Convert raw string to Unicode, all strings are placed in temp parse-time storage
    LPWSTR pns = MultiByteToUnicode(ps);
    ppc->_TrackTempAlloc(pns);

    // "Trim" quotes from string
    *(pns + (wcslen(pns) - 1)) = 0;
    pns++;

    // Insert newlines (newline code is '~', requires 'wrap' content align)
    LPWSTR pscan = pns;

    while (*pscan)
    {
        if (*pscan == '~')
            *pscan = '\n';

        pscan++;
    }

    // Must be freed
    return pns;
}

void yy_delete_current_buffer()
{
    yy_delete_buffer(YY_CURRENT_BUFFER);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\parser\stdafxparser.cpp ===
/*
 * stdafxparser.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\gadget.cpp ===
/*
 * Manual Gadget utility methods
 */

#include "stdafx.h"
#include "util.h"

#include "duigadget.h"

namespace DirectUI
{

void SetGadgetOpacity(HGADGET hgad, BYTE dAlpha)
{
#ifdef GADGET_ENABLE_GDIPLUS

    //
    // When using GDI+, we are directly modifying the alpha channel of our 
    // primitives, rather than using DirectUser's buffers.
    //

    UNREFERENCED_PARAMETER(hgad);
    UNREFERENCED_PARAMETER(dAlpha);

#else

    // Set gadget opacity (225=opaque, 0=transparent)
    if (dAlpha == 255) 
    {
        SetGadgetStyle(hgad, 0, GS_BUFFERED);
        SetGadgetStyle(hgad, 0, GS_OPAQUE);
    } 
    else 
    {
        SetGadgetStyle(hgad, GS_OPAQUE, GS_OPAQUE);
        SetGadgetStyle(hgad, GS_BUFFERED, GS_BUFFERED);

        BUFFER_INFO bi = {0};
        bi.cbSize = sizeof(BUFFER_INFO);
        bi.nMask = GBIM_ALPHA;
        bi.bAlpha = dAlpha;

        SetGadgetBufferInfo(hgad, &bi);
    }
    
#endif    
}

void OffsetGadgetPosition(HGADGET hgad, int x, int y)
{
    RECT rc;
    GetGadgetRect(hgad, &rc, SGR_PARENT);
    rc.left += x;
    rc.top += y;
    SetGadgetRect(hgad, rc.left, rc.top, 0, 0, SGR_PARENT | SGR_MOVE);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\emfload.cpp ===
/*
 * Metafile converter/loader
 */

#include "stdafx.h"
#include "util.h"

#include "duiemfload.h"

namespace DirectUI
{

// Caller must free using DeleteEnhMetaFile

HENHMETAFILE LoadMetaFile(LPCWSTR pszMetaFile)
{
    HENHMETAFILE hEMF = NULL;

    // Open file read only
    HANDLE hFile = CreateFileW(pszMetaFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (hFile == (HANDLE)-1)
        return NULL;

    // Create file mapping of open file
    HANDLE hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hFileMap)
    {
        CloseHandle(hFile);
        return NULL;
    }

    // Map a view of the whole file
    void* pFileMap = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);

    if (!pFileMap)
    {
        CloseHandle(hFileMap);
        CloseHandle(hFile);
        return NULL;
    }

    hEMF = LoadMetaFile(pFileMap, GetFileSize(hFile, NULL));

    // Cleanup
    UnmapViewOfFile(pFileMap);
    CloseHandle(hFileMap);
    CloseHandle(hFile);

    return hEMF;
}

HENHMETAFILE LoadMetaFile(UINT uRCID, HINSTANCE hInst)
{
    HENHMETAFILE hEMF = NULL;

    // Locate resource
    WCHAR szID[41];
    swprintf(szID, L"#%u", uRCID);

    HRSRC hResInfo = FindResourceW(hInst, szID, L"MetaFile");
    DUIAssert(hResInfo, "Unable to locate resource");

    if (hResInfo)
    {
        HGLOBAL hResData = LoadResource(hInst, hResInfo);
        DUIAssert(hResData, "Unable to load resource");

        if (hResData)
        {
            const CHAR* pBuffer = (const CHAR*)LockResource(hResData);
            DUIAssert(pBuffer, "Resource could not be locked");

            hEMF = LoadMetaFile((void*)pBuffer, SizeofResource(hInst, hResInfo));
        }
    }

    return hEMF;
}

HENHMETAFILE LoadMetaFile(void* pData, UINT cbSize)
{
    HENHMETAFILE hEMF = NULL;

    // Process file based on type
    if (((LPENHMETAHEADER)pData)->dSignature == ENHMETA_SIGNATURE)
    {
        // Found Windows Enhanced Metafile
        hEMF = SetEnhMetaFileBits(cbSize, (BYTE*)pData);
    }
    else if (*((LPDWORD)pData) == APM_SIGNATURE)
    {
        // Found Aldus Placeable Metafile (APM)
        PAPMFILEHEADER pApm = (PAPMFILEHEADER)pData;
        PMETAHEADER pMf = (PMETAHEADER)(pApm + 1);
        METAFILEPICT mfpMf;
        HDC hDC;

        // Setup metafile picture structure
        mfpMf.mm = MM_ANISOTROPIC;
        mfpMf.xExt = MulDiv(pApm->bbox.right-pApm->bbox.left, HIMETRICINCH, pApm->inch);
        mfpMf.yExt = MulDiv(pApm->bbox.bottom-pApm->bbox.top, HIMETRICINCH, pApm->inch);
        mfpMf.hMF = NULL;

        // Reference DC
        hDC = GetDC(NULL);
        SetMapMode(hDC,MM_TEXT);

        // Convert to an Enhanced Metafile
        hEMF = SetWinMetaFileBits(pMf->mtSize * 2, (PBYTE)pMf, hDC, &mfpMf);

        ReleaseDC(NULL, hDC);
    }
    else
    {
        // Found Windows 3.x Metafile
		hEMF = SetWinMetaFileBits(cbSize, (PBYTE)pData, NULL, NULL);
    }

    return hEMF;
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\ninegrid.cpp ===
/*
 * NineGrid bitmap rendering (ported from UxTheme)
 */

#include "stdafx.h"
#include "util.h"

#include "duininegrid.h"

namespace DirectUI
{

//---------------------------------------------------------------------------
void GetAlignedRect(HALIGN halign, VALIGN valign, CONST RECT *prcFull, 
    int width, int height, RECT *prcTrue)
{
    //---- apply HALIGN ----
    if (halign == HA_LEFT)
    {
        prcTrue->left = prcFull->left;
    }
    else if (halign == HA_CENTER)
    {
        int diff = WIDTH(*prcFull) - width;
        prcTrue->left = prcFull->left + (diff/2); 
    }
    else            // halign == HA_RIGHT
    {
        prcTrue->left = prcFull->right - width;
    }

    if (prcTrue->left < prcFull->left)
        prcTrue->left = prcFull->left;

    if ((prcTrue->left + width) > prcFull->right)
        prcTrue->right = prcFull->right;
    else
        prcTrue->right = prcTrue->left + width;

    //---- apply VALIGN ----
    if (valign == VA_TOP)
    {
        prcTrue->top = prcFull->top;
    }
    else if (valign == VA_CENTER)
    {
        int diff = HEIGHT(*prcFull) - height;
        prcTrue->top = prcFull->top + (diff/2); 
    }
    else            // valign == VA_BOTTOM
    {
        prcTrue->top = prcFull->bottom - height;
    }

    if (prcTrue->top < prcFull->top)
        prcTrue->top = prcFull->top;

    if ((prcTrue->top + height) > prcFull->bottom)
        prcTrue->bottom = prcFull->bottom;
    else
        prcTrue->bottom = prcTrue->top + height;
}
//---------------------------------------------------------------------------
HBRUSH CreateDibDirectBrush(HDC hdcSrc, int iSrcX, int iSrcY, int iSrcW, int iSrcH, 
    BITMAPINFOHEADER *pSrcHdr, BYTE *pSrcBits, BRUSHBUFF *pbb, BOOL fFlipIt)
{
    UNREFERENCED_PARAMETER(hdcSrc);

    HBRUSH hbr = NULL;

//    ATLAssert(pSrcHdr != NULL);
//    ATLAssert(pSrcBits != NULL);
//    ATLAssert(pbb != NULL);

    //---- ensure pbb->pBuff is big enough for our temp. brush DIB ----
    BITMAPINFOHEADER *pHdr;
    BYTE *pDest;
    BYTE *pSrc;
    int iBytesPerPixel = pSrcHdr->biBitCount/8;

    int iSrcRawBytesPerRow = pSrcHdr->biWidth*iBytesPerPixel;
    int iSrcBytesPerRow = ((iSrcRawBytesPerRow + 3)/4)*4;

    int iDestRawBytesPerRow = iSrcW*iBytesPerPixel;
    int iDestBytesPerRow = ((iDestRawBytesPerRow + 3)/4)*4;

    int iBuffLen = sizeof(BITMAPINFOHEADER) + iSrcH*iDestBytesPerRow;

    if (iBuffLen > pbb->iBuffLen)          // reallocate 
    {
        HFree(pbb->pBuff);
        pbb->iBuffLen = 0;

        pbb->pBuff = (BYTE*)HAlloc(iBuffLen * sizeof(BYTE));
        if (! pbb->pBuff)
        {
//            MakeError32(E_OUTOFMEMORY);
            goto exit;
        }
        
        pbb->iBuffLen = iBuffLen;
    }

    //---- fill out hdr ----
    pHdr = (BITMAPINFOHEADER *)pbb->pBuff;
    memset(pHdr, 0, sizeof(BITMAPINFOHEADER));

    pHdr->biSize = sizeof(BITMAPINFOHEADER);
    pHdr->biWidth = iSrcW;
    pHdr->biHeight = iSrcH;
    pHdr->biPlanes = 1;
    pHdr->biBitCount = static_cast<WORD>(iBytesPerPixel * 8);

    //---- NOTE: rows are reversed in the DIB src and should also be----
    //---- built reversed in the DIB dest ----

    //---- prepare to copy brush bits to buff ----
    pSrc = pSrcBits + (pSrcHdr->biHeight - (iSrcY + iSrcH))*iSrcBytesPerRow + iSrcX*iBytesPerPixel;
    pDest = pbb->pBuff + sizeof(BITMAPINFOHEADER);

    if (fFlipIt)       // trickier case - mirror the pixels in each row
    {
        int iTwoPixelBytes = 2*iBytesPerPixel;

        //---- copy each row ----
        for (int iRow=0; iRow < iSrcH; iRow++)
        {
            pDest += (iDestRawBytesPerRow - iBytesPerPixel);      // point at last value
            BYTE *pSrc2 = pSrc;

            //---- copy each pixel in current row ----
            for (int iCol=0; iCol < iSrcW; iCol++)
            {
                //---- copy a single pixel ----
                for (int iByte=0; iByte < iBytesPerPixel; iByte++)
                    *pDest++ = *pSrc2++;

                pDest -= iTwoPixelBytes;        // point at previous value
            }

            pSrc += iSrcBytesPerRow;
            pDest += (iDestBytesPerRow + iBytesPerPixel);
        }
    }
    else            // non-mirrored rows
    {
        //---- copy each row ----
        for (int iRow=0; iRow < iSrcH; iRow++)
        {
            memcpy(pDest, pSrc, iSrcW*iBytesPerPixel);

            pSrc += iSrcBytesPerRow;
            pDest += iDestBytesPerRow;
        }
    }

    //---- now create the brush ----
    hbr = CreateDIBPatternBrushPt(pbb->pBuff, DIB_RGB_COLORS);

exit:
    return hbr;
}
//---------------------------------------------------------------------------
HBRUSH CreateDibBrush(HDC hdcSrc, int iSrcX, int iSrcY, int iSrcW, int iSrcH, BOOL fFlipIt)
{
    //---- this function is REALLY SLOW for 32-bit source dc/bitmap ----
    
    //---- copy our target portion of bitmap in hdcSrc to a memory dc/bitmap ----
    //---- and then call CreatePatternBrush() to make a brush from it ----

    HBRUSH hbr = NULL;
    DWORD dwOldLayout = 0;

    HBITMAP hBitmap = CreateCompatibleBitmap(hdcSrc, iSrcW, iSrcH);
    if (hBitmap)
    {
        HDC hdcMemory = CreateCompatibleDC(hdcSrc);
        if (hdcMemory)
        {
            if (fFlipIt)
            {
                dwOldLayout = GetLayout(hdcMemory);

                //---- toggle layout so it is different than png->hdcSrc ----
                if (dwOldLayout & LAYOUT_RTL)
                    SetLayout(hdcMemory, 0);
                else
                    SetLayout(hdcMemory, LAYOUT_RTL);
            }

            HBITMAP hbmOld = (HBITMAP) SelectObject(hdcMemory, hBitmap);
            if (hbmOld)
            {
                BitBlt(hdcMemory, 0, 0, iSrcW, iSrcH, hdcSrc, iSrcX, iSrcY, SRCCOPY);

                SelectObject(hdcMemory, hbmOld);

                hbr = CreatePatternBrush(hBitmap);
            }

            if (fFlipIt)
                SetLayout(hdcMemory, dwOldLayout);

            DeleteDC(hdcMemory);
        }

        DeleteObject(hBitmap);
    }

    return hbr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltCopy(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY)
{
    HRESULT hr = S_OK;

    int width = iDestW;
    int height = iDestH;

    //---- draw image in true size ----
    if (pmb->dwOptions & DNG_ALPHABLEND)
    {
        AlphaBlend(pmb->hdcDest, iDestX, iDestY, width, height, 
            pmb->hdcSrc, iSrcX, iSrcY, width, height, 
            pmb->AlphaBlendInfo);
    }
    else if (pmb->dwOptions & DNG_TRANSPARENT)
    {
        TransparentBlt(pmb->hdcDest, iDestX, iDestY, width, height, 
            pmb->hdcSrc, iSrcX, iSrcY, width, height, 
            pmb->crTransparent);
    }
    else
    {
        if (pmb->dwOptions & DNG_DIRECTBITS)
        {
            //---- this guy requires flipped out y values ----
            int iTotalHeight = pmb->pbmHdr->biHeight;

            int iSrcY2 = iTotalHeight - (iSrcY + iDestH);

            StretchDIBits(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH,
                iSrcX, iSrcY2, iDestW, iDestH, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                DIB_RGB_COLORS, SRCCOPY);
        }
        else
        {
            BOOL fOk = BitBlt(pmb->hdcDest, iDestX, iDestY, width, height, 
                pmb->hdcSrc, iSrcX, iSrcY, SRCCOPY);

            if (! fOk)       // something went wrong
            {
                //ATLAssert(0);       // local testing only

                hr = GetLastError();
            }
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltStretch(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_OK;
    
    //---- do the real work here ----
    if (pmb->dwOptions & DNG_ALPHABLEND)
    {
        AlphaBlend(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
            pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, 
            pmb->AlphaBlendInfo);
    }
    else if (pmb->dwOptions & DNG_TRANSPARENT)
    {
        TransparentBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
            pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, 
            pmb->crTransparent);
    }
    else
    {
        if (pmb->dwOptions & DNG_DIRECTBITS)
        {
            //---- this guy requires flipped out y values ----
            int iTotalHeight = pmb->pbmHdr->biHeight;

            int iSrcY2 = iTotalHeight - (iSrcY + iSrcH);

            StretchDIBits(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH,
                iSrcX, iSrcY2, iSrcW, iSrcH, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                DIB_RGB_COLORS, SRCCOPY);
        }
        else
        {
            StretchBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, 
                pmb->hdcSrc, iSrcX, iSrcY, iSrcW, iSrcH, SRCCOPY);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBltTile(MBINFO *pmb, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_OK;
    BOOL fFlipGrids = pmb->dwOptions & DNG_FLIPGRIDS;

    //---- default origin ----
    int alignx = iDestX;         
    int aligny = iDestY;         

    if (pmb->dwOptions & DNG_TILEORIGIN)
    {
        alignx = pmb->ptTileOrigin.x;
        aligny = pmb->ptTileOrigin.y;
    }

    if ((pmb->dwOptions & DNG_ALPHABLEND) || (pmb->dwOptions & DNG_TRANSPARENT) || 
        (pmb->dwOptions & DNG_DIRECTBITS) || (pmb->dwOptions & DNG_MANUALTILING))
    {
        //---- must do manual tiling ----
        int maxbot = iDestY + iDestH;
        int maxright = iDestX + iDestW;

        int iTileCount = 0;

        for (int yoff=iDestY; yoff < maxbot; yoff+=iSrcH)
        {
            for (int xoff=iDestX; xoff < maxright; xoff+=iSrcW)
            {
                //---- manual clipping ----
                int width = min(iSrcW, maxright - xoff);
                int height = min(iSrcH, maxbot - yoff);
    
                if (pmb->dwOptions & DNG_ALPHABLEND)
                {
                    AlphaBlend(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, width, height, pmb->AlphaBlendInfo);
                }
                else if (pmb->dwOptions & DNG_TRANSPARENT)
                {
                    TransparentBlt(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, width, height, pmb->crTransparent);
                }
                else if (pmb->dwOptions & DNG_DIRECTBITS)
                {
                    //---- this guy requires flipped out y values ----
                    int iTotalHeight = pmb->pbmHdr->biHeight;

                    int iSrcY2 = iTotalHeight - (iSrcY + height);

                    StretchDIBits(pmb->hdcDest, xoff, yoff, width, height,
                        iSrcX, iSrcY2, width, height, pmb->pBits, (BITMAPINFO *)pmb->pbmHdr, 
                        DIB_RGB_COLORS, SRCCOPY);
                }
                else        // manual tiling option
                {
                    BitBlt(pmb->hdcDest, xoff, yoff, width, height, 
                        pmb->hdcSrc, iSrcX, iSrcY, SRCCOPY);
                }

                iTileCount++;
            }
        }

//        Log(LOG_TILECNT, L"Manual Tile: Grid=%d, SrcW=%d, SrcH=%d, DstW=%d, DstH=%d, TileCount=%d", 
//            pmb->iCacheIndex, iSrcW, iSrcH, iDestW, iDestH, iTileCount);
    }
    else
    {
        //---- FAST TILE: need to create a sub-bitmap ----
        HBRUSH hBrush = NULL;

        //---- need a tiling brush - try cache first ----
        if ((pmb->dwOptions & DNG_CACHEBRUSHES) && (pmb->pCachedBrushes))
        {
            hBrush = pmb->pCachedBrushes[pmb->iCacheIndex];
        }

        if (! hBrush)       // need to build one
        {
            if (pmb->dwOptions & DNG_DIRECTBRUSH)
            {
                hBrush = CreateDibDirectBrush(pmb->hdcSrc, iSrcX, iSrcY,
                    iSrcW, iSrcH, pmb->pbmHdr, pmb->pBits, pmb->pBrushBuff, fFlipGrids);
            }
            else
            {
//                Log(LOG_TILECNT, L"CreateDibBrush: MirrDest=%d, MirrSrc=%d, FlipDest=%d, FlipSrc=%d",
//                    IsMirrored(pmb->hdcDest), IsMirrored(pmb->hdcSrc), IsFlippingBitmaps(pmb->hdcDest),
//                    IsFlippingBitmaps(pmb->hdcSrc));

                hBrush = CreateDibBrush(pmb->hdcSrc, iSrcX, iSrcY,
                    iSrcW, iSrcH, fFlipGrids);
            }
        }

        //---- align brush with rect being painted ----
        if (fFlipGrids)      
        {
            //---- calculate brush origin in device coords ----
            POINT pt = {alignx + iDestW - 1, aligny};
            LPtoDP(pmb->hdcDest, &pt, 1);

            alignx = pt.x;
        }

        SetBrushOrgEx(pmb->hdcDest, alignx, aligny, NULL);

        HBRUSH hbrOld = (HBRUSH)SelectObject(pmb->hdcDest, hBrush);
        PatBlt(pmb->hdcDest, iDestX, iDestY, iDestW, iDestH, PATCOPY);
        SelectObject(pmb->hdcDest, hbrOld);

        //RECT rc = {iDestX, iDestY, iDestX+iDestW, iDestY+iDestH};
        //FillRect(pmb->hdcDest, &rc, hBrush);

        //---- add back to cache, if possible ----
        if ((pmb->dwOptions & DNG_CACHEBRUSHES) && (pmb->pCachedBrushes))
        {
            pmb->pCachedBrushes[pmb->iCacheIndex] = hBrush;
        }
        else
        {
            DeleteObject(hBrush);
        }

//        Log(LOG_TILECNT, L"PatBlt() Tile: Grid=%d, SrcW=%d, SrcH=%d, DstW=%d, DstH=%d", 
//            pmb->iCacheIndex, iSrcW, iSrcH, iDestW, iDestH);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT MultiBlt(MBINFO *pmb, MBSIZING eSizing, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH)
{
    HRESULT hr = S_FALSE;
    RECT rect;

    //---- validate MBINFO ----
    if (pmb->dwSize != sizeof(MBINFO))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //---- anything to paint from? ----
    if ((iSrcW <= 0) || (iSrcH <= 0))
        goto exit;

    //---- clipping ----
    rect = pmb->rcClip;

    if (iDestX < rect.left)
        iDestX = rect.left;

    if (iDestY < rect.top)
        iDestY = rect.top;

    if (iDestX + iDestW > rect.right)
        iDestW = rect.right - rect.left;

    if (iDestY + iDestH > rect.bottom)
        iDestH = rect.bottom - rect.top;

    //---- anything iLeft to draw? ----
    if ((iDestW <= 0) || (iDestH <= 0))
        goto exit;

    //---- dispatch to correct handler ----
    if (eSizing == MB_COPY)
    {
        hr = MultiBltCopy(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY);
    }
    else if (eSizing == MB_STRETCH)
    {
        hr = MultiBltStretch(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY, iSrcW, iSrcH);
    }
    else if (eSizing == MB_TILE)
    {
        hr = MultiBltTile(pmb, iDestX, iDestY, iDestW, iDestH, iSrcX, iSrcY, iSrcW, iSrcH);
    }
    else
    {
        hr = E_INVALIDARG;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT DrawSampledBorders(NGINFO *png, HDC hdcSrc, int lw1, int rw1, int th1, int bh1)
{
    UNREFERENCED_PARAMETER(hdcSrc);
    UNREFERENCED_PARAMETER(bh1);
    UNREFERENCED_PARAMETER(th1);
    UNREFERENCED_PARAMETER(rw1);
    UNREFERENCED_PARAMETER(lw1);

    int iCount, iTop, iBot, iLeft, iRight;
    HDC hdcDest = png->hdcDest;
    COLORREF crOld = SetBkColor(hdcDest, 0);
    RECT rcDest = png->rcDest;

    //---- draw left borders ----
    iCount = png->iSrcMargins[0];
    iTop = rcDest.top;
    iBot = rcDest.bottom;
    iLeft = rcDest.left;

    COLORREF *pNextColor = png->pcrBorders;

    if (png->dwOptions & DNG_SOLIDCONTENT)
        pNextColor++;       // skip over content color

    for (int i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iTop, iLeft+1, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iBot--;
        iLeft++;
    }

    //---- draw right borders ----
    iCount = png->iSrcMargins[1];
    iTop = rcDest.top;
    iBot = rcDest.bottom;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iRight-1, iTop, iRight, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iBot--;
        iRight--;
    }

    //---- draw top borders ----
    iCount = png->iSrcMargins[2];
    iTop = rcDest.top;
    iLeft = rcDest.left;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iTop, iRight, iTop+1};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iTop++;
        iLeft++;
        iRight--;
    }

    //---- draw bottom borders ----
    iCount = png->iSrcMargins[3];
    iBot = rcDest.bottom;
    iLeft = rcDest.left;
    iRight = rcDest.right;
    
    for (i=0; i < iCount; i++)
    {
        COLORREF crSample = *pNextColor++;

        //---- fast line draw ----
        SetBkColor(hdcDest, crSample);
        RECT rcLine = {iLeft, iBot-1, iRight, iBot};
        ExtTextOut(hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

        //---- shrink lines to avoid overlap with other borders ----
        iBot--;
        iLeft++;
        iRight--;
    }

    //---- restore old color ----
    SetBkColor(hdcDest, crOld);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT DrawNineGrid(NGINFO *png)
{
    HBITMAP hOldBitmap = NULL;
    MBINFO mbinfo = {sizeof(mbinfo)};
    HRESULT hr = S_OK;
    HDC hdcSrc = NULL;
    BOOL fBorder;
    BOOL fContent;
    DWORD dwOldLayout = 0;

    RECT rcDest = png->rcDest;
    RECT rcSrc = png->rcSrc;

    //---- the source margin variables ----
    int lw1, rw1, th1, bh1;
    lw1 = png->iSrcMargins[0];
    rw1 = png->iSrcMargins[1];
    th1 = png->iSrcMargins[2];
    bh1 = png->iSrcMargins[3];

    if ((lw1 < 0) || (rw1 < 0) || (th1 < 0) || (bh1 < 0))   // not valid
    {
        hr = E_FAIL;
        goto exit;
    }

    int iDestW, iDestH;
    iDestH = HEIGHT(rcDest);
    iDestW = WIDTH(rcDest);

    int iSrcW, iSrcH;
    iSrcH = HEIGHT(rcSrc);
    iSrcW = WIDTH(rcSrc);

    //---- prevent left/right src margins from drawing overlapped ----
    if (lw1 + rw1 > iDestW)
    {
        //---- reduce each but maintain ratio ----
        lw1 = int(.5 + float(lw1*iDestW)/float(lw1+rw1));
        rw1 = iDestW - lw1;
    }

    //---- prevent top/bottom src margins from drawing overlapped ----
    if ((th1 + bh1) > iDestH)
    {
        //---- reduce each but maintain ratio ----
        th1 = int(.5 + float(th1*iDestH)/float(th1+bh1));
        bh1 = iDestH - th1;
    }

    //---- make our bitmap usable ----
    hdcSrc = CreateCompatibleDC(png->hdcDest);
    if (! hdcSrc)
    {
        hr = GetLastError();
        goto exit;
    }
    
    if (png->dwOptions & DNG_FLIPGRIDS)
    {
        dwOldLayout = GetLayout(hdcSrc);

        //---- toggle layout so it is different than png->hdcDest ----
        if (dwOldLayout & LAYOUT_RTL)
            SetLayout(hdcSrc, 0);
        else
            SetLayout(hdcSrc, LAYOUT_RTL);
    }
    
    hOldBitmap = (HBITMAP) SelectObject(hdcSrc, png->hBitmap);
    if (! hOldBitmap)       // something wrong with png->hBitmap
    {
        hr = GetLastError();
        goto exit;
    }

    //---- transfer info from png to mbinfo ----
    mbinfo.hdcSrc = hdcSrc;
    mbinfo.hdcDest = png->hdcDest;
    mbinfo.dwOptions = png->dwOptions;

    mbinfo.crTransparent = png->crTransparent;
    mbinfo.rcClip = png->rcClip;
    mbinfo.hBitmap = png->hBitmap;

    mbinfo.pBits = png->pBits;
    mbinfo.pbmHdr = png->pbmHdr;

    mbinfo.AlphaBlendInfo = png->AlphaBlendInfo;
    mbinfo.ptTileOrigin = png->ptTileOrigin;
    mbinfo.iCacheIndex = 0;
    mbinfo.pCachedBrushes = png->pCachedBrushes;

    mbinfo.pBrushBuff = png->pBrushBuff;

    //---- make some values easier to read ----
    fBorder = ((png->dwOptions & DNG_OMITBORDER)==0);
    fContent = ((png->dwOptions & DNG_OMITCONTENT)==0);

    if ((png->eImageSizing == ST_TRUESIZE) && (fBorder) && (fContent))            // just draw & exit
    {
        if (png->dwOptions & DNG_BGFILL)
        {
            //---- fill bg ----
            HBRUSH hbr = CreateSolidBrush(png->crFill);
            if (! hbr)
            {
                hr = GetLastError();
                goto exit;
            }

            FillRect(png->hdcDest, &rcDest, hbr);
            DeleteObject(hbr);
        }

        RECT rcActual;
        GetAlignedRect(png->eHAlign, png->eVAlign, &rcDest, iSrcW, iSrcH, &rcActual);

        hr = MultiBlt(&mbinfo, MB_COPY, rcActual.left, rcActual.top, iSrcW, iSrcH,
            rcSrc.left, rcSrc.top, iSrcW, iSrcH);
        goto exit;
    }

    MBSIZING eSizing, eDefaultSizing;
    if (png->eImageSizing > ST_TILE)            // special tiling mode (dependent on grid)
        eSizing = MB_STRETCH;       // will correct where needed
    else
        eSizing = (MBSIZING)png->eImageSizing;

    //---- optimize for no borders specified
    if ((! lw1) && (! rw1) && (! th1) && (! bh1))
    {
        if (fContent)
        {
            mbinfo.iCacheIndex = 0;

            hr = MultiBlt(&mbinfo, eSizing, rcDest.left, rcDest.top, iDestW, iDestH,
                rcSrc.left, rcSrc.top, iSrcW, iSrcH);
        }

        goto exit;
    }

    //---- the destination margin variables ----
    int lw2, rw2, th2, bh2;
    lw2 = png->iDestMargins[0];
    rw2 = png->iDestMargins[1];
    th2 = png->iDestMargins[2];
    bh2 = png->iDestMargins[3];

    int w2;
    w2 = iDestW - lw2 - rw2;
    int h2;
    h2 = iDestH - th2 - bh2;
    
    //---- prevent left/right dest margins from drawing overlapped ----
    if (lw2 + rw2 > iDestW)
    {
        //---- reduce each but maintain ratio ----
        lw2 = int(.5 + float(lw2*iDestW)/float(lw2+rw2));
        rw2 = iDestW - lw2;
    }

    //---- prevent top/bottom dest margins from drawing overlapped ----
    if ((th2 + bh2) > iDestH)
    {
        //---- reduce each but maintain ratio ----
        th2 = int(.5 + float(th2*iDestH)/float(th2+bh2));
        bh2 = iDestH - th2;
    }

    eDefaultSizing = eSizing;

    if (fContent)
    {
        //---- can we draw content as a solid color? ----
        if ((png->dwOptions & DNG_SOLIDCONTENT) && (png->pcrBorders))
        {
            //---- fast rect draw ----
            COLORREF crContent = *png->pcrBorders;       // first one is content color

            COLORREF crOld = SetBkColor(png->hdcDest, crContent);
            RECT rcLine = {rcDest.left + lw2, rcDest.top + th2, rcDest.right - rw2,
                rcDest.bottom - bh2};

            ExtTextOut(png->hdcDest, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);
            
            //---- restore color ----
            SetBkColor(png->hdcDest, crOld);
        }
        else
        {
            //---- middle area ----
            if (png->eImageSizing == ST_TILECENTER)
                eSizing = MB_TILE;
            else
                eSizing = eDefaultSizing;

            mbinfo.iCacheIndex = 0;

            hr = MultiBlt(&mbinfo, eSizing, 
                    // destination: x, y, width, height
                    rcDest.left + lw2, rcDest.top + th2, w2, h2,
                    // source: x, y, width, height
                    rcSrc.left + lw1, rcSrc.top + th1, iSrcW-lw1-rw1, iSrcH-th1-bh1);

            if (FAILED(hr))
                goto exit;
        }
    }

    if (fBorder)
    {
        //---- can we draw borders as solids? ----
        if ((png->dwOptions & DNG_SOLIDBORDER) && (png->pcrBorders))
        {
            hr = DrawSampledBorders(png, hdcSrc, lw1, rw1, th1, bh1);
            goto exit;
        }

        //---- here come the stretch/tile areas ----
        //---- upper/middle area ----
        if (png->eImageSizing == ST_TILEHORZ)
            eSizing = MB_TILE;
        else
            eSizing = eDefaultSizing;
        
        mbinfo.iCacheIndex = 2;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left + lw2, rcDest.top, w2, th2,  
                // source: x, y, width, height
                rcSrc.left + lw1, rcSrc.top, iSrcW-lw1-rw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- lower/middle area ----
        mbinfo.iCacheIndex = 4;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left + lw2, rcDest.bottom-bh2, w2, bh2, 
                // source: x, y, width, height
                rcSrc.left+lw1, rcSrc.top+iSrcH-bh1, iSrcW-lw1-rw1, bh1);

        if (FAILED(hr))
            goto exit;

        //---- left/middle area ----
        if (png->eImageSizing == ST_TILEVERT)
            eSizing = MB_TILE;
        else
            eSizing = eDefaultSizing;

        mbinfo.iCacheIndex = 1;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.left, rcDest.top + th2, lw2, h2,
                // source: x, y, width, height
                rcSrc.left, rcSrc.top+th1, lw1, iSrcH-th1-bh1);

        if (FAILED(hr))
            goto exit;

        //---- right/middle area ----
        mbinfo.iCacheIndex = 3;

        hr = MultiBlt(&mbinfo, eSizing,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.top + th2, rw2, h2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top+th1, rw1, iSrcH-th1-bh1);

        if (FAILED(hr))
            goto exit;

        //---- upper/left corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.left, rcDest.top, lw2, th2, 
                // source: x, y, width, height
                rcSrc.left, rcSrc.top, lw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- upper/right corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.top, rw2, th2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top, rw1, th1);

        if (FAILED(hr))
            goto exit;

        //---- bottom/right corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.right-rw2, rcDest.bottom-bh2, rw2, bh2, 
                // source: x, y, width, height
                rcSrc.left+iSrcW-rw1, rcSrc.top+iSrcH-bh1, rw1, bh1);

        if (FAILED(hr))
            goto exit;
    
        //---- bottom/left corner ----
        hr = MultiBlt(&mbinfo, MB_COPY,
                // destination: x, y, width, height
                rcDest.left, rcDest.bottom-bh2, lw2, bh2, 
                // source: x, y, width, height
                rcSrc.left, rcSrc.top+iSrcH-bh1, lw1, bh1);

        if (FAILED(hr))
            goto exit;
    }

exit:
    if (hdcSrc)
    {
        if (png->dwOptions & DNG_FLIPGRIDS)
            SetLayout(hdcSrc, dwOldLayout);

        if (hOldBitmap)
            SelectObject(hdcSrc, hOldBitmap);

        DeleteDC(hdcSrc);
    }

    return hr;
}
//---------------------------------------------------------------------------

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\published.h ===
/* 
 * Available headers for other internal projects
 *
 * Published.h contains a list of definitions that are exposed and available
 * outside this project.  Any other DirectUI project that wishes to use
 * these services directly instead of going through public API's can include
 * a corresponding [Project]P.h available in the \inc directory.
 *
 * Definitions that are not exposed through this file are considered project
 * specific implementation details and should not used in other projects.
 */

#ifndef DUI_UTIL_PUBLISHED_H_INCLUDED
#define DUI_UTIL_PUBLISHED_H_INCLUDED

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"
#include "duininegrid.h"

#endif // DUI_UTIL_PUBLISHED_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\sources.inc ===
!IF 0

    DirectUI Util Project sources file

!ENDIF

!include ..\..\sources.inc

SOURCES_USED=..\sources.inc

MAJORCOMP=user

INCLUDES=..;\
        ..\..\..\inc;\
        $(INCLUDES)

SOURCES=\
        ..\convert.cpp        \
        ..\emfload.cpp        \
        ..\gadget.cpp         \
        ..\ninegrid.cpp       \

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafxutil.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\convert.cpp ===
/*
 * Conversion
 */

#include "stdafx.h"
#include "util.h"

#include "duiconvert.h"

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// String conversion

// String must be freed with HeapFree(...)
LPSTR UnicodeToMultiByte(LPCWSTR pszUnicode, int cChars, int* pMultiBytes)
{
    // Negative chars means null-terminated
    // Get number of bytes required for multibyte string
    int dMultiBytes = WideCharToMultiByte(DUI_CODEPAGE, 0, pszUnicode, cChars, NULL, 0, NULL, NULL);

    LPSTR pszMulti = (LPSTR)HAlloc(dMultiBytes);

    if (pszMulti)
    {
        WideCharToMultiByte(DUI_CODEPAGE, 0, pszUnicode, cChars, pszMulti, dMultiBytes, NULL, NULL);

        if (pMultiBytes)
            *pMultiBytes = dMultiBytes;
    }

    return pszMulti;
}

// String must be freed with HeapFree(...)
LPWSTR MultiByteToUnicode(LPCSTR pszMulti, int dBytes, int* pUniChars)
{
    // Negative chars means null-terminated
    // Get number of bytes required for unicode string
    int cUniChars = MultiByteToWideChar(DUI_CODEPAGE, 0, pszMulti, dBytes, NULL, 0);

    LPWSTR pszUnicode = (LPWSTR)HAlloc(cUniChars * sizeof(WCHAR));

    if (pszUnicode)
    {
        MultiByteToWideChar(DUI_CODEPAGE, 0, pszMulti, dBytes, pszUnicode, cUniChars);

        if (pUniChars)
            *pUniChars = cUniChars;
    }

    return pszUnicode;
}

/////////////////////////////////////////////////////////////////////////////
// Atom conversion

ATOM StrToID(LPCWSTR psz)
{
    ATOM atom = FindAtomW(psz);
    DUIAssert(atom, "Atom could not be located");
    return atom;
}

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

// Loads a device-dependent (screen) image. Bitmap color information is
// converted to match device. If device is palette-based, image will be
// dithered to the halftone palette
//
// Device-dependent bitmaps are much faster in blitting operations than
// device-independent bitmps (no conversions required)

HBITMAP LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy)
{
    if (!pszBitmap)
    {
        DUIAssertForce("Invalid parameter: NULL");
        return NULL;
    }

    HBITMAP hBitmap = NULL;
    HDC hDC = GetDC(NULL);

    // Check device color depth
    if ((GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE) != RC_PALETTE)
    {
        // RBG --> RGB
        // PAL --> RGB

        // Non-palette based device. Do normal device-dependent LoadImage
        // which will map colors to the display device
        hBitmap = (HBITMAP)LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, cx, cy, hResLoad ? 0 : LR_LOADFROMFILE);
    }
    else
    {
        // RGB --> PAL
        // PAL --> PAL

        // Palette based. Map colors of image to device (using halftone dithering
        // if needed)
        HBITMAP hDib = (HBITMAP)LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION | (hResLoad ? 0 : LR_LOADFROMFILE));
        if (hDib)
        {
            DIBSECTION ds;
            ZeroMemory(&ds, sizeof(DIBSECTION));

            if (GetObjectW(hDib, sizeof(DIBSECTION), &ds) == sizeof(DIBSECTION))
            {
                // Get DIB info
                BITMAPINFOHEADER* pbmih = &ds.dsBmih;

                // Compatible (with screen) source DC
                HDC hDibDC = CreateCompatibleDC(hDC);
                if (hDibDC)
                {
                    // Select in DIB
                    HBITMAP hOldDibBm = (HBITMAP)SelectObject(hDibDC, hDib);

                    // Compatible (with screen) destination DC
                    HDC hHtDC = CreateCompatibleDC(hDC);
                    if (hHtDC)
                    {
                        // Create a bitmap for memory DC (and compatible with screen) and select
                        hBitmap = CreateCompatibleBitmap(hDC, pbmih->biWidth, pbmih->biHeight);
                        if (hBitmap)
                        {
                            HBITMAP hOldHtBm = (HBITMAP)SelectObject(hHtDC, hBitmap);

                            // Create and select halftone palette
                            HPALETTE hHtPal = CreateHalftonePalette(hHtDC);

                            if (hHtPal)
                            {
                                HPALETTE hOldPal = (HPALETTE)SelectPalette(hHtDC, hHtPal, FALSE);
                                RealizePalette(hHtDC);

                                // Setup blitting mode
                                POINT ptBrushOrg;
                                GetBrushOrgEx(hHtDC, &ptBrushOrg);
                                SetStretchBltMode(hHtDC, HALFTONE);
                                SetBrushOrgEx(hHtDC, ptBrushOrg.x, ptBrushOrg.y, NULL);

                                // Blit
                                StretchBlt(hHtDC, 0, 0, pbmih->biWidth, pbmih->biHeight, hDibDC,
                                    0, 0, pbmih->biWidth, pbmih->biHeight, SRCCOPY);

                                SelectPalette(hHtDC, hOldPal, TRUE);
                                DeleteObject(hHtPal);
                            }

                            SelectObject(hHtDC, hOldHtBm);
                        }

                        DeleteDC(hHtDC);
                    }

                    SelectObject(hDibDC, hOldDibBm);
                    DeleteDC(hDibDC);
                }
            }

            DeleteObject(hDib);
        }
    }

    ReleaseDC(NULL, hDC);

    return hBitmap;
}

#ifdef GADGET_ENABLE_GDIPLUS

HRESULT LoadDDBitmap(
    IN  LPCWSTR pszBitmap, 
    IN  HINSTANCE hResLoad, 
    IN  int cx, 
    IN  int cy, 
    IN  UINT nFormat, 
    OUT Gdiplus::Bitmap** ppgpbmp)
{
    HRESULT hr = E_INVALIDARG;
    Gdiplus::Bitmap* pgpbmp = NULL;

    *ppgpbmp = NULL;

    if (hResLoad)
    {
        // Handle if loading from a resource.  Load the HBITMAP and then 
        // convert it to GDI+.
        HBITMAP hbmpRaw = (HBITMAP) LoadImageW(hResLoad, pszBitmap, IMAGE_BITMAP, 0, 0, 
                LR_CREATEDIBSECTION | LR_SHARED);
        if (hbmpRaw == NULL) {
            return E_OUTOFMEMORY;
        }

        if ((nFormat == PixelFormat32bppPARGB) || (nFormat == PixelFormat32bppARGB)) {
            pgpbmp = ProcessAlphaBitmapF(hbmpRaw, nFormat);
        }

        if (pgpbmp == NULL) {
            pgpbmp = Gdiplus::Bitmap::FromHBITMAP(hbmpRaw, NULL);
        }

        if (hbmpRaw != NULL) {
            DeleteObject(hbmpRaw);
        }
        
        if (pgpbmp == NULL) {
            return E_OUTOFMEMORY;
        }
    } 
    else 
    {
        // Load from a file.  We can have GDI+ directly do this.
        pgpbmp = Gdiplus::Bitmap::FromFile(pszBitmap);
        if (!pgpbmp)
            return E_OUTOFMEMORY;
    }

    // Resize the bitmap
    int cxBmp = pgpbmp->GetWidth();
    int cyBmp = pgpbmp->GetHeight();

    if ((cx != 0) && (cy != 0) && ((cx != cxBmp) || (cy != cyBmp)))
    {
        Gdiplus::PixelFormat gppf = pgpbmp->GetPixelFormat();
        Gdiplus::Bitmap * pgpbmpTemp = new Gdiplus::Bitmap(cx, cy, gppf);
        if (pgpbmpTemp != NULL)
        {
            Gdiplus::Graphics gpgrNew(pgpbmpTemp);
            Gdiplus::Rect rcDest(0, 0, cx, cy);
            gpgrNew.DrawImage(pgpbmp, rcDest, 0, 0, cxBmp, cyBmp, Gdiplus::UnitPixel);

            *ppgpbmp = pgpbmpTemp;
            pgpbmpTemp = NULL;
            hr = S_OK;
        }

        delete pgpbmp;  // Created by GDI+ (cannot use HDelete)
    } 
    else 
    {
        *ppgpbmp = pgpbmp;
        hr = S_OK;
    }

    if (*ppgpbmp == NULL)
    {
        DUITrace("WARNING: Unable to load bitmap 0x%x\n", pszBitmap);
    }

    return hr;
}

#endif // GADGET_ENABLE_GDIPLUS


BOOL HasAlphaChannel(RGBQUAD * pBits, int cPixels)
{
    //
    // We need to examine the source bitmap to see if it contains an alpha
    // channel.  This is simply a heuristic since there is no format difference
    // between 32bpp 888 RGB image and 32bpp 8888 ARGB image.  What we do is look
    // for any non-0 alpha/reserved values.  If all alpha/reserved values are 0,
    // then the image would be 100% invisible if blitted with alpha - which is
    // almost cerainly not the desired result.  So we assume such bitmaps are
    // 32bpp non-alpha.
    //
    
    BOOL fAlphaChannel = FALSE;
    for (int i = 0; i < cPixels; i++) 
    {
        if (pBits[i].rgbReserved != 0)
        {
            fAlphaChannel = TRUE;
            break;
        }
    }

    return fAlphaChannel;
}


// Examines the source bitmap to see if it supports and uses an alpha
// channel.  If it does, a new DIB section is created that contains a
// premultiplied copy of the data from the source bitmap.
//
// If the source bitmap is not capable of supporting, or simply doesn't use,
// an alpha channel, the return value is NULL.
//
// If an error occurs, the return value is NULL.
//
// Ported from ProcessAlphaBitmap in ntuser kernel

HBITMAP ProcessAlphaBitmapI(HBITMAP hbmSource)
{
    BITMAP bmp;
    BITMAPINFO bi;
    HBITMAP hbmAlpha;
    RGBQUAD* pAlphaBitmapBits;
    DWORD cPixels;
    DWORD i;
    RGBQUAD pixel;
    BOOL fAlphaChannel;

    // There are several code paths that end up calling us with a NULL
    // hbmSource.  This is fine, in that it simply indicates that there
    // is no alpha channel.

    if (hbmSource == NULL)
        return NULL;

    if (GetObjectW(hbmSource, sizeof(BITMAP), &bmp) == 0)
        return NULL;

    // Only single plane, 32bpp bitmaps can even contain an alpha channel.
    if (bmp.bmPlanes != 1 || bmp.bmBitsPixel != 32) 
        return NULL;

    // Allocate room to hold the source bitmap's bits for examination.
    // We actually allocate a DIB - that will be passed out if the
    // source bitmap does indeed contain an alpha channel.

    ZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth       = bmp.bmWidth;
    bi.bmiHeader.biHeight      = bmp.bmHeight;
    bi.bmiHeader.biPlanes      = 1;
    bi.bmiHeader.biBitCount    = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    HDC hdcScreen = GetDC(NULL);

    hbmAlpha = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, (void**)&pAlphaBitmapBits, NULL, 0);

    if (NULL != hbmAlpha)
    {
        // Set up the header again in case it was tweaked by GreCreateDIBitmapReal.
        ZeroMemory(&bi, sizeof(bi));
        bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biWidth       = bmp.bmWidth;
        bi.bmiHeader.biHeight      = bmp.bmHeight;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biBitCount    = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        // Copy the bitmap data from the source bitmap into our alpha DIB.
        if (!GetDIBits(hdcScreen, hbmSource, 0, bi.bmiHeader.biHeight, (LPBYTE)pAlphaBitmapBits, (LPBITMAPINFO)&bi, DIB_RGB_COLORS))
        {
            DeleteObject(hbmAlpha);
            ReleaseDC(NULL, hdcScreen);
            return NULL;
        }

        cPixels  = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
        fAlphaChannel = HasAlphaChannel(pAlphaBitmapBits, cPixels);

        if (fAlphaChannel == FALSE)
        {
            DeleteObject(hbmAlpha);
            ReleaseDC(NULL, hdcScreen);
            return NULL;
        }

        // The source bitmap appears to use an alpha channel.  Spin through our
        // copy of the bits and premultiply them.  This is a necessary step to
        // prepare an alpha bitmap for use by GDI.
        for (i = 0; i < cPixels; i++)
        {
            pixel = pAlphaBitmapBits[i];

            pAlphaBitmapBits[i].rgbReserved = pixel.rgbReserved;
            pAlphaBitmapBits[i].rgbRed = (pixel.rgbRed * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbGreen = (pixel.rgbGreen * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbBlue = (pixel.rgbBlue * pixel.rgbReserved) / 0xFF;
        }
    }

    ReleaseDC(NULL, hdcScreen);

    return hbmAlpha;
}



#ifdef GADGET_ENABLE_GDIPLUS

Gdiplus::Bitmap * ProcessAlphaBitmapF(HBITMAP hbmSource, UINT nFormat)
{
    DUIAssert((nFormat == PixelFormat32bppPARGB) || (nFormat == PixelFormat32bppARGB),
            "Must have a valid format");
    
    //
    // Get the bits out of the DIB
    //
    // NOTE: Gdiplus::ARGB has bits in the same order as RGBQUAD, which allows 
    // us to directly copy without bit reordering.
    //
    
    DIBSECTION ds;
    if (GetObject(hbmSource, sizeof(ds), &ds) == 0) {
        DUIAssertForce("GDI+ requires DIB's for alpha-channel conversion");
        return NULL;
    }

    // Only single plane, 32bpp bitmaps can even contain an alpha channel.
    if ((ds.dsBm.bmPlanes) != 1 || (ds.dsBm.bmBitsPixel != 32)) {
        return NULL;
    }


    RGBQUAD * pvBits    = (RGBQUAD *) ds.dsBm.bmBits;
    DUIAssert(pvBits != NULL, "DIB must have valid bits");

    int nWidth  = ds.dsBm.bmWidth;
    int nHeight = ds.dsBm.bmHeight;
    int cPixels = nWidth * nHeight;
    if (!HasAlphaChannel(pvBits, cPixels)) {
        return NULL;
    }

    //
    // DIB's may go bottom up or top down, depending on the height.  This is a
    // bit of a pain, so we need to properly traverse them.
    //

    int cbDIBStride;
    BOOL fBottomUp = ds.dsBmih.biHeight >= 0;
    if (fBottomUp) {
        pvBits += (nHeight - 1) * nWidth;
        cbDIBStride = -(int) (nWidth * 2);
    } else {
        cbDIBStride = 0;
    }
    Gdiplus::ARGB * pc  = (Gdiplus::ARGB *) pvBits;
        


    //
    // Create a GDI+ bitmap to store the data in
    //

    Gdiplus::Bitmap * pgpbmpNew = new Gdiplus::Bitmap(nWidth, nHeight, nFormat);
    if (pgpbmpNew == NULL) {
        return NULL;  // Unable to allocate bitmap
    }


    //
    // Iterate over the DIB, copying the bits into the GDI+ bitmap
    //

    Gdiplus::BitmapData bd;
    Gdiplus::Rect rc(0, 0, nWidth, nHeight);
    if (pgpbmpNew->LockBits(&rc, Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeWrite, 
            nFormat, &bd) == Gdiplus::Ok) {

        BYTE *pRow = (BYTE*) bd.Scan0;
        DWORD *pCol;
        Gdiplus::ARGB c;

        switch (nFormat)
        {
        case PixelFormat32bppPARGB:
            {
                for (int y = 0; y < nHeight; y++, pRow += bd.Stride, pc += cbDIBStride) {
                    pCol = (DWORD *) pRow;
                    for (int x = 0; x < nWidth; x++, pCol++) {
                        //
                        // NOTE: This code is taken from GDI+ and is optimized 
                        // to premultiply a constant alpha level.
                        //

                        c = *pc++;
                        DWORD _aa000000 = c & 0xff000000;
                        BYTE bAlphaLevel = (BYTE) ((_aa000000) >> 24);
                        if (bAlphaLevel != 0x00000000) {
                            Gdiplus::ARGB _000000gg = (c >> 8) & 0x000000ff;
                            Gdiplus::ARGB _00rr00bb = (c & 0x00ff00ff);

                            Gdiplus::ARGB _0000gggg = _000000gg * bAlphaLevel + 0x00000080;
                            _0000gggg += ((_0000gggg >> 8) & 0x000000ff);

                            Gdiplus::ARGB _rrrrbbbb = _00rr00bb * bAlphaLevel + 0x00800080;
                            _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

                            c = _aa000000 | (_0000gggg & 0x0000ff00) | ((_rrrrbbbb >> 8) & 0x00ff00ff);
                        } else {
                            c = 0;
                        }

                        *pCol = c;
                    }
                }

                break;
            }
            
        case PixelFormat32bppARGB:
            {
                for (int y = 0; y < nHeight; y++, pRow += bd.Stride, pc += cbDIBStride) {
                    pCol = (DWORD *) pRow;
                    for (int x = 0; x < nWidth; x++) {
                        *pCol++ = *pc++;
                    }
                }
                break;
            }
        }

        pgpbmpNew->UnlockBits(&bd);
    }

    return pgpbmpNew;
}

#endif // GADGET_ENABLE_GDIPLUS


/////////////////////////////////////////////////////////////////////////////
// Color conversion

HBRUSH BrushFromEnumI(int c)
{
    if (IsSysColorEnum(c))
        return GetSysColorBrush(ConvertSysColorEnum(c));
    else
        return GetStdColorBrushI(c);
}

COLORREF ColorFromEnumI(int c)
{
    if (IsSysColorEnum(c))
        return GetSysColor(ConvertSysColorEnum(c));
    else
        return GetStdColorI(c);
}

#ifdef GADGET_ENABLE_GDIPLUS

Gdiplus::Color ColorFromEnumF(int c)
{
    if (IsSysColorEnum(c))
        return Convert(GetSysColor(ConvertSysColorEnum(c)));
    else
        return GetStdColorF(c);
}

#endif


/////////////////////////////////////////////////////////////////////////////
// Palettes

// Determine if primary device is palettized
bool IsPalette(HWND hWnd)
{
    HDC hDC = GetDC(hWnd);
    bool bPalette = (GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE) == RC_PALETTE;
    ReleaseDC(hWnd, hDC);

    return bPalette;
}

/*
// PAL file conversion, takes file name, pointer to RGBQUAD 256 element array, pointer to error buffer
HPALETTE PALToHPALETTE(LPWSTR pPALFile, bool bMemFile, DWORD dMemFileSize, LPRGBQUAD pRGBQuad, LPWSTR pError)
{
    HPALETTE hPalette = NULL;

    if (pRGBQuad)
        ZeroMemory(pRGBQuad, sizeof(RGBQUAD) * 256);

    HANDLE hFile = NULL;

    if (!bMemFile)
    {
        hFile = CreateFileW(pPALFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            if (pError)
                wcscpy(pError, L"Could not open file!");
            return NULL;
        }
    }

    // Load palette
    HMMIO hmmio;
    MMIOINFO info;

    ZeroMemory(&info, sizeof(MMIOINFO));
    if(!bMemFile)
        info.adwInfo[0] = (DWORD)(UINT_PTR)hFile;    // Use file
    else
    {
        info.pchBuffer = (HPSTR)pPALFile;  // Use memory palette data
        info.fccIOProc = FOURCC_MEM;
        info.cchBuffer = dMemFileSize;
    }
    hmmio = mmioOpen(NULL, &info, MMIO_READ | MMIO_ALLOCBUF);
    if (!hmmio)
    {
        if (pError)
            wcscpy(pError, L"Could not open file! (mmio)");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Process RIFF file
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('P','A','L',' ');
    if (mmioDescend(hmmio, &ckFile, NULL, MMIO_FINDRIFF) != 0)
    {
        if (pError)
            wcscpy(pError, L"Not a valid PAL file!");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Find the 'data' chunk
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(hmmio, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0)
    {
        if (pError)
            wcscpy(pError, L"Not a valid PAL file!");
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    int dSize = ckChunk.cksize;
    void* pData = HAlloc(dSize);
    mmioRead(hmmio, (HPSTR)pData, dSize);
    
    LOGPALETTE* pLogPal = (LOGPALETTE*)pData;
    if (pLogPal->palVersion != 0x300)
    {
        if (pError)
            wcscpy(pError, L"Invalid PAL file version (not 3.0)!");
        if (pData)
            HFree(pData);
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Check number of entires
    if (pLogPal->palNumEntries != 256)
    {   
        if (pError)
            wcscpy(pError, L"PAL file must have 256 color entries!");
        if (pData)
            HFree(pData);
        if (!bMemFile)
            CloseHandle(hFile);
        return NULL;
    }

    // Create palette
    hPalette = CreatePalette(pLogPal);

    // Copy palette entries to RGBQUAD array
    if (pRGBQuad)
    {
        for(int x = 0; x < 256; x++)
        {
            pRGBQuad[x].rgbRed = pLogPal->palPalEntry[x].peRed;
            pRGBQuad[x].rgbGreen = pLogPal->palPalEntry[x].peGreen;
            pRGBQuad[x].rgbBlue = pLogPal->palPalEntry[x].peBlue;
            pRGBQuad[x].rgbReserved = 0;
        }
    }

    // Done
    mmioClose(hmmio,MMIO_FHOPEN);
    HFree(pData);
    if(!bMemFile)
        CloseHandle(hFile);

    return hPalette;
}
*/


int PointToPixel(int nPoint)
{
    // Get DPI
    HDC hDC = GetDC(NULL);
    int nDPI = hDC ? GetDeviceCaps(hDC, LOGPIXELSY) : 0;
    if (hDC)
        ReleaseDC(NULL, hDC);

    // Convert
    return PointToPixel(nPoint, nDPI);
}

int RelPixToPixel(int nRelPix)
{
    // Get DPI
    HDC hDC = GetDC(NULL);
    int nDPI = hDC ? GetDeviceCaps(hDC, LOGPIXELSY) : 0;
    if (hDC)
        ReleaseDC(NULL, hDC);

    // Convert
    return RelPixToPixel(nRelPix, nDPI);
}

} // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_UTIL_STDAFX_H_INCLUDED
#define DUI_UTIL_STDAFX_H_INCLUDED

#pragma once

#include "CommonStdAfx.h"  // Include globally used headers

#endif // DUI_UTIL_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\stdafxutil.cpp ===
/*
 * stdafxutil.cpp: source file that includes just the standard includes
 * <project>.pch will be the pre-compiled header
 * stdafx.obj will contain the pre-compiled type information
 */

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duibasep.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIBASEP_H_INCLUDED
#define DUI_DUIBASEP_H_INCLUDED

#pragma once

#include "..\Engine\Base\Published.h"

#endif // DUI_DUIBASEP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\commonstdafx.h ===
/*
 * Common include for all stdafx.h project headers
 * This includes all common external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_COMMONSTDAFX_H_INCLUDED
#define DUI_COMMONSTDAFX_H_INCLUDED

#pragma once

// Engine warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function
#pragma warning (disable:4201)  // W4: Nameless struct/union may not be compiler portable

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// DirectUser headers

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS

#include <DUser.h>              // DirectUser
#include <DUserCtrl.h>
#ifdef GADGET_ENABLE_GDIPLUS
#include <RenderUtil.h>
#endif

#endif // DUI_COMMONSTDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\directuip.h ===
/*
 * DirectUI main header (private)
 */

#ifndef DUI_INC_DIRECTUIP_H_INCLUDED
#define DUI_INC_DIRECTUIP_H_INCLUDED

#pragma once

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>

#include "DUIBaseP.h"
#include "DUIUtilP.h"
#include "DUICoreP.h"
#include "DUIControlP.h"
#include "DUILayoutP.h"
#include "DUIParserP.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\engine\util\util.h ===
/*
 * Internal project dependencies
 *
 * This file provides a project-wide header that is included in all source
 * files specific to this project.  It is similar to a precompiled header,
 * but is designed for more rapidly changing headers.
 *
 * The primary purpose of this file is to determine which DirectUI
 * projects this project has direct access to instead of going through public
 * API's.  It is VERY IMPORTANT that this is as minimal as possible since
 * adding a new project unnecessarily reduces the benefit of project
 * partitioning.
 */

#ifndef DUI_UTIL_UTIL_H_INCLUDED
#define DUI_UTIL_UTIL_H_INCLUDED

#pragma once

#include <DUIBaseP.h>

#endif // DUI_UTIL_UTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duicorep.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUICOREP_H_INCLUDED
#define DUI_DUICOREP_H_INCLUDED

#pragma once

#include "..\Engine\Core\Published.h"

#endif // DUI_DUICOREP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duicontrolp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUICONTROLP_H_INCLUDED
#define DUI_DUICONTROLP_H_INCLUDED

#pragma once

#include "..\Engine\Control\Published.h"

#endif // DUI_DUICONTROLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duilayoutp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUILAYOUTP_H_INCLUDED
#define DUI_DUILAYOUTP_H_INCLUDED

#pragma once

#include "..\Engine\Layout\Published.h"

#endif // DUI_DUILAYOUTP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duiutilp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIUTILP_H_INCLUDED
#define DUI_DUIUTILP_H_INCLUDED

#pragma once

#include "..\Engine\Util\Published.h"

#endif // DUI_DUIUTILP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\duiparserp.h ===
/*
 * Central location for project specific headers for cross project inclusion
 */

#ifndef DUI_DUIPARSERP_H_INCLUDED
#define DUI_DUIPARSERP_H_INCLUDED

#pragma once

#include "..\Engine\Parser\Published.h"

#endif // DUI_DUIPARSERP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\public\directui.h ===
/*
 * DirectUI main header
 */

#ifndef DUI_INC_DIRECTUI_H_INCLUDED
#define DUI_INC_DIRECTUI_H_INCLUDED

#pragma once

// External dependencies

// The following is required to build using DirectUI

/******************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // TODO: Remove this when updated headers are available
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser
#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
*******************************************************/

// Base Published

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

// Util Published

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"

// Core Published

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

// Control Published

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

// Layout Published

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

// Parser Published

#include "duiparserobj.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\sources.inc ===
!IF 0

    Shared sources.inc file for Test projects.

!ENDIF

# Do not use NTBUILD's Warning.h pragmas, will treat all warnings as errors and use highest level (W4)
COMPILER_WARNINGS=

MSC_STDCALL=1
MSC_WARNING_LEVEL=/W4

USE_MSVCRT=1

INCLUDES=\
        $(WINDOWS_INC_PATH)\DUser;\
        $(SHELL_INC_PATH);\
        $(SDK_INC_PATH)\gdiplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\makefile.inc ===
#
# ARP.ui preprocessing
#

$(O)\arp.uipp: arp.ui
    cl /nologo /EP /I$(WINDOWS_INC_PATH)\DUser arp.ui > $(O)\arp.uipp

$(O)\arpstylestd.uipp: arpstylestd.ui
    cl /nologo /EP /I$(WINDOWS_INC_PATH)\DUser arpstylestd.ui > $(O)\arpstylestd.uipp

$(O)\arpstyletheme.uipp: arpstyletheme.ui
    cl /nologo /EP /I$(WINDOWS_INC_PATH)\DUser arpstyletheme.ui > $(O)\arpstyletheme.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\arp.h ===
// ARP.h
//

// Class definitions

// Frame

// Thread-safe API types
#define ARP_SETINSTALLEDITEMCOUNT             0   // pData is count
#define ARP_INSERTINSTALLEDITEM               1   // InsertItemData struct
#define ARP_INSERTPUBLISHEDITEM               2
#define ARP_SETPUBLISHEDFEEDBACKEMBPTY        3
#define ARP_POPULATECATEGORYCOMBO             4
#define ARP_PUBLISHEDLISTCOMPLETE             5

#define WM_ARPWORKERCOMPLETE                  WM_USER + 1024

// Thread-safe API structures
struct InsertItemData
{
    IInstalledApp* piia;
    IPublishedApp* pipa;    
    WCHAR pszTitle[MAX_PATH];
    WCHAR pszImage[MAX_PATH];
    int iIconIndex;
    ULONGLONG ullSize;
    FILETIME ftLastUsed;
    int iTimesUsed;    
    DWORD dwActions;
    bool bSupportInfo;
};

enum SortType
{
    SORT_NAME = 0,
    SORT_SIZE,
    SORT_TIMESUSED,
    SORT_LASTUSED,
};

class ARPFrame : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, bool bDblBuffer, OUT Element** ppElement);

    virtual void OnDestroy();

    // Initialize IDs and hold parser, called after contents are filled
    void Setup(Parser* pParser, UINT uiStartPane);

    // Thread-safe APIs (do any additional work on callers thread and then marshal)
    void SetInstalledItemCount(UINT cItems);
    void SortItemList();
    void SortList(int iNew, int iOld);
    CompareCallback GetCompareFunction();
    void InsertInstalledItem(IInstalledApp* piia);
    void InsertPublishedItem(IPublishedApp* piia);    
    void PopulateCategoryCombobox();
    SHELLAPPCATEGORYLIST* GetShellAppCategoryList() {return _psacl;}
    void SetShellAppCategoryList(SHELLAPPCATEGORYLIST* psacl) {_psacl = psacl;}
    LPCWSTR GetCurrentPublishedCategory();
    void FeedbackEmptyPublishedList();
    // Generic events
    virtual void OnEvent(Event* pEvent);
    virtual void OnKeyFocusMoved(Element* peFrom, Element* peTo);
    void OnPublishedListComplete();
    virtual void RestoreKeyFocus() { if(peLastFocused) peLastFocused->SetKeyFocus();}
    virtual bool CanSetFocus();
    bool GetPublishedComboFilled() {return _bPublishedComboFilled;}
    void SetPublishedComboFilled(bool bPublishedComboFilled) {_bPublishedComboFilled = bPublishedComboFilled;}
    bool GetPublishedListFilled () {return _bPublishedListFilled;}
    void SetPublishedListFilled (bool bPublishedListFilled) {_bPublishedListFilled = bPublishedListFilled;}
    bool IsChangeRestricted();
    virtual SetModalMode(bool ModalMode) { _bInModalMode = ModalMode;}
    HWND GetHostWindow() {if (_pnhh) return _pnhh->GetHWND(); return NULL;}        
    void SelectInstalledApp(IInstalledApp* piia);
    void UpdateInstalledItems();

    Parser* GetStyleParser() { return _pParserStyle; }

    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    ARPFrame() {_bPublishedListFilled = false; _bDeferredPublishedListFill = false; _bPublishedComboFilled = false; _psacl = NULL; _bInModalMode = FALSE; _uiStartPane = 0; _bSupportInfoRestricted = false; _bInDomain = true;}
    HRESULT Initialize(NativeHWNDHost* pnhh, bool fDlbBuffer);
    virtual ~ARPFrame();

    // Callee thread-safe invoke sink
    virtual void OnInvoke(UINT nType, void* pData);

private:
    NativeHWNDHost* _pnhh;

    // ARP parser (tree resources)
    Parser* _pParser;
    
    // ARP parser for styles (multiple UI files available for different looks)
    Parser* _pParserStyle;
    BOOL _fThemedStyle;
    HANDLE _arH[10];

    // ARP insttaled item list
    Selector* _peInstalledItemList;

    // ARP published item list
    Selector* _pePublishedItemList;

    // ARP Sort by Combobox
    Combobox* _peSortCombo;

    SHELLAPPCATEGORYLIST* _psacl;
    
    // ARP Published Category Combobox
    Combobox* _pePublishedCategory;
    int _curCategory;
    
    // ARP progress bar
    Progress* _peProgBar;

    Element* peFloater;
    Element* peLastFocused;

    // ARP Current Sort Type
    SortType CurrentSortType;

    bool _bPublishedListFilled;
    bool _bDeferredPublishedListFill;
    bool _bPublishedComboFilled;
    bool _bDoubleBuffer;
    bool _bInModalMode;
    bool _bSupportInfoRestricted;
    bool _bInDomain;
    UINT _uiStartPane;
    class ARPHelp* _pah;

    bool ShowSupportInfo(APPINFODATA *paid);
    void PrepareSupportInfo(Element* peHelp, APPINFODATA *paid);
    void ClearAppInfoData(APPINFODATA *paid);
    void RePopulatePublishedItemList();

    // Check for policies, apply as needed.
    void ApplyPolices();

    
public:

    // ARPFrame IDs (for identifying targets of events)
    static ATOM _idOptionList;
    static ATOM _idChange;
    static ATOM _idAddNew;
    static ATOM _idAddRmWin;
    static ATOM _idClose;
    static ATOM _idAddFromDisk;
    static ATOM _idAddFromMsft;
    static ATOM _idSortCombo;
    static ATOM _idCategoryCombo;
    static ATOM _idInstalledList; 
    static ATOM _idAddFromCDPane;
    static ATOM _idAddFromMSPane;
    static ATOM _idAddFromNetworkPane;

    // Helper thread handles
    static HANDLE hRePopPubItemListThread;
    static HANDLE hUpdInstalledItemsThread;
    
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

// Item
class ARPItem : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // Hierarchy
    void SortBy(int iNew, int iOld);

    // ARP item IDs
    static ATOM _idTitle;
    static ATOM _idIcon;
    static ATOM _idSize;
    static ATOM _idFreq;
    static ATOM _idLastUsed;
    static ATOM _idExInfo;
    static ATOM _idInstalled;    
    static ATOM _idChgRm;
    static ATOM _idChg;
    static ATOM _idRm;
    static ATOM _idAdd;    
    static ATOM _idSupInfo;
    static ATOM _idItemAction;
    static ATOM _idRow[3];

    IInstalledApp* _piia;
    IPublishedApp* _pipa;
    ARPFrame*    _paf;
    UINT           _iTimesUsed;
    FILETIME       _ftLastUsed;
    ULONGLONG      _ullSize;

    ARPItem() { _piia = NULL; _pipa = NULL; _paf = NULL;}
    HRESULT Initialize();
    virtual ~ARPItem();
};

// Help box
class ARPHelp : public HWNDElement, public Proxy
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement);
    
    NativeHWNDHost* GetHost() {return _pnhh;}

    virtual void OnDestroy();

    // Generic events
    virtual void OnEvent(Event* pEvent);
    void ARPHelp::SetDefaultFocus();

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPHelp() {_paf =  NULL;}
    HRESULT Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer);
    virtual ~ARPHelp();

private:
    NativeHWNDHost* _pnhh;
    ARPFrame* _paf;
    HRESULT Initialize();
};

class ARPSupportItem : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // Property definitions
    static PropertyInfo* URLProp;

    // Quick property accessors
    const LPWSTR GetURL(Value** ppv)                   DUIQuickGetterInd(GetString(), URL, Specified)
    HRESULT SetURL(LPCWSTR v)                          DUIQuickSetter(CreateString(v), URL)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    IInstalledApp* _piia;

    ARPSupportItem() { }
    HRESULT Initialize();    
    virtual ~ARPSupportItem() { }

private:
    Element* GetChild(UINT index);
};

class ARPSelector: public Selector
{
public:
    static HRESULT Create(OUT Element** ppElement);
   
    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    virtual void OnKeyFocusMoved(Element *peFrom, Element *peTo) {Element::OnKeyFocusMoved(peFrom, peTo);}
};

class ARPParser : public Parser
{
public:
    static HRESULT Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    HRESULT Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB);

    virtual Value* GetSheet(LPCWSTR pszResID);

private:
    ARPFrame* _paf;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\inc\public\directuipp.h ===
/*
 * DirectUI UI file pre-process header
 */

#ifndef DUI_INC_DIRECTUIPP_H_INCLUDED
#define DUI_INC_DIRECTUIPP_H_INCLUDED

/*
 * NOTE: Various system #defines are replicated here for 2 reasons:
 *    1) Preprocessing a file like winuser.h results in a huge UIPP file
 *    2) The resultant UIPP file cannot be parsed by DUI due to function prototypes
 */


/*
 * SYSMETRIC: Retrieves system dependent information (integer values)
 *
 * Can use GetSystemMetrics() SM_* values plus DirectUI-specific values
 * as argument
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// GetSystemMetrics()

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_CXFIXEDFRAME         SM_CXDLGFRAME
#define SM_CYFIXEDFRAME         SM_CYDLGFRAME
#define SM_CXSIZEFRAME          SM_CXFRAME
#define SM_CYSIZEFRAME          SM_CYFRAME
#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#define SM_CMETRICS             83

#endif // DIRECTUIPP_IGNORESYSDEF

#define DSM_NCMAX               -1
#define DSM_CAPTIONFONTSIZE     -1
#define DSM_CAPTIONFONTWEIGHT   -2
#define DSM_CAPTIONFONTSTYLE    -3
#define DSM_MENUFONTSIZE        -4
#define DSM_MENUFONTWEIGHT      -5
#define DSM_MENUFONTSTYLE       -6
#define DSM_MESSAGEFONTSIZE     -7
#define DSM_MESSAGEFONTWEIGHT   -8
#define DSM_MESSAGEFONTSTYLE    -9
#define DSM_SMCAPTIONFONTSIZE   -10
#define DSM_SMCAPTIONFONTWEIGHT -11
#define DSM_SMCAPTIONFONTSTYLE  -12
#define DSM_STATUSFONTSIZE      -13
#define DSM_STATUSFONTWEIGHT    -14
#define DSM_STATUSFONTSTYLE     -15
#define DSM_NCMIN               -15

#define DSM_ICMAX               -16
#define DSM_ICONFONTSIZE        -16
#define DSM_ICONFONTWEIGHT      -17
#define DSM_ICONFONTSTYLE       -18
#define DSM_ICMIN               -18


/*
 * SYSMETRICSTR: Retrieves system dependent information (string values)
 *
 * Can use DirectUI-specific values as argument
 */

#define DSMS_NCMIN              1
#define DSMS_CAPTIONFONTFACE    1
#define DSMS_MENUFONTFACE       2
#define DSMS_MESSAGEFONTFACE    3
#define DSMS_SMCAPTIONFONTFACE  4
#define DSMS_STATUSFONTFACE     5
#define DSMS_NCMAX              5

#define DSMS_ICMIN              6
#define DSMS_ICONFONTFACE       6
#define DSMS_ICMAX              6


#ifndef DIRECTUIPP_IGNORESYSDEF

/*
 * DrawFrameControl
 */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

#endif // DIRECTUIPP_IGNORESYSDEF

/*
 * Themes Support (from TmSchema.h)
 *
 * Can't include UxTheme headers directly since they use 'enum' 
 * instead of #define. So, the preprocessor won't resolve to numbers.
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// Button parts
#define BP_PUSHBUTTON           1
#define BP_RADIOBUTTON          2
#define BP_GROUPBOX             3
#define BP_CHECKBOX             4
#define BP_USERBUTTON           5

// PushButton states
#define PBS_NORMAL              1
#define PBS_HOT                 2
#define PBS_PRESSED             3
#define PBS_DISABLED            4
#define PBS_DEFAULTED           5

// RadioButton states
#define RBS_UNCHECKEDNORMAL     1
#define RBS_UNCHECKEDHOT        2
#define RBS_UNCHECKEDPRESSED    3
#define RBS_UNCHECKEDDISABLED   4
#define RBS_CHECKEDNORMAL       5
#define RBS_CHECKEDHOT          6
#define RBS_CHECKEDPRESSED      7
#define RBS_CHECKEDDISABLED     8

// CheckBox states
#define CBS_UNCHECKEDNORMAL     1
#define CBS_UNCHECKEDHOT        2
#define CBS_UNCHECKEDPRESSED    3
#define CBS_UNCHECKEDDISABLED   4
#define CBS_CHECKEDNORMAL       5
#define CBS_CHECKEDHOT          6
#define CBS_CHECKEDPRESSED      7
#define CBS_CHECKEDDISABLED     8
#define CBS_MIXEDNORMAL         9
#define CBS_MIXEDHOT            10
#define CBS_MIXEDPRESSED        11
#define CBS_MIXEDDISABLED       12

// ScrollBar parts
#define SBP_ARROWBTN            1
#define SBP_THUMBBTNHORZ        2
#define SBP_THUMBBTNVERT        3
#define SBP_LOWERTRACKHORZ      4
#define SBP_UPPERTRACKHORZ      5
#define SBP_LOWERTRACKVERT      6
#define SBP_UPPERTRACKVERT      7
#define SBP_GRIPPERHORZ         8
#define SBP_GRIPPERVERT         9
#define SBP_SIZEBOX             10

// ArrowBtn states
#define ABS_UPNORMAL            1
#define ABS_UPHOT               2
#define ABS_UPPRESSED           3
#define ABS_UPDISABLED          4
#define ABS_DOWNNORMAL          5
#define ABS_DOWNHOT             6
#define ABS_DOWNPRESSED         7
#define ABS_DOWNDISABLED        8    
#define ABS_LEFTNORMAL          9
#define ABS_LEFTHOT             10
#define ABS_LEFTPRESSED         11
#define ABS_LEFTDISABLED        12
#define ABS_RIGHTNORMAL         13
#define ABS_RIGHTHOT            14
#define ABS_RIGHTPRESSED        15
#define ABS_RIGHTDISABLED       16

// ScrollBar states
#define SCRBS_NORMAL            1
#define SCRBS_HOT               2
#define SCRBS_PRESSED           3
#define SCRBS_DISABLED          4

// SizeBox states
#define SZB_RIGHTALIGN          1
#define SZB_LEFTALIGN           2

// Toolbar parts
#define TP_BUTTON               1
#define TP_DROPDOWNBUTTON       2
#define TP_SPLITBUTTON          3
#define TP_SPLITBUTTONDROPDOWN  4
#define TP_SEPARATOR            5
#define TP_SEPARATORVERT        6

// Toolbar states
#define TS_NORMAL               1
#define TS_HOT                  2
#define TS_PRESSED              3
#define TS_DISABLED             4
#define TS_CHECKED              5
#define TS_HOTCHECKED           6

#endif // DIRECTUIPP_IGNORESYSDEF

#endif // DUI_INC_DIRECTUIPP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ARP.rc
//
#define IDS_FONTFACE0                        1
#define IDS_FONTFACE1                        2
#define IDS_FONTFACE2                        3
#define IDS_CLOSE                            4
#define IDS_CHANGEORREMOVEP                  5
#define IDS_ADDPROGRAMS                      6
#define IDS_ADDREMOVEWINDOWS                 7
#define IDS_CURRENTINSTALLED                 8 
#define IDS_ADDFROMCD                        9
#define IDS_CDHELP                          10
#define IDS_CDORFLOPPY                      11 
#define IDS_ADDFROMMS                       12
#define IDS_ADDWUPDATEHELP                  13
#define IDS_WINDOWSUPDATE                   14
#define IDS_LOADING                         15
#define IDS_SUPPORT                         16
#define IDS_CHANGE                          17
#define IDS_REMOVE                          18
#define IDS_CHANGEORREMOVE                  19
#define IDS_ADD                             20
#define IDS_SIZE                            21
#define IDS_SIZEHELP                        22
#define IDS_FREQUENCY                       23
#define IDS_FREQUENCYHELP                   24
#define IDS_FREQUENCYHELP1                  25
#define IDS_FREQUENCYHELP2                  26
#define IDS_TECHSUPPORT                     27
#define IDS_PUBLISHER                       28
#define IDS_VERSION                         29
#define IDS_CONTACT                         30
#define IDS_SUPPORTINFO                     31
#define IDS_README                          32
#define IDS_UPDATE                          33
#define IDS_PRODUCTID                       34
#define IDS_REGCOMPANY                      35
#define IDS_REGOWNER                        36
#define IDS_COMMENTS                        37
#define IDS_REPAIRDESC                      38
#define IDS_REPAIR                          39
#define IDS_SORTBY                          40
#define IDS_GATEGORY                        41 
#define IDS_ADDFROMNETWORK                  42
#define IDS_NAME                            43
#define IDS_DATELASTUSED                    44
#define IDS_ALLCATEGORIES                   45
#define IDS_HELPCHANGEORREMOVE              46
#define IDS_HELPCHANGEREMOVE                47
#define IDS_SIZEFORMAT1                     48
#define IDS_SIZEFORMAT2                     49
#define IDS_USEDREARELY                     50
#define IDS_USEDOCCASIONALLY                51
#define IDS_USEDFREQUENTLY                  52
#define IDS_LASTUSEDFORMAT                  53
#define IDS_ADDHELP                         54          
#define IDS_INSTALLED                       55
#define IDS_ARPTITLE                        56
#define IDS_WAITFEEDBACK                    57
#define IDS_EMPTYFEEDBACK                   58
#define IDS_DEFINITION                      59
#define IDS_SIZELABEL                       60
#define IDS_FREQUENCYLABEL                  61
#define IDS_LASTUSEDLABEL                   62
#define IDS_SIZETITLE                       63
#define IDS_FREQUENCYTITLE                  64
#define IDS_SUPPORTTITLE                    65

#define IDB_PROGRESS                       100
#define IDB_ADDRESSBKGRND                  101
#define IDB_ARP0                           102
#define IDB_ARP1                           103
#define IDB_ARP2                           104
#define IDB_ARP3                           105
#define IDB_ARP4                           106
#define IDB_ARPX                           107
              
#define IDR_ARP                            300
#define IDR_ARPSTYLESTD                    301
#define IDR_ARPSTYLETHEME                  302

#define IDI_ARP                            400

// hTheme identification from within the resource
#define BUTTONHTHEME                       1
#define SCROLLBARHTHEME                    2
#define TOOLBARHTHEME                      3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\shappmgrp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for shappmgrp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* Verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shappmgrp_h__
#define __shappmgrp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IADCCtl_FWD_DEFINED__
#define __IADCCtl_FWD_DEFINED__
typedef interface IADCCtl IADCCtl;
#endif 	/* __IADCCtl_FWD_DEFINED__ */


#ifndef __ADCCtl_FWD_DEFINED__
#define __ADCCtl_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADCCtl ADCCtl;
#else
typedef struct ADCCtl ADCCtl;
#endif /* __cplusplus */

#endif 	/* __ADCCtl_FWD_DEFINED__ */


#ifndef __IInstalledApp_FWD_DEFINED__
#define __IInstalledApp_FWD_DEFINED__
typedef interface IInstalledApp IInstalledApp;
#endif 	/* __IInstalledApp_FWD_DEFINED__ */


#ifndef __IEnumInstalledApps_FWD_DEFINED__
#define __IEnumInstalledApps_FWD_DEFINED__
typedef interface IEnumInstalledApps IEnumInstalledApps;
#endif 	/* __IEnumInstalledApps_FWD_DEFINED__ */


#ifndef __EnumInstalledApps_FWD_DEFINED__
#define __EnumInstalledApps_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInstalledApps EnumInstalledApps;
#else
typedef struct EnumInstalledApps EnumInstalledApps;
#endif /* __cplusplus */

#endif 	/* __EnumInstalledApps_FWD_DEFINED__ */


#ifndef __IShellAppManager_FWD_DEFINED__
#define __IShellAppManager_FWD_DEFINED__
typedef interface IShellAppManager IShellAppManager;
#endif 	/* __IShellAppManager_FWD_DEFINED__ */


#ifndef __ShellAppManager_FWD_DEFINED__
#define __ShellAppManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellAppManager ShellAppManager;
#else
typedef struct ShellAppManager ShellAppManager;
#endif /* __cplusplus */

#endif 	/* __ShellAppManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "shappmgr.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shappmgrp_0000 */
/* [local] */ 

#ifndef _SHAPPMGRP_H_
#define _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_s_ifspec;


#ifndef __SHAPPMGRPLib_LIBRARY_DEFINED__
#define __SHAPPMGRPLib_LIBRARY_DEFINED__

/* library SHAPPMGRPLib */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_SHAPPMGRPLib;

#ifndef __IADCCtl_INTERFACE_DEFINED__
#define __IADCCtl_INTERFACE_DEFINED__

/* interface IADCCtl */
/* [dual][object][oleautomation][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IADCCtl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3964D99F-AC96-11D1-9851-00C04FD91972")
    IADCCtl : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dirty( 
            /* [in] */ VARIANT_BOOL bDirty) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dirty( 
            /* [retval][out] */ VARIANT_BOOL *pbDirty) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Category( 
            /* [in] */ BSTR bstrCategory) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ BSTR *pbstrCategory) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Sort( 
            /* [in] */ BSTR bstrSortExpr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Sort( 
            /* [retval][out] */ BSTR *pbstrSortExpr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Forcex86( 
            /* [in] */ VARIANT_BOOL bForce) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Forcex86( 
            /* [retval][out] */ VARIANT_BOOL *pbForce) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowPostSetup( 
            /* [retval][out] */ VARIANT_BOOL *pbShow) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDomain( 
            /* [in] */ VARIANT_BOOL bOnDomain) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OnDomain( 
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCategory( 
            /* [retval][out] */ BSTR *pbstrCategory) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE msDataSourceObject( 
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE addDataSourceListener( 
            /* [in] */ IUnknown *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( 
            BSTR bstrQualifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADCCtlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADCCtl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADCCtl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADCCtl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADCCtl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADCCtl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dirty )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bDirty);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbDirty);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrCategory);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sort )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrSortExpr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sort )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrSortExpr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Forcex86 )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bForce);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forcex86 )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbForce);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPostSetup )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbShow);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDomain )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bOnDomain);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OnDomain )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultCategory )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *msDataSourceObject )( 
            IADCCtl * This,
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *addDataSourceListener )( 
            IADCCtl * This,
            /* [in] */ IUnknown *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IADCCtl * This,
            BSTR bstrQualifier);
        
        HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IADCCtl * This,
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord);
        
        END_INTERFACE
    } IADCCtlVtbl;

    interface IADCCtl
    {
        CONST_VTBL struct IADCCtlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADCCtl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADCCtl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADCCtl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADCCtl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADCCtl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADCCtl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADCCtl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADCCtl_put_Dirty(This,bDirty)	\
    (This)->lpVtbl -> put_Dirty(This,bDirty)

#define IADCCtl_get_Dirty(This,pbDirty)	\
    (This)->lpVtbl -> get_Dirty(This,pbDirty)

#define IADCCtl_put_Category(This,bstrCategory)	\
    (This)->lpVtbl -> put_Category(This,bstrCategory)

#define IADCCtl_get_Category(This,pbstrCategory)	\
    (This)->lpVtbl -> get_Category(This,pbstrCategory)

#define IADCCtl_put_Sort(This,bstrSortExpr)	\
    (This)->lpVtbl -> put_Sort(This,bstrSortExpr)

#define IADCCtl_get_Sort(This,pbstrSortExpr)	\
    (This)->lpVtbl -> get_Sort(This,pbstrSortExpr)

#define IADCCtl_put_Forcex86(This,bForce)	\
    (This)->lpVtbl -> put_Forcex86(This,bForce)

#define IADCCtl_get_Forcex86(This,pbForce)	\
    (This)->lpVtbl -> get_Forcex86(This,pbForce)

#define IADCCtl_get_ShowPostSetup(This,pbShow)	\
    (This)->lpVtbl -> get_ShowPostSetup(This,pbShow)

#define IADCCtl_put_OnDomain(This,bOnDomain)	\
    (This)->lpVtbl -> put_OnDomain(This,bOnDomain)

#define IADCCtl_get_OnDomain(This,pbOnDomain)	\
    (This)->lpVtbl -> get_OnDomain(This,pbOnDomain)

#define IADCCtl_get_DefaultCategory(This,pbstrCategory)	\
    (This)->lpVtbl -> get_DefaultCategory(This,pbstrCategory)

#define IADCCtl_msDataSourceObject(This,qualifier,ppUnk)	\
    (This)->lpVtbl -> msDataSourceObject(This,qualifier,ppUnk)

#define IADCCtl_addDataSourceListener(This,pEvent)	\
    (This)->lpVtbl -> addDataSourceListener(This,pEvent)

#define IADCCtl_Reset(This,bstrQualifier)	\
    (This)->lpVtbl -> Reset(This,bstrQualifier)

#define IADCCtl_IsRestricted(This,bstrPolicy,pbRestricted)	\
    (This)->lpVtbl -> IsRestricted(This,bstrPolicy,pbRestricted)

#define IADCCtl_Exec(This,bstrQualifier,bstrCmd,nRecord)	\
    (This)->lpVtbl -> Exec(This,bstrQualifier,bstrCmd,nRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Dirty_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bDirty);


void __RPC_STUB IADCCtl_put_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Dirty_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbDirty);


void __RPC_STUB IADCCtl_get_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Category_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrCategory);


void __RPC_STUB IADCCtl_put_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Category_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Sort_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrSortExpr);


void __RPC_STUB IADCCtl_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Sort_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrSortExpr);


void __RPC_STUB IADCCtl_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Forcex86_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bForce);


void __RPC_STUB IADCCtl_put_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Forcex86_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbForce);


void __RPC_STUB IADCCtl_get_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_ShowPostSetup_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbShow);


void __RPC_STUB IADCCtl_get_ShowPostSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_OnDomain_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bOnDomain);


void __RPC_STUB IADCCtl_put_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_OnDomain_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbOnDomain);


void __RPC_STUB IADCCtl_get_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_DefaultCategory_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_DefaultCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_msDataSourceObject_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR qualifier,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IADCCtl_msDataSourceObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_addDataSourceListener_Proxy( 
    IADCCtl * This,
    /* [in] */ IUnknown *pEvent);


void __RPC_STUB IADCCtl_addDataSourceListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Reset_Proxy( 
    IADCCtl * This,
    BSTR bstrQualifier);


void __RPC_STUB IADCCtl_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_IsRestricted_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrPolicy,
    /* [retval][out] */ VARIANT_BOOL *pbRestricted);


void __RPC_STUB IADCCtl_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Exec_Proxy( 
    IADCCtl * This,
    BSTR bstrQualifier,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ LONG nRecord);


void __RPC_STUB IADCCtl_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADCCtl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ADCCtl;

#ifdef __cplusplus

class DECLSPEC_UUID("3964D9A0-AC96-11D1-9851-00C04FD91972")
ADCCtl;
#endif

#ifndef __IInstalledApp_INTERFACE_DEFINED__
#define __IInstalledApp_INTERFACE_DEFINED__

/* interface IInstalledApp */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IInstalledApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BC752DF-9046-11D1-B8B3-006008059382")
    IInstalledApp : public IShellApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Uninstall( 
            HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Modify( 
            HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repair( 
            /* [in] */ BOOL bReinstall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upgrade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstalledAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstalledApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstalledApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstalledApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )( 
            IInstalledApp * This,
            /* [out][in] */ PAPPINFODATA pai);
        
        HRESULT ( STDMETHODCALLTYPE *GetPossibleActions )( 
            IInstalledApp * This,
            /* [out] */ DWORD *pdwActions);
        
        HRESULT ( STDMETHODCALLTYPE *GetSlowAppInfo )( 
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedSlowAppInfo )( 
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE *IsInstalled )( 
            IInstalledApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            IInstalledApp * This,
            HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Modify )( 
            IInstalledApp * This,
            HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *Repair )( 
            IInstalledApp * This,
            /* [in] */ BOOL bReinstall);
        
        HRESULT ( STDMETHODCALLTYPE *Upgrade )( 
            IInstalledApp * This);
        
        END_INTERFACE
    } IInstalledAppVtbl;

    interface IInstalledApp
    {
        CONST_VTBL struct IInstalledAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstalledApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstalledApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstalledApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstalledApp_GetAppInfo(This,pai)	\
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IInstalledApp_GetPossibleActions(This,pdwActions)	\
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IInstalledApp_GetSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IInstalledApp_GetCachedSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IInstalledApp_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)


#define IInstalledApp_Uninstall(This,hwnd)	\
    (This)->lpVtbl -> Uninstall(This,hwnd)

#define IInstalledApp_Modify(This,hwndParent)	\
    (This)->lpVtbl -> Modify(This,hwndParent)

#define IInstalledApp_Repair(This,bReinstall)	\
    (This)->lpVtbl -> Repair(This,bReinstall)

#define IInstalledApp_Upgrade(This)	\
    (This)->lpVtbl -> Upgrade(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstalledApp_Uninstall_Proxy( 
    IInstalledApp * This,
    HWND hwnd);


void __RPC_STUB IInstalledApp_Uninstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Modify_Proxy( 
    IInstalledApp * This,
    HWND hwndParent);


void __RPC_STUB IInstalledApp_Modify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Repair_Proxy( 
    IInstalledApp * This,
    /* [in] */ BOOL bReinstall);


void __RPC_STUB IInstalledApp_Repair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Upgrade_Proxy( 
    IInstalledApp * This);


void __RPC_STUB IInstalledApp_Upgrade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstalledApp_INTERFACE_DEFINED__ */


#ifndef __IEnumInstalledApps_INTERFACE_DEFINED__
#define __IEnumInstalledApps_INTERFACE_DEFINED__

/* interface IEnumInstalledApps */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumInstalledApps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BC752E1-9046-11D1-B8B3-006008059382")
    IEnumInstalledApps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IInstalledApp **pia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInstalledAppsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInstalledApps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInstalledApps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInstalledApps * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInstalledApps * This,
            /* [out] */ IInstalledApp **pia);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInstalledApps * This);
        
        END_INTERFACE
    } IEnumInstalledAppsVtbl;

    interface IEnumInstalledApps
    {
        CONST_VTBL struct IEnumInstalledAppsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInstalledApps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInstalledApps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInstalledApps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInstalledApps_Next(This,pia)	\
    (This)->lpVtbl -> Next(This,pia)

#define IEnumInstalledApps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Next_Proxy( 
    IEnumInstalledApps * This,
    /* [out] */ IInstalledApp **pia);


void __RPC_STUB IEnumInstalledApps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Reset_Proxy( 
    IEnumInstalledApps * This);


void __RPC_STUB IEnumInstalledApps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInstalledApps_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_EnumInstalledApps;

#ifdef __cplusplus

class DECLSPEC_UUID("0B124F8F-91F0-11D1-B8B5-006008059382")
EnumInstalledApps;
#endif

#ifndef __IShellAppManager_INTERFACE_DEFINED__
#define __IShellAppManager_INTERFACE_DEFINED__

/* interface IShellAppManager */
/* [object][helpstring][uuid] */ 

typedef struct _ShellAppCategory
    {
    LPWSTR pszCategory;
    UINT idCategory;
    } 	SHELLAPPCATEGORY;

typedef struct _ShellAppCategory *PSHELLAPPCATEGORY;

typedef struct _ShellAppCategoryList
    {
    UINT cCategories;
    SHELLAPPCATEGORY *pCategory;
    } 	SHELLAPPCATEGORYLIST;

typedef struct _ShellAppCategoryList *PSHELLAPPCATEGORYLIST;


EXTERN_C const IID IID_IShellAppManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("352EC2B8-8B9A-11D1-B8AE-006008059382")
    IShellAppManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberofInstalledApps( 
            DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInstalledApps( 
            IEnumInstalledApps **peia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublishedAppCategories( 
            PSHELLAPPCATEGORYLIST pCategoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPublishedApps( 
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallFromFloppyOrCDROM( 
            HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellAppManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellAppManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellAppManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellAppManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberofInstalledApps )( 
            IShellAppManager * This,
            DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInstalledApps )( 
            IShellAppManager * This,
            IEnumInstalledApps **peia);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublishedAppCategories )( 
            IShellAppManager * This,
            PSHELLAPPCATEGORYLIST pCategoryList);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPublishedApps )( 
            IShellAppManager * This,
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa);
        
        HRESULT ( STDMETHODCALLTYPE *InstallFromFloppyOrCDROM )( 
            IShellAppManager * This,
            HWND hwndParent);
        
        END_INTERFACE
    } IShellAppManagerVtbl;

    interface IShellAppManager
    {
        CONST_VTBL struct IShellAppManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellAppManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellAppManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellAppManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellAppManager_GetNumberofInstalledApps(This,pdwResult)	\
    (This)->lpVtbl -> GetNumberofInstalledApps(This,pdwResult)

#define IShellAppManager_EnumInstalledApps(This,peia)	\
    (This)->lpVtbl -> EnumInstalledApps(This,peia)

#define IShellAppManager_GetPublishedAppCategories(This,pCategoryList)	\
    (This)->lpVtbl -> GetPublishedAppCategories(This,pCategoryList)

#define IShellAppManager_EnumPublishedApps(This,pszCategory,ppepa)	\
    (This)->lpVtbl -> EnumPublishedApps(This,pszCategory,ppepa)

#define IShellAppManager_InstallFromFloppyOrCDROM(This,hwndParent)	\
    (This)->lpVtbl -> InstallFromFloppyOrCDROM(This,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellAppManager_GetNumberofInstalledApps_Proxy( 
    IShellAppManager * This,
    DWORD *pdwResult);


void __RPC_STUB IShellAppManager_GetNumberofInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumInstalledApps_Proxy( 
    IShellAppManager * This,
    IEnumInstalledApps **peia);


void __RPC_STUB IShellAppManager_EnumInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_GetPublishedAppCategories_Proxy( 
    IShellAppManager * This,
    PSHELLAPPCATEGORYLIST pCategoryList);


void __RPC_STUB IShellAppManager_GetPublishedAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumPublishedApps_Proxy( 
    IShellAppManager * This,
    LPCWSTR pszCategory,
    IEnumPublishedApps **ppepa);


void __RPC_STUB IShellAppManager_EnumPublishedApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_InstallFromFloppyOrCDROM_Proxy( 
    IShellAppManager * This,
    HWND hwndParent);


void __RPC_STUB IShellAppManager_InstallFromFloppyOrCDROM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellAppManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellAppManager;

#ifdef __cplusplus

class DECLSPEC_UUID("352EC2B7-8B9A-11D1-B8AE-006008059382")
ShellAppManager;
#endif
#endif /* __SHAPPMGRPLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shappmgrp_0257 */
/* [local] */ 

#endif // _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0257_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\arp.cpp ===
// ARP.cpp : Add Remove Programs
//

#include "stdafx.h"
#include "resource.h"

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);
UsingDUIClass(Thumb);
UsingDUIClass(ScrollBar);
UsingDUIClass(Viewer);
UsingDUIClass(Selector);
UsingDUIClass(Progress);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Combobox);

#include "shappmgrp.h"

#include "arp.h"

#define HRCHK(r)  if (FAILED(r)) goto Cleanup;

// Primary thread run flag
bool g_fRun = true;

// Appliction shutting down after run flag goes false
bool g_fAppShuttingDown = false;

HINSTANCE g_hInstance = NULL;

inline void StrFree(LPWSTR psz)
{
    if (psz)
        CoTaskMemFree(psz);
}

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

////////////////////////////////////////////////////////
// ARPFrame class
////////////////////////////////////////////////////////

// ARPFrame IDs (for identifying targets of events)
ATOM ARPFrame::_idOptionList = 0;
ATOM ARPFrame::_idChange = 0;
ATOM ARPFrame::_idAddNew = 0;
ATOM ARPFrame::_idAddRmWin = 0;
ATOM ARPFrame::_idClose = 0;
ATOM ARPFrame::_idAddFromDisk = 0;
ATOM ARPFrame::_idAddFromMsft = 0;
ATOM ARPFrame::_idSortCombo = 0;
ATOM ARPFrame::_idCategoryCombo = 0;
ATOM ARPFrame::_idInstalledList = 0;
ATOM ARPFrame::_idAddFromCDPane = 0;
ATOM ARPFrame::_idAddFromMSPane = 0;
ATOM ARPFrame::_idAddFromNetworkPane = 0;

HANDLE ARPFrame::hRePopPubItemListThread = NULL;
HANDLE ARPFrame::hUpdInstalledItemsThread = NULL;

ARPFrame::~ARPFrame()
{
    UINT i;

    if (_psacl)
    {
        for (i = 0; i < _psacl->cCategories; i++)
        {
           if (_psacl->pCategory[i].pszCategory)
           {
               StrFree(_psacl->pCategory[i].pszCategory);
           }
        }
        delete _psacl;
        _psacl = NULL;
    }

    if (_pParserStyle)
        _pParserStyle->Destroy();
    
    // Close theme handles (if applicable)
    if (_arH[BUTTONHTHEME])  // Button
        CloseThemeData(_arH[BUTTONHTHEME]);
    if (_arH[SCROLLBARHTHEME])  // Scrollbar
        CloseThemeData(_arH[SCROLLBARHTHEME]);
    if (_arH[TOOLBARHTHEME])  // Toolbar
        CloseThemeData(_arH[TOOLBARHTHEME]);
}

HRESULT ARPFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPFrame::Create(NativeHWNDHost* pnhh, bool fDblBuffer, OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPFrame* paf = HNew<ARPFrame>();
    if (!paf)
        return E_OUTOFMEMORY;

    HRESULT hr = paf->Initialize(pnhh, fDblBuffer);
    if (FAILED(hr))
    {
        paf->Destroy();
        return hr;
    }

    *ppElement = paf;

    return S_OK;
}

HRESULT ARPFrame::Initialize(NativeHWNDHost* pnhh, bool fDblBuffer)
{
    // Initialize
    _pnhh = pnhh;
    _bDoubleBuffer = fDblBuffer;
    _pParserStyle = NULL;
    ZeroMemory(_arH, sizeof(_arH));
    _fThemedStyle = FALSE;

    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), fDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    CurrentSortType = SORT_NAME;
    
    // Store style and theme information
    _fThemedStyle = IsAppThemed();
    if (_fThemedStyle)
    {
        // Populate handle list for theme style parsing
        _arH[0] = g_hInstance; // Default HINSTANCE
        _arH[BUTTONHTHEME] = OpenThemeData(GetHWND(), L"Button");
        _arH[SCROLLBARHTHEME] = OpenThemeData(GetHWND(), L"Scrollbar");
        _arH[TOOLBARHTHEME] = OpenThemeData(GetHWND(), L"Toolbar");
        //SetWindowTheme(hwndTB, L"Placesbar", NULL);
        
        hr = Parser::Create(IDR_ARPSTYLETHEME, _arH, ARPParseError, &_pParserStyle);
    }
    else
    {
        hr = Parser::Create(IDR_ARPSTYLESTD, g_hInstance, ARPParseError, &_pParserStyle);
    }

    if (FAILED(hr) || !_pParserStyle || _pParserStyle->WasParseError())
        return hr;

    return S_OK;
}

extern "C" DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy);
extern "C" bool _cdecl ARPIsOnDomain();

// Initialize IDs and hold parser, called after contents are filled
void ARPFrame::Setup(Parser* pParser, UINT uiStartPane)
{
    WCHAR szTemp[1024];
    
    _pParser = pParser;
    if (uiStartPane <= 2)
    {
        _uiStartPane = uiStartPane;
    }

    // Initialize ID cache
    _idOptionList = StrToID(L"optionlist");
    _idChange = StrToID(L"change");
    _idAddNew = StrToID(L"addnew");
    _idAddRmWin = StrToID(L"addrmwin");
    _idClose = StrToID(L"close");
    _idAddFromDisk = StrToID(L"addfromdisk");
    _idAddFromMsft = StrToID(L"addfrommsft");
    _idSortCombo = StrToID(L"sortcombo");
    _idCategoryCombo = StrToID(L"categorycombo");
    _idInstalledList = StrToID(L"installeditemlist");
    _idAddFromCDPane = StrToID(L"addfromCDPane");
    _idAddFromMSPane = StrToID(L"addfromMSpane");
    _idAddFromNetworkPane = StrToID(L"addfromNetworkpane");    

    DUIAssertNoMsg(_idOptionList);

    // Find children
    _peInstalledItemList = (Selector*)FindDescendent(StrToID(L"installeditemlist"));
    _pePublishedItemList = (Selector*)FindDescendent(StrToID(L"publisheditemlist"));
    _peProgBar = (Progress*)FindDescendent(StrToID(L"progbar"));
    _peSortCombo = (Combobox*)FindDescendent(StrToID(L"sortcombo"));
    _pePublishedCategory = (Combobox*)FindDescendent(StrToID(L"categorycombo"));

    
    
    DUIAssertNoMsg(_peInstalledItemList);
    DUIAssertNoMsg(_pePublishedItemList);    
    DUIAssertNoMsg(_peProgBar);
    DUIAssertNoMsg(_peSortCombo);
    DUIAssertNoMsg(_pePublishedCategory);


    LoadStringW(_pParser->GetHInstance(), IDS_NAME, szTemp, DUIARRAYSIZE(szTemp));     
    _peSortCombo->AddString(szTemp);
    LoadStringW(_pParser->GetHInstance(), IDS_SIZE, szTemp, DUIARRAYSIZE(szTemp));
    _peSortCombo->AddString(szTemp);
    LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCY, szTemp, DUIARRAYSIZE(szTemp));
    _peSortCombo->AddString(szTemp);
    LoadStringW(_pParser->GetHInstance(), IDS_DATELASTUSED, szTemp, DUIARRAYSIZE(szTemp));    
    _peSortCombo->AddString(szTemp);
    _peSortCombo->SetSelection(0);


    // Make the progress bar initially hidden
    _peProgBar->SetVisible(false);

    _bInDomain = ARPIsOnDomain();
    // Apply polices as needed
    ApplyPolices();
    
    // Set initial selection of option list
    ARPSelector* peList = (ARPSelector*)FindDescendent(_idOptionList);
    Element* peSel;
    switch(_uiStartPane)
    {
    case 2:
        peSel = FindDescendent(_idAddRmWin);        
        break;
    case 1:
        peSel = FindDescendent(_idAddNew);
        break;
    case 0:
    default:
        peSel = FindDescendent(_idChange);
        break;
    }

    DUIAssertNoMsg(peSel);
    peList->SetSelection(peSel);

    // Set initial selection of style list
    DUIAssertNoMsg(peSel);
    peList->SetSelection(peSel);

    // initialize focus-following floater window
    peLastFocused = NULL;
    Element::Create(0, &peFloater);
    peFloater->SetLayoutPos(LP_Absolute);
    Add(peFloater);
    peFloater->SetBackgroundColor(ARGB(64, 255, 255, 0));
}


void ARPFrame::OnDestroy()
{
    // Continue with destruction
    HWNDElement::OnDestroy();
}

void ARPFrame::ApplyPolices()
{
   Element* pe;

   if (ARPIsRestricted(L"NoSupportInfo"))
   {
       _bSupportInfoRestricted = true;
   }

   pe = FindDescendent(_idChange);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoRemovePage"))
   {
       pe->SetLayoutPos(LP_None);
       if (0 == _uiStartPane)
        {
           _uiStartPane++;
        }
    }
   pe = FindDescendent(_idAddNew);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoAddPage"))
   {
       pe->SetLayoutPos(LP_None);
       if (1 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }
   else
   {
       if (ARPIsRestricted(L"NoAddFromCDorFloppy"))
       {
           pe = FindDescendent(_idAddFromCDPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
       }
       if (ARPIsRestricted(L"NoAddFromInternet"))
       {
           pe = FindDescendent(_idAddFromMSPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
       }
       if (!_bInDomain || ARPIsRestricted(L"NoAddFromNetwork"))
       {
           pe = FindDescendent(_idAddFromNetworkPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
       }
   }
   pe = FindDescendent(_idAddRmWin);
   DUIAssertNoMsg(pe);
   // Note that in real ARP, we will never end up here with all thre panes disabled since we check for that before doing anything elese.
   if (ARPIsRestricted(L"NoWindowsSetupPage"))
   {
       pe->SetLayoutPos(LP_None);
       if (2 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }

}

bool ARPFrame::IsChangeRestricted()
{
   return ARPIsRestricted(L"NoRemovePage")? true : false;
}

DWORD WINAPI PopulateInstalledItemList(void* paf);

void ARPFrame::UpdateInstalledItems()
{
    if (!IsChangeRestricted())
    {
        _peInstalledItemList->RemoveAll();
        // Start second thread for item population
        //hUpdInstalledItemsThread = _beginthread(PopulateInstalledItemList, 0, (void*)this);
        if (!hUpdInstalledItemsThread && g_fRun)
            hUpdInstalledItemsThread = CreateThread(NULL, 0, PopulateInstalledItemList, (void*)this, 0, NULL);        
    }
}

////////////////////////////////////////////////////////
// Generic eventing

// Helper
inline void _SetElementSheet(Element* peTarget, ATOM atomID, Value* pvSheet, bool bSheetRelease = true)
{
    if (pvSheet)
    {
        Element* pe = peTarget->FindDescendent(atomID);
        DUIAssertNoMsg(pe);
        pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
        if (bSheetRelease)
            pvSheet->Release();
    }
} 

BOOL IsValidFileTime(FILETIME ft)
{
    return ft.dwHighDateTime || ft.dwLowDateTime;
}

BOOL IsValidSize(ULONGLONG ull)
{
    return ull != (ULONGLONG)-1;
}

BOOL IsValidFrequency(int iTimesUsed)
{
    return iTimesUsed >= 0;
}

DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf);

void ARPFrame::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;

            if (pbce->peTarget->GetID() == _idClose)
            {
                // Close button
                _pnhh->DestroyWindow();
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromDisk)
            {
                // Add from disk button
                HRESULT hr;
                IShellAppManager* pisam = NULL;
                hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
                if (SUCCEEDED(hr))
                {
                    pisam->InstallFromFloppyOrCDROM(GetHWND());
                }
                if (pisam)
                {
                    pisam->Release();
                }    
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromMsft)
            {
                // Windows update button
                ShellExecuteW(NULL, NULL, L"wupdmgr.exe", NULL, NULL, SW_SHOWDEFAULT);
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == ARPItem::_idSize ||
                     pbce->peTarget->GetID() == ARPItem::_idFreq ||
                     pbce->peTarget->GetID() == ARPItem::_idSupInfo)
            {
                // Help requests
                ARPHelp* peHelp;
                NativeHWNDHost* pnhh;
                Element* pe;
                WCHAR szTitle[1024];
                if (pbce->peTarget->GetID() == ARPItem::_idSize)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_SIZETITLE, szTitle, DUIARRAYSIZE(szTitle));
                    NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh);
                    ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                    _pParser->CreateElement(L"sizehelp", peHelp, &pe);
                }    
                else if (pbce->peTarget->GetID() == ARPItem::_idFreq)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCYTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh);
                    ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                    _pParser->CreateElement(L"freqhelp", peHelp, &pe);
                }    
                else
                {
                    // Support information, add additional fields
                    LoadStringW(_pParser->GetHInstance(), IDS_SUPPORTTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh);
                    ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                    _pParser->CreateElement(L"suphelp", peHelp, &pe);

                    // Get application info
                    APPINFODATA aid = {0};

                    // Query
                    aid.cbSize = sizeof(APPINFODATA);
                    aid.dwMask = AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                                 AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                                 AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                                 AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

                    // There must be a selection
                    ARPItem* peSel = (ARPItem*)_peInstalledItemList->GetSelection();

                    peSel->_piia->GetAppInfo(&aid);
                    ((ARPHelp*)peHelp)->_piia = peSel->_piia;                    
                    PrepareSupportInfo(peHelp, &aid);

                    // Clean up
                    ClearAppInfoData(&aid);

                }
                
                if (pe) // Fill contents using substitution
                {
                     // Set visible and host
                     _pah = peHelp;
                     _bInModalMode = true;                     
                     EnableWindow(GetHWND(), FALSE);                     
                     pnhh->Host(peHelp);
                     peHelp->SetVisible(true);                     
                     peHelp->SetDefaultFocus();

                   // Do initial show
                   pnhh->ShowWindow();
                }


                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Selector::SelectionChange)
        {
            SelectionChangeEvent* sce = (SelectionChangeEvent*)pEvent;

            if (sce->peTarget->GetID() == _idOptionList)
            {
                // ARP options
                StartDefer();

                Element* peInstalledListContainer = FindDescendent(StrToID(L"installedlistcontainer"));
                Element* pePublishedContainer = FindDescendent(StrToID(L"publishedlistcontainer"));                
                Element* peChangeContentHeader = FindDescendent(StrToID(L"changecontentheader"));
                Element* peAddContentHeader = FindDescendent(StrToID(L"addcontentheader"));
                Element* peAddNewPane = FindDescendent(StrToID(L"addnewpane"));
                Element* peAddRmWinPane = FindDescendent(StrToID(L"addrmwinpane"));

                if (sce->peNew->GetID() == _idChange)
                {
                    peInstalledListContainer->SetLayoutPos(BLP_Client);
                    pePublishedContainer->SetLayoutPos(LP_None);
                    peChangeContentHeader->SetLayoutPos(BLP_Top);
                    peAddContentHeader->SetLayoutPos(LP_None);
                    // TODO: Zero size ancestors need to cause adaptors (HWNDHosts) to hide
                    _peSortCombo->SetVisible(true);
                    _pePublishedCategory->SetVisible(false);
                    peAddNewPane->SetLayoutPos(LP_None);
                    peAddRmWinPane->SetLayoutPos(LP_None);
                }
                else if (sce->peNew->GetID() == _idAddNew)
                {
                    peInstalledListContainer->SetLayoutPos(LP_None);
                    pePublishedContainer->SetLayoutPos(BLP_Client);
                    if (!_bPublishedListFilled)
                    {
                        WCHAR szTemp[1024];
                        LoadStringW(_pParser->GetHInstance(), IDS_WAITFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
                        _pePublishedItemList->SetContentString(szTemp);
                        RePopulatePublishedItemList();
                    }
                    peChangeContentHeader->SetLayoutPos(LP_None);
                    peAddContentHeader->SetLayoutPos(BLP_Top);
                    // TODO: Zero size ancestors need to cause adaptors (HWNDHosts) to hide
                    _peSortCombo->SetVisible(false);
                    _pePublishedCategory->SetVisible(true);
                    peAddNewPane->SetLayoutPos(BLP_Client);
                    peAddRmWinPane->SetLayoutPos(LP_None);
                }
                else if (sce->peNew->GetID() == _idAddRmWin)
                {
                    peInstalledListContainer->SetLayoutPos(LP_None);
                    pePublishedContainer->SetLayoutPos(LP_None);                    
                    peChangeContentHeader->SetLayoutPos(LP_None);
                    peAddContentHeader->SetLayoutPos(LP_None);                    
                    // TODO: Zero size ancestors need to cause adaptors (HWNDHosts) to hide
                    _peSortCombo->SetVisible(false);
                    _pePublishedCategory->SetVisible(false);                    
                    peAddNewPane->SetLayoutPos(LP_None);
                    peAddRmWinPane->SetLayoutPos(BLP_Client);

                    // Invoke Add/Remove Windows components
                    // Command to invoke and OCMgr: "sysocmgr /x /i:%systemroot%\system32\sysoc.inf"
                    WCHAR szInf[MAX_PATH];
                    if (GetSystemDirectoryW(szInf, MAX_PATH) && PathCombineW(szInf, szInf, L"sysoc.inf"))
                    {
                        WCHAR szParam[MAX_PATH];
                        swprintf(szParam, L"/i:%s", szInf);
                        ShellExecuteW(NULL, NULL, L"sysocmgr", szParam, NULL, SW_SHOWDEFAULT);
                    }
                }

                EndDefer();
            }
            else if (sce->peTarget->GetID() == _idInstalledList)
            {
                if (sce->peOld)
                {
                   sce->peOld->FindDescendent(ARPItem::_idRow[0])->SetEnabled(false);
                }
                if (sce->peNew)
                {
                   sce->peNew->FindDescendent(ARPItem::_idRow[0])->RemoveLocalValue(EnabledProp);
                }
            }
            pEvent->fHandled = true;
            return;
        }
        else if (pEvent->uidType == Combobox::SelectionChange)
        {
            SelectionIndexChangeEvent* psice = (SelectionIndexChangeEvent*)pEvent;
            if (psice->peTarget->GetID() == _idSortCombo)
            {
                SortList(psice->iNew, psice->iOld);
            }
            else if (psice->peTarget->GetID() == _idCategoryCombo)
            {
                _curCategory = psice->iNew;
                if (_bPublishedComboFilled)
                {
                    if (_bPublishedListFilled)
                    {
                        RePopulatePublishedItemList();
                    }
                    else
                    {
                        _bDeferredPublishedListFill = true;
                    }
                }    
            }
            pEvent->fHandled = true;
            return;
        }
    }
    
    HWNDElement::OnEvent(pEvent);
}

void ARPFrame::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    if(peTo && IsDescendent(peTo))
    {
        peLastFocused = peTo;
    }
    Element::OnKeyFocusMoved(peFrom, peTo);

/*  uncomment when JStall's message fixing is done
    if (peTo != peLastFocused)
    {
        // transition focus-following floater element from old to new

        if (!peTo)
            peFloater->SetVisible(false);
        else
        {
            Value* pvSize;
            const SIZE* psize = peTo->GetExtent(&pvSize);
            peFloater->SetWidth(psize->cx);
            peFloater->SetHeight(psize->cy);
            pvSize->Release();

            POINT pt = { 0, 0 };
            MapElementPoint(peTo, &pt, &pt);
            peFloater->SetX(pt.x);
            peFloater->SetY(pt.y);

            if (!peLastFocused)
                peFloater->SetVisible(true);
        }

        peLastFocused = peTo;
    }
*/
}

void ARPFrame::OnPublishedListComplete()
{
    Invoke(ARP_PUBLISHEDLISTCOMPLETE, NULL);
}

void ARPFrame::RePopulatePublishedItemList()
{
    _pePublishedItemList->DestroyAll();
    _bPublishedListFilled = false;
    //hRePopPubItemListThread = _beginthread(::PopulateAndRenderPublishedItemList, 0, (void*)this);
    if (!hRePopPubItemListThread && g_fRun)
        hRePopPubItemListThread = CreateThread(NULL, 0, PopulateAndRenderPublishedItemList, (void*)this, 0, NULL);        
}

bool ARPFrame::CanSetFocus()
{
    if (_bInModalMode)
    {
        HWND hWnd = _pah->GetHost()->GetHWND();
        FLASHWINFO fwi = {
        sizeof(FLASHWINFO),               // cbSize
            hWnd,   // hwnd
            FLASHW_CAPTION,               // flags
            5,                            // uCount
            75                            // dwTimeout
            };
        FlashWindowEx(&fwi);
        SetFocus(hWnd);
        return false;
    }
    return true;
}

////////////////////////////////////////////////////////
// Caller thread-safe APIs (do any additional work on callers thread and then marshal)

// Sets the range for the progress bar
void ARPFrame::SetInstalledItemCount(UINT cItems)
{
    Invoke(ARP_SETINSTALLEDITEMCOUNT, (void*)(UINT_PTR)cItems);
}

// Inserts in items, sorted into the ARP list
void ARPFrame::InsertInstalledItem(IInstalledApp* piia)
{
    // Setup marshalled call, do as much work as possible on caller thread
    InsertItemData iid;

    APPINFODATA aid = {0};
    SLOWAPPINFO sai = {0};

    // Query only for display name and support URL
    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    piia->GetAppInfo(&aid);
    
    if(FAILED(piia->GetCachedSlowAppInfo(&sai)))
    {
        piia->GetSlowAppInfo(&sai);
    }
    // Set data
    iid.piia = piia;

    if (aid.pszDisplayName && aid.pszDisplayName[0])
    {
        // Title
        CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

        // Image
        if(aid.pszImage && aid.pszImage[0])
        {
            iid.iIconIndex = PathParseIconLocationW(aid.pszImage);
            CopyMemory(iid.pszImage, aid.pszImage, min(sizeof(iid.pszImage), (wcslen(aid.pszImage) + 1) * sizeof(WCHAR)));    
        }
        else if(sai.pszImage && sai.pszImage[0])
        {
            iid.iIconIndex = PathParseIconLocationW(sai.pszImage);
            CopyMemory(iid.pszImage, sai.pszImage, min(sizeof(iid.pszImage), (wcslen(sai.pszImage) + 1) * sizeof(WCHAR)));
        }
        else
        {
            *iid.pszImage = NULL;
        }

        // Size, Frequency, and Last Used On
        iid.ullSize = sai.ullSize;
        iid.iTimesUsed = sai.iTimesUsed;
        iid.ftLastUsed = sai.ftLastUsed;

        // Possible actions (change, remove, etc.)
        piia->GetPossibleActions(&iid.dwActions);

        // Flag if support information is available
        iid.bSupportInfo = ShowSupportInfo(&aid);

        Invoke(ARP_INSERTINSTALLEDITEM, &iid);
    }

    // Free query memory
    ClearAppInfoData(&aid);
}

void ARPFrame::InsertPublishedItem(IPublishedApp* pipa)
{
    PUBAPPINFO pai = {0};
    APPINFODATA aid = {0};
    InsertItemData iid= {0};

    pai.cbSize = sizeof(pai);
    pai.dwMask = PAI_SOURCE | PAI_ASSIGNEDTIME | PAI_PUBLISHEDTIME | PAI_EXPIRETIME | PAI_SCHEDULEDTIME;

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    pipa->GetAppInfo(&aid);
    pipa->GetPublishedAppInfo(&pai);            

    iid.pipa = pipa;

    // Title
    CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

    Invoke(ARP_INSERTPUBLISHEDITEM, &iid);

    // Free query memory
    ClearAppInfoData(&aid);
}
void ARPFrame::FeedbackEmptyPublishedList()
{
    Invoke(ARP_SETPUBLISHEDFEEDBACKEMBPTY, 0);
}

void  ARPFrame::PopulateCategoryCombobox()
{
    Invoke(ARP_POPULATECATEGORYCOMBO, NULL);
}

LPCWSTR ARPFrame::GetCurrentPublishedCategory()
{
    int iCurrentCategory = _curCategory;
    if (iCurrentCategory == 0 || iCurrentCategory == CB_ERR || _psacl == NULL)
    {
        return NULL;
    }
    return _psacl->pCategory[iCurrentCategory - 1].pszCategory;
}

inline bool ARPFrame::ShowSupportInfo(APPINFODATA *paid)
{
   if (_bSupportInfoRestricted)
   {
       return false;
   }
   if (paid->pszVersion && paid->pszVersion ||
      paid->pszPublisher && paid->pszPublisher ||
      paid->pszProductID && paid->pszProductID ||
      paid->pszRegisteredOwner && paid->pszRegisteredOwner ||
      paid->pszRegisteredCompany && paid->pszRegisteredCompany ||
      paid->pszSupportUrl && paid->pszSupportUrl ||
      paid->pszHelpLink && paid->pszHelpLink ||
      paid->pszContact && paid->pszContact ||
      paid->pszReadmeUrl && paid->pszReadmeUrl ||
      paid->pszComments && paid->pszComments)
   {
       return TRUE;
   }
   return FALSE;
}
void ARPFrame::PrepareSupportInfo(Element* peHelp, APPINFODATA *paid)
{
    DWORD dwAction = 0;
    peHelp->FindDescendent(StrToID(L"title"))->SetContentString(paid->pszDisplayName); 
    peHelp->FindDescendent(StrToID(L"prodname"))->SetContentString(paid->pszDisplayName); 

    ARPSupportItem* pasi;
    pasi = (ARPSupportItem*) (peHelp->FindDescendent(StrToID(L"publisher")));
    pasi->SetAccValue(paid->pszPublisher);
    pasi->SetURL(paid->pszSupportUrl);

    peHelp->FindDescendent(StrToID(L"version"))->SetAccValue(paid->pszVersion);

    peHelp->FindDescendent(StrToID(L"contact"))->SetAccValue(paid->pszContact);

    pasi = (ARPSupportItem*) (peHelp->FindDescendent(StrToID(L"support")));
    pasi->SetAccValue(paid->pszHelpLink);
    pasi->SetURL(paid->pszHelpLink);
    
    pasi = (ARPSupportItem*) (peHelp->FindDescendent(StrToID(L"readme")));
    pasi->SetAccValue(paid->pszReadmeUrl);
    pasi->SetURL(paid->pszReadmeUrl);

    pasi = (ARPSupportItem*) (peHelp->FindDescendent(StrToID(L"update")));
    pasi->SetAccValue(paid->pszUpdateInfoUrl);
    pasi->SetURL(paid->pszUpdateInfoUrl);

    peHelp->FindDescendent(StrToID(L"productID"))->SetAccValue(paid->pszProductID);

    peHelp->FindDescendent(StrToID(L"regCompany"))->SetAccValue(paid->pszRegisteredCompany);

    peHelp->FindDescendent(StrToID(L"regOwner"))->SetAccValue(paid->pszRegisteredOwner);

    peHelp->FindDescendent(StrToID(L"comments"))->SetAccValue(paid->pszComments);

    ((ARPHelp*)peHelp)->_piia->GetPossibleActions(&dwAction);
    if (!(dwAction & APPACTION_REPAIR))
        peHelp->FindDescendent(StrToID(L"repairblock"))->SetLayoutPos(LP_None);
}
extern "C" int __cdecl CompareElementDataName(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataSize(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataFreq(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataLast(const void* pA, const void* pB);

CompareCallback ARPFrame::GetCompareFunction()
{
    switch(CurrentSortType)
    {
        case SORT_SIZE:      return CompareElementDataSize;
        case SORT_TIMESUSED: return CompareElementDataFreq;
        case SORT_LASTUSED:  return CompareElementDataLast;
        default:             return CompareElementDataName;
    }
}

void ARPFrame::SortList(int iNew, int iOld)
{
    if ((iNew >= 0) && (iNew != CurrentSortType))
    {
        CurrentSortType = (SortType) iNew;

        StartDefer();

        if (((iNew != SORT_NAME) || (iOld != SORT_SIZE)) &&
            ((iNew != SORT_SIZE) || (iOld != SORT_NAME)))
        {
            Value* pvChildren;
            ElementList* pel = _peInstalledItemList->GetChildren(&pvChildren);

            for (UINT i = 0; i < pel->GetSize(); i++)
                ((ARPItem*) pel->GetItem(i))->SortBy(iNew, iOld);

            pvChildren->Release();
        }

        _peInstalledItemList->SortChildren(GetCompareFunction());

        if (!_peInstalledItemList->GetSelection())
        {
            Value* pv;
            ElementList* peList = _peInstalledItemList->GetChildren(&pv);

            _peInstalledItemList->SetSelection(peList->GetItem(0));
            pv->Release();
        }

        EndDefer();
    }
}

void ARPFrame::SelectInstalledApp(IInstalledApp* piia)
{
    Value* pv;
    ElementList* peList = _peInstalledItemList->GetChildren(&pv);

    for (UINT i = 0; i < peList->GetSize(); i++)
    {
        ARPItem* pai = (ARPItem*) peList->GetItem(i);
        if (pai->_piia == piia)
        {
            pai->SetKeyFocus();
            break;
        }
    }
    pv->Release();
}

void ARPFrame::ClearAppInfoData(APPINFODATA *paid)
{
    if (paid)
    {
        if (paid->dwMask & AIM_DISPLAYNAME)
            StrFree(paid->pszDisplayName);
            
        if (paid->dwMask & AIM_VERSION)
            StrFree(paid->pszVersion);

        if (paid->dwMask & AIM_PUBLISHER)
            StrFree(paid->pszPublisher);
            
        if (paid->dwMask & AIM_PRODUCTID)
            StrFree(paid->pszProductID);
            
        if (paid->dwMask & AIM_REGISTEREDOWNER)
            StrFree(paid->pszRegisteredOwner);
            
        if (paid->dwMask & AIM_REGISTEREDCOMPANY)
            StrFree(paid->pszRegisteredCompany);
            
        if (paid->dwMask & AIM_LANGUAGE)
            StrFree(paid->pszLanguage);
            
        if (paid->dwMask & AIM_SUPPORTURL)
            StrFree(paid->pszSupportUrl);
            
        if (paid->dwMask & AIM_SUPPORTTELEPHONE)
            StrFree(paid->pszSupportTelephone);
            
        if (paid->dwMask & AIM_HELPLINK)
            StrFree(paid->pszHelpLink);
            
        if (paid->dwMask & AIM_INSTALLLOCATION)
            StrFree(paid->pszInstallLocation);
            
        if (paid->dwMask & AIM_INSTALLSOURCE)
            StrFree(paid->pszInstallSource);
            
        if (paid->dwMask & AIM_INSTALLDATE)
            StrFree(paid->pszInstallDate);
            
        if (paid->dwMask & AIM_CONTACT)
            StrFree(paid->pszContact);

        if (paid->dwMask & AIM_COMMENTS)
            StrFree(paid->pszComments);

        if (paid->dwMask & AIM_IMAGE)
            StrFree(paid->pszImage);
    }
}


////////////////////////////////////////////////////////
// Callee thread-safe invoke (override)

void ARPFrame::OnInvoke(UINT nType, void* pData)
{
    // We are shutting down, ignore any requests from other threads
    if (!g_fRun)
        return;

    // Initialize ID cache if first pass
    if (!ARPItem::_idTitle)
    {
        ARPItem::_idTitle = StrToID(L"title");
        ARPItem::_idIcon = StrToID(L"icon");
        ARPItem::_idSize = StrToID(L"size");
        ARPItem::_idFreq = StrToID(L"freq");
        ARPItem::_idLastUsed = StrToID(L"lastused");
        ARPItem::_idInstalled = StrToID(L"installed");
        ARPItem::_idExInfo = StrToID(L"exinfo");
        ARPItem::_idSupInfo = StrToID(L"supinfo");
        ARPItem::_idItemAction = StrToID(L"itemaction");
        ARPItem::_idRow[0] = StrToID(L"row1");
        ARPItem::_idRow[1] = StrToID(L"row2");
        ARPItem::_idRow[2] = StrToID(L"row3");
    }

    switch (nType)
    {
    case ARP_SETINSTALLEDITEMCOUNT:
        // pData is item count
        DUIAssertNoMsg(_peProgBar);

        _peProgBar->SetMaximum((int)(INT_PTR)pData);
        break;

    case ARP_SETPUBLISHEDFEEDBACKEMBPTY:
        {
        WCHAR szTemp[1024];
        LoadStringW(_pParser->GetHInstance(), IDS_EMPTYFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
        _pePublishedItemList->SetContentString(szTemp);            
        }
        break;
    case ARP_INSERTINSTALLEDITEM:
        {
        WCHAR szTemp[1024] = {0};
        WCHAR szFormat[MAX_PATH];
        
        // pData is InsertItemData struct
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        _pParser->CreateElement(L"installeditem", NULL, (Element**)&peItem);
        peItem->_paf = this;
        
        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        if (!(piid->dwActions & APPACTION_MODIFYREMOVE))
        {
            _pParser->CreateElement(L"installeditemdoubleaction", NULL, &peAction);
            if (!ARPItem::_idChg)
            {
                ARPItem::_idChg = StrToID(L"chg");
                ARPItem::_idRm = StrToID(L"rm");
            }
            LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEORREMOVE, szTemp, DUIARRAYSIZE(szTemp));
            peItem->FindDescendent(StrToID(L"instruct"))->SetContentString(szTemp);
        }
        else
        {
            _pParser->CreateElement(L"installeditemsingleaction", NULL, &peAction);
            if (!ARPItem::_idChgRm)
                ARPItem::_idChgRm = StrToID(L"chgrm");
            LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEREMOVE, szTemp, DUIARRAYSIZE(szTemp));                
            peItem->FindDescendent(StrToID(L"instruct"))->SetContentString(szTemp);
        }
        peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);

        // Support information
        if (!piid->bSupportInfo)
            peItem->FindDescendent(ARPItem::_idSupInfo)->SetLayoutPos(LP_None);

        // Set fields

        // Installed app interface pointer
        peItem->_piia = piid->piia;
        peItem->_piia->AddRef();

        // should just be call into the peItem: peItem->SetTimesUsed(piid->iTimesUsed); etc.
        peItem->_iTimesUsed = piid->iTimesUsed;
        peItem->_ftLastUsed = piid->ftLastUsed;
        peItem->_ullSize    = piid->ullSize;

        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, piid->iIconIndex, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                pvIcon->Release();
            }    
        }
        *szTemp = NULL;
        // Size
        peField = peItem->FindDescendent(ARPItem::_idSize);
        DUIAssertNoMsg(peField);
        if (IsValidSize(piid->ullSize))
        {
            double fSize = (double)(__int64)piid->ullSize;
            fSize /= 1048576.;  // 1MB
            if (fSize > 100.)
            {
                LoadStringW(_pParser->GetHInstance(), IDS_SIZEFORMAT1, szFormat, DUIARRAYSIZE(szFormat));
                swprintf(szTemp, szFormat, (__int64)fSize);  // Clip
            }    
            else
            {
                LoadStringW(_pParser->GetHInstance(), IDS_SIZEFORMAT2, szFormat, DUIARRAYSIZE(szFormat));
                swprintf(szTemp, szFormat, fSize);
            }    
        
            peField->SetContentString(szTemp);
        }
        else
        {
            peField->SetVisible(false);
            peItem->FindDescendent(StrToID(L"sizelabel"))->SetVisible(false);
        }

        // Frequency
        peField = peItem->FindDescendent(ARPItem::_idFreq);
        DUIAssertNoMsg(peField);
        if (IsValidFrequency(piid->iTimesUsed))
        {
            if (piid->iTimesUsed <= 2)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDREARELY, szTemp, DUIARRAYSIZE(szTemp));
            else if (piid->iTimesUsed <= 10)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDOCCASIONALLY, szTemp, DUIARRAYSIZE(szTemp));
            else
                LoadStringW(_pParser->GetHInstance(), IDS_USEDFREQUENTLY, szTemp, DUIARRAYSIZE(szTemp));

            peField->SetContentString(szTemp);
        }
        else
        {
            peField->SetVisible(false);
            peItem->FindDescendent(StrToID(L"freqlabel"))->SetVisible(false);
        }

        // Last used on
        peField = peItem->FindDescendent(ARPItem::_idLastUsed);
        DUIAssertNoMsg(peField);
        if (IsValidFileTime(piid->ftLastUsed))
        {
            SYSTEMTIME stLastUsed;
            FileTimeToSystemTime(&piid->ftLastUsed, &stLastUsed);
            LoadStringW(_pParser->GetHInstance(), IDS_LASTUSEDFORMAT, szFormat, DUIARRAYSIZE(szFormat));
            swprintf(szTemp, szFormat, stLastUsed.wMonth, stLastUsed.wDay, stLastUsed.wYear);
        
            peField->SetContentString(szTemp);
        }
        else
        {
            peField->SetVisible(false);
            peItem->FindDescendent(StrToID(L"lastlabel"))->SetVisible(false);
        }

        // Insert item into list
        _peInstalledItemList->Add(peItem, GetCompareFunction());

        // Make the progress bar visible
        if (_peProgBar->GetPosition() == _peProgBar->GetMinimum())
        {
           _peProgBar->SetVisible(true);
        }

        // Increment progress bar
        _peProgBar->SetPosition(_peProgBar->GetPosition() + 1);

        // Auto-select first item if populate is done
        if (_peProgBar->GetPosition() == _peProgBar->GetMaximum())
        {
            // Only auto-select if no selection
            if (!_peInstalledItemList->GetSelection())
            {
                Value* pv;
                ElementList* peList = _peInstalledItemList->GetChildren(&pv);

                // once list is populated, move focus to list
                peList->GetItem(0)->SetKeyFocus();

                pv->Release();
            }

            _peProgBar->SetVisible(false);
        }

        EndDefer();
        }
        break;
    case ARP_INSERTPUBLISHEDITEM:
        {
        WCHAR szTemp[MAX_PATH] = {0};
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        _pParser->CreateElement(L"publisheditem", NULL, (Element**)&peItem);
        peItem->_paf = this;

        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        _pParser->CreateElement(L"publisheditemsingleaction", NULL, &peAction);
        if (!ARPItem::_idAdd)
            ARPItem::_idAdd = StrToID(L"add");
        LoadStringW(_pParser->GetHInstance(), IDS_ADDHELP, szTemp, DUIARRAYSIZE(szTemp));      
        peItem->FindDescendent(StrToID(L"instruct"))->SetContentString(szTemp);
        peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);

        if (S_OK == piid->pipa->IsInstalled())
        {
            LoadStringW(_pParser->GetHInstance(), IDS_INSTALLED, szTemp, DUIARRAYSIZE(szTemp));      
            peItem->FindDescendent(ARPItem::_idInstalled)->SetContentString(szTemp);
        }
        
        // Published app interface pointer
        peItem->_pipa = piid->pipa;
        peItem->_pipa->AddRef();

        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, NULL, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                pvIcon->Release();
            }    
        }

        // Insert into list, alphabetically
        Value* pvElList;
        ElementList* peElList = _pePublishedItemList->GetChildren(&pvElList);

        Value* pvTitle;
        Element* pe;
        UINT iInsert = 0;

        if (peElList)
        {
            for (; iInsert < peElList->GetSize(); iInsert++)
            {
                pe = peElList->GetItem(iInsert)->FindDescendent(ARPItem::_idTitle);
                DUIAssertNoMsg(pe);

                if (wcscmp(pe->GetContentString(&pvTitle), piid->pszTitle) > 0)
                {
                    pvTitle->Release();
                    break;
                }

                pvTitle->Release();
            }
        }
        
        pvElList->Release();

        // Insert item into list
        _pePublishedItemList->Insert(peItem, iInsert);

         Value* pv;
         ElementList* peList = _pePublishedItemList->GetChildren(&pv);

         _pePublishedItemList->SetSelection(peList->GetItem(0));

         pv->Release();
       
        EndDefer();
    }
        break;
    case ARP_POPULATECATEGORYCOMBO:
    {
    UINT i;
    WCHAR szTemp[1024];

    SHELLAPPCATEGORY *psac = _psacl->pCategory;

    LoadStringW(_pParser->GetHInstance(), IDS_ALLCATEGORIES, szTemp, DUIARRAYSIZE(szTemp));
    _pePublishedCategory->AddString(szTemp);
    StartDefer();
    for (i = 0; i < _psacl->cCategories; i++, psac++)
    {
        if (psac->pszCategory)
        {
            _pePublishedCategory->AddString(psac->pszCategory);
        }
    }
    _pePublishedCategory->SetSelection(_psacl->cCategories ? 1 : 0); 
    EndDefer();
    }
        break;
    case ARP_PUBLISHEDLISTCOMPLETE:
    if (_bDeferredPublishedListFill)
    {
        _bDeferredPublishedListFill = false;
        RePopulatePublishedItemList();
    }
        break;
    }    
}

LRESULT ARPFrame::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_THEMECHANGED:
    case WM_SETTINGCHANGE:
        {
            LockWindowUpdate(_pnhh->GetHWND());
        
            Parser* pOldStyle = _pParserStyle;
            Parser* pNewStyle = NULL;

            if (!pOldStyle)
                break;

            // System parameter changing, reload style sheets so to sync
            // up with changes
            if (_fThemedStyle)
            {
                // Currently themed, throw away all theme data
                // 0th has application instance
                CloseThemeData(_arH[BUTTONHTHEME]); // Button
                _arH[BUTTONHTHEME] = NULL;
                CloseThemeData(_arH[SCROLLBARHTHEME]); // Scrollbar
                _arH[SCROLLBARHTHEME] = NULL;
                CloseThemeData(_arH[TOOLBARHTHEME]); // Toolbar
                _arH[TOOLBARHTHEME] = NULL;
            }

            // Reset app theme bit
            _fThemedStyle = IsAppThemed();

            if (_fThemedStyle)
            {
                // Open theme data
                _arH[BUTTONHTHEME] = OpenThemeData(GetHWND(), L"Button");
                _arH[SCROLLBARHTHEME] = OpenThemeData(GetHWND(), L"Scrollbar");
                _arH[TOOLBARHTHEME] = OpenThemeData(GetHWND(), L"Toolbar");

                Parser::Create(IDR_ARPSTYLETHEME, _arH, ARPParseError, &pNewStyle);
            }
            else
            {
                Parser::Create(IDR_ARPSTYLESTD, g_hInstance, ARPParseError, &pNewStyle);
            }

            // Replace all style sheets
            if (pNewStyle)
            {
                Parser::ReplaceSheets(this, pOldStyle, pNewStyle);
            }

            // New style parser
            _pParserStyle = pNewStyle;

            // Destroy old
            pOldStyle->Destroy();

            LockWindowUpdate(NULL);
        }
        break;
    }

    return HWNDElement::WndProc(hWnd, uMsg, wParam, lParam);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPFrame::Class = NULL;

HRESULT ARPFrame::Register()
{
    return ClassInfo<ARPFrame,HWNDElement>::Register(L"ARPFrame", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPItem class
////////////////////////////////////////////////////////


// ARP item IDs
ATOM ARPItem::_idTitle = 0;
ATOM ARPItem::_idIcon = 0;
ATOM ARPItem::_idSize = 0;
ATOM ARPItem::_idFreq = 0;
ATOM ARPItem::_idLastUsed = 0;
ATOM ARPItem::_idExInfo = 0;
ATOM ARPItem::_idInstalled = 0;
ATOM ARPItem::_idChgRm = 0;
ATOM ARPItem::_idChg = 0;
ATOM ARPItem::_idRm = 0;
ATOM ARPItem::_idAdd = 0;
ATOM ARPItem::_idSupInfo = 0;
ATOM ARPItem::_idItemAction = 0;
ATOM ARPItem::_idRow[3] = { 0, 0, 0 };


////////////////////////////////////////////////////////
// ARPItem

HRESULT ARPItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPItem* pai = HNew<ARPItem>();
    if (!pai)
        return E_OUTOFMEMORY;

    HRESULT hr = pai->Initialize();
    if (FAILED(hr))
    {
        pai->Destroy();
        return hr;
    }

    *ppElement = pai;

    return S_OK;
}

HRESULT ARPItem::Initialize()
{
    _piia = NULL; // Init before base in event of failure (invokes desstructor)
    _pipa = NULL; // Init before base in event of failure (invokes desstructor)


    // Do base class initialization
    HRESULT hr = Button::Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
        return hr;

    return S_OK;
}


ARPItem::~ARPItem()
{
    if (_piia)
        _piia->Release();

    if (_pipa)
        _pipa->Release();
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->uidType == Element::KeyboardNavigate)
    {
        KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*)pEvent;
        if (pkne->iNavDir & NAV_LOGICAL)
        {
            if (pEvent->nStage == GMF_DIRECT)
            {
            }
        }
        else
        {
            if (pEvent->nStage == GMF_ROUTED)
            {
                pEvent->fHandled = true;

                KeyboardNavigateEvent kne;
                kne.uidType = Element::KeyboardNavigate;
                kne.peTarget = this;
                kne.iNavDir = pkne->iNavDir;

                FireEvent(&kne);  // Will route and bubble
            }
            return;
        }
    }

    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;
            ATOM id = pbce->peTarget->GetID();
            if (id == _idChgRm || id == _idRm || id == _idChg || id == _idAdd)
            {
                DUIAssertNoMsg(_paf);
                if (_paf)
                {
                    EnableWindow(_paf->GetHostWindow(), FALSE);
                }

                if (id == _idAdd)
                {
                    if (SUCCEEDED(_pipa->Install(NULL)))
                    {
                        // update installed items list
                        _paf->UpdateInstalledItems();
                    }
                }
                else
                {
                    HRESULT hr = E_FAIL;

                    if ((id == _idChgRm) || (id == _idRm))
                        hr = _piia->Uninstall(NULL);
                    else if (id == _idChg)
                        hr = _piia->Modify(NULL);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE == _piia->IsInstalled())
                        {
                            // remove from installed items list
                            Destroy();
                        }
                    }
                }

                if (_paf)
                {
                    EnableWindow(_paf->GetHostWindow(), TRUE);
                }

                pEvent->fHandled = true;
                return;
            }
        }
    }

    Button::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// System events

void ARPItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selected))
    {
        // Display of extended information
        Element* peExInfo = FindDescendent(_idExInfo);
        DUIAssertNoMsg(peExInfo);

        peExInfo->SetLayoutPos(pvNew->GetBool() ? BLP_Top : LP_None);
        
        // Do default processing in this case
    }

    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void GetOrder(int iSortBy, int* iOrder)
{
    switch (iSortBy)
    {
        case SORT_NAME:
        case SORT_SIZE:      iOrder[0] = 0; iOrder[1] = 1; iOrder[2] = 2; break;
        case SORT_TIMESUSED: iOrder[0] = 1; iOrder[1] = 0; iOrder[2] = 2; break;
        case SORT_LASTUSED:  iOrder[0] = 2; iOrder[1] = 0; iOrder[2] = 1; break;
    }
}

void ARPItem::SortBy(int iNew, int iOld)
{
    Element* pe[3][2];     // size, timesused, lastused
    int iOrderOld[3];      // size, timesused, lastused
    int iOrderNew[3];      // size, timesused, lastused

    GetOrder(iOld, iOrderOld);
    GetOrder(iNew, iOrderNew);

    Element* peRow[3];     // row1, row2, row3

    for (int i = 0; i < 3; i++) // loop through rows
    {
        int row = iOrderOld[i];
        if (row == iOrderNew[i])
            iOrderNew[i] = -1;
        else
        {
            peRow[i] = FindDescendent(ARPItem::_idRow[i]);
            Value* pvChildren;
            ElementList* pel;
            pel = peRow[i]->GetChildren(&pvChildren);
            pe[row][0] = pel->GetItem(0);
            pe[row][1] = pel->GetItem(1);
            pvChildren->Release();
        }
    }

    for (i = 0; i < 3; i++)
    {
        int row = iOrderNew[i];
        if (row != -1) // meaning that this row doesn't change
            peRow[i]->Add(pe[row], 2);
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPItem::Class = NULL;
HRESULT ARPItem::Register()
{
    return ClassInfo<ARPItem,Button>::Register(L"ARPItem", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPHelp
////////////////////////////////////////////////////////

HRESULT ARPHelp::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPHelp::Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement)
{

    *ppElement = NULL;

    ARPHelp* pah = HNew<ARPHelp>();
    if (!pah)
        return E_OUTOFMEMORY;

    HRESULT hr = pah->Initialize(pnhh, paf, bDblBuffer);
    if (FAILED(hr))
    {
        pah->Destroy();
        return hr;
    }

    *ppElement = pah;

    return S_OK;
}

HRESULT ARPHelp::Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer)
{
    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), bDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    // Initialize
    // SetActive(AE_MouseAndKeyboard);
    _pnhh = pnhh;
    _paf = paf;

    return S_OK;
}
void ARPHelp::SetDefaultFocus()
{
    Element* pe = FindDescendent(StrToID(L"close"));
    if (pe)
    {
        pe->SetKeyFocus();
    }
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPHelp::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ATOM id = pEvent->peTarget->GetID();
            if (id == StrToID(L"repair")) 
                _piia->Repair(NULL);
            if (pEvent->peTarget->GetID() == StrToID(L"close")) 
            {
                _pnhh->DestroyWindow();
            }
            pEvent->fHandled = true;
            return;
        }
    }

    HWNDElement::OnEvent(pEvent);
}

void ARPHelp::OnDestroy()
{
    HWNDElement::OnDestroy();
    if (_paf)
    {
        _paf->SetModalMode(false);
    }

}

ARPHelp::~ARPHelp()
{
    if (_paf)
    {
        EnableWindow(_paf->GetHWND(), TRUE);
        SetFocus(_paf->GetHWND());
        _paf->RestoreKeyFocus();
    }

    if (_pnhh)
    {
        _pnhh->Destroy();
    }
}
////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPHelp::Class = NULL;
HRESULT ARPHelp::Register()
{
    return ClassInfo<ARPHelp,HWNDElement>::Register(L"ARPHelp", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPSupportItem
////////////////////////////////////////////////////////

HRESULT ARPSupportItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSupportItem* pasi = HNew<ARPSupportItem>();
    if (!pasi)
        return E_OUTOFMEMORY;

    HRESULT hr = pasi->Initialize();
    if (FAILED(hr))
    {
        pasi->Destroy();
        return hr;
    }

    *ppElement = pasi;

    return S_OK;
}

Value* _pvRowLayout = NULL;

HRESULT ARPSupportItem::Initialize()
{
    // Do base class initialization
    HRESULT hr = Element::Initialize(0);
    if (FAILED(hr))
        return hr;

    // Initialize
    bool fCreateLayout = !_pvRowLayout;

    if (fCreateLayout)
    {
        int ari[3] = { -1, 0, 3 };
        hr = RowLayout::Create(3, ari, &_pvRowLayout);
        if (FAILED(hr))
            return hr;
    }

    Element* peName;
    hr = Element::Create(AE_Inactive, &peName);
    if (FAILED(hr))
        return hr;

    Button* peValue;
    hr = Button::Create((Element**) &peValue);
    if (FAILED(hr))
    {
        peName->Destroy();
        return hr;
    }

    peValue->SetEnabled(false);

    Add(peName);
    Add(peValue);

    SetValue(LayoutProp, PI_Local, _pvRowLayout);
    SetLayoutPos(LP_None);

    if (fCreateLayout)
    {
        // todo:  need to track in propertychanged to know when it reaches null, which is
        // when we need to set it to NULL
    }

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

#define ASI_Name  0
#define ASI_Value 1

Element* ARPSupportItem::GetChild(UINT index)
{
    Value* pvChildren;
    ElementList* pel = GetChildren(&pvChildren);
    Element* pe = NULL;
    if (pel && (pel->GetSize() > index))
        pe = pel->GetItem(index);
    pvChildren->Release();
    return pe;
}


void ARPSupportItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    int index = -1;
    if (IsProp(AccName))
        index = ASI_Name;
    else if (IsProp(AccValue))
        index = ASI_Value;
    else if (IsProp(URL))
    {
        Element* pe = GetChild(ASI_Value);
        if (pe)
        {
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                pe->RemoveLocalValue(EnabledProp);
            else
                pe->SetEnabled(false);
        }
    }

    if (index != -1)
    {
        Element* pe = GetChild(index);
        if (index == ASI_Value)
        {
            // WARNING -- this code assumes you will not put a layoutpos on this element
            // as this code toggles between LP_None and unset, ignoring any previous setting
            // to the property -- Verify this with Mark -- could be that this is local
            // and the markup is specified?  then there wouldn't be a problem
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                RemoveLocalValue(LayoutPosProp);
            else
                SetLayoutPos(LP_None);
        }
        if (pe)
            pe->SetValue(ContentProp, PI_Local, pvNew);
    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPSupportItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            Value* pvURL;
            LPCWSTR lpszURL = GetURL(&pvURL);
            if (*lpszURL)
                ShellExecuteW(NULL, NULL, lpszURL, NULL, NULL, SW_SHOWDEFAULT);
            pvURL->Release();

            pEvent->fHandled = true;
            return;
        }
    }

    Element::OnEvent(pEvent);
}

// URL property
static int vvURL[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultURL, DUIV_STRING, (void*)L"");
static PropertyInfo impURLProp = { L"URL", PF_Normal|PF_Cascade, 0, vvURL, NULL, (Value*)&svDefaultURL };
PropertyInfo* ARPSupportItem::URLProp = &impURLProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ARPSupportItem::URLProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ARPSupportItem::Class = NULL;
HRESULT ARPSupportItem::Register()
{
    return ClassInfo<ARPSupportItem,Element>::Register(L"ARPSupportItem", _aPI, DUIARRAYSIZE(_aPI));
}

// Define class info with type and base type, set static class pointer
HRESULT ARPSelector::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSelector* ps = HNew<ARPSelector>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppElement = ps;

    return S_OK;
};

////////////////////////////////////////////////////////
// Generic eventing

void ARPSelector::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        // Selection occurs only for direct children of selector that
        // fire Button::Click events
        if (pEvent->uidType == Button::Click && pEvent->peTarget->GetParent() == this)
        {
            SetSelection(pEvent->peTarget);

            pEvent->fHandled = true;
            return;
        }
    }
    Selector::OnEvent(pEvent);
}

IClassInfo* ARPSelector::Class = NULL;
HRESULT ARPSelector::Register()
{
    return ClassInfo<ARPSelector,Selector>::Register(L"ARPSelector", NULL, 0);
}

////////////////////////////////////////////////////////
// ARP Parser

HRESULT ARPParser::Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    ARPParser* ap = HNew<ARPParser>();
    if (!ap)
        return E_OUTOFMEMORY;
    
    HRESULT hr = ap->Initialize(paf, uRCID, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        ap->Destroy();
        return hr;
    }

    *ppParser = ap;

    return S_OK;
}

HRESULT ARPParser::Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB)
{
    _paf = paf;
    return Parser::Initialize(uRCID, hInst, pfnErrorCB);
}

Value* ARPParser::GetSheet(LPCWSTR pszResID)
{
    // All style sheet mappings go through here. Redirect sheet queries to appropriate
    // style sheets (i.e. themed or standard look). _pParserStyle points to the
    // appropriate stylesheet-only Parser instance
    return _paf->GetStyleParser()->GetSheet(pszResID);
}

////////////////////////////////////////////////////////
// ARP Parser callback

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

////////////////////////////////////////////////////////
// ARP entry point

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    HRESULT hr;

    g_hInstance = hInstance;
    
    LPWSTR pCL = NULL;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    ARPFrame* paf = NULL;
    Element* pe = NULL;

    WCHAR szTemp[1024];

    // DirectUI init process
    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    // Register ARP classes
    hr = ARPFrame::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPHelp::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSupportItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSelector::Register();
    if (FAILED(hr))
        goto Failure;

    // DirectUI init thread
    hr = InitThread();
    if (FAILED(hr))
        goto Failure;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        goto Failure;

    pCL = MultiByteToUnicode(lpCmdLine);
    if (!pCL)
        goto Failure;

    Element::StartDefer();

    // Create host
    LoadStringW(hInstance, IDS_ARPTITLE, szTemp, DUIARRAYSIZE(szTemp));

    hr = NativeHWNDHost::Create(szTemp, NULL, LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ARP)), CW_USEDEFAULT, CW_USEDEFAULT, 600, 450, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);
    if (FAILED(hr))
        goto Failure;   

    hr = ARPFrame::Create(pnhh, wcsstr(pCL, L"-db") == 0, (Element**)&paf);
    if (FAILED(hr))
        goto Failure;

    // Load tree resources
    ARPParser::Create(paf, IDR_ARP, hInstance, ARPParseError, &pParser);
    if (!pParser || pParser->WasParseError())
        goto Failure;

    pParser->CreateElement(L"main", paf, &pe);
    if (pe) // Fill contents using substitution
    {
        // Set ARPFrame state (incluing ID initialization)
        paf->Setup(pParser, 0);

        // Set visible and host
        paf->SetVisible(true);
        pnhh->Host(paf);

        Element::EndDefer();

        // Do initial show
        pnhh->ShowWindow();

        paf->UpdateInstalledItems();

        // Pump messages
        MSG msg;
        bool fDispatch = true;
        while (GetMessageW(&msg, 0, 0, 0) != 0)
        {
            // Check for destruction of top-level window (always async)
            if (msg.hwnd == pnhh->GetHWND() && msg.message == NHHM_ASYNCDESTROY)
            {
                // Async destroy requested, clean up secondary threads

                // Signal that secondary threads should complete as soon as possible
                // Any requests from secondary threads will be ignored
                // No more secondary threads will be allowed to start
                g_fRun = false;

                // Hide window, some threads may need more time to exit normally
                pnhh->HideWindow();

                // Don't dispatch this one
                if (!g_fAppShuttingDown)
                    fDispatch = false;
            }

            // Check for pending threads
            if (!g_fRun)
            {
                if (!ARPFrame::hRePopPubItemListThread && 
                    !ARPFrame::hUpdInstalledItemsThread)
                {
                    if (!g_fAppShuttingDown)
                    {
                        // Done, reissue async destroy
                        DUITrace(">> App shutting down, async destroying main window\n");
                        g_fAppShuttingDown = true;
                        pnhh->DestroyWindow();
                    }
                }
            }
        
            if (fDispatch)
            {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            else
                fDispatch = true;
        }

        // paf will be deleted by native HWND host when destroyed
    }
    else
        Element::EndDefer();

Failure:

    if (pnhh)
        pnhh->Destroy();
    if (pParser)
        pParser->Destroy();

    // Free command line
    if (pCL)
        HFree(pCL);

    CoUninitialize();
    UnInitThread();
    UnInitProcess();

    return 0;
}

DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy)
{
    return SHGetRestriction(NULL, L"Uninstall", pszPolicy);
}

bool _cdecl ARPIsOnDomain()
{
    // NOTE: assume it's on the domain 
    bool bRet = true;
    LPWSTR pszDomain;
    NETSETUP_JOIN_STATUS nsjs;
    
    if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
    {
        if (nsjs != NetSetupDomainName)
            bRet = FALSE;
        NetApiBufferFree(pszDomain);
    }
    return bRet;
}

////////////////////////////////////////////////////////
// Async ARP item population thread

////////////////////////////////////////////////////////
// Query system and enumerate installed apps
DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf)
{
    DUITrace(">> Thread 'hRePopPubItemListThread' STARTED.\n");

    HRESULT hr;
    UINT iCount = 0;
    IShellAppManager* pisam = NULL;
    IEnumPublishedApps* piepa = NULL;
    IPublishedApp* pipa = NULL;

    // Initialize
    CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    HDCONTEXT hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    if (g_fRun && !((ARPFrame*)paf)->GetPublishedComboFilled())
    {
        // Get the list of categories
        SHELLAPPCATEGORYLIST* psacl = ((ARPFrame*)paf)->GetShellAppCategoryList();
        if (psacl == NULL)
        {
            psacl = new SHELLAPPCATEGORYLIST; 
        }
        if (psacl == NULL)
        {
            goto Cleanup;
        }
        else
        {
            ((ARPFrame*)paf)->SetShellAppCategoryList(psacl);
        }
        hr = pisam->GetPublishedAppCategories(psacl);

        if (SUCCEEDED(hr))
        {
            ((ARPFrame*)paf)->PopulateCategoryCombobox();
            ((ARPFrame*)paf)->SetPublishedComboFilled(true);
        }
        else
        {
            delete psacl;
            ((ARPFrame*)paf)->SetShellAppCategoryList(NULL);
        }        
    }
    
    if (g_fRun)
    {
        hr = pisam->EnumPublishedApps(((ARPFrame*)paf)->GetCurrentPublishedCategory(), &piepa);
        HRCHK(hr);
    }

    while (g_fRun)
    {
        hr = piepa->Next(&pipa);
        
        if (hr == S_FALSE)  // Done with enumeration
            break;
        iCount++;
        ((ARPFrame*)paf)->InsertPublishedItem(pipa);
    }
    if (iCount == 0)
    {
        ((ARPFrame*)paf)->FeedbackEmptyPublishedList();
    }

    // Thread is done, set back to NULL here so that OnPublishedListComplete
    // is allowed to start as a result of deferring
    ARPFrame::hRePopPubItemListThread = NULL;

    if (g_fRun)
    {
        ((ARPFrame*)paf)->OnPublishedListComplete();
        ((ARPFrame*)paf)->SetPublishedListFilled(true);
    }
    
Cleanup:

    if (pisam)
        pisam->Release();
    if (piepa)
        piepa->Release();

    if (hctx)
        DeleteHandle(hctx);
        
    CoUninitialize();

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'hRePopPubItemListThread' DONE.\n");

    return 0;
}

DWORD WINAPI PopulateInstalledItemList(void* paf)
{
    DUITrace(">> Thread 'hUpdInstalledItemsThread' STARTED.\n");

    IShellAppManager* pisam = NULL;
    IEnumInstalledApps* pieia = NULL;
    IInstalledApp* piia = NULL;
    DWORD dwAppCount = 0;
    APPINFODATA aid = {0};

    // Initialize
    CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    HDCONTEXT hctx = InitGadgets(&ig);

    if (hctx == NULL) {
        goto Cleanup;
    }

    HRESULT hr;

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Count installed apps, IShellAppManager::GetNumberofInstalledApps() not impl
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        dwAppCount++;
    }

    // IEnumInstalledApps::Reset() doesn't work
    pieia->Release();
    pieia = NULL;
    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Set app count in frame
    ((ARPFrame*)paf)->SetInstalledItemCount(dwAppCount);

    // Enumerate apps
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        // Insert item
        ((ARPFrame*)paf)->InsertInstalledItem(piia);
    }

Cleanup:

    if (pisam)
        pisam->Release();
    if (pieia)
        pieia->Release();

    if (hctx)
        DeleteHandle(hctx);

    CoUninitialize();

    if (g_fRun)
        ((ARPFrame*)paf)->FlushWorkingSet();

    ARPFrame::hUpdInstalledItemsThread = NULL;        

    DUITrace(">> Thread 'hUpdInstalledItemsThread' DONE.\n");

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    return 0;
}

// Sorting
int __cdecl CompareElementDataName(const void* pA, const void* pB)
{
    Value* pvName1;
    Value* pvName2;
    LPCWSTR pszName1 = (*(ARPItem**)pA)->FindDescendent(ARPItem::_idTitle)->GetContentString(&pvName1);
    LPCWSTR pszName2 = (*(ARPItem**)pB)->FindDescendent(ARPItem::_idTitle)->GetContentString(&pvName2);

   int result;
   if (pszName1 && pszName2)
       result = StrCmpW(pszName1, pszName2);
   else
       result = pszName1 ? 1 : -1;

   pvName1->Release();
   pvName2->Release();

   return result;
}
int __cdecl CompareElementDataSize(const void* pA, const void* pB)
{
    ULONGLONG ull1 = (*(ARPItem**)pA)->_ullSize;
    ULONGLONG ull2 = (*(ARPItem**)pB)->_ullSize;
    if (!IsValidSize(ull1))
        ull1 = 0;
    if (!IsValidSize(ull2))
        ull2 = 0;

    // Big apps come before smaller apps
    if (ull1 > ull2)
        return -1;
    else if (ull1 < ull2)
        return 1;

    return   CompareElementDataName(pA, pB);
}
int __cdecl CompareElementDataFreq(const void* pA, const void* pB)
{
    // Rarely used apps come before frequently used apps.  Blank
    // (unknown) apps go last.  Unknown apps are -1, so those sort
    // to the bottom if we simply compare unsigned values.
    UINT u1 = (UINT)(*(ARPItem**)pA)->_iTimesUsed;
    UINT u2 = (UINT)(*(ARPItem**)pB)->_iTimesUsed;

   if (u1 < u2)
       return -1;
   else if (u1 > u2)
       return 1;
   return   CompareElementDataName(pA, pB);

}

int __cdecl CompareElementDataLast(const void* pA, const void* pB)
{
   FILETIME ft1 = (*(ARPItem**)pA)->_ftLastUsed;
   FILETIME ft2 = (*(ARPItem**)pB)->_ftLastUsed;

   BOOL bTime1 = IsValidFileTime(ft1);
   BOOL bTime2 = IsValidFileTime(ft2);

   if (!bTime1 || !bTime2)
   {
       if (bTime1)
           return -1;
       if (bTime2)
           return 1;
       // else they're both not set -- use name
   }
   else
   {
       LONG diff = CompareFileTime(&ft1, &ft2);
       if (diff)
           return diff;
   }

   return   CompareElementDataName(pA, pB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\arp\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_APP_STDAFX_H_INCLUDED
#define DUI_APP_STDAFX_H_INCLUDED

#pragma once

// Test warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <math.h>

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// Application headers
#include <ocidl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <lm.h>
// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
#include <directui.h>

#endif // DUI_APP_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\duipad\duipad.cpp ===
// DUIPad.cpp : DirectUI 
//

#include "stdafx.h"

#include "resource.h"

using namespace DirectUI;

// Using ALL controls
UsingDUIClass(Element);
UsingDUIClass(HWNDElement);

UsingDUIClass(Button);
UsingDUIClass(Edit);
UsingDUIClass(Progress);
UsingDUIClass(RefPointElement);
UsingDUIClass(RepeatButton);
UsingDUIClass(ScrollBar);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Selector);
UsingDUIClass(Thumb);
UsingDUIClass(Viewer);

////////////////////////////////////////////////////////
// PadFrame
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
// Frame declaration

class PadFrame : public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, OUT Element** ppElement);

    void Setup(HINSTANCE hInst);
    void Refresh();

    virtual void OnInput(InputEvent* pie);
    virtual void OnEvent(Event* pEvent);

    static void CALLBACK ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

    Element* GetEdit() { return _peEdit; }

    static HINSTANCE s_hInst;

    PadFrame() { }
    virtual ~PadFrame() { }
    HRESULT Initialize(NativeHWNDHost* pnhh) { return HWNDElement::Initialize(pnhh->GetHWND(), true, 0); }

private:
    Edit* _peEdit;
    Element* _peContainer;
    Element* _peStatus;
    Element* _peMarkupBox;

    static WCHAR _szParseError[];
    static int _dParseError;

public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

HINSTANCE PadFrame::s_hInst = NULL;

////////////////////////////////////////////////////////
// Frame construction

HRESULT PadFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT PadFrame::Create(NativeHWNDHost* pnhh, OUT Element** ppElement)
{
    *ppElement = NULL;

    PadFrame* ppf = HNew<PadFrame>();
    if (!ppf)
        return E_OUTOFMEMORY;

    HRESULT hr = ppf->Initialize(pnhh);
    if (FAILED(hr))
    {
        ppf->Destroy();
        return hr;
    }

    *ppElement = ppf;

    return S_OK;
}

///////////////////////////////////////////////////////
// Frame initialization

void PadFrame::Setup(HINSTANCE hInst)
{
    // Within a defer cycle

    // Initialize members
    _peStatus = FindDescendent(StrToID(L"status"));
    _peContainer = FindDescendent(StrToID(L"container"));
    _peEdit = (Edit*)FindDescendent(StrToID(L"edit"));
    _peMarkupBox = FindDescendent(StrToID(L"markupbox"));

    DUIAssert(_peStatus && _peContainer && _peEdit, "Error in persisted UI file");

    // Load sample UI file

    // Locate resource
    WCHAR szID[41];
    swprintf(szID, L"#%u", IDR_SAMPLEUI);

    HRSRC hResInfo = FindResourceW(hInst, szID, L"UIFile");
    DUIAssert(hResInfo, "Unable to locate resource");

    if (hResInfo)
    {
        HGLOBAL hResData = LoadResource(hInst, hResInfo);
        DUIAssert(hResData, "Unable to load resource");

        if (hResData)
        {
            const CHAR* pBuffer = (const CHAR*)LockResource(hResData);
            DUIAssert(pBuffer, "Resource could not be locked");

            // Resource data ready, load into edit control
            // NOTE: Resource has terminating NULL as last character, this must always be the case
            LPWSTR pTextW = MultiByteToUnicode(pBuffer, SizeofResource(hInst, hResInfo) / sizeof(CHAR));
            if (pTextW)
            {
                _peEdit->SetContentString(pTextW);
                HFree(pTextW);

                // Reload display
                Refresh();

                // Instructions
                _peStatus->SetContentString(L"Enter UI Markup (F5=Refresh, F6/F7=Font Size)");
            }
        }
    }
}

////////////////////////////////////////////////////////
// System events

void PadFrame::OnInput(InputEvent* pie)
{
    if (pie->nStage == GMF_DIRECT || pie->nStage == GMF_BUBBLED)
    {
        if (pie->nDevice == GINPUT_KEYBOARD)
        {
            KeyboardEvent* pke = (KeyboardEvent*)pie;

            if (pke->nCode == GKEY_DOWN)
            {
                switch (pke->ch)
                {
                case VK_F5:     // Refresh
                    Refresh();              

                    pie->fHandled = true;
                    return;

                case VK_F6:     // Font size down
                case VK_F7:     // Font size up
                    {
                        // Will be negative (point size character height)
                        int dFS = _peEdit->GetFontSize();

                        if (pke->ch == VK_F6)
                        {
                            dFS += 1;
                            if (dFS > -1)
                                dFS = -1;
                        }
                        else
                            dFS -= 1;

                        _peEdit->SetFontSize(dFS);

                        pie->fHandled = true;
                        return;
                    }
                }
            }
        }
    }

    HWNDElement::OnInput(pie);
}

void PadFrame::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Thumb::Drag)
        {
            ThumbDragEvent* ptde = (ThumbDragEvent*)pEvent;

            // Markup box is using a local Width, layout will honor it
            int cx = _peMarkupBox->GetWidth();
            cx += ptde->sizeDelta.cx;

            if (cx < 10)
                cx = 10;
            else if (cx > GetWidth()-20)  // Frame is also using local Width for size
                cx = GetWidth()-20;

            _peMarkupBox->SetWidth(cx);
        }
    }

    HWNDElement::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// Refresh display

WCHAR PadFrame::_szParseError[201];
int PadFrame::_dParseError;

void PadFrame::ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    if (dLine != -1)
        swprintf(_szParseError, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(_szParseError, L"%s '%s'", pszError, pszToken);

    _dParseError = dLine;
}

void PadFrame::Refresh()
{
    StartDefer();

    // Remove all children from container
    _peContainer->DestroyAll();

    Value* pv;

    // Parse text from Edit control
    LPCWSTR pTextW = _peEdit->GetContentString(&pv);

    // Convert to single byte for parser
    LPSTR pText = UnicodeToMultiByte(pTextW);
    if (pText)
    {
        *_szParseError = NULL;
        _dParseError = 0;

        Parser* pParser;
        HRESULT hr = Parser::Create(pText, (int)strlen(pText), s_hInst, ParseError, &pParser);
        
        if (SUCCEEDED(hr))
        {
            Element* pe;
            pParser->CreateElement(L"main", NULL, &pe);
            if (!pe)
                _peStatus->SetContentString(L"Unable to locate 'main' resource.");
            else
            {
                _peContainer->Add(pe);

                _peStatus->SetContentString(L"Parse successful!");
            }

            pParser->Destroy();
        }
        else
        {
            _peStatus->SetContentString(_szParseError);

            // Position caret where error is
            if (_dParseError != -1)
            {
                int dCharIndex = (int)SendMessageW(_peEdit->GetHWND(), EM_LINEINDEX, _dParseError - 1, 0);

                if (dCharIndex != -1)
                    SendMessageW(_peEdit->GetHWND(), EM_SETSEL, dCharIndex, dCharIndex + 1);
            }
        }

        HFree(pText);
    }

    pv->Release();

    EndDefer();
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* PadFrame::Class = NULL;

HRESULT PadFrame::Register()
{
    return ClassInfo<PadFrame,HWNDElement>::Register(L"PadFrame", NULL, 0);
}

////////////////////////////////////////////////////////
// DUIPad entry point

void CALLBACK PE(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR szParseError[201];
    if (dLine != -1)
        swprintf(szParseError, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(szParseError, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, szParseError, L"Dude", MB_OK);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    HRESULT hr;

    LPWSTR pCL = NULL;

    PadFrame::s_hInst = hInstance;

    NativeHWNDHost* pnhh = NULL;
    PadFrame* ppf = NULL;
    Parser* pParser = NULL;
    Element* pe = NULL;

    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    hr = PadFrame::Register();
    if (FAILED(hr))
        goto Failure;

    // DirectUI init thread in caller
    hr = InitThread();
    if (FAILED(hr))
        goto Failure;

    pCL = MultiByteToUnicode(lpCmdLine);

    Element::StartDefer();

    // Create native host
    NativeHWNDHost::Create(L"DUIPad", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 800, 600, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);

    // HWND Root
    hr = PadFrame::Create(pnhh, (Element**)&ppf);
    if (FAILED(hr))
        return 0;

    // Fill content of frame (using substitution)
    hr = Parser::Create(IDR_DUIPADUI, hInstance, PE, &pParser);
    if (FAILED(hr))
        goto Failure;

    pParser->CreateElement(L"duipad", ppf, &pe);

    // Done with parser
    pParser->Destroy();
    pParser = NULL;

    ppf->Setup(hInstance);

    // Set visible and host
    ppf->SetVisible(true);
    pnhh->Host(ppf);

    Element::EndDefer();

    // Do initial show
    pnhh->ShowWindow();

    ppf->GetEdit()->SetKeyFocus();

    // Pump messages
    StartMessagePump();

Failure:

    if (pParser)
        pParser->Destroy();

    if (pnhh)
        pnhh->Destroy();

    // Free command line
    if (pCL)
        HFree(pCL);

    // DirectUI uninit thread
    UnInitThread();
    UnInitProcess();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\hello\hello.cpp ===
// Hello.cpp : DirectUI 
//

#include "stdafx.h"

#include "resource.h"

using namespace DirectUI;

#include "HWNDContainer.h"

class Hello : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    virtual void OnEvent(Event* pEvent);

    Hello() { }
    virtual ~Hello() { }

public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

HRESULT Hello::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Hello* ph = HNew<Hello>();
    if (!ph)
        return E_OUTOFMEMORY;

    HRESULT hr = ph->Initialize(0);
    if (FAILED(hr))
    {
        ph->Destroy();
        return hr;
    }

    *ppElement = ph;

    return S_OK;
}

void Hello::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            Value* pvChildren;

            ElementList* pel = GetChildren(&pvChildren);

            pel->GetItem(0)->SetContentString(L"Wassup!");

            DirectUI::NotifyAccessibilityEvent(EVENT_OBJECT_VALUECHANGE, pel->GetItem(0));

            pvChildren->Release();
        }
    }

    Element::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
// Define class info with type and base type, set static class pointer
IClassInfo* Hello::Class = NULL;
HRESULT Hello::Register()
{
    return ClassInfo<Hello,Element>::Register(L"Hello", NULL, 0);
}

////////////////////////////////////////////////////////
// Hello entry point

void CALLBACK ParserError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR szParseError[201];
    if (dLine != -1)
        swprintf(szParseError, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(szParseError, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, szParseError, L"Dude", MB_OK);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    HRESULT hr;

    Parser* pParser = NULL;
    HWNDContainer* phc = NULL;

    // DirectUI init process
    if (FAILED(InitProcess()))
        goto Failure;

    // Register classes
    if (FAILED(HWNDContainer::Register()))
        goto Failure;
    
    if (FAILED(Hello::Register()))
        goto Failure;

    // DirectUI init thread
    if (FAILED(InitThread()))
        goto Failure;

    Element::StartDefer();

    Parser::Create(IDR_Hello, hInstance, ParserError, &pParser);
    if (!pParser)
        goto Failure;

    if (!pParser->WasParseError())
    {
        // Create host (top-level HWND with a contained HWNDElement)
        hr = HWNDContainer::Create(L"Hello", 0, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL, &phc);
        if (FAILED(hr))
            goto Failure;
    
        Element* pe;
        hr = pParser->CreateElement(L"main", NULL, &pe);
        if (FAILED(hr))
            goto Failure;

        hr = phc->Add(pe);
        if (FAILED(hr))
            goto Failure;

        phc->Show(nCmdShow);
    }

    Element::EndDefer();

    StartMessagePump();

Failure:

    // phc (and entire tree) destroyed when top-level HWND destroyed

    if (pParser)
        pParser->Destroy();

    UnInitThread();
    UnInitProcess();

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\hello\hwndcontainer.h ===
// ----------------------------------------------------------------
//
//  Generic HWNDContainer
//
//   in terms of translating to message tables, just ignore this;
//   assume it's just a class coming out of DUI like Button
//
// ----------------------------------------------------------------

class HWNDContainer : public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(LPWSTR lpszTitle, DWORD dwExStyle, DWORD dwStyle, int x, int y, int cx, int cy, HMENU hMenu, HWND hwndParent, HINSTANCE hInstance, VOID* lpCreateParams, OUT HWNDContainer** pphc);

    void Show(int nCmdShow);

    static HRESULT Create(NativeHWNDHost* pnhh, OUT Element** pphc);

    HWNDContainer() { }
    virtual ~HWNDContainer() { if (_pnhh) _pnhh->Destroy(); }
    HRESULT Initialize(NativeHWNDHost* pnhh) { return HWNDElement::Initialize(pnhh->GetHWND(), true, 0); }

private:
    NativeHWNDHost* _pnhh;

public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

////////////////////////////////////////////////////////
// Frame construction

HRESULT HWNDContainer::Create(LPWSTR lpszTitle, DWORD dwExStyle, DWORD dwStyle, int x, int y, int cx, int cy, HMENU hMenu, HWND hwndParent, HINSTANCE hInstance, VOID* lpCreateParams, OUT HWNDContainer** pphc)
{
    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(dwExStyle);
    UNREFERENCED_PARAMETER(hMenu);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpCreateParams);

    // Create native host
    NativeHWNDHost* pnhh;
    
    HRESULT hr = NativeHWNDHost::Create(lpszTitle, hwndParent, NULL, x, y, cx, cy, dwExStyle, dwStyle, 0, &pnhh);

    if (FAILED(hr))
        return hr;

    // HWND Root
    hr = HWNDContainer::Create(pnhh, (Element**)pphc);

    if (FAILED(hr))
    {
        pnhh->Destroy();
        return hr;
    }

    // Set visible and host
    (*pphc)->SetVisible(true);
    pnhh->Host(*pphc);
    
    return S_OK;
}

HRESULT HWNDContainer::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT HWNDContainer::Create(NativeHWNDHost* pnhh, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDContainer* phc = HNew<HWNDContainer>();
    if (!phc)
        return E_OUTOFMEMORY;

    HRESULT hr = phc->Initialize(pnhh);
    if (FAILED(hr))
        return hr;

    phc->_pnhh = pnhh;

    FillLayout* pfl;
    hr = FillLayout::Create((Layout **) &pfl);
    if (FAILED(hr))
    {
        phc->Destroy();
        return hr;
    }
    phc->SetLayout(pfl);

    *ppElement = phc;
    
    return S_OK;
}

void HWNDContainer::Show(int nCmdShow)
{
    UNREFERENCED_PARAMETER(nCmdShow);

    if (_pnhh)
        _pnhh->ShowWindow();
}


////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDContainer::Class = NULL;
HRESULT HWNDContainer::Register()
{
    return ClassInfo<HWNDContainer,HWNDElement>::Register(L"HWNDContainer", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\hello\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Hello.rc
//

#define IDR_Hello        1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\duipad\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by duipad.rc
//

#define IDR_DUIPADUI        1000
#define IDR_SAMPLEUI        1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\duipad\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_APP_STDAFX_H_INCLUDED
#define DUI_APP_STDAFX_H_INCLUDED

#pragma once

// Test warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <math.h>

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// Application headers
#include <ocidl.h>
#include <shellapi.h>
#include <shlwapi.h>

// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
#include <directui.h>

#endif // DUI_APP_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\hello\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_APP_STDAFX_H_INCLUDED
#define DUI_APP_STDAFX_H_INCLUDED

#pragma once

// Test warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <math.h>

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// Application headers
#include <ocidl.h>
#include <shellapi.h>
#include <shlwapi.h>

// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

#endif // DUI_APP_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\logonui\logon.cpp ===
// Logon.cpp : Windows Logon application
//

#include "priv.h"

using namespace DirectUI;

#include "logon.h"
#include "resource.h"

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(ScrollBar);
UsingDUIClass(Selector);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Edit);

// Globals

LogonFrame* g_plf = NULL;

// Resource string loading
LPCWSTR LoadResString(UINT nID)
{
    static WCHAR szRes[101];
    szRes[0] = NULL;
    LoadStringW(g_plf->GetHInstance(), nID, szRes, DUIARRAYSIZE(szRes) - 1);
    return szRes;
}

// Add all user accounts
HRESULT BuildAccountList(LogonFrame* plf)
{
    HRESULT hr;

    // Accounts to list

    // Test data
    hr = plf->AddAccount(MAKEINTRESOURCEW(IDB_USER0), TRUE, L"Mark Finocchio", L"MarkFi", L"What's my dog's name?", TRUE, TRUE);
    if (FAILED(hr))
        goto Failure;

    hr = plf->AddAccount(MAKEINTRESOURCEW(IDB_USER1), TRUE, L"Jeff Stall", L"JStall", L"What day is today?", TRUE, FALSE);
    if (FAILED(hr))
        goto Failure;

    hr = plf->AddAccount(MAKEINTRESOURCEW(IDB_USER2), TRUE, L"Dwayne Need", L"DwayneN", L"", TRUE, TRUE);
    if (FAILED(hr))
        goto Failure;

    hr = plf->AddAccount(MAKEINTRESOURCEW(IDB_USER3), TRUE, L"Jeff Bodgan", L"JeffBog", L"", TRUE, FALSE);
    if (FAILED(hr))
        goto Failure;

    hr = plf->AddAccount(MAKEINTRESOURCEW(IDB_USER4), TRUE, L"Gerardo Bermudez", L"GerardoB", L"Forget it!", FALSE, FALSE);
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}

////////////////////////////////////////////////////////
//
// LogonFrame
//
////////////////////////////////////////////////////////


int LogonFrame::_nDPI = 0;

HRESULT LogonFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT LogonFrame::Create(HWND hParent, BOOL fDblBuffer, UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    LogonFrame* plf = HNew<LogonFrame>();
    if (!plf)
        return E_OUTOFMEMORY;

    HRESULT hr = plf->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        plf->Destroy();
        return hr;
    }

    *ppElement = plf;

    return S_OK;
}

HRESULT LogonFrame::Initialize(HWND hParent, BOOL fDblBuffer, UINT nCreate)
{
    // Zero-init members
    _peAccountList = NULL;
    _peRightPanel = NULL;
    _pbPower = NULL;
    _pbUndock = NULL;
    _peHelp = NULL;
    _pParser = NULL;

    // Do base class initialization
    HRESULT hr;
    HDC hDC = NULL;

    hr = HWNDElement::Initialize(hParent, fDblBuffer ? true : false, nCreate);
    if (FAILED(hr))
    {
        return hr;
        goto Failure;
    }

    // Initialize
    hDC = GetDC(NULL);
    _nDPI = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    hr = SetActive(AE_MouseAndKeyboard);
    if (FAILED(hr))
        goto Failure;

    // TODO: Additional LogonFrame initialization code here

    return S_OK;


Failure:

    return hr;
}

LogonFrame::~LogonFrame()
{
    // TODO: Frame destruction cleanup
}

// Tree is ready. Upon failure, exit which will casuse the app to shutdown
HRESULT LogonFrame::OnTreeReady(Parser* pParser)
{
    HRESULT hr;

    // Cache
    _pParser = pParser;

    // Cache important descendents
    _peAccountList = (Selector*)FindDescendent(StrToID(L"accountlist"));
    DUIAssert(_peAccountList, "Cannot find account list, check the UI file");
    if (_peAccountList == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peRightPanel = (Selector*)FindDescendent(StrToID(L"rightpanel"));
    DUIAssert(_peRightPanel, "Cannot find account list, check the UI file");
    if (_peRightPanel == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbPower = (Button*)FindDescendent(StrToID(L"power"));
    DUIAssert(_pbPower, "Cannot find account list, check the UI file");
    if (_pbPower == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbUndock = (Button*)FindDescendent(StrToID(L"undock"));
    DUIAssert(_pbPower, "Cannot find account list, check the UI file");
    if (_pbUndock == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peHelp = (Button*)FindDescendent(StrToID(L"help"));
    DUIAssert(_peHelp, "Cannot find account list, check the UI file");
    if (_peHelp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // Setup frame labels
    SetPowerButtonLabel(LoadResString(IDS_POWER));
    SetUndockButtonLabel(LoadResString(IDS_UNDOCK));

    return S_OK;


Failure:

    return hr;
}

// Generic events
void LogonFrame::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_BUBBLED)  // Bubbled events
    {
        if (pEvent->uidType == Button::Click)
        {
            if (pEvent->peTarget == _pbPower)
            {
                // Power button pressed
                OnPower();

                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbUndock)
            {
                // Undock button pressed
                OnUndock();

                pEvent->fHandled = true;
                return;
            }
        }
    }

    HWNDElement::OnEvent(pEvent);
}

// System events

// Watch for input events. If the frame receives them, unselect the list and set keyfocus to it
void LogonFrame::OnInput(InputEvent* pEvent)
{
    if (pEvent->nStage == GMF_DIRECT || pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->nDevice == GINPUT_KEYBOARD)
        {
             KeyboardEvent* pke = (KeyboardEvent*)pEvent;
             if ((pke->nCode == GKEY_DOWN) && (pke->ch == VK_ESCAPE))
             {
                 SetKeyFocus();
                 pEvent->fHandled = true;
                 return;
             }
        }
    }

    HWNDElement::OnInput(pEvent);
}

void LogonFrame::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(KeyFocused))
    {
        if (pvNew->GetBool())
        {
            // Unselect items from account list if pressed on background
            _peAccountList->SetSelection(NULL);
        }
    }

    HWNDElement::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

Element* LogonFrame::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    Element* peFound = HWNDElement::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);

    if (peFound == this)
    //if ((peFound == this) && peFrom)
    {
        // Don't let the frame show up in the tab order. Just repeat the search when we encounter the frame
        return HWNDElement::GetAdjacent(this, iNavDir, pnr, bKeyable);
    }

    return peFound;
}

// Add an account to the frame list
HRESULT LogonFrame::AddAccount(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint,
        BOOL fPwdNeeded, BOOL fLoggedOn)
{
    HRESULT hr;
    LogonAccount* pla = NULL;

    if (!_pParser)
    {
        hr = E_FAIL;
        goto Failure;
    }

    // Build up an account and insert into selection list
    hr = _pParser->CreateElement(L"accountitem", NULL, (Element**)&pla);
    if (FAILED(hr))
        goto Failure;

    hr = pla->OnTreeReady(pszPicture, fPicRes, pszName, pszUsername, pszHint, fPwdNeeded, fLoggedOn, GetHInstance());
    if (FAILED(hr))
        goto Failure;

    hr = _peAccountList->Add(pla);
    if (FAILED(hr)) 
        goto Failure;

    return S_OK;


Failure:

    return hr;
}

// Passed authentication, log user on
HRESULT LogonFrame::OnLogUserOn(LogonAccount* pla)
{
    StartDefer();

    // Set keyfocus back to frame so it isn't pushed anywhere when controls are removed.
    // This will also cause a remove of the password panel from the current account
    SetKeyFocus();

    // Disable status so that it can't be clicked on anymore
    pla->DisableStatus(0);
    pla->DisableStatus(1);

    // Clear list of logon accounts except the one logging on
    Value* pvChildren;
    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        LogonAccount* peAccount;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);

            if (peAccount != pla)
            {
                peAccount->SetLayoutPos(LP_None);
                peAccount->SetLogonState(LS_Denied);
            }
            else
            {
                peAccount->SetLogonState(LS_Granted);
                peAccount->InsertStatus(0);
                peAccount->SetStatus(0, LoadResString(IDS_APPLYSETTINGS));
                peAccount->RemoveStatus(1);
            }

            // Account account items are disabled
            peAccount->SetEnabled(false);
        }
    }
    pvChildren->Release();

    // Hide option buttons
    HidePowerButton();
    HideUndockButton();

    // Set frame status
    SetStatus(LoadResString(IDS_LOGGINGON));

    EndDefer();

    // TODO: Add logon specific code
    DUITrace("LogonUI: LogonFrame::OnLogUserOn()\n");

    return S_OK;
}

HRESULT LogonFrame::OnPower()
{
    DUITrace("LogonUI: LogonFrame::OnPower()\n");

    return S_OK;
}

HRESULT LogonFrame::OnUndock()
{
    DUITrace("LogonUI: LogonFrame::OnUndock()\n");

    return S_OK;
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* LogonFrame::Class = NULL;
HRESULT LogonFrame::Register()
{
    return ClassInfo<LogonFrame,HWNDElement>::Register(L"LogonFrame", NULL, 0);
}

////////////////////////////////////////////////////////
//
// LogonAccount
//
////////////////////////////////////////////////////////

ATOM LogonAccount::idPwdGo = NULL;
ATOM LogonAccount::idPwdInfo = NULL;
Element* LogonAccount::_pePwdPanel = NULL;
Edit* LogonAccount::_pePwdEdit = NULL;
Button* LogonAccount::_pbPwdInfo = NULL;

HRESULT LogonAccount::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    LogonAccount* pla = HNew<LogonAccount>();
    if (!pla)
        return E_OUTOFMEMORY;

    HRESULT hr = pla->Initialize();
    if (FAILED(hr))
    {
        pla->Destroy();
        return hr;
    }

    *ppElement = pla;

    return S_OK;
}

HRESULT LogonAccount::Initialize()
{
    // Zero-init members
    _pbStatus[0] = NULL;
    _pbStatus[1] = NULL;
    _pvUsername = NULL;
    _pvHint = NULL;
    _fPwdNeeded = FALSE;
    _fLoggedOn = FALSE;
    _fHasPwdPanel = FALSE;

    // Do base class initialization
    HRESULT hr = Button::Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
        goto Failure;

    // Initialize

    // TODO: Additional LogonAccount initialization code here

    return S_OK;


Failure:

    return hr;
}

LogonAccount::~LogonAccount()
{
    // Free resources
    if (_pvUsername)
    {
        _pvUsername->Release();
        _pvUsername = NULL;
    }

    if (_pvHint)
    {
        _pvHint->Release();
        _pvHint = NULL;
    }

    // TODO: Account destruction cleanup
}

// Tree is ready
HRESULT LogonAccount::OnTreeReady(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint,
    BOOL fPwdNeeded, BOOL fLoggedOn, HINSTANCE hInst)
{
    HRESULT hr;
    Element* pePicture = NULL;
    Element* peName = NULL;
    Value* pv = NULL;

    StartDefer();

    // Cache important descendents
    _pbStatus[0] = (Button*)FindDescendent(StrToID(L"status0"));
    DUIAssert(_pbStatus[0], "Cannot find account list, check the UI file");
    if (_pbStatus[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbStatus[1] = (Button*)FindDescendent(StrToID(L"status1"));
    DUIAssert(_pbStatus[1], "Cannot find account list, check the UI file");
    if (_pbStatus[1] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // Locate descendents and populate
    pePicture = FindDescendent(StrToID(L"picture"));
    DUIAssert(pePicture, "Cannot find account list, check the UI file");
    if (pePicture == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // CreateGraphic handles NULL bitmaps
    pv = Value::CreateGraphic(pszPicture, GRAPHIC_NoBlend, 0, (USHORT)LogonFrame::RelPixToPixel(48), (USHORT)LogonFrame::RelPixToPixel(48), (fPicRes) ? hInst : 0);
    if (!pv)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    hr = pePicture->SetValue(Element::ContentProp, PI_Local, pv);
    if (FAILED(hr))
        goto Failure;

    pv->Release();
    pv = NULL;

    // Name
    peName = FindDescendent(StrToID(L"username"));
    DUIAssert(peName, "Cannot find account list, check the UI file");
    if (peName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    hr = peName->SetContentString(pszName);
    if (FAILED(hr))
        goto Failure;

    // Store members, will be released in destructor
    if (pszUsername)
    {
        _pvUsername = Value::CreateString(pszUsername);
        if (!_pvUsername)
        {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }
    }

    if (pszHint)
    {
        _pvHint = Value::CreateString(pszHint);
        if (!_pvHint)
        {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }
    }

    _fPwdNeeded = fPwdNeeded;
    _fLoggedOn = fLoggedOn;

    // Test data
    if (_fLoggedOn)
    {
        InsertStatus(0);
        SetStatus(0, LoadResString(IDS_LOGGEDON));
        InsertStatus(1);
        SetStatus(1, LoadResString(IDS_PROGRAMSRUNNING));
    }

    if (!_fPwdNeeded)
    {
        InsertStatus(1);
        SetStatus(1, LoadResString(IDS_PROGRAMSRUNNING));
    }

    EndDefer();

    return S_OK;


Failure:

    EndDefer();

    if (pv)
        pv->Release();

    return hr;
}

// Generic events
void LogonAccount::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_DIRECT)  // Direct events
    {
        // Watch for click events initiated by LogonAccounts only
        // if we are not logging someone on
        if (pEvent->uidType == Button::Click)
        {
            if (pEvent->peTarget == this)
            {
                if (!_fPwdNeeded)
                {
                    // No password needed, attempt logon
                    OnAuthenticateUser();
                }

                pEvent->fHandled = true;
                return;
            }
        }
    }
    else if (pEvent->nStage == GMF_BUBBLED)  // Bubbled events
    {
        if (pEvent->uidType == Button::Click)
        {
            if (pEvent->peTarget->GetID() == idPwdGo)
            {
                // Attempt logon
                OnAuthenticateUser();
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget->GetID() == idPwdInfo)
            {
                // Retrieve hint
                OnHintSelect();
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbStatus[0])
            {
                // Retrieve status info
                OnStatusSelect(0);
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbStatus[1])
            {
                // Retrieve status info
                OnStatusSelect(1);
                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Edit::Enter)
        {
            if (pEvent->peTarget == _pePwdEdit)
            {
                // Attempt logon
                OnAuthenticateUser();
                pEvent->fHandled = true;
                return;
            }
        }
    }

    Button::OnEvent(pEvent);
}

// System events
void LogonAccount::OnInput(InputEvent* pEvent)
{
    Button::OnInput(pEvent);
}

void LogonAccount::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selected))
    {
        if (pvNew->GetBool())
            InsertPasswordPanel();
        else
            RemovePasswordPanel();
    }

    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

HRESULT LogonAccount::InsertPasswordPanel()
{
    HRESULT hr;

    // If already have it, or no password is available, or logon state is not pending
    if (_fHasPwdPanel || !_fPwdNeeded || GetLogonState() != LS_Pending)
        goto Done;

    StartDefer();

    // Add password panel
    hr = Add(_pePwdPanel);
    if (FAILED(hr))
    {
        EndDefer();
        goto Failure;
    }

    _fHasPwdPanel = TRUE;

    // Hide hint button if no hint provided
    if (_pvHint && *(_pvHint->GetString()) != NULL)
        _pbPwdInfo->SetVisible(true);
    else
        _pbPwdInfo->SetVisible(false);

    // Hide status text (do not remove or insert)
    HideStatus(0);
    HideStatus(1);

    // Push focus to edit control
    _pePwdEdit->SetKeyFocus();

    EndDefer();

Done:

    return S_OK;

Failure:

    return hr;
}

HRESULT LogonAccount::RemovePasswordPanel()
{
    HRESULT hr;

    if (!_fHasPwdPanel)
        goto Done;

    StartDefer();

    // Remove password panel
    hr = Remove(_pePwdPanel);
    if (FAILED(hr))
    {
        EndDefer();
        goto Failure;
    }

    // Clear out edit control
    _pePwdEdit->SetContentString(L"");

    // Unhide status text
    ShowStatus(0);
    ShowStatus(1);

    _fHasPwdPanel = FALSE;

    EndDefer();

Done:

    return S_OK;

Failure:
    
    return hr;
}

// User is attempting to log on
void LogonAccount::OnAuthenticateUser()
{
    // Logon requested on this account

    // TODO: Validate
    DUITrace("LogonUI: LogonAccount::OnAuthenticateUser(%S)\n", _pvUsername ? _pvUsername->GetString() : L"<nousrname>");

    // On success, log user on
    g_plf->OnLogUserOn(this);
}

// User requires a hint (pressed the hint button)
void LogonAccount::OnHintSelect()
{
    DUITrace("LogonUI: LogonAccount::OnHintSelect(%S:'%S')\n", _pvUsername ? _pvUsername->GetString() : L"<nousrname>", 
        _pvHint ? _pvHint->GetString() : L"<nohint>");
}

// User pressed the status button
void LogonAccount::OnStatusSelect(UINT nLine)
{
    DUITrace("LogonUI: LogonAccount::OnStatusSelect(Line: %d, %S)\n", nLine, _pvUsername ? _pvUsername->GetString() : L"<nousrname>");
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// LogonState property
static int vvLogonState[] = { DUIV_INT, -1 };
static PropertyInfo impLogonStateProp = { L"LogonState", PF_Normal, 0, vvLogonState, NULL, Value::pvIntZero /*LS_Pending*/ };
PropertyInfo* LogonAccount::LogonStateProp = &impLogonStateProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                LogonAccount::LogonStateProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* LogonAccount::Class = NULL;
HRESULT LogonAccount::Register()
{
    return ClassInfo<LogonAccount,Button>::Register(L"LogonAccount", _aPI, DUIARRAYSIZE(_aPI));
}

////////////////////////////////////////////////////////
// Logon Parser

void CALLBACK LogonParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}


////////////////////////////////////////////////////////
// Logon entry point

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    // Create frame
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;

    // Cache password field atoms for quicker identification (static)
    LogonAccount::idPwdGo = AddAtomW(L"go");
    if (!LogonAccount::idPwdGo)
        goto Failure;

    LogonAccount::idPwdInfo = AddAtomW(L"info");
    if (!LogonAccount::idPwdInfo)
        goto Failure;

    // DirectUI init process
    if (FAILED(InitProcess()))
        goto Failure;

    // Regsiter classes
    if (FAILED(LogonFrame::Register()))
        goto Failure;

    if (FAILED(LogonAccount::Register()))
        goto Failure;

    // DirectUI init thread
    if (FAILED(InitThread()))
        goto Failure;

    if (FAILED(CoInitialize(NULL)))
        goto Failure;

    DisableAnimations();
    
    // Frame creation
    Parser::Create(IDR_LOGONUI, hInst, LogonParseError, &pParser);
    if (!pParser)
        goto Failure;

    if (!pParser->WasParseError())
    {
        // Create password panel
        Element* pePwdPanel;
        pParser->CreateElement(L"passwordpanel", NULL, &pePwdPanel);
        if (!pePwdPanel)
            goto Failure;

        // Cache password panel edit control
        Edit* pePwdEdit = (Edit*)pePwdPanel->FindDescendent(StrToID(L"password"));
        if (!pePwdEdit)
            goto Failure;

        // Cache password panel info button
        Button* pbPwdInfo = (Button*)pePwdPanel->FindDescendent(StrToID(L"info"));
        if (!pbPwdInfo)
            goto Failure;

        LogonAccount::InitPasswordPanel(pePwdPanel, pePwdEdit, pbPwdInfo);

        // Create host
        NativeHWNDHost::Create(L"Welcome", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 770, 640, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);
        if (!pnhh)
            goto Failure;

        Element::StartDefer();

        // Always double buffer
        LogonFrame::Create(pnhh->GetHWND(), true, 0, (Element**)&g_plf);
        if (!g_plf)
        {
            Element::EndDefer();
            goto Failure;
        }

        Element* pe;
        pParser->CreateElement(L"main", g_plf, &pe);

        if (pe) // Fill contents using substitution
        {
            // Frame tree is built
            if (FAILED(g_plf->OnTreeReady(pParser)))
            {
                Element::EndDefer();
                goto Failure;
            }

            // Build contents of account list
            if (FAILED(BuildAccountList(g_plf)))
            {
                Element::EndDefer();
                goto Failure;
            }

            // Host
            pnhh->Host(g_plf);

            // Set visible and focus
            g_plf->SetVisible(true);
            g_plf->SetKeyFocus();
            
            Element::EndDefer();

            // Do initial show
            pnhh->ShowWindow();

            EnableAnimations();

            StartMessagePump();

            // psf will be deleted by native HWND host when destroyed
        }
        else
            Element::EndDefer();
    }

Failure:

    if (pnhh)
        pnhh->Destroy();
    if (pParser)
        pParser->Destroy();

    CoUninitialize();

    UnInitThread();
    UnInitProcess();

    // Free cached atom list
    if (LogonAccount::idPwdGo)
        DeleteAtom(LogonAccount::idPwdGo);

    if (LogonAccount::idPwdInfo)
        DeleteAtom(LogonAccount::idPwdInfo);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\start\makefile.inc ===
#
# start.ui preprocessing
#

start.uipp: start.ui
    cl /nologo /EP start.ui > start.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\logonui\makefile.inc ===
#
# logon.ui preprocessing
#

logon.uipp: logon.ui
    cl /nologo /EP logon.ui > logon.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\start\resource.h ===
//
// Used by start.rc
//

#define IDR_STARTUI               1
#define IDR_STARTEMF              2

#define IDB_PORTRAIT              100
#define IDB_PICTURE               101

#define IDI_LOGO                  1001
#define IDI_BRAND                 1002
#define IDI_INTERNET              1003
#define IDI_EMAIL                 1004
#define IDI_SEARCH                1005
#define IDI_MYCOMPUTER            1006
#define IDI_RECYCLE               1007
#define IDI_DESKTOPFILES          1008
#define IDI_MYDOCUMENTS           1009
#define IDI_MYMUSIC               1010
#define IDI_MYPICTURES            1011
#define IDI_APP0                  1012
#define IDI_APP1                  1013
#define IDI_APP2                  1014
#define IDI_APP3                  1015
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\logonui\priv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       priv.h
//
//  Contents:   precompiled header for shgina.dll
//
//----------------------------------------------------------------------------
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>

#include <process.h>
#include <malloc.h>

#include <uxtheme.h>

// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\start\start.cpp ===
// Start.cpp : Start Page
//

#include "stdafx.h"

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);
UsingDUIClass(Thumb);
UsingDUIClass(ScrollBar);
UsingDUIClass(Viewer);
UsingDUIClass(Selector);
UsingDUIClass(Progress);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);

#include "start.h"

HINSTANCE g_hInst = NULL;

const float flMoveDuration = 0.35f;

////////////////////////////////////////////////////////
// StartFrame class
////////////////////////////////////////////////////////

HRESULT StartFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT StartFrame::Create(NativeHWNDHost* pnhh, bool fDblBuffer, OUT Element** ppElement)
{
    *ppElement = NULL;

    StartFrame* psf = HNew<StartFrame>();
    if (!psf)
        return E_OUTOFMEMORY;

    HRESULT hr = psf->Initialize(pnhh, fDblBuffer);
    if (FAILED(hr))
    {
        psf->Destroy();
        return hr;
    }

    *ppElement = psf;

    return S_OK;
}

HRESULT StartFrame::Initialize(NativeHWNDHost* pnhh, bool fDblBuffer)
{
    Value* pvEMF = NULL;

    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), fDblBuffer, EC_SelfLayout);
    if (FAILED(hr))
        goto Failed;
   
    // Initialize
    pvEMF = Value::CreateGraphic(LoadMetaFile(IDR_STARTEMF, NULL), NULL);
    if (!pvEMF)
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }

    SetValue(BackgroundProp, PI_Local, pvEMF);
    pvEMF->Release();

    // Setup reference point mappings
    _rm[SRP_Portrait].rX = .0602;
    _rm[SRP_Portrait].rY = .1241;

    _rm[SRP_Internet].rX = .3972;
    _rm[SRP_Internet].rY = .1693;

    _rm[SRP_Email].rX = .6018;
    _rm[SRP_Email].rY = .2029;

    _rm[SRP_Search].rX = .8074;
    _rm[SRP_Search].rY = .2453;

    _rm[SRP_RecProgList].rX = .0481;
    _rm[SRP_RecProgList].rY = .3036;

    _rm[SRP_RecProgLabel].rX = .0481;
    _rm[SRP_RecProgLabel].rY = .2832;

    _rm[SRP_RecFileFldList].rX = .4014;
    _rm[SRP_RecFileFldList].rY = .4068;

    _rm[SRP_RecFileFldLabel].rX = .4014;
    _rm[SRP_RecFileFldLabel].rY = .3864;

    _rm[SRP_OtherFldList].rX = .7637;
    _rm[SRP_OtherFldList].rY = .4876;

    return S_OK;

Failed:

    return hr;
}

// Init helpers
Element* CreateItem(LPCWSTR pszTitle, UINT uResID)
{
    Button* pe;
    Button::Create(AE_MouseAndKeyboard, (Element**)&pe);

    BorderLayout* pbl;
    BorderLayout::Create((Layout**)&pbl);
    pe->SetLayout(pbl);

    pe->SetLayoutPos(BLP_Top);

    Value* pv;
    Element* pecc;
    Element::Create(0, &pecc);
    pecc->SetLayoutPos(BLP_Left);

    HICON hIcon = (HICON)LoadImageW(g_hInst, MAKEINTRESOURCEW(uResID), IMAGE_ICON, 0, 0, 0);
    pv = Value::CreateGraphic(hIcon, true, false);   
    
    pecc->SetValue(Element::ContentProp, PI_Local, pv);
    pv->Release();
    pecc->SetBackgroundColor(ARGB(0,0,0,0));
    pe->Add(pecc);

    Element::Create(0, &pecc);
    pecc->SetLayoutPos(BLP_Left);
    pecc->SetContentString(pszTitle);
    pecc->SetBackgroundColor(ARGB(0,0,0,0));
    pe->Add(pecc);

    return pe;        
}

void SetBitmap(Element* pe, LPCWSTR pszID, UINT uResID, BYTE dBlendMode)
{
    Element* pec = pe->FindDescendent(StrToID(pszID));
    DUIAssertNoMsg(pe);

    HBITMAP hBitmap = (HBITMAP)LoadImageW(g_hInst, MAKEINTRESOURCEW(uResID), IMAGE_BITMAP, 0, 0, 0);
    Value* pv = Value::CreateGraphic(hBitmap, dBlendMode);

    pec->SetValue(Element::ContentProp, PI_Local, pv);
    pv->Release();
}

void SetIcon(Element* pe, LPCWSTR pszID, UINT uResID)
{
    Element* pec = pe->FindDescendent(StrToID(pszID));
    DUIAssertNoMsg(pe);

    HICON hIcon = (HICON)LoadImageW(g_hInst, MAKEINTRESOURCEW(uResID), IMAGE_ICON, 0, 0, 0);
    Value* pv = Value::CreateGraphic(hIcon, true, false);   

    pec->SetValue(Element::ContentProp, PI_Local, pv);
    pv->Release();
}

// Init
void StartFrame::Setup()
{
    Element* pe;

    // Set Bitmaps
    SetBitmap(this, L"portrait", IDB_PORTRAIT, GRAPHIC_TransColor);
    SetBitmap(this, L"picture", IDB_PICTURE, GRAPHIC_NoBlend);

    // Set Icons
    SetIcon(this, L"logo", IDI_LOGO);
    SetIcon(this, L"brand", IDI_BRAND);
    SetIcon(this, L"interneticon", IDI_INTERNET);
    SetIcon(this, L"emailicon", IDI_EMAIL);
    SetIcon(this, L"searchicon", IDI_SEARCH);
    SetIcon(this, L"mycomputericon", IDI_MYCOMPUTER);
    SetIcon(this, L"recycle", IDI_RECYCLE);
    SetIcon(this, L"desktopfilesicon", IDI_DESKTOPFILES);
    SetIcon(this, L"mydocumentsicon", IDI_MYDOCUMENTS);
    SetIcon(this, L"mymusicicon", IDI_MYMUSIC);
    SetIcon(this, L"mypicturesicon", IDI_MYPICTURES);

    // Set username
    pe = FindDescendent(StrToID(L"username"));
    DUIAssertNoMsg(pe);
    pe->SetContentString(L"Beverly");

    // Set list items
    pe = FindDescendent(StrToID(L"programlist"));
    DUIAssertNoMsg(pe);
    pe->Add(CreateItem(L"Sample Data 0", IDI_APP0));
    pe->Add(CreateItem(L"Sample Data 1", IDI_APP1));
    pe->Add(CreateItem(L"Sample Data 2", IDI_APP2));
    pe->Add(CreateItem(L"Sample Data 3", IDI_APP3));

    pe = FindDescendent(StrToID(L"filefolderlist"));
    DUIAssertNoMsg(pe);
    pe->Add(CreateItem(L"Sample Data 0", IDI_APP0));
    pe->Add(CreateItem(L"Sample Data 1", IDI_APP1));
    pe->Add(CreateItem(L"Sample Data 2", IDI_APP0));
}

void StartFrame::OnEvent(Event* pEvent)
{
    HWNDElement::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// Self-layout methods 

// StartFrame child layout order, all margins are ignored
//
// Option bar (bottom)
// Logo bar (top)
// Search (ref point: SRP_Search)
// Email (ref point: SRP_Email)
// Internet (ref point: SRP_Internet)
// Portrait (ref point: SRP_Portrait)
// Other folder list (ref point: SRP_OtherFldList)
// Recent files and folders list (ref point: SRP_RecFileFldList)
// Recent files and folders label (ref point: SRP_RecFileFldLabel)
// Recent programs list (ref point: SRP_RecProgList)
// Recent programs label (ref point: SRP_RecProgLabel)

void StartFrame::_SelfLayoutDoLayout(int dWidth, int dHeight)
{
    _FrameLayout(dWidth, dHeight, NULL, true);
}

SIZE StartFrame::_SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf)
{
    return _FrameLayout(dConstW, dConstH, psrf, false);
}

////////////////////////////////////////////////////////
// Common StartFrame Layout/UpdateDesiredSize 

// Helper
inline int ZeroClip(int dClip)
{
    if (dClip < 0)
        dClip = 0;

    return dClip;
}

// Helper
inline int MaxClip(int dClip, int dMax)
{
    if (dClip > dMax)
        dClip = dMax;

    return dClip;
}

// Helper
inline SIZE _GetDSOfChild(Element* pec, int cx, int cy, Surface* psrf, bool fMode)
{
    if (cx < 0)
        cx = 0;
    if (cy < 0)
        cy = 0;

    if (fMode)  // Layout pass
    {
        // Clip to dimensions passed in
        SIZE ds = *(pec->GetDesiredSize());
        if (ds.cx > cx)
            ds.cx = cx;
        if (ds.cy > cy)
            ds.cy = cy;
        return ds;
    }
    else  // Update desired size pass
        return pec->_UpdateDesiredSize(cx, cy, psrf);
}

// Helper
inline void _SetChildBounds(Element* pec, int cxContainer, int cyContainer, Element* peChild, int x, int y, int cx, int cy, bool fMode)
{
    UNREFERENCED_PARAMETER(cyContainer);
    // Only if in Layout pass
    if (fMode)
    {
        if (pec->IsRTL())
            x = cxContainer - cx - x;

        peChild->_UpdateLayoutPosition(x, y);
        peChild->_UpdateLayoutSize(cx, cy);
    }
}

// Common
SIZE StartFrame::_FrameLayout(int dWidth, int dHeight, Surface* psrf, bool fMode)
{
    SIZE cs = {0};

    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren); 

    if (peList)
    {
        Element* pec;
        SIZE ds;        // DS of child
        POINT p;        // Stratch

        // Option bar (bottom)
        pec = peList->GetItem(0);
        ds = _GetDSOfChild(pec, dWidth, dHeight, psrf, fMode);
        int dOpBarY = dHeight - ds.cy;
        _SetChildBounds(this, dWidth, dHeight, pec, 0, dOpBarY, dWidth, ds.cy, fMode);

        // Logo bar (top), constrained above portrait Y
        pec = peList->GetItem(1);
        ds = _GetDSOfChild(pec, dWidth, MaxClip(MapY(SRP_Email, dHeight), dOpBarY), psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, 0, 0, dWidth, ds.cy, fMode);

        // Search (ref point: SRP_Search)
        pec = peList->GetItem(2);
        ds = _GetDSOfChild(pec, dWidth, dHeight, psrf, fMode);
        p.x = MapX(SRP_Search, dWidth) - ds.cx / 2;
        p.y = MapY(SRP_Search, dHeight) - ds.cy / 2;
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y, ds.cx, ds.cy, fMode);

        // Search label
        pec = peList->GetItem(3);
        p.x += ds.cx;
        p.y = MapY(SRP_Search, dHeight);
        ds = _GetDSOfChild(pec, dWidth - p.x, dHeight - p.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y - ds.cy, ds.cx, ds.cy, fMode);

        // Email (ref point: SRP_Email)
        pec = peList->GetItem(4);
        ds = _GetDSOfChild(pec, dWidth, dHeight, psrf, fMode);
        p.x = MapX(SRP_Email, dWidth) - ds.cx / 2;
        p.y = MapY(SRP_Email, dHeight) - ds.cy / 2;
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y, ds.cx, ds.cy, fMode);

        // Email label
        pec = peList->GetItem(5);
        p.x += ds.cx;
        p.y = MapY(SRP_Email, dHeight);
        ds = _GetDSOfChild(pec, dWidth - p.x, dHeight - p.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y - ds.cy, ds.cx, ds.cy, fMode);

        // Internet (ref point: SRP_Internet)
        pec = peList->GetItem(6);
        ds = _GetDSOfChild(pec, dWidth, dHeight, psrf, fMode);
        p.x = MapX(SRP_Internet, dWidth) - ds.cx / 2;
        p.y = MapY(SRP_Internet, dHeight) - ds.cy / 2;
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y, ds.cx, ds.cy, fMode);

        // Internet label
        pec = peList->GetItem(7);
        p.x += ds.cx;
        p.y = MapY(SRP_Internet, dHeight);
        ds = _GetDSOfChild(pec, dWidth - p.x, dHeight - p.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y - ds.cy, ds.cx, ds.cy, fMode);

        // Portrait (ref point: SRP_Portrait)
        pec = peList->GetItem(8);
        ds = _GetDSOfChild(pec, dWidth, dHeight, psrf, fMode);
        p.x = MapX(SRP_Portrait, dWidth) - ds.cx / 2;
        p.y = MapY(SRP_Portrait, dHeight) - ds.cy / 2;
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y, ds.cx, ds.cy, fMode);

        // Portrait label
        pec = peList->GetItem(9);
        p.x += ds.cx;
        p.y = MapY(SRP_Portrait, dHeight);
        ds = _GetDSOfChild(pec, dWidth - p.x, dHeight - p.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, p.x, p.y - ds.cy, ds.cx, ds.cy, fMode);

        // Other folder list (ref point: SRP_OtherFldList)
        pec = peList->GetItem(10);
        POINT ptOFL = { MapX(SRP_OtherFldList, dWidth), MapY(SRP_OtherFldList, dHeight) };
        ds = _GetDSOfChild(pec, dWidth - ptOFL.x, dOpBarY - ptOFL.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, ptOFL.x, ptOFL.y, ds.cx, ds.cy, fMode);

        // Recent files and folders list (ref point: SRP_RecFileFldList)
        pec = peList->GetItem(11);
        POINT ptRFFL = { MapX(SRP_RecFileFldList, dWidth), MapY(SRP_RecFileFldList, dHeight) };
        ds = _GetDSOfChild(pec, ptOFL.x - ptRFFL.x, dOpBarY - ptRFFL.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, ptRFFL.x, ptRFFL.y, ds.cx, ds.cy, fMode);

        // Recent files and folders label (ref point: SRP_RecFileFldLabel)
        pec = peList->GetItem(12);
        ds = _GetDSOfChild(pec, ptOFL.x - ptRFFL.x, MapY(SRP_RecFileFldLabel, dHeight) - MapY(SRP_Internet, dHeight), psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, MapX(SRP_RecFileFldLabel, dWidth), MapY(SRP_RecFileFldLabel, dHeight) - ds.cy, ds.cx, ds.cy, fMode);

        // Recent programs list (ref point: SRP_RecProgList)
        pec = peList->GetItem(13);
        POINT ptRPL = { MapX(SRP_RecProgList, dWidth), MapY(SRP_RecProgList, dHeight) };
        ds = _GetDSOfChild(pec, ptRFFL.x - ptRPL.x, dOpBarY - ptRPL.y, psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, ptRPL.x, ptRPL.y, ds.cx, ds.cy, fMode);
        
        // Recent programs label (ref point: SRP_RecProgLabel)
        pec = peList->GetItem(14);
        ds = _GetDSOfChild(pec, ptRFFL.x - ptRPL.x, MapY(SRP_RecProgLabel, dHeight) - MapY(SRP_Portrait, dHeight), psrf, fMode);
        _SetChildBounds(this, dWidth, dHeight, pec, MapX(SRP_RecProgLabel, dWidth), MapY(SRP_RecProgLabel, dHeight) - ds.cy, ds.cx, ds.cy, fMode);
    }

    pvChildren->Release();

    return cs;
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* StartFrame::Class = NULL;
HRESULT StartFrame::Register()
{
    return ClassInfo<StartFrame,HWNDElement>::Register(L"StartFrame", NULL, 0);
}

////////////////////////////////////////////////////////
// Start Parser callback

void CALLBACK StartParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

////////////////////////////////////////////////////////
// Start entry point

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    g_hInst = hInstance;

    HRESULT hr;

    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    StartFrame* psf = NULL;
    Element* pe = NULL;
    LPWSTR pCL = NULL;

    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    hr = StartFrame::Register();
    if (FAILED(hr))
        goto Failure;

    hr = InitThread();
    if (FAILED(hr))
        goto Failure;

    pCL = MultiByteToUnicode(lpCmdLine);
    if (!pCL)
        goto Failure;

    // Load resources
    Parser::Create(IDR_STARTUI, hInstance, StartParseError, &pParser);

    if (!pParser || pParser->WasParseError())
        goto Failure;

    Element::StartDefer();

    // Create host
    NativeHWNDHost::Create(L"Windows Start Page", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 705, 585, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);
    if (!pnhh)
        goto Failure;

    StartFrame::Create(pnhh, wcsstr(pCL, L"-db") == 0, (Element**)&psf);
    if (!psf)
        goto Failure;
    
    pParser->CreateElement(L"main", psf, &pe);

    if (pe) // Fill contents using substitution
    {
        // Initialize
        psf->Setup();

        // Set visible and host
        psf->SetVisible(true);
        pnhh->Host(psf);

        Element::EndDefer();

        // Setup animations
        Element* pea;
        pea = psf->FindDescendent(StrToID(L"interneticon"));
        MoveTaskItem::Build(psf, pea, 0.00f, flMoveDuration);

        pea = psf->FindDescendent(StrToID(L"emailicon"));
        MoveTaskItem::Build(psf, pea, 0.15f, flMoveDuration);

        pea = psf->FindDescendent(StrToID(L"searchicon"));
        MoveTaskItem::Build(psf, pea, 0.30f, flMoveDuration);

        // Do initial show
        pnhh->ShowWindow();

        StartMessagePump();

        // psf will be deleted by native HWND host when destroyed
    }
    else
        Element::EndDefer();

Failure:

    if (pnhh)
        pnhh->Destroy();
    if (pParser)
        pParser->Destroy();

    if (pCL)
        HFree(pCL);

    UnInitThread();
    UnInitProcess();

    return 0;
}

//
// Animation classes
//

// class ChangeTaskItem

ChangeTaskItem::ChangeTaskItem()
{
    m_hact  = NULL;
    m_hgad  = NULL;
}

ChangeTaskItem::~ChangeTaskItem()
{
}

BOOL ChangeTaskItem::Create(HGADGET hgad, int xA, int yA, int xB, int yB, float flDelay, float flDuration)
{
    m_hgad = hgad;
    m_xA = xA;
    m_yA = yA;
    m_xB = xB;
    m_yB = yB;

    GMA_ACTION gma;
    ZeroMemory(&gma, sizeof(gma));
    gma.cbSize = sizeof(gma);
    gma.cRepeat = 0;
    gma.flDelay = flDelay;
    gma.flPeriod = 0.0f;
    gma.flDuration = flDuration;
    gma.pfnProc = ChangeTaskItem::ActionProc;
    gma.pvData = this;

    m_hact = CreateAction(&gma);
    if (!m_hact)
        return FALSE;

    return TRUE;
}

void ChangeTaskItem::Abort()
{
    //DUIAssert(m_hact != (HANDLE) 0xfeeefeee, "Ensure semi-valid handle");
    DeleteHandle(m_hact);
}

void CALLBACK ChangeTaskItem::ActionProc(GMA_ACTIONINFO* pmai)
{
    ChangeTaskItem* pmti = (ChangeTaskItem*)pmai->pvData;
    if (pmai->fFinished)
    {
        HDelete<ChangeTaskItem>(pmti);
        return;
    }

    float flProgress = pmai->flProgress;

    int xNew = (int) (pmti->m_xA * (1.0f - flProgress) + pmti->m_xB * flProgress);
    int yNew = (int) (pmti->m_yA * (1.0f - flProgress) + pmti->m_yB * flProgress);

    pmti->OnChange(xNew, yNew);
}

// class MoveTaskItem

MoveTaskItem::~MoveTaskItem()
{
}

MoveTaskItem* MoveTaskItem::Build(Element* peRoot, Element* peItem, float flDelay, float flDuration)
{
    DUIAssertNoMsg(peRoot);
    DUIAssertNoMsg(peItem);

    HGADGET hgadRoot = peRoot->GetDisplayNode();
    HGADGET hgadItem = peItem->GetDisplayNode();

    RECT rcContainer, rcItem;
    GetGadgetRect(hgadRoot, &rcContainer, SGR_CONTAINER);

    GetGadgetRect(hgadItem, &rcItem, SGR_CONTAINER);
    POINT ptStart, ptEnd;
    ptStart.x = rcContainer.right + (rcItem.right - rcItem.left);
    ptStart.y = rcItem.top;
    ptEnd.x = rcItem.left;
    ptEnd.y = rcItem.top;

    MoveTaskItem* pmti = HNew<MoveTaskItem>();
    if (!pmti)
        return NULL;

    if (!pmti->Create(hgadItem, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y, flDelay, flDuration))
    {
        HDelete<MoveTaskItem>(pmti);
        return NULL;
    }

    //
    // Move the Element initially off the screen while it waits to start
    // animation.
    //
    SetGadgetRect(hgadItem, ptStart.x, ptStart.y, 0, 0, SGR_MOVE | SGR_CONTAINER);

    return pmti;
}

void MoveTaskItem::OnChange(int x, int y)
{
    SetGadgetRect(m_hgad, x, y, 0, 0, SGR_MOVE | SGR_CONTAINER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\logonui\logon.h ===
// logon.h
//

// Forward declarations
class LogonAccount;

class LogonFrame: public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, BOOL fDblBuffer, UINT nCreate, OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // Frame Callbacks
    HRESULT OnLogUserOn(LogonAccount* pla);
    HRESULT OnPower();
    HRESULT OnUndock();
    HRESULT OnTreeReady(Parser* pParser);

    // Operations
    static int PointToPixel(int nPoint) { return MulDiv(nPoint, _nDPI, 72); }
    static int RelPixToPixel(int nRelPix) { return MulDiv(nRelPix, _nDPI, 96); }
    HINSTANCE GetHInstance() { return _pParser->GetHInstance(); }
    void HideAccountPanel() { _peRightPanel->SetLayoutPos(LP_None); }
    void ShowAccountPanel() { _peRightPanel->SetLayoutPos(BLP_Left); }
    void HidePowerButton() { _pbPower->SetVisible(false); }
    void ShowPowerButton() { _pbPower->SetVisible(true); }
    void SetPowerButtonLabel(LPCWSTR psz) { Element* pe = _pbPower->FindDescendent(StrToID(L"label")); if (pe) pe->SetContentString(psz); }
    void InsertUndockButton() { _pbUndock->SetLayoutPos(BLP_Top); }
    void RemoveUndockButton() { _pbUndock->SetLayoutPos(LP_None); }
    void HideUndockButton() { _pbUndock->SetVisible(false); }
    void ShowUndockButton() { _pbUndock->SetVisible(true); }
    void SetUndockButtonLabel(LPCWSTR psz) { Element* pe = _pbUndock->FindDescendent(StrToID(L"label")); if (pe) pe->SetContentString(psz); }
    void SetStatus(LPCWSTR psz) { if (psz) _peHelp->SetContentString(psz); }
    HRESULT AddAccount(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fPwdNeeded, BOOL fLoggedOn);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    LogonFrame() { }
    virtual ~LogonFrame();
    HRESULT Initialize(HWND hParent, BOOL fDblBuffer, UINT nCreate);

protected:
    // References to key descendents
    Selector* _peAccountList;
    Element* _peRightPanel;
    Button* _pbPower;
    Button* _pbUndock;
    Element* _peHelp;

private:
    static int _nDPI;
    Parser* _pParser;
};

// LogonState property enum
#define LS_Pending      0
#define LS_Granted      1
#define LS_Denied       2

class LogonAccount: public Button
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Account Callbacks
    void OnAuthenticateUser();
    void OnHintSelect();
    void OnStatusSelect(UINT nLine);
    HRESULT OnTreeReady(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fPwdNeeded, BOOL fLoggedOn, HINSTANCE hInst);

    // Operations
    static void InitPasswordPanel(Element* pePwdPanel, Edit* pePwdEdit, Button* pbPwdInfo) { _pePwdPanel = pePwdPanel; _pePwdEdit = pePwdEdit; _pbPwdInfo = pbPwdInfo; }
    HRESULT InsertPasswordPanel();
    HRESULT RemovePasswordPanel();
    void InsertStatus(UINT nLine) { _pbStatus[nLine]->SetLayoutPos(BLP_Top); }
    void RemoveStatus(UINT nLine) { _pbStatus[nLine]->SetLayoutPos(LP_None); }
    void HideStatus(UINT nLine) { _pbStatus[nLine]->SetVisible(false); }
    void ShowStatus(UINT nLine) { _pbStatus[nLine]->SetVisible(true); }
    void SetStatus(UINT nLine, LPCWSTR psz) { if (psz) _pbStatus[nLine]->SetContentString(psz); }
    void DisableStatus(UINT nLine) { _pbStatus[nLine]->SetEnabled(false); }

    // Cached atoms for quicker identification
    static ATOM idPwdGo;
    static ATOM idPwdInfo;

    // Property definitions
    static PropertyInfo* LogonStateProp;

    // Quick property accessors
    int GetLogonState()           DUIQuickGetter(int, GetInt(), LogonState, Specified)
    HRESULT SetLogonState(int v)  DUIQuickSetter(CreateInt(v), LogonState)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    LogonAccount() { }
    virtual ~LogonAccount();
    HRESULT Initialize();

protected:
    // References to key descendents
    Button* _pbStatus[2];

    static Element* _pePwdPanel;
    static Edit* _pePwdEdit;
    static Button* _pbPwdInfo;

    Value* _pvUsername;
    Value* _pvHint;
    BOOL _fPwdNeeded;
    BOOL _fLoggedOn;
    BOOL _fHasPwdPanel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\start\start.h ===
// Start.h
//

// Class definitions

// Frame

// Reference points
#define SRP_Portrait        0
#define SRP_Internet        1
#define SRP_Email           2
#define SRP_Search          3
#define SRP_RecProgList     4
#define SRP_RecProgLabel    5
#define SRP_RecFileFldList  6
#define SRP_RecFileFldLabel 7
#define SRP_OtherFldList    8
#define SRP_Total           9

struct RefMap  // Reference point mapping
{
    double rX;
    double rY;
};

//
// Start Page classes
//

class StartFrame : public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(NativeHWNDHost* pnhh, bool fDblBuffer, OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // Self-layout
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    void Setup();

    // Reference point mapping
    int MapX(UINT nRefPoint, int dExtent) { return (int)((double)dExtent * _rm[nRefPoint].rX); }
    int MapY(UINT nRefPoint, int dExtent) { return (int)((double)dExtent * _rm[nRefPoint].rY); }

    StartFrame() { }
    HRESULT Initialize(NativeHWNDHost* pnhh, bool fDblBuffer);
    virtual ~StartFrame() { }

private:
    SIZE _FrameLayout(int dWidth, int dHeight, Surface* psrf, bool fMode);

    NativeHWNDHost* _pnhh;

    // ARP parser
    Parser* _pParser;

    RefMap _rm[SRP_Total];

public:

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

//
// Animation classes
//

class ChangeTaskItem
{
public:
    ChangeTaskItem();
    virtual ~ChangeTaskItem();

    BOOL Create(HGADGET hgad, int xA, int yA, int xB, int yB, float flDelay, float flDuration);
    void Abort();
    virtual void OnChange(int x, int y) PURE;
 
    static void CALLBACK ActionProc(GMA_ACTIONINFO* pmai);

protected:
    HACTION m_hact;
    HGADGET m_hgad;
    int m_xA;
    int m_yA;
    int m_xB;
    int m_yB;
};

class MoveTaskItem : public ChangeTaskItem
{
public:
    ~MoveTaskItem();
    
    static  MoveTaskItem* Build(Element* peRoot, Element* peItem, float flDelay, float flDuration);
    virtual void OnChange(int x, int y);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\logonui\resource.h ===
//
// Used by logon.rc
//

#define IDS_WELCOMEFONT         1
#define IDS_OPTIONSFONT         2
#define IDS_ACCOUNTLISTFONT     3

#define IDS_POWERFONTSIZE       30
#define IDS_INSTRUCTFONTSIZE    31
#define IDS_WELCOMEFONTSIZE     32
#define IDS_HELPFONTSIZE        33
#define IDS_STATUSFONTSIZE      34

#define IDS_MANAGEACCOUNTS      10
#define IDS_WELCOME             11
#define IDS_BEGIN               12
#define IDS_TYPEPASSWORD        13
#define IDS_APPLYSETTINGS       14
#define IDS_LOGGINGON           15
#define IDS_LOGGEDON            16
#define IDS_PROGRAMSRUNNING     17
#define IDS_POWER               18
#define IDS_UNDOCK              19

#define IDB_BACKGROUND          100
#define IDB_FLAG                101
#define IDB_EDITFRAME           102
#define IDB_GO                  103
#define IDB_GOKF                104
#define IDB_INFO                105
#define IDB_INFOKF              106
#define IDB_POWER               107
#define IDB_UNDOCK              108
#define IDB_SBLINEDOWNV         109
#define IDB_SBLINEUPV           110
#define IDB_SBTHUMBV            111
#define IDB_SELECTION           112
#define IDB_USERFRAME           113
#define IDB_USER0               114
#define IDB_USER1               115
#define IDB_USER2               116
#define IDB_USER3               117
#define IDB_USER4               118

#define IDR_LOGONUI            1000

//
// Windows defines (private project, not under NTBLD)
//

/*
 * GetSystemMetrics() codes
 */

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43

#define SM_CXFIXEDFRAME           SM_CXDLGFRAME  /* ;win40 name change */
#define SM_CYFIXEDFRAME           SM_CYDLGFRAME  /* ;win40 name change */
#define SM_CXSIZEFRAME            SM_CXFRAME     /* ;win40 name change */
#define SM_CYSIZEFRAME            SM_CYFRAME     /* ;win40 name change */

#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71   /* Use instead of GetMenuCheckMarkDimensions()! */
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
//#define SM_CMETRICS             83

/* flags for DrawFrameControl */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\start\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_APP_STDAFX_H_INCLUDED
#define DUI_APP_STDAFX_H_INCLUDED

#pragma once

// Test warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <math.h>

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// Application headers
#include <ocidl.h>
#include <shellapi.h>
#include <shlwapi.h>

// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
#include <directui.h>

#include "resource.h"

#endif // DUI_APP_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\webvw\priv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       priv.h
//
//  Contents:   precompiled header for shgina.dll
//
//----------------------------------------------------------------------------
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>
#include <oleauto.h>    // for IEnumVARIANT
#include <lmcons.h>     // for NET_API_STATUS

#include <process.h>
#include <malloc.h>

// Themes support
#include <uxtheme.h>

// DirectUser and DirectUI
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\webvw\makefile.inc ===
#
# webvw.ui preprocessing
#

webvw.uipp: webvw.ui
    cl /nologo /EP webvw.ui > webvw.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\suite\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Suite.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\webvw\webvw.cpp ===
// WebVw.cpp : Web View
//

#include "priv.h"

using namespace DirectUI;

#include "webvw.h"
#include "resource.h"

//#include "z:\icecap4\include\icecap.h"

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(ScrollBar);
UsingDUIClass(Expando);
UsingDUIClass(Clipper);
UsingDUIClass(ScrollViewer);

////////////////////////////////////////////////////////
// Expando class
////////////////////////////////////////////////////////

// Cached IDs
ATOM Expando::idTitle = NULL;
ATOM Expando::idIcon = NULL;
ATOM Expando::idTaskList = NULL;


HRESULT Expando::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expando* pex = HNew<Expando>();
    if (!pex)
        return E_OUTOFMEMORY;

    HRESULT hr = pex->Initialize();
    if (FAILED(hr))
    {
        pex->Destroy();
        return hr;
    }

    *ppElement = pex;

    return S_OK;
}

Expando::~Expando()
{
}


HRESULT Expando::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    _fExpanding = false;
    SetSelected(true);

    return S_OK;
}

void Expando::OnEvent(Event* pev)
{
    if (pev->uidType == Button::Click)
    {
        // Update exanded property based on clicks that originate
        // only from the first child's subtree
        Value* pv;
        ElementList* peList = GetChildren(&pv);

        if (peList && peList->GetSize() > 0)
        {
            if (peList->GetItem(0) == GetImmediateChild(pev->peTarget))
            {
                SetSelected(!GetSelected());
                pev->fHandled = true;
            }
            else
            {
                // Task selected
                MessageBeep(MB_ICONASTERISK);
            }
        }

        pv->Release();
    }

    Element::OnEvent(pev);
}

////////////////////////////////////////////////////////
// System events

void Expando::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        // Update height of second child based on expanded state
        Value* pvChildren;
        ElementList* peList = GetChildren(&pvChildren);
        if (peList && peList->GetSize() > 1)
        {
            // The following will cause a relayout, mark object so that
            // when the expando's Extent changes, it'll go through
            // with the EnsureVisible. Otherwise, it's being resized
            // as a result of something else. In which case, do nothing.
            _fExpanding = true;

            Element* pe = peList->GetItem(1);

            // To achieve "pulldown" animation, we use a clipper control that will
            // size it's child based on it's unconstrained desired size in its Y direction.
            // 
            if (pvNew->GetBool())
            {
                pe->RemoveLocalValue(HeightProp);
            }
            else
            {
                pe->SetHeight(0);
            }
        }
        pvChildren->Release();
    }
    else if (IsProp(Extent))
    {
        if (_fExpanding && GetSelected())
        {
            _fExpanding = false;
            EnsureVisible();
        }
    }
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Expando::Class = NULL;

HRESULT Expando::Register()
{
    return ClassInfo<Expando,Element>::Register(L"Expando", NULL, 0);
}

////////////////////////////////////////////////////////
// Clipper class
////////////////////////////////////////////////////////

HRESULT Clipper::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Clipper* pc = HNew<Clipper>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT Clipper::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(EC_SelfLayout); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    return S_OK;
}

////////////////////////////////////////////////////////
// Self-layout methods

SIZE Clipper::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(cyConstraint);

    Value* pvChildren;
    SIZE size = { 0, 0 };
    ElementList* peList = GetChildren(&pvChildren);

    // Desired size of this is based solely on it's first child.
    // Width is child's width, height is unconstrained height of child.
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        size = pec->_UpdateDesiredSize(cxConstraint, INT_MAX, psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    pvChildren->Release();

    return size;
}

void Clipper::_SelfLayoutDoLayout(int cx, int cy)
{
    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    // Layout first child giving it's desired height and aligning
    // it with the clipper's bottom edge
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        const SIZE* pds = pec->GetDesiredSize();

        pec->_UpdateLayoutPosition(0, cy - pds->cy);
        pec->_UpdateLayoutSize(cx, pds->cy);        
    }

    pvChildren->Release();
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Clipper::Class = NULL;

HRESULT Clipper::Register()
{
    return ClassInfo<Clipper,Element>::Register(L"Clipper", NULL, 0);
}

////////////////////////////////////////////////////////
// WebView creation

Element* BuildMainSection(Element* peSectionList, UINT residTitle, UINT residIcon, Value* pvSectionSheet, Parser* pParser, HINSTANCE hInst, bool fExpanded = true)
{
peSectionList;

    Element* peSection = NULL;
    Value* pv = NULL;
    Element* pe = NULL;

    // Create a main section
    pParser->CreateElement(L"mainsection", NULL, &peSection);//, peSectionList);
    if (!peSection)
        goto Failure;


    // Populate it's standard content

    // Title
    pe = peSection->FindDescendent(Expando::idTitle);
    if (!pe)
        goto Failure;
    pv = Value::CreateString(MAKEINTRESOURCEW(residTitle), hInst);
    if (pv)
    {
        pe->SetValue(Element::ContentProp, PI_Local, pv);
        pv->Release();
    }

    // Icon (assume bitmap)
    pe = peSection->FindDescendent(Expando::idIcon);
    if (!pe)
        goto Failure;
    pv = Value::CreateGraphic(MAKEINTRESOURCEW(residIcon), GRAPHIC_TransColor, (UINT)-1, 0, 0, hInst);
    if (pv)
    {
        pe->SetValue(Element::ContentProp, PI_Local, pv);
        pv->Release();
    }

    if (pvSectionSheet)
        peSection->SetValue(Element::SheetProp, PI_Local, pvSectionSheet);

    // Expanded by default
    if (!fExpanded)
        peSection->SetSelected(fExpanded);

    peSectionList->Add(peSection);

    return peSection->FindDescendent(Expando::idTaskList);

Failure:
    
    return NULL;
}


Element* BuildSection(Element* peSectionList, UINT residTitle, Value* pvSectionSheet, Parser* pParser, HINSTANCE hInst, bool fExpanded = true)
{
peSectionList;
    Element* peSection = NULL;
    Value* pv = NULL;
    Element* pe = NULL;

    // Create a standard section
    pParser->CreateElement(L"section", NULL, &peSection);//, peSectionList);
    if (!peSection)
        goto Failure;

    // Populate it's standard content

    // Title
    pe = peSection->FindDescendent(Expando::idTitle);
    if (!pe)
        goto Failure;
    pv = Value::CreateString(MAKEINTRESOURCEW(residTitle), hInst);
    if (pv)
    {
        pe->SetValue(Element::ContentProp, PI_Local, pv);
        pv->Release();
    }

    if (pvSectionSheet)
        peSection->SetValue(Element::SheetProp, PI_Local, pvSectionSheet);
    
    // Expanded by default
    if (!fExpanded)
        peSection->SetSelected(fExpanded);

    peSectionList->Add(peSection);
    
    return peSection->FindDescendent(Expando::idTaskList);

Failure:
    
    return NULL;
}


void BuildSectionTask(Element* peTaskList, UINT residTitle, UINT residIcon, Value* pvTaskSheet, Parser* pParser, HINSTANCE hInst)
{
peTaskList;
    Element* peTask = NULL;
    Value* pv = NULL;
    Element* pe = NULL;

    // Create a main section
    pParser->CreateElement(L"sectiontask", NULL, &peTask);//, peTaskList);
    if (!peTask)
        goto Failure;

    // Populate it's standard content

    // Title
    pe = peTask->FindDescendent(Expando::idTitle);
    if (!pe)
        goto Failure;
    pv = Value::CreateString(MAKEINTRESOURCEW(residTitle), hInst);
    if (pv)
    {
        pe->SetValue(Element::ContentProp, PI_Local, pv);
        pv->Release();
    }

    // Icon (assume icon)
    pe = peTask->FindDescendent(Expando::idIcon);
    if (!pe)
        goto Failure;
    pv = Value::CreateGraphic(MAKEINTRESOURCEW(residIcon), 0, 0, hInst);
    if (pv)
    {
        pe->SetValue(Element::ContentProp, PI_Local, pv);
        pv->Release();
    }

    if (pvTaskSheet)
        peTask->SetValue(Element::SheetProp, PI_Local, pvTaskSheet);


    peTaskList->Add(peTask);

Failure:

    return;
}


void BuildSectionList(Element* peWebView, Parser* pParser, HINSTANCE hInst)
{
    Element* peSectionList = NULL;
    Element* peTaskList = NULL;
    Value* pvSectionSheet = NULL;
    Value* pvTaskSheet = NULL;

    // Locate section list
    peSectionList = peWebView->FindDescendent(StrToID(L"sectionlist"));
    if (!peSectionList)
        goto Failure;

    //
    // Music section (main section)
    //

    pvSectionSheet = pParser->GetSheet(L"musicsectionss");
    peTaskList = BuildMainSection(peSectionList, IDS_MUSICTASKS, IDB_MUSIC, pvSectionSheet, pParser, hInst);
    if (pvSectionSheet)
    {
        pvSectionSheet->Release();
        pvSectionSheet = NULL;
    }

    if (!peTaskList)
        goto Failure;

    pvTaskSheet = pParser->GetSheet(L"mainsectiontaskss");
    BuildSectionTask(peTaskList, IDS_PLAYSELECTION, IDI_PLAY, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_MUSICSHOP, IDI_WORLD, pvTaskSheet, pParser, hInst);
    if (pvTaskSheet)
    {
        pvTaskSheet->Release();
        pvTaskSheet = NULL;
    }

    //
    // Sheets for remaining standard sections
    // 

    pvSectionSheet = pParser->GetSheet(L"sectionss");
    pvTaskSheet = pParser->GetSheet(L"sectiontaskss");

    //
    // Folder tasks section (standard section)
    //

    peTaskList = BuildSection(peSectionList, IDS_FILETASKS, pvSectionSheet, pParser, hInst);
    if (!peTaskList)
        goto Failure;

    BuildSectionTask(peTaskList, IDS_RENAMEFOLDER, IDI_RENAME, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_MOVEFOLDER, IDI_MOVE, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_COPYFOLDER, IDI_COPY, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_PUBLISHFOLDER, IDI_PUBLISH, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_DELETEFOLDER, IDI_DELETE, pvTaskSheet, pParser, hInst);

    //
    // Other places tasks section (standard section)
    //

    peTaskList = BuildSection(peSectionList, IDS_OTHERPLACES, pvSectionSheet, pParser, hInst);
    if (!peTaskList)
        goto Failure;

    BuildSectionTask(peTaskList, IDS_DESKTOP, IDI_DESKTOP, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_SHAREDDOC, IDI_FOLDER, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_MYCOMPUTER, IDI_COMPUTER, pvTaskSheet, pParser, hInst);
    BuildSectionTask(peTaskList, IDS_MYNETWORK, IDI_NETWORK, pvTaskSheet, pParser, hInst);
    

    //
    // Details tasks section (standard section)
    //

    BuildSection(peSectionList, IDS_DETAILS, pvSectionSheet, pParser, hInst, false);


Failure:

    if (pvTaskSheet)
        pvTaskSheet->Release();

    if (pvSectionSheet)
        pvSectionSheet->Release();

    return;
}



////////////////////////////////////////////////////////
// WebView Parser

void CALLBACK WebViewParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

////////////////////////////////////////////////////////
// Top-level window

DWORD WINAPI BuildExplorerWindow(void* pv)
{
    UNREFERENCED_PARAMETER(pv);

    //StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);

    HINSTANCE hInst = (HINSTANCE)pv;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    HWNDElement* phe = NULL;

    // DirectUI init thread in caller
    if (FAILED(InitThread()))
        goto Failure;

    if (FAILED(CoInitialize(NULL)))
        goto Failure;

    DisableAnimations();
    
    Parser::Create(IDR_WEBVIEWUI, hInst, WebViewParseError, &pParser);
    if (!pParser)
        goto Failure;

    if (!pParser->WasParseError())
    {
        // Create host
        NativeHWNDHost::Create(L"WebView", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, 700, 550, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);
        if (!pnhh)
            goto Failure;

        Element::StartDefer();

        // Always double buffer
        HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);
        if (!phe)
        {
            Element::EndDefer();
            goto Failure;
        }

        Element* pe;
        pParser->CreateElement(L"webview", phe, &pe);

        if (pe) // Fill contents using substitution
        {
            // Build contents of webview section list
            BuildSectionList(pe, pParser, hInst);

            // Host
            pnhh->Host(phe);

            // Set visible
            phe->SetVisible(true);

            Element::EndDefer();

            // Do initial show
            pnhh->ShowWindow();

            EnableAnimations();

            //DUITrace("GetDependencies():   %d\n", g_cGetDep);
            //DUITrace("GetValue():          %d\n", g_cGetVal);
            //DUITrace("OnPropertyChanged(): %d\n", g_cOnPropChg);

            //StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);

            StartMessagePump();

            // psf will be deleted by native HWND host when destroyed
        }
        else
            Element::EndDefer();
    }

Failure:

    if (pnhh)
        pnhh->Destroy();
    if (pParser)
        pParser->Destroy();

    CoUninitialize();

    UnInitThread();

    return 0;
}

////////////////////////////////////////////////////////
// WebView entry point

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow)
{
    HRESULT hr;

    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    hr = Expando::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Clipper::Register();
    if (FAILED(hr))
        goto Failure;

    // Cache atoms used for loading from resources
    Expando::idTitle = AddAtomW(L"title");
    Expando::idIcon = AddAtomW(L"icon");
    Expando::idTaskList = AddAtomW(L"tasklist");

    // Build explorer windows (one per thread)
    int c = atoi(pCmdLine);
    if (c <= 0)
        c = 1;

    HANDLE* ph = (HANDLE*)_alloca(sizeof(HANDLE) * c);
    if (ph)
    {
        int i;

        // Create all threads
        for (i = 0; i < c; i++)
            ph[i] = CreateThread(NULL, 0, BuildExplorerWindow, (void*)hInst, 0, NULL);

        // Exit when all threads are terminated
        WaitForMultipleObjects(c, ph, TRUE, INFINITE);

        // Close handles
        for (i = 0; i < c; i++)
            CloseHandle(ph[i]);
    }

    // Free cached atoms
    if (Expando::idTitle)
        DeleteAtom(Expando::idTitle);
    if (Expando::idIcon)
        DeleteAtom(Expando::idIcon);
    if (Expando::idTaskList)
        DeleteAtom(Expando::idTaskList);

    hr = S_OK;

Failure:

    UnInitProcess();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\webvw\resource.h ===
//
// Used by webvw.rc
//

#define IDS_MUSICTASKS          1
#define IDS_PLAYSELECTION       2
#define IDS_MUSICSHOP           3
#define IDS_FILETASKS           10
#define IDS_RENAMEFOLDER        11
#define IDS_MOVEFOLDER          12
#define IDS_COPYFOLDER          13
#define IDS_PUBLISHFOLDER       14
#define IDS_DELETEFOLDER        15
#define IDS_OTHERPLACES         20
#define IDS_DESKTOP             21
#define IDS_SHAREDDOC           22
#define IDS_MYCOMPUTER          23
#define IDS_MYNETWORK           24

#define IDS_PREVIEW             30
#define IDS_DETAILS             40


#define IDB_PREVIEW             100
#define IDB_UP                  101
#define IDB_UPHOT               102
#define IDB_DOWN                103
#define IDB_DOWNHOT             104
#define IDB_UPMAIN              105
#define IDB_UPHOTMAIN           106
#define IDB_DOWNMAIN            107
#define IDB_DOWNHOTMAIN         108
#define IDB_MUSIC               109
#define IDB_MUSICWM             110
#define IDB_SBLINEUPV           111
#define IDB_SBLINEDOWNV         112
#define IDB_SBTHUMBV            113
#define IDB_HEADERMAIN          114
#define IDB_HEADERSECTION       115
#define IDB_SBGRIPPER           116

#define IDI_PLAY                200
#define IDI_WORLD               201
#define IDI_COPY                202
#define IDI_DELETE              203
#define IDI_MOVE                204
#define IDI_PUBLISH             205
#define IDI_RENAME              206
#define IDI_DESKTOP             207
#define IDI_FOLDER              208
#define IDI_COMPUTER            209
#define IDI_NETWORK             210

#define IDR_WEBVIEWUI           1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\app\webvw\webvw.h ===
// webvw.h
//

class Expando: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static ATOM idTitle;
    static ATOM idIcon;
    static ATOM idTaskList;

    Expando() { }
    virtual ~Expando();
    HRESULT Initialize();

private:
    bool _fExpanding;
};


class Clipper: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Clipper() { }
    virtual ~Clipper() { }
    HRESULT Initialize();

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\suite\stdafx.h ===
/*
 * External dependencies
 *
 * This includes all project-specific external headers that will be precompiled
 * All external headers must be available via the include path
 */

#ifndef DUI_SUITE_STDAFX_H_INCLUDED
#define DUI_SUITE_STDAFX_H_INCLUDED

#pragma once

// Test warning pragmas
#pragma warning (disable:4710)  // W4: Compiler decided not to inline function

// Exclude rarely-used stuff from Windows headers
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

// TODO: Remove this when updated headers are available
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <math.h>

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// Related services
#ifdef GADGET_ENABLE_GDIPLUS
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif // GADGET_ENABLE_GDIPLUS

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// Themes support
#include <uxtheme.h>

// DirectUser
#include <wchar.h>

#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>

#endif // DUI_SUITE_STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\directui\test\suite\suite.cpp ===
// Suite.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

#include <directui.h>

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);
UsingDUIClass(Thumb);
UsingDUIClass(ScrollBar);
UsingDUIClass(Viewer);
UsingDUIClass(Selector);
UsingDUIClass(Progress);
UsingDUIClass(HWNDElement);
UsingDUIClass(Edit);
UsingDUIClass(RefPointElement);

HINSTANCE g_hInst = NULL;

// Test suites

#define TEST(c)   { if (!(c)) { ForceDebugBreak(); MessageBoxW(NULL, L"Test failed!", L"DirectUI", MB_OK|MB_ICONERROR); return; } }
#define PASSED(s) { MessageBoxW(NULL, L"Test Passed!", s, MB_OK|MB_ICONINFORMATION); }

void TestParser(LPWSTR pCL);
void TestColorTable();
void TestContainment(LPWSTR pCL);
void TestScalability(LPWSTR pCL);
void TestSmallBlockAlloc();
void TestUtilities();

// Main entry

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    g_hInst = hInstance;

    InitProcess();
    InitThread();

    LPWSTR pCL = MultiByteToUnicode(lpCmdLine);

    switch (*pCL)
    {
    case 'z':
        TestParser(pCL);
        break;

    case 't':
        TestColorTable();
        break;

    case 'c':
        TestContainment(pCL);
        break;

    case 's':
        TestScalability(pCL);
        break;

    case 'a':
        TestSmallBlockAlloc();
        break;

    case 'u':
        TestUtilities();
        break;

    default:
        MessageBoxW(NULL, L"Valid parameters:\nu - Base Utility test\na - Small block allocator\ns<Count> - Scalability\nc<Levels> - Containment\nt - Color table\nz<.UI File>", L"DirectUI Test Suite Usage", MB_OK|MB_ICONINFORMATION);
        break;
    }    

    HFree(pCL);

    UnInitThread();
    UnInitProcess();
    
    return 0;
}

////////////////////////////////////////////////////////////////////
// Test Parser
//

void CALLBACK UIParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

void TestParser(LPWSTR pCL)
{
    HRESULT hr;

    // Get filename
    pCL++;
    if (!*pCL)
        UIParseError(L"No .UI file specified", L"Parser Test", -1);

    // Parse file
    Parser* pParser;
    hr = Parser::Create(pCL, g_hInst, UIParseError, &pParser);
    TEST(SUCCEEDED(hr));

    Element::StartDefer();

    Element* pe;
    pParser->CreateElement(L"main", NULL, &pe);
    if (pe)
    {
        NativeHWNDHost* pnhh;
        NativeHWNDHost::Create(L"UIRun", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);
        
        HWNDElement* phe;
        HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);

        BorderLayout* pbl;
        BorderLayout::Create((Layout**)&pbl);
        phe->SetLayout(pbl);

        pe->SetLayoutPos(BLP_Client);
        phe->Add(pe);

        phe->SetVisible(true);

        pnhh->Host(phe);

        Element::EndDefer();

        pnhh->ShowWindow();

        StartMessagePump();

        // phe will be deleted by native HWND host when destroyed
        pnhh->Destroy();
    }
    else
        Element::EndDefer();

    pParser->Destroy();
}

////////////////////////////////////////////////////////////////////
// Test color table
//

Element* CreateHeader(UINT* pCount)
{
    Element* peHdr;
    Element::Create(0, &peHdr);
    (*pCount)++;

    peHdr->SetActive(AE_Mouse);
    peHdr->SetVisible(true);
    peHdr->SetBackgroundStdColor(SC_White);
    peHdr->SetContentString(L"Standard Color Table");
    peHdr->SetFontSize(60);
    peHdr->SetForegroundStdColor(SC_Silver);
    peHdr->SetPadding(10, 0, 80, 10);

    return peHdr;
}

Element* CreateColorTable(UINT* pCount)
{
    UNREFERENCED_PARAMETER(pCount);

    Element* peHost;
    Element::Create(0, &peHost);

    GridLayout* pgl;
    GridLayout::Create((UINT)-1, 10, (Layout**)&pgl);
    peHost->SetLayout(pgl);

    peHost->SetContentAlign(CA_MiddleCenter);
    peHost->SetFontSize(14);

    Element* pe;
    COLORREF cr;
    for (UINT c = 0; c <= SC_MAXCOLORS; c++)
    {
        Element::Create(0, &pe);
        pe->SetBackgroundStdColor(c);
        pe->SetBorderStdColor(SC_Silver);
        pe->SetBorderThickness(2, 2, 2, 2);
        pe->SetBorderStyle(BDS_Sunken);

        pe->SetContentString(GetStdColorName(c));

        cr = GetStdColorI(c);
        if (GetRValue(cr) < 192 && GetBValue(cr) < 192 && GetGValue(cr) < 192)
        {
            pe->SetForegroundStdColor(SC_White);
        }

        peHost->Add(pe);
    }

    return peHost;
}

void TestColorTable()
{
    UINT uCount = 0;

    NativeHWNDHost* pnhh;
    NativeHWNDHost::Create(L"", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);

    StartBlockTimer();

    Element::StartDefer();

    HWNDElement* peApp;
    HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&peApp);

    BorderLayout* pbl;
    BorderLayout::Create((Layout**)&pbl);
    peApp->SetLayout(pbl);

    Element* peSection = CreateHeader(&uCount);
    peSection->SetLayoutPos(BLP_Top);
    peApp->Add(peSection);

    Element* peCTable = CreateColorTable(&uCount);
    peCTable->SetLayoutPos(BLP_Client);
    peApp->Add(peCTable);

    peApp->SetVisible(true);

    pnhh->Host(peApp);

    Element::EndDefer();

    pnhh->ShowWindow();

    StopBlockTimer();

    DUITrace("Time (%d Elements): %dms\n", uCount, BlockTime());

    StartMessagePump();

    // peApp will be destroyed when native host is destroyed
    pnhh->Destroy();
}

////////////////////////////////////////////////////////////////////
// Test containment
//

int g_iLevels;
Element** g_ppe;
UINT g_uElUsed;

class NestElement : public Element
{
public:
    static HRESULT Create(Element** ppElement);

    void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    int nColor;  // Standard color

    NestElement() { };
    virtual ~NestElement() { };
    HRESULT Initialize() { return Element::Initialize(0); }
};

HRESULT NestElement::Create(Element** ppElement)
{
    *ppElement = NULL;

    NestElement* pne = HNew<NestElement>();
    if (!pne)
        return E_OUTOFMEMORY;

    HRESULT hr = pne->Initialize();
    if (FAILED(hr))
        return hr;

    *ppElement = pne;

    return S_OK;
}

void NestElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(MouseFocused))
    {
        Value* pvBack = GetValue(BackgroundProp, PI_Specified);
        if (pvBack->GetType() == DUIV_INT)
        {
            if (pvNew->GetBool())
            {
                nColor = pvBack->GetInt();
                SetBackgroundStdColor(SC_Gray);
            }
            else
            {
                SetBackgroundStdColor(nColor);
            }
        }

        pvBack->Release();
    }
}

int nColors[4] = { SC_Red, SC_Green, SC_Blue, SC_Yellow };
LPWSTR pszContent[] = { L"UL", L"UR", L"BL", L"BR" };

void BuildNesting(Element* peContainer, int dLevel)
{
    if (dLevel == 0)
    {
        // Root
        peContainer->SetPadding(4, 4, 4, 4);

        GridLayout* pgl;
        GridLayout::Create(2, 2, (Layout**)&pgl);
        peContainer->SetLayout(pgl);

        peContainer->SetActive(AE_Mouse);

        g_uElUsed++;

        BuildNesting(peContainer, ++dLevel);
    }
    else if (dLevel <= g_iLevels)
    {
        Element** ppeChildList = g_ppe + g_uElUsed;
        g_uElUsed += 4;

        peContainer->Add(ppeChildList, 4);

        // Build nesting (add children) to given container
        GridLayout* pgl;
        for (int i = 0; i < 4; i++)
        {
            ppeChildList[i]->SetForegroundStdColor(SC_Black);

            // Checks: Normal 1, Transparacy 2, Inheritance Neither
            ppeChildList[i]->SetBackgroundStdColor(nColors[i]);

            ppeChildList[i]->SetPadding(4, 4, 4, 4);
            ppeChildList[i]->SetContentString(pszContent[i]);

            ppeChildList[i]->SetActive(AE_Mouse);

            if ((i == 0 || i == 3) && dLevel < g_iLevels)
            {
                GridLayout::Create(2, 2, (Layout**)&pgl);
                ppeChildList[i]->SetLayout(pgl);
            }
        }

        // Continue nesting recursion
        dLevel++;

        BuildNesting(ppeChildList[0], dLevel);
        BuildNesting(ppeChildList[3], dLevel);
    }
}

UINT NestedElCount(int dLevels)
{
    if (dLevels == 1)
        return 4;

    return NestedElCount(dLevels - 1) + (int)pow(2, dLevels + 1);
}

void TestContainment(LPWSTR pCL)
{
    NativeHWNDHost* pnhh;
    NativeHWNDHost::Create(L"Containment", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);

    // Move to value, example syntax: 'c6'
    pCL++;

    g_iLevels = 0;
    if (pCL && *pCL)
        g_iLevels = _wtoi(pCL);

    if (!g_iLevels)
        g_iLevels = 6;

    StartBlockTimer();

    Element::StartDefer();

    UINT uNestedElCount = NestedElCount(g_iLevels);

    HWNDElement* phe;
    HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);

    // Create pointer array and assign
    g_ppe = (Element**)HAlloc((uNestedElCount + 1) * sizeof(Element*));
    for (UINT i = 0; i < uNestedElCount + 1; i++)
        NestElement::Create(&g_ppe[i]);

    g_uElUsed = 0;

    BuildNesting(*g_ppe, 0);

    GridLayout* pgl;
    GridLayout::Create(1, 1, (Layout**)&pgl);
    phe->SetLayout(pgl);
    
    phe->Add(*g_ppe);
    phe->SetVisible(true);

    pnhh->Host(phe);

    Element::EndDefer();

    pnhh->ShowWindow();

    StopBlockTimer();

    DUIAssert(g_uElUsed - 1 == uNestedElCount, "Elements counts don't match up");

    DUITrace("Time (%d Levels of Containment): %dms\n", g_iLevels, BlockTime());

    StartMessagePump();

    HFree(g_ppe);

    // phe will be destroyed when native HWND is destroyed
    pnhh->Destroy();
}

////////////////////////////////////////////////////////////////////
// Test scalability
//

void TestScalability(LPWSTR pCL)
{
    NativeHWNDHost* pnhh;
    NativeHWNDHost::Create(L"Scalability", NULL, NULL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0, WS_OVERLAPPEDWINDOW, 0, &pnhh);

    StartBlockTimer();

    ProfileOn();

    Element::StartDefer();

    // Move to value, example syntax: 's1000'
    pCL++;

    UINT iElCount = 0;
    if (pCL && *pCL)
        iElCount = _wtoi(pCL);

    if (!iElCount)
        iElCount = 1000;

    HWNDElement* phe;
    HWNDElement::Create(pnhh->GetHWND(), true, 0, (Element**)&phe);

    GridLayout* pgl;
    GridLayout::Create(40, (UINT)-1, (Layout**)&pgl);
    phe->SetLayout(pgl);

    phe->SetBackgroundColor(SC_Yellow);

    // Create pointer array and assign
    Element** ppe = (Element**)HAlloc(iElCount * sizeof(Element*));
    for (UINT i = 0; i < iElCount; i++)
        Element::Create(0, &ppe[i]);

    Value* pv[4];

    pv[0] = Value::CreateInt(SC_Red);
    pv[1] = Value::CreateInt(SC_Green);
    pv[2] = Value::CreateInt(SC_Blue);
    pv[3] = Value::CreateInt(SC_Yellow);

    for (i = 0; i < iElCount; i++)
    {
        ppe[i]->SetValue(Element::BackgroundProp, PI_Local, pv[i % 4]);
    }

    pv[0]->Release();
    pv[1]->Release();
    pv[2]->Release();
    pv[3]->Release();

    phe->Add(ppe, iElCount);

    phe->SetVisible(true);

    pnhh->Host(phe);

    Element::EndDefer();

    ProfileOff();

    pnhh->ShowWindow();

    StopBlockTimer();

    StartMessagePump();

    HFree(ppe);

    // phe destroyed when native HWND is destroyed
    pnhh->Destroy();
}

////////////////////////////////////////////////////////////////////
// Test small block allocator
//

UINT cLeaks = 0;

// Value small block leak detector
class LeakCheck : public ISBLeak
{
    void AllocLeak(void* pBlock) { UNREFERENCED_PARAMETER(pBlock); cLeaks++; }
} vlCheck;

struct TestAlloc
{
    BYTE fReserved;
    int dVal;
};

void TestSmallBlockAlloc()
{
    SBAlloc* psba;
    SBAlloc::Create(sizeof(TestAlloc), 2, &vlCheck, &psba);

    void* b0 = psba->Alloc();
    void* b1 = psba->Alloc();

    TEST(b0 && b1);

    psba->Free(b0);
    psba->Free(b1);

    b1 = psba->Alloc();
    b0 = psba->Alloc();

    TEST(b0 && b1);

    psba->Free(b0);
    psba->Free(b1);

    // Check leak detector
    for (int i = 0; i < 256; i++)
        psba->Alloc();

    psba->Destroy();

    TEST(cLeaks == 256);

    PASSED(L"Small block allocator");
}

////////////////////////////////////////////////////////////////////
// Test utilities
//

void TestUtilities()
{
    // BTree lookup
    BTreeLookup<int>* pbl;
    BTreeLookup<int>::Create(false, &pbl);

    TEST(!pbl->GetItem((void*)9));

    pbl->SetItem((void*)9, 1111);
    pbl->SetItem((void*)7, 2222);

    TEST(*(pbl->GetItem((void*)9)) == 1111);

    pbl->SetItem((void*)9, 3333);
    TEST(*(pbl->GetItem((void*)7)) == 2222);
    TEST(*(pbl->GetItem((void*)9)) == 3333);

    pbl->Remove((void*)0);
    pbl->Remove((void*)9);

    TEST(!pbl->GetItem((void*)9));

    pbl->Remove((void*)7);

    TEST(!pbl->GetItem((void*)7));

    pbl->SetItem((void*)0, 9999);

    TEST(*(pbl->GetItem((void*)0)) == 9999);

    pbl->Destroy();

    // Value map
    ValueMap<int,int>* pvm;
    ValueMap<int,int>::Create(5, &pvm);

    pvm->SetItem(1, 1111, false);
    pvm->SetItem(2, 2222, false);

    int* pValue;

    pValue = pvm->GetItem(2, false);
    TEST(*pValue == 2222);

    pvm->Remove(2, false, false);

    pValue = pvm->GetItem(2, false);
    TEST(pValue == NULL);

    pValue = pvm->GetItem(1, false);
    TEST(*pValue == 1111);

    pvm->SetItem(5, 5555, false);

    pValue = pvm->GetItem(5, false);
    TEST(*pValue == 5555);

    pvm->Remove(1, true, false);

    pValue = pvm->GetItem(5, false);
    TEST(*pValue == 5555);

    pvm->Destroy();

    // Dynamic array
    DynamicArray<int>* pda;
    DynamicArray<int>::Create(0, 0, &pda);

    pda->Add(1000);
    pda->Add(3000);
    pda->Add(4000);

    TEST(pda->GetItem(0) == 1000);
    TEST(pda->GetItem(1) == 3000);

    pda->Insert(1, 2000);

    TEST(pda->GetItem(1) == 2000);
    TEST(pda->GetItem(3) == 4000);

    pda->SetItem(2, 9999);

    TEST(pda->GetItem(2) == 9999);

    TEST(pda->GetSize() == 4);

    pda->Remove(0);
    pda->Remove(0);

    TEST(pda->GetSize() == 2);
    TEST(pda->GetItem(1) == 4000);

    pda->Reset();

    pda->Add(9);
    pda->Insert(0, 8);
    pda->Insert(0, 7);
    pda->Insert(0, 6);
    pda->Insert(0, 5);
    pda->Insert(0, 4);
    pda->Insert(0, 3);
    pda->Insert(0, 2);
    pda->Insert(0, 1);
    pda->Insert(0, 0);

    TEST(pda->GetSize() == 10);
    TEST(pda->GetItem(1) == 1);

    pda->Destroy();

    DynamicArray<PCRecord>* pdaPC;
    DynamicArray<PCRecord>::Create(0, 0, &pdaPC);
    PCRecord* ppcr;

    for (int i = 0; i < 10000; i++)
    {
        pdaPC->AddPtr(&ppcr);
        ppcr->pe = (Element*)(INT_PTR)i;
        ppcr->ppi = (PropertyInfo*)(INT_PTR)i;
        ppcr->iIndex = i;
        ppcr->fVoid = false;
        ppcr->pvNew = NULL;
        ppcr->pvOld = NULL;
        ppcr->dr.cDepCnt = i;
        ppcr->dr.iDepPos = i;
    }

    TEST(pdaPC->GetSize() == 10000);

    pdaPC->Destroy();

    PASSED(L"Base utility test");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\duexts.h ===
/****************************** Module Header ******************************\
*
* Module Name: DuExts.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Common include files for DuExts
* 
* History:
* 11-30-2000    JStall      Created
*
\***************************************************************************/
#ifndef DUEXTS__DuExts_h__INCLUDED
#define DUEXTS__DuExts_h__INCLUDED

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI

#endif // DUEXTS__DuExts_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\genuedef.c ===
LIBRARY DUEXTS

;
; This file allows one file (exts.h) to be used to generate extension 
; exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to DuExts.c
;

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"

;--------------------------------------------------------------------
;
; these are the extension service functions provided for the debugger
;
;--------------------------------------------------------------------

    WinDbgExtensionDllInit
    ExtensionApiVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\duexts.cpp ===
/****************************** Module Header ******************************\
*
* Module Name: DuExts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 11-30-2000    JStall      Created
*
\******************************************************************************/

#include "precomp.h"
#pragma hdrstop

PSTR pszExtName         = "DUEXTS";

#include "stdext64.h"
#include "stdext64.cpp"

/******************************************************************************\
* Constants
\******************************************************************************/
#define BF_MAX_WIDTH    80
#define BF_COLUMN_WIDTH 19

#define NULL_POINTER    ((ULONG64)(0))
#define COUNTOF(x) (sizeof(x) / sizeof(x[0]))

// If you want to debug the extension, enable this.
#if 0
#undef DEBUGPRINT
#define DEBUGPRINT  Print
#endif

/******************************************************************************\
* Global variables
\******************************************************************************/
BOOL bServerDebug = TRUE;
BOOL bShowFlagNames = TRUE;
char gach1[80];
char gach2[80];
char gach3[80];
int giBFColumn;                     // bit field: current column
char gaBFBuff[BF_MAX_WIDTH + 1];    // bit field: buffer

// used in dsi() and dinp()
typedef struct {
    int     iMetric;
    LPSTR   pstrMetric;
} SYSMET_ENTRY;
#define SMENTRY(sm) {SM_##sm, #sm}

extern int gnIndent; // indentation of !dso
/******************************************************************************\
* Macros
\******************************************************************************/

#define NELEM(array) (sizeof(array)/sizeof(array[0]))

#define TestWWF(pww, flag)   (*(((PBYTE)(pww)) + (int)HIBYTE(flag)) & LOBYTE(flag))

void ShowProgress(ULONG i);

void PrivateSetRipFlags(DWORD dwRipFlags, DWORD pid);

#define VAR(v)  "DUser!" #v
#define SYM(s)  "DUser!" #s


/*
 * Use these macros to print field values, globals, local values, etc.
 * This assures consistent formating plus make the extensions easier to read and to maintain.
 */
#define STRWD1 "67"
#define STRWD2 "28"
#define DWSTR1 "%08lx %." STRWD1 "s"
#define DWSTR2 "%08lx %-" STRWD2 "." STRWD2 "s"
#define PTRSTR1 "%08p %-" STRWD1 "s"
#define PTRSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define DWPSTR1 "%08p %." STRWD1 "s"
#define DWPSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define PRTFDW1(p, f1) Print(DWSTR1 "\n", (DWORD)##p##f1, #f1)
#define PRTVDW1(s1, v1) Print(DWSTR1 "\n", v1, #s1)
#define PRTFDW2(p, f1, f2) Print(DWSTR2 "\t" DWSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD)##p##f2, #f2)
#define PRTVDW2(s1, v1, s2, v2) Print(DWSTR2 "\t" DWPSTR2 "\n", v1, #s1, v2, #s2)
#define PRTFRC(p, rc) Print("%-" STRWD2 "s{%#lx, %#lx, %#lx, %#lx}\n", #rc, ##p##rc.left, ##p##rc.top, ##p##rc.right, ##p##rc.bottom)
#define PRTFPT(p, pt) Print("%-" STRWD2 "s{%#lx, %#lx}\n", #pt, ##p##pt.x, ##p##pt.y)
#define PRTVPT(s, pt) Print("%-" STRWD2 "s{%#lx, %#lx}\n", #s, pt.x, pt.y)
#define PRTFDWP1(p, f1) Print(DWPSTR1 "\n", (DWORD_PTR)##p##f1, #f1)
#define PRTFDWP2(p, f1, f2) Print(DWPSTR2 "\t" DWPSTR2 "\n", (DWORD_PTR)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)
#define PRTFDWPDW(p, f1, f2) Print(DWPSTR2 "\t" DWSTR2 "\n", (DWORD_PTR)##p##f1, #f1, (DWORD)##p##f2, #f2)
#define PRTFDWDWP(p, f1, f2) Print(DWSTR2 "\t" DWPSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)

/*
 * Bit Fields
 */
#define BEGIN_PRTFFLG()
#define PRTFFLG(p, f)   PrintBitField(#f, (BOOLEAN)!!(p.f))
#define END_PRTFFLG()   PrintEndBitField()


#define PRTGDW1(g1) \
        { DWORD _dw1; \
            moveExpValue(&_dw1, VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); }

#define PRTGDW2(g1, g2) \
        { DWORD _dw1, _dw2; \
            moveExpValue(&_dw1, VAR(g1)); \
            moveExpValue(&_dw2, VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n",  _dw1, #g1, _dw2, #g2); }

#define PTRGPTR1(g1) \
    Print(PTRSTR1 "\n", GetGlobalPointer(VAR(g1)), #g1)

#define PRTGPTR2(g1, g2) \
    Print(PTRSTR2 "\t" PTRSTR2 "\n", GetGlobalPointer(VAR(g1)), #g1, GetGlobalPointer(VAR(g2)), #g2)


/* This macro requires char ach[...]; to be previously defined */
#define PRTWND(s, pwnd) \
        { DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #s, pwnd, ach); }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd; \
            moveExpValuePtr(&_pwnd, VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }

LPSTR GetFlags(WORD wType, DWORD dwFlags, LPSTR pszBuf, BOOL fPrintZero);
BOOL CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax);

int PtrWidth()
{
    static int width = 0;
    if (width) {
        return width;
    }
    if (IsPtr64()) {
        return width = 17;
    }
    return width = 8;
}


/*******************************************************************************\
* Flags stuff
\*******************************************************************************/

#define NO_FLAG (LPCSTR)(LONG_PTR)0xFFFFFFFF  // use this for non-meaningful entries.
#define _MASKENUM_START         (NO_FLAG-1)
#define _MASKENUM_END           (NO_FLAG-2)
#define _SHIFT_BITS             (NO_FLAG-3)
#define _CONTINUE_ON            (NO_FLAG-4)

#define MASKENUM_START(mask)    _MASKENUM_START, (LPCSTR)(mask)
#define MASKENUM_END(shift)     _MASKENUM_END, (LPCSTR)(shift)
#define SHIFT_BITS(n)           _SHIFT_BITS, (LPCSTR)(n)
#define CONTINUE_ON(arr)        _CONTINUE_ON, (LPCSTR)(arr)

#if 0
enum GF_FLAGS {
    GF_MAX
};


CONST PCSTR* aapszFlag[GF_MAX] = {
};


/***************************************************************************\
* Procedure: GetFlags
*
* Description:
*
* Converts a 32bit set of flags into an appropriate string.
* pszBuf should be large enough to hold this string, no checks are done.
* pszBuf can be NULL, allowing use of a local static buffer but note that
* this is not reentrant.
* Output string has the form: "FLAG1 | FLAG2 ..." or "0"
*
* Returns: pointer to given or static buffer with string in it.
*
* 6/9/1995 Created SanfordS
*
\***************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    CONST PCSTR *apszFlags;
    LPSTR apszFlagNames[sizeof(DWORD) * 8], pszT;
    const char** ppszNextFlag;
    UINT uFlagsCount, uNextFlag;
    DWORD dwUnnamedFlags, dwLoopFlag;
    DWORD dwShiftBits;
    DWORD dwOrigFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    if (!bShowFlagNames) {
        sprintf(pszBuf, "%x", dwFlags);
        return pszBuf;
    }

    if (wType >= GF_MAX) {
        strcpy(pszBuf, "Invalid flag type.");
        return pszBuf;
    }

    /*
     * Initialize output buffer and names array
     */
    *pszBuf = '\0';
    RtlZeroMemory(apszFlagNames, sizeof(apszFlagNames));

    apszFlags = aapszFlag[wType];

    /*
     * Build a sorted array containing the names of the flags in dwFlags
     */
    uFlagsCount = 0;
    dwUnnamedFlags = dwOrigFlags = dwFlags;
    dwLoopFlag = 1;
    dwShiftBits = 0;

reentry:
    for (i = 0; dwFlags; dwFlags >>= 1, i++, dwLoopFlag <<= 1, ++dwShiftBits) {
        const char* lpszFlagName = NULL;

        /*
         * Bail if we reached the end of the flag names array
         */
        if (apszFlags[i] == NULL) {
            break;
        }

        if (apszFlags[i] == _MASKENUM_START) {
            //
            // Masked enumerative items.
            //
            DWORD en = 0;
            DWORD dwMask = (DWORD)(ULONG_PTR)apszFlags[++i];

            // First, clear up the handled bits.
            dwUnnamedFlags &= ~dwMask;
            lpszFlagName = NULL;
            for (++i; apszFlags[i] != NULL && apszFlags[i] != _MASKENUM_END; ++i, ++en) {
                if ((dwOrigFlags & dwMask) == (en << dwShiftBits )) {
                    if (apszFlags[i] != NO_FLAG) {
                        lpszFlagName = apszFlags[i];
                    }
                }
            }
            //
            // Shift the bits and get ready for the next item.
            // Next item right after _MASKENUM_END holds the bits to shift.
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            if (lpszFlagName == NULL) {
                //
                // Could not find the match. Skip to the next item.
                //
                continue;
            }
        }
        else if (apszFlags[i] == _CONTINUE_ON) {
            //
            // Refer the other item array. Pointer to the array is stored at [i+1].
            //
            apszFlags = (LPSTR*)apszFlags[i + 1];
            goto reentry;
        }
        else if (apszFlags[i] == _SHIFT_BITS) {
            //
            // To save some space, just shift some bits..
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            continue;
        }
        else {
            /*
             * continue if this bit is not set or we don't have a name for it
             */
            if (!(dwFlags & 1) || (apszFlags[i] == NO_FLAG)) {
                continue;
            }
            lpszFlagName = apszFlags[i];
        }

        /*
         * Find the sorted position where this name should go
         */
        ppszNextFlag = apszFlagNames;
        uNextFlag = 0;
        while (uNextFlag < uFlagsCount) {
            if (strcmp(*ppszNextFlag, lpszFlagName) > 0) {
                break;
            }
            ppszNextFlag++;
            uNextFlag++;
        }
        /*
         * Insert the new name
         */
        RtlMoveMemory((char*)(ppszNextFlag + 1), ppszNextFlag, (uFlagsCount - uNextFlag) * sizeof(DWORD));
        *ppszNextFlag = lpszFlagName;
        uFlagsCount++;
        /*
         * We got a name so clear it from the unnamed bits.
         */
        dwUnnamedFlags &= ~dwLoopFlag;
    }

    /*
     * Build the string now
     */
    ppszNextFlag = apszFlagNames;
    pszT = pszBuf;
    /*
     * Add the first name
     */
    if (uFlagsCount > 0) {
        pszT += sprintf(pszT, "%s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * Concatenate all other names with " |"
     */
    while (uFlagsCount > 0) {
        pszT += sprintf(pszT, " | %s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * If there are unamed bits, add them at the end
     */
    if (dwUnnamedFlags != 0) {
        pszT += sprintf(pszT, " | %#lx", dwUnnamedFlags);
    }
    /*
     * Print zero if needed and asked to do so
     */
    if (fPrintZero && (pszT == pszBuf)) {
        sprintf(pszBuf, "0");
    }

    return pszBuf;
}

#endif

///////////////////////////////////////////////////////////////////////////
//
// Enumerated items with mask
//
///////////////////////////////////////////////////////////////////////////

typedef struct {
    LPCSTR  name;
    DWORD   value;
} EnumItem;

#define EITEM(a)     { #a, a }

/***************************************************************************\
* Helper Procedures: dso etc.
*
* 04/19/2000 Created Hiro
\***************************************************************************/

// to workaround nosy InitTypeRead
#define _InitTypeRead(Addr, lpszType)   GetShortField(Addr, (PUCHAR)lpszType, 1)

#define CONTINUE    EXCEPTION_EXECUTE_HANDLER

#define RAISE_EXCEPTION() RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL)

#define BAD_SYMBOL(symbol) \
    Print("Failed to get %s: bad symbol?\n", symbol); \
    RAISE_EXCEPTION()

#define CANT_GET_VALUE(symbol, p) \
    Print("Failed to get %s @ %p: memory paged out?\n", symbol, p); \
    RAISE_EXCEPTION()



BOOL dso(LPCSTR szStruct, ULONG64 address, ULONG dwOption)
{
    SYM_DUMP_PARAM symDump = {
        sizeof symDump, (PUCHAR) szStruct, dwOption, // 0 for default dump like dt
        address,
        NULL, NULL, NULL, 0, NULL
    };

    return Ioctl(IG_DUMP_SYMBOL_INFO, &symDump, symDump.size);
}

ULONG64 GetPointer(ULONG64 addr)
{
    ULONG64 p = 0;
    if (!ReadPointer(addr, &p)) {
        CANT_GET_VALUE("a pointer", addr);
    }
    return p;
}

DWORD GetDWord(ULONG64 addr)
{
    ULONG64 dw = 0xbaadbaad;

    if (!GetFieldData(addr, "DWORD", NULL, sizeof dw, &dw)) {
        CANT_GET_VALUE("DWORD", addr);
    }
    return (DWORD)dw;
}

WORD GetWord(ULONG64 addr)
{
    ULONG64 w = 0xbaad;

    if (!GetFieldData(addr, "WORD", NULL, sizeof w, &w)) {
        CANT_GET_VALUE("WORD", addr);
    }
    return (WORD)w;
}

BYTE GetByte(ULONG64 addr)
{
    ULONG64 b = 0;

    if (GetFieldData(addr, "BYTE", NULL, sizeof b, &b)) {
        CANT_GET_VALUE("BYTE", addr);
    }
    return (BYTE)b;
}

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) || (result < sizeof(ULONG))) {
        dprintf("GetUlongFromAddress: unable to read from %I64x\n", Location);
        RAISE_EXCEPTION();
    }

    return Value;
}


ULONG64 GetGlobalPointer(LPSTR symbol)
{
    ULONG64 pp;
    ULONG64 p = 0;

    pp = EvalExp(symbol);
    if (pp == 0) {
        BAD_SYMBOL(symbol);
    } else if (!ReadPointer(pp, &p)) {
        CANT_GET_VALUE(symbol, pp);
    }
    return p;
}

ULONG64 GetGlobalPointerNoExp(LPSTR symbol) // no exception
{
    ULONG64 p = 0;
    __try {
        p = GetGlobalPointer(symbol);
    } __except (CONTINUE) {
    }
    return p;
}

ULONG64 GetGlobalMemberAddress(LPSTR symbol, LPSTR type, LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG offset;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldOffset(type, field, &offset)) {
        BAD_SYMBOL(type);
    }

    return pVar + offset;
}

ULONG64 GetGlobalMember(LPSTR symbol, LPSTR type, LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG64 val;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldValue(pVar, type, field, val)) {
        CANT_GET_VALUE(symbol, pVar);
    }

    return val;
}

ULONG64 GetArrayElement(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index,
    LPSTR lpszType)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
        ulSize = GetTypeSize(lpszType);
    }
    ReadMemory(pAddr + ulOffsetBase + ulSize * index, &result, ulSize, NULL);

    return result;
}

ULONG64 GetArrayElementPtr(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
    }
    if (ulSize == 0) {
        ulSize = GetTypeSize("PVOID");
    }
    ReadPointer(pAddr + ulOffsetBase + ulSize * index, &result);

    return result;
}

/*
 * Show progress in time consuming commands
 * 10/15/2000 hiroyama
 */
void ShowProgress(ULONG i)
{
    const char* clock[] = {
        "\r-\r",
        "\r\\\r",
        "\r|\r",
        "\r/\r",
    };

    /*
     * Show the progress :-)
     */
    Print(clock[i % COUNTOF(clock)]);
}

#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

/***************************************************************************\
* Procedure: PrintBitField, PrintEndBitField
*
* Description: Printout specified boolean value in a structure.
*  Assuming strlen(pszFieldName) will not exceeds BF_COLUMN_WIDTH.
*
* Returns: None
*
* 10/12/1997 Created HiroYama
*
\***************************************************************************/
void PrintBitField(LPSTR pszFieldName, BOOLEAN fValue)
{
    int iWidth;
    int iStart = giBFColumn;

    sprintf(gach1, fValue ? "*%-s " : " %-s ", pszFieldName);

    iWidth = (strlen(gach1) + BF_COLUMN_WIDTH - 1) / BF_COLUMN_WIDTH;
    iWidth *= BF_COLUMN_WIDTH;

    if ((giBFColumn += iWidth) >= BF_MAX_WIDTH) {
        giBFColumn = iWidth;
        Print("%s\n", gaBFBuff);
        iStart = 0;
    }

    sprintf(gaBFBuff + iStart, "%-*s", iWidth, gach1);
}

void PrintEndBitField()
{
    if (giBFColumn != 0) {
        giBFColumn = 0;
        Print("%s\n", gaBFBuff);
    }
}


/***************************************************************************\
*
* Procedure: CopyUnicodeString
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\***************************************************************************/
BOOL
CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax)
{
    ULONG Length;
    ULONG64 Buffer;
    char szLengthName[256];
    char szBufferName[256];

    if (pData == 0) {
        pszDest[0] = '\0';
        return FALSE;
    }

    strcpy(szLengthName, pszFieldName);
    strcat(szLengthName, ".Length");
    strcpy(szBufferName, pszFieldName);
    strcat(szBufferName, ".Buffer");

    if (GetFieldValue(pData, pszStructName, szLengthName, Length) ||
        GetFieldValue(pData, pszStructName, szBufferName, Buffer)) {

        wcscpy(pszDest, L"<< Can't get name >>");
        return FALSE;
    }

    if (Buffer == 0) {
        wcscpy(pszDest, L"<null>");
    } else {
        ULONG cbText;
        cbText = min(cchMax, Length + sizeof(WCHAR));
        if (!(tryMoveBlock(pszDest, Buffer, cbText))) {
            wcscpy(pszDest, L"<< Can't get value >>");
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************\
*
* DirectUser TLS access
*
* 12/03/2000 JStall       Created
*
\***************************************************************************/

BOOL
ReadTlsValue(ULONG64 pteb, ULONG idxSlot, ULONG64 * ppValue)
{
    BOOL fSuccess = FALSE;
    ULONG64 pValue = NULL;

    //
    // Need to remove the high-bit from the TLS slot.  This is set on in 
    // Checked build to detect illegal / uninitialized slots, such as '0'.
    //

    idxSlot &= 0x7FFFFFFF;


    //
    // Get TLS info
    //

    ULONG64 pThread = 0;

//    Print("> idxSlot: %d\n", idxSlot);
//    Print("> TEB: 0x%p\n", pteb);

    if (pteb) {
        ULONG64 rgTLS   = NULL;
        ULONG ulOffset  = 0;
        ULONG ulSize    = GetTypeSize("PVOID");
//        Print("> ulSize: %d\n", ulSize);

        if (idxSlot < TLS_MINIMUM_AVAILABLE) {
            // pThread = Teb->TlsSlots[idxSlot];

            GetFieldOffset(SYM(_TEB), "TlsSlots", &ulOffset);
//            Print("> TlsSlots offset: %d\n", ulOffset);

            ReadPointer(pteb + ulOffset + ulSize * idxSlot, &pValue);
            fSuccess = TRUE;

        } else if (idxSlot >= TLS_MINIMUM_AVAILABLE + TLS_EXPANSION_SLOTS) {
            Print("ERROR: Invalid TLS index %d\n", idxSlot);
        } else {
            // pThread = Teb->TlsExpansionSlots[idxSlot - TLS_MINIMUM_AVAILABLE];

            GetFieldOffset("_TEB", "TlsExpansionSlots", &ulOffset);
//            Print("> TlsExpansionSlots offset: %d\n", ulOffset);

            rgTLS = GetPointer(pteb + ulOffset);
            if (rgTLS != NULL) {
                ReadPointer(rgTLS + ulSize * (idxSlot - TLS_MINIMUM_AVAILABLE), &pValue);
                fSuccess = TRUE;
            }
        }
    }

    *ppValue = pValue;
    return fSuccess;
}


/***************************************************************************\
*
* GetDUserThread
*
* GetDUserThread() returns the global Thread object for the current thread.
*
* 12/03/2000 JStall       Created
*
\***************************************************************************/

BOOL
GetDUserThread(ULONG64 pteb, ULONG64 * ppThread)
{
    *ppThread = NULL;


    //
    // Get DUser TLS slot
    //

    ULONG idxSlot = (ULONG) GetGlobalPointer(VAR(g_tlsThread));
    if (idxSlot == (UINT) -1) {
        Print("ERROR: Unable to get DirectUser TLS information.\n");
        return FALSE;
    }

    if ((!ReadTlsValue(pteb, idxSlot, ppThread)) || (*ppThread == NULL)) {
        Print("ERROR: Unable to get DirectUser Thread information.\n");
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igthread
*
* Dumps DUser Thread information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igthread(DWORD opts, ULONG64 param1)
{
    int nMsg;
    ULONG64 pThread = NULL, pteb = NULL;

    BOOL fVerbose = TRUE;

    __try {
        //
        // Determine options
        //

        fVerbose = opts & OFLAG(v);


        //
        // Get Thread information
        //

        if (opts & OFLAG(t)) {
            //
            // Use the specified TEB
            //

            pteb = param1;
        } else if (param1 == 0) {
            //
            // Use the current thread's TEB
            //

            GetTebAddress(&pteb);
        } 

        if (pteb != NULL) {
            GetDUserThread(pteb, &pThread);
        }
        

        //
        // Display information
        //

        if (pThread != NULL) {
            Print("DUser Thread: 0x%p  pteb: 0x%p\n", pThread, pteb);
            dso(SYM(Thread), pThread, 0);

            ULONG64 pCoreST = GetArrayElementPtr(pThread, SYM(Thread), "m_rgSTs", 0);

            if (pCoreST != NULL) {
                Print("\nDUser CoreST: 0x%p\n", pCoreST);
                dso(SYM(CoreST), pCoreST, 0);
            }

        } else {
            Print("ERROR: Unable to read DUser Thread\n");
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Itls
*
* Dumps a TLS slot value
*
*  6/08/2001 JStall       Created
*
\***************************************************************************/

BOOL Itls(DWORD opts, ULONG64 param1, ULONG64 param2)
{
    __try {
        ULONG idxSlot = ((ULONG) param1) & 0x7FFFFFFF;
        ULONG64 pteb = param2;
        ULONG64 pData;

        if (idxSlot == 0) {
            Print("ERROR: Need to specify a TLS slot.\n");
        } else {
            if (param2 == 0) {
                //
                // Need to determine the current thread
                //
                GetTebAddress(&pteb);
            }

            if (pteb == 0) {
                Print("ERROR: Unable to get thread information.\n");
            } else {
                if (!ReadTlsValue(pteb, idxSlot, &pData)) {
                    Print("ERROR: Unable to get TLS information.\n");
                } else {
                    Print("TLS[%d] = 0x%p  %d\n", idxSlot, pData, pData);
                }
            }
        }
    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igcontext
*
* Dumps DUser Context information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igcontext(DWORD opts, ULONG64 param1)
{
    int nMsg;
    ULONG64 pThread = NULL, pContext = NULL, pteb = NULL;

    BOOL fVerbose = TRUE;

    __try {
        //
        // Determine options
        //

        fVerbose = opts & OFLAG(v);


        //
        // Get Thread and Context information
        //

        if (opts & OFLAG(t)) {
            //
            // Use the specified TEB
            //

            pteb = param1;
        } else if (param1 == 0) {
            //
            // Use the current thread's TEB
            //

            GetTebAddress(&pteb);
        } else {
            pContext = param1;
        }

        if (pteb != NULL) {
            GetDUserThread(pteb, &pThread);
            Print("> Thread: 0x%p\n", pThread);

            if (pThread != NULL) {
                ULONG ulOffset;
                GetFieldOffset(SYM(Thread), "m_pContext", &ulOffset);
                Print("> ulOffset: 0x%x = d\n", ulOffset, ulOffset);

                ReadPointer(pThread + ulOffset, &pContext);
            }
        }


        //
        // Display information
        //

        if (pContext != NULL) {
            Print("DUser Context: 0x%p\n", pContext, pteb);
            dso(SYM(Context), pContext, 0);

            ULONG64 pCoreSC = GetArrayElementPtr(pContext, SYM(Context), "m_rgSCs", 0);
            ULONG64 pMotionSC = GetArrayElementPtr(pContext, SYM(Context), "m_rgSCs", 1);

            if (pCoreSC != NULL) {
                Print("\nDUser CoreSC: 0x%p\n", pCoreSC);
                dso(SYM(CoreSC), pCoreSC, 0);
            }

            if (pMotionSC != NULL) {
                Print("\nDUser MotionSC: 0x%p\n", pMotionSC);
                dso(SYM(MotionSC), pMotionSC, 0);
            }

        } else {
            Print("ERROR: Unable to read DUser Context\n");
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* DirectUser Message Dumping
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

struct DbgMsgInfo 
{
    int         cLevel;                 // Level in heirarchy
    LPCSTR      pszStructName;          // Structure to type-case to
    int         nValue;                 // Value (of children)
    LPCSTR      pszValueName;           // Message / value name
    LPCSTR      pszFieldName;           // Name of field for child lookup
};

#define DBGMI_PARENT(cLevel, pszStructName, value, pszFieldName) \
{ cLevel, SYM(pszStructName), value, #value, #pszFieldName }

#define DBGMI_LEAF(cLevel, pszStructName, value) \
{ cLevel, SYM(pszStructName), value, #value, NULL }

DbgMsgInfo g_dmi[] = {
    DBGMI_PARENT(0, GMSG_DESTROY,       GM_DESTROY,         nCode),
    DBGMI_LEAF(  1, GMSG_DESTROY,       GDESTROY_START),
    DBGMI_LEAF(  1, GMSG_DESTROY,       GDESTROY_FINAL),

    DBGMI_PARENT(0, GMSG_PAINT,         GM_PAINT,           nCmd),
    DBGMI_PARENT(1, GMSG_PAINT,         GPAINT_RENDER,      nSurfaceType),
    DBGMI_LEAF(  2, GMSG_PAINTRENDERI,  GSURFACE_HDC),
    DBGMI_LEAF(  2, GMSG_PAINTRENDERF,  GSURFACE_GPGRAPHICS),

    DBGMI_PARENT(0, GMSG_INPUT,         GM_INPUT,           nDevice),

    DBGMI_PARENT(1, GMSG_MOUSE,         GINPUT_MOUSE,       nCode),
    DBGMI_LEAF(  2, GMSG_MOUSE,         GMOUSE_MOVE),
    DBGMI_LEAF(  2, GMSG_MOUSECLICK,    GMOUSE_DOWN),
    DBGMI_LEAF(  2, GMSG_MOUSECLICK,    GMOUSE_UP),
    DBGMI_LEAF(  2, GMSG_MOUSEDRAG,     GMOUSE_DRAG),
    DBGMI_LEAF(  2, GMSG_MOUSE,         GMOUSE_HOVER),
    DBGMI_LEAF(  2, GMSG_MOUSEWHEEL,    GMOUSE_WHEEL),

    DBGMI_PARENT(1, GMSG_KEYBOARD,      GINPUT_KEYBOARD,    nCode),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_DOWN),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_UP),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_CHAR),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSDOWN),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSUP),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GKEY_SYSCHAR),
    DBGMI_LEAF(  2, GMSG_KEYBOARD,      GMOUSE_WHEEL),

    DBGMI_LEAF(  1, GMSG_INPUT,         GINPUT_JOYSTICK),

    DBGMI_PARENT(0, GMSG_CHANGESTATE,   GM_CHANGESTATE,     nCode),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_KEYBOARDFOCUS),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_MOUSEFOCUS),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_ACTIVE),
    DBGMI_LEAF(  1, GMSG_CHANGESTATE,   GSTATE_CAPTURE),

    DBGMI_LEAF(  0, GMSG_CHANGERECT,    GM_CHANGERECT),

    DBGMI_LEAF(  0, GMSG_CHANGESTYLE,   GM_CHANGESTYLE),

    DBGMI_PARENT(0, GMSG_QUERY,         GM_QUERY,           nCode),
#ifdef GADGET_ENABLE_OLE
    DBGMI_LEAF(  1, GMSG_QUERYINTERFACE,GQUERY_INTERFACE),
    DBGMI_LEAF(  1, GMSG_QUERYINTERFACE,GQUERY_OBJECT),
#endif
    DBGMI_LEAF(  1, GMSG_QUERYRECT,     GQUERY_RECT),
    DBGMI_LEAF(  1, GMSG_QUERYDESC,     GQUERY_DESCRIPTION),
    DBGMI_LEAF(  1, GMSG_QUERYHITTEST,  GQUERY_HITTEST),
    DBGMI_LEAF(  1, GMSG_QUERYPADDING,  GQUERY_PADDING),
#ifdef GADGET_ENABLE_OLE
    DBGMI_LEAF(  1, GMSG_QUERYDROPTARGET,GQUERY_DROPTARGET),
#endif

    { -1, NULL, NULL, NULL, NULL }  // End of list
};


/***************************************************************************\
*
* Procedure: FindMsgInfo()
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

const DbgMsgInfo *
FindMsgInfo(ULONG64 pmsg)
{
    LPCSTR pszCurField = "nMsg";
    int cCurLevel = 0;
    int nSearchValue;
    const DbgMsgInfo * pdmiCur  = g_dmi;
    const DbgMsgInfo * pdmiBest = NULL;

    
    //
    // Start off by decoding the GMSG
    //

    InitTypeRead(pmsg, GMSG);
    nSearchValue = (int) ReadField(nMsg);

//    Print("...searching for nMsg: 0x%x\n", nSearchValue);

    while (pdmiCur->cLevel >= cCurLevel) {
//        Print("   %d: %s, %d\n", pdmiCur->cLevel, pdmiCur->pszStructName, pdmiCur->nValue);

        //
        // Search entries at the same level for a matching value
        //

        if (pdmiCur->cLevel == cCurLevel) {
            if (pdmiCur->nValue == nSearchValue) {
                //
                // We've found a corresponding entry.  We can update our best
                // guess as the to the message type and start searching its
                // children.
                //

                pdmiBest = pdmiCur;
                cCurLevel++;

                if (pdmiBest->pszFieldName != NULL) {
                    //
                    // This node has children that can be used to typecast the
                    // message futher.
                    //

                    // Perform an InitTypeRead() to cast the structure
                    GetShortField(pmsg, pdmiBest->pszStructName, 1);
                
                    // Read the next (int) ReadField(nMsg);
                    nSearchValue = (int) GetShortField(0, pdmiBest->pszFieldName, 0);

//                    Print("...searching for %s: 0x%x\n", pdmiBest->pszFieldName, nSearchValue);
                } else {
                    //
                    // This node has no children, so we are now down.
                    //

                    break;
                }
            }
        }

        pdmiCur++;
    }

    return pdmiBest;
}


/***************************************************************************\
*
* FormatMsgName
*
* FormatMsgName() generates a descriptive message name for a given message.
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

void
FormatMsgName(ULONG64 pmsg, char * pszMsgName, int cch, const DbgMsgInfo ** ppdmi)
{
    UNREFERENCED_PARAMETER(cch);

    if (ppdmi != NULL) {
        *ppdmi = NULL;
    }

    InitTypeRead(pmsg, GMSG);
    int nMsg = (int) ReadField(nMsg);

    if (nMsg < GM_EVENT) {
        strcpy(pszMsgName, "(Method)");
    } else if (nMsg > GM_USER) {
        strcpy(pszMsgName, "(User defined event)");
    } else {
        const DbgMsgInfo * pdmi = FindMsgInfo(pmsg);
        if (pdmi != NULL) {
            sprintf(pszMsgName, "%s : %s", pdmi->pszStructName, pdmi->pszValueName);

            if (ppdmi != NULL) {
                *ppdmi = pdmi;
            }
        } else {
            strcpy(pszMsgName, "(Unable to find GMSG)");
        }
    }
}


/***************************************************************************\
*
* Procedure: Igmsg
*
* Dumps DUser GMSG information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igmsg(DWORD opts, ULONG64 param1)
{
    int nMsg;
    LPCSTR pszMsgName;
    ULONG64 pmsg;
    CHAR szFullMsgName[256];

    BOOL fVerbose = TRUE;
    const DbgMsgInfo * pdmi = NULL;

    pmsg = param1;

    __try {
        //
        // Determine options
        //

        fVerbose    = opts & OFLAG(v);


        //
        // Get GMSG information
        //

        FormatMsgName(pmsg, szFullMsgName, COUNTOF(szFullMsgName), &pdmi);

        
        //
        // Display information
        //

        Print("GMSG = %s\n", szFullMsgName);

        if (pdmi != NULL) {
            dso(pdmi->pszStructName, pmsg, 0);
        }

    } __except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
*
* Procedure: Igme
*
* Dumps DUser MsgEntry information
*
* 11/30/2000 JStall       Created
*
\***************************************************************************/

BOOL Igme(DWORD opts, ULONG64 param1)
{
    DWORD cbSize;
    int nMsg;
    LPCSTR pszMsgName;
    ULONG64 pme, pmsg;
    CHAR szFullMsgName[256];
    const DbgMsgInfo * pdmi = NULL;

    BOOL fVerbose = TRUE;
    BOOL fList = FALSE;

    pme = param1;

    __try {
        //
        // Determine options
        //

        fVerbose    = opts & OFLAG(v);
        fList       = opts & OFLAG(l);

        while (pme != NULL) {
            //
            // Read standard information
            //

            pmsg = pme + GetTypeSize(SYM(MsgEntry));

            InitTypeRead(pmsg, GMSG);
            nMsg        = (int) ReadField(nMsg);

            FormatMsgName(pmsg, szFullMsgName, COUNTOF(szFullMsgName), &pdmi);


            //
            // Display information
            //

            if (fVerbose) {
                Print("MsgEntry:        0x%p\n", pme);
                Print("  Message:       0x%p  %s\n", pmsg, szFullMsgName);

                if (pdmi != NULL) {
                    dso(pdmi->pszStructName, pmsg, 0);
                }
            } else {
                Print("MsgEntry: 0x%p   GMSG: 0x%p   nMsg: 0x%x = %s\n", pme, pmsg, nMsg, szFullMsgName);
            }


            if (fList) {
                //
                // Reading a list, so go to next message
                //

                InitTypeRead(pme, MsgEntry);
                pme = ReadField(pNext);

                if (fVerbose & (pme != NULL)) {
                    Print("\n");
                }
            } else {
                //
                // Not displaying a list, so just exit
                //

                break;
            }
        }
    } __except (CONTINUE) {
    }

    return TRUE;
}

//
// WARNING: Keep this is sync with the real DuTicket
//
struct DuTicketCopy
{
    DWORD Index : 16;
    DWORD Uniqueness : 8;
    DWORD Type : 7;
    DWORD Unused : 1;
};

/***************************************************************************\
*
* Procedure: ForAllTickets
*
* Iterates over all of the tickets in the ticket manager, invoking the
* specified callback for each one.
*
\***************************************************************************/
typedef BOOL (*PfnTicketCallback)(DuTicketCopy ticket, ULONG64 pObject, void * pRawData);
void ForAllTickets(PfnTicketCallback pfnTicketCallback, void * pRawData)
{
	if (pfnTicketCallback == NULL) {
		return;
	}

	//
	// Prepare to read the value of g_TicketManager->m_arTicketData;
	//
	ULONG64 pTicketManager = EvalExp(VAR(g_TicketManager));
	ULONG ulTicketDataOffset = 0;
	GetFieldOffset(SYM(DuTicketManager), "m_arTicketData", &ulTicketDataOffset);
	InitTypeRead(pTicketManager + ulTicketDataOffset, DuTicketDataArray);

	//
	// Extract the data about the actual DuTicketDataArray since we are here.
	//
	ULONG64 paTicketData = ReadField(m_aT);
	int nSize = (int) ReadField(m_nSize);
	int nAllocSize = (int) ReadField(m_nAllocSize);

	//
	// Walk through the entire array.
	//
	ULONG cbTicketData = GetTypeSize("DuTicketData");

	for (int i = 0; i < nSize; i++) {
		InitTypeRead(paTicketData, DuTicketData);

		//
		// Read the fields of the ticket data.
		//
		ULONG64 pObject = ReadField(pObject);
		WORD idxFree = (WORD) ReadField(idxFree);
		BYTE cUniqueness = (BYTE) ReadField(cUniqueness);

		//
		// Construct the equivalent ticket for this ticket data.
		//
		DuTicketCopy ticket;
		ticket.Index = i;
		ticket.Uniqueness = cUniqueness;
		ticket.Type = 0; // TODO: Get this data
		ticket.Unused = 0;

        if (FALSE == pfnTicketCallback(ticket, pObject, pRawData)) {
            //
            // The callback requested that we bail out early!
            //
            break;
        }

		//
		// Advance to the next element in the array.
		//
		paTicketData += cbTicketData;
	}
}

/***************************************************************************\
*
* Procedure: DumpAllTicketsCB
*
* Callback that can be passed to the ForAllTickets function to dump the 
* ticket data for all tickets in the table.
*
\***************************************************************************/
struct DumpAllTicketsData
{
    DumpAllTicketsData(bool f) : fVerbose(f), nSize(0), cTickets(0) {}

    bool fVerbose;
    int nSize;
    int cTickets;
};

BOOL DumpAllTicketsCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpAllTicketsData * pData = (DumpAllTicketsData *) pRawData;

    if (pData == NULL) {
        return FALSE;
    }

    if (pObject != NULL || pData->fVerbose) {
        //     iSlot cUniqueness pObject
        Print("%4d   %4d         0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
    }

    //
    // Count the number of tickets that have a pointer associated with them.
    //
    if (pObject != NULL) {
        pData->cTickets++;
    }

    //
    // Count the number of slots in the table.
    //
    pData->nSize++;

	//
	// Keep going...
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByTicketCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given ticket.
*
\***************************************************************************/
struct DumpTicketByTicketData
{
    DumpTicketByTicketData(DuTicketCopy t) : ticket(t) {}
    DumpTicketByTicketData(DWORD t) : ticket(*((DuTicketCopy*) &t)) {}
	
    DuTicketCopy ticket;
};

BOOL DumpTicketByTicketCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByTicketData * pData = (DumpTicketByTicketData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Index == pData->ticket.Index) {
		if (ticket.Uniqueness != pData->ticket.Uniqueness) {
			Print("Warning: the uniqueness (%d) doesn't match!\n", pData->ticket.Uniqueness);
		}

		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByUniquenessCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given uniqueness.
*
\***************************************************************************/
struct DumpTicketByUniquenessData
{
    DumpTicketByUniquenessData(UINT c) : cUniqueness(c) {}
	
    UINT cUniqueness;
};

BOOL DumpTicketByUniquenessCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByUniquenessData * pData = (DumpTicketByUniquenessData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Uniqueness == pData->cUniqueness) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
	}

	//
	// Keep going...
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketBySlotCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given slot.
*
\***************************************************************************/
struct DumpTicketBySlotData
{
    DumpTicketBySlotData(UINT i) : iSlot(i) {}
	
    UINT iSlot;
};

BOOL DumpTicketBySlotCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketBySlotData * pData = (DumpTicketBySlotData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (ticket.Index == pData->iSlot) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: DumpTicketByObjectCB
*
* Callback that can be passed to the ForAllTickets function to dump only
* the ticket data that matches the given object.
*
\***************************************************************************/
struct DumpTicketByObjectData
{
    DumpTicketByObjectData(ULONG64 p) : pObject(p) {}
	
    ULONG64 pObject;
};

BOOL DumpTicketByObjectCB(DuTicketCopy ticket, ULONG64 pObject, void * pRawData)
{
	DumpTicketByObjectData * pData = (DumpTicketByObjectData *) pRawData;

	if (pData == NULL) {
		return FALSE;
	}

	if (pObject == pData->pObject) {
		Print("iSlot: %d, cUniqueness: %d, pObject: 0x%p\n", ticket.Index, ticket.Uniqueness, pObject);
		
		//
		// Since the indecies matched, there is no point in continuing.
		//
		return FALSE;
	}

	//
	// The indecies didn't match, so keep going.
	//
	return TRUE;
}

/***************************************************************************\
*
* Procedure: Igticket
*
* Dumps DUser ticket information
*
\***************************************************************************/

BOOL Igticket(DWORD opts, ULONG64 param1)
{
    DWORD cbSize;
    int nMsg;
    LPCSTR pszMsgName;
    CHAR szFullMsgName[256];
    const DbgMsgInfo * pdmi = NULL;

    __try {
        //
        // Determine options
        //
        BOOL fTicket = opts & OFLAG(t);
        BOOL fSlot = opts & OFLAG(s);
		BOOL fObject = opts & OFLAG(o);
		BOOL fUniqueness = opts & OFLAG(u);
		BOOL fVerbose = opts & OFLAG(v);

        if (fTicket) {
			DumpTicketByTicketData data((DWORD)param1);
			ForAllTickets(DumpTicketByTicketCB, &data);
        } else if (fSlot) {
			DumpTicketBySlotData data((UINT)param1);
			ForAllTickets(DumpTicketBySlotCB, &data);
        } else if (fObject) {
			DumpTicketByObjectData data(param1);
			ForAllTickets(DumpTicketByObjectCB, &data);
        } else if (fUniqueness) {
			DumpTicketByUniquenessData data((UINT)param1);
			ForAllTickets(DumpTicketByUniquenessCB, &data);
        } else {
			//
			// Just display information about all of the tickets in the table.
			//
			//     slot uniq pObject
			Print("iSlot  cUniqueness  pObject\n");
			Print("---------------------------\n");

            DumpAllTicketsData data(fVerbose ? true : false);
			ForAllTickets(DumpAllTicketsCB, &data);

            Print("Slots: %d, Tickets: %d\n", data.nSize, data.cTickets);
        }
	} __except (CONTINUE) {
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\kdexts.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(dwReserved);

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    WINDBG_EXTENSION_APIS *lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif
    UNREFERENCED_PARAMETER(args);
    UNREFERENCED_PARAMETER(dwProcessor);
    UNREFERENCED_PARAMETER(dwCurrentPc);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(hCurrentProcess);

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdext64.h and stdext64.cpp.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help                - To dump short help text on all commands.\n"
         "  help -v             - To dump long help text on all commands.\n"
         "  help cmd            - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   tls
        ,"tls                           - Displays the current value in a TLS slot\n",
        ,
         "  tls slot             - dumps the given TLS slot for the current thread\n"
         "  tls slot pteb        - dumps the given TLS slot for the given thread\n"
        ,""
        ,STDARGS2)

DOIT(   gcontext
        ,"gcontext                      - Displays information on a given DUser Context\n"
        ,
         "  gcontext             - dumps info on current DUser context\n"
         "  gcontext pcontext    - dumps info on given DUser context\n"
         "  gcontext -t pteb     - dumps info on specified context\n"
         "  gcontext -v          - dumps verbose info\n"
        ,"tv"
        ,STDARGS1)

DOIT(   gme
        ,"gme -lv pme                   - Displays information on a given MsgEntry\n"
        ,
         "  gme pme             - dumps simple info for MsgEntry at pme\n"
         "  gme -l pme          - dumps MsgEntry list\n"
         "  gme -v pme          - dumps verbose info\n"
        ,"lv"
        ,STDARGS1)

DOIT(   gmsg
        ,"gmsg -v pmsg                  - Displays information on a given GMSG\n"
        ,
         "  gmsg pmsg           - dumps simple info for GMSG at pme\n"
         "  gmsg -v pmsg        - dumps verbose info\n"
        ,"v"
        ,STDARGS1)

DOIT(   gthread
        ,"gthread                       - Displays information on a given DUser Thread\n"
        ,
         "  gthread             - dumps info on current DUser thread\n"
         "  gthread pThread     - dumps info on given DUser thread\n"
         "  gthread -t pteb     - dumps info on specified thread\n"
         "  gthread -v          - dumps verbose info\n"
        ,"tv"
        ,STDARGS1)

DOIT(   gticket
        ,"gticket                       - Displays information about DUser tickets\n"
        ,"  gticket                - dumps info on all DUser tickets\n"
         "  gticket -t ticket      - dumps info on the specified ticket\n"
         "  gticket -s slot        - dumps info on the ticket at the specified slot\n"
         "  gticket -o object      - dumps info on the ticket for the specified object\n"
         "  gticket -u uniqueness  - dumps info on all tickets with the specified uniqueness\n"
         "  gticket -v             - adds verbose info (if any)\n"
        ,"tsouv"
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\sources.inc ===
!IF 0

Module Name:  Shared sources.inc file for Engine projects.

Abstract:

Author:
        JStall

!ENDIF

SOURCES_USED=..\sources.inc

MSC_STDCALL=1
MSC_WARNING_LEVEL=-W4
NT_UP=0

USE_MSVCRT=1

USE_STATIC_ATL=1
ATL_VER=30

INCLUDES=\
        ..\..\inc;\
        ..\..\inc\Public;\
        ..\ObjectAPI\$(O);\
        $(WINDOWS_INC_PATH)\DUser;\
        $(BASE_INC_PATH);\
        $(SDK_INC_PATH)\gdiplus

C_DEFINES=$(C_DEFINES) -DWIN32 -D_MBCS -DDUSER_EXPORTS -DNO_DEFAULT_HEAP -DROCKALL_DIRECTUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\makefile.inc ===
HDEPENDENCIES=exts.h stdext64.h

$(O)\DuExts.def: genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP genuedef.c >$@

#
# Dependencies for dummy targets
#
DuExts.cpp: \
        DuExts.h \
        $(HDEPENDENCIES) \
        stdext64.cpp

precomp.h: \
        DuExts.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\precomp.h ===
#ifndef DUEXTS__PreComp_h__INCLUDED
#define DUEXTS__PreComp_h__INCLUDED

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>

#include <DUser.h>

#include "DuExts.h"

#endif // DUEXTS__PreComp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\autoutil.cpp ===
// AutoUtil.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\assertdlg.cpp ===
// AssertDlg.cpp : Implementation of CCAssertDlg
#include "stdafx.h"
#include "AssertDlg.h"
#include "DebugCore.h"

extern HINSTANCE g_hDll;

//**************************************************************************************************
//
// Global Functions
//
//**************************************************************************************************

//-----------------------------------------------------------------------------
void CopyToClipboard(const char * pszMessage)
{
    HANDLE hText;
    UINT nStrSize;
    char * pszText;

    if (OpenClipboard(NULL)) {
        nStrSize = (UINT) strlen(pszMessage) +1;

        hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, nStrSize);
        if (hText != NULL) {
            pszText = (char *) GlobalLock(hText);
            if (pszText != NULL) {
                strcpy(pszText, pszMessage);
                GlobalUnlock(hText);

                EmptyClipboard();
                if (SetClipboardData(CF_TEXT, hText) != NULL) {
                    // Data is now owned by the clipboard
                    hText = NULL;
                }
            }

            if (hText != NULL) {
                // Unable to set clipboard data
                GlobalFree(hText);
            }
        }
        CloseClipboard();
    }
}


//**************************************************************************************************
//
// class CAssertDlg
//
//**************************************************************************************************

BOOL CAssertDlg::s_fInit = FALSE;

//******************************************************************************
//
// CAssertDlg Construction
//
//******************************************************************************

//------------------------------------------------------------------------------
CAssertDlg::CAssertDlg()
{
    m_pszExpression     = "";
    m_pszFileName       = "";
    m_szLineNum[0]      = '\0';
    m_hStackData        =  NULL;
    m_cCSEntries        = 0;
    m_cSkipLevels       = 0;
    m_fProperShutdown   = FALSE;
}


//------------------------------------------------------------------------------
CAssertDlg::~CAssertDlg()
{

}


//******************************************************************************
//
// CAssertDlg Operations
//
//******************************************************************************

//------------------------------------------------------------------------------
INT_PTR
CAssertDlg::ShowDialog(
    IN  LPCSTR pszType,
    IN  LPCSTR pszExpression,
    IN  LPCSTR pszFileName,
    IN  UINT idxLineNum,
    IN  HANDLE hStackData,
    IN  UINT cCSEntries,
    IN  UINT cSkipLevels)
{
    m_pszTitle = pszType;
    m_pszExpression = pszExpression;
    m_pszFileName =  pszFileName;
    wsprintf(m_szLineNum, "%d", (int) idxLineNum);

    m_hStackData    = hStackData;
    m_cCSEntries    = cCSEntries;
    m_cSkipLevels   = cSkipLevels;

    if (!s_fInit) {
        s_fInit = TRUE;
        INITCOMMONCONTROLSEX iccs;
        iccs.dwSize = sizeof(iccs);
        iccs.dwICC  = ICC_LISTVIEW_CLASSES;
        if (!InitCommonControlsEx(&iccs)) {
            return -1;
        }
    }

    INT_PTR nResult = DialogBoxParam(g_hDll, MAKEINTRESOURCE(IDD_Assert), NULL, DlgProc, (LPARAM) this);
    if (!m_fProperShutdown) {
        nResult = IDC_DEBUG;
    }

    return nResult;
}


//******************************************************************************
//
// CAssertDlg Message Handlers
//
//******************************************************************************

//------------------------------------------------------------------------------
void inline InsertColumn(HWND hwnd, int idxColumn, TCHAR * pszName, int fmt = LVCFMT_LEFT)
{
    _ASSERTE(::IsWindow(hwnd));

    LVCOLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = fmt;
    lvc.iOrder  = idxColumn;
    lvc.pszText = pszName;
    ListView_InsertColumn(hwnd, 0, &lvc);
}


//------------------------------------------------------------------------------
INT_PTR CALLBACK 
CAssertDlg::DlgProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CAssertDlg * pThis = (CAssertDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    if (pThis == NULL) {
        if (nMsg == WM_INITDIALOG) {
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis = (CAssertDlg *) lParam;
            pThis->m_hwnd = hwnd;
        }
    }

    BOOL bHandled = FALSE;
    if (pThis != NULL) {
        LRESULT lRet    = 0;
        
        switch (nMsg)
        {
        case WM_INITDIALOG:
            lRet = pThis->OnInitDialog(nMsg, wParam, lParam, bHandled);
            break;

        case WM_DESTROY:
            lRet = pThis->OnDestroy(nMsg, wParam, lParam, bHandled);
            break;

        case WM_COMMAND:
            {
                WORD nCode  = HIWORD(wParam);
                WORD nID    = LOWORD(wParam);
                HWND hwndC  = (HWND) lParam;

                
                if (nCode == BN_CLICKED) {
                    switch (nID)
                    {
                    case IDCANCEL:
                    case IDC_DEBUG:
                    case IDC_IGNORE:
                        lRet = pThis->OnClicked(nCode, nID, hwndC, bHandled);
                        break;

                    case IDC_COPY:
                        lRet = pThis->OnCopy(nCode, nID, hwndC, bHandled);
                    }
                }
            }
            break;
        }

        if (bHandled) {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lRet);
        }
    }
    
    return bHandled;
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

//  CenterWindow();

    SetWindowText(m_hwnd, m_pszTitle);

    //
    // Setup the child windows and fill in all of the values in the dialog.
    //

    HWND hwndT;
    
    hwndT = GetDlgItem(m_hwnd, IDC_ebcExpression);
    SetWindowText(hwndT, m_pszExpression);

    hwndT = GetDlgItem(m_hwnd, IDC_ebcFileName);
    SetWindowText(hwndT, m_pszFileName);

    hwndT = GetDlgItem(m_hwnd, IDC_ebcLineNum);
    SetWindowText(hwndT, m_szLineNum);

    //
    // Display the stack
    //
    if ((hwndT = GetDlgItem(m_hwnd, IDC_lvcCallStack)) != NULL) {
        if (m_hStackData != NULL) {
            InsertColumn(hwndT, 0, _T("Address"));
            InsertColumn(hwndT, 1, _T("Module"));
            InsertColumn(hwndT, 2, _T("Function"));

            DWORD * pdwStackData = (DWORD *) ::GlobalLock(m_hStackData);
            _ASSERTE(pdwStackData != NULL);

            int idxItem = 0;
            DUSER_SYMBOL_INFO si;
            HANDLE hProcess = ::GetCurrentProcess();
            for (UINT nAddress = m_cSkipLevels; nAddress < m_cCSEntries; nAddress++) {
                CDebugHelp::ResolveStackItem(hProcess, pdwStackData, nAddress, si);

                TCHAR szAddr[20];
                wsprintf(szAddr, "0x%p", pdwStackData[nAddress]);

                LVITEM item;
                item.mask       = LVIF_TEXT;
                item.pszText    = szAddr;
                item.iItem      = idxItem++;
                item.iSubItem   = 0;
                int idxAdd = ListView_InsertItem(hwndT, &item);

                ListView_SetItemText(hwndT, idxAdd, 1, si.szModule);
                ListView_SetItemText(hwndT, idxAdd, 2, si.szSymbol);
            }

            ListView_SetColumnWidth(hwndT, 0, LVSCW_AUTOSIZE);
            ListView_SetColumnWidth(hwndT, 1, 130);
            ListView_SetColumnWidth(hwndT, 2, 200);

            ListView_SetExtendedListViewStyle(hwndT, LVS_EX_FULLROWSELECT);

            ::GlobalUnlock(m_hStackData);
        } else {
            EnableWindow(hwndT, FALSE);
        }
    }

    MessageBeep(MB_ICONHAND);

    return TRUE; // let Windows set the focus
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    return 0;
}


//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(wNotifyCode);
    UNREFERENCED_PARAMETER(wID);
    UNREFERENCED_PARAMETER(hWndCtl);
    UNREFERENCED_PARAMETER(bHandled);

    m_fProperShutdown = TRUE;
    EndDialog(m_hwnd, wID);
    return 0;
}


inline void Append(char * & pszCur, const char * pszSrc)
{
    _ASSERTE(pszCur != NULL);
    _ASSERTE(pszSrc != NULL);

    strcpy(pszCur, pszSrc);
    pszCur += strlen(pszSrc);
}

//------------------------------------------------------------------------------
LRESULT CAssertDlg::OnCopy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(wNotifyCode);
    UNREFERENCED_PARAMETER(wID);
    UNREFERENCED_PARAMETER(hWndCtl);
    UNREFERENCED_PARAMETER(bHandled);

    char szBuffer[10000];
    szBuffer[0] = '\0';
    char * pszCur = szBuffer;

    Append(pszCur, "Expression:\r\n");
    Append(pszCur, m_pszExpression);
    Append(pszCur, "\r\n\r\n");
    Append(pszCur, "File: \"");
    Append(pszCur, m_pszFileName);
    Append(pszCur, "\"\r\nLine: ");
    Append(pszCur, m_szLineNum);
    Append(pszCur, "\r\n\r\n");

    DWORD * pdwStackData = (DWORD *) ::GlobalLock(m_hStackData);
    _ASSERTE(pdwStackData != NULL);

    Append(pszCur, "Call stack:\r\n");

    DUSER_SYMBOL_INFO si;
    HANDLE hProcess = ::GetCurrentProcess();
    for (UINT nAddress = m_cSkipLevels; nAddress < m_cCSEntries; nAddress++)
    {
        CDebugHelp::ResolveStackItem(hProcess, pdwStackData, nAddress, si);

        TCHAR szAddr[20];
        wsprintf(szAddr, "0x%8.8x: ", pdwStackData[nAddress]);
        Append(pszCur, szAddr);
        Append(pszCur, si.szModule);
        Append(pszCur, ", ");
        Append(pszCur, si.szSymbol);
        Append(pszCur, "\r\n");
    }

    ::GlobalUnlock(m_hStackData);

    CopyToClipboard(szBuffer);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\stdext64.cpp ===
/****************************** Module Header ******************************\
* Module Name: stdext64.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdext64.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
ULONG64                 dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
DWORD                   dwProcessor;

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit()
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }
    return fCtrlCHit;
}



VOID moveBlock(
PVOID pdst,
ULONG64 src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    __try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    (PVOID)src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}



BOOL tryMoveBlock(
PVOID pdst,
ULONG64 src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    __try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, (PVOID)src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }
    return(fSuccess);
}



VOID moveExp(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            fSuccess = tryMove(dwGlobal, dwGlobal);
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExp(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, addr)) {
            *((PDWORD)pdst) = dw;
            return(TRUE);
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return(FALSE);
}


BOOL tryMoveExpPtr(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dwGlobal;
    BOOL fSuccess = TRUE;

    __try {
        dwGlobal = EvalExp(pszExp);
#if 0
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *pdst = dwGlobal;
    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValuePtr(
PULONG64 pdst,
LPSTR pszExp)
{
    ULONG64 dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, dw, sizeof(dw))) {
            *pdst = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


/***************************************************************************
 * Common command parsing stuff                                            *
 ***************************************************************************/
ULONG64 EvalExp(
LPSTR psz)
{
    ULONG64 p;

    p = (lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == 0) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }
    return p;
}



ULONG64 OptEvalExp(
LPSTR psz)
{
    while (*psz == ' ')
        psz++;
    if (*psz == '\0') {
        return(0);
    }
    return(EvalExp(psz));
}



ULONG64 OptEvalExp2(
LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    ULONG64 dwRet = 0;

    while (*psz == ' ')
        psz++;
    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;
    return(dwRet);
}



DWORD StringToOpts(
LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return(OPTS_ERROR);     // any non-letter option is an error.
        }
        psz++;
    }
    return(opts);
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
LPSTR *ppszArgs,
LPSTR pszLegalArgs) // OPTIONAL
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return(Opts);
        }
    }
    return(Opts);
}



VOID PrintHuge(
LPSTR psz)
{
    /*
     * Looks like this is faulting these days - Print seems to be fixed
     * so I'm leaving this entry point for compatibility. (SAS)
     */
#ifdef ITWORKS
#define HUNK_SIZE   400
    int cch;
    CHAR chSave;

    /*
     * since Print extension can't handle very long strings,
     * break it up into peices for it to chew.
     */
    cch = strlen(psz);
    while (cch > HUNK_SIZE) {
        chSave = psz[HUNK_SIZE];
        psz[HUNK_SIZE] = '\0';
        Print(psz);
        psz[HUNK_SIZE] = chSave;
        psz += HUNK_SIZE;
        cch -= HUNK_SIZE;
    }
#endif
    Print(psz);
}



/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
PVOID pFunction,
LPSTR pszName,
int type,
LPSTR pszLegalOpts,
HANDLE hcp,
HANDLE hct,
ULONG64 dwcp,
DWORD dwp,
LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    ULONG64 param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;

#if 0
    DEBUGPRINT("CommonEP(%x, \"%s\", %d, \"%s\", %x, %x, %x, %x, \"%s\")\n",
            pFunction,
            pszName,
            type,
            pszLegalOpts,
            hcp,
            hct,
            dwcp,
            dwp,
            lpas);
#endif

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    __try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } __except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    ULONG64 dwcp,                                       \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ')
        lpas++;

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                PrintHuge(he[i].pszHelp2);
            }
        }
        return(TRUE);
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                PrintHuge(he[i].pszHelp2);
                return(TRUE);
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\assertdlg.h ===
// AssertDlg.h : Declaration of the CCAssertDlg

#if !defined(AUTOUTIL__AssertDlg_h__INCLUDED)
#define AUTOUTIL__AssertDlg_h__INCLUDED

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCAssertDlg
class CAssertDlg
{
// Construction
public:
    CAssertDlg();
    ~CAssertDlg();

// Operations
public:
    INT_PTR ShowDialog(LPCSTR pszType, LPCSTR pszExpression, LPCSTR pszFileName,
            UINT idxLineNum, HANDLE hStackData, UINT cCSEntries, UINT cSkipLevels = 0);

// Implementation
protected:
    static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCopy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
// Data
protected:
            HWND        m_hwnd;

            LPCSTR      m_pszTitle;         // Dialog title
            LPCSTR      m_pszExpression;    // Expression / comment
            LPCSTR      m_pszFileName;      // FileName
            char        m_szLineNum[10];    // Line number
            HANDLE      m_hStackData;       // Stack data
            UINT        m_cCSEntries;       // Number of levels on stack
            UINT        m_cSkipLevels;      // Number of levels of stack to skip
            BOOL        m_fProperShutdown;  // Had proper shutdown of dialog
    static  BOOL        s_fInit;
};

#endif // AUTOUTIL__AssertDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\autoutil.h ===
#if !defined(AUTOUTIL__AutoUtil_h__INCLUDED)
#define AUTOUTIL__AutoUtil_h__INCLUDED

#include <..\inc\AutoUtil.h>

#endif // AUTOUTIL__AutoUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\duexts\stdext64.h ===
/****************************** Module Header ******************************\
* Module Name: stdext64.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern ULONG64                 dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, ULONG64 src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, ULONG64 src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PULONG64 pdst, LPSTR pszExp);
VOID moveExpValuePtr(PULONG64 pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

ULONG64 OptEvalExp(LPSTR psz);
ULONG64 OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
ULONG64 EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, ULONG64);
typedef BOOL (* TYPE_STDARGS2)(DWORD, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS3)(DWORD, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS4)(DWORD, ULONG64, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, ULONG64 param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3, ULONG64 param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\resource.h ===
#include "..\DUser\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\debugcore.cpp ===
#include "stdafx.h"
#include "DebugCore.h"
#include "resource.h"
#include "AssertDlg.h"


//------------------------------------------------------------------------------
AUTOUTIL_API void _cdecl AutoTrace(const char * pszFormat, ...)
{
    va_list args;
    va_start(args, pszFormat);

    {
        int nBuf;
        char szBuffer[2048];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), pszFormat, args);
        AssertMsg(nBuf < sizeof(szBuffer), "Output truncated as it was > sizeof(szBuffer)");

        OutputDebugStringA(szBuffer);
    }
    va_end(args);
}


//**************************************************************************************************
//
// Global Functions
//
//**************************************************************************************************

CDebugHelp g_DebugHelp;

//------------------------------------------------------------------------------
AUTOUTIL_API IDebug * WINAPI
GetDebug()
{
    return (IDebug *) &g_DebugHelp;
}


#pragma comment(lib, "imagehlp.lib")

#define DUSER_API

//**************************************************************************************************
//
// class CDebugHelp
//
//**************************************************************************************************

//******************************************************************************
//
// CDebugHelp Construction
//
//******************************************************************************

//------------------------------------------------------------------------------
CDebugHelp::CDebugHelp()
{

}


//------------------------------------------------------------------------------
CDebugHelp::~CDebugHelp()
{

}


//******************************************************************************
//
// IDebug Implementation
//
//******************************************************************************

//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::AssertFailedLine(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum)
{
    HGLOBAL hStackData = NULL;
    UINT cCSEntries;

    BuildStack(&hStackData, &cCSEntries);
    BOOL fResult = AssertDialog("Assert", pszExpression, pszFileName, idxLineNum, hStackData, cCSEntries);

    if (hStackData != NULL)
        ::GlobalFree(hStackData);

    return fResult;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::Prompt(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle)
{
    HGLOBAL hStackData = NULL;
    UINT cCSEntries;

    BuildStack(&hStackData, &cCSEntries);
    BOOL fResult = AssertDialog(pszTitle, pszExpression, pszFileName, idxLineNum, hStackData, cCSEntries);

    if (hStackData != NULL)
        ::GlobalFree(hStackData);

    return fResult;
}


//------------------------------------------------------------------------------
//
// IsValidAddress() is taken from AfxIsValidAddress().
//
// IsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CDebugHelp::IsValidAddress(const void * lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CDebugHelp::BuildStack(HGLOBAL * phStackData, UINT * pcCSEntries)
{
    DumpStack(phStackData, pcCSEntries);
}


//******************************************************************************
//
// Implementation
//
//******************************************************************************

BOOL g_fShowAssert = FALSE;
BOOL g_fUnderKernelDebugger = FALSE;

//------------------------------------------------------------------------------
BOOL
IsUnderKernelDebugger()
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION  kdInfo;
    if (NT_SUCCESS(NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                       &kdInfo,
                                       sizeof(kdInfo),
                                       NULL))) {
        return kdInfo.KernelDebuggerEnabled;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
BOOL
CDebugHelp::AssertDialog(
        LPCSTR pszType,
        LPCSTR pszExpression,
        LPCSTR pszFileName,
        UINT idxLineNum,
        HANDLE hStackData,
        UINT cCSEntries)
{
    AutoTrace("%s @ %s, line %d:\n'%s'\n",
            pszType, pszFileName, idxLineNum, pszExpression);

    BOOL fShowAssert = TRUE;
    if (InterlockedExchange((LONG *) &g_fShowAssert, fShowAssert)) {
        OutputDebugString("Displaying another Assert while in first Assert.\n");
        return TRUE;
    }

    //
    // When running under a kernel debugger, immediately break.  This is so that
    // while running under Stress, we break immediately and don't "loose" the
    // Assert in a pile of other things.
    //

    if (IsUnderKernelDebugger()) {
        DebugBreak();
    }


    //
    // Display the dialog
    //

    CAssertDlg dlg;
    INT_PTR nReturn = dlg.ShowDialog(pszType, pszExpression, pszFileName, idxLineNum,
            hStackData, cCSEntries, 3 /* Number of levels to skip*/);

    fShowAssert = FALSE;
    InterlockedExchange((LONG *) &g_fShowAssert, fShowAssert);

    if (nReturn == -1)
    {
        _ASSERTE(pszExpression != NULL);

        // Can't display the dialog for some reason, so revert to MessageBox
        TCHAR szBuffer[10000];
        if (pszFileName != NULL)
        {
            wsprintf(szBuffer, "An %s failed in the program.\n%s\nFile:\t%s\nLine:%d",
                    pszType, pszExpression, pszFileName, idxLineNum);
        }
        else
        {
            wsprintf(szBuffer, "An %s failed in the program.\n%s",
                    pszType, pszExpression);
        }
        nReturn = ::MessageBox(NULL, szBuffer, pszType,
                MB_ABORTRETRYIGNORE | MB_ICONSTOP | MB_DEFBUTTON2);

        // Translate the return code
        switch (nReturn)
        {
        case IDABORT:
            nReturn = IDOK;
            break;
        case IDRETRY:
            nReturn = IDC_DEBUG;
            break;
        case IDIGNORE:
            nReturn = IDC_IGNORE;
            break;
        default:
            _ASSERTE(0 && "Unknown return from MessageBox");
            nReturn = IDC_DEBUG;  // Debug, just in case
        }
    }
    switch (nReturn)
    {
    case IDOK:
    case IDCANCEL:
        (void)TerminateProcess(GetCurrentProcess(), 1);
        (void)raise(SIGABRT);
        _exit(3);
        return FALSE;   // Program will have exited

    case IDC_DEBUG:
        return TRUE;    // Break into the debugger

    case IDC_IGNORE:
        return FALSE;   // Just ignore and continue

    default:
        _ASSERTE(0 && "Unknown return code");
        return TRUE;    // Go to the debugger just in case
    }
}


/////////////////////////////////////////////////////////////////////////////
// Routine to produce stack dump

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress);
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress);

//------------------------------------------------------------------------------
static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress)
{
    return SymFunctionTableAccess(hProcess, dwPCAddress);
}


//------------------------------------------------------------------------------
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress)
{
    IMAGEHLP_MODULE moduleInfo;

    if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
    {
        MEMORY_BASIC_INFORMATION memoryBasicInfo;

        if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress,
            &memoryBasicInfo, sizeof(memoryBasicInfo)))
        {
            DWORD cch = 0;
            char szFile[MAX_PATH] = { 0 };

            cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase,
                szFile, MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            SymLoadModule(hProcess,
                NULL, ((cch) ? szFile : NULL),
                NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0);

            return (DWORD_PTR) memoryBasicInfo.AllocationBase;
        }
        else
            Trace("GetModuleBase() VirtualQueryEx() Error: %d\n", GetLastError());
    }

    return 0;
}


//------------------------------------------------------------------------------
static BOOL ResolveSymbol(HANDLE hProcess, DWORD dwAddress,
    DUSER_SYMBOL_INFO &siSymbol)
{
    BOOL fRetval = TRUE;

    siSymbol.dwAddress = dwAddress;

    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    CHAR szUndec[256];
    CHAR szWithOffset[256];
    LPSTR pszSymbol = NULL;
    IMAGEHLP_MODULE mi;

    memset(&siSymbol, 0, sizeof(DUSER_SYMBOL_INFO));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
        lstrcpyA(siSymbol.szModule, "<no module>");
    else
    {
        LPSTR pszModule = strchr(mi.ImageName, '\\');
        if (pszModule == NULL)
            pszModule = mi.ImageName;
        else
            pszModule++;

        lstrcpynA(siSymbol.szModule, pszModule, _countof(siSymbol.szModule));
       lstrcatA(siSymbol.szModule, "! ");
    }

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddress;
        sym.MaxNameLength = 255;

        if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym))
        {
            pszSymbol = sym.Name;

            if (UnDecorateSymbolName(sym.Name, szUndec, _countof(szUndec),
                UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
            {
                pszSymbol = szUndec;
            }
            else if (SymUnDName(&sym, szUndec, _countof(szUndec)))
            {
                pszSymbol = szUndec;
            }

            if (siSymbol.dwOffset != 0)
            {
                wsprintfA(szWithOffset, "%s + %d bytes", pszSymbol, siSymbol.dwOffset);
                pszSymbol = szWithOffset;
            }
      }
      else
          pszSymbol = "<no symbol>";
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
    }

    lstrcpynA(siSymbol.szSymbol, pszSymbol, _countof(siSymbol.szSymbol));
    return fRetval;
}


//------------------------------------------------------------------------------
void
CDebugHelp::DumpStack(
        HGLOBAL * phStackData,
        UINT * pcCSEntries
        )
{
    _ASSERTE(phStackData != NULL);
    _ASSERTE(pcCSEntries != NULL);

    CSimpleValArray<DWORD_PTR> adwAddress;
    HANDLE hProcess = ::GetCurrentProcess();
    if (SymInitialize(hProcess, NULL, FALSE))
    {
        // force undecorated names to get params
        DWORD dw = SymGetOptions();
        dw |= SYMOPT_UNDNAME;
        SymSetOptions(dw);

        HANDLE hThread = ::GetCurrentThread();
        CONTEXT threadContext;

        threadContext.ContextFlags = CONTEXT_FULL;

        if (::GetThreadContext(hThread, &threadContext))
        {
            STACKFRAME stackFrame;
            memset(&stackFrame, 0, sizeof(stackFrame));
            stackFrame.AddrPC.Mode = AddrModeFlat;

            DWORD dwMachType;

#if defined(_M_IX86)
            dwMachType                  = IMAGE_FILE_MACHINE_I386;

            // program counter, stack pointer, and frame pointer
            stackFrame.AddrPC.Offset    = threadContext.Eip;
            stackFrame.AddrStack.Offset = threadContext.Esp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;
            stackFrame.AddrFrame.Offset = threadContext.Ebp;
            stackFrame.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_AMD64)
            dwMachType                  = IMAGE_FILE_MACHINE_AMD64;
            #pragma message("TODO: Need to fix DebugCore for amd64")
#elif defined(_M_IA64)
            dwMachType                  = IMAGE_FILE_MACHINE_IA64;
            #pragma message("TODO: Need to fix DebugCore for ia64")
#else
#error("Unknown Target Machine");
#endif

            int nFrame;
            for (nFrame = 0; nFrame < 1024; nFrame++)
            {
                if (!StackWalk(dwMachType, hProcess, hProcess,
                    &stackFrame, &threadContext, NULL,
                    FunctionTableAccess, GetModuleBase, NULL))
                {
                    break;
                }

                adwAddress.Add(stackFrame.AddrPC.Offset);
            }

            // Now, copy it to the global memory
            UINT cbData     = adwAddress.GetSize() * sizeof(DWORD);
            HGLOBAL hmem    = ::GlobalAlloc(GMEM_MOVEABLE, cbData);
            if (hmem != NULL)
            {
                void * pmem = ::GlobalLock(hmem);
                memcpy(pmem, adwAddress.GetData(), cbData);
                ::GlobalUnlock(hmem);

                *phStackData    = hmem;
                *pcCSEntries    = adwAddress.GetSize();
            }
        }
    }
    else
    {
        DWORD dw = GetLastError();
        Trace("AutoDumpStack Error: IMAGEHLP.DLL wasn't found. GetLastError() returned 0x%8.8X\r\n", dw);
    }
}


//------------------------------------------------------------------------------
void
CDebugHelp::ResolveStackItem(
    HANDLE hProcess,
    DWORD * pdwStackData,
    int idxItem,
    DUSER_SYMBOL_INFO & si)
{
    _ASSERTE(hProcess != NULL);
    _ASSERTE(pdwStackData != NULL);
    _ASSERTE(idxItem >= 0);

    DWORD dwAddress = pdwStackData[idxItem];
    if (ResolveSymbol(hProcess, dwAddress, si))
    {
        //
        // Successfully resolved the symbol, but we don't need the whole path.
        // Just keep the filename and extension.
        //

        TCHAR szFileName[_MAX_FNAME];
        TCHAR szExt[_MAX_EXT];
        _tsplitpath(si.szModule, NULL, NULL, szFileName, szExt);
        strcpy(si.szModule, szFileName);
        strcat(si.szModule, szExt);
    }
    else
    {
        //
        // Unable to resolve the symbol, so just stub out.
        //

        _tcscpy(si.szSymbol, "<symbol not found>");
        si.szModule[0] = '\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\debugcore.h ===
#if !defined(AUTOUTIL__DebugCore_h__INCLUDED)
#define AUTOUTIL__DebugCore_h__INCLUDED

const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;

struct DUSER_SYMBOL_INFO
{
    DWORD_PTR   dwAddress;
    DWORD_PTR   dwOffset;
    CHAR        szModule[MODULE_NAME_LEN];
    CHAR        szSymbol[SYMBOL_NAME_LEN];
};


class CDebugHelp : public IDebug
{
public:
    CDebugHelp();
    ~CDebugHelp();

// IDebug Implementation
public:
    STDMETHOD_(BOOL, AssertFailedLine)(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum);
    STDMETHOD_(BOOL, IsValidAddress)(const void * lp, UINT nBytes, BOOL bReadWrite);
    STDMETHOD_(void, BuildStack)(HGLOBAL * phStackData, UINT * pcCSEntries);
    STDMETHOD_(BOOL, Prompt)(LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle);

// Operations
public:
    static void ResolveStackItem(HANDLE hProcess, DWORD * pdwStackData, int idxItem, DUSER_SYMBOL_INFO & si);

// Implementation
protected:
    static BOOL AssertDialog(LPCSTR pszType, LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, HANDLE hStackData, UINT cCSEntries);
    static void DumpStack(HGLOBAL * phStackData, UINT * pcCSEntries);
};

#endif // AUTOUTIL__DebugCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\stdafx.h ===
#if !defined(AUTOUTIL__StdAfx_h__INCLUDED)
#define AUTOUTIL__StdAfx_h__INCLUDED
#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // Only compile for NT5
#endif

#include <nt.h>                 // NtQuerySystemInformation()
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <CommCtrl.h>
#include <atlbase.h>

#include <stdio.h>              // Get _vsnprintf

#include <signal.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdarg.h>

#include <AutoUtil.h>

#endif // !defined(AUTOUTIL__StdAfx_h__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\allocpool.cpp ===
/***************************************************************************\
*
* File: AllocPool.cpp
*
* Description:
* AllocPool implements a lightweight class used to pool memory allocations in
* a LIFO stack.  This class has been designed work specifically well with
* RockAll.
*
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "AllocPool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\autoutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  AutoUtil.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\array.cpp ===
/***************************************************************************\
*
* File: Array.cpp
*
* Description:
* Array.cpp implements a collection of different array classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "Array.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\allocpool.h ===
/***************************************************************************\
*
* File: AllocPool.h
*
* Description:
* AllocPool defines a lightweight class used to pool memory allocations in
* a LIFO stack.  This class has been designed work specifically well with
* RockAll.
*
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__AllocPool_h__INCLUDED)
#define BASE__AllocPool_h__INCLUDED
#pragma once

#include "SimpleHeap.h"
#include "Locks.h"

template <class T, int cbBlock = 64, class heap = ContextHeap>
class AllocPoolNL
{
// Construction
public:
    inline  AllocPoolNL();
    inline  ~AllocPoolNL();
    inline  void        Destroy();

// Operations
public:
    inline  T *         New();
    inline  void        Delete(T * pvMem);
    inline  BOOL        IsEmpty() const;

// Data
protected:
            T *         m_rgItems[cbBlock * 2];
            int         m_nTop;
};


template <class T, int cbBlock = 64>
class AllocPool : public AllocPoolNL<T, cbBlock, ProcessHeap>
{
// Operations
public:
    inline  T *         New();
    inline  void        Delete(T * pvMem);

// Data
protected:
            CritLock    m_lock;
};


#include "AllocPool.inl"

#endif // BASE__AllocPool_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\base.h ===
/***************************************************************************\
*
* File: Base.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Base_h__INCLUDED)
#define BASE__Base_h__INCLUDED

#include <DUserError.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Base Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // BASE__Base_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\allocpool.inl ===
/***************************************************************************\
*
* File: AllocPool.inl
*
* History:
*  1/28/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__AllocPool_inl__INCLUDED)
#define BASE__AllocPool_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class AllocListNL
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline  
AllocPoolNL<T, cbBlock>::AllocPoolNL()
{
    m_nTop = 0;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline  
AllocPoolNL<T, cbBlock>::~AllocPoolNL()
{
    Destroy();
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline void
AllocPoolNL<T, cbBlock>::Destroy()
{
    if (m_nTop > 0) {
        ContextMultiFree(heap::GetHeap(), m_nTop, (void **) m_rgItems, sizeof(T));
        m_nTop = 0;
    }
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline T * 
AllocPoolNL<T, cbBlock>::New()
{
    T * ptNew;

    if (m_nTop <= 0) {
        //
        // Not enough items in the pool to hand any new one out, so we need to
        // allocate more.  These will NOT be zero-initialized by the memory 
        // allocator.
        //

        ContextMultiAlloc(heap::GetHeap(), &m_nTop, (void **) m_rgItems, cbBlock, sizeof(T));
        if (m_nTop == 0) {
            ptNew = NULL;
            goto exit;
        }
    }


    //
    // There is an item in the pool, but we need to "scrub" it before handing 
    // it out.
    //
    
    ptNew = m_rgItems[--m_nTop];
    ZeroMemory(ptNew, sizeof(T));
    placement_new(ptNew, T);

exit:
    return ptNew;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline void 
AllocPoolNL<T, cbBlock>::Delete(T * pvMem)
{
    if (pvMem == NULL) {
        return;
    }

    placement_delete(pvMem, T);
    m_rgItems[m_nTop++] = pvMem;

    if (m_nTop >= cbBlock * 2) {
        ContextMultiFree(heap::GetHeap(), cbBlock, (void **) &m_rgItems[cbBlock], sizeof(T));
        m_nTop -= cbBlock;
    }
}


//------------------------------------------------------------------------------
template <class T, int cbBlock, class heap>
inline BOOL
AllocPoolNL<T, cbBlock>::IsEmpty() const
{
    return m_nTop == 0;
}


/***************************************************************************\
*****************************************************************************
*
* class AllocList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, int cbBlock>
inline T * 
AllocPool<T, cbBlock>::New()
{
    m_lock.Enter();
    T * pNew = AllocPoolNL<T, cbBlock>::New();
    m_lock.Leave();
    return pNew;
}


//------------------------------------------------------------------------------
template <class T, int cbBlock>
inline void 
AllocPool<T, cbBlock>::Delete(T * pvMem)
{
    m_lock.Enter();
    AllocPoolNL<T, cbBlock>::Delete(pvMem);
    m_lock.Leave();
}


#endif // BASE__AllocPool_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\array.inl ===
/***************************************************************************\
*
* File: Array.inl
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Array_inl__INCLUDED)
#define BASE__Array_inl__INCLUDED

#include "SimpleHeap.h"

/***************************************************************************\
*
* class GArrayS
* 
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, class heap>
inline
GArrayS<T, heap>::GArrayS() : m_aT(NULL)
{
    //
    // All elements in GArrayS<T, heap> must be at least sizeof(int) large.  This is
    // because of the design that stores the size in the element preceeding the
    // data for the array.
    //

    AssertMsg(sizeof(T) >= sizeof(int), "Ensure minimum element size");
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline 
GArrayS<T, heap>::~GArrayS()
{
    RemoveAll();
}


//------------------------------------------------------------------------------
template <class T, class heap>
BOOL        
GArrayS<T, heap>::IsEmpty() const
{
    return m_aT == NULL;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void *      
GArrayS<T, heap>::GetRawData(BOOL fCheckNull) const
{
    if (fCheckNull) {
        //
        // Need to check if array is allocated
        //

        if (m_aT != NULL) {
            return (void *) (&m_aT[-1]);
        } else {
            return NULL;
        }
    } else {
        //
        // Blindly return the size
        //

        AssertMsg(m_aT != NULL, "Array must be allocated if not checking");
        return &m_aT[-1];
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void    
GArrayS<T, heap>::SetRawSize(int cNewItems)
{
    //
    // Store the size before the array data.  This function should only be 
    // called when an array is allocated (and thus have a non-zero size).
    //

    AssertMsg(cNewItems > 0, "Must specify a positive number of items");
    AssertMsg(m_aT != NULL, "Must allocate range to set number of items");

    int * pnSize = (int *) GetRawData(FALSE);
    *pnSize = cNewItems;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayS<T, heap>::GetSize() const
{
    if (m_aT != NULL) {
        int * pnSize = (int *) GetRawData(FALSE);
        int cItems = *pnSize;
        AssertMsg(cItems >= 1, "Must have at least one item");
        return cItems;
    } else {
        return 0;
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayS<T, heap>::SetSize(int cItems)
{
    AssertMsg(cItems >= 0, "Must have valid size");

    int cSize = GetSize();
    if (cSize == cItems) {
        return TRUE;
    }

    if (cItems == 0) {
        RemoveAll();
        return TRUE;
    } else {
        return Resize(cItems, cSize);
    }
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int
GArrayS<T, heap>::Add(const T & t)
{
    int idxAdd = GetSize();
    if (!Resize(idxAdd + 1, idxAdd)) {
        return -1;
    }

	SetAtIndex(idxAdd, t);
    return idxAdd;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayS<T, heap>::InsertAt(int idxItem, const T & t)
{
    AssertMsg(idxItem <= GetSize(), "Check index");

    // Actually may need to increase the size by one and shift everything 
    // down

    int idxAdd = GetSize();
    if (!Resize(idxAdd + 1, idxAdd)) {
        return FALSE;
    }

    int cbMove = (idxAdd - idxItem) * sizeof(T);
    if (cbMove > 0) {
        MoveMemory(&m_aT[idxItem + 1], &m_aT[idxItem], cbMove);
    }
    SetAtIndex(idxItem, t);
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayS<T, heap>::Remove(const T & t)
{
	int idxItem = Find(t);
    if(idxItem == -1) {
		return FALSE;
    }
	return RemoveAt(idxItem);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayS<T, heap>::RemoveAt(int idxItem)
{
	int cItems = GetSize();
    AssertMsg((idxItem < cItems) && (cItems >= 0), "Ensure valid index");
    m_aT[idxItem].~T();

    cItems--;
    if (cItems > 0) {
        //
        // Found the element, so we need to splice it out of the array.  We
        // can not just Realloc() the buffer b/c we need to slide all
        // property data after this down one.  This means that we have to
        // allocate a new buffer.  If we are unable to allocate a temporary
        // buffer, we can go ahead and just use the existing buffer, but we
        // won't be able to free any memory.
        //

        if (idxItem < cItems) {
		    MoveMemory((void*)&m_aT[idxItem], (void*)&m_aT[idxItem + 1], (cItems - idxItem) * sizeof(T));
	    }

        T * rgNewData = (T *) ContextRealloc(heap::GetHeap(), GetRawData(FALSE), (cItems + 1) * sizeof(T));
        if (rgNewData != NULL) {
            m_aT = &rgNewData[1];
        }

	    SetRawSize(cItems);
    } else {
		ContextFree(heap::GetHeap(), GetRawData(FALSE));
        m_aT = NULL;
    }

	return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayS<T, heap>::RemoveAll()
{
	if(m_aT != NULL) {
        int cItems = GetSize();
        for(int i = 0; i < cItems; i++) {
			m_aT[i].~T();
        }
		ContextFree(heap::GetHeap(), GetRawData(FALSE));
		m_aT = NULL;
	}
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T & 
GArrayS<T, heap>::operator[] (int idxItem) const
{
	Assert(idxItem >= 0 && idxItem < GetSize());
	return m_aT[idxItem];
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T * 
GArrayS<T, heap>::GetData() const
{
	return m_aT;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayS<T, heap>::SetAtIndex(int idxItem, const T & t)
{
	Assert(idxItem >= 0 && (idxItem < GetSize()));
	placement_copynew(&m_aT[idxItem], T, t);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayS<T, heap>::Find(const T & t) const
{
    int cItems = GetSize();
	for(int i = 0; i < cItems; i++) {
        if(m_aT[i] == t) {
			return i;
        }
	}

	return -1;  // not found
}


/***************************************************************************\
*
* GArrayS<T, heap>::Resize()
*
* Resize() changes the size of the array to a non-zero number of elements.
*
* NOTE: This function has been specifically written for the GArrayS<T, heap> 
* class and has slightly different behavior that GArrayF<T, heap>::Resize().
* 
\***************************************************************************/

template <class T, class heap>
inline BOOL
GArrayS<T, heap>::Resize(
    IN  int cItems,                 // New number of items
    IN  int cSize)                  // Current size
{
    AssertMsg(cItems > 0, "Must have non-zero and positive number of items");
    AssertMsg(cItems != cSize, "Must have a different size");

    if (cItems < cSize) {
        //
        // Making the array smaller, so need to destruct the objects we are
        // getting rid of.
        //

        AssertMsg(m_aT != NULL, "Should have data allocated");
        for(int i = cItems; i < cSize; i++) {
			m_aT[i].~T();
        }
    }

    //
    // Resize the array and store the new size.
    //

	T * aT;
	aT = (T *) ContextRealloc(heap::GetHeap(), GetRawData(TRUE), (cItems + 1) * sizeof(T));
    if(aT == NULL) {
        AssertMsg(cItems >= cSize, "Should never fail when shrinking");
		return FALSE;
    }

	m_aT = &aT[1];
    SetRawSize(cItems);

    return TRUE;
}


/***************************************************************************\
*
* class GArrayBase
* 
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T, class heap>
inline
GArrayF<T, heap>::GArrayF() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
{

}


//------------------------------------------------------------------------------
template <class T, class heap>
inline 
GArrayF<T, heap>::~GArrayF()
{
    RemoveAll();
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL        
GArrayF<T, heap>::IsEmpty() const
{
    //
    // GArrayF may have a non-NULL m_aT but a m_nSize if only Add() and Remove()
    // are used, treating the array like a stack.  Therefore, we must use 
    // m_nSize to determine if the array is "empty".  To free all memory 
    // allocated by the array, use RemoveAll().
    //

    return m_nSize <= 0;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayF<T, heap>::GetSize() const
{
	return m_nSize;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayF<T, heap>::SetSize(int cItems)
{
    AssertMsg(cItems >= 0, "Must have valid size");

    if (!Resize(cItems)) {
        return FALSE;
    }

    m_nSize = cItems;
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int
GArrayF<T, heap>::Add(const T & t)
{
	if(m_nSize == m_nAllocSize)	{
		int nNewAllocSize = (m_nAllocSize == 0) ? 8 : (m_nAllocSize * 2);
        if (!Resize(nNewAllocSize)) {
            return -1;
        }
	}

    int idxAdd = m_nSize;
	m_nSize++;
	SetAtIndex(idxAdd, t);
    return idxAdd;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL
GArrayF<T, heap>::InsertAt(int idxItem, const T & t)
{
    AssertMsg(idxItem <= m_nSize, "Check index");

    // Actually may need to increase the size by one and shift everything 
    // down

    if (!Resize(m_nSize + 1)) {
        return FALSE;
    }

    int cbMove = (m_nSize - idxItem) * sizeof(T);
    if (cbMove > 0) {
        MoveMemory(&m_aT[idxItem + 1], &m_aT[idxItem], cbMove);
    }
    m_nSize++;
    SetAtIndex(idxItem, t);
    return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayF<T, heap>::Remove(const T & t)
{
	int idxItem = Find(t);
    if(idxItem == -1) {
		return FALSE;
    }
	return RemoveAt(idxItem);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline BOOL 
GArrayF<T, heap>::RemoveAt(int idxItem)
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");

	if(idxItem != (m_nSize - 1)) {
		m_aT[idxItem].~T();
		MoveMemory((void*)&m_aT[idxItem], (void*)&m_aT[idxItem + 1], (m_nSize - (idxItem + 1)) * sizeof(T));
	}
	m_nSize--;
	return TRUE;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayF<T, heap>::RemoveAll()
{
	if(m_aT != NULL) {
        for(int i = 0; i < m_nSize; i++) {
			m_aT[i].~T();
        }
		ContextFree(heap::GetHeap(), m_aT);
		m_aT = NULL;
	}
	m_nSize = 0;
	m_nAllocSize = 0;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T & 
GArrayF<T, heap>::operator[] (int idxItem) const
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");
	return m_aT[idxItem];
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline T * 
GArrayF<T, heap>::GetData() const
{
	return m_aT;
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline void 
GArrayF<T, heap>::SetAtIndex(int idxItem, const T & t)
{
    AssertMsg((idxItem < m_nSize) && (idxItem >= 0), "Must specify a valid index");
	placement_copynew(&m_aT[idxItem], T, t);
}


//------------------------------------------------------------------------------
template <class T, class heap>
inline int 
GArrayF<T, heap>::Find(const T & t) const
{
	for(int i = 0; i < m_nSize; i++) {
        if(m_aT[i] == t) {
			return i;
        }
	}
	return -1;  // not found
}


/***************************************************************************\
*
* GArrayF<T, heap>::Resize()
*
* Resize() changes the size of the array.
*
* NOTE: This function has been specifically written for the GArrayF<T, heap> 
* class and has slightly different behavior that GArrayS<T, heap>::Resize().
* 
\***************************************************************************/

template <class T, class heap>
inline BOOL
GArrayF<T, heap>::Resize(int cItems)
{
    if (cItems == 0) {
		RemoveAll();
    } else {
        AssertMsg(m_nAllocSize >= m_nSize, "Ensure legal sizes");

        if (cItems < m_nSize) {
            //
            // Making the array smaller, so need to destruct the objects we are
            // getting rid of.
            //

            if(m_aT != NULL) {
                for(int i = cItems; i < m_nSize; i++) {
			        m_aT[i].~T();
                }
	        }
        }

        //
        // Resize the array, but don't update m_nSize b/c that is the caller's
        // responsibility.
        //

	    T * aT;
	    aT = (T *) ContextRealloc(heap::GetHeap(), m_aT, cItems * sizeof(T));
        if(aT == NULL) {
		    return FALSE;
        }

	    m_nAllocSize = cItems;
	    m_aT = aT;
    }

    return TRUE;
}


#endif // BASE__Array_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\baseobject.h ===
/***************************************************************************\
*
* File: BaseObject.h
*
* Description:
* BaseObject.h defines the "basic object" that provides handle-support
* for all items exposed outside DirectUser.
*
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BaseObject_h__INCLUDED)
#define BASE__BaseObject_h__INCLUDED
#pragma once

enum HandleType
{
    htNone              = 0,
    htContext           = 1,
    htHWndContainer     = 2,
    htParkContainer     = 3,
    htNcContainer       = 4,
    htDxContainer       = 5,
    htVisual            = 6,
    htListener          = 7,
    htTransition        = 8,
    htAction            = 9,
    htMsgClass          = 10,
    htMsgObject         = 11,
    htMAX
};


enum HandleMask
{
    hmMsgObject         = 0x00000001,
    hmEventGadget       = 0x00000002,
    hmVisual            = 0x00000004,
    hmContainer         = 0x00000008,
};


/***************************************************************************\
*
* class BaseObject defines an internally referenced counted object that 
* provides conversions from HANDLE's to internal pointers.
*
* NOTE: If created objects are ever exposed as reference counted objects,
* they MUST provide a separate reference count for their "handles".  There 
* is substantial internal code that relies on internal-only reference 
* counting.
* 
\***************************************************************************/

class BaseObject
{
// Construction
public:
    inline  BaseObject();
	virtual	~BaseObject();
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();

// Operations
public:

    inline  HANDLE      GetHandle() const;
    inline static 
            BaseObject* ValidateHandle(HANDLE h);

    virtual BOOL        IsStartDelete() const;

    virtual HandleType  GetHandleType() const PURE;
    virtual UINT        GetHandleMask() const PURE;

    inline  void        Lock();
    inline  BOOL        xwUnlock();

    typedef void        (CALLBACK * FinalUnlockProc)(BaseObject * pobj, void * pvData);
    inline  BOOL        xwUnlockNL(FinalUnlockProc pfnFinal, void * pvData);

// Implementation
protected:
#if DBG
    inline  void        DEBUG_CheckValidLockCount() const;
    virtual BOOL        DEBUG_IsZeroLockCountValid() const;

public:
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
            long        m_cRef;         // Outstanding locks against object

#if DBG
            BOOL        m_DEBUG_fDeleteHandle;
    static  BaseObject* s_DEBUG_pobjEnsure;
#endif // DBG
};


/***************************************************************************\
*****************************************************************************
*
* ObjectLock provides a convenient mechanism of locking a generic Object and
* automatically unlocking when finished.
*
*****************************************************************************
\***************************************************************************/

class ObjectLock
{
public:
    inline  ObjectLock(BaseObject * pobjLock);
    inline  ~ObjectLock();

    BaseObject * pobj;
};


#include "BaseObject.inl"

#endif // BASE__BaseObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\baseobject.cpp ===
/***************************************************************************\
*
* File: BaseObject.cpp
*
* Description:
* BaseObject.cpp implements the "basic object" that provides handle-support 
* for all items exposed outside DirectUser.
*
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "BaseObject.h"
#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* class BaseObject
*
*****************************************************************************
\***************************************************************************/

#if DBG
BaseObject* BaseObject::s_DEBUG_pobjEnsure = NULL;
#endif //DBG


//------------------------------------------------------------------------------
BaseObject::~BaseObject()
{

}


/***************************************************************************\
*
* BaseObject::xwDestroy
*
* In the standard setup, xwDestroy() gets called by xwUnlock() when the lock
* count reaches 0.  The object should then call its destructor to free memory
* and resources.  
* 
* The default implementation will free using the current Context's heap.  
* An object MUST override this if it is stored in a pool or uses the 
* Process heap.
*
\***************************************************************************/

void    
BaseObject::xwDestroy()
{
    ClientDelete(BaseObject, this);
}


/***************************************************************************\
*
* BaseObject::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.  
*
* The default implementation just Unlock's the object.  If an object has
* different schemantics, it should override this function.
*
\***************************************************************************/

BOOL    
BaseObject::xwDeleteHandle()
{
#if DBG
    if (m_DEBUG_fDeleteHandle) {
        PromptInvalid("DeleteHandle() was called multiple times on the same object.");
    }
    m_DEBUG_fDeleteHandle = TRUE;
#endif // DBG

    return xwUnlock();
}


/***************************************************************************\
*
* BaseObject::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
BaseObject::IsStartDelete() const
{
    return FALSE;
}


#if DBG

/***************************************************************************\
*
* BaseObject::DEBUG_IsZeroLockCountValid
*
* DEBUG_IsZeroLockCountValid is called to check if an object allows zero
* lock counts, for example during a destruction stage.  This is only valid
* if an object has overridden xwDestroy() to provide an implementation that
* checks if the object is currently being destroyed and will return safely.
*
* This is a DEBUG only check because it is used only to Prompt the 
* application.  The RELEASE code should properly do the "right thing" in its
* xwDestroy() function.
*
* The default implementation is to return FALSE because 
* BaseObject::xwDestroy() does not check for existing destruction.
*
\***************************************************************************/

BOOL
BaseObject::DEBUG_IsZeroLockCountValid() const
{
    return FALSE;
}


/***************************************************************************\
*
* BaseObject::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

void
BaseObject::DEBUG_AssertValid() const
{
    Assert(m_cRef >= 0);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\array.h ===
/***************************************************************************\
*
* File: Array.h
*
* Description:
* Array.h defines a collection of different array classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Array_h__INCLUDED)
#define BASE__Array_h__INCLUDED

/***************************************************************************\
*
* GArrayS implements an array that is optimized for minimum size.  When no
* items are allocated, the array is only 4 bytes.  When any items are 
* allocated, an extra item is allocated BEFORE the memory location pointed
* by m_aT where the size is stored.
*
* This array class is not designed for continuous size changing.  Any time
* an element is added or removed, the entire array size is reallocated.  
* This helps keep memory usage down, at the expense of runtime performance.
* 
\***************************************************************************/

template <class T, class heap = ContextHeap>
class GArrayS
{
// Construction/destruction
public:
	GArrayS();
	~GArrayS();

// Operations
public:
	int         GetSize() const;
    BOOL        SetSize(int cItems);

    BOOL        IsEmpty() const;

	int         Add(const T & t);
	BOOL        Remove(const T & t);
	BOOL        RemoveAt(int idxItem);
	void        RemoveAll();
    BOOL        InsertAt(int idxItem, const T & t);
	int         Find(const T & t) const;
	T &         operator[] (int idxItem) const;
	T *         GetData() const;

// Implementation
protected:
    void *      GetRawData(BOOL fCheckNull) const;
    void        SetRawSize(int cNewItems);
    BOOL        Resize(int cItems, int cSize);
	void        SetAtIndex(int idxItem, const T & t);

// Data
protected:
	T *         m_aT;
};


/***************************************************************************\
*
* GArrayF implements an array that is optimized for more frequent add and 
* remove operations.  This array class reallocates it size when the 
* used size is either larger or significantly smaller than the current size.
* This implementation takes 12 bytes of storage, so it is more memory 
* expensive than GArrayS<T> when the array is usually empty.
* 
\***************************************************************************/

template <class T, class heap = ContextHeap>
class GArrayF
{
// Construction/destruction
public:
	GArrayF();
	~GArrayF();

// Operations
public:
	int         GetSize() const;
    BOOL        SetSize(int cItems);

    BOOL        IsEmpty() const;

	int         Add(const T & t);
	BOOL        Remove(const T & t);
	BOOL        RemoveAt(int idxItem);
	void        RemoveAll();
    BOOL        InsertAt(int idxItem, const T & t);
	int         Find(const T & t) const;
	T &         operator[] (int idxItem) const;
	T *         GetData() const;

// Implementation
protected:
    BOOL        Resize(int cItems);
	void        SetAtIndex(int idxItem, const T & t);

// Data
protected:
	T *         m_aT;
	int         m_nSize;
	int         m_nAllocSize;
};

#include "Array.inl"

#endif // BASE__Array_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\gfxhelp.h ===
#if !defined(UTIL__GfxHelp_h__INCLUDED)
#define BASE__GfxHelp_h__INCLUDED
#pragma once

#pragma comment(lib, "msimg32.lib")

namespace Gdiplus
{
    class Graphics;
    class Brush;
};

class DuSurface;

BOOL        GdDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush);
BOOL        GdDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness = 1);
BOOL        GdDrawOutlineRect(Gdiplus::Graphics * pgpgr, const RECT * prcPxl, Gdiplus::Brush * pgpbr, int nThickness = 1);

#endif // BASE__GfxHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\bithelp.h ===
/***************************************************************************\
*
* File: BitHelp.h
*
* Description:
* BitHelp.h defines a collection of helpful bit-manipulation routines used
* commonly throughout DirectUser.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BitHelp_h__INCLUDED)
#define BASE__BitHelp_h__INCLUDED

//------------------------------------------------------------------------------
inline HWND 
ValidateHWnd(HWND hwnd)
{
    if ((hwnd == NULL) || (!IsWindow(hwnd))) {
        return NULL;
    }

    return hwnd;
}


//------------------------------------------------------------------------------
__forceinline bool
TestFlag(UINT nValue, UINT nMask)
{
    return (nValue & nMask) != 0;
}


//------------------------------------------------------------------------------
__forceinline bool
TestAllFlags(UINT nValue, UINT nMask)
{
    return (nValue & nMask) == nMask;
}


//------------------------------------------------------------------------------
__forceinline UINT
SetFlag(UINT & nValue, UINT nMask)
{
    nValue |= nMask;
    return nValue;
}


//------------------------------------------------------------------------------
__forceinline UINT
ClearFlag(UINT & nValue, UINT nMask)
{
    nValue &= ~nMask;
    return nValue;
}


//------------------------------------------------------------------------------
__forceinline UINT
ChangeFlag(UINT & nValue, UINT nNewValue, UINT nMask)
{
    nValue = (nNewValue & nMask) | (nValue & ~nMask);
    return nValue;
}


//------------------------------------------------------------------------------
template <class T>
void SafeAddRef(T * p)
{
    if (p != NULL) {
        p->AddRef();
    }
}


//------------------------------------------------------------------------------
template <class T>
void SafeRelease(T * & p)
{
    if (p != NULL) {
        p->Release();
        p = NULL;
    }
}

#endif // BASE__BitHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\gfxhelp.cpp ===
#include "stdafx.h"
#include "Base.h"
#include "GfxHelp.h"

/***************************************************************************\
*
* GdDrawBlendRect
*
* GdDrawBlendRect draws a alpha-blended rectangle using the current brush
* and specified alpha level
*
\***************************************************************************/

BOOL GdDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush)
{
    HBITMAP hbmpSrc = NULL, hbmpOld = NULL;
    HDC hdcSrc = NULL;
    HBRUSH hbrOld;
    BOOL fSuccess = FALSE;

    if ((wBrush == 0) || (hBrush == 0)) {
        wBrush = 100;
        hBrush = 100;
    }

    hbmpSrc = CreateCompatibleBitmap(hdcDest, wBrush, hBrush);
    if (hbmpSrc == NULL) {
        goto cleanup;
    }

    hdcSrc = CreateCompatibleDC(hdcDest);
    if (hdcSrc == NULL) {
        goto cleanup;
    }

    hbmpOld = (HBITMAP) SelectObject(hdcSrc, hbmpSrc);
    hbrOld = (HBRUSH) SelectObject(hdcSrc, hbrFill);
    PatBlt(hdcSrc, 0, 0, wBrush, hBrush, PATCOPY);
    SelectObject(hdcSrc, hbrOld);

    BLENDFUNCTION blend;

    blend.BlendOp     = AC_SRC_OVER;
    blend.BlendFlags  = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

    AlphaBlend(hdcDest, prcDest->left, prcDest->top, 
            prcDest->right - prcDest->left, prcDest->bottom - prcDest->top,
            hdcSrc, 0, 0, wBrush, hBrush, blend);

    fSuccess = TRUE;

cleanup:
    if (hdcSrc != NULL) {
        SelectObject(hdcSrc, hbmpOld);
        DeleteDC(hdcSrc);
    }

    DeleteObject(hbmpSrc);

    return fSuccess;
}


/***************************************************************************\
*
* GetSignFromMappingMode
*
* For the current mapping mode,  find out the sign of x from left to right,
* and the sign of y from top to bottom.
*
* History:
* 2000-04-22    JStall      Ported from NT-USER
*
\***************************************************************************/

BOOL GetSignFromMappingMode (
    HDC    hdc,
    PPOINT pptSign)
{
    SIZE sizeViewPortExt;
    SIZE sizeWindowExt;

    if (!GetViewportExtEx(hdc, &sizeViewPortExt)
            || !GetWindowExtEx(hdc, &sizeWindowExt)) {

        return FALSE;
    }

    pptSign->x = ((sizeViewPortExt.cx ^ sizeWindowExt.cx) < 0) ? -1 : 1;

    pptSign->y = ((sizeViewPortExt.cy ^ sizeWindowExt.cy) < 0) ? -1 : 1;

    return TRUE;
}


BOOL
GdDrawOutlineRect(Gdiplus::Graphics * pgpgr, const RECT * prcPxl, Gdiplus::Brush * pgpbr, int nThickness)
{
    Gdiplus::RectF rc(
        (float) prcPxl->left,
        (float) prcPxl->top, 
        (float) (prcPxl->right - prcPxl->left),
        (float) (prcPxl->bottom - prcPxl->top));

    if ((rc.Width < 0) || (rc.Height < 0)) {
        return FALSE;
    }
    Gdiplus::RectF rcPxl(rc);


    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */

    Gdiplus::PointF ptEdge((float) nThickness, (float) nThickness);

    Gdiplus::RectF rcFill;
    BOOL fSuccess = TRUE;

    // Top border
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = rc.Width;
    rcFill.Height   = ptEdge.Y;
    pgpgr->FillRectangle(pgpbr, rcFill);

    // Bottom border
    rc.Y            = rcPxl.Y + rcPxl.Height - ptEdge.Y;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = rc.Width;
    rcFill.Height   = ptEdge.Y;
    pgpgr->FillRectangle(pgpbr, rcFill);

    /*
     * Left Border
     * Don't xor the corners twice
     */
    rc.Y            = rcPxl.Y + ptEdge.Y;
    rc.Height      -= 2 * ptEdge.Y;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = ptEdge.X;
    rcFill.Height   = rc.Height;
    pgpgr->FillRectangle(pgpbr, rcFill);

    // Right Border
    rc.X            = rcPxl.X + rcPxl.Width - ptEdge.X;
    rcFill.X        = rc.X;
    rcFill.Y        = rc.Y;
    rcFill.Width    = ptEdge.X;
    rcFill.Height   = rc.Height;
    pgpgr->FillRectangle(pgpbr, rcFill);

    return fSuccess;
}


/***************************************************************************\
*
* GdDrawOutlineRect
*
* GdDrawOutlineRect draws the outline of a rectange using the specified 
* brush.  This function uses the same "off-by-1" errors as GDI.
*
\***************************************************************************/

BOOL
GdDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness)
{
    int        w;
    int        h;
    POINT      point;
    POINT      ptEdge;

    if (!GetSignFromMappingMode(hdc, &ptEdge))
        return FALSE;

    h = prcPxl->bottom - (point.y = prcPxl->top);
    if (h < 0) {
        return FALSE;
    }

    w = prcPxl->right -  (point.x = prcPxl->left);

    /*
     * Check width and height signs
     */
    if (((w ^ ptEdge.x) < 0) || ((h ^ ptEdge.y) < 0))
        return FALSE;

    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */
    ptEdge.x *= nThickness;
    ptEdge.y *= nThickness;

    RECT rcFill;
    BOOL fSuccess = TRUE;

    // Top border
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + w;
    rcFill.bottom   = point.y + ptEdge.y;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    // Bottom border
    point.y         = prcPxl->bottom - ptEdge.y;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + w;
    rcFill.bottom   = point.y + ptEdge.y;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    /*
     * Left Border
     * Don't xor the corners twice
     */
    point.y         = prcPxl->top + ptEdge.y;
    h              -= 2 * ptEdge.y;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + ptEdge.x;
    rcFill.bottom   = point.y + h;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    // Right Border
    point.x         = prcPxl->right - ptEdge.x;
    rcFill.left     = point.x;
    rcFill.top      = point.y;
    rcFill.right    = point.x + ptEdge.x;
    rcFill.bottom   = point.y + h;
    fSuccess &= FillRect(hdc, &rcFill, hbrDraw);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\list.cpp ===
/***************************************************************************\
*
* File: List.cpp
*
* Description:
* List.h implements a collection of different list classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "List.h"

//------------------------------------------------------------------------------
GRawList::GetSize() const
{
    int cItems = 0;
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        cItems++;
        pCur = pCur->pNext;
    }

    return cItems;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::GetTail() const
{
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        if (pCur->pNext == NULL) {
            return pCur;
        }
        pCur = pCur->pNext;
    }

    return NULL;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::GetAt(int idxItem) const
{
    ListNode * pCur = m_pHead;
    while ((pCur != NULL) && (idxItem-- > 0)) {
        pCur = pCur->pNext;
    }

    return pCur;
}


//------------------------------------------------------------------------------
void
GRawList::AddHead(ListNode * pNode)
{
    pNode->pPrev = NULL;
    pNode->pNext = m_pHead;

    if (m_pHead != NULL) {
        m_pHead->pPrev = pNode;
    }

    m_pHead = pNode;
}


//------------------------------------------------------------------------------
void
GRawList::AddTail(ListNode * pNode)
{
    ListNode * pTail = GetTail();
    if (pTail != NULL) {
        pNode->pPrev    = pTail;
        pTail->pNext    = pNode;
    } else {
        m_pHead = pNode;
    }
}


//------------------------------------------------------------------------------
void
GRawList::InsertAfter(ListNode * pInsert, ListNode * pBefore)
{
    if ((pBefore == NULL) || IsEmpty()) {
        AddHead(pInsert);
    } else {
        pInsert->pNext = pBefore->pNext;
        if (pInsert->pNext != NULL) {
            pInsert->pNext->pPrev = pInsert;
        }
        pBefore->pNext = pInsert;
    }
}


//------------------------------------------------------------------------------
void
GRawList::InsertBefore(ListNode * pInsert, ListNode * pAfter)
{
    if ((pAfter == m_pHead) || (pAfter == NULL) || IsEmpty()) {
        AddHead(pInsert);
    } else {
        pInsert->pPrev = pAfter->pPrev;
        pInsert->pNext = pAfter;

        AssertMsg(pInsert->pPrev != NULL, "Must have previous or else is head");

        pInsert->pPrev->pNext = pInsert;
        pAfter->pPrev = pInsert;
    }
}


//------------------------------------------------------------------------------
void
GRawList::Unlink(ListNode * pNode)
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pPrev = pNode->pPrev;
    ListNode * pNext = pNode->pNext;

    if (pPrev != NULL) {
        pPrev->pNext = pNext;
    }

    if (pNext != NULL) {
        pNext->pPrev = pPrev;
    }

    if (m_pHead == pNode) {
        m_pHead = pNext;
    }

    pNode->pPrev = NULL;
    pNode->pNext = NULL;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::UnlinkHead()
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pHead = m_pHead;

    m_pHead = pHead->pNext;
    if (m_pHead != NULL) {
        m_pHead->pPrev = NULL;
    }

    pHead->pNext = NULL;
    AssertMsg(pHead->pPrev == NULL, "Check");

    return pHead;
}


//------------------------------------------------------------------------------
ListNode *
GRawList::UnlinkTail()
{
    AssertMsg(!IsEmpty(), "List must have nodes to unlink");

    ListNode * pTail = GetTail();
    if (pTail != NULL) {
        if (m_pHead == pTail) {
            m_pHead = NULL;
        } else {
            AssertMsg(pTail->pPrev != NULL, "If not head, must have prev");
            pTail->pPrev->pNext = NULL;
        }
        pTail->pPrev = NULL;
        AssertMsg(pTail->pNext == NULL, "Check");
    }

    return pTail;
}


//------------------------------------------------------------------------------
int
GRawList::Find(ListNode * pNode) const
{
    int cItems = -1;
    ListNode * pCur = m_pHead;
    while (pCur != NULL) {
        cItems++;
        if (pCur != pNode) {
            pCur = pCur->pNext;
        } else {
            break;
        }
    }

    return cItems;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\baseobject.inl ===
/***************************************************************************\
*
* File: BaseObject.inl
*
* History:
* 11/05/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__BaseObject_inl__INCLUDED)
#define BASE__BaseObject_inl__INCLUDED
#pragma once

#include "Locks.h"

//------------------------------------------------------------------------------
inline HANDLE GetHandle(const BaseObject * pbase)
{
    if (pbase != NULL) {
        return pbase->GetHandle();
    }

    return NULL;
}


/***************************************************************************\
*****************************************************************************
*
* class BaseObject
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
BaseObject::BaseObject()
{
    m_cRef  = 1;  // Start off with a valid reference
}


//------------------------------------------------------------------------------
inline HANDLE  
BaseObject::GetHandle() const
{
    return (HANDLE) this;
}


//------------------------------------------------------------------------------
inline BaseObject *
BaseObject::ValidateHandle(HANDLE h)
{
    return (BaseObject *) h;
}


#if DBG
//------------------------------------------------------------------------------
inline void
BaseObject::DEBUG_CheckValidLockCount() const
{
    if (!DEBUG_IsZeroLockCountValid()) {
        AssertMsg(m_cRef > 0, "Object must have an outstanding reference.");
    }
}
#endif // DBG


//------------------------------------------------------------------------------
inline void
BaseObject::Lock()
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

    SafeIncrement(&m_cRef);
}


/***************************************************************************\
*
* BaseObject::xwUnlock
*
* xwUnlock() decrements the objects's usage count by 1.  When the usage count
* reaches 0, the object will be destroyed.
*
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
* <retval>  Returns if the object is still valid (has not been destroyed)</retval>
*
\***************************************************************************/

inline BOOL
BaseObject::xwUnlock()
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

#if DBG
    AssertMsg((this != s_DEBUG_pobjEnsure) || (m_cRef > 1), "Ensure Object is remains valid");
#endif // DBG

    if (SafeDecrement(&m_cRef) == 0) {
        xwDestroy();
        return FALSE;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
BaseObject::xwUnlockNL(FinalUnlockProc pfnFinal, void * pvData)
{
#if DBG
    DEBUG_CheckValidLockCount();
#endif // DBG

#if DBG
    AssertMsg((this != s_DEBUG_pobjEnsure) || (m_cRef > 1), "Ensure Object is remains valid");
#endif // DBG

    if (SafeDecrement(&m_cRef) == 0) {
        //
        // Object needs to be destroyed, so notify the caller so that it has
        // an opportunity to prepare.
        //

        if (pfnFinal != NULL) {
            pfnFinal(this, pvData);
        }

        xwDestroy();
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class ObjectLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
ObjectLock::ObjectLock(BaseObject * pobjLock)
{
    AssertMsg(pobjLock->GetHandleType() != htContext, "Use ContextLock to lock a Context");

    pobj = pobjLock;
    pobj->Lock();

#if DBG
    pobjLock->DEBUG_AssertValid();
#endif
}


//------------------------------------------------------------------------------
inline  
ObjectLock::~ObjectLock()
{
    pobj->xwUnlock();
}


#endif // BASE__BaseObject_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\locks.cpp ===
/***************************************************************************\
*
* File: Locks.cpp
*
* Description:
* Locks.h implements a collection wrappers used to maintain critical sections
* and other locking devices.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "Locks.h"

//
// NOTE: Must default to multiple threaded.  We can only turn this off if this
// is the first Context that is initialized.
//

BOOL    g_fThreadSafe = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\locks.inl ===
/***************************************************************************\
*
* File: Locks.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Locks_inl__INCLUDED)
#define BASE__Locks_inl__INCLUDED
#pragma once

#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

extern  BOOL    g_fThreadSafe;

//------------------------------------------------------------------------------
inline BOOL
IsMultiThreaded()
{
    return g_fThreadSafe;
}


#if 1
//------------------------------------------------------------------------------
inline long
SafeIncrement(volatile long * pl) 
{
    if (g_fThreadSafe) {
        return InterlockedIncrement((long *) pl);
    } else {
        return ++(*pl);
    }
}


//------------------------------------------------------------------------------
inline long
SafeDecrement(volatile long * pl)
{
    if (g_fThreadSafe) {
        return InterlockedDecrement((long *) pl);
    } else {
        return --(*pl);
    }
}


//------------------------------------------------------------------------------
inline void
SafeEnter(volatile CRITICAL_SECTION * pcs)
{
    Assert(pcs);

    if (g_fThreadSafe) {
        EnterCriticalSection((CRITICAL_SECTION *) pcs);
    }
}


//------------------------------------------------------------------------------
inline void
SafeLeave(volatile CRITICAL_SECTION * pcs)
{
    Assert(pcs);

    if (g_fThreadSafe) {
        LeaveCriticalSection((CRITICAL_SECTION *) pcs);
    }
}
#else
#define SafeIncrement   InterlockedIncrement
#define SafeDecrement   InterlockedDecrement
#define SafeEnter       EnterCriticalSection
#define SafeLeave       LeaveCriticalSection
#endif


/***************************************************************************\
*****************************************************************************
*
* class CritLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
CritLock::CritLock()
{
    m_fThreadSafe = g_fThreadSafe;
    InitializeCriticalSectionAndSpinCount(&m_cs, 500);
}


//------------------------------------------------------------------------------
inline
CritLock::~CritLock()
{
    DeleteCriticalSection(&m_cs);
}


//------------------------------------------------------------------------------
inline void        
CritLock::Enter()
{
    if (m_fThreadSafe) {
        SafeEnter(&m_cs);
    }
}
            

//------------------------------------------------------------------------------
inline void
CritLock::Leave()
{
    if (m_fThreadSafe) {
        SafeLeave(&m_cs);
    }
}


//------------------------------------------------------------------------------
inline BOOL
CritLock::GetThreadSafe() const
{
    return m_fThreadSafe;
}


//------------------------------------------------------------------------------
inline void
CritLock::SetThreadSafe(BOOL fThreadSafe)
{
    m_fThreadSafe = fThreadSafe;
}


/***************************************************************************\
*****************************************************************************
*
* class AutoCleanup
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
template <class base> 
inline
AutoCleanup<base>::~AutoCleanup()
{
    DeleteAll();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::DeleteAll()
{
    //
    // Once we start deleting items during shutdown, no new items should be 
    // created, or they will not be destroyed.
    //
    // Currently, to help ensure this, we take the lock around the entire 
    // shutdown.  If another thread tries to add during this time, they get 
    // blocked.  However, they should not be doing this because this instance
    // is going away and the object will not have a chance to be cleaned up.
    //

    m_lock.Enter();
    while (!m_lstItems.IsEmpty()) {
        base * pItem = m_lstItems.UnlinkHead();
        placement_delete(pItem, base);
        HeapFree(GetProcessHeap(), 0, pItem);
    }
    m_lock.Leave();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::Link(base * pItem) {
    m_lock.Enter();
    m_lstItems.AddHead(pItem);
    m_lock.Leave();
}


//------------------------------------------------------------------------------
template <class base> 
inline void
AutoCleanup<base>::Delete(base * pItem)
{
    AssertMsg(pItem != NULL, "Must specify a valid item");

    m_lock.Enter();
    m_lstItems.Unlink(pItem);
    m_lock.Leave();

    placement_delete(pItem, base);
    HeapFree(GetProcessHeap(), 0, pItem);
}


//------------------------------------------------------------------------------
template <class base, class derived>
inline derived * 
New(AutoCleanup<base> & lstItems)
{
    derived * pItem = (derived *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(derived));
    if (pItem != NULL) {
        placement_new(pItem, derived);
        lstItems.Link(pItem);
    }
    return pItem;
}

#endif // BASE__Locks_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\locks.h ===
/***************************************************************************\
*
* File: Locks.h
*
* Description:
* Locks.h defines a collection wrappers used to maintain critical sections
* and other locking devices.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Locks_h__INCLUDED)
#define BASE__Locks_h__INCLUDED
#pragma once

#include "List.h"

class CritLock
{
// Construction
public:
    inline  CritLock();
    inline  ~CritLock();

// Operations
public:
    inline  void        Enter();
    inline  void        Leave();

    inline  BOOL        GetThreadSafe() const;
    inline  void        SetThreadSafe(BOOL fThreadSafe);

// Data
protected:
    CRITICAL_SECTION    m_cs;
    BOOL                m_fThreadSafe;
};


template <class base> 
class AutoCleanup
{
public:
    ~AutoCleanup();
    void Link(base * pItem);
    void Delete(base * pItem);
    void DeleteAll();

protected:
    GList<base> m_lstItems;
    CritLock    m_lock;
};

template <class base, class derived>
inline derived * New(AutoCleanup<base> & lstItems);

inline  BOOL    IsMultiThreaded();

#if 1
inline  long    SafeIncrement(volatile long * pl);
inline  long    SafeDecrement(volatile long * pl);
inline  void    SafeEnter(volatile CRITICAL_SECTION * pcs);
inline  void    SafeLeave(volatile CRITICAL_SECTION * pcs);
#endif

#include "Locks.inl"

#endif // BASE__Locks_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\list.h ===
/***************************************************************************\
*
* File: List.h
*
* Description:
* List.h defines a collection of different list classes, each designed
* for specialized usage.
*
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__List_h__INCLUDED)
#define BASE__List_h__INCLUDED
#pragma once

#if DUSER_INCLUDE_SLIST
#include "SList.h"
#endif


/***************************************************************************\
*****************************************************************************
*
* class GList provides a high-performance, doublely-linked list.
*
*****************************************************************************
\***************************************************************************/

//
// ListNode wraps some object so that it can be maintained in a list.
// This class does not derive from the class b/c it wants to always have
// pNext and pPrev as the first members of the data so that they are in the
// same place for all lists
//


struct ListNode
{
    ListNode *  pNext;
    ListNode *  pPrev;
};


//------------------------------------------------------------------------------
template <class T>
struct ListNodeT : ListNode
{
    inline  T *         GetNext() const;
    inline  T *         GetPrev() const;
};


//------------------------------------------------------------------------------
class GRawList
{
// Construction/destruction
public:
            GRawList();
            ~GRawList();

// Operations
public:
            int         GetSize() const;
            ListNode *  GetHead() const;
            ListNode *  GetTail() const;
            ListNode *  GetAt(int idxItem) const;

    inline  BOOL        IsEmpty() const;
    inline  void        Extract(GRawList & lstSrc);
    inline  void        MarkEmpty();

            void        Add(ListNode * pNode);
            void        AddHead(ListNode * pNode);
            void        AddTail(ListNode * pNode);

            void        InsertAfter(ListNode * pInsert, ListNode * pBefore);
            void        InsertBefore(ListNode * pInsert, ListNode * pAfter);

            void        Unlink(ListNode * pNode);
            ListNode *  UnlinkHead();
            ListNode *  UnlinkTail();

            int         Find(ListNode * pNode) const;

// Implementation
protected:

// Data
protected:
            ListNode *  m_pHead;
};


//------------------------------------------------------------------------------
template <class T>
class GList : public GRawList
{
// Construction/destruction
public:
    inline  ~GList();

// Operations
public:
    inline  T *         GetHead() const;
    inline  T *         GetTail() const;
    inline  T *         GetAt(int idxItem) const;

    inline  void        Extract(GList<T> & lstSrc);
    inline  T *         Extract();

    inline  void        Add(T * pNode);
    inline  void        AddHead(T * pNode);
    inline  void        AddTail(T * pNode);

    inline  void        InsertAfter(T * pInsert, T * pBefore);
    inline  void        InsertBefore(T * pInsert, T * pAfter);

    inline  void        Remove(T * pNode);
    inline  BOOL        RemoveAt(int idxItem);
    inline  void        RemoveAll();

    inline  void        Unlink(T * pNode);
    inline  void        UnlinkAll();
    inline  T *         UnlinkHead();
    inline  T *         UnlinkTail();

    inline  int         Find(T * pNode) const;
};


/***************************************************************************\
*****************************************************************************
*
* class GSingleList provides a high-performance, non-thread-safe, 
* single-linked list that is similar to GInterlockedList but without 
* the cross-thread overhead.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GSingleList
{
// Construction
public:
    inline  GSingleList();
    inline  ~GSingleList();

// Operations
public:
    inline  T *         GetHead() const;

    inline  BOOL        IsEmpty() const;
    inline  void        AddHead(T * pNode);
            void        Remove(T * pNode);
    inline  T *         Extract();

// Data
protected:
            T *         m_pHead;
};


#if DUSER_INCLUDE_SLIST

/***************************************************************************\
*****************************************************************************
*
* class GInterlockedList provides a high-performance, thread-safe stack
* that doesn't use any locks.  Because of its high-performance, lightweight
* nature, there are not very many functions that are available.  All of the
* available functions use InterlockedXXX functions to safely manipulate
* the list.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GInterlockedList
{
// Construction
public:
    inline  GInterlockedList();
    inline  ~GInterlockedList();

// Operations
public:
    inline  BOOL        IsEmptyNL() const;
    inline  void        AddHeadNL(T * pNode);
    inline  T *         RemoveHeadNL();
    inline  T *         ExtractNL();

// Implementation
protected:
    inline  void        CheckAlignment() const;

// Data
protected:
    SLIST_HEADER    m_head;
};

#endif // DUSER_INCLUDE_SLIST


/***************************************************************************\
*****************************************************************************
*
* Generic List Utilities
*
*****************************************************************************
\***************************************************************************/

template <class T> bool IsLoop(const T * pEntry);
template <class T> void ReverseSingleList(T * & pEntry);


#include "List.inl"

#endif // BASE__List_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\matrix.cpp ===
/***************************************************************************\
*
* File: Matrix.cpp
*
* Description:
* Matrix.cpp implements common Matrix and Vector operations.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Base.h"
#include "Matrix.h"

#include "Rect.h"

/***************************************************************************\
*****************************************************************************
*
* class Vector3
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void        
Vector3::Dump() const
{
    Trace("  | %6.2f, %6.2f, %6.2f |\n", m_rgfl[0], m_rgfl[1], m_rgfl[2]);
}

#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* class Matrix3
*
*****************************************************************************
\***************************************************************************/

/*
    //
    // Standard multiplication of A by the current Matrix.  This can be used
    // as a template to be optimized for different cases.
    //

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(A[0][0] * rgvT0[0] + A[0][1] * rgvT1[0] + A[0][2] * rgvT2[0],
                 A[0][0] * rgvT0[1] + A[0][1] * rgvT1[1] + A[0][2] * rgvT2[1],
                 A[0][0] * rgvT0[2] + A[0][1] * rgvT1[2] + A[0][2] * rgvT2[2]);

    m_rgv[1].Set(A[1][0] * rgvT0[0] + A[1][1] * rgvT1[0] + A[1][2] * rgvT2[0],
                 A[1][0] * rgvT0[1] + A[1][1] * rgvT1[1] + A[1][2] * rgvT2[1],
                 A[1][0] * rgvT0[2] + A[1][1] * rgvT1[2] + A[1][2] * rgvT2[2]);

    m_rgv[2].Set(A[2][0] * rgvT0[0] + A[2][1] * rgvT1[0] + A[2][2] * rgvT2[0],
                 A[2][0] * rgvT0[1] + A[2][1] * rgvT1[1] + A[2][2] * rgvT2[1],
                 A[2][0] * rgvT0[2] + A[2][1] * rgvT1[2] + A[2][2] * rgvT2[2]);
*/


/***************************************************************************\
*
* Matrix3::ApplyLeft
*
* ApplyLeft() left-multiples the given GDI matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = pxfLeft * mCurrent
*
\***************************************************************************/

void 
Matrix3::ApplyLeft(
    IN  const XFORM * pxfLeft)      // GDI matrix to left-multiply
{
    const XFORM * pxf = pxfLeft;

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(pxf->eM11 * rgvT0[0] + pxf->eM12 * rgvT1[0],
                 pxf->eM11 * rgvT0[1] + pxf->eM12 * rgvT1[1],
                 pxf->eM11 * rgvT0[2] + pxf->eM12 * rgvT1[2]);

    m_rgv[1].Set(pxf->eM21 * rgvT0[0] + pxf->eM22 * rgvT1[0],
                 pxf->eM21 * rgvT0[1] + pxf->eM22 * rgvT1[1],
                 pxf->eM21 * rgvT0[2] + pxf->eM22 * rgvT1[2]);

    m_rgv[2].Set(pxf->eDx * rgvT0[0] + pxf->eDy * rgvT1[0] + rgvT2[0],
                 pxf->eDx * rgvT0[1] + pxf->eDy * rgvT1[1] + rgvT2[1],
                 pxf->eDx * rgvT0[2] + pxf->eDy * rgvT1[2] + rgvT2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyLeft
*
* ApplyLeft() left-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = mLeft * mCurrent
*
\***************************************************************************/

void        
Matrix3::ApplyLeft(
    IN  const Matrix3 & mLeft)      // Matrix to left-multiply
{
    if (mLeft.m_fIdentity) {
        return;
    }

    if (m_fOnlyTranslate && mLeft.m_fOnlyTranslate) {
        m_rgv[2].Set(0, m_rgv[2][0] + mLeft.m_rgv[2][0]);
        m_rgv[2].Set(1, m_rgv[2][1] + mLeft.m_rgv[2][1]);

        m_fIdentity = FALSE;
        return;
    }

    const Vector3 & A0 = mLeft.m_rgv[0];
    const Vector3 & A1 = mLeft.m_rgv[1];
    const Vector3 & A2 = mLeft.m_rgv[2];

    Vector3 B0 = m_rgv[0];
    Vector3 B1 = m_rgv[1];
    Vector3 B2 = m_rgv[2];

    m_rgv[0].Set(A0[0] * B0[0] + A0[1] * B1[0] + A0[2] * B2[0],
                 A0[0] * B0[1] + A0[1] * B1[1] + A0[2] * B2[1],
                 A0[0] * B0[2] + A0[1] * B1[2] + A0[2] * B2[2]);

    m_rgv[1].Set(A1[0] * B0[0] + A1[1] * B1[0] + A1[2] * B2[0],
                 A1[0] * B0[1] + A1[1] * B1[1] + A1[2] * B2[1],
                 A1[0] * B0[2] + A1[1] * B1[2] + A1[2] * B2[2]);

    m_rgv[2].Set(A2[0] * B0[0] + A2[1] * B1[0] + A2[2] * B2[0],
                 A2[0] * B0[1] + A2[1] * B1[1] + A2[2] * B2[1],
                 A2[0] * B0[2] + A2[1] * B1[2] + A2[2] * B2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyRight
*
* ApplyRight() right-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
* mCurrent = mCurrent * mRight
*
\***************************************************************************/

void        
Matrix3::ApplyRight(
    IN  const Matrix3 & mRight)     // Matrix to right-multiply
{
    if (mRight.m_fIdentity) {
        return;
    }

    if (m_fOnlyTranslate && mRight.m_fOnlyTranslate) {
        m_rgv[2].Set(0, m_rgv[2][0] + mRight.m_rgv[2][0]);
        m_rgv[2].Set(1, m_rgv[2][1] + mRight.m_rgv[2][1]);

        m_fIdentity = FALSE;
        return;
    }

    Vector3 A0 = m_rgv[0];
    Vector3 A1 = m_rgv[1];
    Vector3 A2 = m_rgv[2];

    const Vector3 & B0 = mRight.m_rgv[0];
    const Vector3 & B1 = mRight.m_rgv[1];
    const Vector3 & B2 = mRight.m_rgv[2];

    m_rgv[0].Set(A0[0] * B0[0] + A0[1] * B1[0] + A0[2] * B2[0],
                 A0[0] * B0[1] + A0[1] * B1[1] + A0[2] * B2[1],
                 A0[0] * B0[2] + A0[1] * B1[2] + A0[2] * B2[2]);

    m_rgv[1].Set(A1[0] * B0[0] + A1[1] * B1[0] + A1[2] * B2[0],
                 A1[0] * B0[1] + A1[1] * B1[1] + A1[2] * B2[1],
                 A1[0] * B0[2] + A1[1] * B1[2] + A1[2] * B2[2]);

    m_rgv[2].Set(A2[0] * B0[0] + A2[1] * B1[0] + A2[2] * B2[0],
                 A2[0] * B0[1] + A2[1] * B1[1] + A2[2] * B2[1],
                 A2[0] * B0[2] + A2[1] * B1[2] + A2[2] * B2[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::ApplyRight
*
* ApplyRight() right-multiples the given matrix to the current matrix and 
* stores the result in the current matrix.
*
\***************************************************************************/

void        
Matrix3::Get(
    OUT XFORM * pxf                 // GDI matrix to receive information
    ) const
{
    pxf->eM11 = m_rgv[0][0];
    pxf->eM12 = m_rgv[0][1];
    pxf->eM21 = m_rgv[1][0];
    pxf->eM22 = m_rgv[1][1];
    pxf->eDx  = m_rgv[2][0];
    pxf->eDy  = m_rgv[2][1];
}


/***************************************************************************\
*
* Matrix3::Execute
*
* Execute() applies to given matrix on the collection of points, 
* transforming each appropriately.
*
\***************************************************************************/

void 
Matrix3::Execute(
    IN OUT POINT * rgpt,            // Points to apply matrix on
    IN  int cPoints) const          // Number of points
{
    if (m_fIdentity) {
        return;
    }

    POINT ptT, ptN;
    POINT * pptCur = rgpt;

    if (m_fOnlyTranslate) {
        //
        // Only have translated so far, so can just offset the points without
        // going through an entire transformation.
        //

        while (cPoints-- > 0) {
            ptT = *pptCur;

            ptN.x = ptT.x + (int) m_rgv[2][0];
            ptN.y = ptT.y + (int) m_rgv[2][1];

            *pptCur++ = ptN;
        }
    } else {
        while (cPoints-- > 0) {
            ptT = *pptCur;

            ptN.x = (int) (ptT.x * m_rgv[0][0] + ptT.y * m_rgv[1][0] + m_rgv[2][0] + 0.5f);
            ptN.y = (int) (ptT.x * m_rgv[0][1] + ptT.y * m_rgv[1][1] + m_rgv[2][1] + 0.5f);

            *pptCur++ = ptN;
        }
    }
}


/***************************************************************************\
*
* Matrix3::ComputeBounds
*
* ComputeBounds() computes the bounding box that will contain the given
* transformed rectangle.
*
\***************************************************************************/

void 
Matrix3::ComputeBounds(
    OUT RECT * prcBounds,           // The bound of the transformation
    IN  const RECT * prcLogical,    // The logical rectangle to transform
    IN  EHintBounds hb              // Hinting for border pixels
    ) const
{
    if (m_fIdentity) {
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");
        *prcBounds = *prcLogical;
        return;
    }

    if (m_fOnlyTranslate) {
        //
        // Only have translated, so the bounding 
        //
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");

        *prcBounds = *prcLogical;
        InlineOffsetRect(prcBounds, (int) m_rgv[2][0], (int) m_rgv[2][1]);
        return;
    }


    POINT rgpt[4];
    rgpt[0].x = prcLogical->left;
    rgpt[0].y = prcLogical->top;
    rgpt[1].x = prcLogical->right;
    rgpt[1].y = prcLogical->top;

    rgpt[2].x = prcLogical->right;
    rgpt[2].y = prcLogical->bottom;
    rgpt[3].x = prcLogical->left;
    rgpt[3].y = prcLogical->bottom;

    Execute(rgpt, _countof(rgpt));

    prcBounds->left   = min(min(rgpt[0].x, rgpt[1].x), min(rgpt[2].x, rgpt[3].x));
    prcBounds->top    = min(min(rgpt[0].y, rgpt[1].y), min(rgpt[2].y, rgpt[3].y));
    prcBounds->right  = max(max(rgpt[0].x, rgpt[1].x), max(rgpt[2].x, rgpt[3].x));
    prcBounds->bottom = max(max(rgpt[0].y, rgpt[1].y), max(rgpt[2].y, rgpt[3].y));

    if (hb == hbOutside) {
        //
        // Just converted from int to float back to int, so we may have rounding
        // errors.  To compensate, need to inflate the given rectangle so that
        // it overlaps these errors.
        //

        InlineInflateRect(prcBounds, 1, 1);
    }
}


/***************************************************************************\
*
* Matrix3::ComputeRgn
*
* ComputeRgn() builds a region for the quadrilateral generated by applying 
* this matrix to the given rectangle.
*
\***************************************************************************/

int
Matrix3::ComputeRgn(
    IN  HRGN hrgnDest, 
    IN  const RECT * prcLogical,
    IN  SIZE sizeOffsetPxl
    ) const
{
    AssertMsg(hrgnDest != NULL, "Must specify a valid (real) region");

    if (m_fIdentity || m_fOnlyTranslate){
        AssertMsg(InlineIsRectNormalized(prcLogical), "Ensure normalized rect");

        RECT rcBounds = *prcLogical;
        InlineOffsetRect(&rcBounds, 
                ((int) m_rgv[2][0]) + sizeOffsetPxl.cx, 
                ((int) m_rgv[2][1]) + sizeOffsetPxl.cy);
        BOOL fSuccess = SetRectRgn(hrgnDest, rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom);
        return fSuccess ? SIMPLEREGION : ERROR;
    }


    POINT rgpt[4];
    rgpt[0].x = prcLogical->left;
    rgpt[0].y = prcLogical->top;
    rgpt[1].x = prcLogical->right;
    rgpt[1].y = prcLogical->top;

    rgpt[2].x = prcLogical->right;
    rgpt[2].y = prcLogical->bottom;
    rgpt[3].x = prcLogical->left;
    rgpt[3].y = prcLogical->bottom;

    Execute(rgpt, _countof(rgpt));

    HRGN hrgnTemp = CreatePolygonRgn(rgpt, _countof(rgpt), WINDING);
    if (hrgnTemp == NULL) {
        return ERROR;
    }
    int nResult;
    nResult = OffsetRgn(hrgnTemp, sizeOffsetPxl.cx, sizeOffsetPxl.cy);
    AssertMsg((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION),
            "Just successfully created region should be either simple or complex");

    nResult = CombineRgn(hrgnDest, hrgnTemp, NULL, RGN_COPY);
    DeleteObject(hrgnTemp);

    return nResult;
}


/***************************************************************************\
*
* Matrix3::SetIdentity
*
* SetIdentity() resets the matrix to the identity matrix.
*
\***************************************************************************/

void 
Matrix3::SetIdentity()
{
    m_rgv[0].Set(1.0f, 0.0f, 0.0f);
    m_rgv[1].Set(0.0f, 1.0f, 0.0f);
    m_rgv[2].Set(0.0f, 0.0f, 1.0f);

    m_fIdentity         = TRUE;
    m_fOnlyTranslate    = TRUE;
}


/***************************************************************************\
*
* Matrix3::Rotate
*
* Rotate() rotates the matrix by the specified angle.  The specific 
* orientation of clockwise or counterclockwise depends on how the matrix
* is being applied.  For MM_TEXT, this is clockwise.
*
\***************************************************************************/

void 
Matrix3::Rotate(
    IN  float flRotationRad)        // Rotation angle in radians
{
    float flCos = (float) cos(flRotationRad);
    float flSin = (float) sin(flRotationRad);
    float flSinN = - flSin;

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(flCos * rgvT0[0] + flSin * rgvT1[0],
                 flCos * rgvT0[1] + flSin * rgvT1[1],
                 flCos * rgvT0[2] + flSin * rgvT1[2]);

    m_rgv[1].Set(flSinN * rgvT0[0] + flCos * rgvT1[0],
                 flSinN * rgvT0[1] + flCos * rgvT1[1],
                 flSinN * rgvT0[2] + flCos * rgvT1[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


/***************************************************************************\
*
* Matrix3::Translate
*
* Translate() offsets the matrix.
*
\***************************************************************************/

void 
Matrix3::Translate(
    IN  float flOffsetX,            // Horizontal offset
    IN  float flOffsetY)            // Vertical offset
{
    if (m_fOnlyTranslate) {
        AssertMsg(fabs(m_rgv[2][2] - 1.0f) < 0.00001f, "Should still be 1.0f");

        m_rgv[2].Set(m_rgv[2][0] + flOffsetX,
                     m_rgv[2][1] + flOffsetY,
                     1.0f);

        m_fIdentity = FALSE;
        return;
    }

    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[2].Set(flOffsetX * rgvT0[0] + flOffsetY * rgvT1[0] + rgvT2[0],
                 flOffsetX * rgvT0[1] + flOffsetY * rgvT1[1] + rgvT2[1],
                 flOffsetX * rgvT0[2] + flOffsetY * rgvT1[2] + rgvT2[2]);

    m_fIdentity = FALSE;
}


/***************************************************************************\
*
* Matrix3::Scale
*
* Scale() scales the matrix.
*
\***************************************************************************/

void 
Matrix3::Scale(
    IN  float flScaleX,             // Horizontal scaling
    IN  float flScaleY)             // Vertical scaling
{
    Vector3 rgvT0 = m_rgv[0];
    Vector3 rgvT1 = m_rgv[1];
    Vector3 rgvT2 = m_rgv[2];

    m_rgv[0].Set(flScaleX * rgvT0[0],
                 flScaleX * rgvT0[1],
                 flScaleX * rgvT0[2]);

    m_rgv[1].Set(flScaleY * rgvT1[0],
                 flScaleY * rgvT1[1],
                 flScaleY * rgvT1[2]);

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}


#if DBG

//------------------------------------------------------------------------------
void        
Matrix3::Dump() const
{
    m_rgv[0].Dump();
    m_rgv[1].Dump();
    m_rgv[2].Dump();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\matrix.inl ===
/***************************************************************************\
*
* File: Matrix.inl
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__Matrix_inl__INCLUDED)
#define BASE__Matrix_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class Vector3
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
Vector3::Vector3()
{

}


//------------------------------------------------------------------------------
inline  
Vector3::Vector3(const Vector3 & src)
{
    m_rgfl[0] = src.m_rgfl[0];
    m_rgfl[1] = src.m_rgfl[1];
    m_rgfl[2] = src.m_rgfl[2];
}


//------------------------------------------------------------------------------
inline  
Vector3::Vector3(float fl0, float fl1, float fl2)
{
    m_rgfl[0] = fl0;
    m_rgfl[1] = fl1;
    m_rgfl[2] = fl2;
}


//------------------------------------------------------------------------------
inline float   
Vector3::operator[](int x) const
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    return m_rgfl[x]; 
}


//------------------------------------------------------------------------------
inline float   
Vector3::Get(int x) const
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    return m_rgfl[x]; 
}


//------------------------------------------------------------------------------
inline void    
Vector3::Set(int x, float fl)
{
    AssertMsg((x < 3) && (x >= 0), "Ensure valid index");
    m_rgfl[x] = fl;
}


//------------------------------------------------------------------------------
inline void    
Vector3::Set(float flA, float flB, float flC)
{
    m_rgfl[0] = flA;
    m_rgfl[1] = flB;
    m_rgfl[2] = flC;
}


//------------------------------------------------------------------------------
inline void
Vector3::Empty()
{
    m_rgfl[0] = 0.0f;
    m_rgfl[1] = 0.0f;
    m_rgfl[2] = 0.0f;
}


/***************************************************************************\
*****************************************************************************
*
* class Matrix3
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Matrix3::Matrix3(bool fInit)
{
    if (fInit) {
        m_rgv[0].Set(1.0f, 0.0f, 0.0f);
        m_rgv[1].Set(0.0f, 1.0f, 0.0f);
        m_rgv[2].Set(0.0f, 0.0f, 1.0f);

        m_fIdentity         = TRUE;
        m_fOnlyTranslate    = TRUE;
    }
}


//------------------------------------------------------------------------------
inline const Vector3 & 
Matrix3::operator[](int y) const
{
    AssertMsg((y < 3) && (y >= 0), "Ensure valid index");
    return m_rgv[y]; 
}


//------------------------------------------------------------------------------
inline float   
Matrix3::Get(int y, int x) const 
{
    return m_rgv[y][x]; 
}


//------------------------------------------------------------------------------
inline void    
Matrix3::Set(int y, int x, float fl)
{ 
    m_rgv[y].Set(x, fl); 

    m_fIdentity         = FALSE;
    m_fOnlyTranslate    = FALSE;
}

#endif // BASE__Matrix_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\list.inl ===
/***************************************************************************\
*
* File: List.inl
*
* History:
*  1/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__List_inl__INCLUDED)
#define BASE__List_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* Generic List Utilities
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
bool IsLoop(const T * pEntry)
{
    if (pEntry == NULL) {
        return false;
    }

    const T * p1 = pEntry;
    const T * p2 = pEntry->pNext;

    while (1) {
        if (p2 == NULL) {
            return false;
        } else if (p1 == p2) {
            return true;
        }

        p2 = p2->pNext;
        if (p2 == NULL) {
            return false;
        } else if (p1 == p2) {
            return true;
        }

        p2 = p2->pNext;
        p1 = p1->pNext;
    }
}


//------------------------------------------------------------------------------
template <class T>
void ReverseSingleList(T * & pEntry)
{
    T * pPrev, * pNext;

    pPrev = NULL;
    while (pEntry != NULL) {
        pNext = static_cast<T *> (pEntry->pNext);
        pEntry->pNext = pPrev;
        pPrev = pEntry;
        pEntry = pNext;
    }

    if (pEntry == NULL) {
        pEntry = pPrev;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class ListNodeT<T>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline T *
ListNodeT<T>::GetNext() const
{
    return (T *) pNext;
}


//------------------------------------------------------------------------------
template <class T>
inline T *
ListNodeT<T>::GetPrev() const
{
    return (T *) pPrev;
}


/***************************************************************************\
*****************************************************************************
*
* class GRawList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
GRawList::GRawList()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
inline
GRawList::~GRawList()
{
    AssertMsg(m_pHead == NULL, "List data was not cleaned up");
}


//------------------------------------------------------------------------------
inline BOOL
GRawList::IsEmpty() const
{
    return m_pHead == NULL;
}


//------------------------------------------------------------------------------
inline ListNode *
GRawList::GetHead() const
{
    return m_pHead;
}


//------------------------------------------------------------------------------
inline void
GRawList::Extract(GRawList & lstSrc)
{
    AssertMsg(IsEmpty(), "Destination list must be empty to receive a new list");

    m_pHead         = lstSrc.m_pHead;
    lstSrc.m_pHead  = NULL;
}


//------------------------------------------------------------------------------
inline void
GRawList::MarkEmpty()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
inline void
GRawList::Add(ListNode * pNode)
{
    AddHead(pNode);
}


/***************************************************************************\
*****************************************************************************
*
* class GList<T>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GList<T>::~GList()
{
    //
    // NOTE: We do not call RemoveAll() from the destructor because this causes
    // too many bugs.  Components are not always aware that GList<> is deleting
    // its members in the destructor.
    //
    // Instead, we'll warn if the list is not empty and just unlink everything.

    if (!IsEmpty()) {
        Trace("WARNING: GList<> at 0x%p is not empty\n", this);
        UnlinkAll();
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetHead() const
{
    return static_cast<T *> (GRawList::GetHead());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetTail() const
{
    return static_cast<T *> (GRawList::GetTail());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::GetAt(int idxItem) const
{
    return static_cast<T *> (GRawList::GetAt(idxItem));
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Extract(GList<T> & lstSrc)
{
    GRawList::Extract(lstSrc);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::Extract()
{
    T * pHead = static_cast<T *> (m_pHead);
    m_pHead = NULL;
    return pHead;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Add(T * pNode)
{
    GRawList::Add(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::AddHead(T * pNode)
{
    GRawList::AddHead(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::AddTail(T * pNode)
{
    GRawList::AddTail(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::InsertAfter(T * pInsert, T * pBefore)
{
    GRawList::InsertAfter(pInsert, pBefore);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::InsertBefore(T * pInsert, T * pAfter)
{
    GRawList::InsertBefore(pInsert, pAfter);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Remove(T * pNode)
{
    Unlink(pNode);
    DoClientDelete<T>(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline BOOL
GList<T>::RemoveAt(int idxItem)
{
    ListNode * pCur = GetAt(idxItem);
    if (pCur != NULL) {
        Remove(pCur);
        return TRUE;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::RemoveAll()
{
    //
    // When removing each item, need to typecase to T so that delete can do the
    // right thing and call the correct destructor.
    //

    while (m_pHead != NULL) {
        ListNode * pNext = m_pHead->pNext;
        m_pHead->pPrev= NULL;
        T * pHead = (T *) m_pHead;
        DoClientDelete<T>(pHead);
        m_pHead = pNext;
    }
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::Unlink(T * pNode)
{
    GRawList::Unlink(pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline void
GList<T>::UnlinkAll()
{
    while (!IsEmpty()) {
        UnlinkHead();
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::UnlinkHead()
{
    return static_cast<T *> (GRawList::UnlinkHead());
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GList<T>::UnlinkTail()
{
    return static_cast<T *> (GRawList::UnlinkTail());
}

//------------------------------------------------------------------------------
template <class T>
inline int
GList<T>::Find(T * pNode) const
{
    return GRawList::Find(pNode);
}


/***************************************************************************\
*****************************************************************************
*
* class GSingleList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GSingleList<T>::GSingleList()
{
    m_pHead = NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline
GSingleList<T>::~GSingleList()
{
    //
    // The list should be cleaned up before being destroyed.  This is being
    // explicitly Assert'd here to help ensure this, since when it is not it is
    // most likely a programming error internal to DirectUser.
    //

    AssertMsg(IsEmpty(), "List data was not cleaned up");
}

//------------------------------------------------------------------------------
template <class T>
inline T *
GSingleList<T>::GetHead() const
{
    return m_pHead;
}

//------------------------------------------------------------------------------
template <class T>
inline BOOL
GSingleList<T>::IsEmpty() const
{
    return m_pHead == NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GSingleList<T>::AddHead(T * pNode)
{
    Assert(pNode != NULL);
    pNode->pNext = m_pHead;
    m_pHead = pNode;
}

//------------------------------------------------------------------------------
template <class T>
void
GSingleList<T>::Remove(T * pNode)
{
    Assert(pNode != NULL);
    if (pNode == m_pHead) {
        m_pHead = pNode->pNext;
        pNode->pNext = NULL;
    } else {
        for (T * pTemp = m_pHead; pTemp != NULL; pTemp = pTemp->pNext) {
            if (pTemp->pNext == pNode) {
                pTemp->pNext = pNode->pNext;
                pNode->pNext = NULL;
                break;
            }
        }
        AssertMsg(pTemp != NULL, "Ensure that the node was found.");
    }
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GSingleList<T>::Extract()
{
    T * pHead = m_pHead;
    m_pHead = NULL;
    return pHead;
}


#if DUSER_INCLUDE_SLIST

/***************************************************************************\
*****************************************************************************
*
* class GInterlockedList
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline
GInterlockedList<T>::GInterlockedList()
{
    _RtlInitializeSListHead(&m_head);
}


//------------------------------------------------------------------------------
template <class T>
inline
GInterlockedList<T>::~GInterlockedList()
{
    //
    // The list should be cleaned up before being destroyed.  This is being
    // explicitly Assert'd here to help ensure this, since when it is not it is
    // most likely a programming error internal to DirectUser.
    //

    AssertMsg(IsEmptyNL(), "List data was not cleaned up");
}


//------------------------------------------------------------------------------
template <class T>
inline BOOL
GInterlockedList<T>::IsEmptyNL() const
{
    return _RtlFirstEntrySList(&m_head) == NULL;
}


//------------------------------------------------------------------------------
template <class T>
inline void
GInterlockedList<T>::CheckAlignment() const
{
    //
    // SList are a special beast because the pNext field MUST be the first
    // member of the structure.  If it is not, then we can't do an 
    // InterlockedCompareExchange64.
    //

    const size_t nOffsetNode    = offsetof(T, pNext);
    const size_t nOffsetEntry   = offsetof(SINGLE_LIST_ENTRY, Next);
    const size_t nDelta         = nOffsetNode - nOffsetEntry;

    AssertMsg(nDelta == 0, "pNext MUST be the first member of the structure");
}


//------------------------------------------------------------------------------
template <class T>
inline void
GInterlockedList<T>::AddHeadNL(T * pNode)
{
    CheckAlignment();
    _RtlInterlockedPushEntrySList(&m_head, (SINGLE_LIST_ENTRY *) pNode);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GInterlockedList<T>::RemoveHeadNL()
{
    return (T *) _RtlInterlockedPopEntrySList(&m_head);
}


//------------------------------------------------------------------------------
template <class T>
inline T *
GInterlockedList<T>::ExtractNL()
{
    return (T *) _RtlInterlockedFlushSList(&m_head);
}


#endif // DUSER_INCLUDE_SLIST

#endif // BASE__List_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__Public_h__INCLUDED)
#define BASE__Public_h__INCLUDED

// Standard
#include "BitHelp.h"
#include "BaseObject.h"

// Synchronization
#include "Locks.h"

// Collections
#include "Array.h"
#include "List.h"
#include "TreeNode.h"

// Resources
#include "SimpleHeap.h"
#include "AllocPool.h"
#include "TempHeap.h"

// Objects
#include "Rect.h"
#include "GfxHelp.h"
#include "StringHelp.h"
#include "Matrix.h"

#endif // BASE__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\matrix.h ===
/***************************************************************************\
*
* File: Matrix.h
*
* Description:
* Matrix.h defines common Matrix and Vector operations.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__Matrix_h__INCLUDED)
#define BASE__Matrix_h__INCLUDED
#pragma once

//------------------------------------------------------------------------------
class Vector3
{
public:
    inline  Vector3();
    inline  Vector3(const Vector3 & src);
    inline  Vector3(float fl0, float fl1, float fl2);

    inline  float       Get(int x) const;
    inline  void        Set(int x, float fl);
    inline  void        Set(float flA, float flB, float flC);
    inline  float       operator[](int x) const;

    inline  void        Empty();

#if DBG
            void        Dump() const;
#endif // DBG

protected:
            float       m_rgfl[3];
};


//------------------------------------------------------------------------------
class Matrix3
{
public:
    inline  Matrix3(bool fInit = true);

            void        ApplyLeft(const XFORM * pxfLeft);
            void        ApplyLeft(const Matrix3 & mLeft);
            void        ApplyRight(const Matrix3 & mRight);

            void        Execute(POINT * rgpt, int cPoints) const;

            enum EHintBounds
            {
                hbInside,                   // Round pixels on the border inside
                hbOutside                   // Round pixels on the border outside
            };

            void        ComputeBounds(RECT * prcBounds, const RECT * prcLogical, EHintBounds hb) const;
            int         ComputeRgn(HRGN hrgnDest, const RECT * prcLogical, SIZE sizeOffsetPxl) const;

    inline  float       Get(int y, int x) const;
    inline  void        Set(int y, int x, float fl);

            void        Get(XFORM * pxf) const;

    inline  const Vector3 & operator[](int y) const;

            void        SetIdentity();
            void        Rotate(float flRotationRad);
            void        Translate(float flOffsetX, float flOffsetY);
            void        Scale(float flScaleX, float flScaleY);

#if DBG
            void        Dump() const;
#endif // DBG

protected:
            Vector3     m_rgv[3];           // Each vector is a row
            BOOL        m_fIdentity:1;      // Identity matrix
            BOOL        m_fOnlyTranslate:1; // Only translations have been applied
};


#include "Matrix.inl"

#endif // BASE__Matrix_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\rect.inl ===
#if !defined(BASE__Rect_inl_INCLUDED)
#define BASE__Rect_inl_INCLUDED
#pragma once


/***************************************************************************\
*
* InlinePtInRect
*
* InlinePtInRect() provides a inline version of PtInRect().  This uses the
* exact same comparisons as PtInRect (>= and <), so don't change this unless
* PtInRect() changes.
*
\***************************************************************************/

__forceinline bool 
InlinePtInRect(const RECT * prcCheck, POINT pt)
{
    return (pt.x >= prcCheck->left) && (pt.x < prcCheck->right) &&
            (pt.y >= prcCheck->top) && (pt.y < prcCheck->bottom);
}


/***************************************************************************\
*
* InlineIsRectEmpty
*
* InlineIsRectEmpty() returns if a rect has a non-negative height and/or 
* width.  This is different than InlineIsRectNull() which checks if the rect
* is all 0's.
*
\***************************************************************************/

__forceinline bool
InlineIsRectEmpty(const RECT * prcCheck)
{
    return ((prcCheck->left >= prcCheck->right) || (prcCheck->top >= prcCheck->bottom));
}


/***************************************************************************\
*
* InlineIsRectNull
*
* InlineIsRectNull() returns if a rect is all 0's.
*
\***************************************************************************/

__forceinline bool
InlineIsRectNull(const RECT * prcCheck)
{
    return (prcCheck->left == 0) && (prcCheck->top == 0) && 
            (prcCheck->right == 0) && (prcCheck->bottom == 0);
}


/***************************************************************************\
*
* InlineIsRectNormalized
*
* InlineIsRectNormalized() returns if a rect is properly normalized so that
* the upper-left corner is able the lower-right corner.  This is different
* than !IsRectEmpty() because the rectangle may still be empty.
*
\***************************************************************************/

__forceinline bool    
InlineIsRectNormalized(const RECT * prcCheck)
{
    return (prcCheck->left <= prcCheck->right) && (prcCheck->top <= prcCheck->bottom);
}


/***************************************************************************\
*
* InlineZeroRect
*
* InlineZeroRect() moves a rect to (0, 0)
*
\***************************************************************************/

__forceinline void    
InlineZeroRect(RECT * prc)
{
    prc->right  -= prc->left;
    prc->bottom -= prc->top;
    prc->left    = 0;
    prc->top     = 0;
}


/***************************************************************************\
*
* InlineOffsetRect
*
* InlineOffsetRect() offsets a rect by a given amount.
*
\***************************************************************************/

__forceinline void    
InlineOffsetRect(RECT * prc, int xOffset, int yOffset)
{
    prc->left   += xOffset;
    prc->top    += yOffset;
    prc->right  += xOffset;
    prc->bottom += yOffset;
}


/***************************************************************************\
*
* InlineInflateRect
*
* InlineInflateRect() moves the corners of the rectangle out from the center
* by a given amount.
*
\***************************************************************************/

__forceinline void    
InlineInflateRect(RECT * prc, int xIncrease, int yIncrease)
{
    prc->left   -= xIncrease;
    prc->top    -= yIncrease;
    prc->right  += xIncrease;
    prc->bottom += yIncrease;
}


/***************************************************************************\
*
* InlineCopyRect
*
* InlineCopyRect() copies a rectangle.
*
\***************************************************************************/

__forceinline void    
InlineCopyRect(RECT * prcDest, const RECT * prcSrc)
{
    prcDest->left   = prcSrc->left;
    prcDest->top    = prcSrc->top;
    prcDest->right  = prcSrc->right;
    prcDest->bottom = prcSrc->bottom;
}


/***************************************************************************\
*
* InlineCopyZeroRect
*
* InlineCopyZeroRect() copies a rectangle and moves it to (0, 0)
*
\***************************************************************************/

__forceinline void    
InlineCopyZeroRect(RECT * prcDest, const RECT * prcSrc)
{
    prcDest->left   = 0;
    prcDest->top    = 0;
    prcDest->right  = prcSrc->right - prcSrc->left;
    prcDest->bottom = prcSrc->bottom - prcSrc->top;
}


//------------------------------------------------------------------------------
__forceinline void    
InlineSetRectEmpty(
    OUT RECT * prcDest)
{
    prcDest->left = prcDest->top = prcDest->right = prcDest->bottom = 0;
}


//------------------------------------------------------------------------------
__forceinline bool 
InlineIntersectRect(
    OUT RECT * prcDst,
    IN  const RECT * prcSrc1,
    IN  const RECT * prcSrc2)
{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return true;        // not empty
        }
    }

    /*
     * empty rect
     */
    InlineSetRectEmpty(prcDst);

    return false;
}


//------------------------------------------------------------------------------
__forceinline bool    
InlineEqualRect(
    IN  const RECT * prc1, 
    IN  const RECT * prc2)
{
    return (prc1->left == prc2->left) && (prc1->top == prc2->top) && 
           (prc1->right == prc2->right) && (prc1->bottom == prc2->bottom);
}


#endif // BASE__Rect_inl_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\simpleheap.cpp ===
/***************************************************************************\
*
* File: SimpleHelp.cpp
*
* Description:
* SimpleHeap.cpp implements the heap operations used throughout DirectUser.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "SimpleHeap.h"

#include "List.h"
#include "Locks.h"


DWORD       g_tlsHeap   = (DWORD) -1;
HANDLE      g_hHeap     = NULL;
DUserHeap * g_pheapProcess;


/***************************************************************************\
*****************************************************************************
*
* class DUserHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DUserHeap::DUserHeap()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
void
DUserHeap::Lock()
{
    SafeIncrement(&m_cRef);
}


//------------------------------------------------------------------------------
BOOL
DUserHeap::Unlock()
{
    AssertMsg(m_cRef > 0, "Must have an outstanding referenced");
    if (SafeDecrement(&m_cRef) == 0) {
        placement_delete(this, DUserHeap);
        HeapFree(g_hHeap, 0, this);

        return FALSE;  // Heap is no longer valid
    }

    return TRUE;  // Heap is still valid
}


#ifdef _DEBUG  // Needs DEBUG CRT's

/***************************************************************************\
*****************************************************************************
*
* class CrtDbgHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class CrtDbgHeap : public DUserHeap
{
// Construction    
public:    
    virtual ~CrtDbgHeap();
            

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);
};


//------------------------------------------------------------------------------
CrtDbgHeap::~CrtDbgHeap()
{
    
}


//------------------------------------------------------------------------------
void *
CrtDbgHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    void * pvMem = _malloc_dbg(cbSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
    if ((pvMem != NULL) && fZero) {
        ZeroMemory(pvMem, cbSize);
    }
    return pvMem;
}


//------------------------------------------------------------------------------
void *
CrtDbgHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    void * pvNewMem = _realloc_dbg(pvMem, cbNewSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
    return pvNewMem;
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    int idx = 0;
    while (idx < cItems) {
        prgAlloc[idx] = _malloc_dbg(cbSize, _NORMAL_BLOCK, pszFileName, idxLineNum);
        if (prgAlloc[idx] == NULL) {
            break;
        }
        idx++;
    }

    *pnActual = idx;
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::Free(void * pvMem)
{
    _free_dbg(pvMem, _NORMAL_BLOCK);
}


//------------------------------------------------------------------------------
void 
CrtDbgHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    UNREFERENCED_PARAMETER(cbSize);

    for (int idx = 0; idx < cItems; idx++) {
        _free_dbg(prgAlloc[idx], _NORMAL_BLOCK);
    }
}

#endif // _DEBUG


/***************************************************************************\
*****************************************************************************
*
* class NtHeap
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class NtHeap : public DUserHeap
{
// Construction    
public:    
    inline  NtHeap();
    virtual ~NtHeap();
            HRESULT     Create(BOOL fSerialize);
    inline  void        Destroy();
    inline  void        Attach(HANDLE hHeap, BOOL fPassOwnership);
    inline  HANDLE      Detach();
            

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);

// Implementation
protected:
    inline  DWORD       GetFlags(DWORD dwExtra = 0) const;
    
// Data
protected:    
            HANDLE      m_hHeap;
            BOOL        m_fOwnHeap:1;
            BOOL        m_fSerialize:1;
};


//------------------------------------------------------------------------------
inline
NtHeap::NtHeap()
{
    m_hHeap         = NULL;
    m_fOwnHeap      = FALSE;
    m_fSerialize    = FALSE;
}


//------------------------------------------------------------------------------
NtHeap::~NtHeap()
{
    Destroy();
}


//------------------------------------------------------------------------------
HRESULT
NtHeap::Create(BOOL fSerialize)
{
    AssertMsg(m_hHeap == NULL, "Can not re-create heap");

    m_hHeap = HeapCreate(fSerialize ? 0 : HEAP_NO_SERIALIZE, 256 * 1024, 0);
    if (m_hHeap != NULL) {
        m_fOwnHeap      = TRUE;
        m_fSerialize    = fSerialize;
    }

    return m_hHeap != NULL ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
inline void
NtHeap::Destroy()
{
    if (m_fOwnHeap && (m_hHeap != NULL)) {
        HeapDestroy(m_hHeap);
        m_hHeap         = NULL;
        m_fOwnHeap      = FALSE;
        m_fSerialize    = FALSE;
    }
}


//------------------------------------------------------------------------------
inline void
NtHeap::Attach(HANDLE hHeap, BOOL fPassOwnership)
{
    AssertMsg(hHeap != NULL, "Must specify valid heap");
    AssertMsg(m_hHeap == NULL, "Can re-attach heap");

    m_hHeap         = hHeap;
    m_fOwnHeap      = fPassOwnership;
    m_fSerialize    = TRUE;
}


//------------------------------------------------------------------------------
inline HANDLE
NtHeap::Detach()
{
    HANDLE hHeap    = m_hHeap;

    m_hHeap         = NULL;
    m_fOwnHeap      = FALSE;
    m_fSerialize    = FALSE;

    return hHeap;
}


//------------------------------------------------------------------------------
inline DWORD
NtHeap::GetFlags(DWORD dwExtra) const
{
    return dwExtra | (m_fSerialize ? 0 : HEAP_NO_SERIALIZE);
}


//------------------------------------------------------------------------------
void *
NtHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    
    return HeapAlloc(m_hHeap, GetFlags(fZero ? HEAP_ZERO_MEMORY : 0), cbSize);
}


//------------------------------------------------------------------------------
void *
NtHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    DWORD dwFlags = GetFlags(HEAP_ZERO_MEMORY);
    
    if (pvMem == NULL) {
        return HeapAlloc(m_hHeap, dwFlags, cbNewSize);
    } else {
        return HeapReAlloc(m_hHeap, dwFlags, pvMem, cbNewSize);
    }
}


//------------------------------------------------------------------------------
void 
NtHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    DWORD dwFlags = GetFlags();
    
    int idx = 0;
    while (idx < cItems) {
        prgAlloc[idx] = HeapAlloc(m_hHeap, dwFlags, cbSize);
        if (prgAlloc[idx] == NULL) {
            break;
        }
        idx++;
    }

    *pnActual = idx;
}


//------------------------------------------------------------------------------
void 
NtHeap::Free(void * pvMem)
{
    if (pvMem != NULL) {
        HeapFree(m_hHeap, 0, pvMem);
    }
}


//------------------------------------------------------------------------------
void 
NtHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    UNREFERENCED_PARAMETER(cbSize);

    DWORD dwFlags = GetFlags(0);
    for (int idx = 0; idx < cItems; idx++) {
        if (prgAlloc[idx] != NULL) {
            HeapFree(m_hHeap, dwFlags, prgAlloc[idx]);
        }
    }
}


/***************************************************************************\
*****************************************************************************
*
* class RockAllHeap
* 
*****************************************************************************
\***************************************************************************/

#if USE_ROCKALL

#include <Rockall.hpp>

#pragma comment(lib, "RAHeap.lib")
#pragma comment(lib, "RALibrary.lib")
#pragma comment(lib, "Rockall.lib")


//------------------------------------------------------------------------------
class RockAllHeap : public DUserHeap
{
// Construction
public:
            RockAllHeap(BOOL fSerialize);
            HRESULT     Create();

// Operations    
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS);
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS);
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS);
    
    virtual void        Free(void * pvMem);
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize);

// Implementation
protected:
    class CustomHeap : public ROCKALL
    {
    // Construction
    public:
                CustomHeap(bool ThreadSafe=true, int MaxFreeSpace=4194304, bool Recycle=true, bool SingleImage=false);
    };

// Data
protected:
            CustomHeap  m_heap;
};


//------------------------------------------------------------------------------
RockAllHeap::RockAllHeap(BOOL fSerialize) : m_heap(!!fSerialize)
{

}


//------------------------------------------------------------------------------
HRESULT
RockAllHeap::Create()
{
    return m_heap.Corrupt() ? E_OUTOFMEMORY : S_OK;
}



//------------------------------------------------------------------------------
void * 
RockAllHeap::Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    return m_heap.New(cbSize, NULL, fZero);
}


//------------------------------------------------------------------------------
void * 
RockAllHeap::Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    return m_heap.Resize(pvMem, cbNewSize);
}


//------------------------------------------------------------------------------
void
RockAllHeap::MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS)
{
    DBG_HEAP_USE;
    m_heap.MultipleNew(pnActual, prgAlloc, cItems, cbSize, NULL, false);
}


//------------------------------------------------------------------------------
void 
RockAllHeap::Free(void * pvMem)
{
    m_heap.Delete(pvMem);
}


//------------------------------------------------------------------------------
void
RockAllHeap::MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize)
{
    m_heap.MultipleDelete(cItems, prgAlloc, cbSize);
}


const int FindCacheSize         = 4096;
const int FindCacheThreshold    = 0;
const int FindSize              = 2048;
const int Stride1               = 8;
const int Stride2               = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/


//
// NOTE: DUser needs to ensure that all memory is allocated on 8 byte 
// boundaries.  This is used be several external components, including
// S-Lists.  To ensure this, the smallest "Bucket Size" must be >= 8 bytes.
//

static ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{       16,      128,     4096,     4096 },
		{       24,       64,     4096,     4096 },
		{       32,       64,     4096,     4096 },
		{       40,      256,     4096,     4096 },
		{       64,      256,     4096,     4096 },
		{       80,      256,     4096,     4096 },
		{      128,       32,     4096,     4096 },
		{      256,       16,     4096,     4096 },
		{      512,        4,     4096,     4096 },
		{ 0,0,0,0 }
	};

static ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

static int NewPageSizes[] = { 1,4,16,64,128,0 };

//------------------------------------------------------------------------------
RockAllHeap::CustomHeap::CustomHeap(bool ThreadSafe, int MaxFreeSpace, bool Recycle, bool SingleImage) :
		ROCKALL(Caches1, Caches2, FindCacheSize, FindCacheThreshold, FindSize,
			    MaxFreeSpace, NewPageSizes, Recycle, SingleImage, 
                Stride1, Stride2, ThreadSafe)
{ 
    
}


#endif // USE_ROCKALL


//------------------------------------------------------------------------------
HRESULT
CreateProcessHeap()
{
    AssertMsg(g_pheapProcess == NULL, "Only should init process heap once");
    
    g_tlsHeap = TlsAlloc();
    if (g_tlsHeap == (DWORD) -1) {
        return E_OUTOFMEMORY;
    }
    
    g_hHeap = GetProcessHeap();

    DUserHeap * pNewHeap;
#ifdef _DEBUG
    pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(CrtDbgHeap));
#else
    pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(NtHeap));
#endif
    if (pNewHeap == NULL) {
        return E_OUTOFMEMORY;
    }

#ifdef _DEBUG
    placement_new(pNewHeap, CrtDbgHeap);
#else
    placement_new(pNewHeap, NtHeap);
    ((NtHeap *) pNewHeap)->Attach(g_hHeap, FALSE /* Don't pass ownership */);
#endif

    g_pheapProcess = pNewHeap;
    
    return S_OK;
}


//------------------------------------------------------------------------------
void
DestroyProcessHeap()
{
    if (g_pheapProcess != NULL) {
        g_pheapProcess->Unlock();
        g_pheapProcess = NULL;
    }

    if (g_tlsHeap == (DWORD) -1) {
        TlsFree(g_tlsHeap);
        g_tlsHeap   = (DWORD) -1;
    }
    
    g_hHeap     = NULL;
}


/***************************************************************************\
*
* CreateContextHeap
*
* CreateContextHeap() initializes the thread-specific heap to either an 
* existing heap or a new heap.  All threads in the same Context should be
* initialized with the same heap so that they can safely shared data between
* threads.  When the Context is finally destroyed, call DestroyContextHeap()
* to cleanup the heap.
*
\***************************************************************************/

HRESULT
CreateContextHeap(
    IN  DUserHeap * pLinkHeap,          // Existing heap to share
    IN  BOOL fThreadSafe,               // Heap mode
    IN  DUserHeap::EHeap id,            // Heap type
    OUT DUserHeap ** ppNewHeap)         // New heap (OPTIONAL)
{
    HRESULT hr;
    
    if (ppNewHeap != NULL) {
        *ppNewHeap = NULL;
    }


    //
    // Check if a heap already exists.
    //
    // NOTE: This will occur on the starting thread because the initial heap 
    // must be initialized so that we can create new objects.
    //
    DUserHeap * pNewHeap = reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap));
    if (pNewHeap == NULL) {
        if (pLinkHeap == NULL) {
            //
            // Need to create a new heap.
            //

            switch (id)
            {
            case DUserHeap::idProcessHeap:
            case DUserHeap::idNtHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(NtHeap));
                break;
                
#ifdef _DEBUG
            case DUserHeap::idCrtDbgHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(CrtDbgHeap));
                break;
#endif
                
#if USE_ROCKALL
            case DUserHeap::idRockAllHeap:
                pNewHeap = (DUserHeap *) HeapAlloc(g_hHeap, 0, sizeof(RockAllHeap));
                break;
#endif

            default:
                AssertMsg(0, "Unknown heap type");
            }
            if (pNewHeap == NULL) {
                return E_OUTOFMEMORY;
            }

            hr = E_FAIL;
            switch (id)
            {
            case DUserHeap::idProcessHeap:
                placement_new(pNewHeap, NtHeap);
                ((NtHeap *) pNewHeap)->Attach(g_hHeap, FALSE /* Don't pass ownership */);
                hr = S_OK;
                break;
                
            case DUserHeap::idNtHeap:
                placement_new(pNewHeap, NtHeap);
                hr = ((NtHeap *) pNewHeap)->Create(fThreadSafe);
                break;
                
#ifdef _DEBUG
            case DUserHeap::idCrtDbgHeap:
                placement_new(pNewHeap, CrtDbgHeap);
                hr = S_OK;
                break;
#endif
                
#if USE_ROCKALL
            case DUserHeap::idRockAllHeap:
                placement_new1(pNewHeap, RockAllHeap, fThreadSafe);
                hr = ((RockAllHeap *) pNewHeap)->Create();
                break;
#endif

            default:
                AssertMsg(0, "Unknown heap type");
            }
            if (FAILED(hr)) {
                pNewHeap->Unlock();
                return hr;
            }
        } else {
            pLinkHeap->Lock();
            pNewHeap = pLinkHeap;
        }

        Verify(TlsSetValue(g_tlsHeap, pNewHeap));
    }

    if (ppNewHeap != NULL) {
        *ppNewHeap = pNewHeap;
    }
    return S_OK;
}


/***************************************************************************\
*
* DestroyContextHeap
*
* DestroyContextHeap() frees resources used by a Context's shared heap.
*
\***************************************************************************/

void        
DestroyContextHeap(
    IN  DUserHeap * pHeapDestroy)      // Heap to destroy
{
    if (pHeapDestroy != NULL) {
        pHeapDestroy->Unlock();
    }

    DUserHeap * pHeap = reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap));
    if (pHeapDestroy == pHeap) {
        Verify(TlsSetValue(g_tlsHeap, NULL));
    }
}


/***************************************************************************\
*
* ForceSetContextHeap
*
* ForceSetContextHeap() is called during shutdown when it is necessary to
* "force" the current thread to use a different thread's heap so that the
* objects can be properly destroyed.
*
* NOTE: This function must be VERY carefully called since it directly 
* changes the heap for a thread.  It should only be called from the
* ResourceManager when destroying threads.
*
\***************************************************************************/

void        
ForceSetContextHeap(
    IN  DUserHeap * pHeapThread)        // Heap to use on this Thread
{
    Verify(TlsSetValue(g_tlsHeap, pHeapThread));
}


#if DBG

//------------------------------------------------------------------------------
void 
DumpData(
    IN  void * pMem,
    IN  int nLength)
{
    int row = 4;
    char * pszData = (char *) pMem;
    int cbData = min(16, nLength);
    int cbTotal = 0;

    //
    // For each row, we will dump up to 16 characters in both hexidecimal
    // and if an actual character, their displayed character.
    //

    while ((row-- > 0) && (cbTotal < nLength)) {
        int cb = cbData;
        char * pszDump = pszData;
        Trace("0x%p: ", pszData);

        int cbTemp = cbTotal;
        while (cb-- > 0) {
            cbTemp++;
            if (cbTemp > nLength) {
                Trace("   ");
            } else {
                Trace("%02x ", (unsigned char) (*pszDump++));
            }
        }

        Trace("   ");

        cb = cbData;
        while (cb-- > 0) {
            char ch = (unsigned char) (*pszData++);
            Trace("%c", IsCharAlphaNumeric(ch) ? ch : '.');

            cbTotal++;
            if (cbTotal > nLength) {
                break;
            }
        }

        Trace("\n");
    }
    Trace("\n");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Base.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\rect.h ===
#if !defined(BASE__Rect_h_INCLUDED)
#define BASE__Rect_h_INCLUDED
#pragma once

inline  bool    InlinePtInRect(const RECT * prcCheck, POINT pt);
inline  bool    InlineIsRectEmpty(const RECT * prcCheck);
inline  bool    InlineIsRectNull(const RECT * prcCheck);
inline  bool    InlineIsRectNormalized(const RECT * prcCheck);
inline  void    InlineZeroRect(RECT * prc);
inline  void    InlineOffsetRect(RECT * prc, int xOffset, int yOffset);
inline  void    InlineInflateRect(RECT * prc, int xIncrease, int yIncrease);
inline  void    InlineCopyRect(RECT * prcDest, const RECT * prcSrc);
inline  void    InlineCopyZeroRect(RECT * prcDest, const RECT * prcSrc);
inline  void    InlineSetRectEmpty(RECT * prcDest);
inline  bool    InlineIntersectRect(RECT * prcDst, const RECT * prcSrc1, const RECT * prcSrc2);
inline  bool    InlineEqualRect(const RECT * prc1, const RECT * prc2);

#include "Rect.inl"

#endif // BASE__Rect_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\stdafx.h ===
#if !defined(BASE__StdAfx_h__INCLUDED)
#define BASE__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // BASE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\simpleheap.inl ===
/***************************************************************************\
*
* File: SimpleHelp.inl
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__SimpleHeap_inl__INCLUDED)
#define BASE__SimpleHeap_inl__INCLUDED
#pragma once

class ProcessHeap
{
public:
    static DUserHeap * GetHeap()
    {
        return pProcessHeap;
    }
};


class ContextHeap
{
public:
    static DUserHeap * GetHeap()
    {
        return pContextHeap;
    }
};


#if DBG

//------------------------------------------------------------------------------
template <class type>
inline type *
DoProcessNewDbg(const char * pszFileName, int idxLineNum)
{
    void * pvMem = pProcessHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoClientNewDbg(const char * pszFileName, int idxLineNum)
{
    void * pvMem = pContextHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoContextNewDbg(DUserHeap * pHeap, const char * pszFileName, int idxLineNum)
{
    void * pvMem = pHeap->Alloc(sizeof(type), true, pszFileName, idxLineNum);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}

#else // DBG

//------------------------------------------------------------------------------
template <class type>
inline type *
DoProcessNew()
{
    void * pvMem = pProcessHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoClientNew()
{
    void * pvMem = pContextHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}


//------------------------------------------------------------------------------
template <class type>
inline type *
DoContextNew(DUserHeap * pHeap)
{
    void * pvMem = pHeap->Alloc(sizeof(type), true);
    if (pvMem != NULL) {
        placement_new(pvMem, type);
    }
    return reinterpret_cast<type *> (pvMem);
}

#endif // DBG

//------------------------------------------------------------------------------
template <class type>
inline void
DoProcessDelete(type * pMem)
{
    if (pMem != NULL) {
#if ENABLE_DUMPDELETE
        Trace("Start ProcessFree(0x%p), size=%d\n", pMem, sizeof(type));
#endif // ENABLE_DUMPDELETE

        placement_delete(pMem, type);

#if ENABLE_DUMPDELETE
        Trace("Dump  ProcessFree(0x%p), size=%d\n", pMem, sizeof(type));
        DumpData(pMem, sizeof(type));
#endif // ENABLE_DUMPDELETE

        pProcessHeap->Free(pMem);
    }
}


//------------------------------------------------------------------------------
template <class type>
inline void
DoClientDelete(type * pMem)
{
    if (pMem != NULL) {
        placement_delete(pMem, type);
        pContextHeap->Free(pMem);
    }
}



//------------------------------------------------------------------------------
template <class type>
inline void
DoContextDelete(DUserHeap * pHeap, type * pMem)
{
    if (pMem != NULL) {
        placement_delete(pMem, type);
        pHeap->Free(pMem);
    }
}


#if !DBG

//------------------------------------------------------------------------------
inline void 
DumpData(
    IN  void * pMem,
    IN  int nLength)
{
    UNREFERENCED_PARAMETER(pMem);
    UNREFERENCED_PARAMETER(nLength);
}

#endif // DBG


#endif // BASE__SimpleHeap_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\stringhelp.cpp ===
#include "stdafx.h"
#include "Base.h"
#include "StringHelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\simpleheap.h ===
/***************************************************************************\
*
* File: SimpleHelp.h
*
* Description:
* SimpleHeap.h defines the heap operations used throughout DirectUser.  See
* below for a description of the different heaps.
*
*
* History:
* 11/26/1999: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__SimpleHeap_h__INCLUDED)
#define BASE__SimpleHeap_h__INCLUDED

#ifdef _X86_
#define USE_ROCKALL         1       // Use RockAll Research heap
#endif

#define USE_DYNAMICTLS      1       // Use Dynamic TLS using TlsAlloc()

/***************************************************************************\
*****************************************************************************
*
* Common memory management
*
*****************************************************************************
\***************************************************************************/

//
// DirectUser supports multiple heaps used in different situations:
// - Default:   Heap shared by all threads within a common Context
// - Context:   Explicit heap for a (potentially different) Context- used cross-Context
// - Process:   Shared heap available by all Context's within the process.
//
// NOTE: It is VERY important that the Alloc() and Free() calls are properly
// matched so that the memory is properly freed from the correct heap.  If this
// is not done, the memory will not be freed and will result in memory leaks
// or potential process faults.
//

#if DBG
#define DBG_HEAP_PARAMS , const char * pszFileName, int idxLineNum
#define DBG_HEAP_USE    do { pszFileName; idxLineNum; } while (0);
#else
#define DBG_HEAP_PARAMS
#define DBG_HEAP_USE
#endif

class DUserHeap
{
// Construction    
public:
            DUserHeap();
    virtual ~DUserHeap() { }

    enum EHeap
    {
        idProcessHeap   = 0,
        idNtHeap        = 1,
#ifdef _DEBUG
        idCrtDbgHeap    = 2,
#endif
#if USE_ROCKALL
        idRockAllHeap   = 3,
#endif
    };

// Operations
public:
    virtual void *      Alloc(SIZE_T cbSize, bool fZero DBG_HEAP_PARAMS) PURE;
    virtual void *      Realloc(void * pvMem, SIZE_T cbNewSize DBG_HEAP_PARAMS) PURE;
    virtual void        MultiAlloc(int * pnActual, void * prgAlloc[], int cItems, SIZE_T cbSize DBG_HEAP_PARAMS) PURE;
    
    virtual void        Free(void * pvMem) PURE;
    virtual void        MultiFree(int cItems, void * prgAlloc[], SIZE_T cbSize) PURE;

    public:
                void        Lock();
                BOOL        Unlock();

// Data:
protected:
                long    m_cRef;
};


HRESULT     CreateProcessHeap();
void        DestroyProcessHeap();
HRESULT     CreateContextHeap(DUserHeap * pLinkHeap, BOOL fThreadSafe, DUserHeap::EHeap id, DUserHeap ** ppNewHeap);
void        DestroyContextHeap(DUserHeap * pHeapDestroy);
void        ForceSetContextHeap(DUserHeap * pHeapThread);


extern DUserHeap *      g_pheapProcess;
extern DWORD            g_tlsHeap;

#define pProcessHeap    g_pheapProcess
#define pContextHeap    (reinterpret_cast<DUserHeap *> (TlsGetValue(g_tlsHeap)))


#if DBG

#define ClientAlloc(a)              pContextHeap->Alloc(a, true, __FILE__, __LINE__)
#define ClientAlloc_(a,b)           pContextHeap->Alloc(a, b, __FILE__, __LINE__)
#define ClientFree(a)               pContextHeap->Free(a)
#define ClientRealloc(a,b)          pContextHeap->Realloc(a, b, __FILE__, __LINE__)
#define ClientMultiAlloc(a,b,c,d)   pContextHeap->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ClientMultiFree(a,b,c)      pContextHeap->MultiFree(a,b,c)

#define ContextAlloc(p, a)          p->Alloc(a, true, __FILE__, __LINE__)
#define ContextAlloc_(p, a, b)      p->Alloc(a, b, __FILE__, __LINE__)
#define ContextFree(p, a)           p->Free(a)
#define ContextRealloc(p, a, b)     p->Realloc(a, b, __FILE__, __LINE__)
#define ContextMultiAlloc(p,a,b,c,d) p->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ContextMultiFree(p,a, b, c) p->MultiFree(a,b,c)

#define ProcessAlloc(a)             pProcessHeap->Alloc(a, true, __FILE__, __LINE__)
#define ProcessAlloc_(a, b)         pProcessHeap->Alloc(a, b, __FILE__, __LINE__)
#define ProcessFree(a)              pProcessHeap->Free(a)
#define ProcessRealloc(a, b)        pProcessHeap->Realloc(a, b, __FILE__, __LINE__)
#define ProcessMultiAlloc(a,b,c,d)  pProcessHeap->MultiAlloc(a, b, c, d, __FILE__, __LINE__)
#define ProcessMultiFree(a, b, c)   pProcessHeap->MultiFree(a,b,c)

void            DumpData(void * pMem, int nLength);


#else  // DBG


#define ClientAlloc(a)              pContextHeap->Alloc(a, true)
#define ClientAlloc_(a,b)           pContextHeap->Alloc(a, b)
#define ClientFree(a)               pContextHeap->Free(a)
#define ClientRealloc(a,b)          pContextHeap->Realloc(a, b)
#define ClientMultiAlloc(a,b,c,d)   pContextHeap->MultiAlloc(a, b, c, d)
#define ClientMultiFree(a,b,c)      pContextHeap->MultiFree(a,b,c)

#define ContextAlloc(p, a)          p->Alloc(a, true)
#define ContextAlloc_(p, a, b)      p->Alloc(a, b)
#define ContextFree(p, a)           p->Free(a)
#define ContextRealloc(p, a, b)     p->Realloc(a, b)
#define ContextMultiAlloc(p,a,b,c,d) p->MultiAlloc(a, b, c, d)
#define ContextMultiFree(p,a, b, c) p->MultiFree(a,b,c)

#define ProcessAlloc(a)             pProcessHeap->Alloc(a, true)
#define ProcessAlloc_(a, b)         pProcessHeap->Alloc(a, b)
#define ProcessFree(a)              pProcessHeap->Free(a)
#define ProcessRealloc(a, b)        pProcessHeap->Realloc(a, b)
#define ProcessMultiAlloc(a,b,c,d)  pProcessHeap->MultiAlloc(a, b, c, d)
#define ProcessMultiFree(a, b, c)   pProcessHeap->MultiFree(a,b,c)


#endif // DBG


/***************************************************************************\
*****************************************************************************
*
* operator new overloading
*
*****************************************************************************
\***************************************************************************/

#ifndef _INC_NEW
#include <new.h>
#endif

#if DBG

//
//  Use this instead of the usual placement new syntax to avoid conflicts when
//  'new' is re-defined to provide memory leak tracking (below)

#define placement_new(pv, Class)            PlacementNewImpl0<Class>(pv)
#define placement_new1(pv, Class, p1)       PlacementNewImpl1<Class>(pv, p1)
#define placement_copynew(pv, Class, src)   PlacementCopyNewImpl0<Class>(pv, src)
#define placement_delete(pv, Class) (((Class *)(pv))->~Class())

#ifdef new
#undef new
#endif

template <class T>
inline T *
PlacementNewImpl0(void *pv)
{
    return new(pv) T;
};

template <class T, class Param1>
inline T *
PlacementNewImpl1(void *pv, Param1 p1)
{
    return new(pv) T(p1);
};

template <class T>
inline T *
PlacementCopyNewImpl0(void *pv, const T & t)
{
    return new(pv) T(t);
};

#else  // DBG

#define DEBUG_NEW new
#define placement_new(pv, Class)            new(pv) Class
#define placement_new1(pv, Class, p1)       new(pv) Class(p1)
#define placement_copynew(pv, Class, src)   new(pv) Class(src)
#define placement_delete(pv, Class) (((Class *)(pv))->~Class())

#endif // DBG


inline void * __cdecl operator new(size_t nSize)
{
    void * pv = ClientAlloc(nSize);
    return pv;
}

inline void __cdecl operator delete(void * pvMem)
{
    ClientFree(pvMem);
}

#if DBG
template <class type>   inline type *   DoProcessNewDbg(const char * pszFileName, int idxLineNum);
template <class type>   inline type *   DoClientNewDbg(const char * pszFileName, int idxLineNum);
template <class type>   inline type *   DoContextNewDbg(DUserHeap * pHeap, const char * pszFileName, int idxLineNum);
#else
template <class type>   inline type *   DoProcessNew();
template <class type>   inline type *   DoClientNew();
template <class type>   inline type *   DoContextNew(DUserHeap * pHeap);
#endif
template <class type>   inline void     DoProcessDelete(type * pMem);
template <class type>   inline void     DoClientDelete(type * pMem);
template <class type>   inline void     DoContextDelete(DUserHeap * pHeap, type * pMem);

#if DBG
#define ProcessNew(t)           DoProcessNewDbg<t>(__FILE__, __LINE__)
#define ClientNew(t)            DoClientNewDbg<t>(__FILE__, __LINE__)
#define ContextNew(t,p)         DoContextNewDbg<t>(p, __FILE__, __LINE__)
#else
#define ProcessNew(t)           DoProcessNew<t>()
#define ClientNew(t)            DoClientNew<t>()
#define ContextNew(t,p)         DoContextNew<t>(p)
#endif
#define ProcessDelete(t,p)      DoProcessDelete<t>(p)
#define ClientDelete(t,p)       DoClientDelete<t>(p)
#define ContextDelete(t,h,p)    DoContextDelete<t>(p)



//
// To allocate memory on the stack that is aligned on an 8-byte boundary
// we need to allocate an extra 4 bytes.  All stack allocations are on
// 4 byte boundaries.
//

#define STACK_ALIGN8_ALLOC(cb) \
    ((void *) ((((UINT_PTR) _alloca(cb + 4)) + 7) & ~0x07))

#include "SimpleHeap.inl"

#endif // BASE__SimpleHeap_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\stringhelp.h ===
#if !defined(BASE__String_h__INCLUDED)
#define BASE__String_h__INCLUDED
#pragma once

inline  void        CopyString(WCHAR * pszDest, const WCHAR * pszSrc, int cchMax);

#include "StringHelp.inl"

#endif // BASE__String_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\tempheap.h ===
/***************************************************************************\
*
* File: TempHelp.h
*
* Description:
* TempHelp.h defines a "lightweight heap", designed to continuously grow 
* until all memory is freed.  This is valuable as a temporary heap that can
* be used to "collect" data and processed slightly later.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__TempHeap_h__INCLUDED)
#define BASE__TempHeap_h__INCLUDED
#pragma once

class TempHeap
{
// Construction
public:
            TempHeap(int cbPageAlloc = 8000, int cbLargeThreshold = 512);
    inline  ~TempHeap();
    inline  void        Destroy();

// Operations
public:
            void *      Alloc(int cbAlloc);
    inline  BOOL        IsCompletelyFree() const;
    inline  void        Lock();
    inline  void        Unlock();

// Implementation
protected:
            void        FreeAll(BOOL fComplete = FALSE);

// Data
protected:
    struct Page
    {
        Page *      pNext;

        inline  BYTE *  GetData()
        {
            return (BYTE *) (((BYTE *) this) + sizeof(Page));
        }
    };

            long        m_cLocks;
            BYTE *      m_pbFree;
            Page *      m_ppageCur;
            Page *      m_ppageLarge;

            int         m_cbFree;           // Free space on current page
            int         m_cbPageAlloc;      // Allocation size of new pages
            int         m_cbLargeThreshold; // Threshold for allocating large pages
};

#include "TempHeap.inl"

#endif // BASE__TempHeap_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\tempheap.cpp ===
/***************************************************************************\
*
* File: TempHelp.cpp
*
* Description:
* TempHelp.h implements a "lightweight heap", designed to continuously grow 
* until all memory is freed.  This is valuable as a temporary heap that can
* be used to "collect" data and processed slightly later.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "TempHeap.h"

#include "SimpleHeap.h"

/***************************************************************************\
*****************************************************************************
*
* class TempHeap
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
TempHeap::TempHeap(int cbPageAlloc, int cbLargeThreshold)
{
    m_ppageCur          = NULL;
    m_ppageLarge        = NULL;
    m_pbFree            = NULL;
    m_cbFree            = 0;
    m_cbPageAlloc       = cbPageAlloc;
    m_cbLargeThreshold  = cbLargeThreshold;
}


//------------------------------------------------------------------------------
void *      
TempHeap::Alloc(int cbAlloc)
{
    AssertMsg(cbAlloc > 0, "Must specify a valid allocation size");

    if (cbAlloc > m_cbLargeThreshold) {
        //
        // Allocating a very large block, so allocate it directly.
        //

        Page * pageNew = (Page *) ClientAlloc(sizeof(Page) + cbAlloc);
        if (pageNew == NULL) {
            return NULL;
        }

        pageNew->pNext  = m_ppageLarge;
        m_ppageLarge     = pageNew;
        return pageNew->GetData();
    }

    if ((m_ppageCur == NULL) || (cbAlloc > m_cbFree)) {
        Page * pageNew = (Page *) ClientAlloc(sizeof(Page) + m_cbPageAlloc);
        if (pageNew == NULL) {
            return NULL;
        }

        pageNew->pNext  = m_ppageCur;
        m_ppageCur       = pageNew;
        m_cbFree        = m_cbPageAlloc;
        m_pbFree        = pageNew->GetData();
    }

    AssertMsg(m_cbFree >= cbAlloc, "Should have enough space to allocate by now");

    void * pvNew = m_pbFree;
    m_cbFree -= cbAlloc;
    m_pbFree += cbAlloc;

    return pvNew;
}


//------------------------------------------------------------------------------
void        
TempHeap::FreeAll(BOOL fComplete)
{
    Page * pageNext;
    Page * pageTemp;

    //
    // Free large-block allocations
    //

    pageTemp = m_ppageLarge;
    while (pageTemp != NULL) {
        pageNext = pageTemp->pNext;
        ClientFree(pageTemp);
        pageTemp = pageNext;
    }
    m_ppageLarge = NULL;


    //
    // Free small-block allocations
    //
    pageTemp = m_ppageCur;
    while (pageTemp != NULL) {
        pageNext = pageTemp->pNext;
        if ((pageNext == NULL) && (!fComplete)) {
            //
            // Don't free the first block, since we will immediately turn around
            // and allocate it again.  Instead, renew it.
            //

            m_ppageCur  = pageTemp;
            m_cbFree    = m_cbPageAlloc;
            m_pbFree    = pageTemp->GetData();
            break;
        }

        ClientFree(pageTemp);
        pageTemp = pageNext;
    }

    if (fComplete) {
        m_ppageCur  = NULL;
        m_pbFree    = NULL;
        m_cbFree    = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\treenode.cpp ===
/***************************************************************************\
*
* File: TreeNode.cpp
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Base.h"
#include "TreeNode.h"

/***************************************************************************\
*****************************************************************************
*
* class TreeNode
*
*****************************************************************************
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\tempheap.inl ===
/***************************************************************************\
*
* File: TempHelp.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(BASE__TempHeap_inl__INCLUDED)
#define BASE__TempHeap_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class TempHeap
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
TempHeap::~TempHeap()
{
    Destroy();
}


//------------------------------------------------------------------------------
inline void
TempHeap::Destroy()
{
    FreeAll(TRUE /* Complete */);
}


//------------------------------------------------------------------------------
inline BOOL       
TempHeap::IsCompletelyFree() const
{
    return (m_ppageCur == NULL) && (m_ppageLarge == NULL);
}


//------------------------------------------------------------------------------
inline void
TempHeap::Lock()
{
    m_cLocks++;
}


//------------------------------------------------------------------------------
inline void
TempHeap::Unlock()
{
    AssertMsg(m_cLocks > 0, "Must have an outstanding lock");
    if (--m_cLocks == 0) {
        FreeAll(FALSE);
    }
}


#endif // BASE__TempHeap_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\stringhelp.inl ===
#if !defined(BASE__String_inl__INCLUDED)
#define BASE__String_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline void        
CopyString(WCHAR * pszDest, const WCHAR * pszSrc, int cchMax)
{
    wcsncpy(pszDest, pszSrc, cchMax);
    pszDest[cchMax - 1] = '\0';
}


#endif // BASE__String_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\basegadget.inl ===
/***************************************************************************\
*
* File: BaseGadget.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__BaseGadget_inl__INCLUDED)
#define CORE__BaseGadget_inl__INCLUDED

#include "Context.h"

/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuEventGadget * 
CastBaseGadget(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmEventGadget)) {
        return (DuEventGadget *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuEventGadget * 
CastBaseGadget(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmEventGadget)) {
        return (const DuEventGadget *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuEventGadget * 
ValidateBaseGadget(HGADGET hgad)
{
    return CastBaseGadget(MsgObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline DuEventGadget * 
ValidateBaseGadget(EventGadget * pgb)
{
    return (DuEventGadget *) MsgObject::CastMsgObject(pgb);
}


//------------------------------------------------------------------------------
inline  
DuEventGadget::DuEventGadget()
{
    m_pContext  = ::GetContext();
    AssertMsg(m_pContext != NULL, "Context must already exist");

#if DBG_CHECK_CALLBACKS
    GetContext()->m_cLiveObjects++;
#endif    
}


//------------------------------------------------------------------------------
inline HGADGET     
DuEventGadget::GetHandle() const
{
    return (HGADGET) MsgObject::GetHandle();
}


//------------------------------------------------------------------------------
inline Context *   
DuEventGadget::GetContext() const
{
    AssertMsg(m_pContext != NULL, "Must have a valid Context");
    return m_pContext;
}


//------------------------------------------------------------------------------
inline UINT        
DuEventGadget::GetFilter() const
{
    return m_cb.GetFilter();
}


//------------------------------------------------------------------------------
inline const GPCB & 
DuEventGadget::GetCallback() const
{
    return m_cb;
}


//------------------------------------------------------------------------------
inline const DuEventPool &
DuEventGadget::GetDuEventPool() const
{
    return m_epEvents;
}


#endif // CORE__BaseGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\basegadget.h ===
/***************************************************************************\
*
* File: BaseGadget.h
*
* Description:
* BaseGadget.h defines the fundamental Gadget object that all Gadgets are 
* derived from.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__BaseGadget_h__INCLUDED)
#define CORE__BaseGadget_h__INCLUDED
#pragma once

#include "Callback.h"
#include "EventPool.h"

class Context;

struct CREATE_INFO
{
    GADGETPROC  pfnProc;
    void *      pvData;
};

/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget defines the fundamental object that all Gadget 
* implementations derived from.
*
*****************************************************************************
\***************************************************************************/

class DuEventGadget : 
#if ENABLE_MSGTABLE_API
        public EventGadgetImpl<DuEventGadget, MsgObject>
#else
        public MsgObject
#endif
{
// Construction
public:
    inline  DuEventGadget();
#if DBG_CHECK_CALLBACKS
    virtual ~DuEventGadget();
#endif

// BaseObject
public:
    inline  HGADGET     GetHandle() const;
    virtual UINT        GetHandleMask() const { return hmMsgObject | hmEventGadget; }

// DuEventGadget Interface
public:
    inline  Context *   GetContext() const;

    inline  UINT        GetFilter() const;
    virtual void        SetFilter(UINT nNewFilter, UINT nMask);

    inline  const GPCB& GetCallback() const;
    inline  const DuEventPool& GetDuEventPool() const;

            HRESULT     AddMessageHandler(MSGID idEvent, DuEventGadget * pdgbHandler);
            HRESULT     AddMessageHandler(MSGID idEvent, DUser::EventDelegate ed);
            HRESULT     RemoveMessageHandler(MSGID idEvent, DuEventGadget * pdgbHandler);
            HRESULT     RemoveMessageHandler(MSGID idEvent, DUser::EventDelegate ed);

            void        RemoveDependency(DuEventGadget * pdgbDependency);

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(EventGadget);
    static HRESULT CALLBACK
    PromoteEventGadget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData) 
    {
        return MsgObject::PromoteInternal(pfnCS, hclCur, pgad, pciData);
    }

    devent  HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetFilter(EventGadget::GetFilterMsg * pmsg);
    dapi    HRESULT     ApiSetFilter(EventGadget::SetFilterMsg * pmsg);
    dapi    HRESULT     ApiAddHandlerG(EventGadget::AddHandlerGMsg * pmsg);
    dapi    HRESULT     ApiAddHandlerD(EventGadget::AddHandlerDMsg * pmsg);
    dapi    HRESULT     ApiRemoveHandlerG(EventGadget::RemoveHandlerGMsg * pmsg);
    dapi    HRESULT     ApiRemoveHandlerD(EventGadget::RemoveHandlerDMsg * pmsg);

#endif // ENABLE_MSGTABLE_API

// Internal Implementation
public:
            void        CleanupMessageHandlers();

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    // 
    // MsgObject:       4 DWORD's (v-table, lock count, pMT, rpgThis)
    //

            Context *   m_pContext;         // (1D) Object context

            GPCB        m_cb;               // (3D) Callback to outside-window "implementation"
                                            // (Debug + 1D)
            DuEventPool   m_epEvents;         // (1D) Event pool
            GArrayS<DuEventGadget *> m_arDepend;   // (1D) Dependencies of this DuVisual (may have duplicates)

    //
    // Current size:    10  DWORD's      (Debug = 11 DWORD's)
    //                  40 bytes         (Debug = 44 bytes)
    //
};

#include "BaseGadget.inl"

#endif // CORE__BaseGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\basegadget.cpp ===
/***************************************************************************\
*
* File: BaseGadget.cpp
*
* Description:
* BaseGadget.cpp implements the "EventGadget" object that provides event
* notifications to any derived objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "BaseGadget.h"


/***************************************************************************\
*****************************************************************************
*
* class DuEventGadget
*
*****************************************************************************
\***************************************************************************/

#if DBG_CHECK_CALLBACKS
DuEventGadget::~DuEventGadget()
{
    GetContext()->m_cLiveObjects--;
}
#endif    


/***************************************************************************\
*
* DuEventGadget::AddMessageHandler
*
* AddMessageHandler() attaches the given Gadget to the set of 
* "message handlers" for this Gadget.
*
* NOTE: Every time 1 DuEventGadget becomes dependent on 2, 2 is added to 1's 
* list.  This means that there may be duplicates, but that is by design 
* since it lets us keep track of the dependency count.
*
* NOTE: This function is designed to be used with DuEventPool::AddHandler() 
* to maintain a list of "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::AddMessageHandler(
    IN  MSGID idEvent,              // Event to handle
    IN  DuEventGadget * pdgbHandler)   // DuEventGadget to handle event
{
    //
    // Dont allow hooking up during destruction.  The Gadgets will NOT receive
    // the proper destruction messages and will have problems properly shutting
    // down.
    //

    if (IsStartDelete() || pdgbHandler->IsStartDelete()) {
        return DU_E_STARTDESTROY;
    }


    //
    // When pdgbHandler can handle events from this DuEventGadget, it is added 
    // to the handler list.  This DuEventGadget must also be added into 
    // pdgbHandler->m_arDepend because pdgbHandler is dependent on this 
    // DuEventGadget.

    switch (m_epEvents.AddHandler(idEvent, pdgbHandler))
    {
    case DuEventPool::aExisting:
        //
        // Already existing, so don't need to do anything (and DON'T add to 
        // m_arDepend or will get out of sync).
        //

        return S_OK;
    
    case DuEventPool::aAdded:
        if (pdgbHandler->m_arDepend.Add(this) >= 0) {
            // Successfully added relationship
            return S_OK;
        } else {
            //
            // Unable to add dependency, so have to remove handler if it 
            // was just added.
            //

            HRESULT hr = m_epEvents.RemoveHandler(idEvent, pdgbHandler);
            VerifyHR(hr);
            return hr;
        }

    
    default:
    case DuEventPool::aFailed:
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuEventGadget::AddMessageHandler
*
* AddMessageHandler() attaches the given delegate to the set of 
* "message handlers" for this Gadget.
*
* NOTE: Every time 1 DuEventGadget becomes dependent on 2, 2 is added to 1's 
* list.  This means that there may be duplicates, but that is by design 
* since it lets us keep track of the dependency count.
*
* NOTE: This function is designed to be used with DuEventPool::AddHandler() 
* to maintain a list of "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::AddMessageHandler(
    IN  MSGID idEvent,              // Event to handle
    IN  DUser::EventDelegate ed)    // Delegate
{
    //
    // Dont allow hooking up during destruction.  The Gadgets will NOT receive
    // the proper destruction messages and will have problems properly shutting
    // down.
    //

    if (IsStartDelete()) {
        return DU_E_STARTDESTROY;
    }


    //
    // When (pvData, pfnHandler) can handle events from this DuEventGadget, it 
    // is added to the handler list.  This DuEventGadget must also be added into 
    // pdgbHandler->m_arDepend because pdgbHandler is dependent on this 
    // DuEventGadget.

    switch (m_epEvents.AddHandler(idEvent, ed))
    {
    case DuEventPool::aExisting:
    case DuEventPool::aAdded:
        return S_OK;
    
    default:
    case DuEventPool::aFailed:
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuEventGadget::RemoveMessageHandler
*
* RemoveMessageHandler() searches for and removes one instance of the given 
* Gadget from the set of "message handlers" for this Gadget.  Both the
* idEvent and pdgbHandler must match.
*
* NOTE: This function is designed to be used with DuEventPool::RemoveHandler()
* and CleanupMessageHandlers() to maintain a list of "message handlers" 
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::RemoveMessageHandler(
    IN  MSGID idEvent,              // Event being handled
    IN  DuEventGadget * pdgbHandler)   // DuEventGadget handling the event
{
    HRESULT hr = DU_E_GENERIC;
    
    hr = m_epEvents.RemoveHandler(idEvent, pdgbHandler);
    if (SUCCEEDED(hr)) {
        if (pdgbHandler->m_arDepend.Remove(this)) {
            hr = S_OK;
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuEventGadget::RemoveMessageHandler
*
* RemoveMessageHandler() searches for and removes one instance of the given 
* delegate from the set of "message handlers" for this Gadget.  Both the
* idEvent and pdgbHandler must match.
*
* NOTE: This function is designed to be used with DuEventPool::RemoveHandler()
* and CleanupMessageHandlers() to maintain a list of "message handlers" 
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventGadget::RemoveMessageHandler(
    IN  MSGID idEvent,              // Event being handled
    IN  DUser::EventDelegate ed)    // Delegate
{
    return m_epEvents.RemoveHandler(idEvent, ed);
}


/***************************************************************************\
*
* DuEventGadget::CleanupMessageHandlers
*
* CleanupMessageHandlers() goes through and detaches all "message handlers"
* attached to this Gadget.  This function is called as a part of Gadget
* destruction when a Gadget is removed from the tree and its 
* "message handlers" need to be notified of the Gadget's destruction.
*
* NOTE: This function does NOT callback and notify the Gadget that it is
* being removed.  This is VERY important because the object may no longer 
* be setup for callbacks.  Therefore, the object needs to be notified before
* this point.  This normally happens by the MessageHandler Gadgets watching 
* GM_DESTROY messages that are marked as GMF_EVENT.
*
\***************************************************************************/

void
DuEventGadget::CleanupMessageHandlers()
{
    //
    // Go through all DuEventGadgets that this DuEventGadget is dependent on and remove the
    // dependency.  If the same DuEventGadget appears in m_arDepend multiple times, it
    // be removed from the corresponding m_epEvents multiple times.
    //

    while (!m_arDepend.IsEmpty()) {
        int cItems = m_arDepend.GetSize();
        for (int idx = 0; idx < cItems; idx++) {
            DuEventGadget * pdgbCur = m_arDepend[idx];
            VerifyMsgHR(pdgbCur->m_epEvents.RemoveHandler(this), "Handler should exist");
        }
        m_arDepend.RemoveAll();
    }


    //
    // Go through and remove all event handlers of this DuEventGadget from m_epEvents.
    //

    m_epEvents.Cleanup(this);
}


/***************************************************************************\
*
* DuEventGadget::RemoveDependency
*
* RemoveDependency() removes a single "message handler" dependency from the
* set of "message handlers".  This function is called back from the 
* DuEventPool for each "message handler" during processing of 
* CleanupMessageHandlers().
*
\***************************************************************************/

void
DuEventGadget::RemoveDependency(
    IN  DuEventGadget * pdgbDependency)    // Dependency to be removed
{
    int idxDepend = m_arDepend.Find(pdgbDependency);
    if (idxDepend >= 0) {
        m_arDepend.RemoveAt(idxDepend);
    } else {
        AssertMsg(0, "Can not find dependency");
    }
}


//------------------------------------------------------------------------------
void
DuEventGadget::SetFilter(UINT nNewFilter, UINT nMask)
{
    m_cb.SetFilter(nNewFilter, nMask);
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiOnEvent(EventMsg * pmsg)
{
    return m_cb.xwCallGadgetProc(GetHandle(), pmsg);
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiGetFilter(EventGadget::GetFilterMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, m_pContext);

    pmsg->nFilter = (GetFilter() & GMFI_VALID);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiSetFilter(EventGadget::SetFilterMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nNewFilter, GMFI_VALID);
    CHECK_MODIFY();

    SetFilter(pmsg->nNewFilter, pmsg->nMask);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiAddHandlerG(EventGadget::AddHandlerGMsg * pmsg)
{
    DuEventGadget * pdgbHandler;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_EVENTGADGET(pmsg->pgbHandler, pdgbHandler);
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = AddMessageHandler(pmsg->nEventMsg, pdgbHandler);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiAddHandlerD(EventGadget::AddHandlerDMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    if (pmsg->ed.m_pfn == NULL) {
        PromptInvalid("Must specify valid delegate");
        goto ErrorExit;
    }
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = AddMessageHandler(pmsg->nEventMsg, pmsg->ed);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiRemoveHandlerG(EventGadget::RemoveHandlerGMsg * pmsg)
{
    DuEventGadget * pdgbHandler;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_EVENTGADGET(pmsg->pgbHandler, pdgbHandler);
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = RemoveMessageHandler(pmsg->nEventMsg, pdgbHandler);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuEventGadget::ApiRemoveHandlerD(EventGadget::RemoveHandlerDMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    if (pmsg->ed.m_pfn == NULL) {
        PromptInvalid("Must specify valid delegate");
        goto ErrorExit;
    }
    if (((pmsg->nEventMsg < PRID_GlobalMin) && (pmsg->nEventMsg > 0)) || (pmsg->nEventMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    retval = RemoveMessageHandler(pmsg->nEventMsg, pmsg->ed);

    END_API();
}


#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\treenode.h ===
/***************************************************************************\
*
* File: TreeNode.h
*
* Description:
* TreeNode describes a low-level tree designed to be used to maintain a 
* window hierarchy.  Specific classes that use this tree should be derived
* from TreeNodeT to safely cast the pointers to its specific type.
*
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__TreeNode_h__INCLUDED)
#define BASE__TreeNode_h__INCLUDED
#pragma once

//------------------------------------------------------------------------------
class TreeNode
{
// Implementation
protected:
            enum ELinkType
            {
                ltAny       = 0,
                ltBefore    = 1,
                ltBehind    = 2,
                ltTop       = 3,
                ltBottom    = 4,
            };
};


//------------------------------------------------------------------------------
template <class T>
class TreeNodeT : public TreeNode
{
// Construction
public:
            TreeNodeT();
            ~TreeNodeT();

// Operations
public:
    inline  T *         GetParent() const;
    inline  T *         GetPrev() const;
    inline  T *         GetNext() const;
    inline  T *         GetTopSibling() const;
    inline  T *         GetBottomSibling() const;
    inline  T *         GetTopChild() const;
    inline  T *         GetBottomChild() const;

// Implementation
protected:
            void        DoLink(T * ptnParent, T * ptnSibling = NULL, ELinkType lt = ltAny);
            void        DoUnlink();

#if DBG
public:
    inline  BOOL        DEBUG_IsChild(const TreeNodeT<T> * pChild) const;
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    //

            TreeNodeT<T> *  m_ptnParent;
            TreeNodeT<T> *  m_ptnChild;
            TreeNodeT<T> *  m_ptnNext;
            TreeNodeT<T> *  m_ptnPrev;
};

#include "TreeNode.inl"

#endif // BASE__TreeNode_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\base\treenode.inl ===
/***************************************************************************\
*
* File: TreeNode.inl
*
* History:
*  1/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(BASE__TreeNode_inl__INCLUDED)
#define BASE__TreeNode_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class TreeNode
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline 
TreeNodeT<T>::TreeNodeT()
{

}


//------------------------------------------------------------------------------
template <class T>
inline
TreeNodeT<T>::~TreeNodeT()
{

}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetTopSibling() const
{
    T * pTreeNode = const_cast<T *> (this);

    while (pTreeNode->m_ptnPrev != NULL) {
        pTreeNode = pTreeNode->m_ptnPrev;
    }

    return pTreeNode;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetBottomSibling() const
{
    TreeNodeT<T> * pTreeNode = const_cast<TreeNodeT<T> *> (this);

    while (pTreeNode->m_ptnNext != NULL) {
        pTreeNode = pTreeNode->m_ptnNext;
    }

    return (T *) pTreeNode;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetParent() const
{
    return (T *) m_ptnParent;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetPrev() const
{
    return (T *) m_ptnPrev;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetNext() const
{
    return (T *) m_ptnNext;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetTopChild() const
{
    return (T *) m_ptnChild;
}


//------------------------------------------------------------------------------
template <class T>
inline T * 
TreeNodeT<T>::GetBottomChild() const
{
    if (m_ptnChild != NULL) {
        return GetTopChild()->GetBottomSibling();
    } else {
        return NULL;
    }
}


/***************************************************************************\
*
* TreeNodeT::DoLink
*
* DoLink chains _this_ node into the tree.  A sibling and a parent (may) be 
* given as reference, depending on the situation.  This node (the one 
* being linked) _must_ have already been unlinked previously.
*
\***************************************************************************/

template <class T>
void    
TreeNodeT<T>::DoLink(
    IN  T * ptnParent,              // New parent
    IN  T * ptnSibling,             // Node to link to this (unlinked) Node
    IN  ELinkType lt)               // Position of ptn relative to this
{
    // Check parameters
    AssertWritePtr(ptnParent);

    // Verify the TreeNode is unlinked
    Assert((m_ptnNext == NULL) && (m_ptnPrev == NULL) && (m_ptnParent == NULL));

    //
    // Link this TreeNode to the parent.
    //

    m_ptnParent                 = ptnParent;
    TreeNodeT<T> * ptnOldChild  = ptnParent->m_ptnChild;
    if (ptnOldChild == NULL) {
        //
        // Simple case, no siblings so just do it.
        //
        AssertMsg(ptnSibling == NULL, "Parent doesn't have any children");

        ptnParent->m_ptnChild   = this;
    } else {
        //
        // Uggh- complex case, so need to Link this TreeNode to its new siblings
        //

        switch (lt) {
        case ltBefore:
            AssertWritePtr(ptnSibling);
            m_ptnNext               = ptnSibling;
            m_ptnPrev               = ptnSibling->m_ptnPrev;
            ptnSibling->m_ptnPrev   = this;
            if (m_ptnPrev != NULL) {
                m_ptnPrev->m_ptnNext = this;
            }
            break;

        case ltBehind:
            AssertWritePtr(ptnSibling);
            m_ptnPrev               = ptnSibling;
            m_ptnNext               = ptnSibling->m_ptnNext;
            ptnSibling->m_ptnNext   = this;
            if (m_ptnNext != NULL) {
                m_ptnNext->m_ptnPrev = this;
            }
            break;

        case ltAny:
        case ltTop:
            ptnParent->m_ptnChild   = this;
            m_ptnNext               = ptnOldChild;
            if (ptnOldChild != NULL) {
                ptnOldChild->m_ptnPrev = this;
            }
            break;

        case ltBottom:
            ptnOldChild             = ptnOldChild->GetBottomSibling();
            ptnOldChild->m_ptnNext  = this;
            m_ptnPrev               = ptnOldChild;
            break;

        default:
            AssertMsg(0, "Unknown link type");
        }
    }
}


/***************************************************************************\
*
* TreeNode::DoUnlink
*
* DoUnlink() removes this TreeNode from the TreeNode tree.  The parents and 
* siblings of the TreeNode are properly modified.
*
\***************************************************************************/

template <class T>
void    
TreeNodeT<T>::DoUnlink()
{
    //
    // Unlink from the parent
    //

    if (m_ptnParent != NULL) {
        if (m_ptnParent->m_ptnChild == this) {
            m_ptnParent->m_ptnChild = m_ptnNext;
        }
    }

    //
    // Unlink from siblings
    //

    if (m_ptnNext != NULL) {
        m_ptnNext->m_ptnPrev = m_ptnPrev;
    }

    if (m_ptnPrev != NULL) {
        m_ptnPrev->m_ptnNext = m_ptnNext;
    }

    m_ptnParent   = NULL;
    m_ptnNext     = NULL;
    m_ptnPrev     = NULL;
}


#if DBG

template <class T>
inline BOOL
TreeNodeT<T>::DEBUG_IsChild(const TreeNodeT<T> * pChild) const
{
    TreeNodeT<T> * pCur = m_ptnChild;
    while (pCur != NULL) {
        if (pCur == pChild) {
            return TRUE;
        }
        pCur = pCur->m_ptnNext;
    }

    return FALSE;
}


/***************************************************************************\
*
* TreeNodeT<T>::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

template <class T>
void
TreeNodeT<T>::DEBUG_AssertValid() const
{
    if (m_ptnParent != NULL) {
        Assert(m_ptnParent->DEBUG_IsChild(this));
    }

    if (m_ptnNext != NULL) {
        Assert(m_ptnNext->m_ptnPrev == this);
    }

    if (m_ptnPrev != NULL) {
        Assert(m_ptnPrev->m_ptnNext == this);
    }

    if (m_ptnChild != NULL) {
        Assert(m_ptnChild->m_ptnParent == this);
    }
}

#endif // DBG

#endif // BASE__TreeNode_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\callback.cpp ===
/***************************************************************************\
*
* File: Callback.cpp
*
* Description:
* Callback.cpp wraps the standard DirectUser DuVisual callbacks into
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Callback.h"

#include "TreeGadget.h"
#include "MessageGadget.h"

/***************************************************************************\
*
* SimpleEventProc (Internal)
*
* SimpleEventProc() provides a stub GadgetProc used when pfnProc is NULL.
* This allows the core to always assume a non-NULL proc and not have to
* perform a comparison.
*
\***************************************************************************/

HRESULT CALLBACK
SimpleEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
	UNREFERENCED_PARAMETER(hgadCur);
	UNREFERENCED_PARAMETER(pvCur);
	UNREFERENCED_PARAMETER(pmsg);

	return DU_S_NOTHANDLED;
}


/***************************************************************************\
*****************************************************************************
*
* class GPCB
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GPCB::Create
*
* Create() initializes a newly constructed GPCB.
*
* NOTE: This function has a different prototype in DEBUG that takes an extra
* HGADGET parameter that is used to Verify against the passed HGADGET for
* the various Fire() functions.
*
\***************************************************************************/

void
GPCB::Create(
    IN  GADGETPROC pfnProc,         // Application defined callback
    IN  void * pvData               // Application defined data
#if DBG
    ,IN HGADGET hgadCheck           // Gadget to Verify proper hookup
#endif // DBG
    )
{
    Assert(hgadCheck != NULL);

	if (pfnProc == NULL) {
        //
        // Don't want to check for NULL's, so just give an "empty" GP if one
        // was not specified.
        //

		pfnProc     = SimpleEventProc;
		pvData      = NULL;
        m_nFilter   = 0;            // Don't need any messages
	}

    m_pfnProc   = pfnProc;
    m_pvData    = pvData;
#if DBG
    m_hgadCheck = hgadCheck;
#endif // DBG
}



/***************************************************************************\
*
* GPCB::Destroy
*
* Destroy() informs the GPCB that the last message has been fired and that
* no more callbacks should be made.  If any slip through, need to send them
* to SimpleEventProc so that they get "eaten".
*
\***************************************************************************/

void
GPCB::Destroy()
{
	m_pfnProc   = SimpleEventProc;
	m_pvData    = NULL;
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwCallOnEvent(const DuEventGadget * pg, EventMsg * pmsg)
{
#if ENABLE_MSGTABLE_API
    return Cast<EventGadget>(pg)->OnEvent(pmsg);
#else
    return pg->GetCallback().xwCallGadgetProc(pg->GetHandle(), pmsg);
#endif
}


/***************************************************************************\
*
* GPCB::xwInvokeRoute
*
* xwInvokeRoute routes a message from the top of the DuVisual sub-tree to 
* the specified gadget.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeRoute(
    IN  DuVisual * const * rgpgadCur, // DuVisual path to send messages to
    IN  int cItems,                     // Number of items in path
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    AssertMsg(GET_EVENT_DEST(pmsg) == GMF_ROUTED, "Must already mark as routed");
    AssertMsg(cItems >= 1, "Must have at least one item");

    BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
    HRESULT hrKeep  = DU_S_NOTHANDLED;

    for (int idx = 0; idx < cItems; idx++) {
        const DuVisual * pgadCur = rgpgadCur[idx];
        HRESULT hrT = xwCallOnEvent(pgadCur, pmsg);
        switch (hrT)
        {
        default:
            if (FAILED(hrT)) {
                return hrT;
            }
            // Else, fall-through
            
        case DU_S_NOTHANDLED:
            break;

        case DU_S_COMPLETE:
            if (fSendAll) {
                hrKeep = DU_S_COMPLETE;
            } else {
                return DU_S_COMPLETE;
            }
            break;

        case DU_S_PARTIAL:
            if (hrKeep == DU_S_NOTHANDLED) {
                hrKeep = DU_S_PARTIAL;
            }
            break;
        }
    }

    return hrKeep;
}


/***************************************************************************\
*
* GPCB::xwInvokeBubble
*
* xwInvokeBubble() walks up the DuVisual tree sending a message to each item.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeBubble(
    IN  DuVisual * const * rgpgadCur, // DuVisual path to send messages to
    IN  int cItems,                     // Number of items in path
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    AssertMsg(GET_EVENT_DEST(pmsg) == GMF_BUBBLED, "Must already mark as bubbled");
    AssertMsg(cItems >= 1, "Must have at least one item");

    BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
    HRESULT hrKeep  = DU_S_NOTHANDLED;

    for (int idx = cItems-1; idx >= 0; idx--) {
        const DuVisual * pgadCur = rgpgadCur[idx];
        HRESULT hrT = xwCallOnEvent(pgadCur, pmsg);
        switch (hrT)
        {
        default:
            if (FAILED(hrT)) {
                return hrT;
            }
            // Else, fall-through
            
        case DU_S_NOTHANDLED:
            break;

        case DU_S_COMPLETE:
            if (fSendAll) {
                hrKeep = DU_S_COMPLETE;
            } else {
                return DU_S_COMPLETE;
            }
            break;

        case DU_S_PARTIAL:
            if (hrKeep == DU_S_NOTHANDLED) {
                hrKeep = DU_S_PARTIAL;
            }
            break;
        }
    }

    return hrKeep;
}


//------------------------------------------------------------------------------
HRESULT 
xwInvoke(DUser::EventDelegate ed, EventMsg * pmsg)
{
    HRESULT hr;

    //
    // Need to guard around the callback to prevent DirectUser from becoming
    // completely toast if something goes wrong.
    //

    __try 
    {
        hr = ed.Invoke(pmsg);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

    return hr;
}


/***************************************************************************\
*
* GPCB::xwInvokeDirect
*
* xwInvokeDirect() implements the core message callback for direct (non-full)
* messages.  This includes the DuVisual itself and any MessageHandlers
* attached to the Gadget.
*
* NOTE: This function directly accesses data in DuEventPool to help
* performance and minimize the implementation exposure of DuEventPool to only
* this function.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeDirect(
    IN  const DuEventGadget * pgadMsg,   // DuVisual to send message to
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    //
    // "Prepare" the message and send to the Gadget.
    //

    pmsg->hgadMsg   = pgadMsg->GetHandle();
    pmsg->nMsgFlags = GMF_DIRECT;

    HRESULT hrKeep = xwCallOnEvent(pgadMsg, pmsg);
    if (FAILED(hrKeep)) {
        return hrKeep;
    }


    //
    // Send to all of the event handlers.  This is a little different than
    // normal iteractions.  We DON'T want to immediately return if we get
    // GPR_COMPLETE.  Instead, just mark it but continue to iterate through
    // and call ALL event handlers.
    //

    const DuEventPool & pool = pgadMsg->GetDuEventPool();

    if (!pool.IsEmpty()) {
        int cItems      = pool.GetCount();

        BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
        BOOL fReadOnly  = TestFlag(nInvokeFlags, ifReadOnly);

        //
        // To send the event to all MessageHandlers, need to:
        // - Copy and lock all MessageHandlers
        // - Fire the message
        // - Unlock all MessageHandlers
        //

        int idx;
        int cbAlloc = cItems * sizeof(DuEventPool::EventData);
        DuEventPool::EventData * rgDataCopy = (DuEventPool::EventData *) _alloca(cbAlloc);
        CopyMemory(rgDataCopy, pool.GetData(), cbAlloc);

        if (!fReadOnly) {
            for (idx = 0; idx < cItems; idx++) {
                if (rgDataCopy[idx].fGadget) {
                    rgDataCopy[idx].pgbData->Lock();
                }
            }
        }


        //
        // Iterate through our copy, firing on each of the MessageHandlers.
        // For Delegates, only fire if the MSGID's are a match
        // For Gadgets, fire if MSGID's are a match, or if signaled to send to all.
        //

        pmsg->nMsgFlags = GMF_EVENT;

        HRESULT hrT;
        for (idx = 0; idx < cItems; idx++) {
            int nID = rgDataCopy[idx].id;
            DuEventPool::EventData & data = rgDataCopy[idx];
            if ((nID == pmsg->nMsg) || 
                    (data.fGadget && (fSendAll || (nID == 0)))) {

                if (data.fGadget) {
                    hrT = xwCallOnEvent(data.pgbData, pmsg);
                } else {
                    hrT = xwInvoke(data.ed, pmsg);
                }
                switch (hrT) {
                default:
                case DU_S_NOTHANDLED:
                    break;

                case DU_S_COMPLETE:
                    hrKeep = DU_S_COMPLETE;

                case DU_S_PARTIAL:
                    if (hrKeep == DU_S_NOTHANDLED) {
                        hrKeep = DU_S_PARTIAL;
                    }
                    break;
                }
            }
        }


        //
        // Done firing, so cleanup our copy.
        //

        if (!fReadOnly) {
            for (idx = 0; idx < cItems; idx++) {
                if (rgDataCopy[idx].fGadget) {
                    rgDataCopy[idx].pgbData->xwUnlock();
                }
            }
        }
    }

    return hrKeep;
}


/***************************************************************************\
*
* GPCB::xwInvokeFull
*
* xwInvokeFull() implements the core message callback for "full" messages.
* This includes routing, direct, message handlers, and bubbling.
*
\***************************************************************************/

HRESULT
GPCB::xwInvokeFull(
    IN  const DuVisual * pgadMsg,   // DuVisual message is about
    IN  EventMsg * pmsg,                // Message to send
    IN  UINT nInvokeFlags               // Flags modifying the Invoke
    ) const
{
    //
    // "Prepare" the message
    //

    pmsg->hgadMsg   = pgadMsg->GetHandle();
    pmsg->nMsgFlags = 0;


    //
    // Build the path that needs to be traversed when routing and bubbling.
    // We need to make a copy (and Lock()) all of these Gadgets so that they
    // are valid during the entire messaging process.
    //

    int cItems = 0;
    DuVisual * pgadCur = pgadMsg->GetParent();
    while (pgadCur != NULL) {
        pgadCur = pgadCur->GetParent();
        cItems++;
    }

    DuVisual ** rgpgadPath = NULL;
    if (cItems > 0) {
        BOOL fSendAll   = TestFlag(nInvokeFlags, ifSendAll);
        BOOL fReadOnly  = TestFlag(nInvokeFlags, ifReadOnly);
        HRESULT hrKeep  = DU_S_NOTHANDLED;


        //
        // Store the path in an array with the Root in the first slot.
        //

        rgpgadPath = (DuVisual **) alloca(cItems * sizeof(DuVisual *));

        int idx = cItems;
        pgadCur = pgadMsg->GetParent();
        if (fReadOnly) {
            while (pgadCur != NULL) {
                rgpgadPath[--idx] = pgadCur;
                pgadCur = pgadCur->GetParent();
            }
        } else {
            while (pgadCur != NULL) {
                rgpgadPath[--idx] = pgadCur;
                pgadCur->Lock();
                pgadCur = pgadCur->GetParent();
            }
        }
        AssertMsg(idx == 0, "Should add every item");
        AssertMsg(rgpgadPath[0]->IsRoot(), "First item must be a Root");


        //
        // Route
        //

        pmsg->nMsgFlags = GMF_ROUTED;
        hrKeep = xwInvokeRoute(rgpgadPath, cItems, pmsg, nInvokeFlags);
        if ((hrKeep == DU_S_COMPLETE) && (!fSendAll)) {
            goto Finished;
        }


        //
        // Direct and MessageHandlers
        //

        hrKeep = xwInvokeDirect(pgadMsg, pmsg, nInvokeFlags);
        if (hrKeep == DU_S_COMPLETE) {
            goto Finished;
        }


        //
        // Bubble
        //

        pmsg->nMsgFlags = GMF_BUBBLED;
        hrKeep = xwInvokeBubble(rgpgadPath, cItems, pmsg, nInvokeFlags);

Finished:
        //
        // Finished processing, so walk through the array from the bottom of the
        // tree, Unlock()'ing each Gadget.
        //

        if (!fReadOnly) {
            idx = cItems;
            while (--idx >= 0) {
                rgpgadPath[idx]->xwUnlock();
            }
        }

        return hrKeep;
    } else {
        //
        // Direct and MessageHandlers
        //

        return xwInvokeDirect(pgadMsg, pmsg, nInvokeFlags);
    }
}


#if DBG

//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuEventGadget * pgad, BOOL fDestructionMsg) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");

    const DuVisual * pgadTree = CastVisual(pgad);
    if (pgadTree != NULL) {
        AssertMsg(fDestructionMsg || (!pgadTree->IsStartDelete()), 
                "Can not send messages in destruction");
    }
}


//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuVisual * pgad, BOOL fDestructionMsg) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");
    AssertMsg(fDestructionMsg || (!pgad->IsStartDelete()), 
            "Can not send messages in destruction");
}


//------------------------------------------------------------------------------
void        
GPCB::DEBUG_CheckHandle(const DuListener * pgad) const
{
    AssertMsg(m_hgadCheck == pgad->GetHandle(), "Gadgets must match");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\callback.inl ===
/***************************************************************************\
*
* File: Callback.inl
*
* Description:
* Callback.inl wraps the standard DirectUser DuVisual callbacks into 
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Callback_inl__INCLUDED)
#define CORE__Callback_inl__INCLUDED

#include "Thread.h"

/***************************************************************************\
*
* GPCB::GPCB
*
* GPCB() builds but does not fully initialize a new GPCB.  The caller must
* call Create() to complete the initialization.
*
\***************************************************************************/

inline
GPCB::GPCB()
{
    //
    // Initially send no optional messages.  Destruction messages will always be
    // sent.
    //
    
    m_nFilter = 0;

#if DBG
    m_hgadCheck = (HGADGET) (INT_PTR) 0xABCD1234;
#endif // DBG
}


//------------------------------------------------------------------------------
inline UINT    
GPCB::GetFilter() const
{
    return m_nFilter;
}


//------------------------------------------------------------------------------
inline void    
GPCB::SetFilter(UINT nNewFilter, UINT nMask)
{
    ChangeFlag(m_nFilter, nNewFilter, nMask);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwInvokeDirect(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags) const
{
    return xwInvokeDirect(reinterpret_cast<const DuEventGadget *> (pgadMsg), pmsg, nInvokeFlags);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwInvokeDirect(const DuListener * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags) const
{
    return xwInvokeDirect(reinterpret_cast<const DuEventGadget *> (pgadMsg), pmsg, nInvokeFlags);
}


//------------------------------------------------------------------------------
inline void        
GPCB::xwFireDestroy(const DuEventGadget * pgad, UINT nCode) const
{
#if DBG
    DEBUG_CheckHandle(pgad, TRUE);
#endif // DBG

    GMSG_DESTROY msg;
    msg.cbSize      = sizeof(msg);
    msg.nMsg        = GM_DESTROY;
    msg.nCode       = nCode;

    xwInvokeDirect(pgad, &msg, ifSendAll);
}


inline const Gdiplus::RectF
Convert(const RECT * prc)
{
    Gdiplus::RectF rc(
        (float) prc->left, 
        (float) prc->top,
        (float) (prc->right - prc->left),
        (float) (prc->bottom - prc->top));

    return rc;
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaint(const DuVisual * pgad, HDC hdc, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_PAINT)) {
        GMSG_PAINTRENDERI msg;
        msg.cbSize          = sizeof(msg);
        msg.nMsg            = GM_PAINT;
        msg.nCmd            = GPAINT_RENDER;
        msg.nSurfaceType    = GSURFACE_HDC;
        msg.hdc             = hdc;
        msg.prcGadgetPxl    = prcGadgetPxl;
        msg.prcInvalidPxl   = prcInvalidPxl;

        xwInvokeDirect(pgad, &msg, ifReadOnly);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaint(const DuVisual * pgad, Gdiplus::Graphics * pgpgr, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_PAINT)) {
        Gdiplus::RectF rcGadgetPxl  = Convert(prcGadgetPxl);
        Gdiplus::RectF rcInvalidPxl = Convert(prcInvalidPxl);

        GMSG_PAINTRENDERF msg;
        msg.cbSize          = sizeof(msg);
        msg.nMsg            = GM_PAINT;
        msg.nCmd            = GPAINT_RENDER;
        msg.nSurfaceType    = GSURFACE_GPGRAPHICS;
        msg.pgpgr           = pgpgr;
        msg.prcGadgetPxl    = &rcGadgetPxl;
        msg.prcInvalidPxl   = &rcInvalidPxl;

        xwInvokeDirect(pgad, &msg, ifReadOnly);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFirePaintCache(const DuVisual * pgad, HDC hdcDraw, const RECT * prcGadgetPxl, 
        BYTE * pbAlphaLevel, BYTE * pbAlphaFormat) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_PAINTCACHE msg;
    msg.cbSize          = sizeof(msg);
    msg.nMsg            = GM_PAINTCACHE;
    msg.hdc             = hdcDraw;
    msg.prcGadgetPxl    = prcGadgetPxl;
    msg.bAlphaLevel     = BLEND_OPAQUE;
    msg.bAlphaFormat    = 0;

    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *pbAlphaLevel   = msg.bAlphaLevel;
        *pbAlphaFormat  = msg.bAlphaFormat;
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xrFireQueryHitTest(const DuVisual * pgad, POINT ptClientPxl, UINT * pnResult) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    AssertWritePtr(pnResult);
    *pnResult           = GQHT_INSIDE;      // Default to inside

    GMSG_QUERYHITTEST msg;
    msg.cbSize          = sizeof(msg);
    msg.nMsg            = GM_QUERY;
    msg.nCode           = GQUERY_HITTEST;
    msg.ptClientPxl     = ptClientPxl;
    msg.nResultCode     = *pnResult;
    msg.pvResultData    = NULL;

    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *pnResult = msg.nResultCode;
    }
}


//------------------------------------------------------------------------------
inline BOOL        
GPCB::xrFireQueryPadding(const DuVisual * pgad, RECT * prcPadding) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    AssertWritePtr(prcPadding);
    ZeroMemory(prcPadding, sizeof(RECT));

    GMSG_QUERYPADDING msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize = sizeof(msg);
    msg.nMsg   = GM_QUERY;
    msg.nCode  = GQUERY_PADDING;
    
    if (IsHandled(xwInvokeDirect(pgad, &msg, ifReadOnly))) {
        *prcPadding = msg.rcPadding;
        return TRUE;
    }

    return FALSE;
}


#if DBG_STORE_NAMES

//------------------------------------------------------------------------------
inline BOOL        
GPCB::xrFireQueryName(const DuVisual * pgad, WCHAR ** ppszName, WCHAR ** ppszType) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_QUERYDESC msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize      = sizeof(msg);
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (xwInvokeDirect(pgad, &msg, GPCB::ifReadOnly) == DU_S_COMPLETE) {
        if (ppszName != NULL) {
            *ppszName = _wcsdup(msg.szName);
        }
        if (ppszType != NULL) {
            *ppszType = _wcsdup(msg.szType);
        }
        return TRUE;
    }

    return FALSE;
}

#endif // DBG_STORE_NAMES


//------------------------------------------------------------------------------
inline void
GPCB::xdFireMouseMessage(const DuVisual * pgad, GMSG_MOUSE * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);

    UINT size;

    switch (pmsg->nCode) {
        case GMOUSE_DRAG:   size = sizeof(GMSG_MOUSEDRAG);  break;
        case GMOUSE_WHEEL:  size = sizeof(GMSG_MOUSEWHEEL); break;
        case GMOUSE_DOWN:
        case GMOUSE_UP:     size = sizeof(GMSG_MOUSECLICK); break;
        default:            size = sizeof(GMSG_MOUSE);      break;
    }
    AssertMsg(pmsg->cbSize == size, "Mouse Message has improperly set cbSize");
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE)) {
        pmsg->nMsg      = GM_INPUT;
        pmsg->nDevice   = GINPUT_MOUSE;

        GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireKeyboardMessage(const DuVisual * pgad, GMSG_KEYBOARD * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_INPUTKEYBOARD)) {
        pmsg->cbSize    = sizeof(GMSG_KEYBOARD);
        pmsg->nMsg      = GM_INPUT;
        pmsg->nDevice   = GINPUT_KEYBOARD;

        GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeState(const DuVisual * pgad, UINT nCode, HGADGET hgadLost, HGADGET hgadSet, UINT nCmd) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGESTATE)) {
        GMSG_CHANGESTATE msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGESTATE;
        msg.nCode       = nCode;
        msg.hgadLost    = hgadLost;
        msg.hgadSet     = hgadSet;
        msg.nCmd        = nCmd;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, SGM_FULL);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeRect(const DuVisual * pgad, const RECT * prc, UINT nFlags) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGERECT)) {
        GMSG_CHANGERECT msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGERECT;
        msg.rcNewRect   = *prc;
        msg.nFlags      = nFlags;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireChangeStyle(const DuVisual * pgad, UINT nOldStyle, UINT nNewStyle) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    if (TestFlag(m_nFilter, GMFI_CHANGESTYLE)) {
        GMSG_CHANGESTYLE msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = GM_CHANGESTYLE;
        msg.nOldStyle   = nOldStyle;
        msg.nNewStyle   = nNewStyle;

        GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
    }
}


//------------------------------------------------------------------------------
inline void        
GPCB::xdFireSyncAdaptor(const DuVisual * pgad, UINT nCode) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GMSG_SYNCADAPTOR msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.nCode   = nCode;
    msg.nMsg    = GM_SYNCADAPTOR;

    GetCoreST()->DeferMessage(&msg, (DuEventGadget *) pgad, 0);
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireDelayedMessage(const DuVisual * pgad, GMSG * pmsg, UINT nFlags) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, nFlags);
}


//------------------------------------------------------------------------------
inline void
GPCB::xdFireDelayedMessage(const DuListener * pgad, GMSG * pmsg) const
{
#if DBG
    DEBUG_CheckHandle(pgad);
#endif // DBG

    GetCoreST()->DeferMessage(pmsg, (DuEventGadget *) pgad, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
GPCB::xwCallGadgetProc(HGADGET hgadCur, EventMsg * pmsg) const
{
#if DBG
    AssertMsg(m_hgadCheck == hgadCur, "Gadgets must match");
#endif // DBG

    HRESULT hr;

    //
    // Need to guard around the callback to prevent DirectUser from becoming
    // completely toast if something goes wrong.
    //

#if DBG_CHECK_CALLBACKS
    hr = E_FAIL;
    BEGIN_CALLBACK()
#endif

    __try 
    {
        hr = (m_pfnProc)(hgadCur, m_pvData, pmsg);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

#if DBG_CHECK_CALLBACKS
    END_CALLBACK()
#endif

    return hr;
}


#endif // CORE__Callback_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\callback.h ===
/***************************************************************************\
*
* File: Callback.h
*
* Description:
* Callback.h wraps the standard DirectUser DuVisual callbacks into 
* individual DuVisual implementations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Callback_h__INCLUDED)
#define CORE__Callback_h__INCLUDED
#pragma once

// Forward declarations
class DuEventGadget;
class DuVisual;
class DuListener;
class DuEventPool;

//
// NOTE:
// There are different types of callback functions that are a natural extension
// of 'xxx' functions found in NT-USER:
//
// - xr: Read-only:  Only "read-only" API's are supported during this callback
// - xw: Read/Write: Any API is supported during this callback
// - xd: Delayed:    The callback is queued and will be called before returning
//                   from the API; any API is supported during this callback.
//
// TODO: Need to mark each of these functions with the appropriate signature
//       and propagate through the code.
//


//
// GPCB holds a GadgetProc Calback and is used to communicate with the 
// outside world.
//

class GPCB
{
// Construction
public:
    inline  GPCB();
#if DBG
            void        Create(GADGETPROC pfnProc, void * pvData, HGADGET hgadCheck);
#else // DBG
            void        Create(GADGETPROC pfnProc, void * pvData);
#endif // DBG
            void        Destroy();

// Operations
public:
    inline  UINT        GetFilter() const;
    inline  void        SetFilter(UINT nNewFilter, UINT nMask);

    inline  void        xwFireDestroy(const DuEventGadget * pgad, UINT nCode) const;

    inline  void        xrFirePaint(const DuVisual * pgad, HDC hdc, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const;
    inline  void        xrFirePaint(const DuVisual * pgad, Gdiplus::Graphics * pgpgr, const RECT * prcGadgetPxl, const RECT * prcInvalidPxl) const;
    inline  void        xrFirePaintCache(const DuVisual * pgad, HDC hdcDraw, const RECT * prcGadgetPxl, 
                                BYTE * pbAlphaLevel, BYTE * pbAlphaFormat) const;

    inline  void        xrFireQueryHitTest(const DuVisual * pgad, POINT ptClientPxl, UINT * pnResult) const;
    inline  BOOL        xrFireQueryPadding(const DuVisual * pgad, RECT * prcPadding) const;

#if DBG_STORE_NAMES
    inline  BOOL        xrFireQueryName(const DuVisual * pgad, WCHAR ** ppszName, WCHAR ** ppszType) const;
#endif // DBG_STORE_NAMES

    inline  void        xdFireMouseMessage(const DuVisual * pgad, GMSG_MOUSE * pmsg) const;
    inline  void        xdFireKeyboardMessage(const DuVisual * pgad, GMSG_KEYBOARD * pmsg) const;
    inline  void        xdFireChangeState(const DuVisual * pgad, UINT nCode, HGADGET hgadLost, HGADGET hgadSet, UINT nCmd) const;
    inline  void        xdFireChangeRect(const DuVisual * pgad, const RECT * prc, UINT nFlags) const;
    inline  void        xdFireChangeStyle(const DuVisual * pgad, UINT nOldStyle, UINT nNewStyle) const;
    inline  void        xdFireSyncAdaptor(const DuVisual * pgad, UINT nCode) const;
    inline  void        xdFireDelayedMessage(const DuVisual * pgad, GMSG * pmsg, UINT nFlags) const;
    inline  void        xdFireDelayedMessage(const DuListener * pgad, GMSG * pmsg) const;

            enum InvokeFlags {
                ifSendAll       = 0x00000001,   // Message must be sent to all Gadgets
                ifReadOnly      = 0x00000002,   // Read-only callback
            };
            
            HRESULT     xwInvokeDirect(const DuEventGadget * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
			HRESULT     xwInvokeFull(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;

    inline  HRESULT     xwCallGadgetProc(HGADGET hgadCur, EventMsg * pmsg) const;

// Implementation
protected:

    inline  HRESULT     xwInvokeDirect(const DuListener * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
    inline  HRESULT     xwInvokeDirect(const DuVisual * pgadMsg, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
            HRESULT     xwInvokeRoute(DuVisual * const * rgpgadCur, int cItems, EventMsg * pmsg, UINT nInvokeFlags = 0) const;
            HRESULT     xwInvokeBubble(DuVisual * const * rgpgadCur, int cItems, EventMsg * pmsg, UINT nInvokeFlags = 0) const;

    static  HRESULT     xwCallOnEvent(const DuEventGadget * pg, EventMsg * pmsg);

#if DBG
            void        DEBUG_CheckHandle(const DuEventGadget * pgad, BOOL fDestructionMsg = FALSE) const;
            void        DEBUG_CheckHandle(const DuVisual * pgad, BOOL fDestructionMsg = FALSE) const;
            void        DEBUG_CheckHandle(const DuListener * pgad) const;
#endif // DBG

// Data
protected:
            GADGETPROC  m_pfnProc;
            void *      m_pvData;
            UINT        m_nFilter;

#if DBG
            HGADGET     m_hgadCheck;    // DEBUGONLY: Check gadget
#endif // DBG
};

#include "Callback.inl"

#endif // CORE__Callback_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\container.cpp ===
/***************************************************************************\
*
* File: Container.cpp
*
* Description:
* Container.cpp implements the basic Gadget container used to host a 
* Gadget-Tree.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Container.h"

#include "RootGadget.h"

/***************************************************************************\
*****************************************************************************
*
* class DuContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuContainer::DuContainer()
{

}


//------------------------------------------------------------------------------
DuContainer::~DuContainer()
{

}


//------------------------------------------------------------------------------
DuRootGadget *    
DuContainer::GetRoot() const
{
    return m_pgadRoot;
}


//------------------------------------------------------------------------------
void    
DuContainer::xwDestroyGadget()
{
    if (m_pgadRoot != NULL) {
        m_pgadRoot->xwDeleteHandle();
    }
}


//------------------------------------------------------------------------------
void    
DuContainer::AttachGadget(DuRootGadget * playNew)
{
    Assert(playNew != NULL);
    DetachGadget();
    m_pgadRoot = playNew;
}


//------------------------------------------------------------------------------
void    
DuContainer::DetachGadget()
{
    m_pgadRoot = NULL;
}


//------------------------------------------------------------------------------
void
DuContainer::SetManualDraw(BOOL fManualDraw)
{
    m_fManualDraw = fManualDraw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\container.h ===
/***************************************************************************\
*
* File: Container.h
*
* Description:
* Container.h defines the basic Gadget DuContainer used to host a 
* Gadget-Tree.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuContainer_h__INCLUDED)
#define CORE__DuContainer_h__INCLUDED
#pragma once

class DuVisual;
class DuRootGadget;

//------------------------------------------------------------------------------
class DuContainer : public BaseObject
{
// Construction
public:
            DuContainer();
    virtual ~DuContainer();

// Operations
public:
            DuRootGadget * GetRoot() const;

            void        xwDestroyGadget();

            void        AttachGadget(DuRootGadget * playNew);
            void        DetachGadget();

// BaseObject
public:
    virtual UINT        GetHandleMask() const { return hmContainer; }

// DuContainer Interface
public:
    // Functions called from Root
    virtual void        OnGetRect(RECT * prcDesktopPxl) PURE;
    virtual void        OnInvalidate(const RECT * prcInvalidDuContainerPxl) PURE;
    virtual void        OnStartCapture() PURE;
    virtual void        OnEndCapture() PURE;
    virtual BOOL        OnTrackMouseLeave() PURE;
    virtual void        OnSetFocus() PURE;
    virtual void        OnRescanMouse(POINT * pptDuContainerPxl) PURE;

            void        SetManualDraw(BOOL fManualDraw);

    // Functions called from Outside
    enum EMsgFlags
    {
        mfForward       = 0x00000001,   // Message is being forwarded
    };
    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags) PURE;

// Data
protected:
            DuRootGadget *
                        m_pgadRoot;
            BOOL        m_fManualDraw;
};

class DuContainer;

//------------------------------------------------------------------------------
inline DuContainer * CastContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && TestFlag(pBase->GetHandleMask(), hmContainer)) {
        return (DuContainer *) pBase;
    }
    return NULL;
}


#endif // CORE__DuContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\context.cpp ===
/***************************************************************************\
*
* File: Context.cpp
*
* Description:
* This file implements the SubContext used by the DirectUser/Core project to
* maintain Context-specific data.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Context.h"

#include "ParkContainer.h"

#if ENABLE_MPH

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL CALLBACK 
MphProcessMessage(
    OUT MSG * pmsg,
    IN  HWND hwnd,
    IN  UINT wMsgFilterMin, 
    IN  UINT wMsgFilterMax,
    IN  UINT flags,
    IN  BOOL fGetMessage)
{
#if DBG_CHECK_CALLBACKS
    if (!IsInitThread()) {
        AlwaysPromptInvalid("DirectUser has been uninitialized before calling into MPH");
    }
#endif
    
    CoreSC * pSC = GetCoreSC();
    return pSC->xwProcessNL(pmsg, hwnd,
            wMsgFilterMin, wMsgFilterMax, flags, fGetMessage ? CoreSC::smGetMsg : 0);
}


//------------------------------------------------------------------------------
BOOL CALLBACK 
MphWaitMessageEx(
    IN  UINT fsWakeMask,
    IN  DWORD dwTimeOut)
{
#if DBG_CHECK_CALLBACKS
    if (!IsInitThread()) {
        AlwaysPromptInvalid("DirectUser has been uninitialized before calling into MPH");
    }
#endif

    
    //
    // Need to convert time-out value from WaitMessageEx() where 0 means
    // infinite delay to WaitForSingleObject() where 0 means no delay.  We do 
    // this here because this behavior is introduced by DirectUser since it uses
    // MsgWaitForMultipleObjects() to implement the MPH'd WaitMessageEx().
    //
        
    CoreSC * pSC = GetCoreSC();
    pSC->WaitMessage(fsWakeMask, dwTimeOut != 0 ? dwTimeOut : INFINITE);
    return TRUE;
}

#endif // ENABLE_MPH


/***************************************************************************\
*****************************************************************************
*
* class CoreSC
*
*****************************************************************************
\***************************************************************************/

IMPLEMENT_SUBCONTEXT(Context::slCore, CoreSC);

struct CoreData
{
    DuParkContainer conPark;
};

/***************************************************************************\
*
* CoreSC::~CoreSC
*
* ~CoreSC() cleans up resources associated with this SubContext.
*
\***************************************************************************/

CoreSC::~CoreSC()
{
#if DBG_CHECK_CALLBACKS
    if (m_fProcessing) {
        PromptInvalid("Cannot DeleteHandle(Context) while processing a DUser message");
    }
#endif
    
    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    AssertMsg(m_msgqSend.IsEmpty(), "All queues should be empty");
    AssertMsg(m_msgqPost.IsEmpty(), "All queues should be empty");

    if (m_hevQData != NULL) {
        CloseHandle(m_hevQData);
    }

    if (m_hevSendDone != NULL) {
        CloseHandle(m_hevSendDone);
    }

    ClientDelete(VisualPool, ppoolDuVisualCache);
}


/***************************************************************************\
*
* CoreSC::Create
*
* Create() is called by the ResourceManager to initialize this new SubContext
* when a new Context is being created.
*
\***************************************************************************/

HRESULT
CoreSC::Create(INITGADGET * pInit)
{
    HRESULT hr;

    //
    // Initialize the messaging subsystem for this CoreSC
    //

    switch (pInit->nMsgMode)
    {
    case IGMM_COMPATIBLE:
        //
        // Need to use timers and hooks to get into the messaging subsystem.
        //

        AssertMsg(0, "TODO: Implement IGMM_COMPATIBLE");
        return E_NOTIMPL;

#if ENABLE_MPH
    case IGMM_STANDARD:
#endif
    case IGMM_ADVANCED:
        break;

    default:
        AssertMsg(0, "Unsupported messaging subsystem mode");
        return E_INVALIDARG;
    }

    m_nMsgMode = pInit->nMsgMode;
    m_hevQData = CreateEvent(NULL, FALSE /* Automatic */, FALSE, NULL);
    if (m_hevQData == NULL) {
        return DU_E_OUTOFKERNELRESOURCES;
    }


    //
    // Determine the event to be signaled when the message has been 
    // processed.  Each thread has its own SendDone event since multiple 
    // threads in the same CoreSC may all send messages and would need to
    // notified independently that each of their messages has been 
    // processed.
    //
    // This event is cached so that it only needs to be created once per 
    // thread.  It is independent of the CoreSC so it doesn't get destroyed
    // when the CoreSC does.
    //
    // The event is an AUTOMATIC event so that that it will automatically 
    // reset after being signaled.  Since the event is only created one, 
    // this function ASSUMES that the event is left in an reset state.  This
    // is normally true since the function blocks on WaitForSingleObject().
    // If there are any other exit paths, they need to ensure that the event
    // is left in a reset state.
    //

    m_hevSendDone = CreateEvent(NULL, FALSE /* Automatic */, FALSE, NULL);
    if (m_hevSendDone == NULL) {
        return DU_E_OUTOFKERNELRESOURCES;
    }


    //
    // Initialize "global" CoreSC-specific data.  It is important to allocate 
    // these on the Process heap because the Context may be destroyed on a 
    // different thread during destruction.
    //

    m_pData = ProcessNew(CoreData);
    if (m_pData == NULL) {
        return E_OUTOFMEMORY;
    }

    ppoolDuVisualCache = ClientNew(VisualPool);
    if (ppoolDuVisualCache == NULL) {
        return E_OUTOFMEMORY;
    }

    pconPark = &m_pData->conPark;
    hr = m_pData->conPark.Create();
    if (FAILED(hr)) {
        return hr;
    }
    
    return S_OK;
}


/***************************************************************************\
*
* CoreSC::xwPreDestroyNL
*
* xwPreDestroyNL() gives this SubContext an opportunity to perform any cleanup 
* while the Context is still valid.  Any operations that involve callbacks
* MUST be done at this time.
*
\***************************************************************************/

void        
CoreSC::xwPreDestroyNL()
{
    //
    // There may be remaining messages in the queues, so we need to empty them
    // now.  This can happen if the more messages are generated after the
    // message pump was last processed.
    //

    do
    {
        //
        // When we callback to allow the SubContext's to destroy, we need to
        // grab a ContextLock so that we can defer messages.  When we leave 
        // this scope, all of these messages will be triggered.  This needs
        // to occur BEFORE the Context continues getting blown away.
        //

        {
            ContextLock cl;
            if (!cl.LockNL(ContextLock::edDefer, m_pParent)) {
                //
                // If the Context becomes orphaned, we need to exit this loop
                // since DllMain(DLL_PROCESS_DETACH) has been called and 
                // DirectUser has been unloaded.
                //
                
                break;
            }


            //
            // Pre-destroying the Parking Gadget may have generated messages, so
            // we want to handle these now.  If we don't objects may continue to 
            // live until the Context is fully destroyed.
            //

            InterlockedExchange((long *) &m_fQData, FALSE);
            AssertMsg(!m_fProcessing, "Another thread must NOT be processing during shutdown");
            xwProcessMsgQNL();


            //
            // Notify the Parking Gadget that the Context is getting wiped.  It 
            // needs to destroy any remaining Gadgets before the Context gets 
            // shutdown so that the Gadgets can use a still valid Context during 
            // their destruction.
            //

            if (pconPark != NULL) {
                pconPark->xwPreDestroy();
            }
        }

        //
        // The ContextLock is now destroyed, causing any delayed messages to
        // be fired.
        //
    } while (m_fQData);

    AssertMsg((pconPark == NULL) || (!pconPark->GetRoot()->HasChildren()), 
            "Parking Gadget should now be empty");
    AssertMsg(m_msgqSend.IsEmpty() && m_msgqPost.IsEmpty(),
            "Queues must now be empty");

#if DBG
    m_msgqSend.DEBUG_MarkStartDestroy();
    m_msgqPost.DEBUG_MarkStartDestroy();
#endif // DBG


    //
    // Everyone has had a chance to be destroyed, so destroy the dynamic data.
    //

    if (m_pData != NULL) {
        ProcessDelete(CoreData, m_pData);
    }
}


/***************************************************************************\
*
* CoreSC::CanProcessUserMsg
*
* CanProcessUserMsg() determines if DirectUser can "hook into" the 
* processing of the USER message and provide extra functionality.
*
\***************************************************************************/

UINT
CoreSC::CanProcessUserMsg(HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
{
    //
    // Considerations:
    //
    // We can only process differ from NTUSER's xxxInternalGetMessage() if the
    // application specifies PM_REMOVE.  If they specify PM_NOREMOVE, they are
    // just looking at the message and it can be very dangerous to process any
    // DirectUser messages at that time.
    //
    // We can also only process messages if there are no filters applied.  If
    // any filters are applied, we may massively change the DirectUser object 
    // state in the application by delivering messages at this time.
    //
    // The same is true for idle-time processing.
    //
    //
    // Requirements:
    // - mvpIdle:   No filter
    // - mvpDUser:  No filter, PM_REMOVE
    //
    
    UINT nValid = 0;

    if ((hWnd == NULL) && (wMsgFilterMin == 0) && (wMsgFilterMax == 0)) {
        SetFlag(nValid, mvpIdle);

        if (TestFlag(wRemoveMsg, PM_REMOVE)) {
            SetFlag(nValid, mvpDUser);
        }
    }

    return nValid;            
}


/***************************************************************************\
*
* CoreSC::WaitMessage
*
* WaitMessage() blocks a thread until a new DirectUser or USER message 
* becomes available.
*
\***************************************************************************/

void
CoreSC::WaitMessage(
    IN  UINT fsWakeMask,                // USER queue wake mask
    IN  DWORD dwTimeOutMax)             // Maximum timeout in millisec's or INFINITE
{
    DWORD dwStartTick, dwRemainTick;

    dwRemainTick = dwTimeOutMax;
    dwStartTick = 0;
    if (dwRemainTick != INFINITE) {
        dwStartTick = GetTickCount();
    }

    while (TRUE) {
        //
        // Check for existing DirectUser messages.
        //

        if (m_fQData) {
            return;
        }


        //
        // We DON'T check for existing USER messages, since the ::WaitMessage()
        // API function will only return when NEW USER messages have been added
        // to the queue.
        //
        // This also means that we will NOT use MWMO_INPUTAVAILABLE when we call
        // Wait().
        //


        //
        // No available messages, so perform idle-time processing and then 
        // wait for the next available message.  We need to perform idle-time
        // processing here, since an application may just call PeekMessage()
        // and WaitMessage(), and would otherwise never perform idle-time
        // processing.
        //

        DWORD dwNewTickOut = m_pParent->xwOnIdleNL();
        if (dwNewTickOut > dwRemainTick) {
            dwNewTickOut = dwRemainTick;
        }

        switch (Wait(fsWakeMask, dwNewTickOut, FALSE, TRUE /* process DUser messages */))
        {
        case wGMsgReady:
        case wUserMsgReady:
            return;

        case wTimeOut:
            //
            // There were no messages to process, so loop again.
            //

            break;

        case wError:
            // Got an unexpected return value, so just continue to wait
            AssertMsg(0, "Unexpected return from CoreSC::Wait()");
            return;
        }


        //
        // Compute how much time is left in the wait period.
        //

        if (dwRemainTick != INFINITE) {
            DWORD dwCurTick = GetTickCount();
            DWORD dwElapsed = dwCurTick - dwStartTick;
            if (dwElapsed < dwRemainTick) {
                dwRemainTick -= dwElapsed;
            } else {
                dwRemainTick = 0;
            }
        }
    }
}


/***************************************************************************\
*
* CoreSC::Wait
*
* Wait() blocks the current thread until new information has been added to
* either the USER queue or a DirectUser queue.  Because 
* WaitForMultipleObjects takes a non-trivial amount of time to potentially
* setup, even if one of the HANDLE's is signaled, we want to avoid calling
* this function while we have any more work to do.
*
\***************************************************************************/

CoreSC::EWait
CoreSC::Wait(
    IN  UINT fsWakeMask,                // USER queue wake mask
    IN  DWORD dwTimeOut,                // Timeout in millisec's or INFINITE
    IN  BOOL fAllowInputAvailable,      // Win2000,98: Use MWMO_INPUTAVAILABLE
    IN  BOOL fProcessDUser)             // Allow processing DUser events
{
    HANDLE  rgh[1];
    int cObj = 0;
    int result;
    DWORD dwFlags;

    //
    // No events were already ready, so need to wait.  This may take a while.
    // If we are running on Win98 or Win2000, specify the MWMO_INPUTAVAILABLE
    // flag to signal that we didn't (necessarily) process all of the User
    // messages.
    //
    // Win2000 USER is pretty smart.  If it sees that any messages are 
    // available, it won't call WaitForMultipleObjects and will instead directly
    // return.  
    //
    // The advantage of using MWMO_INPUTAVAILABLE if it is available is that
    // we don't need to call an extra PeekMessage() when processing a queue of
    // messages.
    //

    if (fProcessDUser) {
        rgh[0] = m_hevQData;
        cObj++;
    }
    dwFlags = 0;                    // Only wait for a single handle
    if (fAllowInputAvailable) {
        dwFlags |= MWMO_INPUTAVAILABLE;
    }


    //
    // If we are waiting up to 1 ms, don't really wait.  It is not worth the
    // cost of going to sleep.
    //

    if (dwTimeOut <= 1) {
        dwTimeOut = 0;
    }

    AssertMsg(cObj <= _countof(rgh), "Ensure don't overflow handle array");
    result = MsgWaitForMultipleObjectsEx(cObj, rgh, dwTimeOut, fsWakeMask, dwFlags);

    if (result == WAIT_OBJECT_0 + cObj) {
        return wUserMsgReady;
    } else if (result == WAIT_OBJECT_0) {
        return wGMsgReady;
    } else if ((result >= WAIT_ABANDONED_0) && (result < WAIT_ABANDONED_0 + cObj)) {
        return wOther;
    } else if (result == WAIT_TIMEOUT) {
        return wTimeOut;
    }
    
    return wError;
}


/***************************************************************************\
*
* CoreSC::xwProcessNL
*
* xwProcessNL() processes all messages in the queues, optionally blocking
* until a USER message becomes available to be processed.  
*
* This function is provides the replacement for GetMessage() and 
* PeekMessage().
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

BOOL
CoreSC::xwProcessNL(
    IN  LPMSG lpMsg,                    // Message information
    IN  HWND hWnd,                      // Filter window
    IN  UINT wMsgFilterMin,             // Filter first message
    IN  UINT wMsgFilterMax,             // Filter last message
    IN  UINT wRemoveMsg,                // Remove message (Peek only)
    IN  UINT nMsgFlag)                  // Messaging flags
{
    AssertMsg((TestFlag(nMsgFlag, smGetMsg) && (wRemoveMsg == PM_REMOVE)) ||
            (!TestFlag(nMsgFlag, smGetMsg)), "If GetMsg, must specify PM_REMOVE");


    UINT nProcessValid = CanProcessUserMsg(hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);


    //
    // We may need to directly jump to PeekMessage() instead of Wait()'ing
    // in a couple of situations:
    // - If we are running on a system that doesn't support MWMO_INPUTAVAILABLE
    // - If we are calling the !smGetMsg version (PeekMessageEx)
    //

    BOOL fInputAvailable = SupportQInputAvailable();
    BOOL fJumpPeek = (!fInputAvailable) || (!TestFlag(nMsgFlag, smGetMsg));
    DWORD dwTimeOut;

    while (TRUE) {
#if DBG_CHECK_CALLBACKS
        if (!IsInitThread()) {
            AlwaysPromptInvalid("DirectUser has been uninitialized between messages");
        }
#endif
        
        dwTimeOut = INFINITE;

        //
        // When coming to wait on an event, first check if there are any events 
        // already ready.  If so, just jump and process them directly so that we
        // don't even need to wait.
        //
        // Check for DUser messages before we check for USER messages because
        // we want to process them faster and checking for USER messages is
        // a large (unnecessary) speed-bump.
        //

        if (TestFlag(nProcessValid, mvpDUser) && InterlockedExchange((long *) &m_fQData, FALSE)) {
            goto ProcessMsgs;
        }

        //
        // If running on a system that doesn't support MWMO_INPUTAVAILABLE, we need
        // to finish eating the USER messages since MsgWaitForMultipleObjectsEx().
        // is expecting that behavior.
        //

        if (fJumpPeek) {
            goto ProcessPeekMessage;
        }


        //
        // Before waiting, but after performing any normal priority requests,
        // do any idle-time processing.
        //

        if (TestFlag(nProcessValid, mvpIdle)) {
            dwTimeOut = m_pParent->xwOnIdleNL();
        }


        //
        // We have had an opportunity to process all of the messages and are now
        // about to wait.  If we are not calling smGetMsg, just return 
        // immediately.
        //
      
        if (!TestFlag(nMsgFlag, smGetMsg)) {
            return FALSE;               // No messages are available
        }


        //
        // When processing GetMessage() / PeekMessage() like functionality, 
        // we want QS_ALLINPUT as the queue wake flags, as this provides similar
        // functionality.
        //

        switch (Wait(QS_ALLINPUT, dwTimeOut, fInputAvailable, TestFlag(nProcessValid, mvpDUser))) 
        {
        case wGMsgReady:
ProcessMsgs:
            AssertMsg(TestFlag(nProcessValid, mvpDUser),
                    "Only should be signaled if allowed to process DUser messages");
            xwProcessMsgQNL();
            break;

        case wUserMsgReady:
            {
ProcessPeekMessage:
                //
                // Got signaled to get a message from the USER queue.  This can 
                // return FALSE if the QS_EVENT was in the wait mask because USER
                // needed to be called back.
                //

                fJumpPeek = FALSE;

                BOOL fResult;
#if ENABLE_MPH
                if (m_nMsgMode == IGMM_STANDARD) {
                    //
                    // When in Standard messaging mode, we need to call back to 
                    // the "real" xxxInternalGetMessage() in NTUSER to process
                    // the message.  If we call PeekMessage(), we will enter a
                    // loop.
                    //
                    // Only do this if this thread is initialized as Standard.
                    // If the thread is setup with a different messaging model,
                    // the call to PeekMessage() will not loop, and is required
                    // to properly setup state.
                    //

                    AssertMsg(g_mphReal.pfnInternalGetMessage != NULL, "Must have valid callback");
                    fResult = (g_mphReal.pfnInternalGetMessage)(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, FALSE);
                } else {
#endif
                    if (TestFlag(nMsgFlag, smAnsi)) {
                        fResult = PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
                    } else {
                        fResult = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
                    }
#if ENABLE_MPH
                }
#endif

#if DBG_CHECK_CALLBACKS
                if (!IsInitThread()) {
                    AlwaysPromptInvalid("DirectUser has been uninitialized during PeekMessage()");
                }
#endif

                if (fResult) {
                    if ((lpMsg->message == WM_QUIT) && TestFlag(nMsgFlag, smGetMsg)) {
                        //
                        // GetMessage behavior is to return FALSE when seeing a 
                        // WM_QUIT message.
                        //

                        fResult = FALSE;
                    }
                    return fResult;
                }
            }
            break;

        case wTimeOut:
            //
            // There were no messages to process, so can do any 
            // idle-time processing here.
            //

            AssertMsg(TestFlag(nProcessValid, mvpIdle), 
                    "Only should be signaled if allowed to perform idle-time processing");
            dwTimeOut = m_pParent->xwOnIdleNL();
            break;

        case wError:
            // Got an unexpected return value, so just continue to wait
            AssertMsg(0, "Unexpected return from CoreSC::Wait()");
            return TRUE;
        }
    }
}


/***************************************************************************\
*
* CoreSC::xwProcessMsgQNL
*
* xwProcessMsgQNL() 
*
\***************************************************************************/

void
CoreSC::xwProcessMsgQNL()
{
    //
    // Only one thread can process messages that need to be 
    // synchronized.  This is because the application is expecting
    // these messages in a certain order (for example, key up after 
    // key down).  To ensure this, mark when a thread starts 
    // processing.
    //

    if (InterlockedCompareExchange((long *) &m_fProcessing, TRUE, FALSE) == FALSE) {
        //
        // A message is available in the CoreSC's queues.  To process the 
        // messages, extract the list inside the lock and then process the
        // messages outside the lock.  This allows more messages to be 
        // queued while the messages are being processed.
        //

        m_msgqSend.xwProcessNL();
        m_msgqPost.xwProcessNL();

        InterlockedExchange((long *) &m_fProcessing, FALSE);
    }
}


//------------------------------------------------------------------------------
HRESULT
CoreSC::xwFireMessagesNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  FGM_INFO * rgFGM,           // Collection of messsages to fire
    IN  int cMsgs,                  // Number of messages
    IN  UINT idQueue)               // Queue to send messages
{
    HRESULT hr = S_OK;
    BOOL fSend;
    SafeMsgQ * pmsgq;


    //
    // Determine which queue the messages are being pumped into
    //

    switch (idQueue)
    {
    case FGMQ_SEND:
        pmsgq = &psctxDest->m_msgqSend;
        fSend = TRUE;
        break;

    case FGMQ_POST:
        pmsgq = &psctxDest->m_msgqPost;
        fSend = FALSE;
        break;

    default:
        PromptInvalid("Unknown queue");
        return E_INVALIDARG;
    }

    if (!IsInitThread()) {
        PromptInvalid("Thread must be initialized with InitGadgets() to call this function()\n");
        return DU_E_NOCONTEXT;
    }

    Thread * pthrSend   = GetThread();

    int cPost = cMsgs;
    if (fSend) {
        if (this == psctxDest) {
            //
            // Sending into the same Context, so can just call directly.
            //

            for (int idx = 0; idx < cMsgs; idx++) {
                FGM_INFO & fgm          = rgFGM[idx];
                EventMsg * pmsg         = fgm.pmsg;
                DuEventGadget *pgadMsg   = (DuEventGadget *) fgm.pvReserved;
                const GPCB & cb         = pgadMsg->GetCallback();
                if (TestFlag(fgm.nFlags, SGM_FULL) && TestFlag(pgadMsg->GetHandleMask(), hmVisual)) {
                    fgm.hr = cb.xwInvokeFull((const DuVisual *) pgadMsg, pmsg, 0);
                } else {
                    fgm.hr = cb.xwInvokeDirect(pgadMsg, pmsg, 0);
                }
            }
            hr = S_OK;
        } else {
            //
            // Sending into a different Context, so need to use the queues.
            //


            //
            // Post messsages the initial messages, up until the last message.
            // We don't need to block waiting for each to return as we can prepare
            // the next message.
            //

            cPost--;
            for (int idx = 0; idx < cPost; idx++) {
                FGM_INFO & fgm          = rgFGM[idx];
                EventMsg * pmsg         = fgm.pmsg;
                DuEventGadget * pgadMsg  = (DuEventGadget *) fgm.pvReserved;
                UINT nFlags             = fgm.nFlags;

                hr = pmsgq->PostNL(pthrSend, pmsg, pgadMsg, GetProcessProc(pgadMsg, nFlags), nFlags);
                if (FAILED(hr)) {
                    goto ErrorExit;
                }
            }


            //
            // All of the previous messages have been posted, so we now need to send
            // the last message and wait for all of the results.
            //

            FGM_INFO & fgm = rgFGM[idx];
            EventMsg * pmsg = fgm.pmsg;
            DuEventGadget * pgadMsg = (DuEventGadget *) fgm.pvReserved;
            UINT nFlags = fgm.nFlags;

            fgm.hr = xwSendNL(psctxDest, pmsgq, pmsg, pgadMsg, nFlags);

            
            //
            // All of the messages have been processed, so copy the results from
            // the posted-messages GadgetProc's back.
            //

            // TODO: Copy the results back.  This is a little complicated since
            // they are stored in the MsgEntry and that is now already recycled.
            // Need to determine how to get these back or change 
            // FireMessagesNL() to not return these.
        }
    } else {
        //
        // Post all of the messsages.
        //

        for (int idx = 0; idx < cPost; idx++) {
            const FGM_INFO & fgm = rgFGM[idx];
            EventMsg * pmsg = fgm.pmsg;
            DuEventGadget * pgadMsg = (DuEventGadget *) fgm.pvReserved;
            UINT nFlags = fgm.nFlags;

            hr = pmsgq->PostNL(pthrSend, pmsg, pgadMsg, GetProcessProc(pgadMsg, nFlags), nFlags);
            if (FAILED(hr)) {
                goto ErrorExit;
            }
        }
    }

ErrorExit:
    return hr;
}


/***************************************************************************\
*
* CoreSC::xwSendNL
*
* xwSendNL sends a new message to the given Gadget.  If the Gadget is
* in the current Context, the message is immediately sent.  If the Gadget is
* on a different Context, the message is queued on that Context and this 
* thread is blocked until the message is processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the sending Gadget's CoreSC 
* and not the destination CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
CoreSC::xwSendNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  SafeMsgQ * pmsgq,           // Destination queue
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  UINT nFlags)                // Message flags
{
    ProcessMsgProc pfnProcess;
    HRESULT hr = DU_E_MESSAGEFAILED;
    int cbMsgSize;

    if (TestFlag(pmo->GetHandleMask(), hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        Context * pctxGad = pgad->GetContext();

        AssertMsg(pctxGad == psctxDest->m_pParent, "Must be called on the receiving Context");
        if (pctxGad == m_pParent) {
            AssertMsg(0, "Should never call CoreSC::xwSendNL() inside DirectUser for same context messages");
            return S_OK;
        }

        pfnProcess = GetProcessProc(pgad, nFlags);
    } else {
        pfnProcess = xwProcessMethod;
    }


    //
    // Destination Gadget is in a different CoreSC that the current 
    // CoreSC, so need to add the message to the SendMessage queue and wait
    // for a response.
    //

    //
    // Setup the MsgEntry.
    //

    MsgEntry * pEntry;
    BOOL fAlloc;
    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    if (pmsg->cbSize <= 256) {
        //
        // The message is pretty small, so just allocate memory on the stack.
        //

        pEntry      = (MsgEntry *) STACK_ALIGN8_ALLOC(cbAlloc);
        AssertMsg(pEntry != NULL, "Failed to allocate on stack- very bad");
        fAlloc      = FALSE;
    } else {
        //
        // The message is rather large, so allocate on the destination 
        // CoreSC's heap to be safe.  However, DON'T mark the entry as
        // SGM_ALLOC or the Entry will be deleted before we can get the
        // result from the message.
        //

        pEntry      = (MsgEntry *) ContextAlloc(m_pParent->GetHeap(), cbAlloc);
        if (pEntry == NULL) {
            hr      = E_OUTOFMEMORY;
            goto CleanUp;
        }
        fAlloc      = TRUE;
    }

    cbMsgSize = pmsg->cbSize;
    CopyMemory(pEntry->GetMsg(), pmsg, cbMsgSize);
    pEntry->pthrSender  = NULL;
    pEntry->pmo         = pmo;
    pEntry->pfnProcess  = pfnProcess;
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = m_hevSendDone;
    pEntry->nResult     = 0;

    pmsgq->AddNL(pEntry);
    psctxDest->MarkDataNL();

    //
    // We have added the event now and can not return until the event has 
    // been signaled or else the event may not be reset when we re-enter.
    //

    // TODO: Need to add another event that can be signaled if this thread
    // gets called back to process a message while waiting.  This allows two
    // threads to send messages back and forth.

    VerifyMsg(WaitForSingleObject(m_hevSendDone, INFINITE) == WAIT_OBJECT_0, 
            "WaitForSingleObject failed on event");

    CopyMemory(pmsg, pEntry->GetMsg(), cbMsgSize);
    hr = pEntry->nResult;

    if (fAlloc) {
        ContextFree(m_pParent->GetHeap(), pEntry);
    }

CleanUp:
    return hr;
}


/***************************************************************************\
*
* CoreSC::PostNL
*
* PostNL adds a new message to the Context of the given Gadget.  This
* function does not block waiting for the message to be processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the destination Gadget's CoreSC 
* and not the current CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
CoreSC::PostNL(
    IN  CoreSC * psctxDest,         // Destination Context
    IN  SafeMsgQ * pmsgq,           // Destination queue
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  UINT nFlags)                // Message flags
{
    ProcessMsgProc pfnProcess;
    Thread * pthrSend = NULL;

    if (!TestFlag(nFlags, SGM_RECEIVECONTEXT) && IsInitThread()) {
        pthrSend = GetThread();
    }

    if (TestFlag(pmo->GetHandleMask(), hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        pfnProcess = GetProcessProc(pgad, nFlags);
    } else {
        pfnProcess = xwProcessMethod;
    }


    HRESULT hr = pmsgq->PostNL(pthrSend, pmsg, pmo, pfnProcess, nFlags);
    if (SUCCEEDED(hr)) {
        psctxDest->MarkDataNL();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\context.h ===
/***************************************************************************\
*
* File: Context.h
*
* Description:
* This file declares the SubContext used by the DirectUser/Core project to
* maintain Context-specific data.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__CoreSC_h__INCLUDED)
#define CORE__CoreSC_h__INCLUDED
#pragma once

#include "MsgQ.h"

struct CoreData;
class CoreSC;

class DuParkContainer;
class DuRootGadget;
class DuVisual;


typedef struct tagPressTrack
{
    BYTE        bButton;        // pressed button
    LONG        lTime;          // time of button press
    POINT       ptLoc;          // location of button press
    DuVisual *
                pgadClick;      // Gadget clicked in
} PressTrack;

#define POOLSIZE_Visual 512


/***************************************************************************\
*****************************************************************************
*
* CoreSC contains Context-specific information used by the Core project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Context object.
*
*****************************************************************************
\***************************************************************************/

#pragma warning(disable:4324)  // structure was padded due to __declspec(align())

class CoreSC : public SubContext
{
// Construction
public:
            ~CoreSC();
            HRESULT     Create(INITGADGET * pInit);
    virtual void        xwPreDestroyNL();


// Operations
public:
    enum EMsgFlag
    {
        smAnsi          = 0x00000001,   // ANSI version of function
        smGetMsg        = 0x00000002,   // GetMessage behavior
    };

    enum EWait
    {
        wError          = -1,           // An error occurred
        wOther          = 0,            // Unexpected return from Wait() (mutex, etc)
        wGMsgReady,                     // DUser message is ready
        wUserMsgReady,                  // Win32 USER message is ready
        wTimeOut,                       // The specified timeout occurred
    };

    enum EMessageValidProcess
    {
        mvpDUser        = 0x00000001,   // Valid to process DUser messages
        mvpIdle         = 0x00000002,   // Valid to perform Idle-time processing
    };

            BOOL        xwProcessNL(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, UINT nMsgFlag);
            void        WaitMessage(UINT fsWakeMask = QS_ALLINPUT, DWORD dwTimeOutMax = INFINITE);

    inline  HRESULT     xwSendMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo);
    inline  HRESULT     xwSendEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
    inline  HRESULT     PostMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo);
    inline  HRESULT     PostEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
            HRESULT     xwFireMessagesNL(CoreSC * psctxDest, FGM_INFO * rgFGM, int cMsgs, UINT idQueue);
    static  UINT        CanProcessUserMsg(HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);

    inline  UINT        GetMsgMode() const { return m_nMsgMode; }


// CoreSC Data
public:
    // Tree management
            DuParkContainer *     
                        pconPark;       // Container for parked Gadgets

            class VisualPool : public AllocPoolNL<DuVisual, POOLSIZE_Visual>
            {
            };
            VisualPool * ppoolDuVisualCache;
                        

    // DuRootGadget management
            // Mouse position (enter / leave)
            DuRootGadget*
                        pgadRootMouseFocus;     // Root Gadget containing the mouse last
            DuVisual*   pgadMouseFocus;         // Actual Gadget containing the mouse last
            PressTrack  pressLast;              // last button press
            PressTrack  pressNextToLast;        // next to last button press
            UINT        cClicks;                // the number of times the button has been clicked in *quick* succession

            // Keyboard
            DuVisual*   pgadCurKeyboardFocus;   // Gadget with keyboard focus
            DuVisual*   pgadLastKeyboardFocus;  // Gadget previously with keyboard focus

            DuVisual*   pgadDrag;       // Gadget owning current drag
            POINT       ptDragPxl;      // Location that drag started
            BYTE        bDragButton;    // Button drag started with

            // Adaptors
            UINT        m_cAdaptors;    // Total number of adaptors in this Context

// Implementation
protected:
    inline  void        MarkDataNL();
            EWait       Wait(UINT fsWakeMask, DWORD dwTimeOut, BOOL fAllowInputAvailable, BOOL fProcessDUser);

            void        xwProcessMsgQNL();

            HRESULT     xwSendNL(CoreSC * psctxDest, SafeMsgQ * pmsgq, GMSG * pmsg, MsgObject * pmo, UINT nFlags);
            HRESULT     PostNL(CoreSC * psctxDest, SafeMsgQ * pmsgq, GMSG * pmsg, MsgObject * pmo, UINT nFlags);

// Data
protected:
            CoreData *  m_pData;        // CoreSC data

    volatile long       m_fQData;       // Data has been queued (NOT A BITFLAG)
    volatile long       m_fProcessing;  // Currently processing synchronized queues

            HANDLE      m_hevQData;     // Data has been queued
            HANDLE      m_hevSendDone;  // Sent data has been processed
            SafeMsgQ    m_msgqSend;     // Sent messages
            SafeMsgQ    m_msgqPost;     // Posted messages
            UINT        m_nMsgMode;     // Messaging mode
};

#pragma warning(default:4324)  // structure was padded due to __declspec(align())

inline  CoreSC *    GetCoreSC();
inline  CoreSC *    GetCoreSC(Context * pContext);

#include "Context.inl"

#endif // CORE__CoreSC_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\context.inl ===
/***************************************************************************\
*
* File: Context.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__CoreSC_inl__INCLUDED)
#define CORE__CoreSC_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class CoreSC
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline CoreSC *   
GetCoreSC()
{
    return static_cast<CoreSC *> (GetContext()->GetSC(Context::slCore));
}


//------------------------------------------------------------------------------
inline CoreSC *    
GetCoreSC(Context * pContext)
{
    return static_cast<CoreSC *> (pContext->GetSC(Context::slCore));
}


//------------------------------------------------------------------------------
inline void   
CoreSC::MarkDataNL()
{
    if ((!m_fQData) && !InterlockedExchange((long *) &m_fQData, TRUE)) {
        SetEvent(m_hevQData);
    }
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::xwSendMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo)
{
    return xwSendNL(psctxDest, &psctxDest->m_msgqSend, pmsg, pmo, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::xwSendEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    return xwSendNL(psctxDest, &psctxDest->m_msgqSend, pmsg, reinterpret_cast<MsgObject *> (pgadMsg), nFlags);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::PostMethodNL(CoreSC * psctxDest, MethodMsg * pmsg, MsgObject * pmo)
{
    return PostNL(psctxDest, &psctxDest->m_msgqPost, pmsg, pmo, 0);
}


//------------------------------------------------------------------------------
inline HRESULT
CoreSC::PostEventNL(CoreSC * psctxDest, EventMsg * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    return PostNL(psctxDest, &psctxDest->m_msgqPost, pmsg, reinterpret_cast<MsgObject *> (pgadMsg), nFlags);
}


#endif // CORE__CoreSC_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\dynaset.cpp ===
/***************************************************************************\
*
* File: DynaSet.h
*
* Description:
* DynaSet.h implements a "dynamic set" that can be used to implement a 
* collection of "atom - data" property pairs.  This extensible, lightweight
* mechanism is optimized for small sets that have been created once and are
* read on occassion.  It is not a high-performance property system.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "DynaSet.h"

/***************************************************************************\
*****************************************************************************
*
* class AtomSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* AtomSet::AtomSet
*
* AtomSet() creates and initializes a new AtomSet.
*
\***************************************************************************/

AtomSet::AtomSet(
    IN  PRID idStartGlobal)         // Starting PRID to number from
{
    m_idNextPrivate = PRID_PrivateMin;
    m_idNextGlobal  = idStartGlobal;
    m_ptemGuid      = NULL;
}


/***************************************************************************\
*
* AtomSet::~AtomSet
*
* ~AtomSet() cleans up and frees resources associated with an AtomSet.
*
\***************************************************************************/

AtomSet::~AtomSet()
{
    Atom * ptemCur, * ptemNext;

    //
    // The list should be empty by now because we are destroying the desktop
    // and all of the applications should have Released their ID.  However, 
    // many apps are bad, so need to clean up anyway.
    //

    ptemCur = m_ptemGuid;
    while (ptemCur != NULL) {
        ptemNext = ptemCur->pNext;
        ProcessFree(ptemCur);
        ptemCur = ptemNext;
    }
}


/***************************************************************************\
*
* AtomSet::GetNextID
*
* GetNextID() returns the next ID to use for a new Atom.  The internal 
* counter to automatically advanced to the next available ID.
*
\***************************************************************************/

PRID    
AtomSet::GetNextID(
    IN  PropType pt)
{
    switch (pt)
    {
    case ptPrivate:
        // Private properties go down
        return m_idNextPrivate--;
        break;

    case ptGlobal:
        // Global properties go up
        return m_idNextGlobal++;
        break;

    default:
        AssertMsg(0, "Illegal property type");
        return PRID_Unused;
    }
}


/***************************************************************************\
*
* AtomSet::AddRefAtom
*
* AddRefAtom() adds a new property to the property list.  If the 
* property already exists, it increments a usage count.  The short-ID will 
* be determined from the type of property.
*
\***************************************************************************/

HRESULT
AtomSet::AddRefAtom(
    IN  const GUID * pguidAdd,          // Property to add
    IN  PropType pt,                    // Type of property
    OUT PRID * pprid)                   // Unique PRID for property
{
    GuidAtom * ptemCur, * ptemTail;
    ptemCur = FindAtom(pguidAdd, pt, &ptemTail);
    if (ptemCur != NULL) {
        ptemCur->cRefs++;
        *pprid = ptemCur->id;
        return S_OK;
    }

    //
    // Unable to find in registered list, so need to add to end.  Will need
    // to determine a new ID to use.
    //

    PRID idNew = GetNextID(pt);

    ptemCur = (GuidAtom *) ProcessAlloc(sizeof(GuidAtom));
    if (ptemCur == NULL) {
        *pprid = PRID_Unused;
        return E_OUTOFMEMORY;
    }

    ptemCur->cRefs  = 1;
    ptemCur->guid   = *pguidAdd;
    ptemCur->pNext  = NULL;
    ptemCur->id     = idNew;

    if (ptemTail == NULL) {
        // First node in list, so store directly
        m_ptemGuid = ptemCur;
    } else {
        // Already existing nodes, so add to end
        ptemTail->pNext = ptemCur;
    }

    *pprid = ptemCur->id;
    return S_OK;
}


/***************************************************************************\
*
* AtomSet::ReleaseAtom
*
* ReleaseAtom() decreases the reference count on the given Atom by one.
* When the reference count reaches 0, the Atom is destroyed.
*
\***************************************************************************/

HRESULT
AtomSet::ReleaseAtom(
    IN const GUID * pguidSearch,    // Property to release
    IN PropType pt)                 // Type of property
{
    GuidAtom * ptemCur, * ptemPrev;
    ptemCur = FindAtom(pguidSearch, pt, &ptemPrev);
    if (ptemCur != NULL) {
        ptemCur->cRefs--;
        if (ptemCur->cRefs <= 0) {
            if (ptemPrev != NULL) {
                //
                // In middle of list, so just splice this item out.
                //

                ptemPrev->pNext = ptemCur->pNext;
            } else {
                //
                // At beginning of list, so need to also update the head.
                //

                m_ptemGuid = (GuidAtom *) ptemCur->pNext;
            }

            ProcessFree(ptemCur);
        }

        return S_OK;
    }

    // Unable to find ID
    return E_INVALIDARG;
}


/***************************************************************************\
*
* AtomSet::FindAtom
*
* FindAtom() searches through the list of registered properties 
* and returns the corresponding short id.  If the ID is not found, returns 
* PRID_Unused.
*
\***************************************************************************/
AtomSet::GuidAtom *
AtomSet::FindAtom(
    IN const GUID * pguidSearch,    // Property to add
    IN PropType pt,                 // Type of property
    OUT GuidAtom ** pptemPrev       // Previous Atom, tail of list
    ) const
{
    GuidAtom * ptemCur, * ptemPrev;

    // Check parameters
    AssertReadPtr(pguidSearch);

    //
    // Search through the list of nodes searching for the ID.
    //

    ptemPrev = NULL;
    ptemCur = m_ptemGuid;
    while (ptemCur != NULL) {
        PropType ptCur = GetPropType(ptemCur->id);
        if ((ptCur == pt) && IsEqualGUID(*pguidSearch, ptemCur->guid)) {
            if (pptemPrev != NULL) {
                // Pass back the previous node
                *pptemPrev = ptemPrev;
            }
            return ptemCur;
        }

        ptemPrev = ptemCur;
        ptemCur = (GuidAtom *) ptemCur->pNext;
    }

    if (pptemPrev != NULL) {
        // Pass back the tail of the list
        *pptemPrev = ptemPrev;
    }
    return NULL;
}


/***************************************************************************\
*
* AtomSet::ValidatePrid
*
* ValidatePrid() checks that the ID range matches with the property 
* type.  This is how we keep DirectUser properties private.
*
\***************************************************************************/
BOOL 
AtomSet::ValidatePrid(
    IN PRID prid,                   // ID to check
    IN PropType pt)                 // Property type to validate
{
    switch (pt)
    {
    case ptPrivate:
        if (ValidatePrivateID(prid))
            return TRUE;
        break;

    case ptGlobal:
        if (ValidateGlobalID(prid))
            return TRUE;
        break;
    }

    return FALSE;
}


/***************************************************************************\
*****************************************************************************
*
* class DynaSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DynaSet::AddItem
*
* AddItem() adds a new data item.
*
\***************************************************************************/

BOOL
DynaSet::AddItem(
    IN  PRID id,                    // PRID of new item to add
    IN  void * pvData)              // Associated data for item
{
    DynaData dd;
    dd.pData    = pvData;
    dd.id       = id;

    return m_arData.Add(dd) >= 0;
}


/***************************************************************************\
*
* DynaDataSet::RemoveAt
*
* RemoveAt() removes the item at the specified index from the set.
*
\***************************************************************************/

void 
DynaSet::RemoveAt(
    IN  int idxData)               // Index to remove
{
    // Search data
#if DBG
    int cItems = GetCount();
    AssertMsg(cItems > 0, "Must have items to remove");
    AssertMsg((idxData < cItems) && (idxData >= 0), "Ensure valid index");
#endif // DBG

    m_arData.RemoveAt(idxData);
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with the specified PRID.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  PRID id                     // PRID of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if (dd.id == id) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with associated data value.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  void * pvData               // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if (dd.pData == pvData) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DynaDataSet::FindItem
*
* FindItem() searches for the first item with both the given PRID and
* associated data value.
*
\***************************************************************************/

int         
DynaSet::FindItem(
    IN  PRID id,                    // PRID of item to find
    IN  void * pvData               // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const DynaData & dd = m_arData[idx];
        if ((dd.id == id) && (dd.pData == pvData)) {
            return idx;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\core.h ===
/***************************************************************************\
*
* File: Core.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Core_h__INCLUDED)
#define CORE__Core_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>

#define DEBUG_MARKDRAWN             0
#define DEBUG_DRAWSTATS             0

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Core Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // CORE__Core_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\dynaset.inl ===
/***************************************************************************\
*
* File: DynaSet.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DynaSet_inl__INCLUDED)
#define CORE__DynaSet_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline bool ValidatePrivateID(PRID id)
{
    return id <= PRID_PrivateMin;
}


//------------------------------------------------------------------------------
inline bool ValidateGlobalID(PRID id)
{
    return id >= PRID_GlobalMin;
}


//------------------------------------------------------------------------------
inline PropType GetPropType(PRID id)
{
    if (id <= PRID_PrivateMin) {
        return ptPrivate;
    } else if (id >= PRID_GlobalMin) {
        return ptGlobal;
    } else {
        AssertMsg(0, "Invalid property ID");
        return ptPrivate;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class AtomSet
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline PRID        
AtomSet::FindAtomID(LPCWSTR pszName, PropType pt) const
{
    AtomSet::StringAtom * psa = FindAtom(pszName, pt, NULL);
    if (psa != NULL) {
        return psa->id;
    } else {
        return 0;   // Unable to find ID
    }
}


//------------------------------------------------------------------------------
inline PRID        
AtomSet::FindAtomID(const GUID * pguidSearch, PropType pt) const
{
    AtomSet::GuidAtom * pga = FindAtom(pguidSearch, pt, NULL);
    if (pga != NULL) {
        return pga->id;
    } else {
        return 0;   // Unable to find ID
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DynaSet
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
DynaSet::DynaSet()
{

}


//------------------------------------------------------------------------------
inline  
DynaSet::~DynaSet()
{
#if DBG
    //
    // Check to make sure all private data has already been free'd.  If it has
    // not, this is a programming error in DirectUser/Core.
    //

    {
        int idx;
        int cItems = GetCount();
        for (idx = 0; idx < cItems; idx++) {
            if (m_arData[idx].id < 0) {
                Trace("DUSER Warning: Destroying server-allocated property %d\n", m_arData[idx].id);
                AssertMsg(0, "Destroying server-allocated property");
            }
        }
    }

#endif // DBG
}


//------------------------------------------------------------------------------
inline BOOL        
DynaSet::IsEmpty() const
{
    return m_arData.IsEmpty();
}


//------------------------------------------------------------------------------
inline int         
DynaSet::GetCount() const
{
    return m_arData.GetSize();
}


//------------------------------------------------------------------------------
inline void    
DynaSet::SetCount(int cNewItems)
{
    AssertMsg(cNewItems > 0, "Must specify a positive number of items");

    m_arData.SetSize(cNewItems);
}


#endif // CORE__DynaSet_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\dynaset.h ===
/***************************************************************************\
*
* File: DynaSet.h
*
* Description:
* DynaSet.h implements a "dynamic set" that can be used to implement a 
* collection of "atom - data" property pairs.  This extensible, lightweight
* mechanism is optimized for small sets that have been created once and are
* read on occassion.  It is not a high-performance property system.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DynaSet_h__INCLUDED)
#define CORE__DynaSet_h__INCLUDED
#pragma once

//
// DynaSets are dynamically allocated sets of extra properties that can be 
// attached to an object.  Each property has both a full ID and a short ID 
// (atom). The full ID (GUID) is always unique, even across sessions.  It is 
// used by the caller to "register" a new property.  However, because GUID's 
// are very expensive to compare and consume more memory, every property is 
// assigned an atom that is used for Get() and Set() operations.  Atoms can 
// be public or private to DirectUser/Core, depending on the caller.  An atom
// will never be reused within a single session.  
//
// NOTE: When an atom is finally Release()'d, any objects (windows) that use
// that property are currently not changed since there is no danger of new
// properties using the same ID.  However, properties should normally be 
// initialized once at the application startup and uninitialized at application
// shutdown.
//
// ID types:
//   Unused:        0
//   Private:       Always negative
//   Global:        Always positive
//

enum PropType
{
    ptPrivate   = 1,       // Private entry only available to DirectUser/Core
    ptGlobal    = 2,       // Public entry available to all applications
};

typedef int PRID;

const PRID PRID_Unused       = 0;
const PRID PRID_PrivateMin   = -1;
const PRID PRID_GlobalMin    = 1;

inline bool ValidatePrivateID(PRID id);
inline bool ValidateGlobalID(PRID id);
inline PropType GetPropType(PRID id);


//------------------------------------------------------------------------------
class AtomSet
{
// Construction
public:
            AtomSet(PRID idStartGlobal = PRID_GlobalMin);
            ~AtomSet();

// Operations
public:
            HRESULT     AddRefAtom(LPCWSTR pszName, PropType pt, PRID * pprid);
            HRESULT     ReleaseAtom(LPCWSTR pszName, PropType pt);

            HRESULT     AddRefAtom(const GUID * pguidAdd, PropType pt, PRID * pprid);
            HRESULT     ReleaseAtom(const GUID * pguidSearch, PropType pt);

            PRID        FindAtomID(LPCWSTR pszName, PropType pt) const;
            PRID        FindAtomID(const GUID * pguidSearch, PropType pt) const;

// Implementation
protected:
    struct Atom
    {
        enum AtomFlags
        {
            tfString    = 0x0000,       // Atom ID is a string
            tfGUID      = 0x0001,       // Atom ID is a GUID

            tfTYPE      = 0x0001
        };

        Atom *      pNext;              // Next node
        ULONG       cRefs;              // Number of references
        PRID        id;                 // Shortened ID (Used with SetData())
        WORD        nFlags;             // Flags on Atom

        inline AtomFlags GetType() const
        {
            return (AtomFlags) (nFlags & tfTYPE);
        }
    };

    struct GuidAtom : Atom
    {
        GUID        guid;               // ID
    };

    struct StringAtom : Atom
    {
        int         cch;                // Number of characters (not including '\0')
        WCHAR       szName[1];          // Property name
    };

            StringAtom* FindAtom(LPCWSTR pszName, PropType pt, StringAtom ** pptemPrev) const;
            GuidAtom *  FindAtom(const GUID * pguidSearch, PropType pt, GuidAtom ** pptemPrev) const;

            PRID        GetNextID(PropType pt);
            BOOL        ValidatePrid(PRID prid, PropType pt);

// Data
protected:
    StringAtom* m_ptemString;       // Head of String list
    GuidAtom *  m_ptemGuid;         // Head of GUID list
    PRID        m_idNextPrivate;    // Next Core-only short ID to use
    PRID        m_idNextGlobal;     // Next externally available global short ID to use
};


//------------------------------------------------------------------------------
class DynaSet
{
// Construction
public:
    inline  DynaSet();
    inline  ~DynaSet();

// Operations
public:

// Implementation
protected:
    inline  BOOL        IsEmpty() const;
    inline  int         GetCount() const;
    inline  void        SetCount(int cNewItems);
            BOOL        AddItem(PRID id, void * pvData);
            void        RemoveAt(int idxData);

            int         FindItem(PRID id) const;
            int         FindItem(void * pvData) const;
            int         FindItem(PRID id, void * pvData) const;

// Data
protected:
    struct DynaData
    {
        void *      pData;              // (User) data
        PRID        id;                 // (Short) Property ID
    };

    GArrayS<DynaData> m_arData;         // Dynamic user data
};

#include "DynaSet.inl"

#endif // CORE__DynaSet_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\eventpool.inl ===
/***************************************************************************\
*
* File: EventPool.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuEventPool_inl__INCLUDED)
#define CORE__DuEventPool_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DuEventPool
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuEventPool::DuEventPool()
{
    AssertMsg(sizeof(MSGID) == sizeof(PRID), "Ensure sizes match");
}


//------------------------------------------------------------------------------
inline 
DuEventPool::~DuEventPool()
{

}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::RegisterMessage(const GUID * pguid, PropType pt, MSGID * pmsgid)
{
    s_lock.Enter();

    HRESULT hr = s_asEvents.AddRefAtom(pguid, pt, (PRID *) pmsgid);

    s_lock.Leave();
    return hr;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::RegisterMessage(LPCWSTR pszName, PropType pt, MSGID * pmsgid)
{
    AssertMsg(0, "TODO: Implement RegisterMessage(String)");

    UNREFERENCED_PARAMETER(pszName);
    UNREFERENCED_PARAMETER(pt);

    *pmsgid = 0;
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::UnregisterMessage(const GUID * pguid, PropType pt)
{
    s_lock.Enter();

    HRESULT hr = s_asEvents.ReleaseAtom(pguid, pt);

    s_lock.Leave();
    return hr;
}


//------------------------------------------------------------------------------
inline HRESULT
DuEventPool::UnregisterMessage(LPCWSTR pszName, PropType pt)
{
    AssertMsg(0, "TODO: Implement UnregisterMessage(String)");

    UNREFERENCED_PARAMETER(pszName);
    UNREFERENCED_PARAMETER(pt);

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
inline BOOL
DuEventPool::IsEmpty() const
{
    return m_arData.IsEmpty();
}


//------------------------------------------------------------------------------
inline int
DuEventPool::GetCount() const
{
    return m_arData.GetSize();
}


//------------------------------------------------------------------------------
inline const DuEventPool::EventData *
DuEventPool::GetData() const
{
    return m_arData.GetData();
}


#endif // CORE__DuEventPool_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\gmouse.cpp ===
/***************************************************************************\
*
* File: GMouse.cpp
*
* Description:
* GMouse.cpp implements mouse-related functions on DuRootGadget.
*
*
* History:
*  7/27/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::xdHandleMouseMessage
*
* xdHandleMouseMessage() is the starting point for all mouse messages coming
* from the container.  This entry point updates all mouse information cached
* in the DuRootGadget, including dragging and focus.  As the message is
* processed, the mouse location will be translated from container pixels
* into client-pixels relative to the Gadget to handle the message.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleMouseMessage(
    IN  GMSG_MOUSE * pmsg,          // Mouse message
    IN  POINT ptContainerPxl)       // Location of mouse in container pixels
{
    CoreSC * pSC = GetCoreSC();

    //
    // Check if we have started destruction.  If so, stop sending mouse 
    // messages.
    //

    if (m_fFinalDestroy) {
        return FALSE;
    }


    //
    // Change the message around, depending on what the mouse is doing.
    //

    GMSG_MOUSEDRAG mde;
    POINT ptClientPxl = { 0, 0 };
    DuVisual * pgadMouse = pSC->pgadDrag;

    if ((pgadMouse != NULL) && (pmsg->nCode == GMOUSE_MOVE) && (!pgadMouse->m_fAdaptor)) {
        //
        // Update drag information: Need to *promote* mouse moves to drags and
        // add extra info for drag message (then change message pointer to
        // point to this new version of the message structure)
        //
        *((GMSG_MOUSE*) &mde) = *pmsg;
        mde.cbSize  = sizeof(GMSG_MOUSEDRAG);
        mde.nCode   = GMOUSE_DRAG;
        mde.bButton = pSC->bDragButton;

        RECT rc;
        pgadMouse->GetLogRect(&rc, SGR_CLIENT);
        pgadMouse->MapPoint(ptContainerPxl, &ptClientPxl);

        mde.fWithin = PtInRect(&rc, ptClientPxl);

        pmsg = &mde;
    }

    //
    // Check if we actually need to process
    //

    if ((pmsg->nCode == GMOUSE_MOVE) &&
        (!TestFlag(GetWantEvents(), DuVisual::weDeepMouseMove | DuVisual::weDeepMouseEnter))) {
        return FALSE;  // Not completely handled
    }


    //
    // A "normal" mouse message, so find the proper control and send a
    // message.  The no drag operation is going on, find the DuVisual at the
    // current point.  If a drag operation is going on, need to transform
    // the current point into one relative to that DuVisual.
    //

    if ((pgadMouse != NULL) &&
            ((pmsg->nCode == GMOUSE_DRAG) || ((pmsg->nCode == GMOUSE_UP) && (pmsg->bButton == pSC->bDragButton)))) {

        //
        // A drag operation is going on.  If the mouse is either dragging,
        // OR (the button was released AND the button is the same as when
        // dragging started), send this message to the Gadget where
        // dragging started.
        //

        if (pmsg->nCode != GMOUSE_DRAG) {
            //
            // for mouse drag, we've already set ptClientPxl
            //
            pgadMouse->MapPoint(ptContainerPxl, &ptClientPxl);
        }
    } else {
        pgadMouse = FindFromPoint(ptContainerPxl, GS_VISIBLE | GS_ENABLED | gspDeepMouseFocus, &ptClientPxl);
        xdUpdateMouseFocus(&pgadMouse, &ptClientPxl);
    }

    if (pgadMouse != NULL) {
        return xdProcessGadgetMouseMessage(pmsg, pgadMouse, ptClientPxl);
    }

    return FALSE;  // Not completely handled
}        


/***************************************************************************\
*
* DuRootGadget::xdProcessGadgetMouseMessage
*
* xdProcessGadgetMouseMessage() handles a mouse message that has been 
* determined to "belong" to a specific Gadget.  At this point, the message
* has already been formatted to this specific Gadget.
*
\***************************************************************************/

BOOL
DuRootGadget::xdProcessGadgetMouseMessage(
    IN  GMSG_MOUSE * pmsg,              // Mouse message
    IN  DuVisual * pgadMouse,       // Gadget "owning" message
    IN  POINT ptClientPxl)              // Location of mouse in Gadget client pixels
{
    AssertMsg(pgadMouse != NULL, "Must specify valid Gadget");
    AssertMsg(pgadMouse->IsParentChainStyle(GS_VISIBLE | GS_ENABLED),
            "Gadget must be visible & enabled");

    CoreSC * pSC = GetCoreSC();

    //
    // Process the mouse message and update drag information.  
    //
    // NOTE: We must not affect dragging for Adaptor Gadgets.  This is because 
    // dragging affects mouse capture, which means that the HWND will not get 
    // the mouse message.
    //

    BOOL fAdaptor = pgadMouse->m_fAdaptor;

    switch (pmsg->nCode)
    {
    case GMOUSE_DOWN:
        if (pSC->pgadDrag == NULL) {
            //
            // User was not already dragging when they clicked the mouse
            // button, so start a drag operation.
            //
            // NOTE: We can only drag and automatically update keyboard focus 
            // for Adaptors.
            //
            // TODO: Provide a mechanism to that allows the adaptor to specify
            // what it supports.  This is because not all adaptors are HWND's.
            //

            if (!fAdaptor) {
                DuVisual * pgadCur = GetKeyboardFocusableAncestor(pgadMouse);
                if (pgadCur) {
                    xdUpdateKeyboardFocus(pgadCur);
                }
            }


            //
            // Update the click-count by determining if the up can form a proper 
            // double-click.  This is done so that the "down" mouse event will 
            // have a cClicks = 0 if it is a "regular" click and not part of a 
            // double-click.
            //
            // One additional requirement is that the click occurs in the same
            // Gadget.  We don't need to check this for UP, since we will always
            // send an up to match the down since we capture the mouse to 
            // perform the drag.
            // 

            if ((pSC->pressLast.pgadClick != pgadMouse) ||
                    (pSC->pressLast.bButton != pmsg->bButton) ||
                    ((UINT) (pmsg->lTime - pSC->pressLast.lTime) > GetDoubleClickTime())) {

                pSC->cClicks = 0;
            }

            GMSG_MOUSECLICK * pmsgM = static_cast<GMSG_MOUSECLICK *>(pmsg);
            pmsgM->cClicks          = pSC->cClicks;


            //
            // Store information about this event to be used when determining clicking
            //

            pSC->pressNextToLast    = pSC->pressLast;

            pSC->pressLast.pgadClick= pgadMouse;
            pSC->pressLast.bButton  = pmsg->bButton;
            pSC->pressLast.lTime    = pmsg->lTime;
            pSC->pressLast.ptLoc    = ptClientPxl;

            pSC->pgadDrag           = pgadMouse;
            pSC->ptDragPxl          = ptClientPxl;
            pSC->bDragButton        = pmsg->bButton;


            //
            // If starting a drag, need to capture the mouse.  We can only do 
            // this if not in an adaptor.
            //
            // TODO: In the future, we need to distinguish between HWND adaptors
            // (which we can't capture) and other adaptors, where we may need to
            // capture.  Don't forget the corresponding OnEndCapture() in the
            // GMOUSE_UP case as well.
            //

            if (!fAdaptor) {
                m_fUpdateCapture = TRUE;
                GetContainer()->OnStartCapture();
                m_fUpdateCapture = FALSE;
            }
        } else {
            //
            // User clicked another mouse button while dragging.  Don't
            // stop dragging, but send this mouse message through.  This
            // behavior is consistent with dragging the title-bar in an
            // HWND.
            //
        }
        break;

    case GMOUSE_UP:
        //
        // Update drag information: On button release, need to release
        // capture and all.
        //
        // NOTE: It is VERY important that dragging information is reset
        // BEFORE calling OnEndCapture(), or else releasing the capture
        // will send another GMOUSE_UP message.
        //

        if ((pSC->pgadDrag != NULL) && (pmsg->bButton == pSC->bDragButton)) {
            pSC->pgadDrag      = NULL;
            pSC->bDragButton   = GBUTTON_NONE;

            if (!fAdaptor) {
                m_fUpdateCapture = TRUE;
                GetContainer()->OnEndCapture();
                m_fUpdateCapture = FALSE;
            }


            //
            // Update the click-count
            //

            GMSG_MOUSECLICK * pmsgM = static_cast<GMSG_MOUSECLICK *>(pmsg);

            RECT rc;
            pgadMouse->GetLogRect(&rc, SGR_CLIENT);

            if (PtInRect(&rc, ptClientPxl)) {
                //
                // The up occurred within the bounds of this gadget, so 
                // treat this as a click.
                //

                if ((pSC->pressNextToLast.bButton == pSC->pressLast.bButton) &&
                        (pSC->pressLast.bButton == pmsg->bButton) &&
                        ((UINT) (pmsg->lTime - pSC->pressNextToLast.lTime) <= GetDoubleClickTime()) &&
                        (abs(ptClientPxl.x - pSC->pressNextToLast.ptLoc.x) <= GetSystemMetrics(SM_CXDOUBLECLK)) &&
                        (abs(ptClientPxl.y - pSC->pressNextToLast.ptLoc.y) <= GetSystemMetrics(SM_CYDOUBLECLK))) {

                    // 
                    // All signs point to this is a quick succession click, 
                    // so update the click count
                    // 

                    pSC->cClicks++;
                } else {
                    pSC->cClicks = 1;
                }

                pmsgM->cClicks = pSC->cClicks;
            } else {
               pmsgM->cClicks = 0;
            }
        } else {
            pSC->cClicks = 0;
        }
        break;

    case GMOUSE_DRAG:
        {
            AssertMsg(pSC->pgadDrag == pgadMouse, "Gadget being dragged must have the mouse");
            //
            // When dragging, give offset from the last location.  This is
            // helpful if the window that is receiving the drag messages
            // is itself being moved.
            //

            SIZE sizeOffset;
            sizeOffset.cx   = ptClientPxl.x - pSC->ptDragPxl.x;
            sizeOffset.cy   = ptClientPxl.y - pSC->ptDragPxl.y;

            GMSG_MOUSEDRAG * pmsgD = (GMSG_MOUSEDRAG *) pmsg;
            pmsgD->sizeDelta.cx   = sizeOffset.cx;
            pmsgD->sizeDelta.cy   = sizeOffset.cy;
        }
        break;
    }

    BOOL fSend   = TRUE;
    UINT nEvents = pgadMouse->GetWantEvents();

    if ((!TestFlag(nEvents, DuVisual::weMouseMove | DuVisual::weDeepMouseMove)) && (pmsg->nCode == GMOUSE_MOVE)) {
        fSend = FALSE;
    }

    if (fSend) {
        pmsg->ptClientPxl = ptClientPxl;
        pgadMouse->m_cb.xdFireMouseMessage(pgadMouse, pmsg);

        //
        // When we delay a mouse message, we need to assume that it may be
        // handled.  This means that we need to report that the message is
        // handled and should not be passed on.
        //
        return TRUE;
    }

    return FALSE;
}



/***************************************************************************\
*
* DuRootGadget::xdHandleMouseLostCapture
*
* xdHandleMouseLostCapture() is called by the container when mouse capture
* is lost.  This provides the DuRootGadget an opportunity to update any cached 
* information including dragging and focus.
*
\***************************************************************************/

void
DuRootGadget::xdHandleMouseLostCapture()
{
    //
    // If in the middle of updating the capture information, don't process here
    // or we will throw everything away.
    //

    if (m_fUpdateCapture) {
        return;
    }


    //
    // Cancel any dragging operation
    //

    CoreSC * pSC = GetCoreSC();

    if (pSC->pgadDrag != NULL) {
        if (!pSC->pgadDrag->m_fAdaptor) {
            GMSG_MOUSECLICK msg;
            msg.cbSize      = sizeof(msg);
            msg.nCode       = GMOUSE_UP;
            msg.bButton     = pSC->bDragButton;
            msg.ptClientPxl = pSC->ptDragPxl;
            msg.cClicks     = 0;

            pSC->pgadDrag->m_cb.xdFireMouseMessage(pSC->pgadDrag, &msg);
        }
        pSC->pgadDrag   = NULL;
    }


    //
    // Update enter/leave information
    //

    if (pSC->pgadRootMouseFocus != NULL) {
        xdUpdateMouseFocus(NULL, NULL);
    }
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateMouseFocus
*
* xdUpdateMouseFocus() updates cached information about which Gadget the
* mosue cursor is currently hovering over.  This information is used to
* generate GM_CHANGESTATE: GSTATE_MOUSEFOCUS events.
*
\***************************************************************************/

void
DuRootGadget::xdUpdateMouseFocus(
    IN OUT DuVisual ** ppgadNew,    // New Gadget containing the mouse cursor
    IN OUT POINT * pptClientPxl)        // Point inside Gadget, in client coordinates
{
    CoreSC * pSC            = GetCoreSC();
    DuVisual * pgadLost = pSC->pgadMouseFocus;
    DuVisual * pgadNew  = ppgadNew != NULL ? *ppgadNew : NULL;


    //
    // If we have started destruction, don't continue to update the mouse focus.
    // Instead, push it to the Root and keep it there.
    //

    if (m_fFinalDestroy) {
        *ppgadNew = this;
        pptClientPxl = NULL;
    }


    //
    // Walk up the tree looking for the first Gadget that wants mouse focus.
    // We also need to convert the given point into new client coordinates for
    // each level.
    //

    if (pptClientPxl != NULL) {
        //
        // No point to translate, so just walk back up
        //

        while (pgadNew != NULL) {
            if (pgadNew->m_fMouseFocus) {
                //
                // Found a Gadget that wants mouse focus
                //

                break;
            }

            pgadNew->DoXFormClientToParent(pptClientPxl, 1);
            pgadNew = pgadNew->GetParent();
        }
    } else {
        //
        // No point to translate, so just walk back up
        //

        while (pgadNew != NULL) {
            if (pgadNew->m_fMouseFocus) {
                //
                // Found a Gadget that wants mouse focus
                //

                break;
            }
            pgadNew = pgadNew->GetParent();
        }
    }

    if (ppgadNew != NULL) {
        *ppgadNew = pgadNew;
    }


    //
    // Update which Gadget has mouse focus
    //

    if ((pSC->pgadRootMouseFocus != this) || (pgadLost != pgadNew)) {
        //
        // Send messages to the gadgets to notify them of the change.  Since 
        // these messages are deferred, we can only use the handles if the 
        // Gadgets have not started their destruction process.
        //

        xdFireChangeState(&pgadLost, &pgadNew, GSTATE_MOUSEFOCUS);
        if (ppgadNew != NULL) {
            *ppgadNew = pgadNew;
        }

        //
        // Update internal information about where we are and start mouse
        // capture so that we can find when we leave.
        //
        // NOTE: We DON'T want to track the mouse when we are actually in an
        // Adaptor.  This is because the mouse is actually in the Adaptor.
        //

        if (pgadNew != NULL) {
            pSC->pgadMouseFocus = pgadNew;

            if (pSC->pgadRootMouseFocus != this) {
                pSC->pgadRootMouseFocus  = this;

                if (!pgadNew->m_fAdaptor) {
                    GetContainer()->OnTrackMouseLeave();
                }
            }
        } else {
            pSC->pgadRootMouseFocus = NULL;
            pSC->pgadMouseFocus     = NULL;
        }
    }

    AssertMsg(((pgadNew == NULL) && (ppgadNew == NULL)) || 
            (pgadNew == *ppgadNew),
            "Ensure match");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\eventpool.h ===
/***************************************************************************\
*
* File: EventPool.h
*
* Description:
* DuEventPool maintains a collection of event handlers for given event ID's.
* This is a many-to-many relationship.  Each event ID may have multiple 
* event handlers.
*
* DuEventPools can not be created and handed outside DirectUser/Core 
* directly.  Instead, must derive some class from DuEventPool to add in 
* BaseObject support for public handles.  This is a little wierd, but it is 
* because DuEventPool is DESIGNED to be as small as possible.  It is 
* ONLY 4 bytes.  There is no v-table, pointer to an "owner", etc.  
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuEventPool_h__INCLUDED)
#define CORE__DuEventPool_h__INCLUDED
#pragma once

#include "DynaSet.h"

class DuEventGadget;
class GPCB;

//------------------------------------------------------------------------------
class DuEventPool
{
// Construction
public:
    DuEventPool();
    ~DuEventPool();

// Operations
public:
    static  HRESULT     RegisterMessage(const GUID * pguid, PropType pt, MSGID * pmsgid);
    static  HRESULT     RegisterMessage(LPCWSTR pszName, PropType pt, MSGID * pmsgid);
    static  HRESULT     UnregisterMessage(const GUID * pguid, PropType pt);
    static  HRESULT     UnregisterMessage(LPCWSTR pszName, PropType pt);
    static  HRESULT     FindMessages(const GUID ** rgpguid, MSGID * rgnMsg, int cMsgs, PropType pt);

    enum EAdd
    {
        aFailed         = -1,       // Adding the handler failed
        aAdded          = 0,        // A new handler was added
        aExisting       = 1,        // The handler already existed
    };

    struct EventData
    {
        union
        {
            DuEventGadget *  
                        pgbData;    // Gadget
            DUser::EventDelegate   
                        ed;         // Delegate
        };
        PRID        id;                 // (Short) Property ID
        BOOLEAN     fGadget;            // Delegate vs. Gadget
    };

    inline  BOOL        IsEmpty() const;
    inline  int         GetCount() const;
    inline  const EventData *
                        GetData() const;

            int         FindItem(DuEventGadget * pvData) const;
            int         FindItem(MSGID id, DuEventGadget * pvData) const;
            int         FindItem(MSGID id, DUser::EventDelegate ed) const;

            EAdd        AddHandler(MSGID nEvent, DuEventGadget * pgadHandler);
            EAdd        AddHandler(MSGID nEvent, DUser::EventDelegate ed);
            HRESULT     RemoveHandler(MSGID nEvent, DuEventGadget * pgadHandler);
            HRESULT     RemoveHandler(MSGID nEvent, DUser::EventDelegate ed);
            HRESULT     RemoveHandler(DuEventGadget * pgadHandler);

            void        Cleanup(DuEventGadget * pgadDependency);

// Implementation
protected:

// Data
protected:
    static  AtomSet     s_asEvents;
    static  CritLock    s_lock;

            GArrayS<EventData>
                        m_arData;         // Dynamic user data
};

#include "EventPool.inl"

#endif // CORE__DuEventPool_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\eventpool.cpp ===
/***************************************************************************\
*
* File: EventPool.cpp
*
* Description:
* DuEventPool maintains a collection of event handlers for given event ID's.
* This is a many-to-many relationship.  Each event ID may have multiple 
* event handlers.
*
* DuEventPools can not be created and handed outside DirectUser/Core directly.  
* Instead, must derive some class from DuEventPool to add in BaseObject 
* support for public handles.  This is a little wierd, but it is because 
* DuEventPool is DESIGNED to be as small as possible.  It is ONLY 4 bytes.  
* There is no v-table, pointer to an "owner", etc.  
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "EventPool.h"

#include "BaseGadget.h"


/***************************************************************************\
*****************************************************************************
*
* class DuEventPool
*
*****************************************************************************
\***************************************************************************/

AtomSet     DuEventPool::s_asEvents(GM_REGISTER);   // Start giving out registered messages at GM_REGISTER
CritLock    DuEventPool::s_lock;


/***************************************************************************\
*
* DuEventPool::FindMessages
*
* FindMessages() looks up and determines the corresponding MSGID's for a 
* collection of unique message GUID's.
*
\***************************************************************************/

HRESULT
DuEventPool::FindMessages(
    IN  const GUID ** rgpguid,      // Array of GUID's to lookup
    OUT MSGID * rgnMsg,             // Corresponding MSGID's of items
    IN  int cMsgs,                  // Number of GUID's to lookup
    IN  PropType pt)                // Item property type
{
    HRESULT hr = S_OK;

    for (int idx = 0; idx < cMsgs; idx++) {
        const GUID * pguidSearch = rgpguid[idx];
        PRID prid = s_asEvents.FindAtomID(pguidSearch, pt);
        rgnMsg[idx] = prid;
        if (prid == 0) {
            //
            // Unable to find ID of one message, but continue searching.
            //

            hr = DU_E_CANNOTFINDMSGID;
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuEventPool::AddHandler
*
* AddHandler() adds the given handler to the set of handlers maintained by
* the event pool.  If an identical handler already exists, it will be used
* instead.
*
* NOTE: This function is designed to be used with 
* DuEventGadget::AddMessageHandler() to maintain a list of "message handlers"
* for a given Gadget.
*
\***************************************************************************/

DuEventPool::EAdd
DuEventPool::AddHandler(
    IN  MSGID nEvent,               // ID of message to handle
    IN  DuEventGadget * pgadHandler)   // Message handler
{
    //
    // Check if already has handler for this specific event
    //

    int idxHandler = FindItem(nEvent, pgadHandler);
    if (idxHandler >= 0) {
        return aExisting;
    }


    //
    // Add a new handler
    //

    EventData data;
    data.pgbData    = pgadHandler;
    data.id         = nEvent;
    data.fGadget    = TRUE;
    
    return m_arData.Add(data) >= 0 ? aAdded : aFailed;
}


//------------------------------------------------------------------------------
DuEventPool::EAdd
DuEventPool::AddHandler(
    IN  MSGID nEvent,                   // ID of message to handle
    IN  DUser::EventDelegate ed)        // Message handler to remove
{
    //
    // Check if already has handler for this specific event
    //

    int idxHandler = FindItem(nEvent, ed);
    if (idxHandler >= 0) {
        return aExisting;
    }


    //
    // Add a new handler
    //

    EventData data;
    data.ed         = ed;
    data.id         = nEvent;
    data.fGadget    = FALSE;

    return m_arData.Add(data) >= 0 ? aAdded : aFailed;
}
    


/***************************************************************************\
*
* DuEventPool::RemoveHandler
*
* RemoveHandler() removes the given handler to the set of handlers 
* maintained by the event pool.
*
* NOTE: This function is designed to be used with 
* DuEventGadget::RemoveMessageHandler() to maintain a list of "message handlers"
* for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventPool::RemoveHandler(
    IN  MSGID nEvent,                   // ID of message being handled
    IN  DuEventGadget * pgadHandler)     // Message handler
{
    int idxHandler = FindItem(nEvent, pgadHandler);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
HRESULT
DuEventPool::RemoveHandler(
    IN  MSGID nEvent,                   // ID of message being handled
    IN  DUser::EventDelegate ed)        // Message handler to remove
{
    int idxHandler = FindItem(nEvent, ed);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


/***************************************************************************\
*
* DuEventPool::RemoveHandler
*
* RemoveHandler() removes the given handler to the set of handlers 
* maintained by the event pool.
*
* NOTE: This function is designed to called directly from
* DuEventGadget::CleanupMessageHandlers() to maintain a list of 
* "message handlers" for a given Gadget.
*
\***************************************************************************/

HRESULT
DuEventPool::RemoveHandler(
    IN  DuEventGadget * pgadHandler)     // Message handler to remove
{
    int idxHandler = FindItem(pgadHandler);
    if (idxHandler >= 0) {
        m_arData.RemoveAt(idxHandler);
        return S_OK;
    }

    // Unable to find
    return E_INVALIDARG;
}


/***************************************************************************\
*
* DuEventPool::Cleanup
*
* Cleanup() is called from during the second stage of 
* DuEventGadget::CleanupMessageHandlers() to cleanup the Gadget depencency 
* graph.
*
\***************************************************************************/

void
DuEventPool::Cleanup(
    IN  DuEventGadget * pgadDependency)    // Gadget being cleaned up
{
    if (IsEmpty()) {
        return;
    }

    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arData[idx].fGadget) {
            DuEventGadget * pgadCur = m_arData[idx].pgbData;
            pgadCur->RemoveDependency(pgadDependency);
        }
    }
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  DuEventGadget * pgadHandler      // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if (dd.fGadget && (dd.pgbData == pgadHandler)) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with both the given MSGID and
* associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  MSGID id,                       // MSGID of item to find
    IN  DuEventGadget * pgadHandler      // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if (dd.fGadget && (dd.id == id) && (dd.pgbData == pgadHandler)) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* DuEventPool::FindItem
*
* FindItem() searches for the first item with both the given MSGID and
* associated data value.
*
\***************************************************************************/

int         
DuEventPool::FindItem(
    IN  MSGID id,                       // MSGID of item to find
    IN  DUser::EventDelegate ed         // Data of item to find
    ) const
{
    int cItems = m_arData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        const EventData & dd = m_arData[idx];
        if ((!dd.fGadget) && (dd.id == id) && 
                (dd.ed.m_pvThis == ed.m_pvThis) && (dd.ed.m_pfn == ed.m_pfn)) {

            return idx;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\gkeyboard.cpp ===
/***************************************************************************\
*
* File: GKeyboard.cpp
*
* Description:
* GKeyboard.cpp implements keyboard-related functions on DuRootGadget.
*
*
* History:
*  7/27/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::xdHandleKeyboardFocus
*
* xdHandleKeyboardFocus() is called by the DuContainer to update keyboard 
* focus information inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleKeyboardFocus(
    IN  UINT nCmd)                  // Command to handle
{
    CoreSC * pSC = GetCoreSC();

    switch (nCmd)
    {
    case GSC_SET:
        //
        // When we get a request to set keyboard focus, we should not already
        // have keyboard focus.  This is because we should have already 
        // processed a message from when we last lost keyboard focus for either
        // the DuRootGadget or any nested Adaptors inside.
        //

        if (pSC->pgadCurKeyboardFocus != NULL) {
            if (pSC->pgadCurKeyboardFocus->m_fAdaptor) {
                PromptInvalid("Adaptor did not reset keyboard focus when lost");
//                pSC->pgadCurKeyboardFocus = NULL;
            }
        }

        AssertMsg(pSC->pgadCurKeyboardFocus == NULL, "Should not have any gadget already with focus");
        return xdUpdateKeyboardFocus(pSC->pgadLastKeyboardFocus);

    case GSC_LOST:
        //
        // We can loose keyboard focus both on the DuRootGadget or on any Adaptor
        // that is forwarding the message to be processed.  This is because an
        // Adaptor can not call SetGadgetFocus(NULL) to remove keyboard focus, 
        // so it needs to forward the WM_KILLFOCUS message to our DuRootGadget for
        // processing.  
        //
        // This is okay since if the DuRootGadget is receiving keyboard focus, it
        // will get the WM_SETFOCUS after the Adaptor has already sent its
        // WM_KILLFOCUS message.
        //

        return xdUpdateKeyboardFocus(NULL);

    default:
        AssertMsg(0, "Unknown value");
        return FALSE;
    }
}


/***************************************************************************\
*
* DuRootGadget::xdHandleKeyboardMessage
*
* xdHandleKeyboardMessage() is called by the DuContainer to process keyboard
* messages inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleKeyboardMessage(
    IN  GMSG_KEYBOARD * pmsg,       // Message to handle
    IN  UINT nMsgFlags)             // Message flags
{
    CoreSC * pSC = GetCoreSC();

    //
    // NOTE: 
    // 
    // For non-Adaptor Gadgets:
    // We need to signal that the message was NOT completely handled.  If we 
    // say that it isn't completely handled, the message will get sent again by
    // the original (non-subclassed) WNDPROC.  If was say the message was 
    // handled, then it won't be passed to the original WNDPROC.  If it isn't
    // sent to the original WNDPROC, this can mess things up for keyboard 
    // messages that the system handles, such as starting the menus.
    //
    // For Adaptor Gadgets:
    // Need to signal that the message is completely handled because we DON'T
    // want to forward the message to DefWindowProc() because it was originally
    // meant for the Adaptor window.
    //

    if (pSC->pgadCurKeyboardFocus != NULL) {
        BOOL fAdaptor = pSC->pgadCurKeyboardFocus->m_fAdaptor;

        if (fAdaptor && (!TestFlag(nMsgFlags, DuContainer::mfForward))) {
            //
            // Don't allow NON forwarded messages to be sent to an Adaptor.
            // These were originally sent to the DuRootGadget and should NOT be
            // forwarded outside.  If we do forward them to the Adaptor, this 
            // can (and often will) create an infinite loop of messages being
            // sent from a child Adaptor to the parentand then back to the 
            // child.
            //

            return FALSE;
        }

        pSC->pgadCurKeyboardFocus->m_cb.xdFireKeyboardMessage(pSC->pgadCurKeyboardFocus, pmsg);

        return fAdaptor;
    }

    return FALSE;  // Not completely handled
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateKeyboardFocus
*
* xdUpdateKeyboardFocus() simulates keyboard focus between different Gadgets 
* by updating where focus is "set".  A Gadget must have GS_KEYBOARDFOCUS 
* set to "receive" focus.
*
\***************************************************************************/

BOOL
DuRootGadget::xdUpdateKeyboardFocus(
    IN  DuVisual * pgadNew)       // New Gadget with focus
{
    if (m_fUpdateFocus) {
        return TRUE;
    }

    if (m_fFinalDestroy) {
        pgadNew = NULL;
    }

    m_fUpdateFocus          = TRUE;
    DuVisual * pgadCur    = pgadNew;

    //
    // First, check if loosing the focus (special case)
    //

    if (pgadNew == NULL) {
        goto Found;
    }

    //
    // Find keyboard focusable ancestor -- if none, then remove focus (indicated by pgadCur being NULL)
    //

    pgadCur = GetKeyboardFocusableAncestor(pgadCur);

Found:
    CoreSC * pSC            = GetCoreSC();
    if (pSC->pgadCurKeyboardFocus != pgadCur) {
        //
        // Found a candidate.  We need to do several things:
        // 1. Notify the old gadget that it no longer has focus.
        // 2. Notify the new gadget that it now has focus.
        // 3. Update the last gadget focus (this is used when our container
        //    gets a GM_CHANGEFOCUS message.
        //

        HGADGET hgadLost    = (HGADGET) ::GetHandle(pSC->pgadCurKeyboardFocus);
        HGADGET hgadSet     = (HGADGET) ::GetHandle(pgadCur);

        if (pSC->pgadCurKeyboardFocus != NULL) {
            pSC->pgadCurKeyboardFocus->m_cb.xdFireChangeState(pSC->pgadCurKeyboardFocus, GSTATE_KEYBOARDFOCUS, hgadLost, hgadSet, GSC_LOST);
            pSC->pgadLastKeyboardFocus = pSC->pgadCurKeyboardFocus;
        }

        pSC->pgadCurKeyboardFocus  = NULL;

        if (pgadCur != NULL) {
            if (!pgadCur->m_fAdaptor) {
                GetContainer()->OnSetFocus();
            }
            pgadCur->m_cb.xdFireChangeState(pgadCur, GSTATE_KEYBOARDFOCUS, hgadLost, hgadSet, GSC_SET);
            pSC->pgadLastKeyboardFocus = pgadCur;
        }

        pSC->pgadCurKeyboardFocus  = pgadCur;
    }

    m_fUpdateFocus = FALSE;

#if 0
    if (pgadNew != pgadCur) {
        Trace("WARNING: DUser: xdUpdateKeyboardFocus() requested 0x%p, got 0x%p\n", pgadNew, pgadCur);
        if (pgadNew != NULL) {
            Trace("  pgadNew: Adaptor: %d\n", pgadNew->m_fAdaptor);
        }
        if (pgadCur != NULL) {
            Trace("  pgadCur: Adaptor: %d\n", pgadCur->m_fAdaptor);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\gpaint.cpp ===
/***************************************************************************\
*
* File: GPaint.cpp
*
* Description:
* GPaint.cpp implements standard DuVisual drawing and painting functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

#define ENABLE_GdiplusAlphaLevel    0   // Use new GDI+ Graphics::AlphaLevel attribute

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL
GdDrawOutlineRect(DuSurface * psrf, const RECT * prcPxl, UINT idxColor, int nThickness)
{
    switch (psrf->GetType())
    {
    case DuSurface::stDC:
        return GdDrawOutlineRect(CastHDC(psrf), prcPxl, GetStdColorBrushI(idxColor), nThickness);

    case DuSurface::stGdiPlus:
        return GdDrawOutlineRect(CastGraphics(psrf), prcPxl, GetStdColorBrushF(idxColor), nThickness);

    default:
        AssertMsg(0, "Unsupported surface");
        return FALSE;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::DrawFill
*
* DrawFill() provides a wrapper used to fill a rectangle with the attached
* background fill.
*
\***************************************************************************/

void        
DuVisual::DrawFill(
    IN  DuSurface * psrf,             // Surface drawing into
    IN  const RECT * prcDrawPxl)    // Rectangle to fill
{
    AssertMsg(m_fBackFill, "Only call when filling");

    FillInfo * pfi;
    VerifyHR(m_pds.GetData(s_pridBackFill, (void **) &pfi));

    if (psrf->GetType() == pfi->type) {
        switch (pfi->type)
        {
        case DuSurface::stDC:
            {
                HDC hdcDraw = CastHDC(psrf);
                if (pfi->bAlpha != BLEND_OPAQUE) {
                    GdDrawBlendRect(hdcDraw, prcDrawPxl, pfi->hbrFill, pfi->bAlpha, pfi->sizeBrush.cx, pfi->sizeBrush.cy);
                } else {
                    FillRect(hdcDraw, prcDrawPxl, pfi->hbrFill);
                }
            }
            break;

        case DuSurface::stGdiPlus:
            {
                Gdiplus::Graphics * pgpgr = CastGraphics(psrf);
                Gdiplus::RectF rc = Convert(prcDrawPxl);
                pgpgr->FillRectangle(pfi->pgpbr, rc);
            }
            break;

        default:
            AssertMsg(0, "Unsupported surface");
        }
    }
}


#if DEBUG_DRAWSTATS
volatile static int s_cDrawEnter    = 0;
volatile static int s_cDrawVisible  = 0;
volatile static int s_cDrawDrawn    = 0;

class DumpDrawStats
{
public:
    ~DumpDrawStats()
    {
        char szBuffer[2048];
        wsprintf(szBuffer, "Draw Enter: %d,  Visible: %d,  Drawn: %d\n", 
                s_cDrawEnter, s_cDrawVisible, s_cDrawDrawn);

        OutputDebugString(szBuffer);
    }
} g_DumpDrawStats;
#endif // DEBUG_DRAWSTATS

#if DEBUG_MARKDRAWN
volatile BOOL g_fFlagDrawn   = FALSE;
#endif // DEBUG_MARKDRAWN


/***************************************************************************\
*
* DuVisual::xrDrawCore
*
* xrDrawCore() provides the core drawing loop for an individual Gadget and 
* its children.  It is assumed that the HDC and Matricies have already been
* properly setup with clipping, XForm, etc. information.
*
\***************************************************************************/

void        
DuVisual::xrDrawCore(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const RECT * prcGadgetPxl)  // Location of Gadget in logical pixels
{
#if DBG_STORE_NAMES
    if (m_DEBUG_pszName == NULL) {
        m_cb.xrFireQueryName(this, &m_DEBUG_pszName, &m_DEBUG_pszType);
    }
#endif // DBG_STORE_NAMES
    
#if ENABLE_OPTIMIZEDIRTY
    //
    // We only need to be painted if we are specifically marked as invalid.
    //

    if (ppi->fDirty) {
#endif

        DuSurface * psrfDraw = ppi->psrf;

        //
        // prcCurInvalidPxl has not yet always been clipped to this Gadget.
        // However, before handing it out to anyone, we should clip it to this
        // Gadget.  If we don't do this, bad things will happen since everyone 
        // assumes that the invalid pixels are "within" the Gadget.  They have 
        // already been properly offsetted into client coordinates.
        //

        RECT rcInvalidPxl;
        InlineIntersectRect(&rcInvalidPxl, prcGadgetPxl, ppi->prcCurInvalidPxl);


        //
        // Draw a background, if one is given.
        //

        if (m_fBackFill) {
            DrawFill(psrfDraw, &rcInvalidPxl);
        }


        //
        // Draw this node
        //

        switch (psrfDraw->GetType())
        {
        case DuSurface::stDC:
            m_cb.xrFirePaint(this, CastHDC(psrfDraw), prcGadgetPxl, &rcInvalidPxl);
            break;

        case DuSurface::stGdiPlus:
            m_cb.xrFirePaint(this, CastGraphics(psrfDraw), prcGadgetPxl, &rcInvalidPxl);
            break;

        default:
            AssertMsg(0, "Unsupported surface");
        }

#if ENABLE_OPTIMIZEDIRTY
    }
#endif

#if DBG
    if (s_DEBUG_pgadOutline == this) {
        GdDrawOutlineRect(psrfDraw, prcGadgetPxl, SC_MediumPurple, 2);
    }
#endif // DBG

#if DEBUG_MARKDRAWN
    if (m_fMarkDrawn) {
        GdDrawOutlineRect(psrfDraw, prcGadgetPxl, SC_SlateBlue);
    }
#endif
}


/***************************************************************************\
*
* DuVisual::DrawPrepareClip
*
* DrawPrepareClip() sets up a surface with clipping information for the 
* specifed Gadget.
*
\***************************************************************************/

int 
DuVisual::DrawPrepareClip(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const RECT * prcGadgetPxl,  // Location of Gadget in logical pixels
    OUT void ** ppvOldClip          // Previous clip region
    ) const
{
    *ppvOldClip = NULL;

    if (!m_fClipInside) {
        // No clipping, so just bypass.  Return a valid "psuedo-region" type.
        return SIMPLEREGION;
    }

    DuSurface * psrfDraw = ppi->psrf;
    switch (psrfDraw->GetType())
    {
    case DuSurface::stDC:
        {
            HDC hdcDraw = CastHDC(psrfDraw);
            GdiCache * pGdiCache = GetGdiCache();

            //
            // Backup the existing clipping region.  Do this by grabbing a temporary
            // region and storing the existing region.  
            //
            // NOTE: If there is not clipping region (nResult == 0), release the 
            // temporary region now.
            //

            HRGN hrgnOldClip = pGdiCache->GetTempRgn();
            if (hrgnOldClip == NULL) {
                return ERROR;
            }

            int nResult = GetClipRgn(hdcDraw, hrgnOldClip);
            if (nResult == -1) {
                //
                // An error occurred
                //
                
                pGdiCache->ReleaseTempRgn(hrgnOldClip);
                return ERROR;
            } else if (nResult == 0) {
                //
                // No clipping region
                //
                
                pGdiCache->ReleaseTempRgn(hrgnOldClip);
                hrgnOldClip = NULL;
            }
            *ppvOldClip = hrgnOldClip;


            //
            // Clip drawing inside this Gadget.  The clipping region must be in 
            // device coordinates, which means that our beautiful world transforms 
            // are ignored.
            //
            // Build the region and RGN_AND it with the current clipping region.  This 
            // way, we get the intersection of this Gadget's clipping region and its 
            // parent's clipping region.  Thus, the drawing will not "spill" outside of
            // all of the levels of containment.
            //
            // Since we do this AND'ing, we store the previous clipping region and 
            // restore it when finished.
            //

            HRGN hrgnClip = GetThread()->hrgnClip;
            ppi->pmatCurDC->ComputeRgn(hrgnClip, prcGadgetPxl, ppi->sizeBufferOffsetPxl);

            nResult = ExtSelectClipRgn(hdcDraw, hrgnClip, RGN_AND);

            return nResult;
        }

    case DuSurface::stGdiPlus:
        {
            Gdiplus::Graphics * pgpgr = CastGraphics(psrfDraw);

            //
            // Backup the old clipping region
            //

            Gdiplus::Region * pgprgnOldClip = new Gdiplus::Region();
            if (pgprgnOldClip == NULL) {
                return ERROR;
            }
            
            pgpgr->GetClip(pgprgnOldClip);
            *ppvOldClip = pgprgnOldClip;


            //
            // Setup a new clipping region.  Unlike GDI, GDI+ will apply 
            // XForm's to the region.
            //

            RECT rcClipPxl;
            InlineIntersectRect(&rcClipPxl, prcGadgetPxl, ppi->prcCurInvalidPxl);

            Gdiplus::RectF rcGadget(Convert(&rcClipPxl));

            pgpgr->SetClip(rcGadget, Gdiplus::CombineModeIntersect);

            if (pgpgr->IsClipEmpty()) {
                return NULLREGION;
            } else {
                return COMPLEXREGION;
            }
        }

    default:
        AssertMsg(0, "Unknown surface type");
        return ERROR;
    }
}


/***************************************************************************\
*
* DuVisual::DrawCleanupClip
*
* DrawCleanupClip() cleans up clipping information set on a DC during the
* drawing of a Gadget subtree.
*
\***************************************************************************/

void
DuVisual::DrawCleanupClip(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  void * pvOldClip            // Previous clip region
    ) const
{
    if (!m_fClipInside) {
        return;
    }

    DuSurface * psrfDraw = ppi->psrf;
    switch (psrfDraw->GetType())
    {
    case DuSurface::stDC:
        {
            HDC hdcDraw = CastHDC(psrfDraw);
            HRGN hrgnOldClip = reinterpret_cast<HRGN>(pvOldClip);

            //
            // Restore the original clipping region (the clipping region of this
            // Gadget's parent).
            //
            // NOTE: hrgnOldClip may be NULL if there was no original clipping region.
            // In this case, the clipping region has already been released, so don't 
            // need to do this again.
            //

            ExtSelectClipRgn(hdcDraw, hrgnOldClip, RGN_COPY);

            if (hrgnOldClip != NULL) {
                GetGdiCache()->ReleaseTempRgn(hrgnOldClip);
            }
        }
        break;

    case DuSurface::stGdiPlus:
        {
            Gdiplus::Graphics * pgpgr = CastGraphics(psrfDraw);
            Gdiplus::Region * pgprgn = reinterpret_cast<Gdiplus::Region *>(pvOldClip);

            pgpgr->SetClip(pgprgn);

            if (pgprgn != NULL) {
                delete pgprgn;
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
    }
}


/***************************************************************************\
*
* DuVisual::xrDrawStart
*
* xrDrawStart() kicks off the the drawing process by ensuring that 
* everything is ready.
*
\***************************************************************************/

void        
DuVisual::xrDrawStart(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  UINT nFlags)                // Drawing flags
{
#if DEBUG_DRAWSTATS
    s_cDrawEnter++;
#endif

    //
    // Skip out if the DuVisual is not visible and not forcably being 
    // rendered.
    //

    BOOL fOldVisible = m_fVisible;
    if (TestFlag(nFlags, GDRAW_SHOW)) {
        m_fVisible = TRUE;
    }

    ClearFlag(nFlags, GDRAW_SHOW);  // Only force shown for top level

    if (!IsVisible()) {
        goto Exit;
    }

    xrDrawFull(ppi);

    ResetInvalid();

Exit:
    m_fVisible = fOldVisible;
}


/***************************************************************************\
*
* DuVisual::DrawSetupBufferCommand
*
* DrawSetupBufferCommand() sets up the buffer to perform some buffering
* operation.
*
\***************************************************************************/

void
DuVisual::DrawSetupBufferCommand(
    IN  const RECT * prcBoundsPxl,
    OUT SIZE * psizeBufferOffsetPxl,
    OUT UINT * pnCmd
    ) const
{
    UINT nCmd = 0;

    //
    // TODO: If performing more complicated buffering operations (such as 
    // applying an alpha blend), need to setup here.
    //


    //
    // Need to copy the background over if:
    // - We are not opaque AND we are not doing some complex alpha-blending
    //   stuff.
    //


    //
    // Copy back remaining settings
    //

    psizeBufferOffsetPxl->cx = -prcBoundsPxl->left;
    psizeBufferOffsetPxl->cy = -prcBoundsPxl->top;
    *pnCmd = nCmd;
}


/***************************************************************************\
*
* DuVisual::xrDrawFull
*
* xrDrawFull() provides the low-level DuVisual drawing function to draw a 
* DuVisual and its subchildren.  This function should not be called 
* directly from outside.  Instead, external callers should use 
* DuRootGadget::xrDrawTree() to properly initialize drawing.
*
* As the DuVisual tree is walked in a depth-first manner, any DuVisual 
* XForm is applied to both the HDC and the PaintInfo.Matrix.  If a 
* DuVisual's bounding rectangle (logical rect with XForm's applied) is 
* applied and is determined to be outside the invalid rectangle, both that 
* DuVisual and its entire sub-tree are skipped.
*
\***************************************************************************/

void        
DuVisual::xrDrawFull(
    IN  PaintInfo * ppi)            // Painting information for this Gadget
{
#if DEBUG_DRAWSTATS
    s_cDrawEnter++;
#endif

    //
    // Check entry conditions
    //

    if (!m_fVisible) {
        return;  // DuVisual is still not visible, so don't draw.
    }
    AssertMsg(IsVisible(), "Should match just checking m_fVisible b/c recursive");
    AssertMsg(!IsRectEmpty(ppi->prcOrgInvalidPxl), "Must have non-empty invalid area to draw");

#if DEBUG_DRAWSTATS
    s_cDrawVisible++;
#endif


    //
    // Keep track of the different items that may need to be "popped" off the
    // stack at the end of this iteration.
    //

    PaintInfo piNew;
    HRESULT hr;

#if DBG
    memset(&piNew, 0xBA, sizeof(piNew));
#endif // DBG

    piNew.psrf                  = ppi->psrf;
    piNew.prcOrgInvalidPxl      = ppi->prcOrgInvalidPxl;
    piNew.fBuffered             = ppi->fBuffered;
    piNew.sizeBufferOffsetPxl   = ppi->sizeBufferOffsetPxl;
#if ENABLE_OPTIMIZEDIRTY
    piNew.fDirty                = ppi->fDirty | m_fInvalidDirty;
#endif


    //
    // Setup common operations for caching and buffering:
    // - Disable any world transformations on the destination.  We will draw 
    //   into the buffer with the world transformations, but we don't need
    //   to apply the world transformations on the buffer when we commit it to
    //   the destination.
    //

    //
    // Setup if cached
    // TODO: Need to totally rewrite this
    //

    BmpBuffer * pbufBmp = NULL;
    BOOL fNewBuffer = FALSE;
    BOOL fNewCache = FALSE;
#if ENABLE_GdiplusAlphaLevel
    BOOL fConstantAlpha = FALSE;
    float flOldAlphaLevel = 1.0f;       // Old alpha-level for this sub-tree
#endif

    if (m_fCached) {
SetupCache:
        BmpBuffer * pbufNew;
        hr = GetBufferManager()->GetCachedBuffer(ppi->psrf->GetType(), &pbufNew);
        if (FAILED(hr)) {
            //
            // If can't cache, can't draw.
            //
            // TODO: Need to figure out how to propagate error conditions 
            // during drawing.
            //
            return;
        }

        ppi->psrf->SetIdentityTransform();
        pbufBmp = pbufNew;


        //
        // Because we redraw everything inside a cache, we need to compute 
        // a new bounding box for the entire Gadget and new invalidation boxes
        // for this subtree.
        //

        //
        // TODO: Need to change invalidation to support caching.
        // - When a child of an GS_CACHED Gadget is invalidated, need to 
        //   invalidate the _entire_ cached Gadget.  This is because pixels can
        //   get moved all around (for example, with a convolution).
        // - Change painting so that if the GS_CACHED Gadget is dirty, it spawns
        //   off and redraws that Gadget.  When finished, commits the drawing 
        //   back.
        // - If not dirty, just directly copy without calling xrDrawCore() or
        //   drawing any children.
        //

        UINT nCmd;                  // Buffer drawing command
        RECT rcClientPxl;           // Size of this Gadget (sub-tree)
        RECT rcBoundsPxl;           // Bounding area (in Container pixels) of this sub-tree
        RECT rcDrawPxl;             // Destination area being redrawn
        SIZE sizeBufferOffsetPxl;   // New offset to account for buffer
        Matrix3 matThis;            // XForm's for this sub-tree

        GetLogRect(&rcClientPxl, SGR_CLIENT);
        BuildXForm(&matThis);
        matThis.ComputeBounds(&rcBoundsPxl, &rcClientPxl, HINTBOUNDS_Clip);

        rcDrawPxl = rcBoundsPxl;
        OffsetRect(&rcDrawPxl, ppi->sizeBufferOffsetPxl.cx, ppi->sizeBufferOffsetPxl.cy);

        DrawSetupBufferCommand(&rcBoundsPxl, &sizeBufferOffsetPxl, &nCmd);

        DuSurface * psrfNew;
        hr = pbufBmp->BeginDraw(ppi->psrf, &rcDrawPxl, nCmd, &psrfNew);
        if (FAILED(hr) || (psrfNew == NULL)) {
            GetBufferManager()->ReleaseCachedBuffer(pbufNew);
            return;
        }

        fNewCache       = TRUE;
        piNew.psrf      = psrfNew;
        piNew.fBuffered = TRUE;
        piNew.sizeBufferOffsetPxl = sizeBufferOffsetPxl;
    } else {
        //
        // Only can (need to) buffer if not cached.
        //
        // If not changing the alpha value, we only need to double-buffer this 
        // specific form if we haven't started double-buffering.
        //

        if (m_fBuffered) {
            if (!ppi->fBuffered) {
                UINT nCmd;                  // Buffer drawing command
                SIZE sizeBufferOffsetPxl;   // New offset to account for buffer
                const RECT * prcDrawPxl = ppi->prcCurInvalidPxl;

                AssertMsg((ppi->sizeBufferOffsetPxl.cx == 0) &&
                        (ppi->sizeBufferOffsetPxl.cy == 0), 
                        "Should still be at 0,0 because not yet buffering");

                DrawSetupBufferCommand(prcDrawPxl, &sizeBufferOffsetPxl, &nCmd);

                switch (ppi->psrf->GetType())
                {
                case DuSurface::stDC:
                    hr = GetBufferManager()->GetSharedBuffer(prcDrawPxl, (DCBmpBuffer **) &pbufBmp);
                    break;

                case DuSurface::stGdiPlus:
                    hr = GetBufferManager()->GetSharedBuffer(prcDrawPxl, (GpBmpBuffer **) &pbufBmp);
                    break;

                default:
                    AssertMsg(0, "Unsupported surface");
                    hr = DU_E_GENERIC;
                }

                //
                // Create a new surface for the buffer
                //

                if (SUCCEEDED(hr)) {
                    DuSurface * psrfNew;
                    ppi->psrf->SetIdentityTransform();
                    hr = pbufBmp->BeginDraw(ppi->psrf, prcDrawPxl, nCmd, &psrfNew);
                    if (SUCCEEDED(hr) && (psrfNew != NULL)) {
                        fNewBuffer      = TRUE;
                        piNew.psrf      = psrfNew;
                        piNew.fBuffered = TRUE;
                        piNew.sizeBufferOffsetPxl = sizeBufferOffsetPxl;
                    } else {
                        //
                        // Unable to successfully create the surface, we need to release
                        // the buffer
                        //

                        GetBufferManager()->ReleaseSharedBuffer(pbufBmp);
                        pbufBmp = NULL;
                    }
                }
            } else {
#if ENABLE_GdiplusAlphaLevel
            
                //
                // Using buffering to achieve fading.
                //
            
                const BUFFER_INFO * pbi = GetBufferInfo();

                switch (ppi->psrf->GetType())
                {
                case DuSurface::stDC:
                    //
                    // GDI doesn't support constant alpha on all operations, 
                    // so we need to draw into a buffer.
                    //
                    
                    if (pbi->bAlpha != BLEND_OPAQUE) {
                        //
                        // This Gadget is being buffered, but has a non-opaque
                        // alpha level.  To accomplish this, treat it the same as 
                        // if it was explicitely cached.
                        //

                        goto SetupCache;
                    }
                    break;

                case DuSurface::stGdiPlus:
                    {
                        //
                        // GDI+ supports constant alpha, so use that directly.
                        //

                        Gdiplus::Graphics * pgpgr = CastGraphics(piNew.psrf);
                        float flOldAlphaLevel = pgpgr->GetAlphaLevel();

                        int nAlpha = pbi->bAlpha;
                        if (nAlpha == 0) {
                            //
                            // Nothing to render
                            //
                            
                            return;
                        } else if (nAlpha == BLEND_OPAQUE) {
                            //
                            // No new alpha-level for this sub-tree
                            //
                        } else {
                            //
                            // Factor this sub-tree's alpha into the Graphics
                            //
                            
                            float flNewAlphaLevel = flOldAlphaLevel * (nAlpha / (float) BLEND_OPAQUE);
                            pgpgr->SetAlphaLevel(flNewAlphaLevel);
                            fConstantAlpha = TRUE;
                        }
                    }
                    break;

                default:
                    AssertMsg(0, "Unsupported surface");
                    hr = DU_E_GENERIC;
                }

#else // ENABLE_GdiplusAlphaLevel

                const BUFFER_INFO * pbi = GetBufferInfo();
                if (pbi->bAlpha != BLEND_OPAQUE) {
                    //
                    // This Gadget is being buffered, but has a non-opaque
                    // alpha level.  To accomplish this, treat it the same as 
                    // if it was explicitely cached.
                    //

                    goto SetupCache;
                }

#endif // ENABLE_GdiplusAlphaLevel

            }
        }
    }


    //
    // Prefill the new buffer
    //

    if (pbufBmp != NULL) {
        if (m_fBuffered) {
            const BUFFER_INFO * pbi = GetBufferInfo();
            if (TestFlag(pbi->nStyle, GBIS_FILL)) {
                pbufBmp->Fill(pbi->crFill);
            }
        }
    }


    //
    // Use positioning, transforms, etc. to determine where the DuVisual will
    // be drawn on the screen.
    //

    RECT rcGadgetPxl;
    GetLogRect(&rcGadgetPxl, SGR_PARENT);

    BOOL fTranslate = ((rcGadgetPxl.left != 0) || (rcGadgetPxl.top != 0));

    float flxGadgetOffset, flyGadgetOffset;
    flxGadgetOffset = (float) rcGadgetPxl.left;
    flyGadgetOffset = (float) rcGadgetPxl.top;

    XFormInfo * pxfi = NULL;

    //
    // New transformations must be first created independently, then
    // folded into the running matrix used to transform the invalid
    // rectangle.
    //
    // Order matters here.  It has to be the INVERSE of whatever 
    // GDI World Transforms we setup to draw with.  This is because we are 
    // applying the Matrix on invalid rectangle instead of the actually 
    // drawing.
    //

    Matrix3 matNewInvalid   = *ppi->pmatCurInvalid;
    piNew.pmatCurInvalid    = &matNewInvalid;
    if (m_fXForm) {
        pxfi = GetXFormInfo();

        Matrix3 matOp;
        pxfi->ApplyAnti(&matOp);
        matNewInvalid.ApplyRight(matOp);
    }

    if (fTranslate) {
        //
        // When we are only performing translation, so we don't need to use the
        // matrix to modify the invalid rect and perform hit testing.
        //

        matNewInvalid.Translate(-flxGadgetOffset, -flyGadgetOffset);
    } 


    //
    // Check if actually need to draw by computing the bounds of the DuVisual to
    // be drawn.  If this DuVisual intersects the invalid region, it should be
    // drawn.  We also intersect the bounds with the parents bounds to not 
    // include the portion of child DuVisuals that overflow outside their parents.
    //
    // Intersect the current DuVisual's rectangle with the invalid region to 
    // determine if we need to draw it.
    //

    bool fIntersect;
    RECT rcNewInvalidPxl;
    piNew.prcCurInvalidPxl = &rcNewInvalidPxl;
    if (m_fXForm) {    
        //
        // Since we are rotating or scaling, we need the full translation 
        // matrix to modify the invalid rect properly.  (No guessing).
        //

        matNewInvalid.ComputeBounds(&rcNewInvalidPxl, ppi->prcOrgInvalidPxl, HINTBOUNDS_Invalidate);
    } else {
        //
        // Perform a simple invalidation intersection without a Matrix
        // transformation.
        //

        rcNewInvalidPxl = *ppi->prcCurInvalidPxl;
        if (fTranslate) {
            InlineOffsetRect(&rcNewInvalidPxl, -rcGadgetPxl.left, -rcGadgetPxl.top);
        }
    }

    if (fTranslate) {
        InlineZeroRect(&rcGadgetPxl);
    }

    RECT rcDummy = rcNewInvalidPxl;
    fIntersect = InlineIntersectRect(&rcNewInvalidPxl, &rcDummy, &rcGadgetPxl);

    //
    // Draw this DuVisual if it intersects with the logical invalid area.
    //

#if DEBUG_MARKDRAWN
    if (g_fFlagDrawn) {
        m_fMarkDrawn = fIntersect;
    }
#endif

    BOOL fCleanedUp = FALSE;
    if (fIntersect) {
#if DEBUG_DRAWSTATS
        s_cDrawDrawn++;
#endif

        //
        // Set DC to be the same as the current Matrix.  We only do this if we
        // are actually going to draw this Gadget (and its children), which is
        // why we didn't do this when we were calculating the intersection 
        // matrix earlier.
        //
        // Right before calling the GDI operation to modify the DC, we need to 
        // also offset by the current buffer offset.  We do a similar thing 
        // when setting up the DC, but this is not reflected in pmatCurDC 
        // because it must be the last operation in the Matrix pipeline.
        //

        Matrix3 matNewDC    = *ppi->pmatCurDC;
        piNew.pmatCurDC     = &matNewDC;

        if (fTranslate) {
            matNewDC.Translate(flxGadgetOffset, flyGadgetOffset);
        }

        if (m_fXForm) {
            AssertMsg(pxfi != NULL, "pxfi must have previously been set");
            pxfi->Apply(&matNewDC);
        }

        XFORM xfNew;
        matNewDC.Get(&xfNew);

        xfNew.eDx += (float) piNew.sizeBufferOffsetPxl.cx;
        xfNew.eDy += (float) piNew.sizeBufferOffsetPxl.cy;

        if (TestFlag(m_cb.GetFilter(), GMFI_PAINT) || 
#if DBG
                (s_DEBUG_pgadOutline == this) ||
#endif // DBG
                m_fBackFill || 
                m_fDeepTrivial) {

            piNew.psrf->SetWorldTransform(&xfNew);
        }


        //
        // At this point, we should NOT use ppi any more because piNew has been
        // fully setup.  If we do use pi, we will be rendering into our parent.
        //

#if DBG
        ppi = (PaintInfo *) UIntToPtr(0xFADEFADE);
#endif // DBG


        //
        // Inner loop:
        // - Setup any clipping on the DC
        // - Draw the Gadget and its children
        //

        void * pvOldClip = NULL;
        int nResult = DrawPrepareClip(&piNew, &rcGadgetPxl, &pvOldClip);
        if ((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION)) {
            //
            // Save state
            //

            void * pvPaintSurfaceState = NULL;
            if (m_fDeepPaintState) {
                pvPaintSurfaceState = piNew.psrf->Save();
            }
#if DBG
            void * DEBUG_pvSurfaceState = NULL;
            if (s_DEBUG_pgadOutline == this) {
                DEBUG_pvSurfaceState = piNew.psrf->Save();
            }
#endif // DBG

            if (fNewCache) {
                pbufBmp->SetupClipRgn();
            }

            xrDrawCore(&piNew, &rcGadgetPxl);

            //
            // Draw each of the children from back to front
            //

            if (m_fDeepTrivial) {
                //
                // Since we are trivial, all of our children are trivial.  This 
                // means that we can optimize the rendering path.  We ourselves
                // could not be optimized because some of our siblings may not
                // have been trivial and may have done complicated things that
                // forced us to go through the full rendering path.
                //

                SIZE sizeOffsetPxl = { 0, 0 };
                DuVisual * pgadCur = GetBottomChild();
                while (pgadCur != NULL) {
                    pgadCur->xrDrawTrivial(&piNew, sizeOffsetPxl);
                    pgadCur = pgadCur->GetPrev();
                }
            } else {
                DuVisual * pgadCur = GetBottomChild();
                while (pgadCur != NULL) {
                    pgadCur->xrDrawFull(&piNew);
                    pgadCur = pgadCur->GetPrev();
                }
            }


            //
            // At this point, we can not do any more drawing on this Gadget 
            // because the DC is setup of one of this Gadget's grand-children.
            //

            //
            // Restore State
            //

#if DBG
            if (s_DEBUG_pgadOutline == this) {
                piNew.psrf->Restore(DEBUG_pvSurfaceState);
                GdDrawOutlineRect(piNew.psrf, &rcGadgetPxl, SC_Indigo, 1);
            }
#endif // DBG

            if (m_fDeepPaintState) {
                piNew.psrf->Restore(pvPaintSurfaceState);
            }

            //
            // Commit the results.  We need to do this before we exit the 
            // "drawing" area since the surfaces are "correctly" setup.
            //

            AssertMsg(((!fNewBuffer) ^ (!fNewCache)) ||
                    ((!fNewBuffer) && (!fNewCache)), 
                    "Can not have both a new buffer and a cache");

            fCleanedUp = TRUE;

            if (pbufBmp != NULL) {
                pbufBmp->PreEndDraw(TRUE /* Commit */);

                BYTE bAlphaLevel    = BLEND_OPAQUE;
                BYTE bAlphaFormat   = 0;
                if (fNewCache) {
                    if (m_fCached) {
                        m_cb.xrFirePaintCache(this, CastHDC(piNew.psrf), &rcGadgetPxl, &bAlphaLevel, &bAlphaFormat);
                    } else {
                        const BUFFER_INFO * pbi = GetBufferInfo();
                        bAlphaLevel = pbi->bAlpha;
                    }
                }

                pbufBmp->EndDraw(TRUE /* Commit */, bAlphaLevel, bAlphaFormat);
            }
        }

        if (nResult != ERROR) {
            DrawCleanupClip(&piNew, pvOldClip);
        }
    }

    //
    // Clean-up any created buffers
    //

#if ENABLE_GdiplusAlphaLevel
    if (fConstantAlpha) {
        CastGraphics(piNew.psrf)->SetAlphaLevel(flOldAlphaLevel);
    }
#endif    
    
    if (pbufBmp != NULL) {
        if (!fCleanedUp) {
            //
            // Clean-up:
            // Didn't actually draw for some reason, so don't need to commit the 
            // results.
            //

            pbufBmp->PreEndDraw(FALSE /* Don't commit */);
            pbufBmp->EndDraw(FALSE /* Don't commit */);
        }
        pbufBmp->PostEndDraw();

        if (fNewCache) {
            GetBufferManager()->ReleaseCachedBuffer((DCBmpBuffer *) pbufBmp);
        } else if (fNewBuffer) {
            GetBufferManager()->ReleaseSharedBuffer(pbufBmp);
        }

        piNew.psrf->Destroy();
    }


#if DEBUG_MARKDRAWN
    if (IsRoot()) {
        g_fFlagDrawn = FALSE;
    }
#endif
}


/***************************************************************************\
*
* DuVisual::xrDrawTrivial
*
* xrDrawTrivial provides an massively simplified code-path that can be 
* executed when an entire subtree is trivial.  Whenever this can be executed
* instead of xrDrawFull(), the rendering can be much faster.  This is 
* because we don't need to worry about expensive operations that force the
* rendering to recalculate its output coordinate system.
*
\***************************************************************************/

void
DuVisual::xrDrawTrivial(
    IN  PaintInfo * ppi,            // Painting information for this Gadget
    IN  const SIZE sizeOffsetPxl)
{
    AssertMsg(m_fDeepTrivial, "Entire subtree must be trivial");

    if (!m_fVisible) {
        return;
    }


    RECT rcGadgetPxl;
    GetLogRect(&rcGadgetPxl, SGR_PARENT);
    InlineOffsetRect(&rcGadgetPxl, sizeOffsetPxl.cx, sizeOffsetPxl.cy);

    RECT rcIntersectPxl;
    BOOL fIntersect = InlineIntersectRect(&rcIntersectPxl, &rcGadgetPxl, ppi->prcCurInvalidPxl);
    if (!fIntersect) {
        return;
    }

    void * pvOldClip;
    int nResult = DrawPrepareClip(ppi, &rcGadgetPxl, &pvOldClip);
    if ((nResult == SIMPLEREGION) || (nResult == COMPLEXREGION)) {
        //
        // Save state
        //

        void * pvPaintSurfaceState = NULL;
        if (m_fDeepPaintState) {
            pvPaintSurfaceState = ppi->psrf->Save();
        }
#if DBG
        void * DEBUG_pvSurfaceState = NULL;
        if (s_DEBUG_pgadOutline == this) {
            DEBUG_pvSurfaceState = ppi->psrf->Save();
        }
#endif // DBG


        xrDrawCore(ppi, &rcGadgetPxl);

        //
        // Draw each of the children from back to front
        //

        DuVisual * pgadCur = GetBottomChild();
        while (pgadCur != NULL) {
            SIZE sizeNewOffsetPxl;
            sizeNewOffsetPxl.cx = rcGadgetPxl.left;
            sizeNewOffsetPxl.cy = rcGadgetPxl.top;

            pgadCur->xrDrawTrivial(ppi, sizeNewOffsetPxl);
            pgadCur = pgadCur->GetPrev();
        }


        //
        // Restore State
        //

#if DBG
        if (s_DEBUG_pgadOutline == this) {
            ppi->psrf->Restore(DEBUG_pvSurfaceState);
            GdDrawOutlineRect(ppi->psrf, &rcGadgetPxl, SC_Indigo, 1);
        }
#endif // DBG

        if (m_fDeepPaintState) {
            ppi->psrf->Restore(pvPaintSurfaceState);
        }
    }

    if (nResult != ERROR) {
        DrawCleanupClip(ppi, pvOldClip);
    }
}


/***************************************************************************\
*
* DuVisual::IsParentInvalid
*
* IsParentInvalid() returns if our parent has already been fully 
* invalidated.  When this occurs, we also have automatically been 
* invalidated.
*
\***************************************************************************/

BOOL
DuVisual::IsParentInvalid() const
{
    //
    // We can't use our m_fInvalidFull flag directly since we need to invalidate
    // every place we get moved to since we don't know if it is our final
    // destination.  We can use our parent's m_fInvalidFull flag since we will be 
    // automatically redrawn when our parent is redrawn because of composition.
    //

    DuVisual * pgadCur = GetParent();
    while (pgadCur != NULL) {
        if (pgadCur->m_fInvalidFull) {
            return TRUE;
        }
        pgadCur = pgadCur->GetParent();
    }

    return FALSE;
}


/***************************************************************************\
*
* DuVisual::Invalidate
*
* Invalidate() provides a convenient wrapper to invalidate an entire 
* DuVisual.
*
\***************************************************************************/

void        
DuVisual::Invalidate()
{
    //
    // Check state where we would not need to invalidate.
    //
    // NOTE: We can't use m_fInvalidFull because we need to invalidate our new
    // location so that we can actually be drawn there.
    //

    if (!IsVisible()) {
        return;
    }


    //
    // Mark this Gadget as completely invalid
    //

    m_fInvalidFull = TRUE;
    

    //
    // Before we actually invalidate this node, check if our parent is already
    // _fully_ invalid.  If this is the case, we don't need to actually 
    // invalidate.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
        if (IsParentInvalid()) {
            return;
        }
    }


    //
    // Do the invalidation.
    //

    RECT rcClientPxl;
    rcClientPxl.left    = 0;
    rcClientPxl.top     = 0;
    rcClientPxl.right   = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    rcClientPxl.bottom  = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    DoInvalidateRect(GetContainer(), &rcClientPxl, 1);
}


/***************************************************************************\
*
* DuVisual::InvalidateRects
*
* Invalidate() provides a convenient wrapper to invalidate a collection
* of areas in a DuVisual.
*
\***************************************************************************/

void        
DuVisual::InvalidateRects(
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    AssertReadPtr(rgrcClientPxl);
    Assert(cRects > 0);

    //
    // Check state where we would not need to invalidate.
    //
    // NOTE: We can't use m_fInvalidFull because we need to invalidate our new
    // location so that we can actually be drawn there.
    //

    if (!IsVisible()) {
        return;
    }


    //
    // We can't mark this Gadget as completely invalid because the rects may
    // not cover the entire area.
    //

    //
    // Before we actually invalidate this node, check if our parent is already
    // _fully_ invalid.  If this is the case, we don't need to actually 
    // invalidate.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
        if (IsParentInvalid()) {
            return;
        }
    }


    //
    // Intersect each rectangle with our boundaries and do the invalidation.
    //

    DuContainer * pcon = GetContainer();

    RECT rcClientPxl;
    rcClientPxl.left    = 0;
    rcClientPxl.top     = 0;
    rcClientPxl.right   = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    rcClientPxl.bottom  = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    RECT * rgrcClipPxl = (RECT *) _alloca(sizeof(RECT) * cRects);
    for (int idx = 0; idx < cRects; idx++) {
        InlineIntersectRect(&rgrcClipPxl[idx], &rcClientPxl, &rgrcClientPxl[idx]);


        //
        // Check if any resulting rectangle completely fills the entire Gadget.
        // We can optimize this to be the same as Invalidate().
        //

        if (InlineEqualRect(&rgrcClipPxl[idx], &rcClientPxl)) {
            m_fInvalidFull = TRUE;
            DoInvalidateRect(pcon, &rcClientPxl, 1);
            return;
        }
    }

    DoInvalidateRect(pcon, rgrcClipPxl, cRects);
}


/***************************************************************************\
*
* DuVisual::DoInvalidateRect
*
* DoInvalidateRect() is the worker function for invalidating a given 
* DuVisual.  The actually bounding rectangle is determined and is used to 
* invalidate the DuVisual.  This function is optimized for when invaliding 
* several DuVisuals at once inside a common container.
*
\***************************************************************************/

void        
DuVisual::DoInvalidateRect(
    IN  DuContainer * pcon,             // Container (explicit for perf reasons)
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    AssertMsg(IsVisible(), "DuVisual must be visible");
    AssertMsg(cRects > 0, "Must specify at least one rectangle");

    //
    // Need to check if pcon is NULL.  This will happen during shutdown when
    // the DuVisual tree is detached from the container.
    //

    if ((pcon == NULL) || 
        ((cRects == 1) && InlineIsRectEmpty(&rgrcClientPxl[0]))) {
        return;
    }

    AssertMsg(GetContainer() == pcon, "Containers must be the same");

    
    //
    // Compute a bounding rectangle that includes all XForms for the given
    // DuVisual.
    //
    // TODO: Need to change this so that we recursively walk up the tree 
    // applying a single XForm at each level.  This is necessary to support
    // Complex Gadgets which can prematurely stop the walk before it would
    // reach the container.
    //

    RECT * rgrcActualPxl = (RECT *) _alloca(cRects * sizeof(RECT));
    DoCalcClipEnumXForm(rgrcActualPxl, rgrcClientPxl, cRects);

    for (int idx = 0; idx < cRects; idx++) {
        //
        // Expand the rectangle out by one because XForms are inaccurate and 
        // sometimes are "off" by a 1 pixel in the upper left and 2 in the lower right
        //

        if (!InlineIsRectEmpty(&rgrcClientPxl[idx])) {
            RECT * prcCur = &rgrcActualPxl[idx];

            prcCur->left--;
            prcCur->top--;
            prcCur->right += 2;
            prcCur->bottom += 2;

            pcon->OnInvalidate(prcCur);
        }
    }


#if ENABLE_OPTIMIZEDIRTY
    //
    // Update m_fInvalidDirty.  We need to mark all of the parents and siblings 
    // as dirty until we hit an "opaque" node that will contain the 
    // invalidation.
    //

    for (DuVisual * pgadCur = this; pgadCur != NULL; pgadCur = pgadCur->GetParent()) {
        for (DuVisual * pgadSibling = pgadCur->GetPrev(); pgadSibling != NULL; pgadSibling = pgadSibling->GetPrev()) {
            pgadSibling->m_fInvalidDirty = TRUE;
        }

        pgadCur->m_fInvalidDirty = TRUE;
        if (pgadCur->m_fOpaque) {
            break;
        }

        for (DuVisual * pgadSibling = pgadCur->GetNext(); pgadSibling != NULL; pgadSibling = pgadSibling->GetNext()) {
            pgadSibling->m_fInvalidDirty = TRUE;
        }
    }
#endif
}

#if DBG
void
DuVisual::DEBUG_CheckResetInvalid() const
{
#if ENABLE_OPTIMIZEDIRTY
    AssertMsg((!m_fInvalidFull) && (!m_fInvalidChildren) && (!m_fInvalidDirty), 
            "Invalid must be reset");
#else
    AssertMsg((!m_fInvalidFull) && (!m_fInvalidChildren), 
            "Invalid must be reset");
#endif

    DuVisual * pgadCur = GetTopChild();
    while (pgadCur != NULL) {
        pgadCur->DEBUG_CheckResetInvalid();
        pgadCur = pgadCur->GetNext();
    }
}

#endif // DBG


/***************************************************************************\
*
* DuVisual::ResetInvalid
*
* ResetInvalid() walks the tree resetting the invalid painting bits, 
* m_fInvalidFull, m_fInvalidChildren, and m_fInvalidDirty, that are used 
* to indicate that a node has been invalidated.
*
\***************************************************************************/

void
DuVisual::ResetInvalid()
{
    m_fInvalidFull  = FALSE;
#if ENABLE_OPTIMIZEDIRTY
    m_fInvalidDirty = FALSE;
#endif

    if (m_fInvalidChildren) {
        m_fInvalidChildren = FALSE;

        DuVisual * pgadCur = GetTopChild();
        while (pgadCur != NULL) {
            pgadCur->ResetInvalid();
            pgadCur = pgadCur->GetNext();
        }
    }

#if DBG
    DEBUG_CheckResetInvalid();
#endif // DBG
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::GetBufferInfo(
    IN  BUFFER_INFO * pbi               // Buffer information
    ) const
{
    AssertWritePtr(pbi);
    AssertMsg(m_fBuffered, "Gadget must be buffered");

    BUFFER_INFO * pbiThis = GetBufferInfo();

    pbi->nMask      = GBIM_VALID;
    pbi->bAlpha     = pbiThis->bAlpha;
    pbi->crFill     = pbiThis->crFill;
    pbi->nStyle     = pbiThis->nStyle;
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::SetBufferInfo(
    IN  const BUFFER_INFO * pbi)        // New information
{
    AssertReadPtr(pbi);
    AssertMsg(m_fBuffered, "Gadget must be buffered");

    BUFFER_INFO * pbiThis = GetBufferInfo();

    int nMask = pbi->nMask;
    if (TestFlag(nMask, GBIM_ALPHA)) {
        pbiThis->bAlpha = pbi->bAlpha;
    }

    if (TestFlag(nMask, GBIM_FILL)) {
        pbiThis->crFill = pbi->crFill;
    }

    if (TestFlag(nMask, GBIM_STYLE)) {
        pbiThis->nStyle = pbi->nStyle;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::SetBuffered(
    IN  BOOL fBuffered)                 // New buffering mode
{
    HRESULT hr;

    if ((!fBuffered) == (!m_fBuffered)) {
        return S_OK;  // No change
    }

    if (fBuffered) {
        BUFFER_INFO * pbi;
        hr = m_pds.SetData(s_pridBufferInfo, sizeof(BUFFER_INFO), (void **) &pbi);
        if (FAILED(hr)) {
            return hr;
        }

        pbi->cbSize = sizeof(BUFFER_INFO);
        pbi->nMask  = GBIM_VALID;
        pbi->bAlpha = BLEND_OPAQUE;
    } else {
        //
        // Remove the existing XFormInfo
        //

        m_pds.RemoveData(s_pridBufferInfo, TRUE);
    }

    m_fBuffered = fBuffered;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::GetRgn(UINT nRgnType, HRGN hrgn, UINT nFlags) const
{
    AssertMsg(hrgn != NULL, "Must specify a valid region");
    UNREFERENCED_PARAMETER(nFlags);

    HRESULT hr = E_NOTIMPL;

    switch (nRgnType)
    {
    case GRT_VISRGN:
        {
            //
            // For right now, just return the bounding box.
            //
            // TODO: Need to be more accurate than this if any rotations are 
            // going on.
            //

            RECT rcClientPxl, rcContainerPxl;
            GetLogRect(&rcClientPxl, SGR_CLIENT);
            DoCalcClipEnumXForm(&rcContainerPxl, &rcClientPxl, 1);

            if (!SetRectRgn(hrgn, rcContainerPxl.left, rcContainerPxl.top,
                   rcContainerPxl.right, rcContainerPxl.bottom)) {

                hr = DU_E_OUTOFGDIRESOURCES;
                goto Exit;
            }

            hr = S_OK;
        }    
        break;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\gstate.cpp ===
/***************************************************************************\
*
* File: GState.cpp
*
* Description:
* GState.cpp implements standard DuVisual state-management functions.
*
*
* History:
*  2/04/2001: JStall:       Created
*
* Copyright (C) 2000-2001 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

/***************************************************************************\
*
* DuVisual::CheckIsTrivial
*
* CheckIsTrivial returns if this node qualifies for trivialness, ignoring
* its children.  
*
* NOTE: This callback function is intended to be called from 
* UpdateDeepAllState().
*
\***************************************************************************/

BOOL
DuVisual::CheckIsTrivial() const
{
    //
    // To be trivial, the following conditions must be met for this node and 
    // all of its children.  If these are not met, then we need to perform 
    // the standard (complicated) painting algorithms.
    // 
    // - fZeroOrigin:       FALSE
    // - fXForm:            FALSE
    // - fClipSiblings:     FALSE
    // - fBuffered:         FALSE
    // - fCached:           FALSE
    //

    return !TestFlag(m_nStyle, GS_ZEROORIGIN | gspXForm | GS_CLIPSIBLINGS | GS_BUFFERED | GS_CACHED);
}


/***************************************************************************\
*
* DuVisual::CheckIsWantMouseFocus
*
* CheckIsWantMouseFocus returns if this node wants mouse focus, ignoring
* its children.  
*
* NOTE: This callback function is intended to be called from 
* UpdateDeepAnyState().
*
\***************************************************************************/

BOOL
DuVisual::CheckIsWantMouseFocus() const
{
    return TestFlag(m_nStyle, GS_MOUSEFOCUS);
}


/***************************************************************************\
*
* DuVisual::UpdateDeepAllState
*
* UpdateDeepAllState() updates the deep state on the specified Gadget so that 
* it properly reflects the state of both this node and all of its children.  
* This function recursively walks up the tree, updating the state as
* necessary.
*
\***************************************************************************/

void
DuVisual::UpdateDeepAllState(
    IN  EUdsHint hint,                  // (Optional) hint from changing child
    IN  DeepCheckNodeProc pfnCheck,     // Callback checking function
    IN  UINT nStateMask)                // State mask
{
    BOOL fNewState = FALSE;

    switch (hint)
    {
    case uhFalse:
        //
        // Child changed to !State, so we must become !State
        //
        
        fNewState = FALSE;
        break;

    case uhTrue:
        //
        // Child changed to State, so we may be able to become State if 
        // everything qualifies.
        //
        // NOTE: We may already be State if this child was already State.
        //
        
        if (!TestFlag(m_nStyle, nStateMask)) {
            goto FullCheck;
        }
        fNewState = TRUE;
        break;
          
    case uhNone:
        {
FullCheck:
            fNewState = (this->*pfnCheck)();
            if (!fNewState) {
                goto NotifyParent;
            }
    
            //
            // Need to scan all of the children to determine what happened
            //

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (!TestFlag(pgadCur->m_nStyle, nStateMask)) {
                    fNewState = FALSE;
                    break;
                }
                pgadCur = pgadCur->GetNext();
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown hint");
        goto FullCheck;
    }


NotifyParent:
    if ((!fNewState) != (!TestFlag(m_nStyle, nStateMask))) {
        //
        // State has changed, so parent needs to update
        //

        EUdsHint hintParent;
        if (fNewState) {
            SetFlag(m_nStyle, nStateMask);
            hintParent = uhTrue;
        } else {
            ClearFlag(m_nStyle, nStateMask);
            hintParent = uhFalse;
        }

        DuVisual * pgadParent = GetParent();
        if (pgadParent != NULL) {
            pgadParent->UpdateDeepAllState(hintParent, pfnCheck, nStateMask);
        }
    }
}


/***************************************************************************\
*
* DuVisual::UpdateDeepAnyState
*
* UpdateDeepAnyState() updates the deep state on the specified Gadget so that 
* it properly reflects the state of (this node || any of its children).  
* This function recursively walks up the tree, updating the state as
* necessary.
*
* NOTE: This function is a mirror image of UpdateDeepAllState() where all of
* the logical has been reversed.
*
\***************************************************************************/

void
DuVisual::UpdateDeepAnyState(
    IN  EUdsHint hint,                  // (Optional) hint from changing child
    IN  DeepCheckNodeProc pfnCheck,     // Callback checking function
    IN  UINT nStateMask)                // State mask
{
    BOOL fNewState = TRUE;

    switch (hint)
    {
    case uhTrue:
        //
        // Child changed to State, so we must become State
        //
        
        fNewState = TRUE;
        break;

    case uhFalse:
        //
        // Child changed to !State, so we may be able to become !State if 
        // everything qualifies.
        //
        // NOTE: We may already be !State if this child was already !State.
        //
        
        if (TestFlag(m_nStyle, nStateMask)) {
            goto FullCheck;
        }
        fNewState = FALSE;
        break;
          
    case uhNone:
        {
FullCheck:
            fNewState = (this->*pfnCheck)();
            if (fNewState) {
                goto NotifyParent;
            }
    
            //
            // Need to scan all of the children to determine what happened
            //

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (TestFlag(pgadCur->m_nStyle, nStateMask)) {
                    fNewState = TRUE;
                    break;
                }
                pgadCur = pgadCur->GetNext();
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown hint");
        goto FullCheck;
    }


NotifyParent:
    if ((!fNewState) != (!TestFlag(m_nStyle, nStateMask))) {
        //
        // State has changed, so parent needs to update
        //

        EUdsHint hintParent;
        if (fNewState) {
            SetFlag(m_nStyle, nStateMask);
            hintParent = uhTrue;
        } else {
            ClearFlag(m_nStyle, nStateMask);
            hintParent = uhFalse;
        }

        DuVisual * pgadParent = GetParent();
        if (pgadParent != NULL) {
            pgadParent->UpdateDeepAnyState(hintParent, pfnCheck, nStateMask);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\grect.cpp ===
/***************************************************************************\
*
* File: GRect.cpp
*
* Description:
* GRect.cpp implements standard DuVisual location/placement functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"

/***************************************************************************\
***********