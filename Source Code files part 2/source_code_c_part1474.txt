CSegmentHeader*) pBufBase;

    Win4Assert(cbBuf > sizeof (CSegmentHeader) + sizeof (CHeapHeader));

    if (oBuf) {
        pSegHdr->oBaseOffset = oBuf;
        if (oBuf + cbBuf > _oNextOffset)
            _oNextOffset = oBuf + cbBuf;
        if (oBuf + TBL_PAGE_MAX_SEGMENT_SIZE > _oNextOffset)
            _oNextOffset = oBuf + TBL_PAGE_MAX_SEGMENT_SIZE;
    } else {
        //
        //  Offset is not constrained to some previously used
        //  value.  For convenience, round up to make it easy
        //  to add to page addresses.
        //
        _oNextOffset = (_oNextOffset + TBL_PAGE_MASK) &
                       ~(TBL_PAGE_MASK);
        _oNextOffset |= (ULONG)((ULONG_PTR)pBufBase & (TBL_PAGE_MASK));

        pSegHdr->oBaseOffset = _oNextOffset;
        _oNextOffset += (cbBuf > TBL_PAGE_MAX_SEGMENT_SIZE) ?
                        cbBuf : TBL_PAGE_MAX_SEGMENT_SIZE;
    }
    pSegHdr->cbSize = cbBuf;

    CHeapHeader* pFirstHeap = (CHeapHeader*) (pSegHdr+1);
    cbBuf -= sizeof (CSegmentHeader);
    Win4Assert((cbBuf & (sizeof (CHeapHeader) - 1)) == 0);

    if (pHeap) {
        Win4Assert((BYTE*)pHeap < ((BYTE*)pFirstHeap) + cbBuf &&
                 (BYTE*)pHeap >= ((BYTE*)pFirstHeap) + 2*sizeof (CHeapHeader));
        Win4Assert(! pHeap->IsFree() && pHeap->IsFirst());

        cbBuf = (size_t)((BYTE*)pHeap - (BYTE*)pFirstHeap);
        pHeap->cbPrev = (USHORT)cbBuf;
        pFirstHeap->cbSize = cbBuf | CHeapHeader::HeapFree;
        pSegHdr->cbFree = cbBuf;

        while (! pHeap->IsLast()) {
            pHeap = pHeap->Next();
            if (pHeap->IsFree())
                pSegHdr->cbFree += pHeap->Size();
        }
    } else {
        pFirstHeap->cbSize = cbBuf | CHeapHeader::HeapFree|CHeapHeader::HeapEnd;
        pSegHdr->cbFree = cbBuf;
    }
    pFirstHeap->cbPrev = CHeapHeader::HeapEnd;

    //
    //  Now insert this segment into the list of segments.
    //
    pSegHdr->pNextSegment = _pBaseAddr;
    _pBaseAddr = pSegHdr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::Allocate, public
//
//  Synopsis:   Allocates a piece of data out of a memory heap
//
//  Effects:    updates _pBuf and _cbBuf
//
//  Arguments:  [cbNeeded] - number of byes of memory needed
//
//  Returns:    PVOID - a pointer to the allocated memory
//
//  Signals:    Throws E_OUTOFMEMORY if not enough memory is available.
//
//  Notes:      Allocated blocks must be less than 64Kb in size.
//              Allocated blocks may move in virtual memory (while
//              there are no outstanding pointers within them), but
//              the offset value saved for an item must always be valid.
//
//              It is assumed that no locking need be done for multi-threaded
//              protection because higher-level callers will do their
//              own synchronization.
//
//              TODO:
//                      - Enforce memory allocation limit
//
//  History:
//
//--------------------------------------------------------------------------

PVOID   CWindowDataAllocator::Allocate(
    ULONG cbNeeded
) {
    CSegmentHeader* pSegHdr = (CSegmentHeader*) _pBaseAddr;
    BYTE* pRetBuf = 0;
    CHeapHeader* pThisHeap;

    Win4Assert(cbNeeded < USHRT_MAX - 2*(sizeof (CHeapHeader)));

    //  Reserve room for the header.

    cbNeeded += sizeof (CHeapHeader);

    //  Only allocate on 8-byte boundaries

    cbNeeded = _RoundUpToChunk( cbNeeded, cbTblAllocAlignment );

    if (pSegHdr == 0)
    {
        ULONG cbSize = TblPageGrowSize(cbNeeded + sizeof (CSegmentHeader),
                                        TRUE);
        BYTE* pbNewData = (BYTE *)TblPageAlloc(cbSize,
                                               *_pcbPageUsed, TBL_SIG_VARDATA);

        tbDebugOut((DEB_TRACE,
                "First variable allocation segment,"
                        " new segment = %08x, size = %06x\n",
                                        pbNewData,   cbSize));
        Win4Assert(pbNewData != 0);

        _SetArena(pbNewData, cbSize);
        pSegHdr = _pBaseAddr;
    }

    do
    {
        //
        //  If there's not enough free space in this segment, just
        //  go on to the next one.
        //
        if (cbNeeded > pSegHdr->cbFree)
            continue;

        for (pThisHeap = (CHeapHeader*)(pSegHdr+1);
             pThisHeap;
             pThisHeap = pThisHeap->Next())
        {

            Win4Assert(pThisHeap->cbPrev != 0 &&
                     pThisHeap->Size() < pSegHdr->cbSize &&
                     (BYTE*)pThisHeap < ((BYTE*)pSegHdr) + pSegHdr->cbSize);

            if (pThisHeap->IsFree() && pThisHeap->Size() >= cbNeeded)
            {
                return _SplitHeap(pSegHdr, pThisHeap, cbNeeded);
            }
        }
    } while (pSegHdr = pSegHdr->pNextSegment);

    tbDebugOut((DEB_TRACE, "Need to grow available data for var allocation\n"));

    //
    //  Not enough space in the set of currently allocated segments.
    //  See if one can be grown to accomodate the new allocation.
    //

    for (pSegHdr = (CSegmentHeader*) _pBaseAddr;
         pSegHdr;
         pSegHdr = pSegHdr->pNextSegment)
    {

        if (cbNeeded >
            (TBL_PAGE_MAX_SEGMENT_SIZE -
             (pSegHdr->cbSize + sizeof (TBL_PAGE_SIGNATURE))))
            continue;

        ULONG cbNew = (cbNeeded + (TBL_PAGE_MASK)) & ~TBL_PAGE_MASK;
        Win4Assert(cbNew + pSegHdr->cbSize < 0xFFFF);

        tbDebugOut((DEB_TRACE,
                        "Grow var allocation segment %x, new size %06x\n",
                        pSegHdr, pSegHdr->cbSize + cbNew));
        TblPageRealloc(pSegHdr, *_pcbPageUsed, cbNew + pSegHdr->cbSize, 0);

        //
        //  Now add the newly allocated data to the heap.
        //
        for (pThisHeap = (CHeapHeader*)(pSegHdr+1);
             !pThisHeap->IsLast();
             pThisHeap = pThisHeap->Next()) {

        }

        if (pThisHeap->IsFree())
        {
            //
            //  Just add the size of the newly allocated data
            //

            pThisHeap->cbSize = (pThisHeap->Size() + (USHORT)cbNew) |
                                    CHeapHeader::HeapFree |
                                    CHeapHeader::HeapEnd;

        }
        else
        {
            //
            //  Create a new arena header which is free and last
            //

            pThisHeap->cbSize &= ~CHeapHeader::HeapEnd;
            pThisHeap->Next()->cbSize = (USHORT)cbNew |
                                            CHeapHeader::HeapFree |
                                            CHeapHeader::HeapEnd;
            pThisHeap->Next()->cbPrev = pThisHeap->Size();
            pThisHeap = pThisHeap->Next();
        }

        pSegHdr->cbSize += cbNew;
        pSegHdr->cbFree += cbNew;
        return _SplitHeap(pSegHdr, pThisHeap, cbNeeded);
    }

    //
    //  Not enough space in the available segments; allocate a new
    //  segment and allocate from it.
    //

    {
        ULONG cbSize = TblPageGrowSize(cbNeeded + sizeof (CSegmentHeader),
                                        TRUE);
        BYTE* pbNewData = (BYTE *)TblPageAlloc(cbSize,
                                               *_pcbPageUsed, TBL_SIG_VARDATA);

        tbDebugOut((DEB_TRACE, "New variable allocation segment linked to %x,"
                        " new segment = %08x, size = %06x\n",
                        _pBaseAddr, pbNewData,   cbSize));
        Win4Assert(pbNewData != 0);

        _SetArena(pbNewData, cbSize);
        pSegHdr = _pBaseAddr;
        pThisHeap = (CHeapHeader *)(pSegHdr+1);
        Win4Assert(pThisHeap->Size() >= cbNeeded && pThisHeap->IsFree());

        return _SplitHeap(pSegHdr, pThisHeap, cbNeeded);
    }

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::_SplitHeap, private
//
//  Synopsis:   Allocates a piece of data out of a memory heap
//
//  Arguments:  [pSegHdr] - pointer to the memory segment header
//              [pThisHeap] - pointer to the arena header to be split
//              [cbNeeded] - count of bytes to be allocated
//
//  Returns:    PVOID - a pointer to the allocated memory
//
//  Notes:      The Heap pointer passed must have enough space
//              to accomodate the memory request.
//
//  History:
//
//--------------------------------------------------------------------------

PVOID   CWindowDataAllocator::_SplitHeap(
    CSegmentHeader* pSegHdr,
    CHeapHeader* pThisHeap,
    size_t cbNeeded
) {
    CHeapHeader* pPrevHeap;

    Win4Assert(pThisHeap->IsFree() && pThisHeap->Size() >= cbNeeded);

    //
    //  Found a suitable chunk of free memory.  Carve off
    //  a piece of memory to be returned; adjust the total
    //  free size in the segment.
    //
    if (pThisHeap->Size() < cbNeeded + 2*sizeof (CHeapHeader)) {
        //
        //  Not enough room to split the arena entry; just
        //  return it all.
        //
        pSegHdr->cbFree -= pThisHeap->Size();
        pThisHeap->cbSize &= ~CHeapHeader::HeapFree;
        return pThisHeap+1;
    }

    //
    //  Need to split the arena entry.  We'll return the upper
    //  portion as the allocated memory so the free memory
    //  will be closer to the beginning of the arena.
    //
    pPrevHeap = pThisHeap;
    pThisHeap = (CHeapHeader*)(((BYTE*)pPrevHeap) +
                            pPrevHeap->Size() - cbNeeded);

    pThisHeap->cbPrev = pPrevHeap->Size() - cbNeeded;
    pThisHeap->cbSize = (USHORT)cbNeeded;
    if (pPrevHeap->IsLast()) {
        pThisHeap->cbSize |= CHeapHeader::HeapEnd;
    } else {
        pPrevHeap->Next()->cbPrev = (USHORT)cbNeeded;
    }
    pPrevHeap->cbSize = (pPrevHeap->Size() - cbNeeded) |
                            CHeapHeader::HeapFree;

    pSegHdr->cbFree -= pThisHeap->Size();
    return pThisHeap+1;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::Free, public
//
//  Synopsis:   Frees a previously allocated piece of data
//
//  Arguments:  [pMem] - pointer to the memory to be freed
//
//  Returns:    Nothing
//
//  Notes:      Coalesces freed block with previous and/or next if they
//              are freed.
//
//              As with the alloc method, it is assumed that a higher-
//              level caller will have taken care of multi-threaded
//              synchronization.
//
//              TODO:   - check that freed block doesn't grow larger than
//                        USHRT_MAX (if segment length is larger)
//                      - Release freed memory if > 1 page at end of block
//                      - Release freed mem if > 1 page at beginning or
//                        middle of block and there's room for a page header
//                        at beginning of next used block.  (this may not
//                        be worth doing due to additional complexity in
//                        realloc case).
//
//  History:
//
//--------------------------------------------------------------------------

void    CWindowDataAllocator::Free(
    PVOID pMem
) {
    Win4Assert( (((ULONG_PTR)pMem) & (sizeof (CHeapHeader) - 1)) == 0 );

    CHeapHeader* pHeader = ((CHeapHeader *) pMem) - 1;
    Win4Assert( pHeader->Size() >= (sizeof CHeapHeader)*2 &&
              !pHeader->IsFree());

    CHeapHeader* pPrev = pHeader;
    while (!pPrev->IsFirst()) {
        pPrev = pPrev->Prev();
    }
    CSegmentHeader* pSegHdr = ((CSegmentHeader*)pPrev) - 1;
    pSegHdr->cbFree += pHeader->Size();

    pHeader->cbSize |= CHeapHeader::HeapFree;
    //
    //  Attempt to coalesce with next and previous blocks.
    //

    if (!(pHeader->IsLast() )) {
        CHeapHeader* pNext = pHeader->Next();
        if (pNext->IsFree()) {
            pHeader->cbSize = pHeader->Size();
            pHeader->cbSize += pNext->Size();
            pHeader->cbSize |= CHeapHeader::HeapFree;
            if (pNext->IsLast()) {
                pHeader->cbSize |= CHeapHeader::HeapEnd;
            } else {
                pNext = pHeader->Next();
                pNext->cbPrev = pHeader->Size();
            }
        }
    }
    if (!(pHeader->IsFirst() )) {
        CHeapHeader* pPrev = pHeader->Prev();
        if (pPrev->IsFree()) {
            pPrev->cbSize = pPrev->Size();
            pPrev->cbSize += pHeader->Size();
            pPrev->cbSize |= CHeapHeader::HeapFree;
            if (pHeader->IsLast()) {
                pPrev->cbSize |= CHeapHeader::HeapEnd;
            } else {
                pHeader = pPrev->Next();
                pHeader->cbPrev = pPrev->Size();
            }
            pHeader = pPrev;
        }
    }
    if (pHeader->IsFirst() && pHeader->IsLast()) {
        tbDebugOut((DEB_WARN, "Empty pool segment to be freed %x\n", pHeader));
    } else if (pHeader->Size() >= 2*TBL_PAGE_ALLOC_MIN) {
        tbDebugOut((DEB_WARN, "Pool page(s) can be deallocated,"
                        " loc = %x, size = %x\n", pHeader, pHeader->Size()));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::OffsetToPointer, public
//
//  Synopsis:   Convert a pointer offset to a pointer.
//
//  Arguments:  [oBuf] - buffer offset to be mapped
//
//  Returns:    PVOID -  a pointer to the data buffer
//
//  Notes:
//
//--------------------------------------------------------------------------

PVOID   CWindowDataAllocator::OffsetToPointer(
    TBL_OFF oBuf
) {
    CSegmentHeader* pSegHdr = _pBaseAddr;

    for (pSegHdr = _pBaseAddr; pSegHdr; pSegHdr = pSegHdr->pNextSegment) {
        if (oBuf < pSegHdr->oBaseOffset)
            continue;
        if ((ULONG_PTR)(oBuf - pSegHdr->oBaseOffset) < pSegHdr->cbSize) {
            return (oBuf - pSegHdr->oBaseOffset) + (BYTE *)pSegHdr;
        }
    }
    Win4Assert(! "CWindowDataAllocator::OffsetToPointer failed");
    return 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::PointerToOffset, public
//
//  Synopsis:   Convert a pointer to a pointer offset.
//
//  Arguments:  [pBuf] - buffer pointer to be mapped
//
//  Returns:    ULONG -  a unique value for the buffer in the memory
//                      arena
//
//  Notes:
//
//--------------------------------------------------------------------------

TBL_OFF   CWindowDataAllocator::PointerToOffset(
    PVOID pBuf
) {
    CSegmentHeader* pSegHdr = _pBaseAddr;

    for (pSegHdr = _pBaseAddr; pSegHdr; pSegHdr = pSegHdr->pNextSegment) {
        if (pBuf < pSegHdr)
            continue;
        if ((TBL_OFF)((BYTE *)pBuf - (BYTE *)pSegHdr) < pSegHdr->cbSize) {
            return ((BYTE *)pBuf - (BYTE *)pSegHdr) + pSegHdr->oBaseOffset;
        }
    }
    Win4Assert(! "CWindowDataAllocator::PointerToOffset failed");
    return 0;
}


void CWindowDataAllocator::SetBase( BYTE* pbBase )
{
    Win4Assert(! "CWindowDataAllocator::SetBase not supported");
}

#if CIDBG
//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::WalkHeap, public
//
//  Synopsis:   Walks the memory arena, calling out to a caller-supplied
//              function for each memory area.
//
//  Arguments:  [pfnReport] - pointer to function for memory report
//
//  Returns:    Nothing
//
//  Notes:      For debugging support only.
//              The pfnReport is called with three parameters, giving the
//              memory address of the block, the size of the block, and the
//              free flag associated with the block.  The block address and
//              size do not include the arena header.
//
//  History:
//
//--------------------------------------------------------------------------


void
CWindowDataAllocator::WalkHeap(
    void (pfnReport)(PVOID pb, USHORT cb, USHORT fFree)
) {
    CSegmentHeader* pSegHdr = (CSegmentHeader*) _pBaseAddr;

    while (pSegHdr) {
        CHeapHeader *pPrevHeap = 0;
        CHeapHeader *pThisHeap;
        ULONG cbFree = 0;

        pThisHeap = (CHeapHeader*)(pSegHdr + 1);

        Win4Assert(pThisHeap->IsFirst());

        while ( TRUE ) {
            pfnReport(pThisHeap+1, pThisHeap->Size() - sizeof (CHeapHeader),
                            (USHORT)pThisHeap->IsFree());
            if (pPrevHeap) {
                Win4Assert(pThisHeap->Prev() == pPrevHeap &&
                         ! pThisHeap->IsFirst());
            }
            if (pThisHeap->IsFree())
                cbFree += pThisHeap->Size();
            if (pThisHeap->IsLast())
                break;
            pPrevHeap = pThisHeap;
            pThisHeap = pThisHeap->Next();
        }
        Win4Assert(cbFree == pSegHdr->cbFree);
        pSegHdr = pSegHdr->pNextSegment;
    }
}
#endif  // CIDBG


//+-------------------------------------------------------------------------
//
//  Member:     CFixedVarAllocator::~CFixedVarAllocator, public
//
//  Synopsis:   Destroys a window data allocator
//
//  Notes:
//
//--------------------------------------------------------------------------

CFixedVarAllocator::~CFixedVarAllocator ()
{
    delete _VarAllocator;

    if (_pbBaseAddr)
    {
        if ( _fDidReInit )
            delete (BYTE *) _pbBaseAddr;
        else
        {
            TblPageDealloc( _pbBaseAddr,
                            _cbPageUsed,
                            0 );
            Win4Assert( _cbPageUsed == 0 );
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CFixedVarAllocator::Allocate, public
//
//  Synopsis:   Allocates a piece of variable data out of a memory buffer
//              Take it from the same buffer as the fixed data until there
//              is no more room available in the that buffer, then split
//              the fixed and variable portions and convert the variable
//              portion to a CVarDataAllocator which will handle subsequent
//              allocations.
//
//  Effects:    updates _cbBuf
//
//  Arguments:  [cbNeeded] - number of byes of memory needed
//
//  Returns:    PVOID - a pointer to the allocated memory
//
//  Signals:    Throws E_OUTOFMEMORY if not enough memory is available.
//
//  Notes:      Allocated blocks must be less than 64Kb in size.
//              Allocated blocks may move in virtual memory (while
//              there are no outstanding pointers within them), but
//              the offset value saved for an item must always be valid.
//
//              It is assumed that a higher-level caller will take
//              care of any multi-thread synchronization issues.
//
//  History:    22 Apr 1994     Alanw   Created
//
//--------------------------------------------------------------------------

PVOID   CFixedVarAllocator::Allocate(
    ULONG cbNeeded
) {
    if ( 0 == _VarAllocator && !_fVarOffsets )
    {
        // Don't use offsets -- just pointers.  Need an allocator from
        // which to allocate.

        _VarAllocator = new CWindowDataAllocator();
    }

    if (_VarAllocator)
    {
        Win4Assert( 0 != _VarAllocator );
        return _VarAllocator->Allocate(cbNeeded);
    }

    Win4Assert(cbNeeded <
                USHRT_MAX - 2*(sizeof (CWindowDataAllocator::CHeapHeader)));

    //
    //  Only allocate on eight-byte boundaries
    //

    cbNeeded = (cbNeeded + (sizeof (CWindowDataAllocator::CHeapHeader)-1)) &
                ~(sizeof (CWindowDataAllocator::CHeapHeader) - 1);
    cbNeeded += sizeof (CWindowDataAllocator::CHeapHeader);

    if (_pbBaseAddr == 0)
        _GrowData(cbNeeded);

    size_t cbFree = FreeSpace();

    if (cbNeeded >= cbFree)
    {
        _SplitData(FALSE);
        Win4Assert(_VarAllocator != 0);
        return _VarAllocator->Allocate(cbNeeded -
                                sizeof (CWindowDataAllocator::CHeapHeader));
    }

    //
    //  Allocate the memory and prefix with a heap header so the
    //  memory can be handed over to the Heap manager eventually.
    //
    CWindowDataAllocator::CHeapHeader* pThisHeap;
    CWindowDataAllocator::CHeapHeader* pPrevHeap;

    pThisHeap = (CWindowDataAllocator::CHeapHeader*)
                            (_pbBaseAddr + _cbBuf - cbNeeded);
    pThisHeap->cbSize = (USHORT)cbNeeded;
    pThisHeap->cbPrev = CWindowDataAllocator::CHeapHeader::HeapEnd;

    if (_cbBuf != _cbTotal)
    {
        pPrevHeap = (CWindowDataAllocator::CHeapHeader *)(_pbBaseAddr+_cbBuf);
        pPrevHeap->cbPrev = ((USHORT)cbNeeded) |
                        (pPrevHeap->cbPrev & (CWindowDataAllocator::CHeapHeader::HeapFree));
    }
    else
    {
        pThisHeap->cbSize |= CWindowDataAllocator::CHeapHeader::HeapEnd;
    }
    _cbBuf -= cbNeeded;
    Win4Assert(_cbBuf >= (unsigned)(_pbBuf - _pbBaseAddr));

    return (BYTE*)(pThisHeap + 1);
}


//+-------------------------------------------------------------------------
//
//  Member:     CFixedVarAllocator::Free, public
//
//  Synopsis:   Frees a previously allocated piece of data.  Passed along
//              to the CVarDataAllocator if fixed and var data have been
//              split.
//
//  Arguments:  [pMem] - pointer to the memory to be freed
//
//  Returns:    Nothing
//
//  Notes:      Coalesces freed block with previous and/or next if they
//              are freed.
//
//              It is assumed that a higher-level caller will take
//              care of any multi-thread synchronization issues.
//
//  History:
//
//--------------------------------------------------------------------------

void    CFixedVarAllocator::Free(
    PVOID pMem
) {
    if (_VarAllocator) {
        _VarAllocator->Free(pMem);
        return;
    }

    Win4Assert( (((ULONG_PTR)pMem) & (sizeof (CWindowDataAllocator::CHeapHeader) - 1)) == 0 );

    CWindowDataAllocator::CHeapHeader* pHeader = ((CWindowDataAllocator::CHeapHeader *) pMem) - 1;
    Win4Assert( pHeader->Size() >= (sizeof CWindowDataAllocator::CHeapHeader)*2 &&
              !pHeader->IsFree());

    pHeader->cbSize |= CWindowDataAllocator::CHeapHeader::HeapFree;

    //
    //  Attempt to coalesce with next and previous blocks.
    //
    if (!(pHeader->IsLast() )) {
        CWindowDataAllocator::CHeapHeader* pNext = pHeader->Next();
        if (pNext->IsFree()) {
            pHeader->cbSize = pHeader->Size();
            pHeader->cbSize += pNext->Size();
            pHeader->cbSize |= CWindowDataAllocator::CHeapHeader::HeapFree;
            if (pNext->IsLast()) {
                pHeader->cbSize |= CWindowDataAllocator::CHeapHeader::HeapEnd;
            } else {
                pNext = pHeader->Next();
                pNext->cbPrev = pHeader->Size();
            }
        }
    }
    if (!(pHeader->IsFirst() )) {
        CWindowDataAllocator::CHeapHeader* pPrev = pHeader->Prev();
        if (pPrev->IsFree()) {
            pPrev->cbSize = pPrev->Size();
            pPrev->cbSize += pHeader->Size();
            pPrev->cbSize |= CWindowDataAllocator::CHeapHeader::HeapFree;
            if (pHeader->IsLast()) {
                pPrev->cbSize |= CWindowDataAllocator::CHeapHeader::HeapEnd;
            } else {
                pHeader = pPrev->Next();
                pHeader->cbPrev = pPrev->Size();
            }
            pHeader = pPrev;
        }
    }

    if (pHeader->IsFirst()) {
        //
        //  Free this memory for use by the fixed allocator
        //
        if (! pHeader->IsLast()) {
            pHeader->Next()->cbPrev =
                        CWindowDataAllocator::CHeapHeader::HeapEnd;
        }
        _cbBuf += pHeader->Size();
        if (pHeader->IsLast()) {
            Win4Assert(_cbBuf == _cbTotal);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ResizeAndInitFixed
//
//  Synopsis:   Resizes the "Fixed Width" part of the buffer to hold atleast
//              as many as "cItems" entries.
//
//  Arguments:  [cbDataWidth] -- Width of the new fixed data.
//              [cItems]      -- Starting number of items that will be added.
//
//  History:    11-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CFixedVarAllocator::ResizeAndInitFixed( size_t cbDataWidth, ULONG cItems )
{
    //
    // This method should be called only if the fixed portion is being
    // currently used.
    //
    Win4Assert( _cbTotal == _cbBuf );

    ULONG cbNewNeeded = (ULONG)(cbDataWidth * cItems + _cbReserved);
    //
    // Round up the size to be an integral number of "pages".
    //
    ULONG cbNewActual = TblPageGrowSize(cbNewNeeded, TRUE);
    _cbDataWidth = cbDataWidth;

    if ( cbNewActual == _cbBuf )
    {
        //
        // The old and new totals are the same. There is no need to do any
        // allocation. Just adjust the pointers and return.
        //
        _pbBuf = _pbBaseAddr+_cbReserved;
        return;
    }
    else
    {
        //
        // Reallocate the buffer to fit the new size.
        //
        BYTE* pbNewData;

        if (_pbBaseAddr && cbNewActual <= TBL_PAGE_MAX_SEGMENT_SIZE)
        {
            pbNewData = (BYTE *)TblPageRealloc(_pbBaseAddr, _cbPageUsed, cbNewActual, 0);
        }
        else
        {
            pbNewData = (BYTE *)TblPageAlloc( cbNewActual, _cbPageUsed, TBL_SIG_ROWDATA);
        }

        Win4Assert( cbNewActual > _cbReserved );
        if (_pbBaseAddr)
        {
            if ( _pbBaseAddr != pbNewData )
            {
                RtlCopyMemory( pbNewData, _pbBaseAddr, _cbReserved );
                TblPageDealloc(_pbBaseAddr, _cbPageUsed);
            }
        }
        else
        {
            if (_cbReserved)
            {
                RtlZeroMemory(pbNewData, _cbReserved);
            }
        }

        _pbBuf = pbNewData + _cbReserved;
        _pbBaseAddr = pbNewData;
        _cbTotal = _cbBuf = cbNewActual;
        _pbLastAddrPlusOne = _pbBaseAddr + _cbBuf;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   AllocMultipleFixed
//
//  Synopsis:   Allocates a buffer for the specified number of items
//              and returns its pointer.
//
//  Arguments:  [cItems] -- Number of "fixed width" items.
//
//  Returns:    A pointer to a buffer to hold the specified number of
//              "fixed width" items.
//
//  History:    11-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void *  CFixedVarAllocator::AllocMultipleFixed( ULONG cItems )
{
    ULONG cbNeeded = cItems * _cbDataWidth;
    if ( cbNeeded > FreeSpace() )
    {
        if ( _cbTotal != _cbBuf )
            _SplitData(TRUE);
    }

    BYTE * pRetBuf = 0;

    //
    // Need to grow the buffer to accommodate more fixed size allocations.
    //
    if ( cbNeeded > FreeSpace() )
    {
        Win4Assert( _cbTotal == _cbBuf );
        _GrowData( cbNeeded );
    }

    if ( cbNeeded <= FreeSpace() )
    {
        pRetBuf = _pbBuf;
        _pbBuf += cbNeeded;
    }

    return pRetBuf;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFixedVarAllocator::_GrowData, private
//
//  Synopsis:   Grow the data area allocated to row data.
//
//  Arguments:  [cbNeeded] - number of bytes needed.  If zero,
//                      assumed to be called for fixed allocation.
//
//  Returns:    Nothing
//
//  Effects:    _pbBaseAddr will be reallocated to a new size.  Existing
//              reserved and row data will be copied to the new location.
//
//  Notes:      _GrowData cannot be called if row data and variable data
//              share the same buffer.  Use _SplitData instead.
//
//--------------------------------------------------------------------------

void CFixedVarAllocator::_GrowData( size_t cbNeeded )
{
    if (cbNeeded == 0)
        cbNeeded = _cbDataWidth;

    Win4Assert(!_pbBaseAddr || (_pbBuf - _pbBaseAddr) + cbNeeded >= _cbTotal);
    Win4Assert(_cbBuf == _cbTotal);     // can be no var data when growing

    ULONG cbSize = TblPageGrowSize((ULONG)(_cbTotal + cbNeeded), TRUE);
    BYTE* pbNewData;

    if (_pbBaseAddr && cbSize <= TBL_PAGE_MAX_SEGMENT_SIZE)
    {
        pbNewData = (BYTE *)TblPageRealloc(_pbBaseAddr, _cbPageUsed, cbSize, 0);
    }
    else
    {
        pbNewData = (BYTE *)TblPageAlloc(cbSize, _cbPageUsed, TBL_SIG_ROWDATA);
    }

    Win4Assert(pbNewData != 0);
    tbDebugOut((DEB_TRACE,
            "Growing fixed data for allocation at %x, new size = %x, new data = %x\n",
            _pbBaseAddr, cbSize, pbNewData));

    if (_pbBaseAddr) {
        Win4Assert(cbSize > _cbBuf);
        if (_pbBaseAddr != pbNewData) {
            memcpy(pbNewData, _pbBaseAddr, _cbBuf);
            _pbBuf = (_pbBuf - _pbBaseAddr) + pbNewData;

            TblPageDealloc(_pbBaseAddr, _cbPageUsed);
        }
    } else {

#if CIDBG == 1
        BYTE *pByte = (BYTE *) pbNewData;

        for ( unsigned i=0; i<_cbReserved; i++ )
            Win4Assert( pByte[i] == 0 );
#endif

        _pbBuf = pbNewData + _cbReserved;
    }
    _pbBaseAddr = pbNewData;
    _cbTotal = _cbBuf = cbSize;
    _pbLastAddrPlusOne = _pbBaseAddr + _cbBuf;
    Win4Assert(_pbBaseAddr && (_pbBuf - _pbBaseAddr) + cbNeeded < _cbBuf);
}


//+-------------------------------------------------------------------------
//
//  Member:     CFixedVarAllocator::_SplitData, private
//
//  Synopsis:   Split the joint allocation of row and variable data
//
//  Arguments:  [fMoveRowData] - if TRUE, the row data is moved; else
//                      the variable data is moved.
//
//  Returns:    Nothing
//
//  Effects:    _pbBaseAddr will be realloced to a new size.  Existing
//              row data will be copied to the new location.  If a
//              data buffer was previously shared between row data and
//              variable data, it will be no longer.
//
//  Notes:
//
//--------------------------------------------------------------------------

void
CFixedVarAllocator::_SplitData( BOOL fMoveRowData )
{
    Win4Assert(_pbBaseAddr != 0 && _VarAllocator == 0);

    ULONG cbSize = _cbTotal;
    ULONG cbVarSize = (ULONG)(_cbTotal - _cbBuf);
    BYTE* pbNewData = (BYTE *)TblPageAlloc(cbSize, _cbPageUsed,
                            fMoveRowData ? TBL_SIG_ROWDATA : TBL_SIG_VARDATA);

    //
    // BROKENCODE - shouldn't pbNewData be in a smart pointer. o/w, there
    // could be a memory leak.
    //

    Win4Assert(pbNewData != 0);
    Win4Assert(cbVarSize != 0 || fMoveRowData);

    tbDebugOut((DEB_TRACE,
                "Splitting fixed data for window from variable data\n"));
    tbDebugOut((DEB_ITRACE,
                "Current fixed size = %x, var size = %x, new %s data = %x\n",
                _cbBuf, _cbTotal - _cbBuf,
                fMoveRowData? "fixed":"var", pbNewData));

    if (fMoveRowData)
    {
        RtlCopyMemory(pbNewData, _pbBaseAddr, (_pbBuf - _pbBaseAddr));

        CWindowDataAllocator* VarAllocator =
                new CWindowDataAllocator (_pbBaseAddr, _cbTotal,
                (CWindowDataAllocator::CHeapHeader*)(_pbBaseAddr + _cbBuf),
                &_cbPageUsed);

        _pbBuf = (_pbBuf - _pbBaseAddr) + pbNewData;
        _pbBaseAddr = pbNewData;
        _pbLastAddrPlusOne = _pbBaseAddr + _cbBuf;
        _VarAllocator = VarAllocator;
    }
    else
    {
        CWindowDataAllocator::CHeapHeader* pHeap = 0;

        if (cbVarSize)
        {
            RtlCopyMemory(pbNewData + _cbBuf, _pbBaseAddr + _cbBuf, _cbTotal - _cbBuf);
            pHeap = (CWindowDataAllocator::CHeapHeader*)(pbNewData + _cbBuf);
        }
        CWindowDataAllocator* VarAllocator =
                new CWindowDataAllocator (pbNewData, _cbTotal,
                                           pHeap, &_cbPageUsed);
        _VarAllocator = VarAllocator;
    }
    _cbBuf = _cbTotal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tblrowal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       tblrowal.cxx
//
//  Contents:   The CTableRowAlloc class, used in allocation
//              of table row data and checking of column bindings.
//
//  Classes:    CTableRowAlloc
//
//  History:    27 Jun 1994     Alanw   Created
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <tblrowal.hxx>

#include "tabledbg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CTableRowAlloc::CTableRowAlloc, public
//
//  Synopsis:   Constructor for a row field allocator.  Initializes
//              max. width and other members.
//
//  Arguments:  [cbRow] - maximum size of the row.  Can be zero if the
//                      row is to grow dynamically via the AllocOffset
//                      method.
//
//  Notes:
//
//+-------------------------------------------------------------------------

CTableRowAlloc::CTableRowAlloc(unsigned cbRow) :
    _maxRow( (USHORT)cbRow ),
    _cbRow( sizeof(_aRowMap) ),
    _iFirstFree(0)
{

    RtlZeroMemory( _aRowMap, sizeof(_aRowMap) );
    _pRowMap = _aRowMap;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowAlloc::_IsLikelyFree
//
//  Synopsis:   Quickly checks to see if the given offset is likely to be
//              free.
//
//  Arguments:  [iOffset] -  Offset to test
//              [cbData]  -  Length of the data needed.
//
//  Returns:    TRUE if that location is likely to be free.
//              FALSE if it is guaranteed not to be a free candidate.
//
//  History:    5-03-96   srikants   Created
//
//  Notes:      This is a quick check to see if the location is likely to
//              be free. Does not guarantee that it is free.
//
//----------------------------------------------------------------------------
inline BOOL CTableRowAlloc::_IsLikelyFree( unsigned iOffset, unsigned cbData )
{
    if ( iOffset < _cbRow && _pRowMap[iOffset] != 0 )
        return FALSE;

    if (iOffset + cbData > _maxRow)
        return FALSE;

    return TRUE;

}

inline unsigned AlignedOffset( unsigned offset, unsigned cbAlign )
{
    Win4Assert( ( cbAlign & (cbAlign-1) ) == 0 );
    return (offset + cbAlign-1) & ~(cbAlign-1);
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableRowAlloc::AllocOffset, public
//
//  Synopsis:   Allocate a row field.  Return the offset in the row.
//
//  Arguments:  [cbData] - size of data field
//              [cbAlign] - required alignment of field (may be zero
//                      if no alignment requirement)
//              [fGrow] - TRUE if row can be grown
//
//  Returns:    USHORT - offset of allocted field.  0xFFFF if failed.
//
//  Notes:
//
//+-------------------------------------------------------------------------

USHORT  CTableRowAlloc::AllocOffset(
    unsigned cbData,
    unsigned cbAlign,
    BOOL fGrow
) {
    Win4Assert(cbAlign <= 16);

    if (cbAlign == 0)
        cbAlign = 1;

    USHORT usSavedMax = _maxRow;

    for ( unsigned i = AlignedOffset(_iFirstFree,cbAlign);
          i < _cbRow;
          i += cbAlign)
    {
        if (fGrow && (i + cbData) > _maxRow)
            SetRowWidth(i + cbData);
        if ( _IsLikelyFree(i, cbData) && ReserveRowSpace( i, cbData )) {
            return (USHORT)i;
        }
    }

    if (fGrow)
    {
        SetRowWidth(i + cbData);
        if (ReserveRowSpace( i, cbData )) {
            return (USHORT)i;
        }
        SetRowWidth(usSavedMax);
    }
    return 0xFFFF;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableRowAlloc::ReserveRowSpace, public
//
//  Synopsis:   Reserve a row field in the allocation map.
//
//  Arguments:  [iOffset] - offset of field in row
//              [cbData] - size of data field
//
//  Returns:    BOOL - TRUE if field could be reserved, FALSE otherwise
//
//  Notes:
//
//+-------------------------------------------------------------------------

BOOL    CTableRowAlloc::ReserveRowSpace(
    unsigned iOffset,
    unsigned cbData
) {
    Win4Assert(cbData > 0);

    if (iOffset + cbData > _maxRow) {
        return FALSE;
    }

    if (iOffset + cbData >= _cbRow) {
        //
        //  Before growing the array, check to see if the reservation
        //  would fail anyway.
        //
        if (iOffset < _cbRow && _pRowMap[ iOffset ] != 0)
        {
            return FALSE;
        }

        //
        //  Need to allocate more space for the row map
        //
        unsigned cbNew = iOffset + max( cbData, CB_INIT );
        BYTE* pNewMap = new BYTE [cbNew];
        Win4Assert( _cbRow > 0 );

        RtlCopyMemory(pNewMap, _pRowMap, _cbRow);
        RtlZeroMemory((void *)&pNewMap[_cbRow], cbNew - _cbRow);

        if ( _pRowMap != _aRowMap )
            delete [] _pRowMap;

        _pRowMap = pNewMap;
        _cbRow = (USHORT)cbNew;
    }

    //
    //  Check if any byte in the field has already been reserved.
    //
    for (unsigned i = 0; i < cbData; i++) {
        if (_pRowMap[ iOffset + i ] != 0) {
            return FALSE;
        }
    }

    //
    //  Reserve the requested field
    //
    for (i = 0; i < cbData; i++) {
        _pRowMap[ iOffset + i ] = 1;
    }

    //
    // Update the _iFirstFree if appropriate.
    //
    Win4Assert( _iFirstFree <= _cbRow );

    if ( _iFirstFree == iOffset )
    {
        //
        // Find the next free location
        //
        Win4Assert( i+iOffset == _iFirstFree+cbData );
        Win4Assert( i == cbData );

        for ( i += iOffset; i < _cbRow; i++ )
        {
            if ( !_IsInUse(i) )
                break;
        }
        _iFirstFree = i;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tablecol.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       TableCol.cxx
//
//  Contents:   Large table column descriptors
//
//  Classes:    CTableColumn
//              CTableColumnArray
//              CTableColumnSet
//
//  History:    15 Sep 94 AlanW     Split from coldesc.cxx
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tablecol.hxx>
#include <tblvarnt.hxx>

#include "colcompr.hxx"
#include "tabledbg.hxx"
#include "pathstor.hxx"

IMPL_DYNARRAY( CTableColumnArray, CTableColumn );

//+-------------------------------------------------------------------------
//
//  Member:     CTableColumn::~CTableColumn, public
//
//  Synopsis:   Destructor for a table column description.
//
//  Notes:
//
//--------------------------------------------------------------------------

CTableColumn::~CTableColumn( )
{
    if (_pCompression && !_fGlobalCompr && _CompressMasterID == 0)
        delete _pCompression;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumnSet::Add, public
//
//  Synopsis:   Add a column description to a column set.
//
//  Arguments:  [pCol] - a smart pointer to column to be added.
//              [iCol] - position in array to use.
//
//  Returns:    Nothing
//
//  Notes:      Care is taken to assure that the smart pointer is
//              transferred to the column array without generating
//              an exception while holding the bare pointer.
//
//--------------------------------------------------------------------------

void
CTableColumnSet::Add(
    XPtr<CTableColumn> & pCol,
    unsigned iCol
) {
    if (iCol >= Size())
        CTableColumnArray::Add(0, iCol);        // probe to expand array

    CTableColumnArray::Add(pCol.Acquire(), iCol);
    if (iCol >= Count())
    {
        Win4Assert(iCol == Count());
        SetCount(iCol+1);
    }
}

// CLEANCODE - old version, delete me someday
void
CTableColumnSet::Add(
    CTableColumn* pCol,
    unsigned iCol
) {
    CTableColumnArray::Add(pCol, iCol);
    if (iCol >= Count())
    {
        Win4Assert(iCol == Count());
        SetCount(iCol+1);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumnSet::Find, public
//
//  Synopsis:   Find a particular column in a column array
//
//  Arguments:  [PropId] - property ID to search for
//              [rfFound] - reference to flag, set to TRUE if match found
//
//  Returns:    CTableColumn* - pointer to the column found, or zero
//
//  Notes:
//
//--------------------------------------------------------------------------

CTableColumn *
CTableColumnSet::Find(
    PROPID const PropId,
    BOOL& rfFound
) const {
    for (unsigned i=0; i<Count(); i++) {
        CTableColumn* pCol = Get(i);
        if (pCol && pCol->PropId == PropId) {
            rfFound = TRUE;
            return pCol;
        }
    }
    rfFound = FALSE;
    return 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumnSet::Marshall, public
//
//  Synopsis:   Serialize a table column set
//
//  Arguments:  [stm] - serialization stream
//              [pids] - CPidMapper to convert propids for propspecs
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CTableColumnSet::Marshall(
    PSerStream & stm,
    CPidMapper & pids
) const {
    stm.PutULong(Count());

    for (unsigned i = 0; i < Count(); i++)
        Get(i)->Marshall( stm, pids );
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumn::Marshall, public
//
//  Synopsis:   Serialize a table column
//
//  Arguments:  [stm] - serialization stream
//              [pids] - CPidMapper to convert propids for propspecs
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CTableColumn::Marshall(
    PSerStream & stm,
    CPidMapper & pids
) const {
    pids.PidToName(PropId)->Marshall( stm );

    stm.PutULong(GetStoredType());

    if ( 0 == IsValueStored() )
        stm.PutByte( FALSE );
    else
    {
        stm.PutByte( TRUE );
        stm.PutUShort( GetValueOffset() );
        stm.PutUShort( GetValueSize() );
    }

    if ( 0 == IsStatusStored() )
        stm.PutByte( FALSE );
    else
    {
        stm.PutByte( TRUE );
        stm.PutUShort( GetStatusOffset() );
        // stm.PutUShort( GetStatusSize() );
    }

    if ( 0 == IsLengthStored() )
        stm.PutByte( FALSE );
    else
    {
        stm.PutByte( TRUE );
        stm.PutUShort( GetLengthOffset() );
        // stm.PutUShort( GetLengthSize() );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumnSet::CTableColumnSet, public
//
//  Synopsis:   Construct a table column set from a serialized stream
//
//  Arguments:  [stm] - serialization stream
//              [pids] - CPidMapper to convert propspecs to fake pids
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CTableColumnSet::CTableColumnSet( PDeSerStream & stm, CPidMapper & pidmap )
        : _cColumns(0),
          CTableColumnArray( 0 )
{
    ULONG cItems = stm.GetULong();

    // Guard against attack

    if ( cItems > 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cItems );

    for ( unsigned i = 0; i < cItems; i++ )
    {
        CFullPropSpec prop( stm );
        if ( !prop.IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );

        PROPID pid = pidmap.NameToPid( prop );
        XPtr<CTableColumn> Col( new CTableColumn( pid ) );

        DBTYPE DataType = (USHORT) stm.GetULong();

        //
        // Only support VT_VARIANT and VT_I4 bindings.  Other ones aren't
        // tested or officially supported -- our OLE DB client only uses
        // these two.  Other datatypes are probably a hacker. 
        //

        if ( VT_I4 == DataType )
        {
            // VT_I4 must be workid

            if ( ! ( ( prop.IsPropertyPropid() ) &&
                     ( prop.GetPropertyPropid() == PROPID_QUERY_WORKID )  &&
                     ( prop.GetPropSet() == PSGUID_QUERY ) ) )
                THROW( CException( E_INVALIDARG ) );
        }
        else if ( VT_VARIANT != DataType ) 
            THROW( CException( E_INVALIDARG ) );

        if ( TRUE == stm.GetByte() )
        {
            USHORT usOffset = stm.GetUShort();

            // Check for a bogus offset

            if ( usOffset > 0x1000 )
                THROW( CException( E_INVALIDARG ) );

            // validate the offset

            Col->SetValueField ( DataType, usOffset, stm.GetUShort() );
        }

        if ( TRUE == stm.GetByte() )
        {
            USHORT usOffset = stm.GetUShort();

            // Check for a bogus offset

            if ( usOffset > 0x1000 )
                THROW( CException( E_INVALIDARG ) );

            Col->SetStatusField ( usOffset, sizeof (BYTE) );
        }

        if ( TRUE == stm.GetByte() )
        {
            USHORT usOffset = stm.GetUShort();

            // Check for a bogus offset

            if ( usOffset > 0x1000 )
                THROW( CException( E_INVALIDARG ) );

            Col->SetLengthField ( usOffset, sizeof (ULONG) );
        }

        Add( Col.Acquire(), i);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _IsSpecialPathProcessing
//
//  Synopsis:   Tests if the column is a candidate for doing special path
//              processing or not.
//
//  Arguments:  [dstColumn] - The column into which the data must be copied
//              in the destination row.
//
//  Returns:    TRUE if special path processing can be done.
//              FALSE o/w
//
//  History:    5-23-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline
BOOL
CTableColumn::_IsSpecialPathProcessing( CTableColumn const & dstColumn ) const
{
    VARTYPE vtDst = dstColumn.GetStoredType();

    return ( pidPath == PropId || pidName == PropId ) &&
           ( vtDst  == VT_LPWSTR ) &&
           ( _StoreAsType == VT_LPWSTR ) &&
           ( _pCompression != 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   _GetPathOrFile
//
//  Synopsis:   Fetches the path or file (if possible) using special processing
//              in the path store (if possible).
//
//  Arguments:  [dstColumn]   -  Destination column into which the data is
//              being copied.
//              [pbSrc]    -  The source window row.
//              [rDstPool] -  Var allocator for destination variable memory
//              allocation.
//              [pbDstRow] -  Pointer to the destination row.
//
//  Returns:    TRUE if the pidName/pidPath could be fetched. FALSE o/w.
//
//  History:    5-23-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableColumn::_GetPathOrFile( CTableColumn const & dstColumn,
                                   const BYTE * pbSrc,
                                   PVarAllocator & rDstPool,
                                   BYTE * pbDstRow
                                    )
{
    const BYTE * pbSrcOrg = pbSrc;

    CPathStore * pSrcPathStore = 0;
    if ( 0 != _pCompression )
    {
        pSrcPathStore =  _pCompression->GetPathStore();
    }

    if ( 0 == pSrcPathStore )
        return FALSE;

// tbDebugOut(( DEB_ITRACE, "Special Path Processing\n" ));

   //
   // We have a path store.
   //

   Win4Assert( GetValueSize() == sizeof(PATHID) );
   pbSrc += GetValueOffset();

   PATHID srcPathId;
   RtlCopyMemory( &srcPathId, pbSrc, sizeof(PATHID) );

   BOOL fDone = FALSE;

   if ( !dstColumn.IsCompressedCol() )
   {
       //
       // Extract the path/file out of the path store for this pathid.
       //
       WCHAR * pwszDest = pSrcPathStore->Get( srcPathId, PropId, rDstPool );
       if ( 0 != pwszDest )
       {

            ULONG_PTR offset = rDstPool.PointerToOffset( pwszDest );
            Win4Assert( dstColumn.GetValueSize() == sizeof(ULONG) );

            RtlCopyMemory( pbDstRow + dstColumn.GetValueOffset(),
                           &offset,
                           dstColumn.GetValueSize() );

            Win4Assert( dstColumn.IsStatusStored() );
            dstColumn.SetStatus( pbDstRow, GetStatus( pbSrcOrg ) );

            if ( dstColumn.IsLengthStored() )
            {
                ULONG *pulLength = (ULONG *)
                                   (pbDstRow + dstColumn.GetLengthOffset());

                *pulLength = (ULONG) (wcslen( pwszDest ) + 1 ) * sizeof(WCHAR);
            }

            fDone = TRUE;
       }
   }
   else
   {
        //
        // The destination column is compressed. See if it
        // also has a path store and copy to it.
        //
        Win4Assert( dstColumn.IsValueStored() );

        //
        // Copy the data to the target.
        //
        if ( 0 == dstColumn.GetCompressMasterId() )
        {
            Win4Assert( dstColumn.IsStatusStored() );
            dstColumn.SetStatus( pbDstRow, GetStatus( pbSrcOrg ) );

            CPathStore * pDstPathStore =
                                    dstColumn.GetCompressor()->GetPathStore();

            ULONG* pulRowColDataBuf = dstColumn.GetValueSize() ?
                  (ULONG*) (pbDstRow + dstColumn.GetValueOffset()) :
                       0;

            Win4Assert( 0 != pulRowColDataBuf );

            if ( 0 != pDstPathStore )
            {
                *pulRowColDataBuf = pDstPathStore->AddPath( *pSrcPathStore, srcPathId );
                fDone = TRUE;
            }
        }
        else
        {
            //
            // This is shared compression. There is nothing to store for this
            // column.
            //
            fDone = TRUE;
        }
   }

   return fDone;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableColumn::CopyColumnData, public
//
//  Synopsis:   Copy a column's data fields between two row buffers.
//              Coercion of the data can occur for data transfer to
//              the user.
//
//  Arguments:  [pbDstRow]      -- destination row buffer
//              [rDstColumn]    -- destination column description
//              [rDstPool]      -- destination variable data allocator
//              [pbSrcRow]      -- source row buffer
//              [rSrcPool]      -- source variable data allocator
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    22 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

DBSTATUS CTableColumn::CopyColumnData(
    BYTE *             pbDstRow,
    CTableColumn const & rDstColumn,
    PVarAllocator &    rDstPool,
    BYTE *             pbSrcRow,
    PVarAllocator &    rSrcPool
)
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    // pull out the data types for clarity below

    VARTYPE vtDst = rDstColumn.GetStoredType();
    VARTYPE vtSrc = GetStoredType();

#if 0
    if (rDstColumn.IsValueStored())
#endif
    {

        Win4Assert( IsValueStored() );

        // the row buffer promises NOT to set the byref bit for these.
        // we'll break elsewhere if this is not true.

        Win4Assert(vtSrc != ( VT_LPWSTR | VT_BYREF ) );
        Win4Assert(vtSrc != ( VT_LPSTR  | VT_BYREF ) );

        Win4Assert( 0 == ( VT_VECTOR & vtDst ) );

        //  Transfer a data value
        if (   ( vtDst == vtSrc ) &&
               ( CTableVariant::IsSimpleType( vtDst ) ) &&
             ! IsCompressedCol() &&
             ! rDstColumn.IsCompressedCol() )
        {
            //  Data columns equivalent, and not indirect.  Just
            //  copy from source to dest.

            Win4Assert( rDstColumn.IsStatusStored() );
            rDstColumn.SetStatus( pbDstRow, GetStatus( pbSrcRow ) );

            #if CIDBG == 1 || DBG == 1

                USHORT cbData, cbAlignment, rgfFlags;
                CTableVariant::VartypeInfo(vtSrc, cbData, cbAlignment, rgfFlags);

                Win4Assert( CTableVariant::TableIsStoredInline( rgfFlags,
                                                                vtSrc ) );
                Win4Assert( rDstColumn.GetValueSize() == GetValueSize() &&
                            cbData == GetValueSize());

            #endif // CIDBG == 1 || DBG == 1

            RtlCopyMemory( pbDstRow + rDstColumn.GetValueOffset(),
                           pbSrcRow + GetValueOffset(),
                           GetValueSize());

            // performance: we never bind to length for these fixed-length
            // fields.

            Win4Assert( !rDstColumn.IsLengthStored() );

            //if (rDstColumn.IsLengthStored())
            //    rDstColumn.SetLength( pbDstRow, rDstColumn.GetValueSize() );
        }
        else
        {

            //
            // Check if this is "pidPath"/ "pidName" and if the destination
            // allows special path processing.
            //
            if ( !_IsSpecialPathProcessing(rDstColumn) ||
                 !_GetPathOrFile( rDstColumn, pbSrcRow,
                                  rDstPool, pbDstRow ) )
            {
                if ( ( vtDst == VT_LPWSTR
                       || vtDst == ( DBTYPE_WSTR | DBTYPE_BYREF )
                     )
                     && vtSrc == VT_LPWSTR
                     && !IsCompressedCol()
                     && !rDstColumn.IsCompressedCol() )
                {
                    //
                    // Optimized path for the common case of wide string -> wide string
                    // copy, such as paths and filenames
                    //
                    BYTE *pbSrc = pbSrcRow + GetValueOffset();

                    WCHAR *pszValue = *(WCHAR **) pbSrc;

                    BYTE *pbDestBuf = pbDstRow + rDstColumn.GetValueOffset();
                    Win4Assert( (ULONG_PTR) pbDestBuf % 4 == 0 );

                    if ( pszValue )
                    {
                        ULONG cbSrc = ( wcslen(pszValue) + 1 ) * sizeof( WCHAR );
                        BYTE *pbDest = (BYTE *) rDstPool.CopyTo( cbSrc, (BYTE *) pszValue );
                        *(BYTE **) pbDestBuf = (BYTE *) rDstPool.PointerToOffset( pbDest );
                    }
                    else
                    {
                        *(ULONG *) pbDestBuf = 0;
                    }

                    Win4Assert( !rDstColumn.IsLengthStored() );

                    #if 0

                    if ( rDstColumn.IsLengthStored() )
                    {
                        ULONG *pulLength = (ULONG *) pbDstRow + rDstColumn.GetLengthOffset();
                        *pulLength = GetValueSize();
                    }

                    #endif // 0
                }
                else
                {
                    //
                    // For any other case, convert to a CTableVariant, then
                    // copy it using the CopyOrCoerce method.  This allows
                    // coercions and variant to nonvariant, etc. conversions
                    // to occur.
                    //
                    //  NOTE:  We may want to optimize the PROPVARIANT to PROPVARIANT
                    //          case when offsets are used in both source and
                    //          destination, since this will occur commonly in
                    //          table splits and row fetches.
                    //

                    CTableVariant varnt;
                    XCompressFreeVariant xpVarnt;

                    if ( CreateVariant(varnt, pbSrcRow, rSrcPool) )
                        xpVarnt.Set(GetCompressor(), &varnt);

                    if ( rDstColumn.IsCompressedCol() )
                    {
                        Win4Assert( rDstColumn.IsValueStored() &&
                                    ! rDstColumn.IsLengthStored() );

                        //
                        // Copy the data to the target.
                        //

                        if (0 == rDstColumn.GetCompressMasterId())
                        {
                            ULONG* pulRowColDataBuf = rDstColumn.GetValueSize() ?
                                  (ULONG*) (pbDstRow + rDstColumn.GetValueOffset()) :
                                       0;
                            GetValueResult eGvr;

                            rDstColumn.GetCompressor()->AddData( &varnt,
                                                                 pulRowColDataBuf,
                                                                 eGvr);
                            Win4Assert( eGvr == GVRSuccess );
                        }
                    }
                    else
                    {
                        DBLENGTH ulTemp;
                        DstStatus = varnt.CopyOrCoerce(
                                            pbDstRow + rDstColumn.GetValueOffset(),
                                            rDstColumn.GetValueSize(),
                                            vtDst,
                                            ulTemp,
                                            rDstPool);
                    }

                    if (rDstColumn.IsLengthStored())
                    {
                        ULONG *pulLength = (ULONG *)
                                   (pbDstRow + rDstColumn.GetLengthOffset());

                        if (rDstColumn.GetStoredType() == VT_VARIANT)
                        {
                            USHORT flags,cbWidth,cbAlign;
                            CTableVariant::VartypeInfo( varnt.vt,
                                                        cbWidth,
                                                        cbAlign,
                                                        flags );
                            if ( CTableVariant::TableIsStoredInline( flags,
                                                                     varnt.vt ) )
                                *pulLength = (ULONG) cbWidth;
                            else
                                *pulLength = (ULONG) varnt.VarDataSize();
                        }
                        else
                        {
                            // PERFFIX - CopyOrCorece should supply the output length!
                            *pulLength = GetValueSize();
                        }
                    }
                }
            }

            Win4Assert( rDstColumn.IsStatusStored() );
            Win4Assert( IsStatusStored() );

            rDstColumn.SetStatus( pbDstRow, GetStatus( pbSrcRow ) );
        }

        tbDebugOut(( DEB_ITRACE, "ColumnStatus: 0x%x\n",
                     rDstColumn.GetStatus( pbDstRow ) ));
    }
#if 0 // we never bind to size/length and NOT bind to value
    else
    {
        //
        //  Destination doesn't need value, check to see if it needs the
        //  length or status.  Get it from the input if it's there.
        //  Assert if the required value is not there.
        //
        //  NOTE:  These values will be valid only for a DBTYPE_VARIANT
        //         result.
        //

        if (rDstColumn.IsLengthStored())
        {
            Win4Assert(VT_VARIANT == rDstColumn.GetStoredType());
            ULONG *pulLength = (ULONG *)
                       (pbDstRow + rDstColumn.GetLengthOffset());

            if (IsLengthStored())
                *pulLength = *(ULONG *) (pbSrcRow + GetLengthOffset());
            else
            {
                Win4Assert(IsValueStored());

                CTableVariant varnt;
                XCompressFreeVariant xpVarnt;

                if ( CreateVariant(varnt, pbSrcRow, rSrcPool) )
                    xpVarnt.Set(GetCompressor(), &varnt);

                USHORT flags,cbWidth,cbAlign;
                CTableVariant::VartypeInfo( varnt.vt,
                                            cbWidth,
                                            cbAlign,
                                            flags );
                if ( CTableVariant::TableIsStoredInline( flags, varnt.vt ) )
                    *pulLength = (ULONG) cbWidth;
                else
                    *pulLength = (ULONG) varnt.VarDataSize();
            }
        }

        // fill-in the column status

        Win4Assert( rDstColumn.IsStatusStored() );
        Win4Assert( IsStatusStored() );

        rDstColumn.SetStatus( pbDstRow, GetStatus( pbSrcRow ) );
    }
#endif // 0:  we never bind to size/length and NOT bind to value
    return DstStatus;
} //CopyColumn


//+-------------------------------------------------------------------------
//
//  Member:     CTableColumn::CreateVariant, public
//
//  Synopsis:   Create a table variant from a source column.
//
//  Arguments:  [rVarnt]        -- reference to variant structure to be filled
//              [pbSrc]         -- source row buffer
//              [rSrcPool]      -- source variable data allocator
//
//  Returns:    BOOL            -- TRUE if variant needs to be freed by
//                                 column compressor.
//
//  Notes:      CLEANCODE - Should this routine take an XCompressFreeVariant as an
//                      input parameter to guard against memory leaks?  An
//                      argument against is that HROW buffers would never
//                      be compressed, and don't need to know about column
//                      compressors.
//
//  History:    22 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

BOOL CTableColumn::CreateVariant(
    CTableVariant &    rVarnt,
    BYTE *             pbSrc,
    PVarAllocator &    rSrcPool
) const {
    //
    //  Advance the row buffer pointer to the stored value data.
    //
    Win4Assert(IsValueStored());
    BYTE * pbSrcRow = pbSrc;
    pbSrc += GetValueOffset();

    if ( IsCompressedCol() )
    {
        GetValueResult eGvr = GetCompressor()->GetData( &rVarnt,
                                         GetStoredType(),
                                         GetValueSize()?
                                            *((ULONG *) (pbSrc)):
                                             0,
                                         PropId);
        if ( GVRSuccess != eGvr )
        {
            rVarnt.vt = VT_EMPTY;
        }

        //
        //  Set up to free the variant when we're done with it.
        //
        return TRUE;
    }
    else
    {
        //
        // There is no compression.
        //

        if (VT_VARIANT == GetStoredType())
        {
            Win4Assert(GetValueSize() == sizeof PROPVARIANT);
            rVarnt = *((CTableVariant *) (pbSrc));
        }
        else
        {
            if ( IsNull( pbSrcRow ) )
                rVarnt.vt = VT_EMPTY;
            else
                rVarnt.Init( GetStoredType(), pbSrc, GetValueSize() );
        }

        if ( rVarnt.VariantPointerInFirstWord() &&
             GetStoredType() != VT_CLSID)      // already stored as pointer
        {
            if (0 == rVarnt.pszVal)
            {
                rVarnt.vt = VT_EMPTY;
                tbDebugOut(( DEB_WARN,
                                "null indirect value for propid %d\n",
                                PropId ));
            }
            else
            {
                rVarnt.pszVal = (LPSTR)
                        rSrcPool.OffsetToPointer((ULONG_PTR)rVarnt.pszVal);
            }
        }
        else if (rVarnt.VariantPointerInSecondWord())
        {
            if (0 == rVarnt.blob.pBlobData)
            {
                rVarnt.vt = VT_EMPTY;
                tbDebugOut(( DEB_WARN,
                                "null indirect value for propid %d\n",
                                PropId ));
            }
            else
            {
                rVarnt.blob.pBlobData = (BYTE *)
                        rSrcPool.OffsetToPointer((ULONG_PTR)rVarnt.blob.pBlobData);
            }
        }
    }   // no compression
    return FALSE;
} // CreateVariant
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tblwindo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       tblwindo.cxx
//
//  Contents:
//
//  Classes:    CTableWindow - a window over a segment of a table
//              XCompressFreeVariant - container for variant which must be freed
//
//  Functions:
//
//  Notes:
//
//  History:    25 Jan 1994     AlanW    Created
//              20 Jun 1995     BartoszM    Added watch regions
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <query.hxx>            // For CGetRowsParams
#include <tbrowkey.hxx>
#include <singlcur.hxx>

#include "tblwindo.hxx"
#include "colcompr.hxx"
#include "tabledbg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::CTableWindow, public
//
//  Synopsis:   Constructor for a window.  Allocates and fills
//              in the column description.  Computes size of
//              per-row data and assigns column offsets.
//              Allocates initial table row data and variable
//              data.  Allocates initial row index.
//
//  Arguments:  [pMasterColumns] -- a pointer to the master column set
//
//  Notes: PERFFIX - vikasman: To save space, we can set up all columns
//         which are not part of the sort set and which are not special
//         columns as deferred columns.
//
//--------------------------------------------------------------------------

CTableWindow::CTableWindow(
    CSortSet const * pSortSet,
    CTableKeyCompare & comparator,
    CColumnMasterSet * pMasterColumns,
    ULONG   segId,
    CCategorize *pCategorize,
    CSharedBuffer & sharedBuf,
    CQAsyncExecute & QExecute
) :     CTableSegment( CTableSegment::eWindow, segId,
                       *pSortSet, comparator ),
        _pSortSet( pSortSet ),
        _Columns( pMasterColumns->Size() ),
        _sharedBuf( sharedBuf ),
        _BookMarkMap(_visibleRowIndex),
        _cPendingDeletes(0),
        _cRowsHardDeleted(0),
        _cRowsAllocated(0),
        _fSplitInProgress(FALSE),
        _cbHeapUsed ( 0 ),
        _pPathStore(0),
        _dynRowIndex(),
        _QueryExecute(QExecute),
        _fCanPartialDefer(QExecute.CanPartialDefer())
{
    tbDebugOut(( DEB_ITRACE, "_CanPartialDefer = %d\n", _fCanPartialDefer ));

    SetCategorizer(pCategorize);

    int cCol = pMasterColumns->Size();

    CTableRowAlloc RowMap(0);

    unsigned maxAlignment = 0;
    _iOffsetWid = ULONG_MAX;
    _iOffsetRowStatus = ULONG_MAX;
    _iOffsetChapter = ULONG_MAX;
    _iOffsetRank = ULONG_MAX;
    _iOffsetHitCount = ULONG_MAX;

    for (int iCol=0; iCol < cCol; iCol++) {
        CColumnMasterDesc& MasterCol = pMasterColumns->Get(iCol);

        if (MasterCol.IsCompressedCol() &&
            MasterCol.GetCompressMasterId() != 0)
        {
            //
            //  Global shared compression; make sure the referenced
            //  column is in the table column set.
            //

            BOOL fFound = FALSE;
            CTableColumn* pColumn =
                _Columns.Find(MasterCol.GetCompressMasterId(), fFound);

            if (fFound != TRUE) {
                CColumnMasterDesc* pMasterComprCol =
                        pMasterColumns->Find(MasterCol.GetCompressMasterId());

                Win4Assert(pMasterComprCol != 0);
                _AddColumnDesc(*pMasterComprCol, RowMap, maxAlignment);
            }
        }
        else if ( pidName == MasterCol.PropId )
        {
            //
            // We must always add the pidPath before pidName if it is
            // present in the MasterColumnSet. This is because we
            // do shared compression for path and name.
            //
            BOOL fPathPresent = FALSE;
            CTableColumn * pWindowPathCol = _Columns.Find( pidPath ,
                                                           fPathPresent );
            if ( !fPathPresent )
            {
                //
                // There is no column for pidPath in the window before
                // this column. Check if there is pidPath in the master
                // column set and if so, add pidPath to the window column
                // set before pidName.
                //
                CColumnMasterDesc * pMasterPathCol =
                                           pMasterColumns->Find( pidPath );
                if ( 0 != pMasterPathCol )
                {
                    _AddColumnDesc( *pMasterPathCol, RowMap, maxAlignment );
                }
            }
        }

        //
        //  See if the column is already there (added for a shared compr)
        //
        BOOL fFound = FALSE;
        CTableColumn* pColumn =
            _Columns.Find(MasterCol.PropId, fFound);

        if (fFound)
            continue;


        _AddColumnDesc(MasterCol, RowMap, maxAlignment);
    }

    _FinishInit( RowMap, maxAlignment );

    END_CONSTRUCTION(CTableWindow);
}

//+---------------------------------------------------------------------------
//
//  Function:   CTableWindow ~ctor
//
//  Synopsis:   Constructor used for creating a new table window with the
//              same structure as an existing table window.
//
//  Arguments:  [src] - Source window which should be used as a basis for
//              the ROW FORMAT only; not the data.
//
//  History:    2-07-95   srikants   Created
//
//  Notes:      This is used during window splitting to create new windows
//              from an existing window.
//
//----------------------------------------------------------------------------

CTableWindow::CTableWindow(
    CTableWindow & src,
    ULONG segId
) :     CTableSegment( src,  segId ),
        _Columns( src._Columns.Count() ),
        _sharedBuf( src._GetSharedBuf() ),
        _BookMarkMap(_visibleRowIndex),
        _pSortSet( src._pSortSet ),
        _cPendingDeletes(0),
        _cRowsHardDeleted(0),
        _cRowsAllocated(0),
        _fSplitInProgress(FALSE),
        _cbHeapUsed ( 0 ),
        _pPathStore(0),
        _dynRowIndex(),
        _QueryExecute(src._QueryExecute),
        _fCanPartialDefer(src._fCanPartialDefer)
{
    SetCategorizer(src.GetCategorizer());

    int cCol = src._Columns.Count();

    CTableRowAlloc RowMap(0);

    unsigned maxAlignment = 0;
    _iOffsetWid = ULONG_MAX;
    _iOffsetRowStatus = ULONG_MAX;
    _iOffsetChapter = ULONG_MAX;
    _iOffsetRank = ULONG_MAX;
    _iOffsetHitCount = ULONG_MAX;

    //
    // PERFFIX: if we don't do window local compression, then we
    // can just copy the column format bit-by-bit and not worry
    // about looking at each column individually. For now, I will leave
    // the loop in place.
    //
    for (int iCol=0; iCol < cCol; iCol++)
    {

        CTableColumn& tableCol = *src._Columns.Get(iCol);

        if ( tableCol.IsCompressedCol() &&
             0 != tableCol.GetCompressMasterId() )
        {

            //
            //  Global shared compression; make sure the referenced
            //  column is in the table column set.
            //

            BOOL fAlreadyPresent = FALSE;
            CTableColumn* pColumn =
                _Columns.Find(tableCol.GetCompressMasterId(), fAlreadyPresent);

            Win4Assert( fAlreadyPresent );

            if (!fAlreadyPresent)
            {
                CTableColumn* pTableComprCol =
                        src._Columns.Find( tableCol.GetCompressMasterId(),
                                           fAlreadyPresent );

                Win4Assert(0 != pTableComprCol);
                _AddColumnDesc(*pTableComprCol, RowMap, maxAlignment);
            }
        }

        //
        //  See if the column is already there (added for a shared compr)
        //
        BOOL fFound = FALSE;
        CTableColumn* pColumn =
            _Columns.Find(tableCol.GetPropId(), fFound);

        if (!fFound)
        {
            _AddColumnDesc(tableCol, RowMap, maxAlignment);
        }
    }

    _FinishInit( RowMap, maxAlignment );
//  tbDebugOut(( DEB_WINSPLIT, "NewWindow-C with id 0x%X\n", segId ));

   END_CONSTRUCTION(CTableWindow);
}


//+---------------------------------------------------------------------------
//
//  Function:   _FinishInit
//
//  Synopsis:   Completes the initialization of the constructor.
//
//  Arguments:  [RowMap]       - RowMap containing the allocation details for
//              the column
//              [maxAlignment] - Maximum alignment requirement
//
//  History:    2-07-95   srikants   Split from the ~ctor to move the common
//                                   code to a function.
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_FinishInit( CTableRowAlloc & RowMap,
                                unsigned & maxAlignment )
{

    Win4Assert(_iOffsetWid != ULONG_MAX);      // workid must be there
    Win4Assert(_iOffsetRowStatus != ULONG_MAX);  // row status must be there
    _cbRowSize = RowMap.GetRowWidth();

    //
    //  Be sure the alignment holds from row to row too.
    //
    if (maxAlignment &&
        ALIGN(_cbRowSize, maxAlignment) != _cbRowSize) {

        RowMap.ReserveRowSpace(
                    _cbRowSize,
                    ALIGN(_cbRowSize, maxAlignment) - _cbRowSize
                );

        _cbRowSize = RowMap.GetRowWidth();
        Win4Assert(ALIGN(_cbRowSize, maxAlignment) == _cbRowSize);
    }

    Win4Assert(_cbRowSize >= sizeof (ULONG) && _cbRowSize < MAX_ROW_SIZE);

    Win4Assert(TBL_PAGE_ALLOC_MIN > _cbRowSize);
    _DataAllocator.SetRowSize(_cbRowSize);

    tbDebugOut(( DEB_ITRACE,
                 "New CTableWindow %08x, Columns: %d\tRowSize: %d\n",
                 this, _Columns.Count(), _cbRowSize ));

    _InitSortComparators();
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::~CTableWindow, public
//
//  Synopsis:   Destructor for a window.  Deallocates any memory,
//              and releases resources.
//
//  Notes:      All work is done by sub-object destructors
//
//--------------------------------------------------------------------------

CTableWindow::~CTableWindow(void)
{
    tbDebugOut(( DEB_WINSPLIT, "Destroying Window 0x%X\n", GetSegId() ));

//    Win4Assert(_cbHeapUsed == 0);
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::_AddColumnDesc, private
//
//  Synopsis:   Add a column description to a table
//
//  Arguments:  [MasterCol] - a reference to a master column description
//                      for the column to be added
//              [RowMap] - a reference to a row allocation map for
//                      allocating row data
//              [maxAlignment] - maximumn alignment constraint for the
//                      allocated row
//
//  Returns:    Nothing
//
//  Effects:    Space is allocated in the RowMap, maxAlignment is
//              adjusted.
//
//  Notes:
//
//--------------------------------------------------------------------------

void
CTableWindow::_AddColumnDesc(
    CColumnMasterDesc& MasterCol,
    CTableRowAlloc& RowMap,
    unsigned& maxAlignment
    )
{
    VARTYPE vt = MasterCol.DataType;
    if (vt == VT_NULL)
        vt = VT_VARIANT;

    //
    //  The data type VT_EMPTY is used for columns like bookmark which
    //  may occur in the master column set, but which has no data
    //  stored in the table.  Don't even bother adding it to the table
    //  column set.
    //
    if (vt == VT_EMPTY)
        return;

    XPtr<CTableColumn> xTableCol( new CTableColumn( MasterCol.PropId, vt ) );

    _cbHeapUsed += sizeof CTableColumn;


    // If we can make this partial deferred, do so and get out
    if ( _fCanPartialDefer && _CanPartialDeferCol( xTableCol ) )
    {

        tbDebugOut(( DEB_ITRACE,
                 "Setting col as partial deferred propid = %x\n",
                 xTableCol->GetPropId()));

        xTableCol->SetPartialDeferred( TRUE );

        _Columns.Add( xTableCol.GetPointer(), _Columns.Count() );
        xTableCol.Acquire();

        return;
    }

    USHORT cbData, cbAlignment, rgfFlags;

    CTableVariant::VartypeInfo(vt, cbData, cbAlignment, rgfFlags);
    Win4Assert(cbData != 0);

    if (cbData == 0)
    {
        tbDebugOut(( DEB_WARN,
                    "Unknown variant type %4x for propid %d\n",
                    vt, MasterCol.PropId ));
    }

    if (MasterCol.IsCompressedCol())
    {
        //
        //  Global compression; save a pointer to the
        //  compressor.
        //

        xTableCol->SetGlobalCompressor( MasterCol.GetCompressor(),
                                        MasterCol.GetCompressMasterId() );

        if (xTableCol->GetCompressMasterId() != 0)
        {
            //
            //  Look up the masterID, point the data offset and width
            //  to it.  Shadow the existing column.
            //

            BOOL fFound = FALSE;
            CTableColumn* pColumn =
                _Columns.Find(MasterCol.GetCompressMasterId(), fFound);
            Win4Assert(fFound == TRUE);

            xTableCol->SetValueField( vt,
                                      pColumn->GetValueOffset(),
                                      pColumn->GetValueSize() );
            cbData = 0;         // indicate no new data needed

            Win4Assert( pColumn->IsStatusStored() );

            xTableCol->SetStatusField( pColumn->GetStatusOffset(), sizeof (BYTE) );
        }
        else
        {
            cbData = cbAlignment = sizeof (ULONG);
        }
    }

    if (cbAlignment)
    {
        if (cbAlignment > maxAlignment)
            maxAlignment = cbAlignment;
    }
    else
    {
        cbAlignment = 1;
    }

    if (cbData != 0)
    {
        xTableCol->SetValueField( vt,
                            RowMap.AllocOffset( cbData, cbAlignment, TRUE ),
                                  cbData);

        // Always add a status byte -- even storage props may not be present
        // for summary catalogs.  For others, need to know if the value is
        // deferred.

        xTableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                       sizeof (BYTE),
                                                       TRUE ),
                                                       sizeof (BYTE));
    }

    if (xTableCol->PropId == pidWorkId)
    {
        _iOffsetWid = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidRank)
    {
        _iOffsetRank = xTableCol->GetValueOffset();
    }
    else if (xTableCol->PropId == pidHitCount)
    {
        _iOffsetHitCount = xTableCol->GetValueOffset();
    }
    else if (xTableCol->PropId == pidRowStatus)
    {
        _iOffsetRowStatus = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidChapter)
    {
        _iOffsetChapter = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidSelf)
    {
        xTableCol->MarkAsSpecial();
    }
    else if ( xTableCol->IsCompressedCol() && 0 != xTableCol->GetCompressMasterId() )
    {
        xTableCol->MarkAsSpecial();
    }

#if CIDBG==1
    if ( xTableCol->IsValueStored() )
        Win4Assert( xTableCol->IsStatusStored() );
#endif

    _Columns.Add( xTableCol.GetPointer(), _Columns.Count() );
    xTableCol.Acquire();
} //_AddColumnDesc


//+---------------------------------------------------------------------------
//
//  Function:   CTableWindow::_AddColumnDesc, private
//
//  Synopsis:   Add a column description to the table based on another
//              column description.
//
//  Arguments:  [srcTableCol]  -  The source upon which the new column table
//                      description is based
//              [RowMap]       -  a reference to a row allocation map for
//                      allocating row data
//              [maxAlignment] -  maximumn alignment constraint for the
//                      allocated row.
//
//  History:    2-07-95   srikants   Created
//              11-Nov-99 KLam       size check only valid for non-compressed
//                                   columns
//
//  Notes:
//
//----------------------------------------------------------------------------


void
CTableWindow::_AddColumnDesc(
    CTableColumn& srcTableCol,
    CTableRowAlloc& RowMap,
    unsigned& maxAlignment
)
{
    XPtr<CTableColumn> xTableCol( new CTableColumn(srcTableCol) );

    _cbHeapUsed += sizeof CTableColumn;

    // If partial deferred, just add and return
    if ( xTableCol->IsPartialDeferred() )
    {
        _Columns.Add( xTableCol.GetPointer(), _Columns.Count() );
        xTableCol.Acquire();

        return;
    }


    VARTYPE vt = srcTableCol.GetStoredType();

    USHORT cbData, cbAlignment, rgfFlags;

    CTableVariant::VartypeInfo(vt, cbData, cbAlignment, rgfFlags);

    // Globally compressed columns either have a size of 0 or the size of the key
    // in the column
    Win4Assert( cbData != 0  
                || ( srcTableCol.IsGlobalCompressedCol() 
                     && srcTableCol.GetCompressMasterId() ) );
    Win4Assert( cbData == srcTableCol.GetValueSize() 
                || srcTableCol.IsGlobalCompressedCol() );

    if ( 0 == cbData )
    {
        tbDebugOut(( DEB_WARN,
                    "Unknown variant type %4x for propid %d\n",
                    vt, srcTableCol.GetPropId() ));
    }

    //
    //  Store strings by reference
    //
    if ( (rgfFlags & CTableVariant::ByRef) &&
         !(rgfFlags & CTableVariant::StoreDirect))
    {
        Win4Assert( 0 == ( vt & VT_BYREF ) );
    }

    if ( srcTableCol.IsCompressedCol() )
    {
        if ( srcTableCol.IsGlobalCompressedCol() )
        {
            if ( 0 != srcTableCol.GetCompressMasterId() )
            {
                cbData = 0;         // indicate no new data needed
            }
            else
            {
                // This size is refering to the size of the compression key
                cbData = cbAlignment = sizeof (ULONG);
            }
        }
        else
        {

            //
            // There is local compression in the source table.
            //
            if ( (pidName == srcTableCol.PropId) || (pidPath == srcTableCol.PropId ) )
            {
            }
            else
            {
                //
                // How did the local compression got set when it
                // is not yet implemented.
                //
                Win4Assert( !"TableWindow - Local Compression - NYI " );
            }
        }
    }

    if (cbAlignment)
    {
        if (cbAlignment > maxAlignment)
            maxAlignment = cbAlignment;
    }
    else
    {
        cbAlignment = 1;
    }

    //
    //  This SetValueField call is not necessary for setting the
    //  values in the column, since those have already been copied
    //  from the source column, but this has the important side-effect
    //  of updating the RowMap (which will presumably give back the
    //  same values as the original allocation).
    //
    if (cbData != 0)
    {
        xTableCol->SetValueField( vt,
                            RowMap.AllocOffset( cbData, cbAlignment, TRUE ),
                                  cbData);

        Win4Assert( xTableCol->GetValueOffset() == srcTableCol.GetValueOffset() );

        // Always add a status byte -- even storage props may not be present
        // for summary catalogs.  For others, need to know if the value is
        // deferred.

        xTableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                       sizeof (BYTE),
                                                       TRUE ),
                                   sizeof (BYTE));
    }

    if (xTableCol->PropId == pidWorkId)
    {
        _iOffsetWid = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidRank)
    {
        _iOffsetRank = xTableCol->GetValueOffset();
    }
    else if (xTableCol->PropId == pidHitCount)
    {
        _iOffsetHitCount = xTableCol->GetValueOffset();
    }
    else if (xTableCol->PropId == pidRowStatus)
    {
        _iOffsetRowStatus = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidChapter)
    {
        _iOffsetChapter = xTableCol->GetValueOffset();
        xTableCol->MarkAsSpecial();
    }
    else if (xTableCol->PropId == pidSelf)
    {
        xTableCol->MarkAsSpecial();
    }
    else if ( xTableCol->IsCompressedCol() && 0 != xTableCol->GetCompressMasterId() )
    {
        xTableCol->MarkAsSpecial();
    }

#if CIDBG==1
    if ( xTableCol->IsValueStored() )
        Win4Assert( xTableCol->IsStatusStored() );
#endif

    _Columns.Add(xTableCol.GetPointer(), _Columns.Count());
    xTableCol.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_PopulateRow, private
//
//  Synopsis:   Extracts row data from an object cursor into row storage
//
//  Arguments:  [obj]      -- source of data
//              [pThisRow] -- where to put the data
//              [wid]      -- workid of the row
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CTableWindow::_PopulateRow(
    CRetriever & obj,
    BYTE *       pThisRow,
    WORKID       wid )
{
    Win4Assert(!(wid & 0x80000000));    // Bad work ID?
    _SetRowWorkid(pThisRow, wid);

    //
    // Temporary buffer for column data.  If it doesn't fit in this
    // buffer, defer the load.  The buffer is owned by CLargeTable
    // and is only accessed under the lock taken in CLargeTable::PutRow
    //

    XUseSharedBuffer xSharedBuf(_sharedBuf);
    XArray<BYTE>     xBuf;

    CTableVariant* pvarnt = (CTableVariant *) xSharedBuf.LokGetBuffer();
    unsigned cbBuf        = xSharedBuf.LokGetSize();

    for (unsigned i=0; i < _Columns.Count(); i++)
    {
        CTableColumn* pColumn = _Columns[ i ];

        // Ignore PartailDeferred columns here. Retrieve data only when
        // requested by the client
        if ( pColumn->IsPartialDeferred() )
        {
            continue;
        }

        Win4Assert( pColumn->IsStatusStored() );

        // Some columns have special processing and don't need to go through
        // this loop.

        if ( pColumn->IsSpecial() )
        {
            pColumn->SetStatus( pThisRow, CTableColumn::StoreStatusOK );
            continue;
        }


        ULONG cbLength = cbBuf;

        VARTYPE vt = pColumn->GetStoredType();

        // it'd be a "special" column handled above if it were VT_EMPTY
        Win4Assert( VT_EMPTY != vt );

        GetValueResult eGvr = obj.GetPropertyValue( pColumn->PropId,
                                                    pvarnt,
                                                    &cbLength );

        CTableColumn::StoreStatus stat = CTableColumn::StoreStatusOK;

        switch ( eGvr )
        {
        case GVRSuccess:
            break;

        case GVRNotAvailable:
            pvarnt->vt = VT_EMPTY;
            stat = CTableColumn::StoreStatusNull;
            break;

        case GVRNotEnoughSpace:
            {
                tbDebugOut(( DEB_ITRACE,
                             "variant data too large for propid %d\n",
                             pColumn->PropId ));

                stat = CTableColumn::StoreStatusDeferred;

                if ( pColumn->IsLengthStored() )
                    * (ULONG *) (pThisRow + pColumn->GetLengthOffset()) = cbLength;
            }
            break;

        case GVRSharingViolation:
            pvarnt->vt = VT_EMPTY;
            stat = CTableColumn::StoreStatusNull;
            break;

        default:
            //
            // There was an error while retrieving the column from the
            // retriever.
            //
            THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
            break;
        }

        BYTE* pRowColDataBuf = pThisRow + pColumn->GetValueOffset();
        ULONG cbRowColDataBuf = pColumn->GetValueSize();

        RtlZeroMemory(pRowColDataBuf, cbRowColDataBuf);

        Win4Assert( pColumn->IsStatusStored() );

        if ( ( CTableColumn::StoreStatusOK == stat ) &&
             ( VT_EMPTY == pvarnt->vt ) )
            pColumn->SetStatus( pThisRow, CTableColumn::StoreStatusNull );
        else
            pColumn->SetStatus( pThisRow, stat );

        if ( CTableColumn::StoreStatusOK == stat )
        {
            if ( pColumn->IsLengthStored() )
                * (ULONG *) (pThisRow + pColumn->GetLengthOffset()) = cbLength;

            //
            //  Store the property value in the table.  The main cases
            //  handled below are:
            //
            //  1.  The column is compressed.  In this case, the column
            //      compressor will handle it.
            //  2.  The column is stored as a variant.  Just store the
            //      value, as long as it's not too big.
            //  3.  The column is stored as a data value, and the property
            //      value is of the same type.  Just store the data value.
            //  4.  The column is stored as a data value, and the property
            //      value is of a different type.  In this case, attempt to
            //      convert the value to another type and store it.  Otherwise
            //      fail.
            // BROKENCODE - failure here could be the wrong thing to do.  Other
            //      things that could be done include converting the column
            //      (might be the correct thing to do if it's a range error
            //      on a column which has been range compressed), or storing
            //      the value as an exception (might be the correct thing to
            //      do when it is a column which has been type compressed).
            //

            if (pColumn->IsCompressedCol())
            {
                pColumn->GetCompressor()->AddData(pvarnt,
                                                cbRowColDataBuf?
                                                    (ULONG *)pRowColDataBuf: 0,
                                                eGvr);
            }
            else
            {
                DBLENGTH ulTemp;
                pvarnt->CopyOrCoerce( pRowColDataBuf,
                                      cbRowColDataBuf,
                                      vt,
                                      ulTemp,
                                      _DataAllocator );
            }
        }
    }
} //_PopulateRow

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::PutRow, public
//
//  Synopsis:   Add a row to a large table
//
//  Arguments:  [obj]  -- a pointer to an accessor which can
//                                  return object data
//
//  Returns:    FALSE -- Don't need progress indication
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------


BOOL CTableWindow::PutRow( CRetriever& obj, CTableRowKey & currKey )
{
    WORKID wid = obj.WorkId();

    //
    //  NOTE:  Even if in the initial fill, first check to see if the row
    //         is already in the table.  We may see the same work ID
    //         multiple times due to links.
    //

    TBL_OFF obRow;
    ULONG     iRowOrdinal;
    BOOL fExisting = _FindWorkId(wid, obRow, iRowOrdinal);
//    Win4Assert( !fExisting &&
//         "Modifications must be treated as deletions followed by additions" );

    if ( fExisting )
    {
        BYTE * pbOldRow = _DataAllocator.FixedPointer( obRow );
        if ( TBL_DATA_PENDING_DELETE != _RowStatus(pbOldRow) )
        {
            tbDebugOut(( DEB_WARN, "Not adding a linked object with wid 0x%X \n", wid ));
            return FALSE;
        }
        else
        {
            //
            // There can be a pending delete only if there is a watch
            // region.
            //
            Win4Assert( IsWatched() );
        }
    }

    BYTE * pThisRow = _RowAlloc();

    Win4Assert(pThisRow != NULL);

    _PopulateRow( obj, pThisRow, wid );

    TBL_OFF oTableRow = _DataAllocator.FixedOffset(pThisRow);

    CRowIndex & rowIndex = _GetInvisibleRowIndex();

    ULONG iRowPos = rowIndex.AddRow(oTableRow);

    tbDebugOut(( DEB_BOOKMARK,
        "CTableWindow::PutRow Add new row Wid 0x%X -- Segment 0x%X -- oTable 0x%X \n",
        wid, GetSegId(), oTableRow ));

    _SetRowStatus(pThisRow,TBL_DATA_ROWADDED);

    if ( !IsWatched() )
    {
        //
        // There are no notifications enabled for this window. So, we
        // should add the entry to the book mark mapping.
        //
        _BookMarkMap.AddReplaceBookMark( wid, oTableRow );
    }
    else
    {
        _xDeltaBookMarkMap->AddReplaceBookMark( wid, oTableRow );
    }

    if ( IsCategorized() )
    {
        CCategParams params = { wid, widInvalid, widInvalid,
                                chaptInvalid, chaptInvalid,
                                0, 0 };

        if ( 0 != iRowPos )
        {
            BYTE * pb = (BYTE *) _DataAllocator.FixedPointer(
                                 rowIndex.GetRow( iRowPos - 1) );
            params.widPrev = RowWorkid( pb );
            params.catPrev = _RowChapter( pb );
        }
        if ( (iRowPos + 1) != rowIndex.RowCount() )
        {
            BYTE * pb = (BYTE *) _DataAllocator.FixedPointer(
                                 rowIndex.GetRow( iRowPos + 1) );
            params.widNext = RowWorkid( pb );
            params.catNext = _RowChapter( pb );
        }

        if ( ( chaptInvalid   == params.catPrev ) ||
             ( params.catNext != params.catPrev ) )
        {
            // new row is not sandwiched between rows in same category,
            // so come up with positive column # where the new row
            // differs from its neighbors.

            if ( widInvalid != params.widPrev )
                params.icmpPrev = _CompareRows( rowIndex.GetRow( iRowPos ),
                                                rowIndex.GetRow( iRowPos - 1 ));
            if ( widInvalid != params.widNext )
                params.icmpNext = _CompareRows( rowIndex.GetRow( iRowPos + 1),
                                                rowIndex.GetRow( iRowPos ));
        }

        _SetChapter( pThisRow, LokCategorize( params ) );
    }

    // Update Low and High Keys, if necessary, based on the rowpos of the new row

    BOOL fReady = FALSE;

    if ( 0 == iRowPos )
    {
        // need to update lowkey

        currKey.MakeReady();
        fReady = TRUE;
        _lowKey = currKey;
    }

    if ( RowCount() - 1 == iRowPos )
    {
        // need to update highKey

        if ( !fReady )
            currKey.MakeReady();
        _highKey = currKey;
    }

    return FALSE; // no need for progress calculation
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::_FindWorkId, public
//
//  Synopsis:   Find the row associated with a work ID
//
//  Arguments:  [wid] -- work ID to be found
//              [obRow] - set to the row offset from the base of the
//                      row data if the workid was found
//              [riRowOrdinal] - set to the ordinal row number if the
//                      workid was found (the row index ordinal)
//
//  Returns:    BOOL - TRUE if wid is represented in this window, FALSE
//                      otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL  CTableWindow::_FindWorkId(
    WORKID      wid,
    TBL_OFF & obRow,
    ULONG &     riRowOrdinal
)
{
    //
    // A linear search is made in the dynamic row index based on whether
    // an entry exists in the bookmark mapping or not. This will eliminate
    // searches in cases where the wid does not exist in the window.
    //
    BOOL fFound = FALSE;

    if ( !IsWatched() )
    {
        //
        // The notifications are not enabled. The "visible" bookmark mapping
        // is uptodate and has all the entries.
        //
        fFound = _BookMarkMap.FindBookMark( wid, obRow, riRowOrdinal );
    }
    else
    {
        BOOL fLookInDynRowIndex = FALSE;
        //
        // Since notifications are enabled, we must first look for the wid
        // in the "delta" bookmark mapping and then in the "visible" bookmark
        // mapping. If a "valid" bookmark mapping exists, then we must locate the
        // row ordinal in the "dynamic" row index.
        //
        if ( _xDeltaBookMarkMap->FindBookMark(wid, obRow) )
        {
            fLookInDynRowIndex = TRUE;
        }
        else if ( _BookMarkMap.FindBookMark(wid, obRow) )
        {
            //
            // If it is in the static book mark mapping, then only the
            // rows with the TBL_DATA_OKAY are valid for further look up.
            //
            BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(obRow);
            fLookInDynRowIndex =  TBL_DATA_OKAY == _RowStatus(pbRow);
        }

        if (fLookInDynRowIndex)
            fFound = _dynRowIndex.FindRow(obRow, riRowOrdinal);
    }

#if 0
    //
    // This is an expensive test.  Re-add it if there are bugs
    //
    if ( !fFound )
    {
        CRowIndex & srchRowIndex = _GetInvisibleRowIndex();

        for (unsigned i = 0; i < srchRowIndex.RowCount(); i++)
        {
            BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(srchRowIndex.GetRow(i));

            Win4Assert(0 != pbRow);
            Win4Assert( _RowStatus(pbRow) != TBL_DATA_PENDING_DELETE &&
                        _RowStatus(pbRow) != TBL_DATA_SOFT_DELETE );

            if (RowWorkid(pbRow) == wid)
            {
                Win4Assert( !"Must not be found" );

                obRow = srchRowIndex.GetRow(i);
                riRowOrdinal = i;
                return TRUE;
            }
        }
    }

#endif

    return fFound;

}

//+---------------------------------------------------------------------------
//
//  Function:   CTableWindow::FindBookMark, private
//
//  Synopsis:   Locates the requested bookmark using the bookmark mapping.
//
//  Arguments:  [wid]          --  WorkId to locate
//              [obRow]  --  set to the row offset from the base of the
//                      row data if the workid was found
//              [riRowOrdinal] --  set to the ordinal row number if the
//                      workid was found (the row index ordinal)
//
//  History:    11-30-94   srikants   Created
//
//  Notes:      This method differs from the _FindWorkId in that this uses
//              the book mark mapping and _FindWorkId does not. When
//              notifications are enabled for this window, we add rows to the
//              "dynamic" row index but do not add the corresponding entry
//              to the book mark mapping. In that case, we cannot use the
//              BookMarkMap to locate the work id.
//
//----------------------------------------------------------------------------

BOOL  CTableWindow::FindBookMark(
    WORKID      wid,
    TBL_OFF & obRow,
    ULONG &     riRowOrdinal
)
{

    BOOL fFound = FALSE;

    if ( _visibleRowIndex.RowCount() > 0 )
    {
        if ( WORKID_TBLFIRST == wid )
        {
            riRowOrdinal = 0;
            obRow = _visibleRowIndex.GetRow(riRowOrdinal);
            fFound = TRUE;
        }
        else if ( WORKID_TBLLAST == wid )
        {
            riRowOrdinal = _visibleRowIndex.RowCount()-1;
            obRow = _visibleRowIndex.GetRow(riRowOrdinal);
            fFound = TRUE;
        }
        else
        {
            fFound = _BookMarkMap.FindBookMark( wid, obRow, riRowOrdinal );
        }
    }

    return fFound;

}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::IsRowInSegment, inline
//
//  Synopsis:   Determine if a row for some work ID exists in the table.
//
//  Arguments:  [wid] -- work ID to be found
//
//  Returns:    BOOL - TRUE if wid is represented in this window, FALSE
//                      otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL  CTableWindow::IsRowInSegment(WORKID wid)
{
    TBL_OFF iRowOffset;
    ULONG iRow;
    return _FindWorkId(wid, iRowOffset, iRow);
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::GetRows
//
//  Synopsis:   Return a set of row data to the caller
//
//  Arguments:  [hRegion] - region to be expanded
//              [widStart] - WORKID identifying first row to be
//                      transferred.  If WORKID_TBLBEFOREFIRST or
//                      WORKID_TBLFIRST is used, the transfer will
//                      start at the first row in the segment.
//              [chapt]    - Chapter from which to fetch rows (if chaptered)
//              [rOutColumns] - a CTableColumnSet that describes the
//                      output format of the data table.
//              [rGetParams] - an CGetRowsParams structure which
//                      describes how many rows are to be fetched and
//                      other parameters of the operation.
//              [rwidLastRowTransferred] - on return, the work ID of
//                      the next row to be transferred from this table.
//                      Can be used as widStart on next call.
//
//  Returns:    SCODE - status of the operation.  DB_S_ENDOFROWSET if
//                      widStart is WORKID_TBLAFTERLAST at start of
//                      transfer, or if rwidLastRowTransferred is
//                      the last row in the table segment at the end
//                      of the transfer, and not all requested rows were
//                      transferred.
//                      DB_S_BLOCKLIMITEDROWS if insufficient space is
//                      available in the pVarAllocator.
//
//  Notes:      Extends the watch region (if handle non-zero)
//
//--------------------------------------------------------------------------

SCODE   CTableWindow::GetRows(
    HWATCHREGION              hRegion,
    WORKID                    widStart,
    CI_TBL_CHAPT              chapt,
    ULONG &                   cRowsToGet,
    CTableColumnSet const &   rOutColumns,
    CGetRowsParams &          rGetParams,
    WORKID&                   rwidLastRowTransferred
) {

    tbDebugOut(( DEB_BOOKMARK, "CTableWindow::GetRows called with starting wid 0x%X\n", widStart ));

    if (widStart == WORKID_TBLAFTERLAST)
    {
        rwidLastRowTransferred = WORKID_TBLAFTERLAST;
        tbDebugOut(( DEB_BOOKMARK, "CTableWindow::GetRows returning with 0x%X\n",
                     DB_S_ENDOFROWSET ));
        return DB_S_ENDOFROWSET;
    }

    if (widStart == widInvalid)
    {
        tbDebugOut(( DEB_BOOKMARK, "CTableWindow::GetRows returning with 0x%X\n", E_FAIL ));
        return E_FAIL;          // maybe the wid got deleted???
    }

    ULONG iRowIndex = 0;        // Starting row as an index in the row index

    CRowIndex * pRowIndex = _BookMarkMap.GetRowIndex();
    Win4Assert( pRowIndex == &_visibleRowIndex );

    if ( widStart == WORKID_TBLLAST )
        iRowIndex = pRowIndex->RowCount() - 1;

    if (widStart != WORKID_TBLFIRST
        && widStart != WORKID_TBLBEFOREFIRST
        && widStart != WORKID_TBLLAST )
    {
        TBL_OFF iRowOffset = 0; // Starting row as an offset into row data
        BOOL fFound = FindBookMark(widStart, iRowOffset, iRowIndex);

        if (!fFound)
            return E_FAIL;
    }
    else if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
    {
        // turn special wids (first/last) into real wids in the chapter

        if ( !rGetParams.GetFwdFetch() )
            Win4Assert( !"Backwards fetch not yet implemented for categorized rowsets" );

        TBL_OFF iRowOffset = 0;
        if ( !_FindWorkId( GetCategorizer()->GetFirstWorkid( chapt ),
                           iRowOffset,
                           iRowIndex ) )
        {
            // must be a continuation of getrows from a previous window
            iRowIndex = 0;
        }
    }

    SCODE scResult = S_OK;

    //
    // iRowIndex is a ulong, and so after row 0 is fetched (in
    // backwards fetch) we set fBwdRowsExhausted to true, instead
    // decrementing 0, which is the value of iRowIndex.
    // fBwdRowsExhausted is initialy true if there are 0 rows in this
    // segment.
    //
    BOOL fBwdRowsExhausted = pRowIndex->RowCount() == 0;

    //
    // This flag is set to true, if rOutColumns contains at least one
    // partially deferred column
    //
    BOOL fPartialDeferredCols = FALSE;

    Win4Assert( 0 != pRowIndex );

    TRY
    {
        const COUNT_CACHED_TABLE_COLS = 10;        // Size of cached column array
        CTableColumn *apTableCol[COUNT_CACHED_TABLE_COLS];

        CTableColumn **pTableCols = apTableCol;

        XArray<CTableColumn *> xaTableCol;
        if ( rOutColumns.Count() > COUNT_CACHED_TABLE_COLS )
        {
            xaTableCol.Init( rOutColumns.Count() );
            pTableCols = xaTableCol.GetPointer();
        }

        for (unsigned i=0; i < rOutColumns.Count(); i++)
        {
            CTableColumn const & outColumn = *rOutColumns[ i ];

            BOOL fFound = FALSE;
            pTableCols[i] = _Columns.Find( outColumn.PropId, fFound );
            Win4Assert(fFound == TRUE);

            fPartialDeferredCols = ( fPartialDeferredCols ||
                                     pTableCols[i]->IsPartialDeferred() );
        }

        //
        // FRowsRemaining tests whether there are rows remaining.
        // The test differs for forward and backwards fetch.
        //

        BOOL fRowsRemaining;
        if ( rGetParams.GetFwdFetch() )
            fRowsRemaining = iRowIndex < pRowIndex->RowCount();
        else
            fRowsRemaining = !fBwdRowsExhausted;

        //
        // Set up the cursor in case we have partial deferred column(s)
        //

        BOOL fAbort = FALSE;

        if ( fPartialDeferredCols && _xCursor.IsNull() )
        {
            _xCursor.Set( _QueryExecute.GetSingletonCursor( fAbort ) );
            Win4Assert( _xCursor.GetPointer() );
        }

        while ( 0 != cRowsToGet && fRowsRemaining )
        {
            BYTE *pRow = (BYTE *)
                    _DataAllocator.FixedPointer(pRowIndex->GetRow(iRowIndex));

            // If we've moved on to another chapter, stop retrieving rows

            if ( IsCategorized() &&
                 DB_NULL_HCHAPTER != chapt &&
                 (_RowChapter(pRow) != chapt) )
            {
                scResult = DB_S_ENDOFROWSET;
                break;
            }

            BYTE* pbOutRow = (BYTE *)rGetParams.GetRowBuffer();

            //
            // Update RowId in xCursor if we have partial deferred column(s)
            //

            if ( fPartialDeferredCols )
            {
                _xCursor->SetCurrentWorkId( RowWorkid( pRow ) );
                Win4Assert( _xCursor->WorkId() != widInvalid );
            }

            _CopyColumnData( pRow,
                             pbOutRow,
                             pTableCols,
                             rOutColumns,
                             rGetParams.GetVarAllocator(),
                             _xCursor.GetPointer() );

            //
            //  We've transferred a row.  Update pointers and counters.
            //

            rwidLastRowTransferred = RowWorkid((BYTE *)_DataAllocator.
                                     FixedPointer(pRowIndex->GetRow(iRowIndex)));

            if ( rGetParams.GetFwdFetch() )
                iRowIndex++;
            else
            {
                if ( iRowIndex == 0 )
                    fBwdRowsExhausted = TRUE;
                else
                    iRowIndex--;
            }

            rGetParams.IncrementRowCount();
            cRowsToGet--;

            if ( rGetParams.GetFwdFetch() )
                fRowsRemaining = iRowIndex < pRowIndex->RowCount();
            else
                fRowsRemaining = !fBwdRowsExhausted;
        }
    }

    CATCH( CException, e )
    {
        scResult = e.GetErrorCode();

        if ( STATUS_BUFFER_TOO_SMALL == scResult &&
             rGetParams.RowsTransferred() > 0 )
            scResult = DB_S_BLOCKLIMITEDROWS;
    }
    END_CATCH

    if (! _xCursor.IsNull() )
        _xCursor->Quiesce( );

    if (iRowIndex >= pRowIndex->RowCount() || fBwdRowsExhausted )
    {
        Win4Assert(scResult != DB_S_BLOCKLIMITEDROWS);
        tbDebugOut(( DEB_BOOKMARK, "CTableWindow::GetRows End of table window\n" ));
        return DB_S_ENDOFROWSET;
    }
    else
    {
        tbDebugOut(( DEB_BOOKMARK, "CTableWindow::GetRows next wid 0x%X\n", rwidLastRowTransferred ));
        return scResult;
    }
} //GetRows

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_CopyColumnData, private
//
//  Synopsis:   Goes thru the list of output columns and transfers
//              data to pbOutRow for them. The input data either comes
//              from pbSrcRow or in case of partially deferred column
//              we retrive it from the CRetriever object
//
//  Arguments:  [pSrcRow]      -- the src row
//              [pThisRow]     -- where to put the data
//              [pTableCols]   -- table(input) column set corr. to output columns
//              [rOutColumns]  -- output column set
//              [rDstPool]     -- destination variable data allocator
//              [obj]          -- source of data
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CTableWindow::_CopyColumnData(
    BYTE* pbSrcRow,
    BYTE* pbOutRow,
    CTableColumn **pTableCols,
    CTableColumnSet const& rOutColumns,
    PVarAllocator& rDstPool,
    CRetriever* obj /* = NULL */ )
{

    //
    // Temporary buffer for column data.  If it doesn't fit in this
    // buffer, defer the load.  The buffer is owned by CLargeTable.
    // and is only accessed under the lock taken in CLargeTable::GetRowsAt
    //
    XUseSharedBuffer xSharedBuf(_sharedBuf);
    CTableVariant* pvarnt = (CTableVariant *) xSharedBuf.LokGetBuffer();
    unsigned cbBuf        = xSharedBuf.LokGetSize();

    for (unsigned i=0; i < rOutColumns.Count(); i++)
    {
        CTableColumn * pColumn = pTableCols[i];
        Win4Assert(pColumn);

        CTableColumn* pOutColumn = rOutColumns[ i ];
        Win4Assert(pOutColumn);

        if ( !pColumn->IsPartialDeferred() )
        {
            pColumn->CopyColumnData( pbOutRow,
                                     *pOutColumn,
                                     rDstPool,
                                     pbSrcRow,
                                     _DataAllocator );
            continue;
        }


        ULONG cbLength = cbBuf;

        VARTYPE vt = pOutColumn->GetStoredType();

        Win4Assert( obj );

        GetValueResult eGvr = obj->GetPropertyValue( pColumn->PropId,
                                                     pvarnt,
                                                     &cbLength );

        CTableColumn::StoreStatus stat = CTableColumn::StoreStatusOK;

        switch ( eGvr )
        {
        case GVRSuccess:
            break;

        case GVRNotAvailable:
            pvarnt->vt = VT_EMPTY;
            stat = CTableColumn::StoreStatusNull;
            break;

        case GVRNotEnoughSpace:
            {
                tbDebugOut(( DEB_ITRACE,
                             "variant data too large for propid %d\n",
                             pColumn->PropId ));

                stat = CTableColumn::StoreStatusDeferred;

                if ( pOutColumn->IsLengthStored() )
                    * (ULONG *) (pbOutRow + pOutColumn->GetLengthOffset()) = cbLength;
            }
            break;

        case GVRSharingViolation:
            pvarnt->vt = VT_EMPTY;
            stat = CTableColumn::StoreStatusNull;
            break;

        default:
            //
            // There was an error while retrieving the column from the
            // retriever.
            THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
            break;
        }

        BYTE* pRowColDataBuf = pbOutRow + pOutColumn->GetValueOffset();
        ULONG cbRowColDataBuf = pOutColumn->GetValueSize();

        RtlZeroMemory(pRowColDataBuf, cbRowColDataBuf);

        Win4Assert( pOutColumn->IsStatusStored() );

        if ( ( CTableColumn::StoreStatusOK == stat ) &&
             ( VT_EMPTY == pvarnt->vt ) )
            pOutColumn->SetStatus( pbOutRow, CTableColumn::StoreStatusNull );
        else
            pOutColumn->SetStatus( pbOutRow, stat );

        if ( CTableColumn::StoreStatusOK == stat )
        {
            if ( pOutColumn->IsLengthStored() )
                * (ULONG *) (pbOutRow + pOutColumn->GetLengthOffset()) = cbLength;

            if (pOutColumn->IsCompressedCol())
            {
                pOutColumn->GetCompressor()->AddData(pvarnt,
                                                     cbRowColDataBuf?
                                                     (ULONG *)pRowColDataBuf: 0,
                                                     eGvr);
            }
            else
            {
                DBLENGTH ulTemp;
                pvarnt->CopyOrCoerce( pRowColDataBuf,
                                      cbRowColDataBuf,
                                      vt,
                                      ulTemp,
                                      rDstPool );
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::RemoveRow, public
//
//  Synopsis:   Removes a row from the table, if it exists.
//
//  Arguments:  [varUnique]   -- Variant that uniquely identifies the row.
//              [widNext]     -- Returns workid of row immediately after
//                               deleted row, used for categorization.
//              [chapt]       -- Returns chapter of deleted row.
//
//  Returns:    TRUE if the row existed or FALSE otherwise
//
//  History:    24 Oct 1994     dlee   Created
//
//  BROKENCODE/NEWFEATURE:  update min/max wid?  This code won't be called...
//
//--------------------------------------------------------------------------

BOOL CTableWindow::RemoveRow(
    PROPVARIANT const & varUnique,
    WORKID &        widNext,
    CI_TBL_CHAPT & chapt )
{
    Win4Assert(varUnique.vt == VT_I4);

    WORKID wid = (WORKID) varUnique.lVal;

    TBL_OFF obRow;
    ULONG     iRowOrdinal;
    BOOL      fExisting = _FindWorkId(wid, obRow, iRowOrdinal);

    if (fExisting)
    {
        BOOL fFirstRow = (0 == iRowOrdinal);
        BOOL fLastRow  = (RowCount() - 1 == iRowOrdinal);

        CRowIndex & srchRowIndex = _GetInvisibleRowIndex();

        BYTE * pRow = (BYTE *) _DataAllocator.FixedPointer(obRow);

        if ( IsCategorized() )
        {
            chapt = _RowChapter( pRow );

            if ( iRowOrdinal < ( srchRowIndex.RowCount() - 1 ) )
                widNext = RowWorkid( _DataAllocator.FixedPointer(
                                     srchRowIndex.GetRow(iRowOrdinal + 1)));
            else
                widNext = widInvalid;
        }

        const ULONG rowStatus = _RowStatus(pRow);

        if ( TBL_DATA_ROWADDED == rowStatus || !IsWatched() )
        {
            //
            // This row has only been added but not notified to the
            // user. So, we can go ahead and do a hard delete.
            //
            BOOL fFound = FALSE;
            if ( IsWatched() )
            {
                fFound = _xDeltaBookMarkMap->DeleteBookMark( wid );
            }
            else
            {
                Win4Assert( _xDeltaBookMarkMap.IsNull() ||
                            !_xDeltaBookMarkMap->IsBookMarkPresent(wid) );
                Win4Assert( 0 == _dynRowIndex.RowCount() );
                fFound = _BookMarkMap.DeleteBookMark( wid );
            }

            Win4Assert( fFound && "BookMark to be deleted not found" );

            Win4Assert( obRow == srchRowIndex.GetRow(iRowOrdinal) );
            srchRowIndex.DeleteRow(iRowOrdinal);

            _cRowsHardDeleted++;
            _SetRowStatus(pRow,TBL_DATA_HARD_DELETE);

            tbDebugOut(( DEB_WATCH,
                "Hard Deleting Workid 0x%X oTable %#p oIndex 0x%X\n",
                wid, obRow, iRowOrdinal ));

            // Update low and high keys

            if ( fFirstRow && fLastRow )
            {
                // this means now RowCount == 0
                // we should probably delete this segment
            }
            else if ( fFirstRow )
            {
                // the first row got deleted, therefore update lowKey
                GetSortKey( 0, _lowKey );
            }
            else if ( fLastRow )
            {
                // the last row got deleted, therefore update highKey
                GetSortKey( (ULONG) ( RowCount() - 1 ), _highKey );
            }
        }
        else
        {
            //
            // The existence of this row is known to the user. It is left in
            // a pending delete state until a refresh is done.
            // Updation of _highKey and _lowKey is also done at that time
            Win4Assert( _BookMarkMap.IsBookMarkPresent(wid) );
            Win4Assert( _xDeltaBookMarkMap.IsNull() ||
                        !_xDeltaBookMarkMap->IsBookMarkPresent(wid) );

            _cPendingDeletes++;
            _SetRowStatus(pRow,TBL_DATA_PENDING_DELETE);

            tbDebugOut(( DEB_WATCH,
                "Soft Deleting Workid 0x%X oTable %#p oIndex 0x%X\n",
                wid, obRow, iRowOrdinal ));
        }
    }

    return fExisting;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::IsPendingDelete
//
//  Synopsis:
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  Modifies:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableWindow::IsPendingDelete( WORKID wid )
{
    TBL_OFF iRowOffset;

    BOOL fFound = _BookMarkMap.FindBookMark( wid, iRowOffset );
    if ( fFound )
    {
        BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(iRowOffset);
        return TBL_DATA_PENDING_DELETE == _RowStatus(pbRow) ;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::CompareRange, public
//
//  Synopsis:   Checks to see how a given potential row object would fit
//              in this window based on the current sort criteria.
//
//  Arguments:  [obj] -- accessor to the potential row object
//
//  Returns:    -1 if < min item
//               0 if (<= max and >= min) or no items in window
//               1 if > max item
//
//  History:    2 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

void
CTableWindow::CompareRange( CRetriever &obj, CCompareResult & rslt )
{

    //
    // If there is a comparator and any rows for comparison
    //

    CRowIndex & srchRowIndex = _GetInvisibleRowIndex();

    if ((0 != _RowCompare.GetPointer()) &&
        (0 != srchRowIndex.RowCount()))
    {

        int iComp = _RowCompare->CompareObject(obj,srchRowIndex.GetRow(0));

        if (iComp > 0)
        {
            //
            // Compare to the maximum row
            // If > min and < max, it belongs in the range
            //

            iComp = _RowCompare->CompareObject(obj,
                                   srchRowIndex.GetRow(srchRowIndex.RowCount()-1));

            if (iComp < 0)
                iComp = 0;
        }

        rslt.Set( iComp );
    }
    else
    {
        rslt.Set( CCompareResult::eUnknown );
    }

} //CompareRange

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::_InitSortComparators, private
//
//  Synopsis:   Establishes the sort order used by the table.
//
//  History:    19 Jan 1995     dlee   Created from old SetSortOrderCode
//
//--------------------------------------------------------------------------

void CTableWindow::_InitSortComparators()
{
    Win4Assert( 0 == _RowCompare.GetPointer() &&
                0 == _QuickRowCompare.GetPointer() );

    Win4Assert( 0 != _pSortSet->Count() );

    // Special-case quick comparators for one or two comparisons
    // of basic types.

    if (_pSortSet->Count() == 1)
    {
        SSortKey Key = _pSortSet->Get(0);
        BOOL fFound = FALSE;

        CTableColumn* pColumn = _Columns.Find(Key.pidColumn,fFound);

        Win4Assert(fFound);

        //
        // If inline, not compressed, and not a vector, it is a
        // candidate for a faster comparison.
        //
        // pidWorkid can be compressed and stored in the row for
        // the downlevel case.

        if ((pColumn->PropId == pidWorkId ||
             ! pColumn->IsCompressedCol()) &&
            (0 == (pColumn->GetStoredType() & VT_VECTOR)))
        {
            if (pColumn->GetStoredType() == VT_I8 ||
                pColumn->GetStoredType() == VT_FILETIME)
                _QuickRowCompare.Set( new TRowCompare<LONGLONG>
                                           (_DataAllocator,
                                           pColumn->GetValueOffset(),
                                           Key.dwOrder ));
            else if (pColumn->GetStoredType() == VT_I4)
                _QuickRowCompare.Set( new TRowCompare<LONG>
                                           (_DataAllocator,
                                            pColumn->GetValueOffset(),
                                            Key.dwOrder ));
        }
    }
    else if (_pSortSet->Count() == 2)
    {
        SSortKey Key1 = _pSortSet->Get(0);
        SSortKey Key2 = _pSortSet->Get(1);
        BOOL fFound = FALSE;

        CTableColumn* pColumn1 = _Columns.Find(Key1.pidColumn,fFound);
        Win4Assert(fFound);

        CTableColumn* pColumn2 = _Columns.Find(Key2.pidColumn,fFound);
        Win4Assert(fFound);

        //
        // If inline, not compressed, and not a vector, it is a
        // candidate for a faster comparison.
        //
        // pidWorkid can be compressed and stored in the row for
        // the downlevel case.

        if ((! pColumn1->IsCompressedCol()) &&
            (0 == (pColumn1->GetStoredType() & VT_VECTOR)) &&
            (! pColumn2->IsCompressedCol()
             || pColumn2->PropId == pidWorkId
             ) &&
            (0 == (pColumn2->GetStoredType() & VT_VECTOR)))
        {
            if (((pColumn1->GetStoredType() == VT_I8) ||
                 (pColumn1->GetStoredType() == VT_FILETIME)) &&
                (pColumn2->GetStoredType() == VT_I4))
                _QuickRowCompare.Set( new TRowCompareTwo<LONGLONG,LONG>
                                           (_DataAllocator,
                                            pColumn1->GetValueOffset(),
                                            Key1.dwOrder,
                                            pColumn2->GetValueOffset(),
                                            Key2.dwOrder ));
            else if ((pColumn1->GetStoredType() == VT_I4) &&
                     (pColumn2->GetStoredType() == VT_I4))
                _QuickRowCompare.Set( new TRowCompareTwo<LONG,LONG>
                                           (_DataAllocator,
                                            pColumn1->GetValueOffset(),
                                            Key1.dwOrder,
                                            pColumn2->GetValueOffset(),
                                            Key2.dwOrder ));
            else if ((pColumn1->GetStoredType() == VT_UI4) &&
                     (pColumn2->GetStoredType() == VT_I4))
                _QuickRowCompare.Set( new TRowCompareTwo<ULONG,LONG>
                                           (_DataAllocator,
                                            pColumn1->GetValueOffset(),
                                            Key1.dwOrder,
                                            pColumn2->GetValueOffset(),
                                            Key2.dwOrder ));
            else if ((pColumn1->GetStoredType() == VT_LPWSTR) &&
                     (pColumn2->GetStoredType() == VT_I4))
                _QuickRowCompare.Set( new TRowCompareStringPlus<LONG>
                                           (_DataAllocator,
                                            pColumn1->GetValueOffset(),
                                            Key1.dwOrder,
                                            pColumn2->GetValueOffset(),
                                            Key2.dwOrder ));
        }
    }

    //
    // Make the default comparator
    //

    _RowCompare.Set( new CRowCompareVariant(*this) );

    //
    // Use a faster comparator if available, or just use the default
    //

    _dynRowIndex.SetComparator((0 != _QuickRowCompare.GetPointer()) ?
         _QuickRowCompare.GetPointer() : _RowCompare.GetPointer());

    _visibleRowIndex.SetComparator((0 != _QuickRowCompare.GetPointer()) ?
         _QuickRowCompare.GetPointer() : _RowCompare.GetPointer());

} //_InitSortComparators

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::SortOrder, private
//
//  Synopsis:   Only here because of class hierarchy artifact.
//
//  Returns:    CSortSet & -- sort set from parent object.
//
//  History:    24 Oct 1994     dlee   Created
//
//--------------------------------------------------------------------------

CSortSet const & CTableWindow::SortOrder()
{
    return * _pSortSet;
} //SortOrder

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_ReconcileRowIndexes
//
//  Synopsis:   Reconciles the source and destination row indexes. At the end
//              of it both the source and destination will be identical. Also,
//              all the deleted rows would have been removed from the row
//              indexes.
//
//  Arguments:  [src] -
//              [dst] -
//
//  History:    7-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_ReconcileRowIndexes( CRowIndex & dst , CRowIndex & src )
{
    ULONG cRowsInSrc = src.RowCount();

    dst.ResizeAndInit( cRowsInSrc );
    for ( unsigned i = 0; i < cRowsInSrc ; i++ )
    {
        TBL_OFF oRow = src.GetRow(i);
        BYTE * pbRow = _GetRow( oRow );
        const ULONG  rowStatus = _RowStatus( pbRow );

        //
        // By the time reconcile is called, all pending deletes must be
        // converted to hard deletes.
        //
        Win4Assert( TBL_DATA_PENDING_DELETE != rowStatus );

        if ( TBL_DATA_OKAY == rowStatus )
        {
            dst.AppendRow( oRow );
        }
        else
        {
            tbDebugOut(( DEB_BOOKMARK,
                "Not Copying Row 0x%X because of status 0x%X\n",
                oRow, rowStatus ));
        }
    }

    src.SyncUp( dst );

    // Update Low and High Keys
    if ( dst.RowCount() )
    {
        GetSortKey( 0, _lowKey );
        GetSortKey( dst.RowCount() - 1, _highKey );
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_CleanupAndReconcileRowIndexes
//
//  Synopsis:
//
//  Arguments:  [fCreatingWatch] -
//              [pScript]        -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-27-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_CleanupAndReconcileRowIndexes( BOOL fCreatingWatch )
{


    Win4Assert( !_fSplitInProgress );

    //
    // First see how many rows have notification information
    //

    ULONG cAllocatedRows = _AllocatedRowCount();

    BYTE *pbRow = (BYTE *) _DataAllocator.FirstRow();

    ULONG cAdd = 0, cDelete = 0;

    for (unsigned i = 0; i < cAllocatedRows; i++, pbRow += _cbRowSize)
    {
        switch (_RowStatus(pbRow))
        {
            case TBL_DATA_ROWADDED :
                cAdd++;
                break;
            case TBL_DATA_PENDING_DELETE :
                cDelete++;
                break;
        }
    }

    //
    // Record the notification info
    //

    ULONG cChanges = cAdd + cDelete;
    ULONG iChange = 0;

    for (i = 0, pbRow = (BYTE *) _DataAllocator.FirstRow();
         iChange < cChanges && i < cAllocatedRows;
         i++, pbRow += _cbRowSize)
    {

        ULONG currStatus = _RowStatus(pbRow);
        switch (currStatus)
        {
            case TBL_DATA_ROWADDED :

                //
                // Update the book mark mapping to reflect the new row if
                // notifications were enabled before this.
                //
                if ( !fCreatingWatch )
                {
                    _BookMarkMap.AddReplaceBookMark( RowWorkid(pbRow),
                                      _DataAllocator.FixedOffset(pbRow) );
                }


                _SetRowStatus(pbRow, TBL_DATA_OKAY);
                tbDebugOut(( DEB_WATCH,
                             "Notify:Add Wid 0x%X TblRow0x%X\n",
                             RowWorkid(pbRow), _DataAllocator.FixedOffset(pbRow) ));
                iChange++;
                break;

            case TBL_DATA_PENDING_DELETE :

                Win4Assert( !fCreatingWatch );

                //
                // Mark the row so that it is considered a hard delete and
                // also remove it from the bookmark mapping.
                //
                _SetRowStatus(pbRow,TBL_DATA_HARD_DELETE);
                _BookMarkMap.DeleteBookMark( RowWorkid(pbRow) );

                _cPendingDeletes--;
                _cRowsHardDeleted++;

                tbDebugOut(( DEB_WATCH,
                             "Notify:Delete Wid 0x%X TblRow0x%X\n",
                             RowWorkid(pbRow), _DataAllocator.FixedOffset(pbRow) ));

                iChange++;
                break;
        }


#if DBG==1
        //
        // This is a very expensive test. Turn it off once code stabilizes.
        //
        {
            //
            // If any row in the tablewindow has a stats of TBL_DATA_OKAY, it
            // must have an entry in the bookmark map now.
            //
            TBL_OFF oTableRow;
            ULONG status = _RowStatus(pbRow);

            if ( TBL_DATA_OKAY == status )
            {
                BOOL fFound = _BookMarkMap.FindBookMark( RowWorkid(pbRow),
                                                         oTableRow );
                if ( !fFound )
                {
                    _BookMarkMap.FindBookMark( RowWorkid(pbRow),
                                               oTableRow );
                    Win4Assert( !"Not Found in BookMarkMap" );
                }
                TBL_OFF tbRow = _DataAllocator.FixedOffset(pbRow);
                if ( tbRow != oTableRow )
                {
                    Win4Assert( !"Wrong Data in BookMarkMap" );
                }
            }
        }
#endif  // DBG
    }

    //
    // We should have processed all the changes.
    //
    Win4Assert( iChange == cChanges );
    Win4Assert( 0 == _cPendingDeletes );

    //
    // Synchronize the static and dynamic row indexes.
    //
    if ( fCreatingWatch )
    {
        //
        // Watch is being created for the first time. Selectively copy
        // only the non-soft deleted rows from the visible row index to
        // the dynamic row index.
        //
        _ReconcileRowIndexes( _dynRowIndex , _visibleRowIndex );
    }
    else
    {
        //
        // Reconcile the dynamic row index to the visible row index and
        // then get rid of the soft deletion entries from the dynamic
        // row index.
        //
        _ReconcileRowIndexes( _visibleRowIndex , _dynRowIndex );
    }

    _xDeltaBookMarkMap->DeleteAllEntries();


#if DBG==1
//
// This is a very expensive test. Take it out once code stabilizes.
//
for ( unsigned j = 0; j < _visibleRowIndex.RowCount(); j++ )
    {
        TBL_OFF oTableRow = _visibleRowIndex.GetRow(j);
        BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(oTableRow);
        WORKID wid = RowWorkid(pbRow);
        TBL_OFF bmTableRow;
        ULONG     bmIndex;
        BOOL fFound =  _BookMarkMap.FindBookMark( wid, bmTableRow, bmIndex );
        if ( !fFound )
        {
            _BookMarkMap.FindBookMark( RowWorkid(pbRow), bmTableRow, bmIndex );
            tbDebugOut(( DEB_ERROR,
                         "Workid 0x%X Not Found In BookMarkMap\n", wid ));
            Win4Assert( !"Verification:Not Found in BookMarkMap" );
        }

        if ( bmTableRow != oTableRow || bmIndex != j )
        {
            tbDebugOut(( DEB_ERROR,
                         "Mismatch in BookMarkMap oRow=%p:iRowIndex=%x ",
                         bmTableRow, bmIndex ));
            tbDebugOut(( DEB_ERROR|DEB_NOCOMPNAME,
                         "and RowIndex oRow=%p:iRowIndex=%x\n",
                         oTableRow, j ));

            Win4Assert( !"Verification:Wrong Data in BookMarkMap" );
        }
    }
#endif  // DBG==1

}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_StartStaticDynamicSplit
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    7-27-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_StartStaticDynamicSplit()
{
    _CleanupAndReconcileRowIndexes(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_EndStaticDynamicSplit
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    7-27-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_EndStaticDynamicSplit()
{
    _CleanupAndReconcileRowIndexes(FALSE);
    _dynRowIndex.ClearAll();
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindow::_Refresh
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    7-27-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_Refresh()
{
    _CleanupAndReconcileRowIndexes(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTableWindow::_CopyRow
//
//  Synopsis:   Given a source window and a row offset in the source window,
//              this method makes a copy of the source row and adds it to the
//              current window.
//
//  Arguments:  [srcWindow]    - Reference to the source window.
//              [oSrcTableRow] - Offset in the source window.
//
//  Returns:    The offset of the row added in this window.
//
//  History:    2-07-95   srikants   Created
//
//  Notes:      There are four kinds of variant data in the rows:
//
//              1. In place data (eg. I1, I2, I4, I8, etc )
//              2. Pointer to global compression data.
//              3. Pointer to window specific compression data.
//              4. Pointer to window specific non-compressed data.
//
//              Data fields of types 1 and 2 can be copied directly from the
//              source row but types 3 and 4 have to be extracted from the
//              source row and then copied.
//
//              An underlying assumption is that rows in the source and
//              target windows have the same layout.
//
//----------------------------------------------------------------------------

TBL_OFF CTableWindow::_CopyRow( CTableWindow & srcWindow, TBL_OFF oSrcTableRow )
{

    BYTE * pSrcRow = srcWindow._GetRow( oSrcTableRow );
    WORKID wid = srcWindow.RowWorkid( pSrcRow );

    BYTE * pThisRow = _RowAlloc();

    Win4Assert( _cbRowSize == srcWindow._cbRowSize &&
                _Columns.Count() == srcWindow._Columns.Count());

    //
    // First copy the entire row and then fix up the variable length
    // variant parts.
    //
    RtlCopyMemory( pThisRow, pSrcRow, _cbRowSize );
    TBL_OFF oTableRow = _DataAllocator.FixedOffset(pThisRow);

    //
    // For each column, determine its type. If it is an in-place value or a
    // globally compressed value, just ignore it as we have already copied the
    // data. O/W, extract the variant and copy its contents.
    //
    for ( unsigned i=0; i < _Columns.Count(); i++)
    {
        CTableColumn * pDstColumn    = _Columns.Get(i);
        CTableColumn * pSrcColumn    = srcWindow._Columns.Get(i);
        Win4Assert( 0 != pDstColumn && 0 != pSrcColumn );

        if ( pSrcColumn->IsPartialDeferred() )
        {
            // No Data to copy here
            continue;
        }

        Win4Assert(
            pDstColumn->GetStoredType()   == pSrcColumn->GetStoredType()   &&
            pDstColumn->GetValueOffset()  == pSrcColumn->GetValueOffset()  &&
            pDstColumn->GetStatusOffset() == pSrcColumn->GetStatusOffset() &&
            pDstColumn->GetLengthOffset() == pSrcColumn->GetLengthOffset()
        );

        VARTYPE vtSrc = pSrcColumn->GetStoredType();
        Win4Assert( pDstColumn->GetStoredType() == vtSrc );

        USHORT cbData, cbAlignment, rgfFlags;
        CTableVariant::VartypeInfo(vtSrc, cbData, cbAlignment, rgfFlags);

        if ( CTableVariant::TableIsStoredInline( rgfFlags, vtSrc ) ||
             pSrcColumn->IsGlobalCompressedCol() ||
             ! pSrcColumn->IsValueStored())
        {
            //
            // This data is either stored in-line or is a globally compressed
            // data. We can skip and go the next field.
            //
            continue;
        }

        DBSTATUS CopyStatus = pSrcColumn->CopyColumnData(
                                                pThisRow,
                                                *pDstColumn,
                                                _DataAllocator,
                                                pSrcRow,
                                                srcWindow._DataAllocator);

        Win4Assert(DBSTATUS_S_OK ==  CopyStatus ||
                   DBSTATUS_S_ISNULL ==  CopyStatus);

    }   // for loop

    return oTableRow;
}

//+---------------------------------------------------------------------------
//
//  Function:   _PutRowToVisibleRowIndex
//
//  Synopsis:   Copies the given row to the table and adds an entry to the
//              visible row index.
//
//  Arguments:  [srcWindow] -  Reference to the source window.
//              [oSrcRow]   -  Row Offset in the source window to be copied.
//
//  History:    1-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_PutRowToVisibleRowIndex( CTableWindow & srcWindow,
                                             TBL_OFF oSrcRow )
{

    BYTE * pbRow = srcWindow._GetRow( oSrcRow );

    //
    // Add the rowdata and make an entry in the visible row index
    // for this.
    //
    WORKID wid = RowWorkid( pbRow );
    Win4Assert( !_BookMarkMap.IsBookMarkPresent(wid) );

    TBL_OFF oTableRow = _CopyRow( srcWindow, oSrcRow );

    _visibleRowIndex.AddRow(oTableRow);
    _BookMarkMap.AddBookMark( wid, oTableRow );

    const ULONG status = _RowStatus(pbRow);

    Win4Assert( TBL_DATA_HARD_DELETE != status );

    Win4Assert( TBL_DATA_OKAY == status ||
                TBL_DATA_PENDING_DELETE == status ||
                TBL_DATA_ROWADDED == status  );

    if ( TBL_DATA_PENDING_DELETE == status )
    {
        _cPendingDeletes++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _PutRowToDynRowIndex
//
//  Synopsis:   Adds the given row to the dynamic row index. In addition, if
//              the row is a "new" row and is not present in the table
//              already, it will be added to the table also.
//
//  Arguments:  [srcWindow] -  Source window
//              [oSrcRow]   -  Offset of the row in the source window.
//
//  History:    1-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::_PutRowToDynRowIndex( CTableWindow & srcWindow,
                                         TBL_OFF oSrcRow )
{
    BYTE * pbRow = srcWindow._GetRow( oSrcRow );
    WORKID wid = srcWindow.RowWorkid( pbRow );

    TBL_OFF  oTableRow;

    const ULONG rowStatus = srcWindow._RowStatus(pbRow);

    Win4Assert( TBL_DATA_HARD_DELETE != rowStatus );

    if ( TBL_DATA_OKAY == rowStatus || TBL_DATA_PENDING_DELETE == rowStatus )
    {
        //
        // Since the row status is OKAY or pending delete, it MUST have
        // already been added via the _visibleRowIndex.
        //
        BOOL fFound = _BookMarkMap.FindBookMark( wid, oTableRow );
        Win4Assert( fFound );
    }
    else
    {
        //
        // This row has not been added already via the visible row
        // index. We should add it to the table.
        //
        Win4Assert( TBL_DATA_ROWADDED == rowStatus );
        oTableRow = _CopyRow( srcWindow, oSrcRow );
        Win4Assert( _xDeltaBookMarkMap.IsNull() ||
                    !_xDeltaBookMarkMap->IsBookMarkPresent(wid) );
        _xDeltaBookMarkMap->AddBookMark( wid, oTableRow );
    }

    _dynRowIndex.AddRow( oTableRow );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEmptyForQuery
//
//  Synopsis:   Checks if the window is empty from query's perspective.
//
//  Returns:    TRUE if there are no entries in the "invisible" row index.
//              FALSE o/w
//
//  History:    2-07-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableWindow::IsEmptyForQuery()
{
    return _GetInvisibleRowIndex().RowCount() == 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsGettingFull
//
//  Synopsis:   Checks if the current window is getting full.
//
//  Returns:    TRUE if it is getting full.
//              FALSE o/w
//
//  History:    2-07-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableWindow::IsGettingFull()
{
    //
    // PERFFIX - need a better heuristic based on memory usage.
    //
    return _GetInvisibleRowIndex().RowCount() >= CTableSink::cWindowRowLimit;
}

unsigned CTableWindow::PercentFull()
{
    return (_GetInvisibleRowIndex().RowCount() * 100) / CTableSink::cWindowRowLimit;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSortKey
//
//  Synopsis:   Fills the requested window row as a "bktRow" by extracting
//              only the "sort columns".
//
//  Arguments:  [iRow]      -  Index of the requested window row.
//              [pvtOut]    -  Variants of the sort set.
//              [bktRow]    -  (Output) will have the row in a "bucket row"
//              form.
//
//  History:    2-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableWindow::GetSortKey( ULONG iRow, CTableRowKey & sortKey )
{
    Win4Assert( 0 != _RowCompare.GetPointer() &&
                iRow < _GetInvisibleRowIndex().RowCount() );

    TBL_OFF oTableRow = _GetInvisibleRowIndex().GetRow(iRow);

    Win4Assert( 0 != _pSortSet );

    BYTE * pRow = _GetRow( oTableRow );

    for ( unsigned i = 0; i < _pSortSet->Count(); i++ )
    {
        const SSortKey & key = _pSortSet->Get(i);
        PROPID pidColumn = key.pidColumn;

        BOOL fFoundCol = FALSE;
        CTableColumn * pColumn = _Columns.Find(pidColumn, fFoundCol);
        Win4Assert(fFoundCol == TRUE);

        //
        // Create a variant out of the data in the column and copy its contents
        // to the output row.
        //
        CTableVariant varnt;
        CTableVariant* pvarnt;
        XCompressFreeVariant xpvarnt;

        pvarnt = &varnt;
        if ( pColumn->CreateVariant( *pvarnt, pRow, _DataAllocator ) )
        {
            //
            // Variant needs to be freed by the column compressor.
            //
            xpvarnt.Set(pColumn->GetCompressor(), pvarnt);
        }

        //
        // Initialize the column in the bucket row with the data in the
        // variant just extracted.
        //
        sortKey.Init( i, *pvarnt );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::FindRegion, private
//
//  Synopsis:   Delete watch region
//
//  Returns:    The number of rows deleted from watch
//
//  History:    22-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

unsigned CTableWindow::FindRegion (HWATCHREGION hRegion) const
{
    for (unsigned i = 0; i < _aWindowWatch.Count(); i++)
    {
        if (_aWindowWatch.Get(i)._hRegion == hRegion)
            break;
    }
    return i;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::AddWatch
//
//  Synopsis:   Add watch region starting at offset
//
//  Returns:    The number of rows added to the watch
//
//  History:    26-Jul-95   BartoszM    Created
//
//  Notes:      If this is the last segment, add all cRows
//              otherwise don't overshoot the end of window
//--------------------------------------------------------------------------

long CTableWindow::AddWatch (   HWATCHREGION hRegion,
                                long iStart,
                                LONG cRows,
                                BOOL isLast)
{
    Win4Assert( cRows > 0 );

    long cRowsHere = cRows;
    if (!isLast && cRows > (long)_visibleRowIndex.RowCount() - iStart)
    {
        cRowsHere = (long)_visibleRowIndex.RowCount() - iStart;
    }


    Win4Assert( cRowsHere >= 0 );

    CWindowWatch watch;
    watch._hRegion = hRegion;
    watch._iRowStart = iStart;
    watch._cRowsHere = cRowsHere;
    watch._cRowsLeft = cRows;
    _AddWatchItem (watch);
    return cRowsHere;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::DeleteWatch
//
//  Synopsis:   Delete watch region
//
//  Returns:    The number of rows deleted from watch
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------


long CTableWindow::DeleteWatch (HWATCHREGION hRegion)
{
    unsigned i = FindRegion(hRegion);
    Win4Assert (i < _aWindowWatch.Count());
    long count = _aWindowWatch.Get(i)._cRowsHere;
    _RemoveWatchItem (i);
    return count;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::ModifyWatch
//
//  Synopsis:   Modify watch region
//
//  Returns:    The number of rows in the modified watch
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------


long CTableWindow::ModifyWatch (HWATCHREGION hRegion, long iStart, long cRows, BOOL isLast)
{
    Win4Assert( cRows > 0 );
    Win4Assert( 0 == iStart || iStart < (long) _visibleRowIndex.RowCount() );

    unsigned i = FindRegion(hRegion);
    Win4Assert (i < _aWindowWatch.Count());
    CWindowWatch& watch =  _aWindowWatch.Get(i);
    long cRowsHere = cRows;
    if ( !isLast && cRows > (long)_visibleRowIndex.RowCount() - iStart )
    {
        cRowsHere = (long)_visibleRowIndex.RowCount() - iStart;
    }

    Win4Assert( cRowsHere >= 0 );

    watch._iRowStart = iStart;
    watch._cRowsHere = cRowsHere;
    watch._cRowsLeft = cRows;
    return cRowsHere;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::ShrinkWatch
//
//  Synopsis:   Shrink watch region so that it starts with the
//              bookmark and extends no farther than cRows
//
//  Returns:    The number of rows left in the region
//
//  History:    21-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------


long CTableWindow::ShrinkWatch (HWATCHREGION hRegion,
                                CI_TBL_BMK  bookmark,
                                LONG cRows)
{
    Win4Assert( cRows > 0 );

    // find the bookmark
    TBL_OFF off;
    ULONG     uiStart;
    if ( !FindBookMark( bookmark, off, uiStart))
    {
        Win4Assert (!"CTableWindow::ShrinkWatch, bookmark not found" );
    }

    long iStart = (long)uiStart;

    unsigned i = FindRegion(hRegion);
    Win4Assert (i < _aWindowWatch.Count());

    CWindowWatch& watch = _aWindowWatch.Get(i);
    // Assert that bookmark is within the watch region
    Win4Assert (watch._iRowStart <= iStart);
    Win4Assert (watch._iRowStart + watch._cRowsHere > iStart);

    long cRowsLeftHere = watch._cRowsHere - (iStart - watch._iRowStart);
    long cRowsLeft     = watch._cRowsLeft - (iStart - watch._iRowStart);

    Win4Assert( cRowsLeftHere > 0 );
    Win4Assert( cRowsLeft > 0 );

    watch._iRowStart = iStart;
    watch._cRowsHere = min (cRowsLeftHere, cRows);
    watch._cRowsLeft = min (cRowsLeft, cRows);
    return watch._cRowsHere;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::ShrinkWatch
//
//  Synopsis:   Shrink watch region so that it extends no farther than cRows
//              The assumption is that the beginning of the region
//              is at the beginning of the window.
//
//  Returns:    The number of rows left in the region
//
//  History:    21-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------


long CTableWindow::ShrinkWatch (HWATCHREGION hRegion, LONG cRows)
{
    unsigned i = FindRegion(hRegion);
    Win4Assert (i < _aWindowWatch.Count());
    Win4Assert (_aWindowWatch.Get(i)._iRowStart == 0);
    CWindowWatch& watch = _aWindowWatch.Get(i);

    Win4Assert( cRows > 0 );
    Win4Assert( watch._cRowsHere >= 0 );
    Win4Assert( watch._cRowsLeft > 0 );

    watch._cRowsHere = min (watch._cRowsHere, cRows);
    watch._cRowsLeft = min (watch._cRowsLeft, cRows);
    return watch._cRowsHere;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::IsWatched
//
//  Synopsis:   Returns TRUE if the window has the watch region hRegion
//              and the bookmark is within this region
//
//  History:    21-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CTableWindow::IsWatched (HWATCHREGION hRegion, CI_TBL_BMK bookmark)
{
    unsigned i = FindRegion(hRegion);

    if (i == _aWindowWatch.Count())
        return FALSE;
    // find the bookmark
    TBL_OFF off;
    ULONG     iBmk;
    if ( !FindBookMark( bookmark, off, iBmk))
    {
        return FALSE;
    }
    long iWatchStart =  _aWindowWatch.Get(i)._iRowStart;
    long iWatchEnd   =  iWatchStart + _aWindowWatch.Get(i)._cRowsHere;
    return iWatchStart <= (long)iBmk && (long)iBmk < iWatchEnd;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::HasWatch
//
//  Synopsis:   Returns TRUE if the window has the watch region hRegion
//
//  History:    21-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CTableWindow::HasWatch (HWATCHREGION hRegion)
{
    unsigned i = FindRegion(hRegion);
    return i < _aWindowWatch.Count();
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::RowsWatched
//
//  Synopsis:   Returns the number of rows in the watch region hRegion
//
//  History:    22-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

long CTableWindow::RowsWatched (HWATCHREGION hRegion)
{
    unsigned i = FindRegion(hRegion);
    if ( i < _aWindowWatch.Count() )
        return _aWindowWatch.Get(i)._cRowsHere;

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::_AddWatchItem
//
//  Synopsis:   Adds a new watch item to list and
//              changes the state of the window if necessary
//
//  History:    26-Jul-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CTableWindow::_AddWatchItem (CWindowWatch& watch)
{
    _aWindowWatch.Add (watch, _aWindowWatch.Count());
    if ( _aWindowWatch.Count() == 1 && !_fSplitInProgress )
    {
        _StartStaticDynamicSplit();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::_RemoveWatcheItem
//
//  Synopsis:   Removes a watch item from the list and
//              changes the state of the window if necessary
//
//  History:    26-Jul-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CTableWindow::_RemoveWatchItem (unsigned i)
{
    _aWindowWatch.Remove(i);
    if (_aWindowWatch.Count() == 0)
    {
        _EndStaticDynamicSplit();
    }
}

BOOL CTableWindow::FindNearestDynamicBmk( CI_TBL_CHAPT chapter,
                                          CI_TBL_BMK & bookMark )
{
    // If the row corresponding to the bookmark exists in the
    // dynamic state, return the original bookmark.
    // If the row has been deleted from the dynamic state
    // return the bookmark of the next available dynamic row.
    // If you hit the end of the table, return the bookmark
    // of the last row in the dynamic state of the table

    //
    // NEWFEATURE - does not understand categorization .
    //
    Win4Assert( IsWatched() );

    if ( WORKID_TBLFIRST == bookMark || WORKID_TBLLAST == bookMark )
    {
        return TRUE;
    }

    TBL_OFF iRowOffset;

    if ( _xDeltaBookMarkMap->FindBookMark(bookMark, iRowOffset) )
    {
        //
        // The row is present in the delta bookmark map. Just return
        // it.
        //
        return TRUE;
    }

    //
    // Locate the closest row in the dynamic bookmark mapping
    // for the row.
    //
    BOOL fFound = _BookMarkMap.FindBookMark(bookMark, iRowOffset);
    Win4Assert( fFound );

    //
    // Locate the row offset in the dynamic row index and find the
    // closest row which is not in a pending delete state.
    //
    ULONG iRowOrdinal;
    fFound = _dynRowIndex.FindRow(iRowOffset,iRowOrdinal);
    Win4Assert( fFound );

    for ( ULONG i = iRowOrdinal; i < _dynRowIndex.RowCount(); i++ )
    {
        BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(
                                                _dynRowIndex.GetRow(i) );

        ULONG status = _RowStatus(pbRow);
        if ( TBL_DATA_PENDING_DELETE != status )
        {
            Win4Assert( TBL_DATA_HARD_DELETE != status );
            bookMark = RowWorkid(pbRow);
            return TRUE;
        }
    }

    //
    // Try to the left of the bookmark.
    //
    for ( long j = (long) iRowOrdinal-1; j >=0; j-- )
    {
        BYTE * pbRow = (BYTE *) _DataAllocator.FixedPointer(
                                    _dynRowIndex.GetRow( (ULONG) j) );

        ULONG status = _RowStatus(pbRow);
        if ( TBL_DATA_PENDING_DELETE != status )
        {
            Win4Assert( TBL_DATA_HARD_DELETE != status );
            bookMark = RowWorkid(pbRow);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CTableWindow::FindFirstNonDeleteDynamicBmk( CI_TBL_BMK & bmk )
{

    CRowIndex & rowIndex = _GetInvisibleRowIndex();

    for ( unsigned i = 0; i < rowIndex.RowCount(); i++ )
    {
        BYTE * pbRow = (BYTE *)
            _DataAllocator.FixedPointer( rowIndex.GetRow(i) );
        if ( TBL_DATA_PENDING_DELETE != _RowStatus(pbRow) )
        {
            Win4Assert( TBL_DATA_HARD_DELETE != _RowStatus(pbRow) );
            bmk = RowWorkid(pbRow);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CTableWindow::FindLastNonDeleteDynamicBmk( CI_TBL_BMK & bmk )
{

    CRowIndex & rowIndex = _GetInvisibleRowIndex();

    for ( long i = (long) rowIndex.RowCount()-1; i >= 0; i-- )
    {
        BYTE * pbRow = (BYTE *)
            _DataAllocator.FixedPointer( rowIndex.GetRow( (ULONG) i) );
        if ( TBL_DATA_PENDING_DELETE != _RowStatus(pbRow) )
        {
            Win4Assert( TBL_DATA_HARD_DELETE != _RowStatus(pbRow) );
            bmk = RowWorkid(pbRow);
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::LokGetOneColumn
//
//  Synopsis:   Fills a buffer with a particular column from a row
//
//  Arguments:  [wid]        -- workid of the row to be queried
//              [rOutColumn] -- layout of the output data
//              [pbOut]      -- where to write the column data
//              [rVarAlloc]  -- variable data allocator to use
//
//  History:    22-Aug-95   dlee   Created
//
//--------------------------------------------------------------------------

void CTableWindow::LokGetOneColumn(
    WORKID                    wid,
    CTableColumn const &      rOutColumn,
    BYTE *                    pbOut,
    PVarAllocator &           rVarAllocator )
{
    TBL_OFF oRow;
    ULONG     iRow;
    BOOL fFound = FindBookMark( wid, oRow, iRow );

    Win4Assert( fFound && "LokGetOneColumn could not find bmk" );

    BYTE *pbRow = (BYTE *) _DataAllocator.FixedPointer( oRow );

    CTableColumn * pColumn = _Columns.Find( rOutColumn.PropId );

    pColumn->CopyColumnData( pbOut,
                             rOutColumn,
                             rVarAllocator,
                             pbRow,
                             _DataAllocator );
} //LokGetOneColumn

//+-------------------------------------------------------------------------
//
//  Member:     CTableWindow::IsFirstRowFirstOfCategory
//
//  Synopsis:   Returns TRUE if the first row in the window is also the
//              first of a category.  Needed for window selection in PutRow
//
//  History:    6-Nov-95   dlee   Created
//
//--------------------------------------------------------------------------

BOOL CTableWindow::IsFirstRowFirstOfCategory()
{
    CRowIndex & ri = _GetInvisibleRowIndex();

    if ( 0 != ri.RowCount() )
    {
        BYTE *pbRow = _GetRowFromIndex( 0, ri );
        ULONG chapt = _RowChapter( pbRow );
        WORKID wid = RowWorkid( pbRow );

        CCategorize & Cat = * GetCategorizer();

        return ( Cat.GetFirstWorkid( chapt ) == wid );
    }

    return FALSE;
} //IsFirstRowFirstOfCategory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tblvarnt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       tblvarnt.cxx
//
//  Contents:   Class to aid in dealing with PROPVARIANTs in the result table.
//
//  Classes:    VARNT_DATA - size and allignment constraints of variant types
//              CTableVariant - Wrapper around PROPVARIANT
//
//  History:    25 Jan 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <tblvarnt.hxx>
#include <pmalloc.hxx>

#include "tabledbg.hxx"

//--------------------------------------------------------------------------
//
//  The following structure gives the size and allignment requirements
//  to store a bare variant type (without the variant overhead) in window
//  row data.  For variable length data, information about the location
//  of pointers in the structure is given.
//
//  Flags information is given as follows:
//      01 (CanBeVector) - base type can be in a vector
//      02 (ByRef)       - includes pointer in first word of data part
//      04 (CntRef)      - includes pointer in second word of data part
//      08 (StoreDirect) - variant form includes pointer; store direct in table
//      10 (MultiSize)   - for data like BYTES that is inline in client output
//      20 (SimpleType)  - simple inline datatype, like VT_I4
//      40 (OAType)      - valid in OLE Automation variants (older style)
//
//  NOTE:  This table includes all valid types in PROPVARIANT;
//         it is not limited to types in OLE-DB's appendix A.
//  NOTE:  Some types are listed in wtypes.h as being valid in automation
//         variants, but we can't mark them as OAType until the language
//         interpreters catch up and recognize those types.
//
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntData [] = {
    // DBTYPE_VECTOR 0x1000
    // DBTYPE_BYREF  0x4000

    /* 0  0  VT_EMPTY   */ { 0, 0, SimpleType|OAType},
    /* 1  1  VT_NULL    */ { 0, 0, SimpleType},
    /* 2  2  VT_I2      */ { sizeof (short), sizeof (short), CanBeVector|SimpleType|OAType},
    /* 3  3  VT_I4      */ { sizeof (long), sizeof (long), CanBeVector|SimpleType|OAType},
    /* 4  4  VT_R4      */ { sizeof (float), sizeof (float), CanBeVector|SimpleType|OAType},
    /* 5  5  VT_R8      */ { sizeof (double), sizeof (double), CanBeVector|SimpleType|OAType},
    /* 6  6  VT_CY      */ { sizeof (CY), sizeof (CY), CanBeVector|SimpleType|OAType},
    /* 7  7  VT_DATE    */ { sizeof (DATE), sizeof (DATE), CanBeVector|SimpleType|OAType},
    /* 8  8  VT_BSTR    */ { sizeof (void*), sizeof (void*), CanBeVector|ByRef|OAType},
    /* 9  9  VT_DISPATCH*/ { sizeof (void *), sizeof (void *), 0},
    /* a  10 VT_ERROR   */ { sizeof(SCODE), sizeof(SCODE), CanBeVector|SimpleType|OAType},
    /* b  11 VT_BOOL    */ { sizeof (VARIANT_BOOL), sizeof (VARIANT_BOOL), CanBeVector|SimpleType|OAType},
    /* c  12 VT_VARIANT */ { sizeof (PROPVARIANT), sizeof (double), ByRef|StoreDirect|CanBeVector|OAType},
    /* d  13 VT_UNKNOWN */ { sizeof (void *), sizeof (void *), 0},
    /* e  14 VT_DECIMAL */ { sizeof (DECIMAL), sizeof (LARGE_INTEGER), SimpleType|OAType},
    /* f  15            */ { 0, 0, 0},
    /* 10 16 VT_I1      */ { sizeof(char), sizeof(char), CanBeVector|SimpleType},
    /* 11 17 VT_UI1     */ { sizeof(UCHAR), sizeof(UCHAR), CanBeVector|SimpleType|OAType},
    /* 12 18 VT_UI2     */ { sizeof(unsigned short), sizeof(unsigned short), CanBeVector|SimpleType},
    /* 13 19 VT_UI4     */ { sizeof(unsigned long), sizeof(unsigned long),   CanBeVector|SimpleType},
    /* 14 20 VT_I8      */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},
    /* 15 21 VT_UI8     */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},

    /* 16 22 VT_INT     */ { sizeof (INT), sizeof (INT), SimpleType},
    /* 17 23 VT_UINT    */ { sizeof (UINT), sizeof (UINT), SimpleType},
    // Codes 24-29 are valid for typelibs only
    /* 18 24            */ { 0, 0, 0},
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     25-29, unused
    /* 1e 30 VT_LPSTR   */ { sizeof (LPSTR), sizeof (LPSTR), CanBeVector|ByRef},
    /* 1f 31 VT_LPWSTR  */ { sizeof (LPWSTR), sizeof (LPWSTR), CanBeVector|ByRef},
    /* 20 32            */ { 0, 0, 0},
    /* 21 33            */ { 0, 0, 0},
    /* 22 34            */ { 0, 0, 0},
    /* 23 35            */ { 0, 0, 0},
    /* 24 36 VT_RECORD? */ { 0, 0, 0},          // SPECDEVIATION - what is it?
                      {0,0,0},  {0,0,0}, {0,0,0},       //     37-39, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     40-44, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     45-49, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     50-54, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     55-59, unused
    /* 3c 60            */ { 0, 0, 0},
    /* 3d 61            */ { 0, 0, 0},
    /* 3e 62            */ { 0, 0, 0},
    /* 3f 63            */ { 0, 0, 0},
    /* 40 64 VT_FILETIME*/ { sizeof (FILETIME), sizeof (FILETIME), CanBeVector|SimpleType},
    /* 41 65 VT_BLOB    */ { sizeof (BLOB), sizeof (void*), CntRef},

    // Can these really occur in properties???  varnt.idl says they
    //          are interface pointers
    /* 42 66 VT_STREAM  */ { sizeof (LPWSTR), sizeof (LPWSTR), ByRef},
    /* 43 67 VT_STORAGE */ { sizeof (LPWSTR), sizeof (LPWSTR), ByRef},

    // NOTE:  object-valued properties must be retrieved as Entry IDs
    //          (workid, propid)

    // Can these really occur in properties???  varnt.idl says they
    // are interface pointers.  Even if so, is the definition
    // below appropriate?

    /* 44 68 VT_STREAMED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 45 69 VT_STORED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 46 70 VT_BLOB_OBJECT   */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 47 71 VT_CF      */ { sizeof (CLIPDATA*), sizeof (CLIPDATA*), CanBeVector|ByRef},
    /* 48 72 VT_CLSID   */ { sizeof (GUID), sizeof DWORD, StoreDirect|ByRef|CanBeVector},
};

const unsigned CTableVariant::cVarntData = sizeof CTableVariant::varntData /
                                           sizeof CTableVariant::varntData[0];

//--------------------------------------------------------------------------
//
//  This table is like the table above, but is for DBVARIANT extensions,
//  i.e., those whose variant type values are 128 and above.
//
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntExtData [] = {
    //
    //  Additional type definitions above those in PROPVARIANT.
    //  Some cannot be used for variant binding.
    //
    { 0, sizeof BYTE, MultiSize},               // DBTYPE_BYTES   = x80 128,
    { 0, sizeof CHAR, MultiSize},               // DBTYPE_STR     = x81 129,
    { 0, sizeof WCHAR, MultiSize},              // DBTYPE_WSTR    = x82 130,
    { sizeof LONGLONG, sizeof LONGLONG, 0},     // DBTYPE_NUMERIC = x83 131,
    { 0, 0, 0},                                 // DBTYPE_UDT     = x84 132,
    { sizeof DBDATE, sizeof USHORT, 0},         // DBTYPE_DBDATE  = x85 133,
    { sizeof DBTIME, sizeof USHORT, 0},         // DBTYPE_DBTIME  = x86 134,
    { sizeof DBTIMESTAMP, sizeof ULONG, 0},     // DBTYPE_DBTIMESTAMP= x87 135,
    { sizeof HCHAPTER, sizeof ULONG, 0},        // DBTYPE_HCHAPTER   = x88 136,
    { 0, 0, 0},                                 // was DBTYPE_DBFILETIME
    { sizeof PROPVARIANT, sizeof(double), 0},   // DBTYPE_PROPVARIANT = X8a 138,
    { sizeof DB_VARNUMERIC, sizeof BYTE, 0},    // DBTYPE_VARNUMERIC = x8b 139,
};

const unsigned CTableVariant::cVarntExtData =
    sizeof CTableVariant::varntExtData / sizeof CTableVariant::varntExtData[0];

#ifdef _WIN64
//
// VARIANT DATA for Win32 clients on a Win64 server
//  Pointer references must be 32 bits in length (sizeof ULONG)
//  See '+' for changed entries
//

const CTableVariant::VARNT_DATA CTableVariant::varntData32 [] = {
    // DBTYPE_VECTOR 0x1000
    // DBTYPE_BYREF  0x4000

    /* 0  0  VT_EMPTY   */ { 0, 0, SimpleType|OAType},
    /* 1  1  VT_NULL    */ { 0, 0, SimpleType},
    /* 2  2  VT_I2      */ { sizeof (short), sizeof (short), CanBeVector|SimpleType|OAType},
    /* 3  3  VT_I4      */ { sizeof (long), sizeof (long), CanBeVector|SimpleType|OAType},
    /* 4  4  VT_R4      */ { sizeof (float), sizeof (float), CanBeVector|SimpleType|OAType},
    /* 5  5  VT_R8      */ { sizeof (double), sizeof (double), CanBeVector|SimpleType|OAType},
    /* 6  6  VT_CY      */ { sizeof (CY), sizeof (CY), CanBeVector|SimpleType|OAType},
    /* 7  7  VT_DATE    */ { sizeof (DATE), sizeof (DATE), CanBeVector|SimpleType|OAType},
    /*+8  8  VT_BSTR    */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef|OAType},
    /*+9  9  VT_DISPATCH*/ { sizeof (ULONG), sizeof (ULONG), 0},
    /* a  10 VT_ERROR   */ { sizeof (SCODE), sizeof(SCODE), CanBeVector|SimpleType|OAType},
    /* b  11 VT_BOOL    */ { sizeof (VARIANT_BOOL), sizeof (VARIANT_BOOL), CanBeVector|SimpleType|OAType},
    /*+c  12 VT_VARIANT */ { sizeof (PROPVARIANT32), sizeof (double), ByRef|StoreDirect|CanBeVector|OAType},
    /* d  13 VT_UNKNOWN */ { sizeof (ULONG), sizeof (ULONG), 0},
    /* e  14 VT_DECIMAL */ { sizeof (DECIMAL), sizeof (LARGE_INTEGER), SimpleType|OAType},
    /* f  15            */ { 0, 0, 0},
    /* 10 16 VT_I1      */ { sizeof(char), sizeof(char), CanBeVector|SimpleType},
    /* 11 17 VT_UI1     */ { sizeof(UCHAR), sizeof(UCHAR), CanBeVector|SimpleType|OAType},
    /* 12 18 VT_UI2     */ { sizeof(unsigned short), sizeof(unsigned short), CanBeVector|SimpleType},
    /* 13 19 VT_UI4     */ { sizeof(unsigned long), sizeof(unsigned long),   CanBeVector|SimpleType},
    /* 14 20 VT_I8      */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},
    /* 15 21 VT_UI8     */ { sizeof (LARGE_INTEGER), sizeof (LARGE_INTEGER), CanBeVector|SimpleType},

    /* 16 22 VT_INT     */ { sizeof (INT), sizeof (INT), SimpleType},
    /* 17 23 VT_UINT    */ { sizeof (UINT), sizeof (UINT), SimpleType},
    // Codes 24-29 are valid for typelibs only
    /* 18 24            */ { 0, 0, 0},
                           {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     25-29, unused
    /*+1e 30 VT_LPSTR   */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 1f 31 VT_LPWSTR  */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 20 32            */ { 0, 0, 0},
    /* 21 33            */ { 0, 0, 0},
    /* 22 34            */ { 0, 0, 0},
    /* 23 35            */ { 0, 0, 0},
    /* 24 36 VT_RECORD? */ { 0, 0, 0},          // SPECDEVIATION - what is it?
                      {0,0,0},  {0,0,0}, {0,0,0},       //     37-39, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     40-44, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     45-49, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     50-54, unused
    {0,0,0}, {0,0,0}, {0,0,0},  {0,0,0}, {0,0,0},       //     55-59, unused
    /* 3c 60            */ { 0, 0, 0},
    /* 3d 61            */ { 0, 0, 0},
    /* 3e 62            */ { 0, 0, 0},
    /* 3f 63            */ { 0, 0, 0},
    /* 40 64 VT_FILETIME*/ { sizeof (FILETIME), sizeof (FILETIME), CanBeVector|SimpleType},
    /*+41 65 VT_BLOB    */ { sizeof (BLOB32), sizeof (ULONG), CntRef},

    // Can these really occur in properties???  varnt.idl says they
    //          are interface pointers
    /*+42 66 VT_STREAM  */ { sizeof (ULONG), sizeof (ULONG), ByRef},
    /*+43 67 VT_STORAGE */ { sizeof (ULONG), sizeof (ULONG), ByRef},

    // NOTE:  object-valued properties must be retrieved as Entry IDs
    //          (workid, propid)

    // Can these really occur in properties???  varnt.idl says they
    // are interface pointers.  Even if so, is the definition
    // below appropriate?

    /* 44 68 VT_STREAMED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 45 69 VT_STORED_OBJECT */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /* 46 70 VT_BLOB_OBJECT   */ { 2*sizeof (ULONG), sizeof (ULONG), 0},
    /*+47 71 VT_CF      */ { sizeof (ULONG), sizeof (ULONG), CanBeVector|ByRef},
    /* 48 72 VT_CLSID   */ { sizeof (GUID), sizeof DWORD, StoreDirect|ByRef|CanBeVector},
};

//--------------------------------------------------------------------------
//
//  This table is like the table above, but is for DBVARIANT extensions,
//  i.e., those whose variant type values are 128 and above.
//  
//  This one is also for 64 bit servers talking to 32 bit clients
//--------------------------------------------------------------------------

const CTableVariant::VARNT_DATA CTableVariant::varntExtData32 [] = {
    //
    //  Additional type definitions above those in PROPVARIANT.
    //  Some cannot be used for variant binding.
    //
    { 0, sizeof BYTE, MultiSize},               // DBTYPE_BYTES   = x80 128,
    { 0, sizeof CHAR, MultiSize},               // DBTYPE_STR     = x81 129,
    { 0, sizeof WCHAR, MultiSize},              // DBTYPE_WSTR    = x82 130,
    { sizeof LONGLONG, sizeof LONGLONG, 0},     // DBTYPE_NUMERIC = x83 131,
    { 0, 0, 0},                                 // DBTYPE_UDT     = x84 132,
    { sizeof DBDATE, sizeof USHORT, 0},         // DBTYPE_DBDATE  = x85 133,
    { sizeof DBTIME, sizeof USHORT, 0},         // DBTYPE_DBTIME  = x86 134,
    { sizeof DBTIMESTAMP, sizeof ULONG, 0},     // DBTYPE_DBTIMESTAMP= x87 135,
    { sizeof ULONG, sizeof ULONG, 0},           // DBTYPE_HCHAPTER   = x88 136,
    { 0, 0, 0},                                 // was DBTYPE_DBFILETIME
    { sizeof PROPVARIANT32, sizeof(double), 0}, // DBTYPE_PROPVARIANT = X8a 138,
    { sizeof DB_VARNUMERIC, sizeof BYTE, 0},    // DBTYPE_VARNUMERIC = x8b 139,
};

#endif // _WIN64


//
//      Variant helper methods
//


//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::Copy, public
//              CTableVariant::CopyData, private
//
//  Synopsis:   Copy the data of a variant.  One method copies the variant
//              and its data, the other copies the variant only.
//
//  Arguments:  [pvarntDest] - pointer to destination variant (Copy method only)
//              [rVarAllocator] - pointer to variable allocator for dest. data
//              [cbDest] - expected size in bytes of variable data
//              [pbBias] - base address of variable data if offset stored in
//                              variant
//
//  Returns:    VOID* - the address to which the data was copied
//
//  Notes:      If the variant is an internal form, double indirect
//              data will use offsets, not pointers.  The input
//              variant from external callers will generally have
//              pointers, not offsets even for internal form variants.
//
//--------------------------------------------------------------------------

void CTableVariant::Copy(
                        CTableVariant *pvarntDest,
                        PVarAllocator &rVarAllocator,
                        USHORT cbDest,
                        BYTE* pbBias) const
{
    // Copy into a temp variant so if copy fails the output variant
    // isn't affected.  Clients don't always check return codes.

    CTableVariant tmp = *this;

    BOOL fBased = rVarAllocator.IsBasedMemory();
    if ( fBased )
    {
        tmp.SetDataSize((USHORT) cbDest);
    }
    else
    {
        tmp.ResetDataSize( );
    }

    if (cbDest != 0)
    {
        BYTE* pbDest = (BYTE *) CopyData(rVarAllocator, cbDest, pbBias);

        if ( fBased )
            pbDest = (BYTE*) rVarAllocator.PointerToOffset(pbDest);

        if ( tmp.VariantPointerInFirstWord() )
        {
            tmp.pszVal = (LPSTR)pbDest;
        }
        else
        {
            Win4Assert( tmp.VariantPointerInSecondWord() );

            tmp.blob.pBlobData = pbDest;
        }
    }

    *pvarntDest = tmp;
}


VOID* CTableVariant::CopyData(
                             PVarAllocator &rVarAllocator,
                             USHORT cbDest, BYTE* pbBias ) const
{
    BYTE* pbSrc = VariantPointerInFirstWord() ?
                  (BYTE*)pszVal : blob.pBlobData;
    pbSrc += (ULONG_PTR)pbBias;

    Win4Assert( cbDest != 0 );

    // optimize this most typical path
    if ( VT_LPWSTR == vt )
    {
        return (BYTE*) rVarAllocator.CopyTo( cbDest, pbSrc );
    }

    if (vt == VT_BSTR)
    {
        //  Need to allow for byte count before the string
        return rVarAllocator.CopyBSTR(cbDest -
                                     (sizeof (DWORD) + sizeof (OLECHAR)),
                                     (WCHAR *)pbSrc );
    }

    //
    //  Determine if offsets or pointers are used in the source data.  If
    //  offsets are used, and offsets will be used in the destination, the
    //  data can simply be block copied.  Otherwise, vectors of strings and
    //  vectors of variants must have pointers translated to offsets or
    //  vice-versa.
    //

    if ( _IsInternalVariant() && rVarAllocator.IsBasedMemory() )
    {
        Win4Assert( vt != VT_VARIANT && vt != VT_BSTR );
        //
        //  We're copying with offsets to a destination with offsets.
        //  Just copy.
        //
        return rVarAllocator.CopyTo(cbDest, pbSrc);
    }

    BYTE* pbDest = 0;

    switch (vt)
    {
    case VT_LPSTR:
    case VT_CLSID:
    case VT_BLOB:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
    case VT_VECTOR | VT_CLSID:
        //
        //  There are no embedded pointers.  Just copy.
        //
        pbDest = (BYTE*) rVarAllocator.CopyTo(cbDest, pbSrc);
        break;

    case VT_VECTOR | VT_BSTR:
        pbDest = (BYTE*) rVarAllocator.Allocate( calpstr.cElems * sizeof (BSTR) );

        if (pbDest != 0)
        {
            BSTR* paStr = (BSTR*) pbDest;
            CABSTR caStr = cabstr;
            caStr.pElems = (BSTR*)pbSrc;

            for (unsigned i = 0; i < caStr.cElems; i++)
            {
                pbSrc = pbBias + (ULONG_PTR) caStr.pElems[i];

                ULONG cb = BSTRLEN((BSTR)pbSrc);

                BYTE *pbTmp = (BYTE *) rVarAllocator.PointerToOffset(
                                          rVarAllocator.CopyBSTR(cb, (WCHAR*)pbSrc));

                paStr[i] = (BSTR) pbTmp;
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
    case VT_VECTOR | VT_LPSTR:
        pbDest = (BYTE*) rVarAllocator.Allocate( calpstr.cElems * sizeof (LPSTR) );

        if (pbDest != 0)
        {
            LPSTR* paStr = (LPSTR*) pbDest;
            CALPSTR caStr = calpstr;
            caStr.pElems = (LPSTR*)pbSrc;

            for (unsigned i = 0; i < caStr.cElems; i++)
            {
                ULONG cb;
                pbSrc = pbBias + (ULONG_PTR) caStr.pElems[i];

                if ( ( VT_LPWSTR | VT_VECTOR ) == vt )
                    cb = (wcslen((LPWSTR)pbSrc) + 1) * sizeof (WCHAR);
                else
                    cb = (strlen((LPSTR)pbSrc) + 1) * sizeof (CHAR);

                paStr[i] = (LPSTR) rVarAllocator.PointerToOffset(
                                             rVarAllocator.CopyTo(cb, pbSrc));
            }
        }
        break;

    case VT_CF:
    {
        pbDest = (BYTE *) rVarAllocator.Allocate( sizeof CLIPDATA );
        CLIPDATA *pClipData = (CLIPDATA *) pbDest;
        pClipData->cbSize = pclipdata->cbSize;
        pClipData->ulClipFmt = pclipdata->ulClipFmt;

        ULONG cbData = CBPCLIPDATA( *pclipdata );
        pClipData->pClipData = 0;
        pClipData->pClipData = (BYTE *) rVarAllocator.Allocate( cbData );
        RtlCopyMemory( pClipData->pClipData, pclipdata->pClipData, cbData );
        pClipData->pClipData = (BYTE *) rVarAllocator.PointerToOffset( pClipData->pClipData );
    }
        break;

    case VT_VECTOR | VT_CF:
    {
        // allocate the array of pointers to clip format elements

        ULONG cbArray = caclipdata.cElems * sizeof caclipdata.pElems[0];
        pbDest = (BYTE *) rVarAllocator.Allocate( cbArray );

        if ( 0 != pbDest )
        {
            CLIPDATA * aData = (CLIPDATA *) pbDest;
            RtlZeroMemory( aData, cbArray );

            for ( unsigned i = 0; i < caclipdata.cElems; i++ )
            {
                aData[i].cbSize = caclipdata.pElems[i].cbSize;
                aData[i].ulClipFmt = caclipdata.pElems[i].ulClipFmt;
                ULONG cbData = CBPCLIPDATA( caclipdata.pElems[ i ] );
                aData[i].pClipData = (BYTE *) rVarAllocator.Allocate( cbData );
                RtlCopyMemory( aData[i].pClipData,
                               caclipdata.pElems[i].pClipData,
                               cbData );
                aData[i].pClipData = (BYTE *) rVarAllocator.PointerToOffset( aData[i].pClipData );
            }
        }
    }
        break;

    case VT_VECTOR | VT_VARIANT:
        //
        //  Copy vector of variant.  Recurses for any element of the
        //  vector that has variable data.  Special handling is needed
        //  for the case of pVarAllocator being a size allocator, which
        //  is indicated by an allocation return being zero (the allocators
        //  throw an exception if out of memory).
        //

        pbDest = (BYTE*) rVarAllocator.Allocate( capropvar.cElems *
                                                 sizeof CTableVariant );

        if (pbDest != 0)
        {
            CTableVariant* paVarnt = (CTableVariant*) pbDest;

            CTableVariant* paSrcVarnt = (CTableVariant*)
                                        (pbBias + (ULONG_PTR) capropvar.pElems);
            for (unsigned i = 0; i < capropvar.cElems; i++)
            {
                ULONG cbVarData = paSrcVarnt->VarDataSize();
                Win4Assert( cbVarData <= USHRT_MAX );

                paSrcVarnt->Copy(paVarnt, rVarAllocator, (USHORT)cbVarData,
                                 _IsInternalVariant() ? (BYTE *)paSrcVarnt : 0);

                paSrcVarnt++;
            }
        }
        break;

    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
        {
            SAFEARRAY * pSaSrc  = parray;
            SAFEARRAY * pSaDest = 0;

            if ( SaCreateAndCopy( rVarAllocator, pSaSrc, &pSaDest ) &&
                 0 != pSaDest )
                SaCreateData( rVarAllocator,
                              vt & ~VT_ARRAY,
                              *pSaSrc,
                              *pSaDest,
                              TRUE );

            pbDest = (BYTE*)pSaDest;
        }
        break;

    default:
        tbDebugOut(( DEB_WARN, "Unsupported variant type %4x\n", (int) vt ));
        Win4Assert(! "Unsupported variant type in CTableVariant::CopyData");
    }

    //
    //  NOTE:  pbDest can be null if the allocator we were passed is a
    //          size allocator.
    //
    //Win4Assert(pbDest != 0);
    return pbDest;
}

#ifdef _WIN64

//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::FixDataPointers, public
//
//  Synopsis:   Adjust offsets to be pointers for variable data
//
//  Arguments:  [pbBias] - adjustment base for variable data pointer
//              [pArrayAlloc] - Pointer to an allocator
//
//  Returns:    -Nothing-
//
//  History:    22 Sep 1999     KLam    Reinstated and added code
//
//  Notes:      This routine can be recursive when operating on variants
//              which contain vectors of variants.  As a side-effect, the
//              signature which indicates an internal form of variant is
//              cleared.
//
//              This routine is only be used for communication between a 32
//              bit server and 64 bit client.  So the pointers found in the
//              rows are always 32 bits.  Note the casting.
//              Arrays of of pointers are stored in the pArrayAlloc buffer.
//
//--------------------------------------------------------------------------

void CTableVariant::FixDataPointers(BYTE* pbBias, CFixedVarAllocator *pArrayAlloc)
{
    PROPVARIANT32 *pThis32 = (PROPVARIANT32 *)this;

    USHORT flags = _FindVarType( pThis32->vt ).flags;
    BOOL fVectorOrArray = ( 0 != ( (VT_ARRAY|VT_VECTOR) & pThis32->vt ) );
    USHORT vtBase = pThis32->vt & VT_TYPEMASK;
    BOOL fSafeArray = ( (0 != ( VT_ARRAY & pThis32->vt )) || (VT_SAFEARRAY == vtBase) );

    // If a simple type and not a vector, just return

    tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers [this:0x%I64x] (Bias: 0x%I64x) pThis32->vt:0x%x\n",
                 this, pbBias, vt ));

    if ( ( 0 != ( flags & SimpleType ) ) &&
         ( ! fVectorOrArray ) )
        return;

    Win4Assert( _IsInternalVariant() );

    //  Clear internal reserved fields

    ResetDataSize();

    BYTE* pbVarData;

    if ( ( ! fVectorOrArray ) &&
         ( 0 != ( flags & ByRef ) ) )
    {
        pszVal = (LPSTR) ( pbBias + pThis32->p );

        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting string to 0x%I64x\n", pszVal ));
        return;
    }
    else if ( fSafeArray )
    {
        pbVarData = pbVal = pbBias + pThis32->p;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting SafeArray to 0x%I64x\n", pszVal ));
    }
    else
    {
        Win4Assert( VariantPointerInSecondWord() );
        blob.pBlobData = pbVarData = pbBias + pThis32->blob.pBlob;
        blob.cbSize = pThis32->blob.cbSize;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting value to 0x%I64x\n", pbVarData ));
    }

    //
    //  Adjust offsets to pointers in vectors with pointers
    //
    if (vt == (VT_LPWSTR|VT_VECTOR) ||
        vt == (VT_LPSTR|VT_VECTOR) ||
        vt == (VT_BSTR|VT_VECTOR))
    {
        LPSTR * paNewArray = (LPSTR *)pArrayAlloc->Allocate( calpstr.cElems * (sizeof (void *)) );
        ULONG * puStr = (ULONG *) pbVarData;
        for (unsigned i = 0; i < calpstr.cElems; i++)
            paNewArray[i] = (LPSTR) (puStr[i] + pbBias);
        // Point to the new bigger array
        blob.pBlobData = pbVarData = (BYTE *)paNewArray;
        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers setting vector to 0x%I64x\n", paNewArray ));
    }
    // VECTOR of VARIANTS aren't currently supported
    // This branch is untested
    else if (vt == (VT_VARIANT|VT_VECTOR))
    {
        CTableVariant* pVarnt = (CTableVariant*) pbVarData;

        tbDebugOut(( DEB_TRACE, "CTableVariant::FixDataPointers recursively setting variant vector!\n" ));
        for (unsigned i = 0; i < capropvar.cElems; i++)
        {
            pVarnt->FixDataPointers(pbBias, pArrayAlloc);
            pVarnt++;
        }
    }
    else if ( fSafeArray )
    {
        SAFEARRAY32 *pSafeArray32 = (SAFEARRAY32 *) pbVarData;
        // Get the size of the safearray
        unsigned cbSASize = sizeof (SAFEARRAY) + ( (pSafeArray32->cDims - 1 ) * sizeof (SAFEARRAYBOUND) );

        // Allocate a new SAFEARRAY for WIN64
        SAFEARRAY *pSafeArray = (SAFEARRAY *)pArrayAlloc->Allocate( cbSASize );
        
        // Copy the SAFEARRAY
        tbDebugOut(( DEB_TRACE, 
                     "CTableVariant::FixDataPointers SafeArray32\n\tcDims:%d fFeatures:0x%x cbElements:%d cLocks:%d pvData:0x%I64x\n", 
                     pSafeArray32->cDims, pSafeArray32->fFeatures, pSafeArray32->cbElements, pSafeArray32->cLocks, pSafeArray32->pvData ));

        pSafeArray->cDims = pSafeArray32->cDims;
        pSafeArray->fFeatures = pSafeArray32->fFeatures;
        pSafeArray->cbElements = pSafeArray32->cbElements;
        pSafeArray->cLocks = pSafeArray32->cLocks;
        pSafeArray->pvData = pSafeArray32->pvData + pbBias;
        memcpy ( pSafeArray->rgsabound, pSafeArray32->rgsabound, pSafeArray32->cDims * sizeof (SAFEARRAYBOUND) );
        
        tbDebugOut(( DEB_TRACE, 
                     "CTableVariant::FixDataPointers SafeArray\n\tcDims:%d fFeatures:0x%x cbElements:%d cLocks:%d pvData:0x%I64x\n", 
                     pSafeArray->cDims, pSafeArray->fFeatures, pSafeArray->cbElements, pSafeArray->cLocks, pSafeArray->pvData ));

        // Point the table variant at it
        parray = pSafeArray;
        
        tbDebugOut(( DEB_TRACE, 
                     "CTableVariant::FixDataPointers setting safearray to 0x%I64x with array at 0x%I64x\n", 
                     pSafeArray, pSafeArray->pvData ));

        // Safearray of BSTR
        if ( VT_BSTR == vtBase )
        {
            // Pointing to an array of pointers so adjust the size
            pSafeArray->cbElements = sizeof (void *);

            // Get the number of elements in the safe array
            unsigned cBstrElements = pSafeArray->rgsabound[0].cElements;
            for ( unsigned j = 1; j < pSafeArray->cDims; j++ )
                cBstrElements *= pSafeArray->rgsabound[j].cElements;

            unsigned cbBstrElements = cBstrElements * sizeof (void *);
            ULONG_PTR *apStrings = (ULONG_PTR *) pArrayAlloc->Allocate ( cbBstrElements );
            ULONG *pulBstr = (ULONG *) pSafeArray->pvData;
            for ( j = 0; j < cBstrElements; j++ )
                apStrings[j] = (ULONG_PTR) (pulBstr[j] + pbBias);
            pSafeArray->pvData = apStrings;

            tbDebugOut(( DEB_TRACE, 
                         "CTableVariant::FixDataPointers setting safearray BSTRs to 0x%I64x\n", 
                         apStrings ));
        }
        else if ( VT_VARIANT == vtBase )
        {
            // Pointing to an array of variants so adjust its size
            pSafeArray->cbElements = sizeof ( PROPVARIANT );

            // Get the number of elements in the safe array
            unsigned cVarElements = pSafeArray->rgsabound[0].cElements;
            for ( unsigned k = 1; k < pSafeArray->cDims; k++ )
                cVarElements *= pSafeArray->rgsabound[k].cElements;

            unsigned cbVarElements = cVarElements * sizeof (PROPVARIANT);
            PROPVARIANT *apVar = (PROPVARIANT *) pArrayAlloc->Allocate ( cbVarElements );
            PROPVARIANT32 *pVar32 = (PROPVARIANT32 *) pSafeArray->pvData;
            CTableVariant *ptv;
            for ( k = 0; k < cVarElements; k++ )
            {
                apVar[k].vt = pVar32[k].vt;
                apVar[k].wReserved1 = _wInternalSig;
                apVar[k].wReserved2 = pVar32[k].wReserved2;
                apVar[k].wReserved3 = _wInternalSig;

                apVar[k].blob.cbSize = pVar32[k].blob.cbSize;
                ULONG ulBlob = pVar32[k].blob.pBlob;
                apVar[k].blob.pBlobData = (BYTE *) UlongToPtr( ulBlob ) ;
                ptv = (CTableVariant *)&apVar[k];
                ptv->FixDataPointers ( pbBias, pArrayAlloc );
            }
            
            pSafeArray->pvData = apVar;

            tbDebugOut(( DEB_TRACE, 
                         "CTableVariant::FixDataPointers setting safearray BSTRs to 0x%I64x\n", 
                         apVar ));
        }
    }
} //FixDataPointers

//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::VarDataSize32, public
//
//  Synopsis:   Compute variable data size of a 64 bit variant for a Win32 
//              machine
//
//  Arguments:  [pbBase]        - Buffer containing variant data
//              [ulpOffset]     - Offset of buffer on the client
//
//  Returns:    ULONG - size in bytes of data which is outside the
//                      variant structure itself
//
//  Notes:      For variants which are stored internally in the table,
//              the size is computed once and stored in the wReserved2
//              field of the variant structure.
//
//              This function must be called **BEFORE** 32 pointer fixing
//
//  History:    11-04-99    KLam    Created for Win64
//              12-Feb-2000 KLam    Vector string pointers not rebased
//                                  BSTRs not multiplied by sizeof (OLECHAR)
//
//--------------------------------------------------------------------------

ULONG CTableVariant::VarDataSize32 ( BYTE *pbBase,
                                     ULONG_PTR ulpOffset ) const
{
    if ( VT_LPWSTR == vt )
    {
        LPWSTR lpwstrRef = (LPWSTR)( ((UINT_PTR)pwszVal - ulpOffset ) + pbBase );
        return ( wcslen( lpwstrRef ) + 1 ) * sizeof (WCHAR);
    }

    if ( IsSimpleType( vt ) )
    {
        if ( 0 == ( ( VT_ARRAY | VT_VECTOR ) & vt ) )
        {
            return 0;
        }
        else if ( vt & VT_VECTOR )
        {
            USHORT cbSize, cbAllign, rgFlags;

            VartypeInfo32( vt, cbSize, cbAllign, rgFlags );

            return cbSize * cai.cElems;
        }
    }

    Win4Assert( 0 == ( vt & VT_BYREF ) );

    switch (vt)
    {
    case VT_LPSTR:
        {
            LPSTR lpstrRef = (LPSTR)( ((UINT_PTR)pszVal - ulpOffset ) + pbBase );
            return strlen(lpstrRef) + 1;
        }

    case VT_BLOB:
        return blob.cbSize;

    case VT_BSTR:
        {
            BSTR bstrRef = (BSTR)( ((UINT_PTR)bstrVal - ulpOffset ) + pbBase );
            tbDebugOut(( DEB_TRACE, 
                         "VarDataSize32 sizing BSTR at bstrRef: 0x%I64x with size %d\n", 
                         bstrRef, BSTRLEN(bstrRef) ));

            Win4Assert(bstrRef[ BSTRLEN(bstrRef) / sizeof (OLECHAR) ] == OLESTR('\0'));
            return ( BSTRLEN(bstrRef) * sizeof (OLECHAR) ) 
                    + sizeof (DWORD) + sizeof (OLECHAR);
        }

    case VT_BSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof (PTR32) * cabstr.cElems;
            BSTR * abstrRef = (BSTR *)( ((UINT_PTR)cabstr.pElems - ulpOffset ) + pbBase );
            tbDebugOut(( DEB_TRACE, 
                         "VarDataSize32 sizing %d BSTR(s) vector at abstrRef: 0x%I64x \n", 
                         cabstr.cElems, abstrRef ));
            for (unsigned i=0; i < cabstr.cElems; i++)
            {
                BSTR bstrFixed = (BSTR)((((UINT_PTR)(abstrRef[i])) - ulpOffset ) + pbBase);
                cbTotal +=  ( BSTRLEN( bstrFixed ) * sizeof (OLECHAR) ) +
                           sizeof (DWORD) + sizeof (OLECHAR);
            }
            return cbTotal;
        }

    case VT_LPSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof (PTR32) * calpstr.cElems;
            LPSTR * alpstrRef = (LPSTR *)( ((UINT_PTR)calpstr.pElems - ulpOffset ) + pbBase );
            for (unsigned i=0; i < calpstr.cElems; i++)
            {
                LPSTR lpstrFixed = (LPSTR)(( ((UINT_PTR)(alpstrRef[i])) - ulpOffset ) + pbBase);
                cbTotal += strlen( lpstrFixed ) + 1;
            }
            return cbTotal;
        }

    case VT_LPWSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof(PTR32)  * calpwstr.cElems;
            LPWSTR * alpwstr = (LPWSTR *)( ((UINT_PTR)calpwstr.pElems - ulpOffset ) + pbBase );
            for (unsigned i=0; i < calpwstr.cElems; i++)
            {
                LPWSTR lpwstrFixed = (LPWSTR)(( ((UINT_PTR)(alpwstr[i])) - ulpOffset ) + pbBase); 
                cbTotal += (wcslen( lpwstrFixed ) + 1) * sizeof (WCHAR);
            }
            return cbTotal;
        }

    case VT_VARIANT | VT_VECTOR:
        {
            ULONG cbTotal = sizeof PROPVARIANT32 * capropvar.cElems;
            CTableVariant * atv = (CTableVariant *)( ((UINT_PTR)capropvar.pElems - ulpOffset ) + pbBase );
            for (unsigned i=0; i < capropvar.cElems; i++)
                cbTotal += atv[i].VarDataSize();
            return cbTotal;
        }

    case VT_CLSID :
        {
            return sizeof CLSID;
        }

    case VT_CLSID | VT_VECTOR :
        {
            return sizeof CLSID * cai.cElems;
        }

    case VT_CF :
        {
            if ( 0 != pclipdata )
            {
                CLIPDATA * pclipRef = (CLIPDATA *)( ((UINT_PTR)pclipdata - ulpOffset ) + pbBase );
                return sizeof CLIPDATA32 + CBPCLIPDATA( *pclipRef );
            }
            else
                return 0;
        }

    case VT_CF | VT_VECTOR :
        {
            ULONG cb = sizeof CLIPDATA32 * caclipdata.cElems;
            CLIPDATA * aclipRef = (CLIPDATA *)( ((UINT_PTR)(caclipdata.pElems) - ulpOffset ) + pbBase );
            for ( ULONG i = 0; i < caclipdata.cElems; i++ )
                cb += CBPCLIPDATA( aclipRef[i] );
            return cb;
        }

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
        {
            LPSAFEARRAY psaRef = (LPSAFEARRAY)( ((UINT_PTR)parray - ulpOffset ) + pbBase );
            return SaComputeSize32( vt & ~VT_ARRAY, *psaRef, pbBase, ulpOffset );
        }

    case VT_EMPTY :
        return 0;

    default:
        tbDebugOut(( DEB_WARN, "Unsupported variant type %4x\n", (int) vt ));
        Win4Assert(! "Unsupported variant type in CTableVariant::VarDataSize");
        return 0;
    }
} // VarDataSize32

//+---------------------------------------------------------------------------
//
//  Function:   CTableVariant::SaComputeSize32, public static
//
//  Synopsis:   Computes the size of a safearray for a 32 bit machine.
//
//  Arguments:  [vt]            - variant type (VT_ARRAY assumed)
//              [saSrc]         - 64 bit source safearry
//              [pbBase]        - Buffer containing variant data
//              [ulpOffset]     - Offset of buffer on the client
//
//  Returns:    ULONG - number of bytes of memory needed to store safearray
//
//  History:    5-01-98     AlanW       Created
//              11-4-99     KLam        Adjusted for 32bit array on 64bit machine
//
//----------------------------------------------------------------------------

ULONG CTableVariant::SaComputeSize32( VARTYPE vt,
                                      SAFEARRAY & saSrc,
                                      BYTE *pbBase,
                                      ULONG_PTR ulpOffset )
{
    //
    // get number of data elements in array and size of the header.
    //
    unsigned cDataElements = 1;
    for ( unsigned i = 0; i < saSrc.cDims; i++ )
        // This array is in place so no pointer fixing is necessary
        cDataElements *= saSrc.rgsabound[i].cElements;

    Win4Assert( 0 != saSrc.cDims );

    ULONG    cb = sizeof (SAFEARRAY32) +
                  (saSrc.cDims-1) * sizeof (SAFEARRAYBOUND) +
                  cDataElements * saSrc.cbElements;

    cb = AlignBlock( cb, sizeof LONGLONG );

    switch (vt)
    {
    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
        break;

    case VT_BSTR:
        {
            BSTR *pBstrSrc = (BSTR *)( ( ((UINT_PTR)saSrc.pvData) - ulpOffset ) + pbBase );

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pBstrSrc[i]  != 0 );

                BSTR bstrRef = (BSTR) ( ( ( (UINT_PTR) (pBstrSrc[i]) ) - ulpOffset ) + pbBase );
                tbDebugOut(( DEB_TRACE, 
                             "Sizing Array of BSTR: 0x%I64x BSTR[%d]: %xI64x (size: %d)\n", 
                             pBstrSrc, bstrRef, BSTRLEN(bstrRef) ));
                cb += AlignBlock( SysStringByteLen(bstrRef) +
                                  sizeof ULONG + sizeof WCHAR,
                                  sizeof LONGLONG );
            }
        }
        break;

    case VT_VARIANT:
        {
            CAllocStorageVariant *pVarnt = (CAllocStorageVariant *)( ((UINT_PTR)saSrc.pvData - ulpOffset ) + pbBase );

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                if ( VT_BSTR == pVarnt[i].vt )
                {
                    BSTR bstrRef = (BSTR)( ((UINT_PTR)pVarnt[i].bstrVal - ulpOffset ) + pbBase );
                    cb += AlignBlock( SysStringByteLen( bstrRef ) +
                                      sizeof ULONG + sizeof WCHAR,
                                      sizeof LONGLONG );
                }
                else if ( 0 != (pVarnt[i].vt & VT_ARRAY) )
                {
                    LPSAFEARRAY psaRef = (LPSAFEARRAY)( ((UINT_PTR)pVarnt[i].parray - ulpOffset ) + pbBase );
                    cb += AlignBlock( SaComputeSize32( (pVarnt[i].vt & ~VT_ARRAY),
                                                       *psaRef,
                                                       pbBase,
                                                       ulpOffset ),
                                      sizeof LONGLONG );
                }
                else
                {
                    Win4Assert( pVarnt[i].vt != VT_VARIANT );
                }
            }
        }
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unexpected SafeArray type: vt=%x\n", vt ) );
        Win4Assert( !"Unexpected SafeArray Type" );
        return 1;
    }

    return cb;
} // SaComputeSize32


#endif // _WIN64

//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::VarDataSize, public
//
//  Synopsis:   Compute variable data size for a variant
//
//  Arguments:  - none -
//
//  Returns:    ULONG - size in bytes of data which is outside the
//                      variant structure itself
//
//  Notes:      For variants which are stored internally in the table,
//              the size is computed once and stored in the wReserved2
//              field of the variant structure.
//
//--------------------------------------------------------------------------

ULONG CTableVariant::VarDataSize (void) const
{
    // short-circuit this common path: VT_LPWSTR

    if ( VT_LPWSTR == vt )
        return ( wcslen( pwszVal ) + 1 ) * sizeof (WCHAR);

    if ( IsSimpleType( vt ) )
    {
        if ( 0 == ( ( VT_ARRAY | VT_VECTOR ) & vt ) )
        {
            return 0;
        }
        else if ( vt & VT_VECTOR )
        {
            USHORT cbSize, cbAllign, rgFlags;

            VartypeInfo( vt, cbSize, cbAllign, rgFlags );

            return cbSize * cai.cElems;
        }
    }

    Win4Assert( 0 == ( vt & VT_BYREF ) );

    switch (vt)
    {
    case VT_LPSTR:
        return strlen(pszVal) + 1;

    case VT_BLOB:
        return blob.cbSize;

    case VT_BSTR:
        Win4Assert(bstrVal[ BSTRLEN(bstrVal) / sizeof (OLECHAR) ] == OLESTR('\0'));
        return BSTRLEN(bstrVal) + sizeof (DWORD) + sizeof (OLECHAR);

    case VT_BSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof (void *) * cabstr.cElems;
            for (unsigned i=0; i<cabstr.cElems; i++)
                cbTotal += BSTRLEN(cabstr.pElems[i]) +
                           sizeof (DWORD) + sizeof (OLECHAR);
            return cbTotal;
        }

    case VT_LPSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof (void *) * calpstr.cElems;
            for (unsigned i=0; i<calpstr.cElems; i++)
                cbTotal += strlen(calpstr.pElems[i]) + 1;
            return cbTotal;
        }

    case VT_LPWSTR | VT_VECTOR:
        {
            ULONG cbTotal = sizeof( void * )  * calpwstr.cElems;
            for (unsigned i=0; i<calpwstr.cElems; i++)
                cbTotal += (wcslen(calpwstr.pElems[i]) + 1) * sizeof (WCHAR);
            return cbTotal;
        }

    case VT_VARIANT | VT_VECTOR:
        {
            ULONG cbTotal = sizeof PROPVARIANT * capropvar.cElems;
            for (unsigned i=0; i<capropvar.cElems; i++)
                cbTotal += ((CTableVariant &)capropvar.pElems[i]).VarDataSize();
            return cbTotal;
        }

    case VT_CLSID :
        {
            return sizeof CLSID;
        }

    case VT_CLSID | VT_VECTOR :
        {
            return sizeof CLSID * cai.cElems;
        }

    case VT_CF :
        {
            if ( 0 != pclipdata )
                return sizeof CLIPDATA + CBPCLIPDATA( *pclipdata );
            else
                return 0;
        }

    case VT_CF | VT_VECTOR :
        {
            ULONG cb = sizeof CLIPDATA * caclipdata.cElems;
            for ( ULONG i = 0; i < caclipdata.cElems; i++ )
                cb += CBPCLIPDATA( caclipdata.pElems[i] );
            return cb;
        }

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
            return SaComputeSize( vt & ~VT_ARRAY, *parray);

    case VT_EMPTY :
        return 0;

    default:
        tbDebugOut(( DEB_WARN, "Unsupported variant type %4x\n", (int) vt ));
        Win4Assert(! "Unsupported variant type in CTableVariant::VarDataSize");
        return 0;
    }
}

const USHORT CTableVariant::_wInternalSig = 0x3210;

//+-------------------------------------------------------------------------
//
//  Method:     CTableVariant::Init, public
//
//  Synopsis:   Fills in a variant with new data
//
//  Arguments:  [vtIn] -- the data type of the new variant
//              [pbData] -- pointer to source of data
//              [cbData] -- size in bytes of data at pbData
//
//  Returns:    -Nothing-
//
//  Notes:      The variant is reused.  The caller is responsible
//              for freeing any memory from the previous contents
//              of the variant prior to calling Init.
//
//              If pbData is NULL and cbData is zero, only the
//              variant type is filled in.
//
//--------------------------------------------------------------------------

void CTableVariant::Init(
                        VARTYPE vtIn,
                        BYTE* pbData,
                        ULONG cbData)
{
    // Clean out the entire variant
    RtlZeroMemory(this, sizeof CTableVariant);

    vt = vtIn;  // default; minor exceptions below

    if (pbData == 0 && cbData == 0)
        return;

    if ( VT_VARIANT == vtIn )
    {
        tbDebugOut(( DEB_ITRACE, "CTableVariant::Init from vt_variant\n" ));
        * this = * ((CTableVariant *) pbData);
    }
    else if (vtIn & VT_VECTOR)
    {
        Win4Assert( cbData == sizeof (CAI) );
        RtlCopyMemory((BYTE *)&cai, pbData, sizeof (CAI));
    }
    else if ( IsSimpleType( vtIn ) )
    {
        RtlCopyMemory( (BYTE *)&iVal, pbData, cbData );
    }
    else
    {
        switch (vtIn)
        {
        case VT_CLSID:
            Win4Assert(cbData == sizeof (GUID));
            puuid = (GUID *)pbData;
            break;
        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            Win4Assert(cbData == sizeof (LPSTR));
            pszVal = *(LPSTR *)pbData;
            break;
        case VT_BLOB:
            Win4Assert(cbData == sizeof (BLOB));
            blob = *(BLOB *)pbData;
            break;
        default:
            tbDebugOut(( DEB_WARN, "Unsupported variant type %4x\n", (int) vtIn ));
            Win4Assert(! "unsupported variant type in CTableVariant::Init");
        }
    }
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CTableVariant::_StoreString, private
//
//  Synopsis:   Copy variant string data, coerce if possible
//
//  Arguments:  [pbDstBuf]    -- destination buffer
//              [cbDstBuf]    -- size of destination buffer
//              [vtDst]       -- data type of the dest
//              [rcbDstLen]   -- on return, length of destination data
//              [rPool]       -- to use for destination byref allocations
//
//  Returns:    status for copy

//  Notes:      Expects the 'this' data type to be either VT_LPSTR,
//              VT_LPWSTR or VT_BSTR.
//
//--------------------------------------------------------------------------

DBSTATUS CTableVariant::_StoreString( BYTE *           pbDstBuf,
                                      DBLENGTH         cbDstBuf,
                                      VARTYPE          vtDst,
                                      DBLENGTH &       rcbDstLen,
                                      PVarAllocator &  rPool) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    ULONG cbSrc = (vt == VT_BSTR) ? BSTRLEN(bstrVal) + sizeof (OLECHAR) :
                  VarDataSize();

    // if   both are VT_LPWSTR                           or
    //      both are VT_LPSTR                            or
    //      dst is byref wstr and source is VT_LPWSTR    or
    //      dst is byref str and source is VT_LPSTR

    if ( ( (vtDst == vt) &&
           (IsLPWSTR(vtDst)))                           ||
         ( (vtDst == vt) &&
           (IsLPSTR(vtDst)) )                           ||
         ( (vtDst == (DBTYPE_BYREF | DBTYPE_WSTR) ) &&
           (IsLPWSTR(vt) || vt == VT_BSTR) )      ||
         ( (vtDst == (DBTYPE_BYREF | DBTYPE_STR) ) &&
           (IsLPSTR(vt)) ) )
    {
        Win4Assert ((vtDst & VT_VECTOR) == 0 &&
                    cbDstBuf == sizeof LPWSTR);

        BYTE* pbDest = (BYTE *) rPool.CopyTo(cbSrc,(BYTE *) pszVal);

        // ADO gives us 1 byte aligned buffers sometimes.  Sigh.
        // Happens for vt_lpwstr => dbtype_byref|dbtype_wstr

//        Win4Assert( 0 == ( (ULONG_PTR) pbDstBuf % sizeof(ULONG_PTR) ) );

        *(ULONG_PTR UNALIGNED *) pbDstBuf = rPool.PointerToOffset(pbDest);
        rcbDstLen = (vtDst == VT_BSTR) ? sizeof (BSTR) :
                (vtDst == VT_LPWSTR || vtDst == (DBTYPE_BYREF|DBTYPE_WSTR)) ?
                    cbSrc - sizeof (WCHAR) : cbSrc - sizeof (char);
    }
    else if (((vtDst == DBTYPE_WSTR) &&
              (IsLPWSTR(vt) || vt == VT_BSTR))    ||
             ((vtDst == DBTYPE_STR) &&
              (IsLPSTR(vt))))
    {
        // In-line, compatible data types
        if (cbDstBuf >= cbSrc)
        {
            RtlCopyMemory(pbDstBuf, pszVal, cbSrc);
            rcbDstLen = cbSrc - ((vtDst == DBTYPE_WSTR) ?
                                 sizeof (WCHAR) : sizeof (char));
        }
        else
        {
            RtlCopyMemory(pbDstBuf, pszVal, cbDstBuf);
            DstStatus = DBSTATUS_S_TRUNCATED;
            rcbDstLen = cbDstBuf;
        }
    }
    else if ((vtDst == DBTYPE_STR) && (IsLPWSTR(vt) || vt == VT_BSTR))
    {
        // if they want fancy composed chars, they can bind to the
        // proper data type and do the coercion themselves.

        int cb = WideCharToMultiByte(ulCoercionCodePage,0,pwszVal,-1,
                                     0,0,0,0);
        if (0 == cb)
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE; // something odd...
        else
        {
            if (cb > (int) cbDstBuf)
            {
                DstStatus = DBSTATUS_S_TRUNCATED;
                rcbDstLen = cbDstBuf;
            }
            else
                rcbDstLen = cb - sizeof (char);

            WideCharToMultiByte(ulCoercionCodePage,0,pwszVal,-1,
                                (char *) pbDstBuf,(ULONG) cbDstBuf,0,0);
        }
    }
    else if ((vtDst == DBTYPE_WSTR) && (IsLPSTR(vt)))
    {
        // if they want fancy composed chars, they can bind to the
        // proper data type and do the coercion themselves.

        int cwcDst = (int) ( cbDstBuf / sizeof WCHAR );

        int cwc = MultiByteToWideChar(ulCoercionCodePage,0,
                                      pszVal,-1,0,0);
        if (0 == cwc)
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE; // something odd...
        else
        {
            if (cwc > cwcDst)
            {
                DstStatus = DBSTATUS_S_TRUNCATED;
                rcbDstLen = (cwcDst) * sizeof (WCHAR);
            }
            else
                rcbDstLen = (cwc-1) * sizeof (WCHAR);

            MultiByteToWideChar(ulCoercionCodePage,0,
                                pszVal,-1,(WCHAR *) pbDstBuf,cwcDst);
        }
    }
    else if (vtDst == VT_BSTR)
    {
        Win4Assert(vt != VT_BSTR && vt != DBTYPE_STR && vt != DBTYPE_WSTR);
        rcbDstLen = sizeof (BSTR);

        if (IsLPWSTR(vt))
        {
            BSTR bstrDest = (BSTR) rPool.CopyBSTR( cbSrc - sizeof (OLECHAR),
                                                   pwszVal );
            *(ULONG_PTR*) pbDstBuf = rPool.PointerToOffset(bstrDest);
        }
        else
        {
            Win4Assert(IsLPSTR(vt));
            int cwc = MultiByteToWideChar(ulCoercionCodePage,0,
                                          pszVal,-1,0,0);
            if (0 == cwc)
            {
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE; // something odd...
                *(BSTR*) pbDstBuf = 0;
                rcbDstLen = 0;
            }
            else
            {
                XArray<WCHAR> wcsDest( cwc );

                MultiByteToWideChar(ulCoercionCodePage, 0,
                                    pszVal, -1,  wcsDest.Get(), cwc);

                BSTR bstrDest = (BSTR) rPool.CopyBSTR((cwc-1)*sizeof (OLECHAR),
                                                      wcsDest.Get());
                *(ULONG_PTR*) pbDstBuf = rPool.PointerToOffset(bstrDest);
            }
        }
    }
    else
    {
        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        rcbDstLen = 0;
    }

    return DstStatus;
} //_StoreString


//+-------------------------------------------------------------------------
//
//  Member:     CTableVariant::CopyOrCoerce, public
//
//  Synopsis:   Copy table data between a variant structure and
//              a fixed width field.  This is used both for copying
//              data into a window, and out to an output destination.
//
//  Arguments:  [pbDstBuf]    -- pointer to area to be filled in
//              [cbDstBuf]    -- size in bytes of storage area
//              [vtDst]       -- VARTYPE of the destination
//              [rcbDstLen]   -- on return, length of destination data
//              [rPool]       -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  Notes:      This function(and class) now deals only with PROPVARIANTs.
//              If conversion is needed for OLE-DB/Automation types, use the
//              COLEDBVariant class.
//              The [rcbDstLen] is computed according to OLE-DB's (somewhat
//              arbitrary) rules.
//
//  History:    09 Jan 1998     VikasMan   Modified the function to deal ONLY
//                                         with PROPVARIANTs
//
//--------------------------------------------------------------------------

DBSTATUS CTableVariant::CopyOrCoerce(
                                    BYTE *            pbDstBuf,
                                    DBLENGTH          cbDstBuf,
                                    VARTYPE           vtDst,
                                    DBLENGTH &        rcbDstLen,
                                    PVarAllocator &   rPool) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    Win4Assert( (vt & VT_BYREF) == 0 );

    if ( ( vtDst == vt ) && IsSimpleType( vt ) && ! IsVectorOrArray( vt ) )
    {
        if (vt == VT_DECIMAL)
        {
            Win4Assert( cbDstBuf == sizeof (DECIMAL) );
            RtlCopyMemory(pbDstBuf, this, cbDstBuf);
        }
        else
        {
            Win4Assert( cbDstBuf &&
                        cbDstBuf <= sizeof (LONGLONG) );
            RtlCopyMemory(pbDstBuf, &iVal, cbDstBuf);
        }
        rcbDstLen = cbDstBuf;
    }
    else if ( VT_VARIANT == vtDst )
    {
        Win4Assert(cbDstBuf == sizeof PROPVARIANT);

        Copy( (CTableVariant*) pbDstBuf, rPool, (USHORT) VarDataSize() );

        if ( VT_EMPTY == vt )
            DstStatus = DBSTATUS_S_ISNULL;
        rcbDstLen = sizeof (PROPVARIANT);
    }
    else if ( VT_EMPTY == vt )
    {
        RtlZeroMemory( pbDstBuf, cbDstBuf );
        DstStatus = DBSTATUS_S_ISNULL;
        rcbDstLen = 0;
    }
    else if ( ( IsLPWSTR( vtDst ) ) || ( IsLPSTR( vtDst ) ) )
    {
        if ( VT_LPSTR == vt || VT_LPWSTR == vt || VT_BSTR == vt )
        {
            DstStatus = _StoreString( pbDstBuf,
                                      cbDstBuf,
                                      vtDst,
                                      rcbDstLen,
                                      rPool );
        }
        else
        {
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            rcbDstLen = 0;
        }
    }
    else if ( vtDst == vt )
    {
        if ( VT_CLSID == vtDst )
        {
            //  UUID is the one case of a fixed size indirect
            //  reference in DBVARIANT.

            Win4Assert(cbDstBuf == sizeof GUID );
            RtlCopyMemory(pbDstBuf,puuid,sizeof GUID);
            rcbDstLen = sizeof (GUID);
        }
        else
        {
            // Must be a vector or a blob or a bstr

            unsigned cbSrcVar = VarDataSize();

            Win4Assert(vtDst == VT_BSTR ||
                       ((vtDst & VT_VECTOR) != 0 &&
                        vtDst != (VT_VARIANT|VT_VECTOR) &&
                        vtDst != (VT_LPWSTR|VT_VECTOR) &&
                        vtDst != (VT_LPSTR|VT_VECTOR)));

            BYTE* pTmpBuf = (BYTE *) CopyData(rPool,(USHORT) cbSrcVar);

            if (VariantPointerInFirstWord()) // BSTR case
            {
                Win4Assert(cbDstBuf == sizeof (BYTE *));

                *(ULONG_PTR *) pbDstBuf = rPool.PointerToOffset(pTmpBuf);
                rcbDstLen = sizeof (BSTR);
            }
            else
            {
                Win4Assert(VariantPointerInSecondWord() &&
                           (cbDstBuf == sizeof (BLOB) ||
                            cbDstBuf == sizeof (DBVECTOR)));
                if (vtDst == VT_BLOB)
                {
                    ((BLOB *) pbDstBuf)->pBlobData = (BYTE *) rPool.PointerToOffset(pTmpBuf);
                    ((BLOB *) pbDstBuf)->cbSize = blob.cbSize;
                    rcbDstLen = sizeof (BLOB);
                }
                else
                {
                    ((DBVECTOR *) pbDstBuf)->ptr = (BYTE *) rPool.PointerToOffset(pTmpBuf);
                    ((DBVECTOR *) pbDstBuf)->size =cai.cElems;
                    rcbDstLen = 0;
                }

            }
        }
    }
    else
    {
        //  Coercion required.  Only a very limited set of coercions
        //  are done.  These are between various types of integers,
        //  and between two types of strings (both direct and by reference).

        switch (vtDst)
        {
        case VT_LPWSTR:
        case VT_LPSTR:
        case VT_BSTR:

        case (DBTYPE_STR | DBTYPE_BYREF): 
        case (DBTYPE_WSTR | DBTYPE_BYREF):
        case DBTYPE_STR:
        case DBTYPE_WSTR:
            //      case DBTYPE_BYTES:
            if ( VT_LPSTR == vt || VT_LPWSTR == vt || VT_BSTR == vt )
            {
                DstStatus = _StoreString(pbDstBuf,
                                         cbDstBuf,
                                         vtDst,
                                         rcbDstLen,
                                         rPool);
            }
            else
            {
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            }
            break;

        case VT_R4:
            if (VT_R8 == vt)
            {
                if (dblVal > FLT_MAX ||
                    dblVal < FLT_MIN)
                    DstStatus = DBSTATUS_S_TRUNCATED;

                * (float *) pbDstBuf = (float) dblVal;
                rcbDstLen = sizeof (float);
            }
            else
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            break;

        case VT_R8:
            // since DATE is stored as a double, someone may want
            // this odd coercion.

            if (VT_R4 == vt)
                * (double *) pbDstBuf = (double) fltVal;
            if (VT_DATE == vt)
                * (double *) pbDstBuf = (double) date;
            else
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;

            rcbDstLen = sizeof (double);
            break;

        case VT_HRESULT:
        case VT_ERROR:
            // allow coercions from some 4-byte quantities

            if (VT_ERROR == vt || VT_HRESULT == vt ||
                VT_I4 == vt    || VT_UI4 == vt)
                * (ULONG *) pbDstBuf = lVal;
            else
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;

            rcbDstLen = sizeof (SCODE);
            break;

        case VT_CY:
            // allow coercions from I8 and UI8

            if (VT_I8 == vt || VT_UI8 == vt)
                * (LONGLONG *) pbDstBuf = hVal.QuadPart;
            else
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;

            rcbDstLen = sizeof (LONGLONG);
            break;

        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_I4:
        case VT_UI4:
        case VT_BOOL:
        case VT_I8:
        case VT_UI8:
            if ( vt == VT_I1       ||
                 vt == VT_UI1      ||
                 vt == VT_I2       ||
                 vt == VT_UI2      ||
                 vt == VT_I4       ||
                 vt == VT_UI4      ||
                 vt == VT_I8       ||
                 vt == VT_UI8      ||
                 vt == VT_BOOL     ||
                 vt == VT_ERROR    ||
                 vt == VT_HRESULT  ||
                 vt == VT_FILETIME ||
                 vt == VT_EMPTY ) // empty if object is deleted
            {
                DstStatus = _StoreInteger( vtDst, pbDstBuf );

                if (DstStatus != DBSTATUS_E_CANTCONVERTVALUE)
                    rcbDstLen = cbDstBuf;
#if DBG
                USHORT cbSize, cbAllign, rgFlags;
                VartypeInfo( vtDst, cbSize, cbAllign, rgFlags );
                // this fires for all  conversions to VT_BOOL
                // Win4Assert( rcbDstLen == cbSize );
                Win4Assert( DstStatus != DBSTATUS_S_TRUNCATED );
#endif // DBG
            }
            else
            {
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            }
            break;

        case VT_CLSID:
            //  VT_CLSID is given with VT_BYREF in the row buffer

            if (vt == (VT_CLSID | VT_BYREF))
                RtlCopyMemory(pbDstBuf,puuid,sizeof (GUID *));
            else
                DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            break;

        case VT_DATE:
        case VT_FILETIME:
        case DBTYPE_DBDATE:
        case DBTYPE_DBTIME:
        case DBTYPE_DBTIMESTAMP:
            // CTableVariant class does not handle date conversions any longer.
            // These get handled by its derived class - COLEDBVariant now
            tbDebugOut(( DEB_IWARN,
                         "CTableVariant does not handle date conversions.\n" ));
            //Win4Assert( !"Invalid switch case in CopyOrCoerce!" );

                // FALL through
        default:
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
            tbDebugOut(( DEB_ITRACE,
                         "Unexpected dest storage type %4x\n"
                         "\tsource storage type %4x\n",
                         vtDst, vt));
            break;
        }
    }

    if (DstStatus == DBSTATUS_E_CANTCONVERTVALUE)
        rcbDstLen = 0;

    Win4Assert( rcbDstLen < 0x01000000 );
    return DstStatus;
} //CopyOrCoerce

//+-------------------------------------------------------------------------
//
//  Member:     CTableVariant::Free, public, static
//
//  Synopsis:   Frees data associated with a variant or a variant type
//
//  Arguments:  [pbData]      -- pointer to area to be freed
//              [vtData]      -- VARTYPE of the data
//              [rPool]       -- pool to free from if necessary
//
//  History:    18 Jan 1995     dlee    Created
//
//--------------------------------------------------------------------------

void CTableVariant::Free(
                        BYTE *            pbData,
                        VARTYPE           vtData,
                        PVarAllocator &   rPool)
{
    switch ( vtData )
    {
    case DBTYPE_BYREF|DBTYPE_PROPVARIANT:
        Win4Assert( !"DBTYPE_BYREF|DBTYPE_PROPVARIANT free" );
        {
            CTableVariant *pvar = *((CTableVariant **) pbData);
            Free( (BYTE *) & ( pvar->lVal ), pvar->vt, rPool );
            break;
        }

    case VT_VARIANT :
        {
            CTableVariant *pvar = (CTableVariant *) pbData;
            Free( (BYTE *) & ( pvar->lVal ), pvar->vt, rPool );
            break;
        }

    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_I2:
    case VT_I4:
    case VT_I8:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
    case VT_UI8:
    case VT_INT:
    case VT_UINT:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_CY:
    case VT_DATE:
    case VT_DECIMAL:
    case VT_FILETIME:
    case VT_ERROR:
    case DBTYPE_WSTR:
    case DBTYPE_STR:
    case DBTYPE_HCHAPTER:
        break;

    case VT_BSTR:
        {
            BSTR * pBstr = (BSTR *) pbData;
            rPool.FreeBSTR( *pBstr );
            break;
        }

    case VT_LPWSTR:
    case VT_LPSTR:
    case DBTYPE_STR | DBTYPE_BYREF:
    case DBTYPE_WSTR | DBTYPE_BYREF:
    case VT_CLSID:
        {
            rPool.Free( * (LPWSTR *) pbData );
            break;
        }

    case VT_BLOB:
        {
            BLOB * p = (BLOB *) pbData;

            if ( 0 != p->cbSize )
                rPool.Free( p->pBlobData );
            break;
        }

    case (VT_VECTOR | VT_I1):
    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_UI2):
    case (VT_VECTOR | VT_UI4):
    case (VT_VECTOR | VT_UI8):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):
    case (VT_VECTOR | VT_FILETIME):
    case (VT_VECTOR | VT_CLSID):
        {
            CAUL * p = (CAUL *) pbData;

            tbDebugOut(( DEB_ITRACE, "calling free on vector type %x, # %x, pb %x\n",
                         vtData, p->cElems, p->pElems ));

            if ( 0 != p->cElems )
                rPool.Free( p->pElems );

            break;
        }

    case (VT_VECTOR | VT_LPSTR):
    case (VT_VECTOR | VT_LPWSTR):
    case (VT_VECTOR | DBTYPE_STR | DBTYPE_BYREF): // SPECDEVIATION vector/byref mutually exclusive
    case (VT_VECTOR | DBTYPE_WSTR | DBTYPE_BYREF):
        {
            CALPWSTR * p = (CALPWSTR *) pbData;
            if ( 0 != p->cElems )
            {
                for ( unsigned x = 0; x < p->cElems; x++ )
                    rPool.Free( p->pElems[ x ] );

                rPool.Free( p->pElems );
            }
            break;
        }

    case (VT_VECTOR | VT_BSTR):
        {
            CABSTR * p = (CABSTR *) pbData;
            if ( 0 != p->cElems )
            {
                for ( unsigned x = 0; x < p->cElems; x++ )
                    rPool.FreeBSTR( p->pElems[ x ] );

                rPool.Free( p->pElems );
            }
            break;
        }

    case (VT_VECTOR | VT_VARIANT):
        {
            CAPROPVARIANT * p = (CAPROPVARIANT *) pbData;

            if ( 0 != p->cElems )
            {
                for ( unsigned x = 0; x < p->cElems; x++ )
                    Free( (BYTE *) & (p->pElems[ x ]), VT_VARIANT, rPool );

                rPool.Free( p->pElems );
            }
            break;
        }

    case VT_ARRAY|VT_I1:
    case VT_ARRAY|VT_I2:
    case VT_ARRAY|VT_I4:
    case VT_ARRAY|VT_I8:
    case VT_ARRAY|VT_UI1:
    case VT_ARRAY|VT_UI2:
    case VT_ARRAY|VT_UI4:
    case VT_ARRAY|VT_UI8:
    case VT_ARRAY|VT_INT:
    case VT_ARRAY|VT_UINT:
    case VT_ARRAY|VT_R4:
    case VT_ARRAY|VT_R8:
    case VT_ARRAY|VT_BOOL:
    case VT_ARRAY|VT_CY:
    case VT_ARRAY|VT_DATE:
    case VT_ARRAY|VT_DECIMAL:
        {
            SAFEARRAY * p = *(SAFEARRAY **)pbData;

            tbDebugOut(( DEB_ITRACE, "calling free on array type %x, # %x, pb %x\n",
                         vtData, p, p->pvData ));

            rPool.Free( p->pvData );
            rPool.Free( p );

            break;
        }

    case VT_ARRAY|VT_BSTR:
        {
            SAFEARRAY * p = *(SAFEARRAY **)pbData;

            tbDebugOut(( DEB_ITRACE, "calling free on array type %x, # %x, pb %x\n",
                         vtData, p, p->pvData ));

            ULONG cElements = SaCountElements(*p);
            BSTR *apBstr = (BSTR *)p->pvData;

            for (unsigned x = 0; x < cElements; x++)
            {
                rPool.FreeBSTR( apBstr[ x ] );
            }

            rPool.Free( apBstr );
            rPool.Free( p );

            break;
        }

    case VT_ARRAY|VT_VARIANT:
        {
            SAFEARRAY * p = *(SAFEARRAY **)pbData;

            tbDebugOut(( DEB_ITRACE, "calling free on array type %x, # %x, pb %x\n",
                         vtData, p, p->pvData ));

            ULONG cElements = SaCountElements(*p);
            VARIANT *apVarnt = (VARIANT *)p->pvData;

            for (unsigned x = 0; x < cElements; x++)
            {
                Free( (BYTE *) & (apVarnt[ x ]), VT_VARIANT, rPool );
            }

            rPool.Free( apVarnt );
            rPool.Free( p );

            break;
        }


    case VT_CF:
        {
            CLIPDATA * * ppClipData = (CLIPDATA **) pbData;
            if ( 0 != ppClipData )
            {
                rPool.Free( (*ppClipData)->pClipData );
                rPool.Free( *ppClipData );
            }
            break;
        }

    case (VT_VECTOR | VT_CF):
        {
            CACLIPDATA * p = (CACLIPDATA *) pbData;

            if ( 0 != p )
            {
                for ( ULONG i = 0; i < p->cElems; i++ )
                    rPool.Free( p->pElems[i].pClipData );
                rPool.Free( p->pElems );
            }
            break;
        }

    default:
        {
            tbDebugOut(( DEB_WARN, "tblvarnt free of unknown type %x\n",
                         vtData ));
            break;
        }
    }
} //Free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tblbuket.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       tblbuket.cxx
//
//  Contents:   Implementation of the bucket in large table.
//
//  Classes:    CTableBucket
//              CBucketRowIter
//              CBucketRowCompare
//
//  History:    2-14-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <query.hxx>
#include <objcur.hxx>

#include "tblbuket.hxx"
#include "tabledbg.hxx"
#include "tblwindo.hxx"
#include "colcompr.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CTableBucket constructor
//
//  Arguments:  [pSortSet]     -  Pointer to the sort set.
//              [masterColSet] -  Reference tot he master column set.
//              [segId]        -  Segment Id of the this segment
//
//  History:    2-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


CTableBucket::CTableBucket( CSortSet const & sortSet,
                            CTableKeyCompare & comparator,
                            CColumnMasterSet & masterColSet,
                            ULONG segId )
    : CTableSegment( CTableSegment::eBucket, segId, sortSet, comparator ),
      _minWid(0), _maxWid(0),
      _fSorted(TRUE),
      _widArray( CTableSegment::cBucketRowLimit+20 )
      ,_pLargeTable(0)
{
     _fStoreRank = ( 0 != masterColSet.Find( pidRank ) );
     _fStoreHitCount = ( 0 != masterColSet.Find( pidHitCount ) );

    CColumnMasterDesc * pDesc = masterColSet.Find(pidPath);
    _pPathCompressor =   pDesc ? pDesc->GetCompressor() : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   PutRow
//
//  Synopsis:   Add/Replaces a row in the bucket
//
//  Arguments:  [obj]      - Reference to the retriever for the row
//              [eRowType] - Type of the row.
//
//  Returns:    FALSE always (why?)
//
//  History:    2-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableBucket::PutRow( CRetriever & obj, CTableRowKey & currKey )
{
    WORKID wid = obj.WorkId();

    PROPVARIANT vRank;
    if ( _fStoreRank )
    {
        ULONG cbRank = sizeof vRank;
        obj.GetPropertyValue( pidRank, &vRank, &cbRank );
        Win4Assert( VT_I4 == vRank.vt );
    }

    PROPVARIANT vHitCount;
    if ( _fStoreHitCount )
    {
        ULONG cbHitCount = sizeof vHitCount;
        obj.GetPropertyValue( pidHitCount, &vHitCount, &cbHitCount );
        Win4Assert( VT_I4 == vHitCount.vt );
    }

    BOOL fNew = _AddWorkId( wid, vRank.lVal, vHitCount.lVal );

    // Update Low and High Keys

    currKey.MakeReady();

    if ( _comparator.Compare( currKey, _lowKey ) < 0 )
        _lowKey = currKey;

    int iCmp = _comparator.Compare( currKey, _highKey );
    if ( iCmp > 0 )
        _highKey = currKey;
    else if ( iCmp < 0 )
        _fSorted = FALSE;

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   _AddWorkId
//
//  Synopsis:   Add/Replace the given workid to the table. It appends the
//              new workid to the end of the widArray and updates the
//              hash table.
//
//  Arguments:  [wid]        - The wid to be added.
//              [lRank]      - Rank for the hit
//              [lHitCount]  - HitCount for the hit
//
//  Returns:    TRUE  if this is a brand new wid.
//              FALSE if the wid already existed.
//
//  History:    2-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableBucket::_AddWorkId(
    WORKID wid,
    LONG   lRank,
    LONG   lHitCount )
{
    if ( 0 == _hTable.Count() )
    {
        _minWid = _maxWid = wid;
    }
    else if ( wid < _minWid )
    {
        _minWid = wid;
    }
    else if ( wid > _maxWid )
    {
        _maxWid = wid;
    }

    CWidValueHashEntry  entry( wid );

    BOOL fFound = _hTable.LookUpWorkId( entry );
    if ( !fFound )
    {
        //
        // The wid doesn't already exist. We have to append it to
        // the end of the wid array
        //
        unsigned pos = _widArray.Count();
        _widArray.Add( wid, pos );
        entry.SetValue( pos );

        if ( _fStoreRank )
            _aRank[ pos ] = lRank;

        if ( _fStoreHitCount )
            _aHitCount[ pos ] = lHitCount;

        //
        // Add the workid to the hash table.
        //
        _hTable.AddEntry( entry );
    }
    else
    {
        Win4Assert( entry.Value() < _widArray.Size() );
        Win4Assert( _widArray.Get( entry.Value() ) == wid );
    }

    return !fFound;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveRow
//
//  Synopsis:   Removes the specified row (if present) from the table.
//
//  Arguments:  [varUnique] - The row to be removed
//
//  History:    2-17-95   srikants   Created
//
//  Notes: NEWFEATURE/BROKENCODE: vikasman - _highKey & _lowKey not being
//         updated here !!  But we don't expect RemoveRow to be called
//
//----------------------------------------------------------------------------

BOOL CTableBucket::RemoveRow(
    PROPVARIANT const & varUnique,
    WORKID &        widNext,
    CI_TBL_CHAPT & chapt )
{
    widNext = widInvalid; // until categorization supports buckets
    chapt = chaptInvalid;

    Win4Assert(varUnique.vt == VT_I4);

    WORKID wid = (WORKID) varUnique.lVal;

    CWidValueHashEntry  entry( wid );

    BOOL fFound = _hTable.LookUpWorkId( entry );
    if ( fFound )
    {
        Win4Assert( entry.Value() < _widArray.Size() );
        Win4Assert( _widArray.Get( entry.Value() ) == wid );

        //
        // Set the value to widInvalid in the widArray.
        //
        _widArray.Get( entry.Value() ) = widDeleted;
        _hTable.DeleteWorkId( wid );

        //
        // While deletions don't really destroy the sort order, the
        // widArray will no longer have workids in order because we don't
        // compact the widarray on deletions. Compaction is memory intensive
        // as well we have to fix the hash table.
        //
        _fSorted = FALSE;
    }

    return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   SortOrder
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    2-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSortSet const & CTableBucket::SortOrder()
{
    Win4Assert( !"Must not be called" );
    return *((CSortSet *) 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsGettingFull
//
//  Synopsis:   Checks if the bucket is getting too full.
//
//  Returns:    TRUE if getting full. FALSE o/w
//
//  History:    3-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableBucket::IsGettingFull()
{
    return _hTable.Count() >= CTableSink::cBucketRowLimit;
}

//+---------------------------------------------------------------------------
//
//  Function:   WorkIdAtOffset
//
//  Synopsis:   Returns the workid at the specified offset, if one can
//              be found. windInvalid o/w
//
//  Arguments:  [offset] - The offset at which the wid is needed.
//
//  Returns:    If the bucket is sorted and the offset is within the
//              limits of the bucket, it will be the workid at that offset.
//              O/W, it will be widInvalid.
//
//  History:    3-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WORKID CTableBucket::WorkIdAtOffset( ULONG offset ) const
{

    WORKID wid = widInvalid;

    if ( IsSorted() && ( offset < _widArray.Count() ))
    {
        wid = _widArray.Get(offset);
    }

    return wid;
}

//+---------------------------------------------------------------------------
//
//  Function:   RowOffset
//
//  Synopsis:   Gives the row offset of the workid, if possible.
//
//  Arguments:  [wid]     -  The workid to look up.
//              [rOffset] -  On output, it will have the offset of the
//              row.
//
//  Returns:    TRUE if the wid could be located and the bucket is sorted.
//              FALSE o/w
//
//  History:    3-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableBucket::RowOffset( WORKID wid, ULONG & rOffset )
{
    BOOL fRet = FALSE;
    if ( _fSorted )
    {
        CWidValueHashEntry  entry( wid );

        if ( _hTable.LookUpWorkId( entry ) )
        {
            fRet = TRUE;
            rOffset = entry.Value();
            Win4Assert( _widArray.Get( rOffset ) == wid );
        }
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   WorkIdToPath
//
//  Synopsis:   Used in downlevel for bucket->window conversion. Given a
//              workid, it returns the path associated with the wid.
//
//  Arguments:  [wid]      -  The wid to convert to a path.
//              [outVarnt] -  The variant that will contain the path.
//              [cbVarnt]  -  Length of the variant
//
//  Returns:    TRUE if successfully retrieved.
//              FALSE o/w
//
//  History:    3-29-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableBucket::WorkIdToPath( WORKID wid,
                                 CInlineVariant & outVarnt, ULONG & cbVarnt )
{

    Win4Assert( 0 != _pLargeTable );
    Win4Assert( 0 != _pPathCompressor );

    CLock   lock( _pLargeTable->GetMutex() );

    CTableVariant pathVarnt;
    XCompressFreeVariant xpvarnt;

    BOOL fStatus = FALSE;

    if ( GVRSuccess ==
         _pPathCompressor->GetData( &pathVarnt, VT_LPWSTR, wid, pidPath ) )
    {
        xpvarnt.Set( _pPathCompressor, &pathVarnt );

        //
        // Copy the data from the variant to the buffer.
        //
        const ULONG cbHeader  = sizeof(CInlineVariant);
        ULONG cbVarData = pathVarnt.VarDataSize();
        ULONG cbTotal   = cbVarData + cbHeader;

        if ( cbVarnt >= cbTotal )
        {
            CVarBufferAllocator bufAlloc( outVarnt.GetVarBuffer(), cbVarData );
            bufAlloc.SetBase(0);
            pathVarnt.Copy( &outVarnt, bufAlloc, (USHORT) cbVarData, 0 );
            fStatus = TRUE;
        }

        cbVarnt = cbTotal;
    }

    return fStatus;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Function:   _CheckIfTooBig
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    4-14-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableBucket::_CheckIfTooBig()
{
    if ( _hTable.Count() > CTableSink::cBucketRowLimit )
    {
        tbDebugOut(( DEB_ERROR,
            "Bucket 0x%X is getting too full 0x%X Rows. Still adding. \n",
            GetSegId(), _hTable.Count() ));
    }
}
#endif  // DBG==1

//+---------------------------------------------------------------------------
//
//  Function:   WorkId
//
//  Synopsis:   Returns the current workid in the retriever.
//
//  History:    3-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WORKID CBucketRowIter::WorkId()
{
    WORKID wid = widInvalid;

    //
    // Skip over the deleted wids
    //
    while ( !_AtEnd() && ( (wid=_Get()) == widDeleted ) )
        _Next();

    if ( !_AtEnd() )
    {
        Win4Assert( widInvalid != wid );

        if ( _fRetrievePath )
        {
            _pwszPath[0] = 0;
            _cwcCurrPath = 1;

            ULONG cbVarnt = cbPathVarnt;
            BOOL fStatus = _bucket.WorkIdToPath( wid, _pathVarnt, cbVarnt );
            Win4Assert( fStatus );
            Win4Assert( cbVarnt >= sizeof(CTableVariant) );
            _cwcCurrPath = (cbVarnt-sizeof(CTableVariant))/sizeof(WCHAR);
        }

        return wid;
    }
    else
    {
        return widInvalid;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NextWorkId
//
//  Synopsis:   Positions to the next workid in the iterator
//
//  Returns:    The next work id.
//
//  History:    3-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WORKID CBucketRowIter::NextWorkId()
{
    Win4Assert ( !_AtEnd() );
    _Next();
    return WorkId();
}

//+---------------------------------------------------------------------------
//
//  Function:   Path
//
//  Synopsis:   Retrieves the path of the current wid.
//
//  History:    3-29-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR const * CBucketRowIter::Path()
{
    return _pwszPath;
}

//+---------------------------------------------------------------------------
//
//  Function:   PathSize
//
//  Synopsis:   Returns the size of the path in bytes excluding the
//              null termination
//
//  Returns:    The size of the path in BYTES WITHOUT the null termination
//
//  History:    3-29-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

unsigned CBucketRowIter::PathSize()
{

    Win4Assert( _cwcCurrPath > 0 );
    //
    // Don't include the trailing zero
    //
    return (_cwcCurrPath-1)*sizeof(WCHAR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tbrowkey.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       tbrowkey.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <objcur.hxx>
#include <tableseg.hxx>

CTableRowKey::CTableRowKey( CSortSet const & sortSet )
    : _cCols(sortSet.Count()), _sortSet(sortSet),
      _acbVariants( _cCols ), _apVariants( _cCols )
{
    Win4Assert( sizeof(CInlineVariant) == sizeof(CTableVariant) );

    for ( unsigned i = 0; i < _cCols; i++ )
    {
        _acbVariants[i] = 0;
        _apVariants[i] = 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey  ~dtor
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------

CTableRowKey::~CTableRowKey()
{
    for ( unsigned i = 0; i < _cCols; i++ )
        delete [] (BYTE *) _apVariants[i];
}


//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey::ReAlloc
//
//  Synopsis:   Reallocates memory for the indicated column. Note that
//              the old contents may be tossed out.
//
//  Arguments:  [i]  -  The column for which reallocation is needed.
//              [vt] -  Variant type of the variant
//              [cb] -  Number of bytes needed for the variant.
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------

void CTableRowKey::ReAlloc( unsigned i, VARTYPE vt, unsigned cb )
{
    Win4Assert( i < _cCols );

    const ULONG cbHeader  = sizeof(CInlineVariant);
    ULONG cbTotal   = cb;
    Win4Assert( cbTotal >= cbHeader );

    if ( _acbVariants[i] < cbTotal )
    {
        delete [] (BYTE *) _apVariants[i];
        _apVariants[i]  = 0;
        _acbVariants[i] = 0;

        ULONG cbToAlloc = cbTotal;

        _apVariants[i] = (CInlineVariant *) new BYTE [cbToAlloc];
        _acbVariants[i] = cbToAlloc;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey::Init
//
//  Synopsis:   Initialized the column "i" with the source variant.
//
//  Arguments:  [i]         -  Column to be initialized.
//              [src]       -  Source variant
//              [pbSrcBias] -  Bais of the data allocation in the source
//              variant.
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------


void CTableRowKey::Init( unsigned i, CTableVariant & src, BYTE * pbSrcBias  )
{
    Win4Assert( i < _cCols );

    const ULONG cbHeader  = sizeof(CInlineVariant);
    ULONG cbVarData = src.VarDataSize();
    ULONG cbTotal   = cbVarData + cbHeader;

    if ( _acbVariants[i] < cbTotal )
        ReAlloc( i, src.vt, cbTotal );

    Win4Assert( _acbVariants[i] >= cbTotal );
    Win4Assert( _acbVariants[i]-cbHeader >= cbVarData );

    CVarBufferAllocator bufAlloc( _apVariants[i]->GetVarBuffer(), cbVarData );
    bufAlloc.SetBase(0);

    src.Copy( _apVariants[i], bufAlloc, (USHORT) cbVarData, pbSrcBias );
}

//+---------------------------------------------------------------------------
//
//  Function:   assignemnt operator
//
//  Synopsis:   Copies the contents of the source bucket row into this.
//
//  Arguments:  [src] - The source bucket row.
//
//  Returns:    A reference to this bucket row.
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------


CTableRowKey & CTableRowKey::operator=( CTableRowKey & src )
{
    Win4Assert( src._cCols == _cCols );

    for ( unsigned i = 0; i < _cCols; i++ )
        Init( i, *(src._apVariants[i]) );

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey::PreSet
//
//  Synopsis:   Get ready for use later.
//
//  Arguments:  [pObj]         - value retriever for the object
//              [pInfoSortKey] - sort info
//
//  History:    8-20-98   dlee Created
//
//----------------------------------------------------------------------------

void CTableRowKey::PreSet(
    CRetriever * pObj,
    XArray<VARTYPE> * pInfoSortKey )
{
    _pObj = pObj;
    _pVarType = pInfoSortKey;
} //PreSet

//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey::MakeReady
//
//  Synopsis:   Retrieves the sort key values
//
//  History:    8-20-98   dlee Created
//
//----------------------------------------------------------------------------

void CTableRowKey::MakeReady()
{
    Set( *_pObj, *_pVarType );
} //MakeReady

//+---------------------------------------------------------------------------
//
//  Method:     CTableRowKey::Set
//
//  Synopsis:   Given a "row" and the "obj" for a row, it
//              fills the "row" with the data from the "obj". It retrieves
//              only the columns in the sort key.
//
//  Arguments:  [row] - The row to fill
//              [obj] - Retriever for the columns.
//
//  History:    2-15-95   srikants   Created
//
//----------------------------------------------------------------------------

void CTableRowKey::Set( CRetriever & obj, XArray<VARTYPE> & vtInfoSortKey )
{
    Win4Assert( _sortSet.Count() == _cCols );

    for ( ULONG i = 0; i < _cCols; i++ )
    {
        SSortKey & key = _sortSet.Get(i);
        PROPID pid = key.pidColumn;

        ULONG cbVarnt;
        CTableVariant * pvarnt = Get(i, cbVarnt);
        GetValueResult eGvr;
        VARTYPE vt = vtInfoSortKey.Get()[i];

        if ( 0 == pvarnt )
        {
            //
            // This is the first time we are setting the value of this
            // variant. Determine its type and allocate the optimum amount
            // of memory.
            //
            CTableVariant   varnt;
            cbVarnt = sizeof(varnt);
            pvarnt = &varnt;
            eGvr = obj.GetPropertyValue( pid, pvarnt, &cbVarnt );
            if ( GVRSuccess != eGvr &&
                 GVRNotEnoughSpace != eGvr &&
                 GVRSharingViolation != eGvr )
            {
                if ( eGvr == GVRNotSupported || eGvr == GVRNotAvailable )
                {
                    THROW( CException( QUERY_E_INVALIDSORT ) );
                }
                else
                {
                    THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
                }
            }

            if ( ( GVRSharingViolation == eGvr ) ||
                 ( 0 == cbVarnt ) )
                cbVarnt = sizeof varnt;

            ReAlloc( i, vt, cbVarnt );
            pvarnt = Get( i, cbVarnt );
        }

        Win4Assert( 0 != pvarnt );
        eGvr = obj.GetPropertyValue( pid, pvarnt, &cbVarnt );

        if ( GVRNotEnoughSpace == eGvr )
        {
            //
            // This path should be executed very rarely because for strings
            // we over-allocate the memory and for "fixed" length variants
            // the correct length must have been allocated the first time.
            //
            ReAlloc( i, vt, cbVarnt );
            pvarnt = Get( i, cbVarnt );
            eGvr = obj.GetPropertyValue( pid, pvarnt, &cbVarnt );
        }

        if ( GVRSharingViolation == eGvr )
            pvarnt->vt = VT_EMPTY;
        else if ( GVRSuccess != eGvr )
            THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
    }
} //Set
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tputget.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       tputget.cxx
//
//  Contents:   Classes to put, get and locate rows in the bigtable.
//
//  Classes:    CTableRowPutter, CTableRowGetter, CTableRowLocator
//
//  Functions:
//
//  History:    4-17-95   srikants   Created
//
//----------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include "tputget.hxx"
#include "tblwindo.hxx"
#include "tblbuket.hxx"
#include "winsplit.hxx"
#include "tabledbg.hxx"
#include "query.hxx"
#include "regtrans.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   _LokShouldUseNext
//
//  Synopsis:   Tests whether the segment should be use for a putrow.
//
//  Arguments:  [icmp]   -- compare result of current row to first of pSeg
//              [pSeg]   -- the segment in question
//
//  Returns:    TRUE if new row is in same category as the first row in
//              [pSeg] and if the first row in [pSeg] is the first of its
//              category.
//
//  History:    11-7-95   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CTableRowPutter::_LokShouldUseNext(
    int icmp,
    CTableSegment * pSeg )
{
    Win4Assert( _largeTable.IsCategorized() );

    CTableWindow *pWin = (CTableWindow *) pSeg;

    return ( ( ( (unsigned) (- icmp ) ) > _largeTable._cCategorizersTotal ) &&
             ( pWin->IsFirstRowFirstOfCategory() ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   _IsHintGood
//
//  Synopsis:   Tests whether the segment passed in as a hint or one of
//              its immediate neighbors can be used to insert the new row.
//
//  Arguments:  [pSegHint] -  The input segment which is the hint.
//
//  Returns:    Pointer to either the hint or one of its neighbors if the
//              row can be inserted into them. NULL if the hint is not good.
//
//  History:    4-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableSegment * CTableRowPutter::_IsHintGood( CTableSegment * pSegHint )
{
    if ( 0 == pSegHint )
        return 0;

    CTableSegment * pResult = 0;

    Win4Assert( pSegHint->GetLowestKey().IsInitialized() );

    int icmp = _comparator.Compare( _currRow, pSegHint->GetLowestKey() );

    if ( icmp >= 0 )
    {
        //
        // The current key is >= the lowest key in the hint. See if this is
        // less than the key in the next segment.
        //
        if ( _segList.GetLast() != pSegHint )
        {
            CTableSegment * pNext = _segList.GetNext( pSegHint );

            int icmpNext = _comparator.Compare( _currRow,
                                                pNext->GetLowestKey() );

            if ( icmpNext < 0 )
            {
                // If categorized AND
                //    new row in same category as first row of next window AND
                //    first row of next window is first of its category
                // use the next window.  Otherwise use the current window.
                //

                if ( ( _largeTable.IsCategorized() ) &&
                     ( _LokShouldUseNext( icmpNext, pNext ) ) )
                {
                    tbDebugOut(( DEB_ITRACE, "updated hint window for categorized putrow\n" ));
                    pResult = pNext;
                }
                else
                {
                    //
                    // The current row is < the lowest key in the next segment.
                    // It is also not in the same category as the lowest key
                    // in the next segment.
                    // So, it is a good candidate.
                    //
                    pResult = pSegHint;
                }
            }
        }
        else
        {
            pResult = pSegHint;
        }
    }
    else if ( _segList.GetFirst() == pSegHint )
    {
        //
        // We are at the first segment and the current row is < the first
        // segment. So, just use it.
        //
        pResult = pSegHint;
    }

    return pResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokFindSegToInsert
//
//  Synopsis:   Finds the segment to insert the current row.
//
//  Arguments:  [pSegHint] - Segment used as a hint.
//
//  Returns:    The segment into which the row must be inserted.
//
//  History:    4-17-95   srikants   Created
//
//----------------------------------------------------------------------------

CTableSegment * CTableRowPutter::LokFindSegToInsert( CTableSegment * pSegHint )
{
    //
    // For the most common case, there will be only one segment. Just use
    // that and don't setup _currRow.
    //

    if ( 1 == _segList.GetSegmentsCount() )
    {
        Win4Assert( 0 == pSegHint || _segList.GetFirst() == pSegHint );
        return _segList.GetFirst();
    }

    //
    // Initialize the sort key and use that to compare with various segments.
    //

    _currRow.MakeReady();

    if ( _segList.IsEmpty() )
    {
        CTableWindow * pWindow = _largeTable._CreateNewWindow(
                                                _largeTable._AllocSegId(),
                                                _currRow,
                                                _currRow);
        _segListMgr.Push( pWindow );
        tbDebugOut(( DEB_WINSPLIT,
            " Adding Window 0x%X to an empty list\n", pWindow ));

        return pWindow;
    }

    Win4Assert( 0 != _largeTable.GetSortSet() );

    //
    // See if the hint is usable.
    //
    CTableSegment * pSeg = _IsHintGood( pSegHint );

    if ( 0 == pSeg )
    {
        //
        // Either there was no hint or the row did not belong there.
        //
        pSeg = _segListMgr.GetSegmentArray().LookUp( _currRow );

        if ( ( _largeTable.IsCategorized() ) &&
             ( _segList.GetLast() != pSeg ) )
        {
            // Pick a window so that the unique categorizer can make the
            // assumption that:
            //   - an insert at the end of a window either belongs to the
            //     same category as the previous last row OR is a new
            //     category
            //   - an insert at the beginning of a window is the new first
            //     member of the category of the first row in the window

            CTableSegment * pNext = _segList.GetNext( pSeg );

            int icmpNext = _comparator.Compare( _currRow,
                                                pNext->GetLowestKey() );

            Win4Assert( icmpNext < 0 );

            if ( _LokShouldUseNext( icmpNext, pNext ) )
            {
                tbDebugOut(( DEB_ITRACE, "updated window for categorized putrow\n" ));
                pSeg = pNext;
            }
        }

        // This assert will not be true when a row is the new first row
        // of both a segment and a category.

        if ( ! _largeTable.IsCategorized() )
        {
            Win4Assert( _IsHintGood(pSeg) == pSeg );
        }

#if 0

        CBackTableSegIter   iter(_segList);
        Win4Assert( !_segList.AtEnd(iter) );

        do
        {
            CTableSegment & segment = *iter.GetSegment();
            Win4Assert( segment.GetLowestKey().IsInitialized() );

            if ( _comparator.Compare(_currRow, segment.GetLowestKey()) >= 0 )
            {
                //
                // The current row is >= the lowest key in this segment. We
                // can use it.
                //
                break;
            }
            else
            {
                _segList.BackUp(iter);
            }
        }
        while ( !_segList.AtEnd(iter) );

        if ( _segList.AtEnd(iter) )
        {
            //
            // We have gone past the end of the list. Just use the
            // first one.
            //
            pSeg = _segList.GetFirst();
            Win4Assert( _comparator.Compare( _currRow,
                                             pSeg->GetLowestKey() ) < 0 );
        }
        else
        {
            pSeg = iter.GetSegment();
            Win4Assert( _comparator.Compare( _currRow,
                                             pSeg->GetLowestKey() ) >= 0  );
        }
#endif  // 0

    }

    Win4Assert( 0 != pSeg );

    Win4Assert( pSeg->GetLowestKey().IsInitialized() );

    return pSeg;


}

//+---------------------------------------------------------------------------
//
//  Function:   LokSplitOrAddSegment
//
//  Synopsis:   When a segment gets too full, it needs to be either split
//              or a new one added, if possible.
//
//              A segment can be split if it is a window and the window
//              contents permit a sorted split.
//
//              If the segment is a window but either there is no sort set
//              or all rows in it are equal, then we have to either append
//              or insert a new segment before the current one.
//
//              If the segment is bucket, then a new segment can either be
//              inserted or appended only if the current row falls outside
//              the range of the rows of the bucket.
//
//  Arguments:  [pSegToSplit] - The segment which we should check to split
//                              or insert/append to.
//
//  Returns:    The segment into which the row must be inserted.
//
//  History:    4-17-95   srikants   Created
//
//----------------------------------------------------------------------------

CTableSegment * CTableRowPutter::LokSplitOrAddSegment( CTableSegment * pSegToSplit )
{
    Win4Assert( 0 != pSegToSplit );
    Win4Assert( !_fNewWindowCreated );

    _currRow.MakeReady();

    CTableSegment * pSegment = pSegToSplit;

    Win4Assert( pSegment->IsGettingFull() );

    if ( pSegment->IsWindow() )
    {
        ULONG iSplit;

        BOOL fSortedSplit =  pSegment->IsSortedSplit(iSplit);

        Win4Assert( fSortedSplit && "Unsorted window is not legal" );

        CTableWindow * pWindow = (CTableWindow *) pSegment;
        //
        // This window will permit a sorted split.
        //
        pSegment = _largeTable._LokSplitWindow( &pWindow, iSplit );
        pSegment = LokFindSegToInsert( pSegment );

        _fNewWindowCreated = TRUE;
    }
    else
    {

        Win4Assert( pSegment->IsBucket() );

        //
        // The segment is a bucket. The row we have must be bigger than
        // the smallest in the bucket.
        //
        Win4Assert( _comparator.Compare( _currRow,
                                         pSegment->GetLowestKey() ) >= 0 );
        //
        // A new window can be added only if the current row is bigger than
        // the biggest row in the bucket.
        //
        CTableBucket * pBucket = (CTableBucket *) pSegment;

        if ( _comparator.Compare( _currRow, pBucket->GetHighestKey() ) > 0 )
        {

            //
            // It is either an un-sorted set or a sorted set will all
            // the rows in that window being equal.
            //
            CTableSegment * pNewSeg = _largeTable._CreateNewWindow(
                                         _largeTable._AllocSegId(),
                                         _currRow,
                                         _currRow );

            _fNewWindowCreated = TRUE;

            _segListMgr.InsertAfter( pSegment, pNewSeg );

            pSegment = pNewSeg;
        }
    }

    return pSegment;
}


CTableRowGetter::CTableRowGetter( CLargeTable & largeTable,
                   CTableColumnSet const & outColumns,
                   CGetRowsParams & getParams,
                   CI_TBL_CHAPT chapt,
                   HWATCHREGION hRegion)
:
    _largeTable(largeTable),
    _segListMgr(largeTable._GetSegListMgr()),
    _segList(_segListMgr.GetList()),
    _outColumns(outColumns),
    _getParams(getParams),
    _hRegion(hRegion),
    _pBucketToExpand(0),
    _widLastTransferred(widInvalid),
    _chapt(chapt),
    _cRowsToTransfer(_getParams.RowsToTransfer())
{

}

void CTableRowGetter::SetRowsToTransfer( ULONG cRowsToTransfer )
{
    Win4Assert( cRowsToTransfer <= _getParams.RowsToTransfer() );
    _cRowsToTransfer = cRowsToTransfer;
}

//+---------------------------------------------------------------------------
//
//  Function:   _GetRowsFromWindow
//
//  Synopsis:
//
//  Arguments:  [iter] -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-13-95   srikants   Split from GetRowsAtSegment to make it
//                                   more modular
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CTableRowGetter::_GetRowsFromWindow( CDoubleTableSegIter & iter )
{

    Win4Assert( iter.GetSegment()->IsWindow() );

    CTableWindow * pWindow = iter.GetWindow();
    //
    // Real work done here!
    //
    _status = pWindow->GetRows( _hRegion,
                               _widStart,
                               _chapt,
                               _cRowsToTransfer,
                               _outColumns,
                               _getParams,
                               _widLastTransferred );

    if ( _getParams.GetFwdFetch() )
        _segList.Advance(iter);
    else
        _segList.BackUp(iter);

    BOOL fContinue = TRUE;

    if ( _status != DB_S_ENDOFROWSET && _status != S_OK )
    {
        fContinue = FALSE;

        if (_fAsync && _hRegion != 0 && _status == DB_S_BLOCKLIMITEDROWS)
        {
            //
            // NEWFEATURE - Finish extending the region
            //

        }
    }
    else if ( _segList.AtEnd(iter) ||
              0 == _cRowsToTransfer )
    {
        //
        // Add the last workid retrieved to the MRU list of
        // wids.
        //
        ULONG endOffset;
        if ( pWindow->RowOffset( _widLastTransferred, endOffset ) )
        {
            _segListMgr.SetInUseByClient( _widLastTransferred,
                                          pWindow );
        }

        //
        // If transfer is complete, don't return DB_S_ENDOFROWSET
        //
        if (  0 == _cRowsToTransfer )
            _status = S_OK;

        fContinue = FALSE;
    }
    else
    {
        //
        // Retrieve rows from the next/prev segment.
        //

        if ( _getParams.GetFwdFetch() )
            _widStart = WORKID_TBLFIRST;
        else
            _widStart = WORKID_TBLLAST;
    }

    return fContinue;
}

//+---------------------------------------------------------------------------
//
//  Function:   _ProcessBucket
//
//  Synopsis:
//
//  Arguments:  [iter]          -
//              [xBktsToExpand] -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-13-95   srikants   Split from GetRowsAtSegment to make it
//                                   more modular
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CTableRowGetter::_ProcessBucket( CDoubleTableSegIter & iter,
                                 XPtr<CTableBucket> & xBktToExplode )
{
    CTableSegment * pSegment = iter.GetSegment();
    Win4Assert( pSegment->IsBucket() );
    Win4Assert( 0 == xBktToExplode.GetPointer() );

    BOOL fContinue = TRUE;

    if (!_fAsync)
    {
        //
        // Current segment is a bucket. It must be expanded before
        // we can continue to retrieve rows.
        //
        Win4Assert( pSegment->IsBucket() );

        CTableBucket * pBktToExplode =
                    _largeTable._LokReplaceWithEmptyWindow( iter );

        xBktToExplode.Set( pBktToExplode );
        fContinue = FALSE;
        _status = DB_S_BLOCKLIMITEDROWS;
    }
    else
    {
        //
        // How did we end up with buckets in the fetch region. All buckets
        // in the fetch region should have been converted into windows and
        // scheduled for expansion. These windows cannot be converted into
        // buckets because they have watch regions on them.
        //

        Win4Assert( !"Found Buckets in the Fetch Region" );

        //
        // Just skip them ??
        //
        _segList.Advance( iter );

        fContinue = !_segList.AtEnd(iter);
    }

    return fContinue;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowGetter::LokGetRowsAtSegment
//
//  Synopsis:   Retrieves rows starting at the specified segment. It will
//              continue fetching until either all the requested rows are
//              returned or we are past the end of the list of segments or
//              we hit a bucket.
//
//  Arguments:  [pStartSeg] - The starting segment to use for retrieveing
//              rows.
//              [widStart]  - The starting workid in that segment.
//              [fAsync]   -  Explode buckets asynchronously
//              [xBktToExplode] - Safe pointer for the bucket to be exploded
//              (if any)
//
//  Returns:    Status of the operation.
//
//  History:    4-18-95   SrikantS   Created (Moved from CLargeTable)
//              6-28-95   BartoszM   Added watch region support
//              7-13-95   SrikantS   Enhanced for watch region support
//
//  Notes:      The watch region handle has been verified!
//
//----------------------------------------------------------------------------

SCODE CTableRowGetter::LokGetRowsAtSegment( CTableSegment * pStartSeg,
                                            WORKID widStart,
                                            BOOL fAsync,
                                            XPtr<CTableBucket> & xBktToExplode
                                          )
{
    _InitForGetRows( widStart, fAsync );

    if ( 0 == pStartSeg )
    {
        return DB_S_ENDOFROWSET;
    }
    else
    {
        Win4Assert( !_segList.IsEmpty() );
    }

    //
    // Skip over the nodes upto the segment passed.
    //
    for ( CFwdTableSegIter iter( _segList ); !_segList.AtEnd(iter);
          _segList.Advance(iter) )
    {
        if ( iter.GetSegment() == pStartSeg )
        {
            break;
        }
    }

    Win4Assert( !_segList.AtEnd(iter) );
    Win4Assert( iter.GetSegment() == pStartSeg );

    //
    //  Do the GetRows to a window, crossing segment boundaries as needed.
    //

    //
    // Add the starting wid to the "MRU" list of wid/segment pairs.
    //
    if ( !IsSpecialWid(widStart) && iter.GetSegment()->IsWindow() )
    {

#if DBG==1
        CTableWindow * pTemp = iter.GetWindow();
        ULONG startOffset;
        BOOL fFound = pTemp->RowOffset( widStart, startOffset );
        Win4Assert( fFound );
#endif  // DBG==1

       _segListMgr.SetInUseByClient( widStart, iter.GetSegment() );
    }

    BOOL fContinue = TRUE;

    do
    {
        CTableSegment * pSegment = iter.GetSegment();

        if (  pSegment->IsWindow() )
        {
            fContinue = _GetRowsFromWindow( iter );
        }
        else
        {
            fContinue = _ProcessBucket( iter, xBktToExplode );
        }
    }
    while (fContinue);

    return _status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLocator::LokLocate
//
//  Synopsis:   Locates the starting bookmark in the list of segments.
//
//  Arguments:  [hRegion]     -
//              [fAsync]      -
//              [iter]        -
//              [transformer] -
//
//  Returns:    Status of the operation.
//
//  History:    4-18-95   srikants   Created
//              6-29-95     BartoszM    Rewrote for notifications
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CTableRowLocator::LokLocate(  HWATCHREGION hRegion,
                                    BOOL fAsync,
                                    CDoubleTableSegIter& iter,
                                    CRegionTransformer& transformer )
{
    SCODE status = S_OK;

    if ( _segList.IsEmpty() )
    {

        if ( IsSpecialWid( _widStart ) )
        {
            _widFound = _widStart;
            return DB_S_ENDOFROWSET;
        }
        else
        {
            QUIETTHROW (CException( DB_E_BADSTARTPOSITION ));
        }
    }

    CTableSegment* pSegmentWatch = 0;

    if ( fAsync )
    {
        CWatchRegion *pRegion = transformer.Region();
        if (pRegion)
        {
            pSegmentWatch = pRegion->Segment();
            Win4Assert( 0 == pSegmentWatch || pSegmentWatch->IsWindow() );
        }
    }

    //
    // Do not modify the _widStart and _iRowOffset member variables here
    // as they are "input" values and must not be modified here. The client
    // of this class can modify them if needed.
    //
    WORKID widStart = _widStart;
    LONG iRowOffset = _iRowOffset;

    Win4Assert( WORKID_TBLBEFOREFIRST != widStart &&
                WORKID_TBLAFTERLAST != widStart );
    //
    // Locate either the segment in which the fetch bookmark is present
    // or the segment which is the beginning of the watch region -
    // whichever comes first in the segment list.
    //
    if (widStart != WORKID_TBLFIRST)
    {
        if (widStart == WORKID_TBLLAST)
        {
            //
            // PERFFIX - can we optimize by initializing the iterator with the
            // pSegmentWatch if it is not 0.
            //
            while ( !_segList.IsLast(iter) && iter.GetSegment() != pSegmentWatch)
            {
                _segList.Advance(iter);
            }
        }
        else
        {
            while ( !_segList.AtEnd(iter) && iter.GetSegment() != pSegmentWatch)
            {
                if ( iter.GetSegment()->IsRowInSegment(widStart) )
                {
                    tbDebugOut(( DEB_REGTRANS, "found wid %#x in segment %#x\n",
                                 widStart, iter.GetSegment() ));
                    break;
                }
                _segList.Advance(iter);
            }
        }
    }

    if (_segList.AtEnd(iter))
    {
        THROW (CException ( DB_E_BADBOOKMARK));
    }

    TBL_OFF obRow; // dummy
    ULONG iRowInSeg = 0;   // position of bookmark in current segment

    //
    // The iterator is positioned either at the beginning of the watch region
    // or at the segment that contains widStart
    //
    if (iter.GetSegment() == pSegmentWatch)
    {
        //
        // We are in the watch region
        //
        Win4Assert (0 != pSegmentWatch  && pSegmentWatch->IsWindow() );

        CTableWindow* pWindow = iter.GetWindow();

        transformer.SetWatchPos( pWindow->GetWatchStart(hRegion) );

        if ( pWindow->FindBookMark( widStart, obRow, iRowInSeg ))
        {
            //
            // both the watch and the starting wid are in the same window
            //
            transformer.SetFetchBmkPos (iRowInSeg);
        }
        else
        {
            DBROWCOUNT iFetch = 0;
            // skip segments to get to the starting bookmark
            do
            {
                iFetch += iter.GetSegment()->RowCount();
                _segList.Advance(iter);
                if (_segList.AtEnd(iter))
                {
                    //
                    // Bookmarks do become invalid.
                    // For instance it could have
                    // gone to an expanding bucket.
                    //
                    THROW (CException ( DB_E_BADBOOKMARK));
                }
            }
            while ( !iter.GetSegment()->IsRowInSegment(widStart));

            //
            // Is the starting bookmark in a bucket?
            //
            if (!iter.GetSegment()->IsWindow())
            {
                //
                // We hit a bucket. The bookmark became invisible
                // to the user. In the asynchronous world bookmarks
                // are not valid forever, buddy!
                //
                THROW (CException ( DB_E_BADBOOKMARK));
            }
            else
            {
                //
                // The starting bookmark is in a window.
                //
                pWindow = iter.GetWindow();
                pWindow->FindBookMark ( widStart, obRow, iRowInSeg );
                iFetch += iRowInSeg;
            }
            transformer.SetFetchBmkPos ( iFetch );
        }
    }
    else if ( 0 != hRegion )
    {
        //
        // Found widStart but not the watch region.
        // We now have to search for the watch region in the subsequent
        // segments.
        //

        if (!iter.GetSegment()->IsWindow())
        {
            //
            // We hit a bucket. The bookmark became invisible
            // to the user. In the asynchronous world bookmarks
            // are not valid forever, buddy!
            //
            THROW (CException ( DB_E_BADBOOKMARK));
        }
        else
        {
            CTableWindow* pWindow = iter.GetWindow ();
            ULONG iOffset, iRowInSeg;

            pWindow->FindBookMark ( widStart, obRow, iRowInSeg );

            //
            // iFetch is now the offset from the beginning of the bookmark
            // segment.
            //
            transformer.SetFetchBmkPos ( iRowInSeg );

            if ( 0 != pSegmentWatch )
            {
                DBROWCOUNT iWatch = 0;
                // Search for the beginning of watch region
                CDoubleTableSegIter iter2 (iter);
                do
                {
                    iWatch += iter2.GetSegment()->RowCount();
                    _segList.Advance (iter2);
                    Win4Assert (!_segList.AtEnd(iter2));

                } while (iter2.GetSegment() != pSegmentWatch);

                pWindow = iter2.GetWindow();
                iWatch += pWindow->GetWatchStart (hRegion);
                transformer.SetWatchPos (iWatch);
            }
        }
    }

    // CLEANCODE: Can we make this function void since it's throwing exceptions?
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLocator::LokRelocate
//
//  Synopsis:   Finds the start of the fetch region by counting the offset
//              from the start bookmark.
//
//  Arguments:  [fAsync]        -
//              [iter]          -
//              [transformer]   -
//              [xBktToExplode] -
//              [xBktToConvert] -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableRowLocator::LokRelocate( BOOL fAsync,
                                    CDoubleTableSegIter& iter,
                                    CRegionTransformer& transformer,
                                    XPtr<CTableBucket>&  xBktToExplode,
                                    CDynStack<CTableBucket>& xBktToConvert )
{

#if CIDBG==1
    tbDebugOut(( DEB_REGTRANS, "Before Relocating\n" ));
    transformer.DumpState();
#endif  // CIDBG

    //
    // 1. We have located the "anchor" bookmark. The iterator
    //    is positioned at that segment.
    //
    // 2. If there was a watch region, we have located the watch region
    //
    //
    //    Now, we have to locate the segment which
    //    is at the particular offset from the "anchor" bookmark.
    //

    if ( iter.GetSegment()->IsBucket() )
    {
        Win4Assert( !fAsync &&
                    "Must be synchronous when a bookmark is in a bucket" );
        CTableBucket * pBucket =
                    _largeTable._LokReplaceWithEmptyWindow( iter );
        xBktToExplode.Set( pBucket );
        return;
    }

    //
    // The first segment in the iterator is a window.
    //

    WORKID widStart   = _widStart;
    DBCOUNTITEM cRowsInSeg = iter.GetSegment()->RowCount();

    DBROWCOUNT cRowsResidual = transformer.GetFetchOffsetFromAnchor();
    _cRowsBeyond = 0;

    Win4Assert( WORKID_TBLBEFOREFIRST != widStart &&
                WORKID_TBLAFTERLAST != widStart );

    BOOL fGoingForward = cRowsResidual >= 0;

    if ( !fGoingForward )
    {
        //
        // Make the residual row count always positive.
        //
        cRowsResidual = -cRowsResidual;
    }

    //
    // Do the computations for the first segment.
    // The residual row count will always be WRT the beginning of a segment
    // if going forward and will be WRT to the end of a segment if going
    // backward. It will always be positive.
    //

    ULONG iRowStart;

    if ( WORKID_TBLLAST == widStart )
    {
        iRowStart = (ULONG) (cRowsInSeg-1);
    }
    else if ( WORKID_TBLFIRST == widStart )
    {
        iRowStart = 0;
    }
    else
    {
        CTableWindow * pStartWindow = iter.GetWindow();
        BOOL fFound = pStartWindow->RowOffset( widStart, iRowStart );
        Win4Assert( fFound && "Must Find Starting BookMark" );
    }

    if ( fGoingForward )
    {
        // WRT to the beginning of the current segment
        cRowsResidual += iRowStart;
    }
    else
    {
        // WRT to the end of the current segment
        cRowsResidual += (cRowsInSeg-iRowStart)-1;
    }

    //
    // Look for the row in this segment.
    //
    while ( !IsOffsetFound(iter, cRowsResidual) )
    {
        cRowsResidual -= cRowsInSeg;
        Win4Assert( cRowsResidual >= 0 );

        if ( fGoingForward )
        {
            _segList.Advance(iter);
        }
        else
        {
            _segList.BackUp(iter);
        }

        if ( _segList.AtEnd(iter) )
        {
            break;
        }

        cRowsInSeg = iter.GetSegment()->RowCount();

        if ( iter.GetSegment()->IsBucket() &&
             fAsync &&
             transformer.IsContiguous() )
        {

            //
            // We are doing asynchronous get rows in a contiguous
            // watch region. So, we should schedule the buckets for
            // later expansion and NOT count the rows in them for the
            // offset computation.
            //
            CTableBucket * pBktToExpand =
                _largeTable._LokReplaceWithEmptyWindow( iter );
            xBktToConvert.Push( pBktToExpand );

            //
            // We should not count the rows in a bucket in async case.
            //
            cRowsInSeg = 0;
        }
    }

    if ( _segList.AtEnd( iter ) )
    {
        if ( fGoingForward )
        {
            _cRowsBeyond = -cRowsResidual;
            if ( 0 == _cRowsBeyond )
            {
                //
                // Should be the first row after the last segment.
                //
                _cRowsBeyond = 1;
            }
        }
        else
        {
            _cRowsBeyond = -cRowsResidual;
            if ( 0 == _cRowsBeyond )
            {
                //
                // Is the first row before this segment.
                //
                _cRowsBeyond = -1;
            }
        }
        _widFound = widInvalid;
    }
    else
    {
        if ( !iter.GetSegment()->IsWindow() )
        {
            _RelocateThruBuckets( fAsync, iter, transformer, xBktToExplode );
        }
        else
        {
            CTableWindow * pWindow = iter.GetWindow();
            Win4Assert( pWindow->RowCount() > (ULONG) cRowsResidual );

            if ( fGoingForward )
            {
                _widFound = pWindow->GetBookMarkAt( (ULONG) cRowsResidual );
            }
            else
            {
                _widFound = pWindow->GetBookMarkAt( (ULONG) (
                            pWindow->RowCount() - cRowsResidual - 1 ) );
            }
        }
    }

#if CIDBG==1
    tbDebugOut(( DEB_REGTRANS, "After Relocating\n" ));
    transformer.DumpState();
#endif  // CIDBG

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLocator::_RelocateThruBuckets
//
//  Synopsis:   Does the processing needed after locating the segment in
//              which the requested row is contained.  If the current segment
//              is a bucket, the following actions must be taken:
//
//              1. If it is synchronous fetch, must EXPLODE the bucket.
//
//              2. O/W, it must a non-contiguous fetch. In this case, we
//                 must locate the closest window.
//
//                 If the fetch is forward,
//                 (+ve count of rows), we must locate the first window in
//                 the forward direction and position at the beginning of the
//                 window.
//
//                 If the fetch is backward (-ve count of rows), we must
//                 locate the first window in the backward direction and
//                 position at the end of the window.
//
//  Arguments:  [fAsync]        -
//              [iter]          -
//              [transformer]   -
//              [xBktToExplode] -
//
//  History:    7-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CTableRowLocator::_RelocateThruBuckets( BOOL fAsync,
                                        CDoubleTableSegIter& iter,
                                        CRegionTransformer& transformer,
                                        XPtr<CTableBucket>& xBktToExplode
                                      )
{

    //
    // If the iterator is not at the end of the list, then the current
    // segment MUST contain the row we are looking for.
    //
    Win4Assert( !iter.GetSegment()->IsWindow() );

    if (!fAsync)
    {
        //
        // We are in synchronous mode and the iterator is positioned at
        // a bucket. Must explode the bucket.
        //
        CTableBucket * pBucket = _largeTable._LokReplaceWithEmptyWindow( iter );
        xBktToExplode.Set( pBucket );
        return;
    }

    //
    // If the fetch is contiguous, we must be either at a window or past the
    // end of the list. Both cases are eliminated above this.
    //
    Win4Assert( !transformer.IsContiguous() );

    //
    // Search for the nearest window - either in the positive
    // or negative direction depending upon the count of the
    // rows.
    //
    BOOL fForward = transformer.GetFetchCount() >= 0 ;

    while ( !_segList.AtEnd(iter) )
    {
        CTableSegment * pSeg = iter.GetSegment();
        if ( pSeg->IsBucket() ||
             0 == pSeg->RowCount() )
        {
            if ( fForward )
            {
                _segList.Advance(iter);
            }
            else
            {
                _segList.BackUp(iter);
            }
        }
        else
        {
            Win4Assert( pSeg->IsWindow() );
            break;
        }
    }

    if ( !_segList.AtEnd(iter) )
    {
        if ( fForward )
        {
            _widFound = iter.GetWindow()->GetBookMarkAt(0);
        }
        else
        {
            _widFound = iter.GetWindow()->GetBookMarkAt( (ULONG) (iter.GetSegment()->RowCount()-1) );
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLocator::LokSimulateFetch
//
//  Synopsis:   Simulates fetching rows from windows and schedules the buckets
//              in the path to be converted to windows. This allows setting
//              the watch region correctly over all the required segments.
//
//  Arguments:  [iter]          -  The iterator is positioned at the segment to
//              start fetching from.
//              [transformer]   -  The transformer is initialized with the old
//              and new fetch/watch arguments.
//              [xBktToConvert] -  On output, will have buckets to be converted
//              into windows. These buckets were in the fetch region and will be
//              replace with empty windows here.
//
//  History:    7-26-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableRowLocator::LokSimulateFetch( CDoubleTableSegIter& iter,
                                         CRegionTransformer& transformer,
                                         CDynStack<CTableBucket>& xBktToConvert
                                       )
{

#if CIDBG==1
    tbDebugOut(( DEB_REGTRANS, " Before SimulateFetch\n" ));
    transformer.DumpState();
#endif  // CIDBG

    Win4Assert( iter.GetSegment()->IsWindow() );
    Win4Assert( widInvalid != _widFound );

//    Win4Assert( IsRowFound(iter) );

    //
    // If it is asynchronous fetch, we do not have categorization and so
    // we don't have to worry about checking for going beyond chapters.
    //

    BOOL  fForward = transformer.GetFetchCount() >= 0;

    DBROWCOUNT cRowsToRetrieve = 0;  // tracks the number of rows still to retrieve.

    if ( fForward )
        cRowsToRetrieve = transformer.GetFetchCount();
    else
        cRowsToRetrieve = -transformer.GetFetchCount();

    CTableWindow * pFirstWindow = iter.GetWindow();

    ULONG iRowOffset;
    TBL_OFF dummy;
    BOOL fFound = pFirstWindow->FindBookMark( _widFound, dummy, iRowOffset );
    Win4Assert( fFound );

    //
    // For determining the lowest fetch position.
    //
    ULONG iOffsetInFirstWindow = iRowOffset;

    //
    // Compute the number of rows that can be retrieved from current window.
    //
    ULONG cRowsFromCurrWindow = 0;
    if ( fForward )
        cRowsFromCurrWindow = (ULONG) (pFirstWindow->RowCount()-iRowOffset);
    else
        cRowsFromCurrWindow = iRowOffset+1;

    if ( cRowsToRetrieve > (long) cRowsFromCurrWindow )
    {
        //
        // We still have more rows to be retrieved.
        //
        cRowsToRetrieve -= cRowsFromCurrWindow;
    }
    else
    {
        //
        // This window can give us all the rows to be fetched.
        //
        if ( !fForward )
        {
            Win4Assert( iRowOffset+1 >= (ULONG) cRowsToRetrieve );
            iOffsetInFirstWindow = (ULONG) ( iRowOffset+1-cRowsToRetrieve );
        }
        cRowsToRetrieve = 0;
    }

    while ( cRowsToRetrieve > 0 )
    {
        Win4Assert( !_segList.AtEnd(iter) );

        if ( fForward )
        {
            _segList.Advance( iter );
        }
        else
        {
            _segList.BackUp(iter);
        }

        if ( _segList.AtEnd(iter) )
        {
            break;
        }

        if ( iter.GetSegment()->IsBucket() )
        {
            CTableBucket * pBucket =
                _largeTable._LokReplaceWithEmptyWindow(iter);
            xBktToConvert.Push(pBucket);
        }
        else
        {
            CTableWindow * pWindow = iter.GetWindow();
            cRowsFromCurrWindow = (ULONG) pWindow->RowCount();

            if ( cRowsToRetrieve > (long) cRowsFromCurrWindow )
            {
                cRowsToRetrieve -= cRowsFromCurrWindow;
            }
            else
            {
                if ( !fForward )
                {
                    iOffsetInFirstWindow = (ULONG) (
                                    pWindow->RowCount()-cRowsToRetrieve );
                    pFirstWindow = pWindow;
                }
                cRowsToRetrieve = 0;
            }
        }
    }

    if ( _segList.AtEnd(iter) && !fForward )
    {
       //
       // we have gone beyond the beginning of the table but still
       // cannot satisfy the row count to be retrieved. Is it okay to assume
       // that the first window and the first row are the lowest fetch points
       //
       Win4Assert( _segList.GetFirst() &&
                   _segList.GetFirst()->IsWindow() );
       pFirstWindow = (CTableWindow *) _segList.GetFirst();
       iOffsetInFirstWindow = 0;
    }

    Win4Assert( 0 != pFirstWindow );
    Win4Assert( iOffsetInFirstWindow < pFirstWindow->RowCount() );

    transformer.SetLowFetchPos( pFirstWindow, iOffsetInFirstWindow );

    if ( transformer.GetFetchOffsetFromOrigin() < 0 )
    {
        transformer.MoveOrigin( transformer.GetFetchOffsetFromOrigin() -
                                iOffsetInFirstWindow );
    }

#if CIDBG==1
    tbDebugOut(( DEB_REGTRANS, " SimulateFetch Done\n" ));
#endif  // CIDBG==1

}

void
CTableRowLocator::SeekAndSetFetchBmk( WORKID wid , CDoubleTableSegIter & iter )
{
    _widFound = widInvalid;

    if ( _segList.IsEmpty() )
        return;

    CTableWindow * pWindow;
    ULONG iRowOffset;

    if ( WORKID_TBLFIRST == wid )
    {
        //
        // We want the first bookmark in the table.
        //
        _segList.SetToBeginning( iter );
        pWindow = iter.GetWindow();
        iRowOffset = 0;
    }
    else
    {
        Win4Assert( WORKID_TBLLAST == wid );

        //
        // We want the last bookmark in the table.
        //
        _segList.SetToEnd(iter);
        pWindow = iter.GetWindow();
        if ( pWindow->RowCount() > 0 )
            iRowOffset = (ULONG) (pWindow->RowCount()-1);
    }

    if ( pWindow->RowCount() > 0 )
    {
        _widFound = pWindow->GetBookMarkAt( iRowOffset );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tmem.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       tmem.cxx
//
//  Contents:   tmem - test mem allocators for big tables.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

DECLARE_INFOLEVEL(tb)

#include "tblalloc.hxx"

BYTE MemPool[4096];

//BYTE* PoolPtrs[409];
//ULONG PoolOffs[409];

BOOL fInMemPool = TRUE;


//
//  ReportHeap - report heap blocks
//

void ReportHeap(
    void* pBlock,
    USHORT cbSize,
    USHORT fFree
) {
    BYTE* pbBlock = (BYTE*) pBlock;
    printf("%08x  %d%s\n", pbBlock, cbSize, fFree? " FREE": "");

    if (fInMemPool &&
	(pbBlock < &MemPool[0] ||
	 pbBlock + cbSize > &MemPool[ sizeof MemPool ])) {
	printf("\007***\tpBlock outside mem pool\t***\007");
    }
}

//
//  FreeBlocks -- free some of the allocated blocks
//

void FreeBlocks(
    BYTE* apbPtrs[],
    unsigned cPtrs,
    int fVerbose,
    CWindowDataAllocator& Alloc
) {
    unsigned i;
  
    // Free every third allocated block

    for (i = 2; i < cPtrs; i += 3) {
	if (apbPtrs[i]) {
	    Alloc.Free((void*)apbPtrs[i]);
	    apbPtrs[i] = 0;
	}
    }

    if (fVerbose) {
	printf("\nAfter freeing every third allocation\n");
	Alloc.WalkHeap(ReportHeap);
    }

    // Free every other allocated block, will cause some coalescing

    for (i = 0; i < cPtrs; i += 2) {
	if (apbPtrs[i]) {
	    Alloc.Free((void*)apbPtrs[i]);
	    apbPtrs[i] = 0;
	}
    }
    if (fVerbose) {
	printf("\nAfter freeing every other allocation\n");
	Alloc.WalkHeap(ReportHeap);
    }

    // Finally, Free every fourth allocated block, will cause more coalescing

    for (i = 3; i < cPtrs; i += 4) {
	if (apbPtrs[i]) {
	    Alloc.Free((void*)apbPtrs[i]);
	    apbPtrs[i] = 0;
	}
    }
    if (fVerbose) {
	printf("\nAfter freeing every other allocation\n");
	Alloc.WalkHeap(ReportHeap);
    }
}


__cdecl main(int argc, char** argv)
{
    BYTE* pMem = MemPool;
    int fVerbose = 0;
    unsigned i;

    for (i=1; i<(unsigned)argc; i++) {
	if (argv[i][0] == '-' &&
	    tolower(argv[i][1]) == 'v')
	    fVerbose++;
	else {
	    printf("Usage: %s [-v]\n", argv[0]);
	}
    }

    // Test the simple allocator with forward allocation.
    memset(pMem, 0xD5, sizeof MemPool);
    CVarBufferAllocator	Alloc1(pMem, sizeof MemPool);
    BYTE* pbuf;
    BOOL fBreak = FALSE;

    for (i=0; i<0xFFFFFFFF && !fBreak; i++)
    {
        TRY
        {
            pbuf = 0;
            pbuf = (BYTE *)Alloc1.Allocate(10);
        }
        CATCH (CException, e)
        {
            if (e.GetErrorCode() == E_OUTOFMEMORY)
                fBreak = TRUE;
            else
                RETHROW();
        }
        END_CATCH

	if (pbuf)
            memset(pbuf, '0' + i%10, 10);
    }
    Win4Assert(i == sizeof MemPool/10);

    for (i=0; i<sizeof MemPool - (sizeof MemPool % 10); i++) {
	Win4Assert(MemPool[i] == ((i/10) % 10 + '0'));
    }

#if 0
    // Test the simple allocator with top-down allocation.
    memset(pMem, 0xD5, sizeof MemPool);
    CVarBufferAllocator	Alloc2(pMem, sizeof MemPool, TRUE);

    for (i=0; pbuf = (BYTE *)Alloc2.Allocate(10); i++) {
	memset(pbuf, '0' + i%10, 10);
    }
    Win4Assert(i == sizeof MemPool/10);

    for (i=0; i<sizeof MemPool; i++) {
	if (i < (sizeof MemPool % 10)) {
	    Win4Assert(MemPool[i] == 0xD5);
	} else {
	    Win4Assert(MemPool[i] ==
			((((sizeof MemPool - 1) - i)/10) % 10 + '0'));
	}
    }
#endif //0

    // Test the heap allocator
    memset(pMem, 0, sizeof MemPool);

    BYTE **paPoolPtrs = (BYTE**)&MemPool;
    unsigned cPoolPtrs = sizeof MemPool / sizeof (BYTE *);

    CWindowDataAllocator	Alloc3;

    fInMemPool = FALSE;
    for (i=0; pbuf = (BYTE *)Alloc3.Allocate(10); i++) {
	if (i == cPoolPtrs)
	    break;
	paPoolPtrs[i] = pbuf;
	memset(pbuf, '0' + i%10, 10);
    }
    Win4Assert(i == cPoolPtrs);

    for (i=0; i<sizeof MemPool; i++) {
	Win4Assert(paPoolPtrs[i/10][i%10] == ((i/10) % 10 + '0'));
    }

    if (fVerbose) {
	printf("Grow forward allocation\n");
	Alloc3.WalkHeap(ReportHeap);
    }

    FreeBlocks(paPoolPtrs, cPoolPtrs, fVerbose, Alloc3);


    // Test the fixed/variable allocator
    memset(pMem, 0, sizeof MemPool);

    Win4Assert(sizeof (BYTE*) == sizeof (ULONG));

    paPoolPtrs = (BYTE **)&MemPool;
    cPoolPtrs = (sizeof MemPool / sizeof (BYTE *)) / 2;

    ULONG *paPoolOffs = (ULONG *)&paPoolPtrs[cPoolPtrs];

    memset(paPoolPtrs, 0, sizeof (BYTE *) * cPoolPtrs);
    memset(paPoolOffs, 0, sizeof (BYTE *) * cPoolPtrs);
    CFixedVarAllocator	Alloc4(TRUE, TRUE, 10);

//    for (i=0; i<sizeof MemPool; i++) {
//	Alloc4.SetLimit(i);
//	Win4Assert(Alloc4.Limit() == i);
//    }
//
//    Alloc4.SetLimit(1000);

    for (i=0; (pbuf = (BYTE *)Alloc4.Allocate(10)) && i < cPoolPtrs; i++) {
	memset(pbuf, '0' + i%10, 10);
	paPoolOffs[i] = Alloc4.PointerToOffset(pbuf);

	pbuf = (BYTE*)Alloc4.AllocFixed();
	memset(pbuf, '9' - i%10, 10);
    }
    Win4Assert(i == cPoolPtrs);

    CWindowDataAllocator* pVAlloc = Alloc4.VarAllocator();
    if (fVerbose && pVAlloc) {
	printf("\nFixed/Var allocation\n");
	pVAlloc->WalkHeap(ReportHeap);
    }

    if (pVAlloc) {
	for (i=0; i<cPoolPtrs; i++) {
	    if (paPoolOffs[i]) {
		paPoolPtrs[i] = (BYTE*)Alloc4.OffsetToPointer(paPoolOffs[i]);
	    }
	}
	FreeBlocks(paPoolPtrs, cPoolPtrs, fVerbose, *pVAlloc);
    }


    // Test the fixed/variable allocator
    memset(pMem, 0, sizeof MemPool);

    Win4Assert(sizeof (BYTE*) == sizeof (ULONG));

    paPoolPtrs = (BYTE **)&MemPool;
    cPoolPtrs = (sizeof MemPool / sizeof (BYTE *));

    memset(paPoolPtrs, 0, sizeof (BYTE *) * cPoolPtrs);
    CFixedVarAllocator	Alloc5(TRUE, TRUE, 0x28);

    for (i=0; (pbuf = (BYTE *)Alloc5.AllocFixed()) && i < cPoolPtrs; i++) {
	memset(pbuf, '0' + i%10, 0x28);
    }
    Win4Assert(i == cPoolPtrs);

    for (i=0; i<cPoolPtrs; i++) {
	if (paPoolOffs[i]) {
	    paPoolPtrs[i] = (BYTE*)Alloc5.OffsetToPointer(paPoolOffs[i]);
	}
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\winsplit.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       winsplit.cxx
//
//  Contents:   Contains the code to do a window split.
//
//  Classes:    CTableWindowSplit
//
//  Functions:  
//
//  History:    1-08-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "winsplit.hxx"
#include "tabledbg.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   CTableWindowSplit     ~ctor
//
//  Synopsis:   Constructor for the CTableWindowSplit class.
//
//  Arguments:  [srcWindow]             -   The source window that needs to be
//              split
//              [iSplitVisibleRowIndex] -   Index in the source window's visible
//              row index which is the split index. All rows <= 
//              iSplitVisibleRowIndex will be in the left hand window and the rest
//              in the right hand window after the split.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTableWindowSplit::CTableWindowSplit( CTableWindow & srcWindow,
                                      ULONG iSplitQueryRowIndex,
                                      ULONG segIdLeft, ULONG segIdRight,
                                      BOOL  fIsLastSegment )
    : _srcWindow(srcWindow),
      _pLeftWindow(0),
      _pRightWindow(0),
      _srcQueryRowIndex(srcWindow._GetInvisibleRowIndex()),
      _srcClientRowIndex(srcWindow._GetVisibleRowIndex()),
      _iSplitQueryRowIndex(iSplitQueryRowIndex),
      _iSplitClientRowIndex(-1),
      _segIdLeft(segIdLeft), _segIdRight(segIdRight),
      _fIsLastSegment(fIsLastSegment)
{

    Win4Assert( _srcQueryRowIndex.RowCount() >= 2 );
    Win4Assert( iSplitQueryRowIndex < _srcQueryRowIndex.RowCount()-1 );


    if ( _srcWindow.IsWatched() )
    {
        //
        // The source window has watch regions. The dynamic rowindex must
        // also be split.
        //
        TBL_OFF oQuerySplitRow = _srcQueryRowIndex.GetRow( iSplitQueryRowIndex );
        _iSplitClientRowIndex = _srcClientRowIndex.FindSplitPoint( oQuerySplitRow )-1;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ~CTableWindowSplit  ~dtor for the CTableWindowSplit class
//
//  Synopsis:   Frees up the resources
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTableWindowSplit::~CTableWindowSplit()
{
    delete _pLeftWindow;
    delete _pRightWindow;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateTargetWindows
//
//  Synopsis:   Creates the target windows and initializes their
//              notification region based on the source window notification
//              region.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::CreateTargetWindows()
{

    //
    // First create the left and right windows
    //
    Win4Assert( 0 == _pLeftWindow );
    Win4Assert( 0 == _pRightWindow );

    _pLeftWindow  = new CTableWindow( _srcWindow, _segIdLeft );
    _pRightWindow = new CTableWindow( _srcWindow, _segIdRight );

}

//+---------------------------------------------------------------------------
//
//  Function:   TransferTargetWindows
//
//  Synopsis:   Transfers the control of the target windows to the caller.
//
//  Arguments:  [ppLeftWindow]  - (output) The pointer to the left window.
//              [ppRightWindow] - (output) The pointer to the right window.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::TransferTargetWindows( CTableWindow ** ppLeftWindow,
                                              CTableWindow ** ppRightWindow )
{
    Win4Assert( 0 != ppLeftWindow && 0 != ppRightWindow );


    *ppLeftWindow  = _pLeftWindow;
    _pLeftWindow = 0;

    *ppRightWindow = _pRightWindow;
    _pRightWindow = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   _CopyWithoutNotifications
//
//  Synopsis:   Copies rows from the source window to the destination window. Only
//              the rows in the "srcRowIndex" will be copied to the
//              destination.
//
//  Arguments:  [destWindow]     -  Target window to copy to.
//              [srcRowIndex]    -  The source row index.
//              [iStartRowIndex] -  Starting offset in the row index to start
//              copying rows from.
//              [iEndRowIndex]   -  Ending offset in the row index to stop
//              copying.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::_CopyWithoutNotifications( CTableWindow & destWindow,
                            CRowIndex & srcRowIndex,
                            ULONG iStartRowIndex, ULONG iEndRowIndex )
{

    Win4Assert( iEndRowIndex < srcRowIndex.RowCount() );

    for ( ULONG i = iStartRowIndex; i <= iEndRowIndex; i++ )
    {
        destWindow._PutRowToVisibleRowIndex( _srcWindow, srcRowIndex.GetRow(i) );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _SimpleSplit
//
//  Synopsis:   Does a simple split in which the first half of the rows from
//              the source row index will be copied to the left window and the
//              second half to the right window.
//
//  History:    1-31-95   srikants   Created
//
//  Notes:      This must be called only when there is no notification region
//              in the source window.
//
//----------------------------------------------------------------------------

void CTableWindowSplit::_SimpleSplit()
{
    
    Win4Assert( !_srcWindow.IsWatched() );

    //
    // The source notifcation region is completely empty. We have to copy from
    // the visible row index only.
    //
    tbDebugOut(( DEB_WINSPLIT, "CTableWindowSplit::Simple Split\n" ));
    _CopyWithoutNotifications( *_pLeftWindow,  _srcQueryRowIndex,
                               0, _iSplitQueryRowIndex );
    _CopyWithoutNotifications( *_pRightWindow, _srcQueryRowIndex,
                               _iSplitQueryRowIndex+1,
                               _srcQueryRowIndex.RowCount()-1 );
    
}


//+---------------------------------------------------------------------------
//
//  Function:   DoSplit
//
//  Synopsis:   Splits the source window into left and right windows.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::DoSplit()
{
    Win4Assert( 0 != _pLeftWindow && 0 != _pRightWindow );

    _pLeftWindow->_SetSplitInProgress();
    _pRightWindow->_SetSplitInProgress();

    if ( !_srcWindow.IsWatched() )
    {
        //
        // The source notifcation region is completely empty. We have to copy from
        // the visible row index only.
        //
        Win4Assert( -1 == _iSplitClientRowIndex );
        _SimpleSplit();

        _pLeftWindow->_SetSplitDone();
        _pRightWindow->_SetSplitDone();
        
    }
    else
    {
        //
        // If notifications are enabled in the target window, then we must copy
        // both the client row index and the query row index. O/W, just copy
        // the contents of the query row index.
        //

        //
        // Copy the contents to the target left window.
        //
        tbDebugOut(( DEB_WINSPLIT, "Left Window with Notifications\n" ));
        _CopyWithNotifications( *_pLeftWindow, 0, _iSplitQueryRowIndex,
                                0, _iSplitClientRowIndex );
        //
        // Copy the contents to the target right window.
        //
        tbDebugOut(( DEB_WINSPLIT, "Right Window with Notifications\n" ));
        _CopyWithNotifications( *_pRightWindow,
                   _iSplitQueryRowIndex+1,  _srcQueryRowIndex.RowCount()-1,
                   _iSplitClientRowIndex+1, _srcClientRowIndex.RowCount()-1 );

        //
        // Now apply the watch regions on the new windows.
        //
        _CopyWatchRegions();

        //
        // Indicate that the split is done.
        //
        _pLeftWindow->_SetSplitDone();
        _pRightWindow->_SetSplitDone();

        //
        // If any of the windows doesn't have any watch regions, we have to
        // do a state change to delete the dynamic/static split.
        //

        Win4Assert( _pLeftWindow->IsWatched() || _pRightWindow->IsWatched() );

        if ( !_pLeftWindow->IsWatched() )
        {
            _pLeftWindow->_EndStaticDynamicSplit();    
        }

        if ( !_pRightWindow->IsWatched() )
        {
            _pRightWindow->_EndStaticDynamicSplit();    
        }
    }

    //
    // Setup the lowest & highest keys for the left and right windows.
    //
    _srcWindow.GetSortKey( 0, _pLeftWindow->GetLowestKey() );
    _srcWindow.GetSortKey( _iSplitQueryRowIndex+1, _pRightWindow->GetLowestKey() );

    _srcWindow.GetSortKey( _iSplitQueryRowIndex, _pLeftWindow->GetHighestKey() );
    _srcWindow.GetSortKey( (ULONG) _srcWindow.RowCount()-1, _pRightWindow->GetHighestKey() );
}

//+---------------------------------------------------------------------------
//
//  Function:   _CopyWithNotifications
//
//  Synopsis:   Copies contents of both the "visible" and "dynamic" row index
//              from the source window to the destination window. 
//
//  Arguments:  [destWindow]        -   Destination window to copy to.
//              [iStartVisRowIndex] -   Starting offset in the visible rowindex.
//              [iEndVisRowIndex]   -   Ending offset in the visible rowindex.
//              [iStartDynRowIndex] -   Starting offset in the dynamic rowindex.
//              [iEndDynRowIndex]   -   Ending offset in the dynamic rowindex.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::_CopyWithNotifications( CTableWindow & destWindow,
                                   ULONG iStartQueryRowIndex,  ULONG iEndQueryRowIndex,
                                   LONG  iStartClientRowIndex,  LONG iEndClientRowIndex )
{

    Win4Assert( _srcWindow.IsWatched() );
    
    Win4Assert( iStartQueryRowIndex < _srcQueryRowIndex.RowCount() );
    Win4Assert( iEndQueryRowIndex >= iStartQueryRowIndex &&
                iEndQueryRowIndex < _srcQueryRowIndex.RowCount() );
    
    //
    // Copy the rows from the client row index.
    //
    for ( LONG j = iStartClientRowIndex; j <= iEndClientRowIndex; j++ )
    {
        destWindow._PutRowToVisibleRowIndex( _srcWindow, _srcClientRowIndex.GetRow(j) );
    }

    //
    // Copy the rows from the query row index.
    //
    for ( ULONG i = iStartQueryRowIndex; i <= iEndQueryRowIndex; i++ )
    {
        destWindow._PutRowToDynRowIndex( _srcWindow, _srcQueryRowIndex.GetRow(i) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindowSplit::_IsOffsetInLeftWindow
//
//  Synopsis:   
//
//  Arguments:  [iOffset] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    7-27-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

inline
BOOL CTableWindowSplit::_IsOffsetInLeftWindow( long iOffset )
{
    return iOffset <= _iSplitClientRowIndex;    
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableWindowSplit::_CopyWatchRegions
//
//  Synopsis:   
//
//  Modifies:   
//
//  History:    7-27-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CTableWindowSplit::_CopyWatchRegions()
{
    Win4Assert( _srcWindow.IsWatched() );

    for ( unsigned i = 0; i < _srcWindow._aWindowWatch.Count(); i++ )
    {
        CWindowWatch & watch = _srcWindow._aWindowWatch.Get(i);

        long cResidual = watch._cRowsLeft;

        if ( _IsOffsetInLeftWindow( watch._iRowStart ) )
        {
            cResidual -= _pLeftWindow->AddWatch( watch._hRegion,
                                                     watch._iRowStart,
                                                     cResidual,
                                                     FALSE );
            if ( cResidual > 0 )
            {
                _pRightWindow->AddWatch( watch._hRegion,
                                         0,
                                         cResidual,
                                         _fIsLastSegment );
            }
        }
        else
        {
            //
            // The offset must be in the right hand side window.
            //
            Win4Assert( watch._iRowStart > _iSplitClientRowIndex &&
                        watch._iRowStart < (long) _srcWindow.RowCount() );

            Win4Assert( (long) _pLeftWindow->RowCount() == _iSplitClientRowIndex+1 );

           _pRightWindow->AddWatch( watch._hRegion,
                                    (LONG) (watch._iRowStart - _pLeftWindow->RowCount()),
                                    cResidual,
                                    _fIsLastSegment );
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\catarray.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       CatArray.cxx
//
//  Contents:   Catalog array, for user mode content index
//
//  History:    22-Dec-92 KyleP     Split from vquery.cxx
//              11-Oct-96 dlee      added catalog name support
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catarray.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>

#include <docstore.hxx>
#include <imprsnat.hxx>
#include <eventlog.hxx>
#include <cievtmsg.h>

#include "cicat.hxx"

#include <dbgproxy.hxx>
#include <query.hxx>
#include <srequest.hxx>
#include <removcat.hxx>

CCatArray Catalogs;


//+---------------------------------------------------------------------------
//
//  Member:     COldCatState::COldCatState, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [dwOldState] -- old state of the catalog
//              [wcsCatName] -- name of the catalog
//              [wcVol] -- volume letter
//
//  History:    15-Jul-98   KitmanH        Created
//
//----------------------------------------------------------------------------

COldCatState::COldCatState( DWORD dwOldState, WCHAR const * wcsCatName, WCHAR wcVol )
    : _dwOldState(dwOldState),
      _cStopCount(1)
{
    RtlZeroMemory( _aVol, sizeof _aVol );

    if ( 0 != wcVol )
        _aVol[toupper(wcVol) - L'A'] = 1;

    _xCatName.Init( wcslen( wcsCatName ) + 1 );
    RtlCopyMemory( _xCatName.Get(), wcsCatName, _xCatName.SizeOf() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::CCatArray, public
//
//  Synopsis:   Constructor for array to handle switching drives for catalogs
//
//  History:    07-May-92   AmyA        Lifted from vquery.cxx
//              02-Jun-92   KyleP       Added UNC support.
//              12-Jun-92   KyleP       Lifted from citest.cxx
//
//----------------------------------------------------------------------------

CCatArray::CCatArray()
    : _aDocStores(0),
      _pDrvNotifArray(0),
      _fInit(FALSE),
      _mutex(FALSE)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::Init, public
//
//  Synopsis:   Initializer for catalogs array
//
//  History:    20 May 99   AlanW       Created
//
//----------------------------------------------------------------------------

void CCatArray::Init()
{
      _mutex.Init();
      _fInit = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::~CCatArray, public
//
//  Synopsis:   Destructor for array to handle switching drives for catalogs
//
//  History:    07-May-92   AmyA        Lifted from vquery.cxx
//              02-Jun-92   KyleP       Added UNC support.
//              12-Jun-92   KyleP       Lifted from citest.cxx
//
//----------------------------------------------------------------------------

CCatArray::~CCatArray()
{
    if (_fInit)
    {
        CLock lockx( _mutex );
        _pDrvNotifArray = 0;
        ClearStopArray();
        Flush();
    }
} //~CCatArray

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::Flush, public
//
//  Synopsis:   Close all open catalogs
//
//  History:    03-Sep-93 KyleP     Created
//
//  Notes:      This is a dangerous operation.  It should only be called
//              when no-one is accessing any indexes.
//
//--------------------------------------------------------------------------

void CCatArray::Flush()
{
    if (! _fInit)
        return;

    CLock lock( _mutex );

    TRY
    {
        // Close all the open docstores

        for ( unsigned i = 0; i < _aDocStores.Count(); i++ )
        {
            Win4Assert( 0 != _aDocStores[i] );
            _aDocStores[i]->Shutdown();
        }

        // Delete registry entries for auto-mounted catalogs

        if ( 0 != _pDrvNotifArray )
        {
            BOOL aDrives[ RTL_MAX_DRIVE_LETTERS ];
            RtlZeroMemory( aDrives, sizeof aDrives );

            _pDrvNotifArray->GetAutoMountDrives( aDrives );

            for ( WCHAR x = 0;  x < RTL_MAX_DRIVE_LETTERS; x++ )
            {
                if ( aDrives[x] )
                {
                    CRemovableCatalog cat( L'A' + x );
                    cat.Destroy();
                }
            }
        }
    }
    CATCH( CException, e )
    {
        Win4Assert( !"unexpected exception when shutting down a docstore" );
    }
    END_CATCH

    _aDocStores.Free();
} //Flush

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::FlushOne, public
//
//  Synopsis:   Close one catalog
//
//  Arguments:  [pDocStore] -- Pointer to the docstore to be flushed
//
//  History:    27-Apr-98 KitmanH    Created
//
//  Notes:      This is a dangerous operation.  It should only be called
//              when no-one is accessing any indexes.  If this wasn't
//              downlevel scaffolding we'd have to perform some serious
//              serialization and refcounting here.
//
//--------------------------------------------------------------------------

void CCatArray::FlushOne( ICiCDocStore * pDocStore )
{
    CLock lock( _mutex );

    for ( unsigned i = 0; i < _aDocStores.Count(); i++ )
    {
        Win4Assert( 0 != _aDocStores[i] );

        if ( _aDocStores[i] == pDocStore)
        {
            _aDocStores[i]->Shutdown();

            CClientDocStore * p = _aDocStores.AcquireAndShrink(i);
            p->Release();
            return;
        }
    }
} //FlushOne

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::GetDocStore, public
//
//  Synopsis:   Returns a PCatalog by either using an existing catalog or
//              creating a new one.  Returns 0 if a catalog couldn't be
//              found or created.
//
//  Arguments:  [pwcPathOrName]  -- Root of the catalog or friendly name
//
//  History:    07-May-92   AmyA        Lifted from vquery.cxx
//              22-May-92   AmyA        Added TRY/CATCH
//              02-Jun-92   KyleP       Added UNC support.
//              12-Jun-92   KyleP       Lifted from citest.cxx
//              29-Sep-94   KyleP       Added ofs proxy support
//              1-16-97     srikants    Changed to return DocStore.
//
//----------------------------------------------------------------------------

CClientDocStore * CCatArray::GetDocStore(
    WCHAR const * pwcPathOrName,
    BOOL          fMustExist )
{
    BOOL fPath = wcschr( pwcPathOrName, L':' ) ||
                 wcschr( pwcPathOrName, L'\\' );
    return GetNamedDocStore( pwcPathOrName, fPath ? 0 : pwcPathOrName,
                             FALSE,       // read-only
                             fMustExist );
} //GetDocStore

//+---------------------------------------------------------------------------
//
//  Function:   CatalogPathToName
//
//  Synopsis:   Enumerates catalogs looking for a named catalog whose
//              location matches the given path.
//
//  Arguments:  [pwcPath]      -- Path to look for
//              [pwcName]      -- Returns the catalog name
//
//  Returns:    S_OK if a match was found, S_FALSE otherwise.
//
//  History:    22-Jun-98   dlee        created
//
//----------------------------------------------------------------------------

SCODE CatalogPathToName(
    WCHAR const * pwcPath,
    WCHAR *       pwcName )
{
    BOOL fFound = FALSE;

    HKEY hKey;
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        wcsRegCatalogsSubKey,
                                        0,
                                        KEY_QUERY_VALUE |
                                            KEY_ENUMERATE_SUB_KEYS,
                                        &hKey ) )
    {
        SRegKey xKey( hKey );
        DWORD iSubKey = 0;

        do
        {
            FILETIME ft;
            WCHAR awcName[MAX_PATH];
            DWORD cwcName = sizeof awcName / sizeof WCHAR;
            LONG err = RegEnumKeyEx( hKey,
                                     iSubKey,
                                     awcName,
                                     &cwcName,
                                     0, 0, 0, &ft );

            // either error or end of enumeration

            if ( ERROR_SUCCESS != err )
                break;

            iSubKey++;

            HKEY hCatName;
            if ( ERROR_SUCCESS == RegOpenKeyEx( hKey,
                                                awcName,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hCatName ) )
            {
                SRegKey xCatNameKey( hCatName );

                // Check if the catalog is inactive and can be ignored

                WCHAR awcKey[MAX_PATH];
                wcscpy( awcKey, wcsRegJustCatalogsSubKey );
                wcscat( awcKey, L"\\" );
                wcscat( awcKey, awcName );

                CRegAccess reg( RTL_REGISTRY_CONTROL, awcKey );
                BOOL fInactive = reg.Read( wcsCatalogInactive,
                                           CI_CATALOG_INACTIVE_DEFAULT );

                if ( !fInactive )
                {
                    WCHAR awcPath[MAX_PATH];
                    DWORD cbPath = sizeof awcPath;
                    if ( ERROR_SUCCESS == RegQueryValueEx( hCatName,
                                                           wcsCatalogLocation,
                                                           0,
                                                           0,
                                                           (BYTE *)awcPath,
                                                           &cbPath ) )
                    {
                        int cwc = wcslen( awcPath ) - 1;
                        if ( ( cwc >= 0 ) && ( L'\\' == awcPath[ cwc ] ) )
                            awcPath[ cwc ] = 0;

                        if ( !_wcsicmp( awcPath, pwcPath ) )
                        {
                            fFound = TRUE;
                            wcscpy( pwcName, awcName );
                            break;
                        }
                    }
                }
            }
        } while ( TRUE );
    }

    return fFound ? S_OK : S_FALSE;
} //CatalogPathToName

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::GetNamedDocStore, public
//
//  Synopsis:   Returns a PCatalog by either using an existing catalog or
//              creating a new one.  Returns 0 if a catalog couldn't be
//              found or created.
//
//  Arguments:  [pwcPath]      -- Root of the catalog
//              [pwcName]      -- 0 or name of the catalog (optional param)
//              [fMustExist]   -- If TRUE, the catalog must exist unless
//                                it is the null catalog.  If FALSE, the
//                                catalog can be opened.
//
//  History:    12-Oct-96   dlee        created
//              1-16-97     srikants    Changed to return DocStore.
//              16-Feb-2000 KLam        Make sure path is good before using it
//
//----------------------------------------------------------------------------

CClientDocStore * CCatArray::GetNamedDocStore(
    WCHAR const * pwcPath,
    WCHAR const * pwcName,
    BOOL          fOpenForReadOnly,
    BOOL          fMustExist )
{
    WCHAR awcPath[ MAX_PATH ];

    Win4Assert ( 0 != pwcPath );

    unsigned len = wcslen( pwcPath );
    RtlCopyMemory( awcPath, pwcPath, ( len + 1 ) * sizeof WCHAR );

    // Get rid of trailing slash.

    Win4Assert ( len > 0 && len < MAX_PATH );
    if ( len > 0 && awcPath[ len - 1 ] == '\\' )
        awcPath[ len - 1 ] = 0;

    // make a complete path including \catalog.wci

    WCHAR awcCompletePath[ MAX_PATH ];
    wcscpy( awcCompletePath, awcPath );
    wcscat( awcCompletePath, CAT_DIR );

    BOOL fNullCatalog = !wcscmp( pwcPath, CINULLCATALOG );

    CLock lock( _mutex );

    // Look for previous use of catalog path or name.

    for ( unsigned i = 0; i < _aDocStores.Count(); i++ )
    {
        Win4Assert( 0 != _aDocStores[i] );

        const WCHAR *pwcCatName = _aDocStores[i]->GetName();
        CiCat * pCat = _aDocStores[i]->GetCiCat();
        const WCHAR *pwcCatPath = ( 0 == pCat ) ? 0 : pCat->GetCatDir();

        ciDebugOut(( DEB_ITRACE, "pwcPath: '%ws'\n", pwcPath ));
        ciDebugOut(( DEB_ITRACE, "pwcName: '%ws'\n", pwcName ));
        ciDebugOut(( DEB_ITRACE, "pwcCatName: '%ws'\n", pwcCatName ));
        ciDebugOut(( DEB_ITRACE, "pwcCatPath: '%ws'\n", pwcCatPath ));
        ciDebugOut(( DEB_ITRACE, "awcPath: '%ws'\n", awcPath ));
        ciDebugOut(( DEB_ITRACE, "awcCompletePath: '%ws'\n", awcCompletePath ));

        if ( ( fNullCatalog && ( 0 == pwcCatName ) ) ||
             ( ( 0 != pwcCatPath ) &&
               ( 0 == _wcsicmp( awcCompletePath, pwcCatPath ) ) ) ||
             ( ( ( 0 != pwcCatName ) &&
                 ( 0 != pwcName ) &&
                 ( 0 == _wcsicmp( pwcName, pwcCatName ) ) ) ) )
            return _aDocStores[i];
    }

    //
    // We will let the special case of NullCatalog percolate through
    // so we can create it only if the registry entry IsCatalogActive
    // says we should activate it.
    //

    if ( fMustExist && !fNullCatalog)
        return 0;

    // Try to fault the catalog in by name or path

    WCHAR awcName[ MAX_PATH ];

    if ( !fMustExist )
    {
        // Can we fault-in a named catalog?

        if ( L':' != awcPath[1] )
        {
            HKEY hCatName;
            WCHAR awcCat[ MAX_PATH ];
            wcscpy( awcCat, wcsRegCatalogsSubKey );
            wcscat( awcCat, L"\\" );
            wcscat( awcCat, pwcName );

            ciDebugOut(( DEB_ITRACE, "attempting to fault-in %ws\n", awcCat ));

            if ( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                                awcCat,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hCatName ) )
                return 0;

            SRegKey xCatName( hCatName );
            DWORD cbPath = sizeof awcPath;
            if ( ERROR_SUCCESS != RegQueryValueEx( hCatName,
                                                   wcsCatalogLocation,
                                                   0,
                                                   0,
                                                   (BYTE *)awcPath,
                                                   &cbPath ) )
                return 0;

            // Trim trailing backslash

            int cwc = wcslen( awcPath ) - 1;
            if ( ( cwc >= 0 ) && ( L'\\' == awcPath[ cwc ] ) )
                awcPath[ cwc ] = 0;
        }
        else if ( ( 0 == pwcName ) || ( L':' == pwcName[1] ) )
        {
            // no name, just a path in both fields -- inverse lookup

            if ( S_FALSE == CatalogPathToName( awcPath, awcName ) )
                return 0;

            pwcName = awcName;
        }
    }

    // Catalog name instead of a path?  If so, fail the lookup since
    // catalogs can only be really opened by path.

    if ( L':' != awcPath[1] )
        return 0;

    TRY
    {
        BOOL fInactive = FALSE;

        // We want the null catalog's registry entry to be looked up using
        // friendly name.

        WCHAR const *pwcCatName = fNullCatalog ? pwcPath : pwcName;

        // Check if the catalog is marked as inactive.  Don't do this
        // in the constructor of CiCat -- it would be after a few
        // threads are created and lots of activity has started.

        if ( 0 != pwcCatName )
        {
            WCHAR awcKey[MAX_PATH];
            wcscpy( awcKey, wcsRegJustCatalogsSubKey );
            wcscat( awcKey, L"\\" );
            wcscat( awcKey, pwcCatName );

            CRegAccess reg( RTL_REGISTRY_CONTROL, awcKey );
            fInactive = reg.Read( wcsCatalogInactive,
                                  CI_CATALOG_INACTIVE_DEFAULT );
        }

        if ( !fInactive )
        {
            CImpersonateSystem impersonate;

            // Have we reached the maximum # of docstores?

            if ( _aDocStores.Count() >= GetMaxCatalogs() )
            {
                ciDebugOut(( DEB_WARN, "can't open %ws, out of catalogs!\n", pwcName ));

                TRY
                {
                    CEventLog eventLog( 0, wcsCiEventSource );
                    CEventItem item( EVENTLOG_WARNING_TYPE,
                                     CI_SERVICE_CATEGORY,
                                     MSG_CI_TOO_MANY_CATALOGS,
                                     1 );

                    item.AddArg( awcPath );
                    eventLog.ReportEvent( item );
                }
                CATCH( CException, e )
                {
                    // if we can't log the event, ignore
                }
                END_CATCH

                return 0; //Expensive, but who cares?
            }

            XPtr<CClientDocStore> xDocStore;

            if (fNullCatalog)
                xDocStore.Set( new CClientDocStore() );
            else
                xDocStore.Set( new CClientDocStore( awcPath,
                                                    fOpenForReadOnly,
                                                    *_pDrvNotifArray,
                                                    pwcName ) );

            _aDocStores.Add( xDocStore.GetPointer(), _aDocStores.Count() );
            xDocStore.Acquire();
        }
    }
    CATCH( CException, e )
    {
        // ignore catalogs that can't be opened
    }
    END_CATCH

    if ( i < _aDocStores.Count() )
        return _aDocStores[i];
    else
        return 0;
} //GetNamedDocStore

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::GetOne, public
//
//  Synopsis:   Returns a PCatalog by either using an existing catalog or
//              creating a new one.  Returns 0 if a catalog couldn't be
//              found or created.
//
//  Arguments:  [pwcPathOrName]  -- Root of the catalog or friendly name
//
//  History:    07-May-92   AmyA        Lifted from vquery.cxx
//              22-May-92   AmyA        Added TRY/CATCH
//              02-Jun-92   KyleP       Added UNC support.
//              12-Jun-92   KyleP       Lifted from citest.cxx
//              29-Sep-94   KyleP       Added ofs proxy support
//
//----------------------------------------------------------------------------

PCatalog * CCatArray::GetOne ( WCHAR const * pwcPathOrName )
{
    CClientDocStore * pDocStore = GetDocStore( pwcPathOrName );
    return pDocStore ? pDocStore->GetCiCat() : 0;
} //GetOne

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::GetNamedOne, public
//
//  Synopsis:   Returns a PCatalog by either using an existing catalog or
//              creating a new one.  Returns 0 if a catalog couldn't be
//              found or created.
//
//  Arguments:  [pwcPath]      -- Root of the catalog
//              [pwcName]      -- 0 or name of the catalog (optional param)
//
//  History:    12-Oct-96   dlee        created
//
//----------------------------------------------------------------------------

PCatalog * CCatArray::GetNamedOne(
    WCHAR const * pwcPath,
    WCHAR const * pwcName,
    BOOL fOpenForReadOnly,
    BOOL fNoQuery )
{
    CClientDocStore * pDocStore = GetNamedDocStore( pwcPath, pwcName, fOpenForReadOnly );
    if ( pDocStore )
    {
        if ( fNoQuery )
            pDocStore->SetNoQuery();
        else
            pDocStore->UnSetNoQuery();
    }

    return pDocStore ? pDocStore->GetCiCat() : 0;
} //GetNamedOne

//+-------------------------------------------------------------------------
//
//  Member:     AddStoppedCat, public
//
//  Synopsis:   Add an item of COldCatState into the _aStopCatalogs array
//
//  Arguments:  [dwOldState] -- Old state of a docstore
//              [wcsCatName] -- Catalog name of the docstore
//              [wcVol] -- Letter of the volume on which the catalog resides
//
//  History:    07-July-98 KitmanH    Created
//              10-July-98 KitmanH    Don't add an item with same CatName
//                                    more than once
//              23-July-98 KitmanH    Add volume letter on which the catalog
//                                    resides
//
//--------------------------------------------------------------------------

void CCatArray::AddStoppedCat( DWORD dwOldState,
                               WCHAR const * wcsCatName,
                               WCHAR wcVol )
{
    XPtrST<COldCatState> xOldState( new COldCatState( dwOldState,
                                                      wcsCatName,
                                                      wcVol) );

    CLock lockx( _mutex );
    _aStoppedCatalogs.Add( xOldState.GetPointer(), _aStoppedCatalogs.Count() );
    xOldState.Acquire();
} //AddStoppedCat

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::LokFindCat, private
//
//  Synopsis:   returns the index of the catalog in the _aStoppedcatalogs
//              Array
//
//  Arguments:  [wcsCatName] -- name of the catalog
//
//  History:    23-July-98 KitmanH    Created
//
//--------------------------------------------------------------------------

DWORD CCatArray::FindCat( WCHAR const * wcsCatName )
{
    Win4Assert( _mutex.IsHeld() );

    for ( unsigned i = 0; i < _aStoppedCatalogs.Count(); i++ )
    {
        COldCatState * pOldState = _aStoppedCatalogs.Get(i);

        if ( !(_wcsicmp( pOldState->GetCatName(), wcsCatName ) ) )
            return i;
    }

    return -1;
} //FindCat

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::GetOldState, public
//
//  Synopsis:   returns the old state of a catalog before the volume was locked
//
//  Arguments:  [wcsCatName] -- catalog name
//
//  Returns:    old state of a catalog
//
//  History:    07-July-98 KitmanH    Created
//
//--------------------------------------------------------------------------

DWORD CCatArray::GetOldState( WCHAR const * wcsCatName )
{
    CLock lockx( _mutex );
    DWORD i = FindCat(wcsCatName);

    if ( -1 != i )
        return (_aStoppedCatalogs.Get(i)->GetOldState() );
    else
        return -1;
} //GetOldState

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::RmFromStopArray, public
//
//  Synopsis:   remove the catalog from the stop array
//
//  Arguments:  [wcsCatName] -- name of the catalog
//
//  History:    05-May-98 KitmanH    Created
//
//--------------------------------------------------------------------------

void CCatArray::RmFromStopArray( WCHAR const * wcsCatName )
{
    CLock lockx( _mutex );
    DWORD i = FindCat( wcsCatName );

    if ( -1 != i )
    {
        delete _aStoppedCatalogs.Get(i);
        _aStoppedCatalogs.Remove(i);
        ciDebugOut(( DEB_ITRACE, "Catalog %ws is deleted from Array\n",
                     wcsCatName ));
    }
} //RmFromStopArray

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::IsCatStopped, public
//
//  Synopsis:   check if the catalog has been stopped
//
//  Arguments:  [wcsCatName] -- name of the catalog
//
//  History:    05-May-98 KitmanH    Created
//
//--------------------------------------------------------------------------

BOOL CCatArray::IsCatStopped( WCHAR const * wcsCatName )
{
    CLock lockx( _mutex );
    DWORD i = FindCat( wcsCatName );

    if ( -1 != i )
    {
        ciDebugOut(( DEB_ITRACE, "Catalog %ws is Stopped\n", wcsCatName ));
        return TRUE;
    }
    else
        return FALSE;
} //IsCatStopped

//+-------------------------------------------------------------------------
//
//  Member:     ClearStopArray, public
//
//  Synopsis:   clear the contents in the _aStoppedCatalogs array
//
//  History:    05-May-98 KitmanH    Created
//              08-July-98 KitmanH   ReWrited
//
//  Note:       _aStoppedCatalogs now stores the old state with the cat name
//
//--------------------------------------------------------------------------

void CCatArray::ClearStopArray()
{
    CLock lockx( _mutex );

    for ( unsigned i = 0; i < _aStoppedCatalogs.Count(); i++ )
    {
        ciDebugOut(( DEB_ITRACE, "ClearStopArray: i is %d\n", i ));
        COldCatState * pOldState = _aStoppedCatalogs.Get(i);
        delete pOldState;
    }

    _aStoppedCatalogs.Clear();
} //ClearStopArray

//+-------------------------------------------------------------------------
//
//  Member:     CCatArray::IncStopCount, public
//
//  Synopsis:   Increment the _cStopCount and set the appropriate element
//              in the volume array
//
//  Arguments:  [wcsCatName] -- name of the catalog
//              [wcVol] -- volume letter
//
//  History:    24-Aug-98 KitmanH    Created
//
//--------------------------------------------------------------------------

BOOL CCatArray::IncStopCount( WCHAR const * wcsCatName, WCHAR wcVol )
{
    ciDebugOut(( DEB_ITRACE, "IncStopCount %wc\n", wcVol ));
    CLock lockx( _mutex );

    DWORD i = FindCat( wcsCatName );

    if ( -1 != i )
    {
        COldCatState * pOldState = _aStoppedCatalogs.Get(i);
        pOldState->IncStopCountAndSetVol( wcVol );
        return TRUE;
    }
    else
        return FALSE;
} //IncStop

//+-------------------------------------------------------------------------
//
//  Funtion:    DriveHasCatalog
//
//  Synopsis:   Checks if there is a catalog.wci directory on the root
//              of the volume.
//
//  Arguments:  [wc] -- the volume to check
//
//  History:    16-Apr-99 dlee    Created
//
//--------------------------------------------------------------------------

BOOL DriveHasCatalog( WCHAR wc )
{
    BOOL fCat = FALSE;

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = wc;

    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

    if ( hVolume != INVALID_HANDLE_VALUE )
    {
        SWin32Handle xHandleVolume( hVolume );

        //
        // Is there media in the drive?  This check avoids possible hard-error
        // popups prompting for media.
        //

        ULONG ulSequence;
        DWORD cb = sizeof(ULONG);

        BOOL fOk = DeviceIoControl( hVolume,
                                    IOCTL_STORAGE_CHECK_VERIFY,
                                    0,
                                    0,
                                    &ulSequence,
                                    sizeof(ulSequence),
                                    &cb,
                                    0 );

        if ( fOk )
        {
            WCHAR awcCatDir[ MAX_PATH ];
            wcscpy( awcCatDir, L"c:\\" );
            wcscat( awcCatDir, CAT_DIR ); // catalog.wci
            awcCatDir[0] = wc;

            WIN32_FILE_ATTRIBUTE_DATA fData;
            if ( GetFileAttributesEx( awcCatDir, GetFileExInfoStandard, &fData ) )
            {
                // Is the catalog path a file or a directory?

                fCat = ( 0 != ( fData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) );
            }
        }

    }

    ciDebugOut(( DEB_ITRACE, "catalog on drive %wc? %s\n", wc, fCat ? "yes" : "no" ));

    return fCat;
} //DriveHasCatalog

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::TryToStartCatalogOnRemovableVol
//
//  Synopsis:   Attempts to open a catalog on the root of the volume.
//
//  Arguments:  [wcVol]     -- Volume letter
//              [pRequestQ] -- Pointer to the RequestQueue
//
//  History:    16-Apr-99 dlee    Created
//
//----------------------------------------------------------------------------

void CCatArray::TryToStartCatalogOnRemovableVol(
    WCHAR           wcVol,
    CRequestQueue * pRequestQ )
{
    Win4Assert( IsRemovableDrive( wcVol ) );

    if ( DriveHasCatalog( wcVol ) )
    {
        ciDebugOut(( DEB_ITRACE, "opening temporary catalog\n" ));

        // Make the registry entries

        CRemovableCatalog cat( wcVol );
        cat.Create();

        WCHAR awcName[MAX_PATH];
        cat.MakeCatalogName( awcName );
        CClientDocStore *p = GetDocStore( awcName, FALSE );
    }
} //TryToStartCatalogOnRemovableVol

//+---------------------------------------------------------------------------
//
//  Member:     CCatArray::StartCatalogsOnVol
//
//  Synopsis:   Restore all catalogs on the volume specified to its previous
//              state before the volume was locked.
//
//  Arguments:  [wcVol] -- Volume letter
//              [pRequestQ] -- Pointer to the RequestQueue
//
//  History:    09-03-98    kitmanh   Created
//
//----------------------------------------------------------------------------

void CCatArray::StartCatalogsOnVol( WCHAR wcVol, CRequestQueue * pRequestQ )
{
    ciDebugOut(( DEB_ITRACE, "StartCatalogsOnVol %wc\n", wcVol ));
    CLock lock( _mutex );

    SCWorkItem newItem;
    RtlZeroMemory( &newItem, sizeof newItem );

    BOOL fOpenedCatalogs = FALSE;

    for ( unsigned i = 0 ; i < _aStoppedCatalogs.Count(); i++ )
    {
        COldCatState * pOldCatState = _aStoppedCatalogs.Get(i);

        if (  pOldCatState->IsVolSet( wcVol ) )
        {
            if ( 1 == pOldCatState->GetStopCount() )
            {
                ciDebugOut(( DEB_ITRACE, "Catalog %ws : pOldCatState->GetStopCount() is == 1\n",
                             pOldCatState->GetCatName() ));

                WCHAR const * awcName = pOldCatState->GetCatName();

                DWORD dwOldState = pOldCatState->GetOldState();

                if ( -1 != dwOldState )
                {
                    ciDebugOut(( DEB_ITRACE, "dwOldState for %ws is %d\n", awcName, dwOldState ));
                    fOpenedCatalogs = TRUE;

                    if ( !( (CICAT_READONLY & dwOldState) ||
                            (CICAT_STOPPED & dwOldState) ) )
                    {
                        if ( 0 != (CICAT_NO_QUERY & dwOldState) )
                        {
                            newItem.type = eNoQuery;
                            newItem.fNoQueryRW = TRUE;
                        }
                        else if ( 0 != (CICAT_WRITABLE & dwOldState) )
                        {
                            newItem.type = eCatW;
                        }
                        else
                        {
                            Win4Assert( !"Undefined CICAT state" );
                        }

                        newItem.pDocStore = 0;
                        pRequestQ->AddSCItem( &newItem, awcName );
                    }
                    else if ( 0 != (CICAT_READONLY & dwOldState) ) //readonly
                    {
                        newItem.type = eCatRO;
                        newItem.pDocStore = 0;
                        pRequestQ->AddSCItem( &newItem, awcName );
                    }
                }
            }
            else
            {
                ciDebugOut(( DEB_ITRACE, "Catalog %ws: pOldCatState->GetStopCount() is %d\n",
                             pOldCatState->GetCatName(), pOldCatState->GetStopCount() ));

                Win4Assert( 1 < pOldCatState->GetStopCount() );
                // Decreament stopcount
                pOldCatState->UnSetVol( wcVol );
                pOldCatState->DecStopCount();
            }
        }
    }

    //
    // If we didn't open any catalogs on the volume and it's a removable
    // volume with a catalog.wci directory in the root, make a temporary
    // entry in the registry and open the catalog read-only.  Close the
    // catalog and remove the registry entries when the volume is ejected.
    //

    if ( !fOpenedCatalogs )
    {
        if ( IsRemovableDrive( wcVol ) && DriveHasCatalog( wcVol ) )
        {
            ciDebugOut(( DEB_ITRACE, "trying to opening temporary catalog\n" ));

            // Make the registry entries

            CRemovableCatalog cat( wcVol );
            cat.Create();

            // Tell the request queue to open the catalog

            newItem.type = eCatRO;
            newItem.pDocStore = 0;
            newItem.fNoQueryRW = FALSE;
            WCHAR awcName[MAX_PATH];
            cat.MakeCatalogName( awcName );
            newItem.StoppedCat = awcName;
            pRequestQ->AddSCItem( &newItem, awcName );
        }
        else
        {
            //
            // File a null work item so the request queue won't close
            // connections to all query clients.
            //

            newItem.type = eNoCatWork;
            pRequestQ->AddSCItem( &newItem, L"" );
        }
    }
} //StartCatalogsOnVol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\wregion.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       wregion.cxx
//
//  Contents:   Watch region list
//
//  Classes:    CWatchRegion
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <wregion.hxx>
#include <seglist.hxx>

#include "tblwindo.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CWatchRegion::CWatchRegion
//
//  Synopsis:   Assign default values
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

CWatchRegion::CWatchRegion ( ULONG mode)
: _mode (mode),
  _chapter(0),
  _bookmark(0),
  _cRows(0),
  _pSegment (0)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::CWatchList
//
//  Synopsis:   Initialize
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

CWatchList::CWatchList(CTableSegList& segList)
    : _segList(segList)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::~CWatchList
//
//  Synopsis:   Deletes all watch regions
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

CWatchList::~CWatchList ()
{
    CWatchRegion* p;
    while ( (p = _list.Pop()) != 0)
        delete p;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::NewRegion
//
//  Synopsis:   Create new empty region
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

HWATCHREGION CWatchList::NewRegion (ULONG mode)
{
    CWatchRegion* pRegion = new CWatchRegion(mode);
    _list.Add (pRegion);
    return (HWATCHREGION) pRegion;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::ChangeMode
//
//  Synopsis:   Change region mode
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CWatchList::ChangeMode ( HWATCHREGION hRegion, ULONG mode )
{
    CWatchRegion* pRegion = FindVerify (hRegion);
    pRegion->SetMode (mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::GetInfo, private
//
//  Synopsis:   GetInfo about a watch region
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CWatchList::GetInfo (HWATCHREGION hRegion,
              CI_TBL_CHAPT* pChapter,
              CI_TBL_BMK* pBookmark,
              DBCOUNTITEM* pcRows)
{
    CWatchRegion* pRegion = FindVerify (hRegion);
    *pChapter = pRegion->Chapter();
    *pBookmark = pRegion->Bookmark();
    *pcRows = pRegion->RowCount();
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::BuildRegion
//
//  Synopsis:   Build watch region
//
//  History:    22-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------
void CWatchList::BuildRegion (  HWATCHREGION hRegion,
                        CTableSegment* pSegment,
                        CI_TBL_CHAPT   chapter,
                        CI_TBL_BMK     bookmark,
                        LONG cRows )
{
    Win4Assert (cRows > 0);
    CWatchRegion* pRegion = FindVerify (hRegion);
    pRegion->SetSegment(pSegment);
    pRegion->Set (chapter, bookmark, cRows);
    CDoubleTableSegIter iter (pSegment);
    CTableWindow* pWindow = iter.GetWindow();

    // Add watch to the first window in series
    int cRowsAdded;
    if (bookmark == WORKID_TBLFIRST)
    {
        cRowsAdded = pWindow->AddWatch (hRegion, 0, cRows, _segList.IsLast(iter));
    }
    else
    {
        TBL_OFF off;
        ULONG uiStart;
        if ( !pWindow->FindBookMark( bookmark, off, uiStart))
        {
            Win4Assert (!"CWatchList::BuildRegion, bookmark not found" );
        }

        cRowsAdded = pWindow->AddWatch (hRegion, (long)uiStart, cRows, _segList.IsLast(iter));
    }

    while (cRowsAdded < cRows)
    {
        // continue through another segment
        _segList.Advance(iter);
        Win4Assert ( iter.GetSegment()->IsWindow());
        pWindow = iter.GetWindow();
        cRowsAdded += pWindow->AddWatch (hRegion, 0, cRows - cRowsAdded, _segList.IsLast(iter));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::DeleteRegion
//
//  Synopsis:   Delete watch region
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CWatchList::DeleteRegion (HWATCHREGION hRegion)
{
    ShrinkRegionToZero (hRegion);
    CWatchRegion* pRegion = GetRegion(hRegion);
    pRegion->Unlink();
    delete pRegion;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::ShrinkRegionToZero
//
//  Synopsis:   Shrink watch region to zero but don't delete it
//              (e.g., prepare to move the region discontinuously)
//
//  History:    27-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CWatchList::ShrinkRegionToZero (HWATCHREGION hRegion)
{
    CWatchRegion* pRegion = FindVerify (hRegion);

    if (pRegion->Segment())
    {
        CDoubleTableSegIter iter (pRegion->Segment());
        long cRowsLeft = pRegion->RowCount();
        do
        {
            CTableWindow* pWindow = iter.GetWindow();
            cRowsLeft -= pWindow->DeleteWatch (pRegion->Handle());

            if (cRowsLeft <= 0 )
                break;
            _segList.Advance(iter);
        } while (!_segList.AtEnd(iter));
    }

    pRegion->SetSegment(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::ShrinkRegion
//
//  Synopsis:   Shrink watch region
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CWatchList::ShrinkRegion ( HWATCHREGION hRegion,
                    CI_TBL_CHAPT   chapter,
                    CI_TBL_BMK     bookmark,
                    LONG cRows )
{
    // Werify arguments

    if (cRows < 0)
    {
        THROW (CException(E_INVALIDARG));
    }
    else if ( cRows == 0)
    {
        DeleteRegion (hRegion);
        return;
    }

    // BROKENCODE: verify validity of chapter / bookmark

    CWatchRegion* pRegion = FindVerify (hRegion);
    long cRowsLeft = pRegion->RowCount();
    if (cRows > cRowsLeft)
    {
        THROW (CException(DB_E_NOTASUBREGION));
    }

    // Find starting window of the old region

    if (pRegion->Segment() == 0)
        THROW (CException(E_INVALIDARG));
    CDoubleTableSegIter iter (pRegion->Segment());

    // find starting window of the new region

    CTableWindow* pWindowBmk = 0;

    if (bookmark == WORKID_TBLFIRST)
    {
        CTableSegment* pSeg = _segList.GetTop();
        if (!pSeg->IsWindow())
        {
            THROW (CException(DB_E_NOTASUBREGION));
        }
        pWindowBmk = (CTableWindow*) pSeg;
    }
    else
    {
        CDoubleTableSegIter iter2 (iter.GetSegment()); // clone it
        do
        {
            if ( iter2.GetSegment()->IsRowInSegment( bookmark ) )
                break;
            _segList.Advance(iter2);
        } while (!_segList.AtEnd(iter2));

        if (_segList.AtEnd(iter2))
        {
            THROW (CException(DB_E_NOTASUBREGION));
        }

        pWindowBmk = iter2.GetWindow();

        if (!pWindowBmk->IsWatched (hRegion, bookmark))
        {
            THROW (CException(DB_E_NOTASUBREGION));
        }
    }

    // Real work starts here
    // we know that the bookmark is within the old watch region
    // delete watch regions before the bookmark

    CTableWindow* pWindow = iter.GetWindow();
    while ( pWindow != pWindowBmk)
    {
        cRowsLeft -= pWindow->DeleteWatch (hRegion);
        Win4Assert (cRowsLeft > 0);
        _segList.Advance(iter);
        Win4Assert (!_segList.AtEnd(iter));
        pWindow = iter.GetWindow();
    }

    // Beginning of new region

    pRegion->SetSegment (pWindow);

    // Shrink the watch in the first window in series
    long cRowsInRegion = 0;

    cRowsInRegion = pWindow->ShrinkWatch( hRegion, bookmark, cRows );

    // continue through windows that will stay in the watch region

    while (cRowsInRegion < cRows)
    {
        _segList.Advance(iter);

        if (_segList.AtEnd(iter)
            || !iter.GetSegment()->IsWindow()
            || !iter.GetWindow()->HasWatch(hRegion))
        {
            // Leave in consistent state
            pRegion->Set (chapter, bookmark, cRowsInRegion);
            THROW (CException(DB_E_NOTASUBREGION));
        }

        // the watch continues in this window
        pWindow = iter.GetWindow();
        cRowsInRegion += pWindow->RowsWatched (hRegion);
    }

    // Shrink the last segment of the new watch region

    if (cRowsInRegion > cRows)
    {
        long cDelta = cRowsInRegion-cRows;
        long cRowsRemaining = pWindow->RowsWatched(hRegion) - cDelta;
        Win4Assert( cRowsRemaining > 0 );

        pWindow->ShrinkWatch( hRegion, cRowsRemaining);        
    }

    pRegion->Set (chapter, bookmark, cRows);

    // delete the rest of the old watch region

    for ( _segList.Advance(iter);
           !_segList.AtEnd(iter)
           && iter.GetSegment()->IsWindow()
           && iter.GetWindow()->HasWatch(hRegion);
          _segList.Advance(iter) )
    {
        // the watch continues in this window
        iter.GetWindow()->DeleteWatch (hRegion);
    }

#if CIDBG==1
    CheckRegionConsistency( pRegion );
#endif  // CIDBG==1

}


//+---------------------------------------------------------------------------
//
//  Function:   FindRegion
//
//  Synopsis:
//
//  Arguments:  [hRegion] -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-05-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CWatchRegion * CWatchList::FindRegion(HWATCHREGION hRegion)
{
    for (CWatchIter iter(_list); !_list.AtEnd(iter); _list.Advance(iter))
    {
        if (iter->IsEqual(hRegion))
            break;
    }

    if (_list.AtEnd(iter))
    {
        return 0;
    }
    else
    {
        return iter.Get();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CWatchList::FindVerify
//
//  Synopsis:   Find watch region, throw if not found
//
//  History:    20-Jun-95   BartoszM    Created
//
//--------------------------------------------------------------------------

CWatchRegion* CWatchList::FindVerify (HWATCHREGION hRegion)
{
    CWatchRegion * pRegion = FindRegion( hRegion );

    if ( 0 != pRegion )
    {
        return pRegion;
    }
    else
    {
        THROW (CException(DB_E_BADREGIONHANDLE));
    }

    return 0;   // Keep the compiler happy
}


//+---------------------------------------------------------------------------
//
//  Member:     CWatchRegion::UpdateSegment
//
//  Synopsis:   Updates the segment in the region to point to the new one
//              if the current one is same as pOld.
//
//  Arguments:  [pOld] - 
//              [pNew] - 
//
//  History:    8-16-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CWatchRegion::UpdateSegment( CTableSegment * pOld,
                                  CTableWindow *pNew,
                                  CI_TBL_BMK bmkNew )
{
    Win4Assert( 0 != pNew );

    if ( _pSegment == pOld )
    {
        Win4Assert( pNew->HasWatch( Handle()) );
        _pSegment = pNew;

        // NEWFEATURE - how about chapter ??
        
        _bookmark = bmkNew;
    }
}

#if CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CWatchList::CheckRegionConsistency
//
//  Synopsis:   Checks that the length of the region as stored in the
//              region is same as the cumulative length of all the watch
//              in the windows.
//
//  Arguments:  [pRegion] - Region which must be checked.
//
//  History:    8-16-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CWatchList::CheckRegionConsistency( CWatchRegion * pRegion )
{
    if ( 0 != pRegion && 0 != pRegion->Segment() )
    {
        HWATCHREGION hRegion = pRegion->Handle();

        CDoubleTableSegIter iter( pRegion->Segment() );
        for ( long cRegionLen = 0;
              !_segList.AtEnd(iter) &&
              iter.GetSegment()->IsWindow() &&
              iter.GetWindow()->HasWatch(hRegion);
              _segList.Advance(iter) )
        {
            CTableWindow * pWindow = iter.GetWindow();
            long cRowsInWindow = pWindow->RowsWatched(hRegion);
            Win4Assert( cRowsInWindow >= 0 );
            cRegionLen += cRowsInWindow;        
        }

        Win4Assert( cRegionLen == pRegion->RowCount() );
    }
}

#endif  // CIDBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\catreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       catreg.cxx
//
//  Contents:   Catalog registry helper classes
//
//  History:    13-Dec-1996   dlee  split from cicat.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <lm.h>

#include <ciregkey.hxx>
#include <regacc.hxx>
#include <pathpars.hxx>
#include <regscp.hxx>
#include <cimbmgr.hxx>
#include <lcase.hxx>

#include "cicat.hxx"
#include "cinulcat.hxx"
#include "catreg.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CIISVirtualDirectories::CallBack, public
//
//  Synopsis:   Adds a virtual directory to the list
//
//  Arguments:  [pwcIISVPath] -- Virtual Root
//              [pwcIISPPath] -- Physical path of vroot
//              [fIsIndexed]  -- TRUE if vroot should be indexed
//              [dwAccess]    -- IIS access permissions
//              [pwcUser]     -- Username for logons if pwcPRoot is a UNC
//              [pwcPassword] -- Password for logons if pwcPRoot is a UNC
//              [fIsAVRoot]   -- TRUE if a vroot, FALSE if a vpath
//
//  History:    2-Sep-97 dlee     Created
//
//--------------------------------------------------------------------------

SCODE CIISVirtualDirectories::CallBack(
    WCHAR const * pwcIISVPath,
    WCHAR const * pwcIISPPath,
    BOOL          fIsIndexed,
    DWORD         dwAccess,
    WCHAR const * pwcUser,
    WCHAR const * pwcPassword,
    BOOL          fIsAVRoot )
{
    ciDebugOut(( DEB_ITRACE, "CII::CB '%ws' '%ws', %d, %#x, %d\n",
                 pwcIISVPath,
                 pwcIISPPath,
                 fIsIndexed,
                 dwAccess,
                 fIsAVRoot ));

    BOOL fReadable = ( 0 != ( dwAccess & MD_ACCESS_READ ) );

    //
    // Treat unreadable paths the same as nonindexed paths
    //

    if ( !fReadable )
    {
        fIsIndexed = FALSE;
        fReadable = TRUE;
    }

    //
    // Ignore vdirs that are indexed -- they are indexed by the vroot
    // under which they fall.
    //

    if ( !fIsAVRoot && fIsIndexed )
        return STATUS_SUCCESS;

    CLowcaseBuf lcPPath( pwcIISPPath );

    WCHAR * pwcPRoot = lcPPath.GetWriteable();
    unsigned cwcPRoot = lcPPath.Length();

    BOOL fValidPRoot = FALSE;

    if (cwcPRoot >= 3 &&
        pwcPRoot[1] == L':' &&
        pwcPRoot[2] == L'\\')
    {
        fValidPRoot = TRUE;
    }
    else if ( cwcPRoot == 2 &&
              pwcPRoot[1] == L':' )
    {
        // Treat this as the root of the drive. Append a backslash.

        pwcPRoot[2] = L'\\';
        cwcPRoot++;
        pwcPRoot[cwcPRoot] = 0;
        fValidPRoot = TRUE;
    }
    else if ( CiCat::IsUNCName( pwcPRoot ) )
    {
        fValidPRoot = TRUE;
    }

    //
    // This is probably obsolete in the metabase world:
    // Flip slashes.  Believe it or not, Gibraltar allows physical paths to
    // have slashes in place of backslashes.
    //

    lcPPath.ForwardToBackSlash();

    //
    // Remove the trailing backslash if it exists
    //

    if ( cwcPRoot > 3 && L'\\' == pwcPRoot[ cwcPRoot - 1 ] )
    {
        cwcPRoot--;
        pwcPRoot[ cwcPRoot ] = 0;
    }

    //
    // Remember the root if it's valid
    //

    if ( fValidPRoot )
    {
        CLowcaseBuf lcVPath( pwcIISVPath );
        lcVPath.ForwardToBackSlash();

        WCHAR * pwcVRoot = lcVPath.GetWriteable();
        unsigned cwcVRoot = lcVPath.Length();

        XPtr<CIISVirtualDirectory> xvdir( new CIISVirtualDirectory( pwcVRoot,
                                                                    pwcPRoot,
                                                                    fIsIndexed,
                                                                    dwAccess,
                                                                    pwcUser,
                                                                    pwcPassword,
                                                                    fIsAVRoot ) );
        _aDirectories.Add( xvdir.GetPointer(), _aDirectories.Count() );
        _htDirectories.Add( xvdir.GetPointer() );
        xvdir.Acquire();
    }

    return S_OK;
} //CallBack

//+-------------------------------------------------------------------------
//
//  Member:     CIISVirtualDirectories::Lookup, public
//
//  Synopsis:   Looks for a virtual directory exact match in the list
//
//  Arguments:  [pwcVPath]  -- Virtual path
//              [cwcVPath]  -- # characters in pwcVPath
//              [pwcPPath]  -- Physical path
//              [cwcPPath]  -- # characters in pwcPPath
//
//  Returns:    TRUE if a match was found.
//
//  History:    2-Sep-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CIISVirtualDirectories::Lookup(
    WCHAR const * pwcVPath,
    unsigned      cwcVPath,
    WCHAR const * pwcPPath,
    unsigned      cwcPPath )
{
    CIISVirtualDirectory * pDir = _htDirectories.Lookup( pwcVPath );

    if ( 0 != pDir )
    {
        //
        // Physical paths don't have a terminating backslash.  They
        // are stripped by the callback unless it's a drive root like x:\
        // OR for input pwcVPath a unc root like \\machine\share\
        //

        if ( ( cwcPPath > 3 ) &&
             ( L'\\' == pwcPPath[ cwcPPath - 1 ] ) )
            cwcPPath--;

        Win4Assert( 3 == cwcPPath ||
                    L'\\' != pwcPPath[ cwcPPath - 1 ] );

        Win4Assert( 3 == pDir->PPathLen() ||
                    L'\\' != pDir->PPath()[ pDir->PPathLen() - 1 ] );

        if ( cwcPPath == pDir->PPathLen() &&
             RtlEqualMemory( pwcPPath, pDir->PPath(), cwcPPath * sizeof WCHAR ) )
            return TRUE;
    }

    return FALSE;
} //Lookup

//+-------------------------------------------------------------------------
//
//  Member:     CIISVirtualDirectories::Enum, public
//
//  Synopsis:   Adds directories in the list to the catalog
//
//  Arguments:  [cicat]  -- The catalog into which vdirs are added
//
//  History:    2-Sep-97 dlee     Created
//
//--------------------------------------------------------------------------

void CIISVirtualDirectories::Enum( CiCat & cicat )
{
    for ( unsigned i = 0; i < _aDirectories.Count(); i++ )
    {
        CIISVirtualDirectory & vdir = * _aDirectories[i];

        ciDebugOut(( DEB_WARN,
                     "adding %s %s %ws %s '%ws', proot '%ws'\n",
                     ( MD_ACCESS_READ & vdir.Access() ) ? "readable" : "unreadable",
                     vdir.IsIndexed() ? "indexed" : "non-indexed",
                     GetVRootService( _eType ),
                     vdir.IsAVRoot() ? "vroot" : "vpath",
                     vdir.VPath(),
                     vdir.PPath() ));

        cicat.AddVirtualScope( vdir.VPath(),
                               vdir.PPath(),
                               TRUE,
                               _eType,
                               vdir.IsAVRoot(),
                               vdir.IsIndexed() );
    }
} //Enum

//+-------------------------------------------------------------------------
//
//  Member:     CIISVirtualDirectories::Enum, public
//
//  Synopsis:   Enumerates the directory list into the callback
//
//  Arguments:  [callback]  -- The callback for each directory
//
//  History:    2-Sep-97 dlee     Created
//
//--------------------------------------------------------------------------

void CIISVirtualDirectories::Enum( CMetaDataCallBack & callback )
{
    for ( unsigned i = 0; i < _aDirectories.Count(); i++ )
    {
        CIISVirtualDirectory & vdir = * _aDirectories[i];

        callback.CallBack( vdir.VPath(),
                           vdir.PPath(),
                           vdir.IsIndexed(),
                           vdir.Access(),
                           vdir.User(),
                           vdir.Password(),
                           vdir.IsAVRoot() );
    }
} //Enum

//+-------------------------------------------------------------------------
//
//  Member:     CIISVirtualDirectory::CIISVirtualDirectory, public
//
//  Synopsis:   Constructs a vdir object
//
//  Arguments:  [pwcVPath]     -- The virtual path
//              [pwcPPath]     -- The physical path
//              [fIsIndexed]   -- TRUE if indexed
//              [dwAccess]     -- access mask
//              [pwcUser]      -- The domain\username
//              [pwcPassword]  -- The password for logons
//              [fIsAVRoot]    -- TRUE if a root, FALSE if a directory
//              [fIsIndexed]   -- TRUE if indexed, FALSE otherwise
//
//  History:    2-Sep-97 dlee     Created
//
//--------------------------------------------------------------------------

CIISVirtualDirectory::CIISVirtualDirectory(
    WCHAR const * pwcVPath,
    WCHAR const * pwcPPath,
    BOOL          fIsIndexed,
    DWORD         dwAccess,
    WCHAR const * pwcUser,
    WCHAR const * pwcPassword,
    BOOL          fIsAVRoot ) :
    _fIsIndexed( fIsIndexed ),
    _dwAccess( dwAccess ),
    _fIsAVRoot( fIsAVRoot ),
    _pNext( 0 )
{
    _cwcVPath = wcslen( pwcVPath );
    XArray<WCHAR> xVPath( _cwcVPath + 1 );
    RtlCopyMemory( xVPath.GetPointer(), pwcVPath, xVPath.SizeOf() );
    _xVPath.Set( xVPath.Acquire() );

    _cwcPPath = wcslen( pwcPPath );
    XArray<WCHAR> xPPath( _cwcPPath + 1 );
    RtlCopyMemory( xPPath.GetPointer(), pwcPPath, xPPath.SizeOf() );
    _xPPath.Set( xPPath.Acquire() );

    unsigned cwcUser = 1 + wcslen( pwcUser );
    XArray<WCHAR> xUser( cwcUser );
    RtlCopyMemory( xUser.GetPointer(), pwcUser, xUser.SizeOf() );
    _xUser.Set( xUser.Acquire() );

    unsigned cwcPassword = 1 + wcslen( pwcPassword );
    XArray<WCHAR> xPassword( cwcPassword );
    RtlCopyMemory( xPassword.GetPointer(), pwcPassword, xPassword.SizeOf() );
    _xPassword.Set( xPassword.Acquire() );
} //CIISVirtualDirectory

//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackRemoveAlias::CRegistryScopesCallBackRemoveAlias, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [Cat]        -- Catalog
//              [dlNetApi32] -- Dynamically loaded NetApi32 (for performance)
//              [fRemoveAll] -- TRUE if *all* aliases should be deleted.
//
//  History:    13-Jun-1998  KyleP  Created
//
//--------------------------------------------------------------------------

CRegistryScopesCallBackRemoveAlias::CRegistryScopesCallBackRemoveAlias( CiCat & Cat,
                                                                        CDynLoadNetApi32 & dlNetApi32,
                                                                        BOOL fRemoveAll )
        : _cicat( Cat ),
          _dlNetApi32( dlNetApi32 ),
          _fScopeRemoved( FALSE ),
          _fRemoveAll( fRemoveAll )
{
    _ccCompName = sizeof(_wcsCompName)/sizeof(WCHAR);

    if ( !GetComputerName(  &_wcsCompName[0], &_ccCompName ) )
    {
        ciDebugOut(( DEB_ERROR, "Error %u from GetComputerName\n", GetLastError() ));

        THROW( CException() );
    }
} //CRegistryScopesCallBackRemoveAlias

//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackRemoveAlias::Callback
//
//  Synopsis:   Registry callback routine.  Removes unneeded fixups.
//
//  Arguments:  [pValueName]   -- Scope
//              [uValueType]   -- REG_SZ
//              [pValueData]   -- Fixup, flags, etc.
//              [uValueLength] -- Length
//
//  History:    13-Jun-1998  KyleP  Created
//
//--------------------------------------------------------------------------

NTSTATUS CRegistryScopesCallBackRemoveAlias::CallBack( WCHAR *pValueName,
                                                       ULONG uValueType,
                                                       VOID *pValueData,
                                                       ULONG uValueLength )
{
    CParseRegistryScope parse( pValueName,
                               uValueType,
                               pValueData,
                               uValueLength );

    if ( parse.IsShadowAlias() )
    {
        //
        // Does it still exist?
        //

        BYTE * pbShareInfo;

        DWORD dwError = _dlNetApi32.NetShareGetInfo( _wcsCompName,                                // Server
                                                     (WCHAR *)parse.GetFixup() + _ccCompName + 3, // Share (un-const, ugh)
                                                     2,                                           // Level 2
                                                     &pbShareInfo );                              // Result

        if ( _fRemoveAll || NO_ERROR != dwError )
        {
            //
            // Note that removing a share based on a bogus error code (out-of-memory, etc.)
            // is not too bad an error.  The fixup will be readded later.
            //

            ciDebugOut(( DEB_ITRACE, "Removing alias %ws\n", parse.GetFixup() ));

            _cicat.GetScopeFixup()->Remove( parse.GetScope(), parse.GetFixup() );
            _cicat.DeleteIfShadowAlias( parse.GetScope(), parse.GetFixup() );

            //
            // Set flag.  I'm not sure if we are guaranteed to examine everything after
            // a change has been made.  We're modifying the scope we're iterating over.
            //

            _fScopeRemoved = TRUE;
        }
        else
            _dlNetApi32.NetApiBufferFree( pbShareInfo );
    }

    return STATUS_SUCCESS;
} //CallBack

//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackAdd::Callback
//
//  Synopsis:   Registry callback routine.  Adds scopes.
//
//  Arguments:  [pValueName]   -- Scope
//              [uValueType]   -- REG_SZ
//              [pValueData]   -- Fixup, flags, etc.
//              [uValueLength] -- Length
//
//  History:    13-Jun-1998  KyleP  Moved to .cxx file
//
//--------------------------------------------------------------------------

NTSTATUS CRegistryScopesCallBackAdd::CallBack( WCHAR *pValueName,
                                               ULONG uValueType,
                                               VOID *pValueData,
                                               ULONG uValueLength )
{
    // if the value isn't a string, ignore it.

    if ( REG_SZ == uValueType )
    {
        ciDebugOut(( DEB_ITRACE, "callbackadd '%ws', '%ws'\n",
                     pValueName, pValueData ));

        CParseRegistryScope parse( pValueName,
                                   uValueType,
                                   pValueData,
                                   uValueLength );

        if ( parse.IsShadowAlias() )
            _cicat.GetScopeFixup()->Add( parse.GetScope(), parse.GetFixup() );
        else if ( parse.IsPhysical() )
        {
            // update the list of ignored scopes; either add or remove path

            BOOL fChange = _cicat._scopesIgnored.Update( parse.GetScope(),
                                                         parse.IsIndexed() );

            // Either add the scope or make sure it isn't in the list of
            // scopes being indexed.
            // If the scope is supposed to be indexed, only do a scan if
            // the state of indexing went from off to on.
            //
            // Only remove the scope if it used to be indexed, and now
            // its not or if this is startup.

            if ( parse.IsIndexed() )
                _cicat.ScanOrAddScope( parse.GetScope(),
                                       TRUE,
                                       UPD_INCREM,
                                       TRUE,
                                       fChange );

            else if ( fChange )
                _cicat.RemoveScopeFromCI( parse.GetScope(), TRUE );
        }

        if ( parse.IsPhysical() ||
             parse.IsVirtualPlaceholder() ||
             parse.IsShadowAlias() )
        {
            // add the fixup as well -- it may have changed

            if ( 0 != parse.GetFixup() )
            {
                ciDebugOut(( DEB_ITRACE,
                             "callbackAdd '%ws', fixup as '%ws'\n",
                             pValueName, parse.GetFixup() ));
                _cicat._scopeFixup.Add( parse.GetScope(), parse.GetFixup() );
            }
        }
    }

    return S_OK;
} //CallBack

//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackFillUsnArray::Callback
//
//  Synopsis:   Registry callback routine.  Popular the Usn volume array.
//
//  Arguments:  [pValueName]   -- Scope
//              [uValueType]   -- REG_SZ
//              [pValueData]   -- Fixup, flags, etc.
//              [uValueLength] -- Length
//
//  History:    23-Jun-1998  KitmanH  created
//
//--------------------------------------------------------------------------

NTSTATUS CRegistryScopesCallBackFillUsnArray::CallBack( WCHAR *pValueName,
                                                        ULONG uValueType,
                                                        VOID *pValueData,
                                                        ULONG uValueLength )
{
    // if the value isn't a string, ignore it.

    if ( REG_SZ == uValueType )
    {
        ciDebugOut(( DEB_ITRACE, "CallBackFillUsnArray '%ws', '%ws'\n",
                     pValueName, pValueData ));

        WCHAR  wcsPath[MAX_PATH+1];

        ULONG scopeLen = wcslen( pValueName );

        RtlCopyMemory( wcsPath, pValueName, (scopeLen+1) * sizeof(WCHAR) );
        TerminateWithBackSlash( wcsPath, scopeLen );

        CLowcaseBuf lcase( wcsPath );

        _cicat.VolumeSupportsUsns( lcase.Get()[0] );
    }

    return S_OK;
} //CallBack

//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackToDismount::Callback
//
//  Synopsis:   Registry callback routine. Check if the catlog contains a
//              scope that resides on a volume to be dismounted.
//
//  Arguments:  [pValueName]   -- Scope
//              [uValueType]   -- REG_SZ
//              [pValueData]   -- Fixup, flags, etc.
//              [uValueLength] -- Length
//
//  History:    21-Jul-1998  KitmanH  created
//
//--------------------------------------------------------------------------

NTSTATUS CRegistryScopesCallBackToDismount::CallBack( WCHAR *pValueName,
                                                      ULONG uValueType,
                                                      VOID *pValueData,
                                                      ULONG uValueLength )
{
    // if the value isn't a string, ignore it.

    if ( REG_SZ == uValueType )
    {
        ciDebugOut(( DEB_ITRACE, "CallBackToDismount: scope '%ws' for volume %wc\n",
                     pValueName, _wcVol ));

        if ( toupper(pValueName[0]) == toupper(_wcVol) )
        {
            _fWasFound = TRUE;
            ciDebugOut(( DEB_ITRACE, "CRegistryScopesCallBackToDismount: FOUND\n" ));
        }
    }

    return S_OK;
} //CallBack


//+-------------------------------------------------------------------------
//
//  Member:     CRegistryScopesCallBackAddDrvNotif::Callback
//
//  Synopsis:   Registry callback routine. Register the scopes for drive
//              notification
//
//  Arguments:  [pValueName]   -- Scope
//              [uValueType]   -- REG_SZ
//              [pValueData]   -- Fixup, flags, etc.
//              [uValueLength] -- Length
//
//  History:    19-Aug-1998  KitmanH  created
//
//--------------------------------------------------------------------------

NTSTATUS CRegistryScopesCallBackAddDrvNotif::CallBack( WCHAR *pValueName,
                                                       ULONG uValueType,
                                                       VOID *pValueData,
                                                       ULONG uValueLength )
{
    // if the value isn't a string, ignore it.

    if ( REG_SZ == uValueType )
    {
        ciDebugOut(( DEB_ITRACE, "CallBackAddDrvNotif for scope '%ws'\n", pValueName ));

        if ( L'\\' != pValueName[0] )
            _pNotifArray->AddDriveNotification( pValueName[0] );
    }

    return S_OK;
} //CallBack
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\chash.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000
//
//  File:       CHash.hxx
//
//  Contents:   Hash table
//
//  Classes:    CWidHashTable
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "chash.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::CWidHashTable, public
//
//  Synopsis:   Null constructor
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

CWidHashTable::CWidHashTable( BOOL fAggressiveGrowth )
        : _size (0),
          _table(0),
          _count(0),
          _fAggressiveGrowth( fAggressiveGrowth )
{
    Win4Assert( widInvalid == 0xFFFFFFFF );

#ifdef DO_STATS
    _cMaxChainLen  =  0;
    _cTotalSearches =  0;
    _cTotalLength = 0;
#endif  // DO_STATS
}

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::Init, public
//
//  Synopsis:   Initialize hash table
//
//  Arguments:  [count] -- Count of used elements
//              [size]  -- Size of [table]
//              [table] -- Hash table
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

void CWidHashTable::Init( ULONG count, ULONG size, WORKID * table )
{
    _count = count;
    _size = size;
    _table = table;
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::ReInit, public
//
//  Synopsis:   "ReInitialize" to empty state.
//
//  Arguments:  [count] -- Count of used elements
//              [size]  -- Size of [table]
//              [table] -- Hash table
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

void CWidHashTable::ReInit(ULONG count, ULONG size, WORKID* table )
{
    Init( count, size, table );

    Win4Assert( widInvalid == 0xFFFFFFFF );
    RtlFillMemory( _table, _size * sizeof(_table[0]), 0xFF );
} //ReInit

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::GrowSize, public
//
//  Synopsis:   Compute new size for table
//
//  Arguments:  [count] -- Count of to-be-used elements
//
//  Returns:    Suggested new size
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

unsigned CWidHashTable::GrowSize ( unsigned count )
{
    if ( count < 3 )
        return INIT_HASH_SIZE;

    if ( !_fAggressiveGrowth )
        return count * 2 - 1;

    // Make the hash table as large as possible without eathing too much
    // memory.  4 seems to work ok.
    // The hash table is deemed "full" in IsFull if half of the entries
    // are in use.
    // This is so aggressive in picking a new size because:
    //    - rehashing is expensive
    //    - walking on hash collisions is expensive
    //    - it's resized mostly on the initial scan, and there are probably
    //      a lot more files to be added soon.

    unsigned size = count * 4;

    // make it power of two + 1
    // a good approximation of a prime

    for ( unsigned sizeInit = 1; sizeInit < size; sizeInit *= 2 )
        continue;

    return sizeInit - 1;
} //GrowSize

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::Add, public
//
//  Synopsis:   Add a new entry
//
//  Arguments:  [hash] -- Best position for entry
//              [wid]  -- Workid (entry)
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

void CWidHashTable::Add ( unsigned hash, WORKID wid )
{
    Win4Assert ( !IsFull() );
    unsigned cur = hash % _size;
    unsigned start = cur;
    unsigned delta = Delta();

    // this loop has to terminate
    // since the table is NOT full!

    while ( _table[cur] != widInvalid && _table[cur] != widUnused )
    {
        cur = (cur + delta) % _size;
        if ( cur == start ) // wrapped around
        {
            Win4Assert( delta != 1 ); // table is full
            delta = 1;
            cur = (cur + 1) % _size;
        }
    }

    _count++;
    _table[cur] = wid;
} //Add

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::Remove, public
//
//  Synopsis:   Removes entry from table
//
//  Arguments:  [hash] -- Best position for entry
//              [wid]  -- Workid (entry)
//              [fDisableDeletionCheck] -- Should we assert that the deleted
//                                         entry must be found ?
//
//  History:    10-Jan-96   KyleP       Added header
//
//  Notes:      An entry is 'removed' by marking its slot as unused.  An
//              unused slot is like an empty slot, except it does not
//              terminate a CShortWidList.
//
//----------------------------------------------------------------------------

void CWidHashTable::Remove( unsigned hash,
                            WORKID wid,
                            BOOL fDisableDeletionCheck )
{
    //
    // This assert not true -- IsFull is checked before adding a new item,
    // so after the add it could be full.  If we happen to do a delete at
    // this point, the table could be full and that's ok.
    //
    // Win4Assert ( !IsFull() );

    unsigned cur = hash % _size;
    unsigned start = cur;
    unsigned delta = Delta();

    // this loop has to terminate
    // since the table is NOT full!

    while ( _table[cur] != wid && _table[cur] != widInvalid )
    {
        cur = (cur + delta) % _size;
        if ( cur == start ) // wrapped around
        {
            Win4Assert( delta != 1 ); // table is full
            delta = 1;
            cur = (cur + 1) % _size;
        }
    }

    if ( !fDisableDeletionCheck )
    {
        Win4Assert( wid == _table[cur] );
    }

    if ( _table[cur] == wid )
    {
        _count--;
        _table[cur] = widUnused;
    }
} //Remove

//+---------------------------------------------------------------------------
//
//  Member:     CShortWidList::CShortWidList, public
//
//  Synopsis:   Iterator for closed hash 'bucket'.
//
//  Arguments:  [hash]      -- Starting position
//              [hashTable] -- Table
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

CShortWidList::CShortWidList ( unsigned hash, CWidHashTable& hashTable )
        : _hashTable(hashTable),
          _counter(0),
          _size( hashTable.Size() )
{
    if (_size == 0)
        _wid = widInvalid;
    else
    {
        _iCur = hash % _size;
        _iStart = _iCur;
        _delta = hashTable.Delta();
        _wid = _hashTable[_iCur];

        if ( widUnused == _wid )
            _wid = NextWorkId();
    }
} //CShortWidList

//+---------------------------------------------------------------------------
//
//  Member:     CShortWidList::NextWorkId, public
//
//  Returns:    Next workid in 'bucket', or widInvalid if at end.
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

WORKID CShortWidList::NextWorkId()
{
    _wid = widUnused;

    do
    {
        _counter++;

        _iCur = ( _iCur + _delta ) % _size;

        if ( _iCur == _iStart ) // wrapped around
        {
            if (_counter >= _size) // looked at all
            {
                _wid = widInvalid;
                break;
            }
            else
            {
                _delta = 1; // try the fallback delta
                _iCur = (_iCur + 1) % _size;
                _wid = _hashTable[_iCur];
            }
        }
        else
        {
            _wid = _hashTable[_iCur];
        }
    } while ( _wid == widUnused );

    return _wid;
} //NextWorkId

//+---------------------------------------------------------------------------
//
//  Member:     CWidHashTable::IsFull, private
//
//  Returns:    TRUE if hash table is full (is running out of slack).
//
//  History:    10-Jan-96   KyleP       Added header
//
//----------------------------------------------------------------------------

BOOL CWidHashTable::IsFull()
{
    // If the hash table is greater than or equal to half full,
    // it's time to rehash.

    if ( _fAggressiveGrowth )
        return ( _count * 2 ) >= _size;

    return ( _count * 3 / 2 ) >= _size;
} //IsFull
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\acinotfy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       acinotfy.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-26-96   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <tgrow.hxx>
#include <ffenum.hxx>
#include <docstore.hxx>
#include <lcase.hxx>

#include <eventlog.hxx>
#include <cievtmsg.h>

#include "acinotfy.hxx"
#include "cicat.hxx"

CWorkQueue  TheFrameworkClientWorkQueue( 0,
                                         CWorkQueue::workQueueFrmwrkClient );

//+---------------------------------------------------------------------------
//
//  Function:   CCiSyncProcessNotify::CCiSyncProcessNotify
//
//  Synopsis:   Constructor
//
//  Arguments:  [cicat]   -- Catalog
//              [scanMgr] -- Scan thread manager
//              [pbChange] -- Change buffer
//              [wcsRoot]  -- Root dir for notifications
//              [fAbort]   -- Abort ?
//
//  History:    20-Mar-96    SitaramR     Added header
//
//----------------------------------------------------------------------------

CCiSyncProcessNotify::CCiSyncProcessNotify( CiCat & cicat,
                                            CCiScanMgr & scanMgr,
                                            BYTE const * pbChanges,
                                            WCHAR const * wcsRoot,
                                            BOOL & fAbort )
                          :_cicat(cicat),
                           _scanMgr(scanMgr),
                           _changeQueue(pbChanges),
                           _rootLen(0),
                           _fAbort(fAbort),
                           _nUpdates(0)

{
    _lowerFunnyPath.SetPath( wcsRoot, _rootLen = wcslen( wcsRoot ) );
    Win4Assert( (_lowerFunnyPath.GetActualPath())[_rootLen-1] == L'\\' );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiSyncProcessNotify::DoIt
//
//  Synopsis:   Processes changes notifications
//
//  History:    3-07-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiSyncProcessNotify::DoIt()
{

    FILETIME    ftNow;
    GetSystemTimeAsFileTime( &ftNow );

    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        CDirNotifyEntry const * pNotify = _changeQueue.First();

        //
        // Iterate through changes
        //
        for ( ;
              0 != pNotify;
              pNotify = _changeQueue.Next() )
        {

            if ( _fAbort )
                break;

            _nUpdates++;

            _relativePathLen = pNotify->PathSize() / sizeof(WCHAR);
            Win4Assert( _relativePathLen > 0 );

            _lowerFunnyPath.Truncate( _rootLen );
            _lowerFunnyPath.AppendPath( pNotify->Path(), _relativePathLen );

            switch ( pNotify->Change() )
            {
            case FILE_ACTION_MODIFIED:
            case FILE_ACTION_ADDED_STREAM:
            case FILE_ACTION_REMOVED_STREAM:
            case FILE_ACTION_MODIFIED_STREAM:
            {
                ciDebugOut(( DEB_FSNOTIFY, "Updating file %ws. Change code 0x%X\n",
                             _lowerFunnyPath.GetActualPath(), pNotify->Change() ));

                ULONG ulFileAttrib = GetFileAttributes( _lowerFunnyPath.GetPath() );

                //
                // If we got an error value for file attributes, then substitute zero
                // because we don't want the directory bit to be turned on
                //
                if ( ulFileAttrib == 0xFFFFFFFF )
                    ulFileAttrib = 0;

                if ( IsShortName() )
                {
                    ciDebugOut(( DEB_IWARN, "Converting %ws to long filename ",
                                 _lowerFunnyPath.GetActualPath() ));

                    if ( ConvertToLongName() )
                    {
                        ciDebugOut(( DEB_IWARN | DEB_NOCOMPNAME, "\t%ws\n",
                                     _lowerFunnyPath.GetActualPath() ));
                    }
                    else
                    {
                        ciDebugOut(( DEB_WARN,
                                     "Couldn't convert short filename %ws. Scope will be scanned.\n",
                                     _lowerFunnyPath.GetActualPath() ));

                        RescanCurrentPath();
                        break;
                    }
                }

                _cicat.Update( _lowerFunnyPath, FALSE, ftNow, ulFileAttrib ); // Not a deletion

                break;
            }

            case FILE_ACTION_ADDED:
            {
                ULONG ulFileAttrib = GetFileAttributes( _lowerFunnyPath.GetPath() );

                if ( IsShortName() )
                {
                    ciDebugOut(( DEB_IWARN, "Converting %ws to long filename ",
                                 _lowerFunnyPath.GetActualPath() ));

                    if ( ConvertToLongName() )
                    {
                        ciDebugOut(( DEB_IWARN | DEB_NOCOMPNAME, "\t%ws\n",
                                     _lowerFunnyPath.GetActualPath() ));
                    }
                    else
                    {
                        ciDebugOut(( DEB_WARN,
                                     "Couldn't convert short filename %ws. Scope will be scanned.\n",
                                     _lowerFunnyPath.GetActualPath() ));

                        RescanCurrentPath();
                        break;
                    }
                }

                if ( ulFileAttrib == 0xFFFFFFFF )
                {
                    ciDebugOut(( DEB_FSNOTIFY,
                                 "Adding file %ws. Change code 0x%X\n",
                                 _lowerFunnyPath.GetActualPath(),
                                 pNotify->Change() ));

                    ulFileAttrib = 0;
                    _cicat.Update( _lowerFunnyPath, FALSE, ftNow, ulFileAttrib );
                }
                else
                {
                    if ( ulFileAttrib & FILE_ATTRIBUTE_DIRECTORY )
                    {
                        ciDebugOut(( DEB_FSNOTIFY,
                                     "Adding directory %ws. Change code 0x%X\n",
                                     _lowerFunnyPath.GetActualPath(),
                                     pNotify->Change() ));

                        //
                        // Append '\' and convert to lower case
                        //
                        _lowerFunnyPath.AppendBackSlash();

                        _scanMgr.DirAddNotification( _lowerFunnyPath.GetActualPath() );
                    }
                    else
                    {
                        ciDebugOut(( DEB_FSNOTIFY,
                                     "Adding file %ws. Change code 0x%X\n",
                                     _lowerFunnyPath.GetActualPath(),
                                     pNotify->Change() ));

                        _cicat.Update( _lowerFunnyPath, FALSE, ftNow, ulFileAttrib );
                    }
                }

                break;
            }

            case FILE_ACTION_REMOVED:
            {
                if ( IsShortName() )
                {
                    //
                    // File is in the index with a long name.  Need to rescan scope.
                    // Still worth trying the immediate delete as well.
                    //

                    ciDebugOut(( DEB_WARN,
                                 "Missed deletion of short filename %ws. Scope will be scanned.\n",
                                 _lowerFunnyPath.GetActualPath() ));

                    Report8Dot3Delete();
                    RescanCurrentPath();
                }

                if ( _cicat.IsDirectory( &_lowerFunnyPath, 0 )  )
                {
                    ciDebugOut(( DEB_FSNOTIFY,
                                 "Deleting directory %ws. Change code 0x%X\n",
                                 _lowerFunnyPath.GetActualPath(),
                                 pNotify->Change() ));

                    _lowerFunnyPath.AppendBackSlash();
                    _scanMgr.RemoveScope( _lowerFunnyPath.GetActualPath() );
                }
                else
                {
                    ciDebugOut(( DEB_FSNOTIFY,
                                 "Deleting file %ws. Change code 0x%X\n",
                                 _lowerFunnyPath.GetActualPath(),
                                 pNotify->Change() ));

                    _cicat.Update( _lowerFunnyPath, TRUE, ftNow, 0 );
                }

                break;
            }

            case FILE_ACTION_RENAMED_OLD_NAME:
            {
                if ( IsShortName() )
                {
                    ciDebugOut(( DEB_WARN,
                                 "Old file \"%ws\" is a short name.  Scope will be rescanned.\n",
                                 _lowerFunnyPath.GetActualPath() ));
                    RescanCurrentPath();
                    break;
                }

                //
                // Look at next notification entry (don't advance) to see if
                // it is a renamed notification
                //
                CDirNotifyEntry const *pNotifyNext = _changeQueue.NextLink();

                if ( pNotifyNext &&
                     pNotifyNext->Change() == FILE_ACTION_RENAMED_NEW_NAME )
                {
                    //
                    // Advance to next notification entry and get the new name
                    //
                    pNotify = _changeQueue.Next();

                    ULONG relativeNewPathLen = pNotify->PathSize()/sizeof( WCHAR );
                    Win4Assert( relativeNewPathLen > 0 );

                    CLowerFunnyPath lcaseFunnyNewName( _lowerFunnyPath );
                    lcaseFunnyNewName.Truncate( _rootLen );
                    lcaseFunnyNewName.AppendPath( pNotify->Path(), relativeNewPathLen );

                    if ( _cicat.IsDirectory( &_lowerFunnyPath, &lcaseFunnyNewName ) )
                    {
                        ciDebugOut(( DEB_FSNOTIFY,
                                     "Renaming directory %ws. Change code 0x%X\n",
                                     _lowerFunnyPath.GetActualPath(),
                                     pNotify->Change() ));

                        _lowerFunnyPath.AppendBackSlash();
                        lcaseFunnyNewName.AppendBackSlash();

                        _scanMgr.DirRenameNotification( _lowerFunnyPath.GetActualPath(), 
                                                        lcaseFunnyNewName.GetActualPath() );
                    }
                    else
                    {
                        //
                        // Delete old file
                        //
                        ciDebugOut(( DEB_FSNOTIFY,
                                     "Deleting file %ws. Change code 0x%X\n",
                                     _lowerFunnyPath.GetActualPath(),
                                     pNotify->Change() ));
                        _cicat.Update( _lowerFunnyPath, TRUE, ftNow, 0 );

                        //
                        // Add new file
                        //
                        ULONG ulFileAttrib = GetFileAttributes( lcaseFunnyNewName.GetPath() );
                        if ( ulFileAttrib == 0xFFFFFFFF )
                            ulFileAttrib = 0;

                        ciDebugOut(( DEB_FSNOTIFY,
                                     "Adding file %ws. Change code 0x%X\n",
                                     lcaseFunnyNewName.GetActualPath(),
                                     pNotify->Change() ));
                        _cicat.Update( lcaseFunnyNewName, FALSE, ftNow, ulFileAttrib );
                    }
                }
                else
                {
                    ciDebugOut(( DEB_ERROR,
                                 "Renaming directory %ws, file_action_renamed_new_name notification not found\n",
                                 _lowerFunnyPath.GetActualPath() ));
                }

                break;
            }

            case FILE_ACTION_RENAMED_NEW_NAME:

                //
                // We might have skipped the old path because it is too big or
                // because it was a short name.
                // A later scan will pick up the file if appropriate.
                //
                break;

            default:
                ciDebugOut(( DEB_ERROR, "Unknown modification type 0x%X\n",
                             pNotify->Change() ));
                Win4Assert( !"Unknown modification type" );
                break;
            }
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
        "CCiSyncProcessNotify::DoIt - Error 0x%X while processing changes\n",
                     e.GetErrorCode() ));

        status = e.GetErrorCode();
    }
    END_CATCH

    if ( !_fAbort )
    {
        if ( STATUS_SUCCESS == status )
        {
            _cicat.IncrementUpdateCount( _nUpdates );
        }
        else
        {
            _cicat.HandleError( status );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiSyncProcessNotify::IsShortName, private
//
//  Returns:    TRUE if current file is potentially a short (8.3) name for
//              a file with a long name.
//
//  History:    06-Jan-98   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCiSyncProcessNotify::IsShortName()
{
    //
    // First, see if this is possibly a short name (has ~ in final component).
    //

    BOOL fTwiddle = FALSE;
    unsigned ccFN = 0;
    unsigned cDot = 0;

    const WCHAR * const pwcsFullPath = _lowerFunnyPath.GetActualPath();

    for ( int i = _rootLen + _relativePathLen; i >= 0 && ccFN < 13; i-- )
    {
        //
        // Note: Ed Lau tested to confirm that we don't have to all ~ at the beginning
        //

        if ( pwcsFullPath[i] == L'~' && pwcsFullPath[i-1] != L'\\' )
            fTwiddle = TRUE;
        else if ( pwcsFullPath[i] == L'.' )
        {
            // max extension length is 3
            // valid short names don't start with '.' (except . and ..)
            if ( ccFN > 3 || pwcsFullPath[i-1] == L'\\' )
                return FALSE;
            cDot++;
        }
        else if ( pwcsFullPath[i] == L'\\' )
            break;

        ccFN++;
    }

    if (fTwiddle)
    {
        // short names can't have more than 1 '.'
        // max filename size if no extension is 8
        if (cDot >= 2 || cDot == 0 && ccFN > 8)
            return FALSE;

        // check for min (e.g., EXT~1 for .ext) and max lengths
        if (ccFN >= 5 && ccFN <= 12)
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiSyncProcessNotify::ConvertToLongName, private
//
//  Synopsis:   Converts current filename from a short name to a long name.
//
//  Returns:    TRUE if conversion was successful.
//
//  History:    06-Jan-98   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCiSyncProcessNotify::ConvertToLongName()
{
    return _lowerFunnyPath.ConvertToLongName();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiSyncProcessNotify::RescanCurrentPath, private
//
//  Synopsis:   Rescans directory
//
//  History:    06-Jan-98   KyleP   Created
//
//----------------------------------------------------------------------------

void CCiSyncProcessNotify::RescanCurrentPath()
{

    //
    // Rescan whole directory.
    //

    WCHAR wcTemp;
    WCHAR * pwcsFullPath = (WCHAR*)_lowerFunnyPath.GetActualPath();

    for ( int i = _rootLen + _relativePathLen; i >= 0; i-- )
    {
        if ( pwcsFullPath[i] == L'\\' )
        {
            i++;
            wcTemp = pwcsFullPath[i];
            pwcsFullPath[i] = 0;
            break;
        }
    }

    _cicat.ReScanPath( pwcsFullPath, // Path
                       TRUE );       // Delayed

    pwcsFullPath[i] = wcTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiSyncProcessNotify::Report8Dot3Delete, private
//
//  Synopsis:   Writes event log message identifying slow rescan due to
//              short filename delete.
//
//  History:    06-Jan-98   KyleP   Created
//
//----------------------------------------------------------------------------

void CCiSyncProcessNotify::Report8Dot3Delete()
{
    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );

        CEventItem item( EVENTLOG_WARNING_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_DELETE_8DOT3_NAME,
                         1 );

        item.AddArg( _lowerFunnyPath.GetActualPath() );

        eventLog.ReportEvent( item );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Exception 0x%X while writing to event log\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     ~ctor of CCiAsyncProcessNotify
//
//  Synopsis:   Primes the changequeue member with the given data.
//
//  Arguments:  [cicat]     -
//              [pbChanges] -  Pointer to the list of changes.
//              [cbChanges] -  Number of bytes in pbChanges.
//              [wcsRoot]   -  Root of the scope for changes.
//
//  History:    2-28-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCiAsyncProcessNotify::CCiAsyncProcessNotify( CWorkManager & workMan,
                                              CiCat & cicat,
                                              CCiScanMgr & scanMgr,
                                              XArray<BYTE> & xChanges,
                                              WCHAR const * wcsRoot )
       : CFwAsyncWorkItem( workMan, TheFrameworkClientWorkQueue),
         _changes( cicat,
                   scanMgr,
                   xChanges.GetPointer(),
                   wcsRoot ,
                   _fAbort )
{
    _pbChanges = xChanges.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAsyncProcessNotify::DoIt
//
//  Synopsis:   Processes the changes in the change buffer.
//
//  Arguments:  [pThread] -- Thread actually completing request.
//
//  History:    2-26-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiAsyncProcessNotify::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    _changes.DoIt();

    Done();
    Release();
    // --------------------------------------------------------
}

//+---------------------------------------------------------------------------
//
//  Member:     CIISVRootAsyncNotify::DoIt
//
//  Synopsis:   Process IIS VRoot change notification.
//
//  Arguments:  [pThread] -
//
//  History:    4-11-96   srikants   Created
//
//----------------------------------------------------------------------------

void CIISVRootAsyncNotify::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    ciDebugOut(( DEB_WARN, "Processing IIS vroot change...\n" ));

    _cicat.SynchWithIIS();

    Done();
    Release();
    // --------------------------------------------------------
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegistryScopesAsyncNotify::DoIt
//
//  Synopsis:   Process registry scopes registry change notification.
//
//  Arguments:  [pThread] -
//
//  History:    4-11-96   srikants   Created
//
//----------------------------------------------------------------------------

void CRegistryScopesAsyncNotify::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    ciDebugOut(( DEB_WARN, "Processing registry scopes change...\n" ));

    _cicat.SynchWithRegistryScopes();

    Done();
    Release();
    // --------------------------------------------------------
}


//+---------------------------------------------------------------------------
//
//  Member:     CStartFilterDaemon::DoIt
//
//  Synopsis:   Starts the filter daemon process.
//
//  Arguments:  [pThread] - A worker thread pointer.
//
//  History:    12-23-96   srikants   Created
//
//----------------------------------------------------------------------------

void CStartFilterDaemon::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    _docStore._StartFiltering();

    Done();
    Release();
    // --------------------------------------------------------
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\cicat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       CICAT.CXX
//
//  Contents:   Content index temporary catalog
//
//  Classes:
//
//  History:    09-Mar-1992   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <lm.h>

#include <fsciexps.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <eventlog.hxx>
#include <doclist.hxx>
#include <fdaemon.hxx>
#include <update.hxx>
#include <pstore.hxx>
#include <mmstrm.hxx>
#include <pidremap.hxx>
#include <imprsnat.hxx>
#include <nntpprop.hxx>
#include <ciguid.hxx>

#include <docstore.hxx>

#include <cievtmsg.h>
#include <cifailte.hxx>
#include <pathpars.hxx>
#include <regscp.hxx>
#include <cimbmgr.hxx>
#include <regprop.hxx>
#include <cifrmcom.hxx>
#include <glbconst.hxx>
#include <dmnproxy.hxx>
#include <propspec.hxx>
#include <lcase.hxx>

#include "propiter.hxx"
#include "propobj.hxx"
#include "cicat.hxx"
#include "cinulcat.hxx"
#include "catreg.hxx"

#include <timlimit.hxx>
#include <fa.hxx>
#include <dynmpr.hxx>

static const GUID guidCharacterization = PSGUID_CHARACTERIZATION;
static const unsigned propidCharacterization = 2;

static const GUID guidDocSummary = DocPropSetGuid;
static const PROPID propidTitle = PIDSI_TITLE;

//
// Given a registry string like \Registry\Machine\System\CurrentControlSet\...
// you skip the first 18 characters if using w/ HKEY_LOCAL_MACHINE.
//

unsigned const SKIP_TO_LM = 18;

// -------------------------------------------------------------------------
// DO NOT VIOLATE THE FOLLOWING LOCK HIERARCHY
//
// 1. DocStore Lock
// 2. CiCat Admin Lock
// 3. CiCat Lock
// 4. Resman Lock
// 5. ScopeTable Lock
// 6. NotifyMgr Lock
// 7. ScanMgr Lock
// 8. Propstore write lock
// 9. Propstore lock record
//
// It is okay for a thread to acquire lock at level X and then acquire a lock
// at a level >= X but not locks < X. This will avoid deadlock situations.
//
// SrikantS   - April 25, 1996
// SrikantS   _ Dec 31, 1996 - Added DocStore as the highest level lock
//
// -------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Member:     CiCat::CiCat, public
//
//  Synopsis:   Creates a new 'content index catalog'
//
//  Arguments:  [docStore]   - Doc store
//              [workMan]    - Work queue manager
//              [wcsCatPath] - root path of catalog
//              [fVersionChange] - Set to true if there is a format version
//                                 change.
//              [pwcName]    - name of the catalog from the registry
//
//  History:    10-Mar-92 BartoszM  Created
//              14-mar-92 KyleP     Added Content index object.
//              03-Mar-98 KitmanH   Added code to deal with read-only catalogs
//              02-Apr-98 KitmanH   Start the CiCat in r/o mode if
//                                  fOpenForReadOnly is TRUE
//              01-Nov-98 KLam      Pass DiskSpaceToLeave to CiStorage
//
//--------------------------------------------------------------------------

CiCat::CiCat ( CClientDocStore & docStore,
               CWorkManager & workMan,
               WCHAR const * wcsCatPath,
               BOOL &fVersionChange,
               BOOL fOpenForReadOnly,
               CDrvNotifArray & DrvNotifArray,
               WCHAR const * pwcName,
               BOOL fLeaveCorruptCatalog )
        : _regParams( pwcName ),
          _ulSignature( LONGSIG( 'c', 'c', 'a', 't' ) ),
          _fIsReadOnly( _regParams.IsReadOnly() ),
          _statusMonitor(_wcsCatDir),
          _pStorage(0),
          _state(eStarting),
          _docStore(docStore),
          _PartId(1),
          _fInitialized(FALSE),
          _workMan( workMan ),
#pragma warning( disable : 4355 )       // this used in base initialization
          _strings( _propstoremgr, *this ),
          _fileIdMap( _propstoremgr ),
          _scanMgr(*this),
          _usnMgr(*this),
          _notify(*this, _scanMgr),
          _scopeTable(*this, _notify, _scanMgr, _usnMgr),
#pragma warning( default : 4355 )
          _fRecovering( FALSE ),
          _fRecoveryCompleted( FALSE ),
          _propstoremgr( _regParams.GetMinDiskSpaceToLeave() ),
          _fAutoAlias( TRUE ),
          _fIndexW3Roots( FALSE ),
          _fIndexNNTPRoots( FALSE ),
          _fIndexIMAPRoots( FALSE ),
          _W3SvcInstance( 1 ),
          _NNTPSvcInstance( 1 ),
          _IMAPSvcInstance( 1 ),
          _fIsIISAdminAlive( FALSE ),
          _impersonationTokenCache( pwcName ),
          _evtRescanTC( 0 ),
          _cIISSynchThreads( 0 ),
          _cUsnVolumes(0),
          _DrvNotifArray(DrvNotifArray)
{
    Win4Assert( 0 != pwcName );

    ciDebugOut(( DEB_WARN, "CiCat::CiCat: %ws\n", pwcName ));

    CImpersonateSystem impersonate;

    //
    // Configure the property store
    //

    _propstoremgr.SetBackupSize(_regParams.GetPrimaryStoreBackupSize(), PRIMARY_STORE);
    _propstoremgr.SetMappedCacheSize(_regParams.GetPrimaryStoreMappedCache(), PRIMARY_STORE);
    _propstoremgr.SetBackupSize(_regParams.GetSecondaryStoreBackupSize(), SECONDARY_STORE);
    _propstoremgr.SetMappedCacheSize(_regParams.GetSecondaryStoreMappedCache(), SECONDARY_STORE);

    fVersionChange = FALSE;
    RtlZeroMemory( &_ftLastCLFlush, sizeof(_ftLastCLFlush) );

    //
    // Get path to hives.  Needed to avoid indexing them (oplock problems).
    //

    //
    // Use _wcsCatDir as scratch space.
    //

    WCHAR const wcsConfigDir[] = L"\\config";

    if ( 0 != GetSystemDirectory( _wcsCatDir,
                                  (sizeof(_wcsCatDir) - sizeof(wcsConfigDir))/sizeof(WCHAR) ) )
    {
        wcscat( _wcsCatDir, wcsConfigDir );
    }

    //
    // Set up catalog paths
    //

    CLowcaseBuf PathBuf( wcsCatPath );

    if ( PathBuf.Length() >= MAX_CAT_PATH )
    {
        ciDebugOut(( DEB_ERROR, "Path for catalog (%ws) is too long\n",
                                wcsCatPath ));
        CCiStatusMonitor::ReportPathTooLong( wcsCatPath );
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    _xwcsDriveName.SetBuf( PathBuf.Get(), wcslen( PathBuf.Get() ) + 1 );
    wcscpy ( _wcsCatDir, PathBuf.Get() );
    wcscat ( _wcsCatDir, CAT_DIR );

    _CatDir.Init( _wcsCatDir, wcslen( _wcsCatDir ) );

    SetName( pwcName );
    BuildRegistryScopesKey( _xScopesKey, pwcName );

    // Note: indexsrv uses the full path with catalog.wci while query
    //       uses just the cat path.

    CSharedNameGen nameGen( wcsCatPath );
    _evtRescanTC.Set( new CEventSem( nameGen.GetRescanTCEventName() ) );
    _evtRescanTC->Reset();

    _fAutoAlias = _regParams.IsAutoAlias();
    _fIndexW3Roots = _regParams.IsIndexingW3Roots();
    _fIndexNNTPRoots = _regParams.IsIndexingNNTPRoots();
    _fIndexIMAPRoots = _regParams.IsIndexingIMAPRoots();
    _W3SvcInstance = _regParams.GetW3SvcInstance();
    _NNTPSvcInstance = _regParams.GetNNTPSvcInstance();
    _IMAPSvcInstance = _regParams.GetIMAPSvcInstance();

    // CImpersonateSystem::_fRunningAsSystem will already be set as TRUE
    // if running in CiSvc

    if ( _fIndexW3Roots || _fIndexNNTPRoots || _fIndexIMAPRoots )
    {
        CImpersonateSystem::SetRunningAsSystem();

        BOOL fInstalled;
        _fIsIISAdminAlive = CMetaDataMgr::IsIISAdminUp( fInstalled );

        if ( !_fIsIISAdminAlive )
        {
            // if IIS isn't installed, don't bother at all

            if ( !fInstalled )
            {
                _fIndexW3Roots = FALSE;
                _fIndexNNTPRoots = FALSE;
                _fIndexIMAPRoots = FALSE;
                ciDebugOut(( DEB_WARN, "IIS isn't installed!!!\n" ));
            }

            EvtLogIISAdminNotAvailable();
        }
    }

    _impersonationTokenCache.Initialize( CI_ACTIVEX_NAME,
                                         _fIndexW3Roots,
                                         _fIndexNNTPRoots,
                                         _fIndexIMAPRoots,
                                         _W3SvcInstance,
                                         _NNTPSvcInstance,
                                         _IMAPSvcInstance );

    #if CIDBG == 1
        if ( _fIndexW3Roots )
            ciDebugOut(( DEB_ITRACE, "Indexing W3 roots in %d\n", _W3SvcInstance ));
        if ( _fIndexNNTPRoots )
            ciDebugOut(( DEB_ITRACE, "Indexing NNTP roots in %d\n", _NNTPSvcInstance ));
        if ( _fIndexIMAPRoots )
            ciDebugOut(( DEB_ITRACE, "Indexing IMAP roots in %d\n", _IMAPSvcInstance ));

        ciDebugOut(( DEB_ITRACE, "_fIsIISAdminAlive: %d\n", _fIsIISAdminAlive ));
    #endif // CIDBG == 1

    // obtain an ICiCAdviseStatus interface pointer to use

    ICiCAdviseStatus    *pAdviseStatus = 0;

    SCODE sc = _docStore.QueryInterface( IID_ICiCAdviseStatus,
                                         (void **) &pAdviseStatus);
    if ( S_OK != sc )
    {
        Win4Assert( 0 == pAdviseStatus );
        THROW( CException(sc) );
    }

    _xAdviseStatus.Set(pAdviseStatus);

    XPtr<PStorage> xStorage;

    _pStorage = new CiStorage ( _wcsCatDir,
                                _xAdviseStatus.GetReference(),
                                _regParams.GetMinDiskSpaceToLeave(),
                                FSCI_VERSION_STAMP,
                                _fIsReadOnly );
    
    xStorage.Set( _pStorage );

    // in case the catalog allows only read-only access, but it was not marked
    // as read-only in the registry, refresh _fIsReadOnly value and setreadonly()
    // for _scanMgr, if _pStorage is found as IsReadOnly() after its construction
    // Also if we are in "net paused" state, we're restarting the CiCat in r/o
    // mode

    if ( _pStorage->IsReadOnly() || fOpenForReadOnly )
    {
        _fIsReadOnly = TRUE;
        _scanMgr.SetReadOnly();
        _pStorage->SetReadOnly(); //refresh it if we're in "net pause"
    }

    //
    // The scope table is initialized to check the corruption status
    // and format version.
    //

    NTSTATUS status = STATUS_SUCCESS;
    TRY
    {
        _scopeTable.FastInit();
    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%x while initializing scopetable\n",
                     status ));
    }
    END_CATCH

    if ( status != STATUS_SUCCESS )
    {
        if ( IsCiCorruptStatus(status) || status == CI_INCORRECT_VERSION )
        {
            // if catalog is corrupted and the catalog is readonly, We cannot recover
            if ( IsReadOnly() )
            {
                Win4Assert( !"Catalog is read-only, cannot be recovered!" );
                _statusMonitor.LogEvent( CCiStatusMonitor::eInitFailed, status );
                THROW( CException( status ) );
            }

#if CIDBG==1
            //if ( IsCiCorruptStatus(status) )
            //    Win4Assert( !"FSCI(Catalog) Data Corruption" );
#endif
            if ( status == CI_INCORRECT_VERSION )
                fVersionChange = TRUE;

            // If instructed to leave corrupt catalogs, throw now.
            // Don't leave around catalogs that need to change due to a
            // version change.  Note that some corruptions may just look
            // like a version change, but that's the way it goes.

            if ( fLeaveCorruptCatalog && !fVersionChange )
            {
                _statusMonitor.LogEvent( CCiStatusMonitor::eInitFailed, status );
                Win4Assert( !"leaving corrupt catalog" );
                THROW( CException( status ) );
            }

            //
            // Log an event that we are doing automatic recovery.
            //
            _statusMonitor.LogEvent( CCiStatusMonitor::eCiRemoved );
            _pStorage->DeleteAllFsCiFiles();

            _statusMonitor.Reset();
            _scopeTable.FastInit();
        }
        else
        {
            if ( status == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
                _statusMonitor.LogEvent( CCiStatusMonitor::eInitFailed,
                                         status );

            THROW( CException( status ) );
        }
    }

    xStorage.Acquire();

    //
    // Start all the threads up, after we can THROW.
    //

    _notify.Resume();
    _usnMgr.Resume();
    _scanMgr.Resume();
} //CiCat

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::EvtLogIISAdminNotAvailable(), private
//
//  Synopsis:   Logs an event that iisadmin was needed but not available
//
//  History:    2-19-97   dlee   Created
//
//----------------------------------------------------------------------------

void CiCat::EvtLogIISAdminNotAvailable()
{
    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );

        CEventItem item( EVENTLOG_WARNING_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_IISADMIN_NOT_AVAILABLE,
                         0 );

        eventLog.ReportEvent( item );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Exception 0x%X while writing to event log\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //EvtLogIISAdminNotAvailable

//+-------------------------------------------------------------------------
//
//  Method:     CiCat::PathToFileId, private
//
//  Synopsis:   Looks up a fileid based on a path
//
//  Arguments:  [funnyPath]  -- Full funny path of the file.
//
//  Returns:    The fileid of the file or fileIdInvalid if not found.
//
//  History:    3-3-98   dlee   Created
//
//--------------------------------------------------------------------------

FILEID CiCat::PathToFileId( const CFunnyPath & funnyPath )
{
    FILEID fileId = fileIdInvalid;

    BOOL fAppendBackSlash = FALSE;

    // For volume \\?\D:, NtQueryInformationFile with the following
    // error: 0xC0000010L - STATUS_INVALID_DEVICE_REQUEST. Need to append a \,
    // to make it work. We need to append the '\'only in case of volume path.

    if ( 2 == funnyPath.GetActualLength() && !funnyPath.IsRemote() )
    {
        Win4Assert( L':'  == (funnyPath.GetActualPath())[1] );
        ((CFunnyPath&)funnyPath).AppendBackSlash();    // override const
        fAppendBackSlash = TRUE;
    }

    HANDLE h;
    NTSTATUS status = CiNtOpenNoThrow( h,
                                       funnyPath.GetPath(),
                                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       0 );

    if ( fAppendBackSlash )
    {
        ((CFunnyPath&)funnyPath).RemoveBackSlash();    // override const
    }

    if ( NT_SUCCESS( status ) )
    {
        SHandle xFile( h );

        FILE_INTERNAL_INFORMATION fii;
        IO_STATUS_BLOCK IoStatus;
        status = NtQueryInformationFile( h,
                                         &IoStatus,
                                         &fii,
                                         sizeof fii,
                                         FileInternalInformation );
        if ( NT_SUCCESS( status ) )
            status = IoStatus.Status;

        if ( NT_SUCCESS( status ) )
        {
            fileId = fii.IndexNumber.QuadPart;
            Win4Assert( fileIdInvalid != fileId );
        }
    }

    if ( NT_ERROR( status ) )
    {
        // ignore and return fileIdInvalid if the file doesn't exist.

        if ( ! ( IsSharingViolation( status ) ||
                 STATUS_ACCESS_DENIED == status ||
                 STATUS_DELETE_PENDING == status ||
                 STATUS_OBJECT_PATH_NOT_FOUND == status ||
                 STATUS_OBJECT_NAME_NOT_FOUND == status ||
                 STATUS_OBJECT_NAME_INVALID == status ||
                 STATUS_NO_MEDIA_IN_DEVICE == status ||
                 STATUS_NONEXISTENT_SECTOR == status ||
                 STATUS_IO_REPARSE_TAG_NOT_HANDLED == status ) )
        {
            #if CIDBG == 1
                if ( STATUS_WRONG_VOLUME != status &&
                     STATUS_VOLUME_DISMOUNTED != status &&
                     STATUS_INSUFFICIENT_RESOURCES != status &&
                     STATUS_UNRECOGNIZED_VOLUME != status ) 
                {
                    ciDebugOut(( DEB_WARN,
                                 "error 0x%x, can't get fileid for '%ws'\n",
                                 status, funnyPath.GetPath() ));

                    char acTemp[ 200 ];
                    sprintf( acTemp, "New error %#x from PathToFileId.  Call DLee", status );
                    Win4AssertEx(__FILE__, __LINE__, acTemp);
                }
            #endif

            THROW( CException( status ) );
        }
        else
        {
            ciDebugOut(( DEB_ITRACE, "(ok) pathtofileid failed %#x\n", status ));
        }
    }

    return fileId;
} //PathToFileId

//+-------------------------------------------------------------------------
//
//  Method:     CiCat::LokLookupWid, private
//
//  Synopsis:   Looks up a workid based on a fileid or path
//
//  Arguments:  [lcaseFunnyPath]  -- Full path of the file.
//              [fileId]          -- The fileid of the file or fileIdInvalid if
//                                   the fileid should be found based on pwcPath.
//                                   Returns the fileId if it was looked up.
//
//  Returns:    The workid of the file or widInvalid if not found.
//
//  History:    3-3-98   dlee   Created
//
//--------------------------------------------------------------------------

WORKID CiCat::LokLookupWid( const CLowerFunnyPath & lcaseFunnyPath, FILEID & fileId )
{
    Win4Assert( _mutex.IsHeld() );

    if ( fileIdInvalid == fileId )
        fileId = PathToFileId( lcaseFunnyPath );

    if ( fileIdInvalid == fileId )
        return widInvalid;

    return _fileIdMap.LokFind( fileId, MapPathToVolumeId( lcaseFunnyPath.GetActualPath() ) );
} //LokLookupWid

//+-------------------------------------------------------------------------
//
//  Method:     CiCat::PropertyToPropId
//
//  Synopsis:   Locate pid for property
//
//  Arguments:  [ps]      -- Property specification (name)
//              [fCreate] -- TRUE if non-existent mapping should be created
//
//  Returns:    The pid of [ps].
//
//  History:    09 Jan 1996     AlanW   Created
//
//--------------------------------------------------------------------------

PROPID CiCat::PropertyToPropId( CFullPropSpec const & ps,
                                BOOL fCreate )
{
    FULLPROPSPEC const * fps = ps.CastToStruct();

    if ( IsStarted() )
        return _docStore._PropertyToPropid( fps, fCreate );

    return _propMapper.PropertyToPropId( ps, fCreate);
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::GetStorage, public
//
//  Returns:    Storage object for catalog
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

PStorage& CiCat::GetStorage ()
{
    return *_pStorage;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::GetDriveName, public
//
//  Returns:    Drive name
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

WCHAR * CiCat::GetDriveName()
{
   return( _xwcsDriveName.Get() );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::LokExists, private
//
//  Returns:    TRUE if a catalog directory exists.
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

BOOL CiCat::LokExists()
{
    Win4Assert( _mutex.IsHeld() );

    if ( IsStarted() )
        return TRUE;

    DWORD dwAttr = GetFileAttributesW( _wcsCatDir );
    if ( dwAttr == 0xFFFFFFFF )
    {
        ciDebugOut((DEB_ITRACE, "Directory %ws does not exist\n", _wcsCatDir));
        return(FALSE);
    }
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::LokCreate, private
//
//  Synopsis:   Creates content index.
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

void CiCat::LokCreate()
{
    Win4Assert( _mutex.IsHeld() );

    CImpersonateSystem impersonate;

    CreateDirectory ( _wcsCatDir, 0 );

    ciDebugOut ((DEB_ITRACE, "Catalog Directory %ws created\n", _wcsCatDir ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::DoRecovery
//
//  Synopsis:   Does the "long" initialization process. If any recovery
//              needs to be done, it will be done here. This is done in
//              the scan threads context and will not allow any other
//              writer to come in.
//
//  History:    3-06-96   srikants   Created
//              9-Nov-98  KLam       Throws CI_E_CONFIG_DISK_FULL if there is no disk space
//
//----------------------------------------------------------------------------

void CiCat::DoRecovery()
{
    ciDebugOut(( DEB_ITRACE, "Doing long initialization step\n" ));

    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        if ( !IsStarted() || _statusMonitor.IsCorrupt() )
        {
            // Win4Assert( !"Corrupt catalog" );
            _pStorage->ReportCorruptComponent( L"CiCatalog1" );

            THROW( CException( CI_CORRUPT_CATALOG ) );
        }

        //
        // Check for disk full situation and process it accordingly.
        //
        BOOL fLow = _docStore.VerifyIfLowOnDiskSpace();

        if ( fLow )
        {
            THROW( CException( CI_E_CONFIG_DISK_FULL ) );
        }
        else if ( IsLowOnDisk() )
        {
            //
            // A disk-full situation existed before. Clear it up.
            //
            NoLokClearDiskFull();
        }

        if ( _propstoremgr.IsDirty() )
            _statusMonitor.ReportPropStoreRecoveryStart();

        ULONG cInconsistencies;
        _propstoremgr.LongInit( _fRecovering, cInconsistencies, UpdateDuringRecovery, this );

        if ( _fRecovering )
        {
            if (cInconsistencies)
            {
                _statusMonitor.ReportPropStoreRecoveryError( cInconsistencies );
                THROW( CException( CI_CORRUPT_CATALOG ) );
            }
            else
                _statusMonitor.ReportPropStoreRecoveryEnd();
        }

        //
        // Add properties to primary store.  Will only happen on first call.
        //
        ULONG_PTR ulToken = _propstoremgr.BeginTransaction();

        _propstoremgr.Setup( pidLastSeenTime, VT_FILETIME, sizeof (FILETIME), ulToken, FALSE, PRIMARY_STORE );
        _propstoremgr.Setup( pidParentWorkId, VT_UI4,  sizeof( WORKID ), ulToken, FALSE, PRIMARY_STORE );
        _propstoremgr.Setup( pidAttrib, VT_UI4, sizeof (ULONG), ulToken, FALSE, PRIMARY_STORE );

        //
        // Usn/Ntfs 5.0 properties
        //

        _propstoremgr.Setup( pidFileIndex, VT_UI8, sizeof( FILEID ), ulToken, FALSE, PRIMARY_STORE );
        _propstoremgr.Setup( pidVolumeId, VT_UI4,  sizeof( VOLUMEID ), ulToken, FALSE, PRIMARY_STORE );

        //
        // User properties destined to the primary store
        //

        RecoverUserProperties( ulToken, PRIMARY_STORE );

        _propstoremgr.EndTransaction( ulToken, TRUE, pidSecurity, pidVirtualPath );

        //
        // Add properties to secondary store.  Will only happen on first call.
        //
        ulToken = _propstoremgr.BeginTransaction();

        //
        // 'Standard' properties.
        //

        CFullPropSpec psTitle( guidDocSummary, propidTitle );
        PROPID pidTitle = PropertyToPropId( psTitle, TRUE );

        _propstoremgr.Setup( pidSize, VT_I8, sizeof (LONGLONG), ulToken, FALSE, SECONDARY_STORE );
        _propstoremgr.Setup( pidWriteTime, VT_FILETIME, sizeof (LONGLONG), ulToken, FALSE, SECONDARY_STORE );
        _propstoremgr.Setup( pidTitle, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

        //
        // 'Characterization'
        //

        CFullPropSpec psCharacterization( guidCharacterization, propidCharacterization );
        PROPID pidCharacterization = PropertyToPropId( psCharacterization, TRUE );

        BOOL fCanStoreChar = _propstoremgr.CanStore( pidCharacterization );

        if ( _regParams.GetGenerateCharacterization() )
        {
            if ( ! fCanStoreChar )
                _propstoremgr.Setup( pidCharacterization,
                                     VT_LPWSTR,
                                     4,
                                     ulToken,
                                     TRUE,
                                     SECONDARY_STORE );
        }
        else
        {
            // size of 0 means remove the property

            if ( fCanStoreChar )
                _propstoremgr.Setup( pidCharacterization,
                                     VT_LPWSTR,
                                     0,
                                     ulToken,
                                     TRUE,
                                     SECONDARY_STORE );
        }

        //
        // IMAP properties
        //

        if (  _fIndexIMAPRoots )
        {
            CFullPropSpec psNewsReceivedDate( guidNNTP, propidNewsReceivedDate );

            PROPID pidNewsReceivedDate = PropertyToPropId( psNewsReceivedDate, TRUE );

            if ( !_propstoremgr.CanStore( pidNewsReceivedDate ) )
                _propstoremgr.Setup( pidNewsReceivedDate, VT_FILETIME, 8, ulToken, TRUE, SECONDARY_STORE );
        }

        //
        // IMAP/NNTP properties
        //

        if ( _fIndexNNTPRoots || _fIndexIMAPRoots )
        {
            CFullPropSpec psNewsDate( guidNNTP, propidNewsDate );
            CFullPropSpec psNewsArticleid( guidNNTP, propidNewsArticleid );

            PROPID pidNewsDate       = PropertyToPropId( psNewsDate, TRUE );
            PROPID pidNewsArticleid  = PropertyToPropId( psNewsArticleid, TRUE );

            if ( !_propstoremgr.CanStore( pidNewsDate ) )
                _propstoremgr.Setup( pidNewsDate, VT_FILETIME, 8, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsArticleid ) )
                _propstoremgr.Setup( pidNewsArticleid, VT_UI4, 4, ulToken, TRUE, SECONDARY_STORE );
        }

        //
        // NNTP properties
        //

        if ( _fIndexNNTPRoots )
        {
            CFullPropSpec psNewsSubject( guidNNTP, propidNewsSubject );
            CFullPropSpec psNewsFrom( guidNNTP, propidNewsFrom );
            CFullPropSpec psNewsGroup( guidNNTP, propidNewsGroup );
            CFullPropSpec psNewsGroups( guidNNTP, propidNewsGroups );
            CFullPropSpec psNewsReferences( guidNNTP, propidNewsReferences );
            CFullPropSpec psNewsMsgid( guidNNTP, propidNewsMsgid );

            PROPID pidNewsSubject    = PropertyToPropId( psNewsSubject, TRUE );
            PROPID pidNewsFrom       = PropertyToPropId( psNewsFrom, TRUE );
            PROPID pidNewsGroup      = PropertyToPropId( psNewsGroup, TRUE );
            PROPID pidNewsGroups     = PropertyToPropId( psNewsGroups, TRUE );
            PROPID pidNewsReferences = PropertyToPropId( psNewsReferences, TRUE );
            PROPID pidNewsMsgid      = PropertyToPropId( psNewsMsgid, TRUE );

            if ( !_propstoremgr.CanStore( pidNewsSubject ) )
                _propstoremgr.Setup( pidNewsSubject, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsFrom ) )
                _propstoremgr.Setup( pidNewsFrom, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsGroup ) )
                _propstoremgr.Setup( pidNewsGroup, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsGroups ) )
                _propstoremgr.Setup( pidNewsGroups, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsReferences ) )
                _propstoremgr.Setup( pidNewsReferences, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );

            if ( !_propstoremgr.CanStore( pidNewsMsgid ) )
                _propstoremgr.Setup( pidNewsMsgid, VT_LPWSTR, 4, ulToken, TRUE, SECONDARY_STORE );
        }

        //
        // User properties destined to the secondary store
        //

        RecoverUserProperties( ulToken, SECONDARY_STORE );
        _propstoremgr.EndTransaction( ulToken, TRUE, pidSecurity, pidVirtualPath);

        //
        // The strings/fileidmap version numbers are 1 greater than the index
        // version, since we needed to change the on-disk format of the hash
        // tables but don't want to force a reindex of the catalog.  Hash tables
        // are rebuilt automatically from the property store if the version is
        // incorrect.
        //

        _strings.LongInit( CURRENT_VERSION_STAMP + 1, _fRecovering );
        _fileIdMap.LongInit( CURRENT_VERSION_STAMP + 1, _fRecovering );

        ciDebugOut(( DEB_ITRACE, "Long Initialization procedure complete\n" ));

        _evtInitialized.Set();
        _fInitialized = TRUE;

#ifdef CI_FAILTEST
        NTSTATUS failStatus = CI_CORRUPT_CATALOG;
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST
    }
    CATCH( CException, e )
    {
        //
        // Set that the initialization failed and CI is not mounted.
        //
        status = e.GetErrorCode();
    }
    END_CATCH

    if ( STATUS_SUCCESS != status )
    {
        HandleError( status );

        if ( !CiCat::IsDiskLowError(status) )
        {
            //
            // Report any error other than the disk full error.
            //
            CLock   lock(_mutex);

            if ( _statusMonitor.GetStatus() != status )
            {
                _statusMonitor.SetStatus( status );
                _statusMonitor.ReportInitFailure();
            }
        }

        THROW( CException( status ) );
    }

    _fRecovering = FALSE;
} //DoRecovery

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::StartScansAndNotifies
//
//  Synopsis:   Enables scanning and tracking notifications.
//
//  History:    12-09-96   srikants   Created
//
//  Notes:      Must be called only after recovery is complete.
//
//----------------------------------------------------------------------------

void CiCat::StartScansAndNotifies()
{
    Win4Assert( !_fRecovering );

    NTSTATUS status = STATUS_SUCCESS;

     TRY
     {
        _scopeTable.StartUp( _docStore, GetPartition() );

        _evtPh2Init.Set();

#ifdef CI_FAILTEST
        NTSTATUS failStatus = CI_CORRUPT_CATALOG;
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        //
        // Just to make sure the shadow virtual root registry entries
        // didn't get messed up...
        //

        AddShadowScopes();

        if ( _fIndexW3Roots || _fIndexNNTPRoots || _fIndexIMAPRoots )
        {
            //
            // DO NOT OBTAIN LOCK WHILE DOING SYNC WITH IIS
            //

            // setup tracking even if iisadmin is hosed -- _notify
            // will poll until iisadmin is up.

            _notify.TrackIISVRoots( _fIndexW3Roots,
                                    _W3SvcInstance,
                                    _fIndexNNTPRoots,
                                    _NNTPSvcInstance,
                                    _fIndexIMAPRoots,
                                    _IMAPSvcInstance );
        }

        // Always synch with IIS.  Indexing of IIS may have been on
        // on the previous run of this catalog but not for this run,
        // so we need to remove those vroots

        SynchWithIIS( TRUE, FALSE );

        if ( 0 != GetName() )
        {
            SynchWithRegistryScopes( FALSE );
            _notify.TrackScopesInRegistry();
        }

        _notify.TrackCiRegistry();

    }
    CATCH( CException, e )
    {
        //
        // Set that the initialization failed and CI is not mounted.
        //
        status = e.GetErrorCode();
    }
    END_CATCH

    if ( STATUS_SUCCESS != status )
    {
        HandleError( status );

        if ( !CiCat::IsDiskLowError(status) )
        {
            //
            // Report any error other than the disk full error.
            //
            CLock   lock(_mutex);

            if ( _statusMonitor.GetStatus() != status )
            {
                _statusMonitor.SetStatus( status );
                _statusMonitor.ReportInitFailure();
            }
        }

        THROW( CException( status ) );
    }

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock lock(_mutex);
        if( IsStarting() )
            _state = eStarted;
    }
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++

} //StartScansAndNotifies

//+---------------------------------------------------------------------------
//
//  Member:     CCiCat::SetRecoveryCompleted
//
//  Synopsis:   Marks that recovery is complete on persistent data
//              structures. It informs the docstore about the completed
//              recovery which can then enable filtering.
//
//  History:    12-09-96   srikants   Created
//
//  Notes:      MUST BE CALLED ONLY BY A WORKER THREAD.
//              Should NOT throw.
//
//----------------------------------------------------------------------------

void CiCat::SetRecoveryCompleted()
{
    Win4Assert( !CImpersonateSystem::IsImpersonated() );
    Win4Assert( !_fRecovering );

    TRY
    {
        _docStore._SetCiCatRecovered();
        _fRecoveryCompleted = TRUE;
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "SetRecoveryCompleted error (0x%X)\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //SetRecoveryCompleted

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::EnableUpdateNotifies
//
//  Synopsis:   Called by the doc store to start scanning and filtering
//              when CI is ready to receive notification changes.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::EnableUpdateNotifies()
{
    Win4Assert( !_fRecovering );
    Win4Assert( _fInitialized );

    _scanMgr.StartScansAndNotifies();
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::LokInit, private
//
//  Synopsis:   Opens content index.  Index corruption failures during
//              LokInit do not require a restart of the process to blow
//              away the corrupt index
//
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

void CiCat::LokInit()
{
    Win4Assert( _mutex.IsHeld() );

    ciDebugOut ((DEB_ITRACE, "CiCat::LokInit.. Catalog Directory is %ws\n", _wcsCatDir ));

    if ( 0 == _xCiManager.GetPointer() )
        THROW( CException( CI_E_NOT_INITIALIZED ) );

#ifdef CI_FAILTEST
        NTSTATUS failStatus = CI_CORRUPT_CATALOG;
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

    TRY
    {
        ciDebugOut ((DEB_ITRACE, "Opening Catalog %ws\n", _wcsCatDir ));

        if ( !_scopeTable.IsInit() )
            _scopeTable.FastInit();

        // Win4Assert( !_scopeTable.IsCiDataCorrupt() );  // Commented out because it's hit by version upgrade.

        if ( _scopeTable.IsFsCiDataCorrupt() )
        {
            ciDebugOut(( DEB_ERROR, "Persistent corruption detected in ci %ws\n",
                         _wcsCatDir ));
            // Win4Assert( !"Corrupt scope table" );  // Commented out because it's hit by version upgrade.
            _pStorage->ReportCorruptComponent( L"CiCatalog2" );

            THROW( CException( CI_CORRUPT_CATALOG ) );
        }

        _propstoremgr.FastInit( _pStorage );

        //
        // If we went down dirty during an initial scan, blow away the
        // catalog and start again.
        //

        BOOL fBackedUpMode = _propstoremgr.IsBackedUpMode();
        ciDebugOut(( DEB_ITRACE, "startup: is backed up mode: %d\n", fBackedUpMode ));

        if ( !fBackedUpMode )
        {
            _pStorage->ReportCorruptComponent( L"Crash during scan" );
            THROW( CException( CI_CORRUPT_CATALOG ) );
        }

#ifdef CI_FAILTEST
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        PRcovStorageObj * pObj = _pStorage->QueryPidLookupTable( 0 );

        // Init takes ownership of the object regardless of whether it
        // succeeds.

        if ( !_PidTable.Init( pObj ) )
        {
            ciDebugOut ((DEB_ERROR, "Failed init of PidTable\n"));
            // Win4Assert( !"Corrupt pid table" );
            _pStorage->ReportCorruptComponent( L"CiCatalog3" );

            THROW (CException(CI_CORRUPT_CATALOG));
        }

#ifdef CI_FAILTEST
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        if ( !_SecStore.Init( _pStorage ) )
        {
            ciDebugOut ((DEB_ERROR, "Failed init of SecStore\n"));
            // Win4Assert( !"Corrupt security store" );
            _pStorage->ReportCorruptComponent( L"CiCatalog4" );

            THROW (CException(CI_CORRUPT_CATALOG));
        }

#ifdef CI_FAILTEST
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        //
        // On initial creation, this will happen.
        // A transaction can only operate on one store at a time,
        // so separate Setup calls into two transactions.
        //

        ULONG_PTR ulToken = _propstoremgr.BeginTransaction();

        _propstoremgr.Setup( pidSecurity, VT_UI4, sizeof (ULONG), ulToken, FALSE, PRIMARY_STORE );
        //
        // Create a pointer to secondary store top-level wid, which will be the
        // counter part of the top-level in the primary
        //
        _propstoremgr.Setup( pidSecondaryStorage, VT_UI4, sizeof (ULONG), ulToken, FALSE, PRIMARY_STORE );

        _propstoremgr.EndTransaction( ulToken, TRUE, pidSecurity, pidVirtualPath );

        ulToken = _propstoremgr.BeginTransaction();

        _propstoremgr.Setup( pidPath, VT_LPWSTR, MAX_PATH / 3, ulToken, FALSE, SECONDARY_STORE );
        _propstoremgr.Setup( pidVirtualPath, VT_UI4, 4, ulToken, FALSE, SECONDARY_STORE );

        _propstoremgr.EndTransaction( ulToken, TRUE, pidSecurity, pidVirtualPath );

        //
        // The strings/fileidmap version numbers are 1 greater than the index
        // version, since we needed to change the on-disk format of the hash
        // tables but don't want to force a reindex of the catalog.  Hash tables
        // are rebuilt automatically from the property store if the version is
        // incorrect.
        //

        _strings.FastInit( _pStorage, CURRENT_VERSION_STAMP + 1 );
        _fileIdMap.FastInit( _pStorage, CURRENT_VERSION_STAMP + 1 );

#ifdef CI_FAILTEST
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        ciDebugOut ((DEB_ITRACE, "Opening Content Index %ws\n", _wcsCatDir ));

#ifdef CI_FAILTEST
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        _state = eQueryOnly;

        // make fixups available so we can start to process queries asap

        SetupScopeFixups();

        _statusMonitor.ReportCIStarted();

        if ( !_fIsReadOnly )
            DoRecovery();
    }
    CATCH(CException, e)
    {
        ciDebugOut (( DEB_ERROR,
                      "Catalog initialization failed, CI exception = %08x\n",
                      e.GetErrorCode() ));

        _statusMonitor.SetStatus( e.GetErrorCode() );

        _strings.Empty();
        _fileIdMap.Empty();
        _propstoremgr.Empty();
        _SecStore.Empty();
        _PidTable.Empty();
        _scopeTable.Empty();
    }
    END_CATCH

    if ( !_statusMonitor.IsOk() )
    {
        SCODE sc = _statusMonitor.GetStatus();

        //
        // If the status is corrupt, we'll blow away the catalog and start
        // again.  Note that a version change error at this point is due to
        // a corrupt file, since normal version changes are detected earlier.
        //

        if ( ! ( IsCiCorruptStatus( sc ) || ( CI_INCORRECT_VERSION == sc ) ) )
            _statusMonitor.ReportInitFailure();

        THROW( CException( sc ) );
    }
} //LokInit

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ForceMerge, public
//
//  Synopsis:   Forces a merge in the content index
//
//  Arguments:  [partid] -- Partition id
//
//  History:    10-Jan-96 KyleP     Added header
//              03-11-98  kitmanh   Don't merge if catalog is
//                                  opened for read-only. Also raise
//                                  assertion fail to warn
//
//--------------------------------------------------------------------------

NTSTATUS  CiCat::ForceMerge( PARTITIONID partid )
{
    if ( _pStorage->IsReadOnly() )
    {
        ciDebugOut(( DEB_WARN, "Cannot merge. Catalog is opened for read-only.\n" ));
        return STATUS_ACCESS_DENIED;
    }


    XInterface<ICiManager> xCiManager;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock   lock(_mutex);
        if ( IsShuttingDown() || 0 == _xCiManager.GetPointer() )
        {
            return STATUS_TOO_LATE;
        }
        else
        {
            _xCiManager->AddRef();
            xCiManager.Set( _xCiManager.GetPointer() );
        }
    }
    // -----------------------------------------------------

    return xCiManager->ForceMerge( CI_MASTER_MERGE );
} //ForceMerge

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::AbortMerge, public
//
//  Synopsis:   Stops a merge in the content index
//
//  Arguments:  [partid] -- Partition id
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

NTSTATUS CiCat::AbortMerge( PARTITIONID partid )
{
    XInterface<ICiManager> xCiManager;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock   lock(_mutex);
        if ( IsShuttingDown() || 0 == _xCiManager.GetPointer() )
        {
            return STATUS_TOO_LATE;
        }
        else
        {
            _xCiManager->AddRef();
            xCiManager.Set( _xCiManager.GetPointer() );
        }
    }
    // -----------------------------------------------------

    return xCiManager->AbortMerge();
} //AbortMerge

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::DumpWorkId, public
//
//  Synopsis:   Debug method to dump CI data
//
//  Arguments:  [wid] -- Workid
//              [iid] -- Index id (0 if any)
//              [pb]  -- Return buffer
//              [cb]  -- Size of return buffer
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

void CiCat::DumpWorkId( WORKID wid, ULONG iid, BYTE * pb, ULONG cb )
{

    Win4Assert( !"Backdoor not supported in framework" );

#if 0
    if ( 0 != _pCci )
    {
        ULONG UNALIGNED * pul = (ULONG UNALIGNED *)pb;
        *pul = CiDumpWorkId;
        pul++;
        *pul = wid;

        pul++;
        *pul = iid;

        _pCci->BackDoor( cb, pb );
    }
#endif  // 0

}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::CreateContentIndex, public
//
//  Synopsis:   Creates a virgin content index.
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

SCODE CiCat::CreateContentIndex()
{

    Win4Assert( !"Must Not Be Called" );

    InitIf();
    return IsStarted();
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::EmptyContentIndex, public
//
//  Synopsis:   Deletes content index (including storage)
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

void CiCat::EmptyContentIndex()
{
    XInterface<ICiManager> xCiManager;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock   lock(_mutex);
        if ( IsShuttingDown() || 0 == _xCiManager.GetPointer() )
        {
            return;
        }
        else
        {
            _xCiManager->AddRef();
            xCiManager.Set( _xCiManager.GetPointer() );
        }
    }
    // -----------------------------------------------------

    SCODE sc = xCiManager->Empty();
    if ( S_OK != sc )
    {
        ciDebugOut(( DEB_ERROR,
                     "ICiManager::Empty failed with error (0x%X)\n",
                     sc ));

        THROW( CException( sc ) );
    }
} //EmptyContentIndex

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::_IsEligibleForFiltering, private
//
//  Synopsis:   Determine if a directory should be filtered
//
//  Arguments:  [pwcsPath] -- directory path name to be tested
//              [ccPath]   -- length of pwcsPath
//
//  Returns:    BOOL - TRUE if directory and contents should be filtered,
//                     FALSE otherwise
//
//  History:    23 Jun 98   VikasMan     Created
//
//  Notes:      This is the function which does the work and gets called from
//              various versions of IsEligbleForFiltering. The path pwcsPath
//              has to be all lowercase.
//
//--------------------------------------------------------------------------

BOOL CiCat::_IsEligibleForFiltering( const WCHAR * pwcsPath, unsigned ccPath )
{
    AssertLowerCase( pwcsPath, ccPath );

    //
    // These files can't be indexed or we'll either deadlock or never filter
    // the files.
    //
    struct SUnfilterable
    {
        WCHAR const * pwcFile;
        unsigned      cwcFile;
    };

    static const SUnfilterable aUnfilterable[] =
    {
        { L"\\classes.dat",      12 },     // classes hive
        { L"\\classes.dat.log",  16 },     // classes hive log
        { L"\\hiberfil.sys",     13 },     // the hibernation file
        { L"\\ntuser.dat",       11 },     // user hive
        { L"\\ntuser.dat.log",   15 },     // user hive log file
        { L"\\pagefile.sys",     13 },     // the pagefile
        { L"\\usrclass.dat",     13 },     // user classes hive file
        { L"\\usrclass.dat.log", 17 },     // user classes hive log file
    };

    const cUnfilterable = sizeof aUnfilterable / sizeof aUnfilterable[0];

    //
    // IMPORTANT OBSERVATION:
    //
    // All the entries above end in either 't', 'g', or 's'
    //

    static const WCHAR aLastLetter[] = L"tgs";
    const cLastLetter = sizeof(aLastLetter)/sizeof(aLastLetter[0]) - 1;

    for ( unsigned i = 0; i < cLastLetter; i++ )
        if ( pwcsPath[ccPath-1] == aLastLetter[i] )
        {
            for ( unsigned j = 0; j < cUnfilterable; j++ )
            {
                SUnfilterable const & entry = aUnfilterable[ j ];

                if ( ( ccPath > entry.cwcFile ) &&
                     ( RtlEqualMemory( pwcsPath + ccPath - entry.cwcFile,
                                       entry.pwcFile,
                                       entry.cwcFile * sizeof WCHAR ) ) )
                {
                    ciDebugOut(( DEB_IWARN,
                                 "File %ws ineligible for filtering (unfilterable).\n",
                                 pwcsPath ));
                    return FALSE;
                }
            }

            break;
        }

    //
    // Nothing in a CATALOG.WCI directory can be indexed.  That is metadata.
    //

    const unsigned CAT_DIR_LEN = sizeof CAT_DIR / sizeof CAT_DIR[0];

    const WCHAR * wcsComponent = pwcsPath;

    while ( wcsComponent = wcschr( wcsComponent + 1, L'\\' ) )
    {
        switch ( wcsComponent[1] )
        {
        case 'c':
            Win4Assert( CAT_DIR[1] == L'c' );
            if ( RtlEqualMemory( wcsComponent, CAT_DIR,
                                 sizeof CAT_DIR - sizeof (WCHAR)) &&
                 ( wcsComponent[ CAT_DIR_LEN-1 ] == L'\\' ||
                   wcsComponent[ CAT_DIR_LEN-1 ] == L'\0' ))
            {
                ciDebugOut(( DEB_IWARN,
                             "File %ws ineligible for filtering (ci metadata).\n",
                             pwcsPath ));
                return FALSE;
            }
            break;

        case L'$':
            Win4Assert( SETUP_DIR_PREFIX[1] == L'$' );
            if ( RtlEqualMemory( wcsComponent, SETUP_DIR_PREFIX,
                                 sizeof SETUP_DIR_PREFIX - sizeof (WCHAR) ) )
            {
                ciDebugOut(( DEB_IWARN,
                             "File %ws ineligible for filtering (nt setup directory).\n",
                             pwcsPath ));
                return FALSE;
            }
            break;
        } //switch
    } //while

    //
    // skip indexing catalog directory.
    //

    if ( _CatDir.IsInScope( pwcsPath, ccPath ) )
        return FALSE;

    //
    // Nothing the admin told us not to index can be indexed.  Duh!
    //

    BOOL fFound = _scopesIgnored.RegExFind( pwcsPath );

    ciDebugOut(( DEB_ITRACE, "%ws %ws\n", pwcsPath,
                 fFound? L"not indexed" : L" indexed" ));

    return !fFound;
} //_IsEligibleForFiltering

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::IsEligibleForFiltering, public
//
//  Synopsis:   Determine if a directory should be filtered
//
//  Arguments:  [wcsDirPath] -- directory path name to be tested
//
//  Returns:    BOOL - TRUE if directory and contents should be filtered,
//                     FALSE otherwise
//
//  History:    09 Feb 96   AlanW     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::IsEligibleForFiltering( WCHAR const* wcsDirPath )
{
    CLowcaseBuf Buf( wcsDirPath );

    return _IsEligibleForFiltering( Buf.Get(), Buf.Length() );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::IsEligibleForFiltering, public
//
//  Synopsis:   Determine if a directory should be filtered
//
//  Arguments:  [lcPath] -- directory path name to be tested
//
//  Returns:    BOOL - TRUE if directory and contents should be filtered,
//                     FALSE otherwise
//
//  History:    17 Jul 96   AlanW     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::IsEligibleForFiltering( const CLowcaseBuf & lcPath )
{
    return _IsEligibleForFiltering( lcPath.Get(), lcPath.Length() );
} //IsEligibleForFiltering

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::IsEligibleForFiltering, public
//
//  Synopsis:   Determine if a directory should be filtered
//
//  Arguments:  [lowerFunnyPath] -- directory path name to be tested
//
//  Returns:    BOOL - TRUE if directory and contents should be filtered,
//                     FALSE otherwise
//
//  History:    23 Jun 98   VikasMan     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::IsEligibleForFiltering( const CLowerFunnyPath & lowerFunnyPath )
{
    return _IsEligibleForFiltering( lowerFunnyPath.GetActualPath(),
                                    lowerFunnyPath.GetActualLength() );
} //IsEligibleForFiltering

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::Update, public
//
//  Synopsis:   Updates an individual workid
//
//  Arguments:  [wid]      -- Workid
//              [partid]   -- Partition id
//              [volumeId] -- Volume id
//              [usn]      -- USN
//              [action]   -- Update or delete
//
//  History:    10-Jan-96 KyleP     Added header
//              07-May-97 SitaramR  Usns
//
//--------------------------------------------------------------------------

SCODE CiCat::Update( WORKID wid,
                     PARTITIONID partid,
                     VOLUMEID volumeId,
                     USN usn,
                     ULONG action )
{
    InitOrCreate();

    if (wid != widInvalid)
    {
        Win4Assert( 0 != _xCiManager.GetPointer() );
        BOOL fDelete = CI_DELETE_OBJ == action;

        CDocumentUpdateInfo info( wid, volumeId, usn, fDelete );
        return _xCiManager->UpdateDocument( &info );
    }
    return S_OK;
} //Update

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::Update
//
//  Synopsis:   Process usn notification
//
//  Arguments:  [lcaseFunnyPath] -- File path
//              [fileId]         -- File id
//              [widParent]      -- Parent workid
//              [usn]            -- Usn
//              [pUsnVolume]     -- Usn volume
//              [fDeleted]       -- Deleted file ?
//              [pLock]          -- If non-zero, this is the cicat lock
//                                  and we have already verified the file
//                                  isn't in the catalog yet.
//
//  History:    07-May-97   SitaramR     Created
//
//--------------------------------------------------------------------------

void  CiCat::Update(
    const CLowerFunnyPath & lcaseFunnyPath,
    FILEID                  fileId,
    WORKID                  widParent,
    USN                     usn,
    CUsnVolume *            pUsnVolume,
    BOOL                    fDeleted,
    CReleasableLock *       pLock )
{
    // NOTE: We do not need cimpersonatesystem here because this is a USN
    // notification, so it is always local!

    //
    // Get rid of any remaining backslash
    //
    // override const here - unethical, but saves us a copy
    BOOL fRemoveBackSlash = ((CLowerFunnyPath&)lcaseFunnyPath).RemoveBackSlash();

    TRY
    {
        WORKID wid;
        ULONG action = CI_UPDATE_OBJ;
        BOOL fNew = FALSE;

        {
            CLock lock( _mutex );

            if ( IsShuttingDown() )
                THROW( CException( STATUS_TOO_LATE ) );

            Win4Assert( 0 != _xCiManager.GetPointer() );
            Win4Assert( fileIdInvalid != fileId );

            // The caller knows for sure that the file doesn't exist in
            // the fileid map, and called this under cicat lock.

            if ( 0 != pLock )
            {
                wid = widInvalid;
                Win4Assert( widInvalid == _fileIdMap.LokFind( fileId, pUsnVolume->VolumeId() ) );
            }
            else
            {
                wid = _fileIdMap.LokFind( fileId, pUsnVolume->VolumeId() );
            }

            if ( fDeleted && widInvalid == wid )
            {
                //
                // This file is not yet known to us. Nothing to do.
                //
                return;
            }

            Win4Assert( IsOnUsnVolume( lcaseFunnyPath.GetActualPath() ) );

            if ( fDeleted )
            {
                ciDebugOut(( DEB_ITRACE, "delete %#I64x %ws\n",
                             fileId, lcaseFunnyPath.GetActualPath() ));
                action = CI_DELETE_OBJ;

                _fileIdMap.LokDelete( fileId, wid );
                _strings.LokDelete( 0, wid, TRUE, TRUE );
            }
            else if ( widInvalid == wid )
            {
                fNew = TRUE;
                wid = _strings.LokAdd( lcaseFunnyPath.GetActualPath(),
                                       fileId,
                                       TRUE,
                                       widParent );

                #if CIDBG == 1
                    ciDebugOut(( DEB_ITRACE, "lokadded %#I64x %#x, '%ws'\n",
                                 fileId, wid, lcaseFunnyPath.GetActualPath() ));

                    //
                    // Just a few lines above in LokLookupWid, we couldn't
                    // lookup the wid using the fileid map.  If we can look
                    // it up now, something is broken.
                    //

                    WORKID widExisting = _fileIdMap.LokFind( fileId,
                                                             pUsnVolume->VolumeId() );
                    if ( widInvalid != widExisting )
                    {
                        Win4Assert( widInvalid != widExisting );
                        ciDebugOut(( DEB_ERROR, "wid %#x, widExisting %#x\n",
                                     wid, widExisting ));
                        ciDebugOut(( DEB_ERROR, "Wid info:" ));
                        DebugPrintWidInfo( wid );
                        ciDebugOut(( DEB_ERROR, "WidExisting info:" ));
                        DebugPrintWidInfo( widExisting );
                    }
                #endif // CIDBG == 1

                //
                // Add fileid -> wid map
                //

                _fileIdMap.LokAdd( fileId, wid, pUsnVolume->VolumeId() );

                ciDebugOut(( DEB_ITRACE,
                             "Added fileId %#I64x -> wid 0x%x mapping\n",
                             fileId, wid ));
            }

            if ( 0 != pLock )
                pLock->Release();
        }

        SCODE sc = Update( wid,
                           GetPartition(),
                           pUsnVolume->VolumeId(),
                           usn,
                           action );

        ciDebugOut(( DEB_USN,
                     "File %ws, fileId %#I64x, widParent 0x%x, usn %#I64x, fDelete %d, processed\n",
                     lcaseFunnyPath.GetActualPath(),
                     fileId,
                     widParent,
                     usn,
                     fDeleted ));

        //
        // Newly created files have pidLastSeenTime and pidAttrib initialized
        // to 0 already in CStrings::LokAdd
        //

        if ( !fNew && !fDeleted && SUCCEEDED(sc))
        {
            FILETIME ftLastSeen;
            RtlZeroMemory( &ftLastSeen, sizeof(ftLastSeen) );
            CStorageVariant var( ftLastSeen );

            XWritePrimaryRecord rec( _propstoremgr, wid );

            SCODE scW = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                            pidLastSeenTime,
                                                            var );
            if ( FAILED( scW ) )
                THROW( CException( scW ) );

            PROPVARIANT propVar;
            propVar.vt = VT_UI4;
            propVar.ulVal = 0;
            scW = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                      pidAttrib,
                  *(CStorageVariant const *)(ULONG_PTR)&propVar );
            if ( FAILED( scW ) )
                THROW( CException( scW ) );
        }
    }
    CATCH( CException, e )
    {
        if ( fRemoveBackSlash )
        {
            // override const here - unethical, but saves us a copy
            ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
        }
        RETHROW();
    }
    END_CATCH

    if ( fRemoveBackSlash )
    {
        // override const here - unethical, but saves us a copy
        ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
    }
} //Update

//+---------------------------------------------------------------------------
//
//  Function:   IsBackupLikeNotification
//
//  Synopsis:   Tests if the change notification is like backup resetting the
//              archive bit.
//
//  Arguments:  [ulAttribNew] - The current file attributes
//              [ulAttribOld] - Previous file attributes that are stored
//
//  Returns:    TRUE if the change notification is due to backup archiving
//              the file.
//              FALSE o/w
//
//  History:    5-13-96   srikants   Created
//
//  Notes:      If the notification is a result of BACKUP turning off the
//              archive bit:
//              1. The archive bit is turned OFF
//              2. The attribute mask MAY have the FILE_ATTRIBUTE_NORMAL
//              turned on.
//
//----------------------------------------------------------------------------

inline BOOL IsBackupLikeNotification( ULONG ulAttribNew, ULONG ulAttribOld )
{
    Win4Assert( (ulAttribNew & FILE_ATTRIBUTE_ARCHIVE) == 0 );

    //
    // See if the only difference between the old and the new attributes
    // is in the FILE_ATTRIBUTE_NORMAL and FILE_ATTRIBUTE_ARCHIVE.
    //
    return ( (ulAttribNew ^ ulAttribOld) &
             (~(FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_ARCHIVE)) ) == 0;
} //IsBackupLikeNotification

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::IsIgnoreNotification
//
//  Synopsis:   Tests if the current notification can be ignored
//
//  Arguments:  [wid]          -  Workid
//              [funnyPath]    -  Full Path of the file
//              [ulFileAttrib] -  Current file attributes of the file
//
//  Returns:    TRUE if the notification can be ignored.
//              FALSE if not.
//
//  History:    5-17-96   srikants   Created
//
//  Notes:      Programs like touch.exe don't update any attributes but just
//              update the last write time. In addition to checking the
//              archive bit, we also have to check the last write time.
//
//----------------------------------------------------------------------------

BOOL CiCat::IsIgnoreNotification( WORKID wid, const CFunnyPath & funnyPath,
                                  ULONG ulFileAttrib )
{
    BOOL fIgnore = TRUE;

    //
    // See if the only difference with the existing attributes is
    // archive bit. In that case, we don't have to refilter the doc.
    //

    XPrimaryRecord rec( _propstoremgr, wid );

    PROPVARIANT propVar;
    if ( !_propstoremgr.ReadProperty( rec.GetReference(), pidAttrib, propVar ) )
        return FALSE;

    ULONG ulOldAttrib = propVar.ulVal;

    if ( !IsBackupLikeNotification(ulFileAttrib, ulOldAttrib) )
        return FALSE;

    //
    // Read the last "seen" time from the property store.
    //

    if ( ( !_propstoremgr.ReadProperty( rec.GetReference(), pidLastSeenTime, propVar ) ) ||
         ( VT_EMPTY == propVar.vt ) ||
         ( 0 == propVar.hVal.QuadPart ) )
        return FALSE;

    //
    // Retrieve the last write time from the file and then compare.
    //

    WIN32_FIND_DATA ffData;
    if ( !GetFileAttributesEx( funnyPath.GetPath(), GetFileExInfoStandard, &ffData ) )
        return FALSE;

    return CompareFileTime( &ffData.ftLastWriteTime,
                            (FILETIME *) &propVar.hVal ) <= 0;
} //IsIgnoreNotification

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::Update
//
//  Synopsis:   Notifies content index about the change to the given document.
//
//  Arguments:  [lcaseFunnyPath]  -  Path of the document that changed.
//              [fDeleted]        -  Set to TRUE if the document is deleted.
//              [ftLastSeen]      - Last seen time
//              [ulFileAttrib]    - File attributes to be written to prop store
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::Update( const CLowerFunnyPath & lcaseFunnyPath,
                    BOOL fDeleted,
                    FILETIME const &ftLastSeen,
                    ULONG ulFileAttrib )
{
    //
    //  Don't filter catalog files
    //
    if ( ! IsEligibleForFiltering( lcaseFunnyPath ) )
        return;

    CImpersonateSystem impersonate;

    // override const here - unethical, but saves us a copy
    BOOL fRemoveBackSlash = ((CLowerFunnyPath&)lcaseFunnyPath).RemoveBackSlash();

    TRY
    {
        WORKID wid;
        USN usn;
        ULONG action;
        BOOL fNew;

        {
            CLock lock( _mutex );

            if ( IsShuttingDown() )
                THROW( CException( STATUS_TOO_LATE ) );

            Win4Assert( 0 != _xCiManager.GetPointer() );

            Win4Assert( !IsOnUsnVolume( lcaseFunnyPath.GetActualPath() ) );

            wid = _strings.LokFind( lcaseFunnyPath.GetActualPath() );

            if ( fDeleted && widInvalid == wid )
            {
                //
                // This file is not yet known to us. Nothing to do.
                //
                return;
            }

            usn = 1;
            action = CI_UPDATE_OBJ;
            fNew = FALSE;

            if ( fDeleted )
            {
                usn = 0;
                action = CI_DELETE_OBJ;
                _strings.LokDelete( lcaseFunnyPath.GetActualPath(), wid );
            }
            else if ( widInvalid == wid )
            {
                fNew = TRUE;
                wid = _strings.LokAdd( lcaseFunnyPath.GetActualPath(),
                                       fileIdInvalid,
                                       FALSE,
                                       widInvalid,
                                       ulFileAttrib,
                                       & ftLastSeen );
            }
        }

        Win4Assert( widInvalid != wid );

        //
        // BACKUP program just turns off the archive bit. We don't want to
        // filter in that case.
        //
        BOOL fIgnore = FALSE;
        if ( !fNew && !fDeleted && !(ulFileAttrib & FILE_ATTRIBUTE_ARCHIVE) )
        {
            fIgnore = IsIgnoreNotification( wid, lcaseFunnyPath, ulFileAttrib );

    #if CIDBG==1
            if ( fIgnore )
            {
                ciDebugOut(( DEB_ITRACE,
                    "Ignoring Archive Bit modification for (%ws)\n",
                    lcaseFunnyPath.GetActualPath() ));
            }
    #endif // CIDBG==1
        }

        SCODE sc = S_OK;
        if ( !fIgnore )
            sc = Update( wid, GetPartition(), CI_VOLID_USN_NOT_ENABLED, usn, action );

        if ( !fNew && !fDeleted && SUCCEEDED(sc) )
        {
            CStorageVariant var( ftLastSeen );

            XWritePrimaryRecord rec( _propstoremgr, wid );

            sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                     pidLastSeenTime,
                                                     var );
            if (FAILED(sc))
                THROW(CException(sc));

            Win4Assert( ulFileAttrib != 0xFFFFFFFF );

            PROPVARIANT propVar;
            propVar.vt = VT_UI4;
            propVar.ulVal = ulFileAttrib;
            sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                     pidAttrib,
                                                     *(CStorageVariant const *)(ULONG_PTR)&propVar );
            if (FAILED(sc))
                THROW(CException(sc));
        }
    }
    CATCH( CException, e )
    {
        if ( fRemoveBackSlash )
        {
            // override const here - unethical, but saves us a copy
            ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
        }
        RETHROW();
    }
    END_CATCH

    if ( fRemoveBackSlash )
    {
        // override const here - unethical, but saves us a copy
        ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
    }
} //Update

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::AddDocuments
//
//  Synopsis:   Adds the given documents to the content index.
//
//  Arguments:  [docList] - List of documents.
//
//  History:    3-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::AddDocuments( CDocList const & docList )
{
    Win4Assert( 0 != _xCiManager.GetPointer() );

    FILETIME    ftLastSeen;
    GetSystemTimeAsFileTime( &ftLastSeen );

    CStorageVariant var( ftLastSeen );

    for ( unsigned i = 0; i < docList.Count(); i++ )
    {
        CDocumentUpdateInfo info( docList.Wid(i),
                                  docList.VolumeId(i),
                                  docList.Usn(i),
                                  FALSE );
        SCODE sc = _xCiManager->UpdateDocument( &info );

        // NTRAID#DB-NTBUG9-83752-2000/07/31-dlee cicat::AddDocuments ignores return code from CIManager::UpdateDocument

        if (SUCCEEDED(sc))
        {
            sc = _propstoremgr.WritePrimaryProperty( docList.Wid(i),
                                                     pidLastSeenTime,
                                                     var );
            if (FAILED(sc))
                THROW(CException(sc));
        }
    }
} //AddDocuments

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::CatalogState, public
//
//  Synopsis:   Compute and return catalog state
//
//  Arguments:  [cDocuments]    -- Total number of documents in catalog
//              [cPendingScans] -- Count of pending scans
//              [fState]        -- In-progress actions
//
//  History:    04-18-96   KyleP      Created
//              05-14-96   KyleP      Added pending scans
//
//----------------------------------------------------------------------------

void CiCat::CatalogState( ULONG & cDocuments,
                          ULONG & cPendingScans,
                          ULONG & fState )
{
    if ( IsShuttingDown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::CatalogState - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( IsStarted() )
    {
        cDocuments = _propstoremgr.CountRecordsInUse();

        if ( IsReadOnly() )
        {
            fState = CI_STATE_READ_ONLY;
            cPendingScans = 0;
        }
        else
        {
            ULONG ulInProgressScans, ulPendingScans;
            _scanMgr.Count( ulInProgressScans, ulPendingScans );

            ULONG ulInProgressUsnScans, ulPendingUsnScans;
            _usnMgr.Count( ulInProgressUsnScans, ulPendingUsnScans );

            cPendingScans = ulInProgressScans
                            + ulPendingScans
                            + ulInProgressUsnScans
                            + ulPendingUsnScans;

            if ( ulInProgressScans > 0 || ulInProgressUsnScans > 0 )
                fState = CI_STATE_SCANNING;
            else
                fState = 0;

            if ( !_fRecoveryCompleted )
                fState |= CI_STATE_RECOVERING;
        }
    }
    else
    {
        cDocuments = 0;
        cPendingScans = 0;
        fState = 0;
    }
} //CatalogState

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::EnumerateProperty, public
//
//  Synopsis:   Iterates all properties
//
//  Arguments:  [ps]        -- Property returned here
//              [cbInCache] -- Number of bytes / record allocated for this property
//              [type]      -- Property type.
//              [storeLevel]-- Property store level.
//              [fIsModifiable] -- Can the meta data for this prop be modified?
//              [iBmk]      -- Bookmark for iteration.  Begin at 0.
//
//  Returns:    TRUE if another property was returned.
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::EnumerateProperty( CFullPropSpec & ps, unsigned & cbInCache,
                               ULONG & type, DWORD & dwStoreLevel,
                               BOOL & fIsModifiable, unsigned & iBmk )
{

    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::EnumerateProperty - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    //
    // Cheat a little here.  I probably should call CQCat...
    //

    BOOL fOk;

    //
    // Note that the 'special' property sets (query\rank, etc.) other
    // than storage are excluded. They can never be in the property cache.
    //

    if ( iBmk <= PID_STG_MAX - 2 )
    {
        static const GUID guidStorage = PSGUID_STORAGE;

        ps.SetPropSet( guidStorage );
        ps.SetProperty( iBmk + 2 );
        iBmk++;
        fOk = TRUE;
    }
    else
    {
        iBmk -= (PID_STG_MAX - 2 + 1); // Want 0-based count.

        fOk = _PidTable.EnumerateProperty( ps, iBmk );

        iBmk += (PID_STG_MAX - 2 + 1); // Back to global count.
    }

    if ( fOk )
    {
        PROPID pid = PropertyToPropId( ps, FALSE );

        if ( pidInvalid == pid )
            return FALSE;

        cbInCache     = _propstoremgr.Size( pid );
        type          = _propstoremgr.Type( pid );
        dwStoreLevel  = _propstoremgr.StoreLevel( pid );
        fIsModifiable = _propstoremgr.CanBeModified( pid );
    }

    return fOk;
} //EnumerateProperty

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::BeginCacheTransaction, public
//
//  Synopsis:   Opens a cache transaction. Aborts any existing open transaction.
//
//  Returns:    Token of new transaction.
//
//  History:    20-Jun-96 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG_PTR CiCat::BeginCacheTransaction()
{
    //
    // Don't let anyone in until the long initialization is completed.
    //

    if ( !_fInitialized )
        _evtInitialized.Wait();


    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::BeginCacheTransaction - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CImpersonateSystem impersonate;

    CLock lockAdmin( _mtxAdmin );

    return _propstoremgr.BeginTransaction();
} //BeginCacheTransaction

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::SetupCache, public
//
//  Synopsis:   Add/Modify/Remove property from cache.
//
//  Arguments:  [ps]       -- Property spec
//              [vt]       -- Data type of value
//              [cbMaxLen] -- Soft-maximum length of value. 0 --> delete
//              [ulToken]  -- Token of active transaction
//
//  History:    17-Jan-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CiCat::SetupCache( CFullPropSpec const & ps,
                        ULONG vt,
                        ULONG cbMaxLen,
                        ULONG_PTR ulToken,
                        BOOL  fCanBeModified,
                        DWORD dwStoreLevel )
{
    //
    // Don't let anyone in until the long initialization is completed.
    //

    if ( !_fInitialized )
        _evtInitialized.Wait();

    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::SetupCache - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CLock lockAdmin( _mtxAdmin );

    PROPID pid = PropertyToPropId( ps, TRUE );

    if ( pid != pidPath && pid != pidLastSeenTime && pid != pidAttrib &&
         pid != pidVirtualPath && pid != pidSecurity &&
         pid != pidParentWorkId && pid != pidSecondaryStorage &&
         pid != pidFileIndex && pid != pidVolumeId &&
         pid != pidSize && pid != pidWriteTime )
    {
        CImpersonateSystem impersonate;

        _propstoremgr.Setup( pid, vt, cbMaxLen, ulToken, fCanBeModified, dwStoreLevel );

        if ( 0 == cbMaxLen )  // Delete
            DeleteUserProperty( ps );
    }
    else
    {
        ciDebugOut(( DEB_WARN, "Attempt to modify caching of required property ignored!\n" ));
        //THROW( CException( STATUS_INVALID_PARAMETER ) );
    }
} //SetupCache

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::EndCacheTransaction, public
//
//  Synopsis:   Closes a cache transaction.
//
//  Arguments:  [ulToken] -- Token of transaction
//              [fCommit] -- TRUE --> Commit changes
//
//  History:    20-Jun-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CiCat::EndCacheTransaction( ULONG_PTR ulToken, BOOL fCommit )
{
    //
    // Don't let anyone in until the long initialization is completed.
    //

    if ( !_fInitialized )
        _evtInitialized.Wait();

    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::EndCacheTransaction - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CImpersonateSystem impersonate;

    CLock lockAdmin( _mtxAdmin );

    _propstoremgr.EndTransaction( ulToken, fCommit, pidSecurity, pidVirtualPath );
} //EndCacheTransaction

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::StoreValue, public
//
//  Synopsis:   Stores value in property cache
//
//  Arguments:  [wid] -- Workid
//              [ps]  -- Property spec
//              [var] -- Value to store
//
//  Returns:    TRUE if the property is in the property store schema
//              FALSE if the property is not in the property store schema
//
//  Notes:      Throws on exceptions.
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

BOOL CiCat::StoreValue( WORKID wid,
                        CFullPropSpec const & ps,
                        CStorageVariant const & var )
{
    if ( !IsStarted() && !IsShuttingDown() )
        return FALSE;

    PROPID pid = PropertyToPropId( ps, FALSE );

    if ( pid != pidInvalid && wid != widInvalid )
    {
        //
        // HACK #721: On NTFS volumes, store LastChange time as LastSeen time.
        //            We don't use LastSeen for NTFS, and we need LastChange.
        //            This trick saves 1 DWORD per primary record.
        //
        //            Note that only NTFS volumes will ever send a LastChange
        //            time.
        //

        if ( pidChangeTime == pid )
            pid = pidLastSeenTime;

        SCODE sc = _propstoremgr.WriteProperty( wid, pid, var );

        if (FAILED(sc))
            HandleError( sc );

        if ( S_OK != sc )
        {
            if ( pidSize == pid )
            {
                ciDebugOut(( DEB_FORCE, "cicat: can't store pidSize: %#x\n", sc ));
            }
        }

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        return (S_OK == sc);
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchValue, public
//
//  Synopsis:   Retrieves value from property cache
//
//  Arguments:  [wid]    -- Workid
//              [pid]    -- Property id
//              [pbData] -- Value returned here
//              [pcb]    -- On input, size in bytes of [pbData].  On
//                          output, size needed to store value.
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

BOOL CiCat::FetchValue( WORKID wid,
                        PROPID pid,
                        PROPVARIANT * pbData,
                        unsigned * pcb )
{
    if ( !IsStarted() && !IsShuttingDown() )
        return FALSE;
    else
        return _propstoremgr.ReadProperty( wid, pid, pbData, pcb );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchValue, public
//
//  Synopsis:   Retrieves value from property cache.  Uses CoTaskMemAlloc
//
//  Arguments:  [wid]    -- Workid
//              [pid]    -- Property id
//              [var]    -- Value returned here
//
//  History:    10-Jan-96 KyleP     Added header
//
//--------------------------------------------------------------------------

BOOL CiCat::FetchValue( WORKID wid,
                        CFullPropSpec const & ps,
                        PROPVARIANT & var )
{
    if ( !IsStarted() && !IsShuttingDown() )
        return FALSE;
    else
    {
        PROPID pid = PropertyToPropId( ps, FALSE );

        if ( pidInvalid != pid )
            return _propstoremgr.ReadProperty( wid, pid, var );
        else
            return FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchValue, public
//
//  Synopsis:   Retrieves value from property cache.  Uses pre-existing
//              property record.
//
//  Arguments:  [pRec]   -- Property record
//              [pid]    -- Property id
//              [pbData] -- Value returned here
//              [pcb]    -- On input, size in bytes of [pbData].  On
//                          output, size needed to store value.
//
//  Returns:    TRUE if property exists (and was returned).
//
//  History:    03-Apr-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::FetchValue( CCompositePropRecord * pRec,
                        PROPID pid,
                        PROPVARIANT * pbData,
                        unsigned * pcb )
{
    if ( (!IsStarted() && !IsShuttingDown()) || 0 == pRec )
        return FALSE;
    else
        return _propstoremgr.ReadProperty( *pRec, pid, pbData, pcb );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchValue, public
//
//  Synopsis:   Retrieves value from property cache.  Uses pre-existing
//              property record.
//
//  Arguments:  [Rec]     -- Property record
//              [pid]     -- Property id
//              [pbData]  -- Value returned here
//              [pbExtra] -- Where to put data that won't fit in pbData
//              [pcbExtra]-- On input, size in bytes of [pbExtra].  On
//                           output, size needed to store value.
//
//  Returns:    TRUE if property exists (and was returned).
//
//  History:    02-Feb-98 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::FetchValue( CCompositePropRecord & Rec,
                        PROPID pid,
                        PROPVARIANT * pvData,
                        BYTE * pbExtra,
                        unsigned * pcbExtra )
{
    if ( (!IsStarted() && !IsShuttingDown()) || 0 == &Rec )
        return FALSE;
    else
        return _propstoremgr.ReadProperty( Rec, pid, *pvData, pbExtra, pcbExtra );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchValue, public
//
//  Synopsis:   Retrieves value from property cache.  Uses pre-existing
//              property record, and allocations are done with CoTaskMem
//
//  Arguments:  [pRec]   -- Property record
//              [pid]    -- Property id
//              [var]    -- Value returned here
//
//  Returns:    TRUE if property exists (and was returned).
//
//  History:    19-Dec-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::FetchValue( CCompositePropRecord * pRec,
                        PROPID pid,
                        PROPVARIANT & var )
{
    if ( (!IsStarted() && !IsShuttingDown()) || 0 == pRec )
        return FALSE;
    else
        return _propstoremgr.ReadProperty( *pRec, pid, var );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::OpenValueRecord, public
//
//  Synopsis:   Opens property record, which can be used for multiple
//              fetch operations.
//
//  Arguments:  [wid] -- WorkId of top-level record to open.
//              [pb]  -- Storage for record
//
//  Returns:    Pointer to record, or zero if invalid.
//
//  History:    03-Apr-96 KyleP     Created
//
//--------------------------------------------------------------------------

CCompositePropRecord * CiCat::OpenValueRecord( WORKID wid, BYTE * pb )
{
    if ( !IsStarted() && !IsShuttingDown() )
        return 0;
    else
        return _propstoremgr.OpenRecord( wid, pb );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::CloseValueRecord, public
//
//  Synopsis:   Closes property record.
//
//  Arguments:  [pRec] -- Pointer to record.  0 is legal.
//
//  History:    03-Apr-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CiCat::CloseValueRecord( CCompositePropRecord * pRec )
{
    if ( 0 != pRec )
        _propstoremgr.CloseRecord( pRec );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::StoreSecurity, public
//
//  Synopsis:   Determine SDID value and save in property cache.
//
//  Arguments:  [wid]    -- Workid of file to store SDID for
//              [pSD]    -- a pointer to the file's security descriptor
//              [cbSD]   -- the size in bytes of the security descriptor
//
//  History:    02 Feb 96 Alanw     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::StoreSecurity( WORKID wid,
                           PSECURITY_DESCRIPTOR pSD,
                           ULONG cbSD )
{
    Win4Assert ( IsStarted() || IsShuttingDown() );

    PROPVARIANT var;
    var.vt = VT_UI4;

    if ( 0 != cbSD )
        var.ulVal = _SecStore.LookupSDID( pSD, cbSD );
    else
        var.ulVal = sdidNull;

    SCODE sc = _propstoremgr.WritePrimaryProperty( wid,
                                                   pidSecurity,
                                                   *(CStorageVariant const *)(ULONG_PTR)&var );

    if (FAILED(sc))
        HandleError( sc );

    return (S_OK == sc);
} //StoreSecurity

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::FetchSDID, public
//
//  Synopsis:   Retrieve SDID value for a file
//
//  Arguments:  [pRec]   -- Property record (may be NULL)
//              [wid]    -- Workid of file for which to fetch SDID
//
//  History:    02 Feb 96 Alanw     Created
//
//--------------------------------------------------------------------------

SDID CiCat::FetchSDID( CCompositePropRecord * pRec, WORKID wid )
{
    PROPVARIANT var;
    unsigned cbVar = sizeof var;

    BOOL fOk;
    if ( 0 == pRec )
        fOk = FetchValue( wid, pidSecurity, &var, &cbVar );
    else
        fOk = FetchValue( pRec, pidSecurity, &var, &cbVar );

    // if the property isn't in the schema, we don't care about security

    if ( !fOk )
        return sdidNull;

    // if there isn't a value yet, assume no access

    if ( VT_UI4 != var.vt )
        return sdidInvalid;

    return var.ulVal;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::AccessCheck, public
//
//  Synopsis:   Perform an access check given an SDID
//
//  Arguments:  [sdid]   -- SDID of file to be checked
//              [hToken] -- token handle for client
//              [am]     -- requested access
//              [fGranted] -- if successful check, whether access was granted
//
//  Returns:    BOOL - TRUE if the access check was successfully done.
//
//  History:    02 Feb 96 Alanw     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::AccessCheck( SDID sdid,
                         HANDLE hToken,
                         ACCESS_MASK am,
                         BOOL & fGranted )
{
    CImpersonateSystem impersonate;

    return _SecStore.AccessCheck( sdid, hToken, am, fGranted );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::PersistMaxUSNs, private
//
//  Synopsis:   Writes the maximum USN processed to the scope table, called
//              at shutdown.
//
//  History:    11-18-98    dlee  Created
//
//----------------------------------------------------------------------------

void CiCat::PersistMaxUSNs()
{
    //
    // Do nothing for read-only catalogs and error cases.
    //

    if ( IsReadOnly() || eStarted != _state )
    {
        ciDebugOut(( DEB_ITRACE, "not persisting max usn...\n" ));
        return;
    }

    //
    // Update the persistent scope table so the high-water USN is
    // persisted.  This is needed if lots of usns have been processed
    // but no documents have been indexed, so ProcessChangesFlush hasn't
    // been called to persist the scope table.
    //

    ciDebugOut(( DEB_ITRACE, "flushinfolist count before %d\n",
                 _usnFlushInfoList.Count() ));

    _usnMgr.GetMaxUSNs( _usnFlushInfoList );

    ciDebugOut(( DEB_ITRACE, "flushinfolist count after %d\n",
                 _usnFlushInfoList.Count() ));

    SerializeChangesInfo();
} //PersistMaxUsns

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ShutdownPhase1, public
//
//  Synopsis:   Dismounts the catalog by stopping all scan/update activity.
//
//  History:    1-30-96   srikants   Created
//
//  Notes:      In phase 1 of shutdown, all activity sent to the framework
//              is disabled.  The framework can still call the property store.
//
//----------------------------------------------------------------------------

void CiCat::ShutdownPhase1()
{
    ciDebugOut(( DEB_ITRACE, "ShutdownPhase1 %ws\n", _xName.Get() ));

    TRY
    {
        CImpersonateSystem impersonate;

        TRY
        {
            PersistMaxUSNs();
        }
        CATCH( CException, e )
        {
            // Ignore it if we can't persist the max usns
            // We'll just index more next time.
        }
        END_CATCH

        // ===================================================
        {
            CLock   lock(_mutex);
            _state = eShutdownPhase1;
        }
        // ===================================================

        _evtInitialized.Set();
        _evtPh2Init.Set();

        _strings.Abort();

        //
        // Initiate the shutdown for operations that may take a while.
        //

        _scanMgr.InitiateShutdown();
        _usnMgr.InitiateShutdown();
        _notify.InitiateShutdown();
        _workMan.AbortWorkItems();
        _scanMgr.WaitForShutdown();
        _usnMgr.WaitForShutdown();
        _notify.WaitForShutdown();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "CiCat::Shutdown failed with error 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //ShutdownPhase1

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ShutdownPhase2, public
//
//  Synopsis:   Finishes catalog dismount
//
//  History:    1-30-96   srikants   Created
//
//  Notes:      Called after framework is stopped.
//
//----------------------------------------------------------------------------

void CiCat::ShutdownPhase2()
{
    TRY
    {
        CImpersonateSystem impersonate;

        // ===================================================
        {
            CLock   lock(_mutex);
            Win4Assert( eShutdownPhase1 == _state );
            _state = eShutdown;
        }
        // ===================================================

        // Tell the property store we're in backedup mode and shutdown
        // cleanly.

        TRY
        {
            if ( !_propstoremgr.IsBackedUpMode() )
                _propstoremgr.MarkBackedUpMode();

            _propstoremgr.Shutdown();
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_ERROR, "CiCat::ShutdownPhase2: nested try block failed with error 0x%X\n",
                         e.GetErrorCode() ));
        }
        END_CATCH

        if ( _pStorage )
        {
            _strings.Shutdown();
            _fileIdMap.Shutdown();
            delete _pStorage;
            _pStorage = 0;
        }

        _workMan.WaitForDeath();

        CLock   lock(_mutex);

        _xCiManager.Free();
        _xAdviseStatus.Free();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "CiCat::ShutdownPhase2 failed with error 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //ShutdownPhase2

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::~CiCat, public
//
//  Synopsis:   Destructor
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

CiCat::~CiCat ()
{
    ciDebugOut(( DEB_WARN, "CiCat::~CiCat: %ws\n", _xName.GetPointer() ));

    if ( !IsShutdown() )
    {
        ShutdownPhase1();
        ShutdownPhase2();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::Touch, public
//
//  Synopsis:   Marks a file as seen (so it appears to the catalog to have
//              been recently saved).
//
//  Arguments:  [wid]   - wid of file to be "touched"
//              [eType] - Seen array type
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

void CiCat::Touch ( WORKID wid, ESeenArrayType eType )
{
    CLock lock(_mutex);
    Win4Assert ( IsInit() );
    _strings.LokSetSeen ( wid, eType );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::WorkIdToPath, public
//
//  Synopsis:   Returns a path for a document given its work id, as funny path
//
//  Arguments:  [wid]       - the work id of the document
//              [funnyPath] - buffer to copy the path
//
//  Returns:    0 if string not found ELSE
//              Count of total chars in funnyPath
//
//  History:    21-May-98 VikasMan  Created
//
//--------------------------------------------------------------------------
unsigned CiCat::WorkIdToPath ( WORKID wid, CFunnyPath& funnyPath )
{
    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::WorkIdToPath - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    Win4Assert( wid != widInvalid );

    unsigned cc = _strings.Find( wid, funnyPath );

#if CIDBG == 1
    if (  cc > 0 )
            ciDebugOut(( DEB_ITRACE, "wid %d (0x%x) --> %.*ws\n", wid, wid,
                         cc, funnyPath.GetActualPath() ));
#endif
    return cc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::WorkIdToAccuratePath, public
//
//  Synopsis:   Returns a path for a document given its work id, as funny path.
//              This variant uses fileid --> path mappings instead of trusting
//              the property store.
//
//  Arguments:  [wid]       - the work id of the document
//              [funnyPath] - buffer to copy the path
//
//  Returns:    0 if string not found ELSE
//              Count of total chars in funnyPath
//
//  History:    31-Dec-1998   KyleP  Created
//
//--------------------------------------------------------------------------

unsigned CiCat::WorkIdToAccuratePath ( WORKID wid, CLowerFunnyPath& funnyPath )
{
    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::WorkIdToPath - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    Win4Assert( wid != widInvalid );

    //
    // First try to get the path based on file id and volume id.
    // This only works for files on USN volumes.
    //

    unsigned cc;
    VOLUMEID volumeId;
    FILEID fileId;

    CCompositePropRecord PropRec( wid, _propstoremgr );

    if ( PropertyRecordToFileId( PropRec, fileId, volumeId ) )
    {
        // PropertyRecordToFileId doesn't return a fileid without a volumeid

        Win4Assert( CI_VOLID_USN_NOT_ENABLED != volumeId );

        cc = FileIdToPath( fileId, volumeId, funnyPath );
    }
    else
        cc = _strings.Find( PropRec, funnyPath );

#if CIDBG == 1
    if (  cc > 0 )
            ciDebugOut(( DEB_ITRACE, "wid %d (0x%x) --> %.*ws\n", wid, wid,
                         cc, funnyPath.GetActualPath() ));
#endif
    return cc;
} // WorkIdToAccuratePath

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::MarkUnReachable
//
//  Synopsis:   Marks the given wid currently unreachable.
//
//  Arguments:  [wid] -  WORKID
//
//  History:    5-21-96   srikants   Created
//
//  Notes:      We write MAXTIME as the last seen time and this will be used
//              as a special value during scanning.
//
//----------------------------------------------------------------------------

void CiCat::MarkUnReachable ( WORKID wid )
{
    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::MarkUnReachable - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    Win4Assert( wid != widInvalid );

    FILETIME ft;
    FillMaxTime(ft);
    CStorageVariant var( ft );
    SCODE sc = _propstoremgr.WritePrimaryProperty( wid, pidLastSeenTime, var );
    if (FAILED(sc))
        THROW(CException(sc));

    //
    //  Set the SDID to avoid showing the file in case access was revoked.
    //
    var.SetUI4( sdidInvalid );
    sc = _propstoremgr.WritePrimaryProperty( wid, pidSecurity, var );
    if (FAILED(sc))
        THROW(CException(sc));
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::PathToWorkId, public
//
//  Synopsis:   Returns a workid for a document given its path.
//
//  Arguments:  [lcaseFunnyPath] -- Fully qualified path
//              [fCreate]        -- if TRUE, create workid for path if it
//                                  doesn't already have one.
//              [fNew]           -- set to TRUE if a new workid is created
//              [pftLastSeen]    -- If non zero pointer, will have the time of
//                                  the file last seen. If the last seen time is
//                                  not known, or this file is being seen for
//                                  the first time, the value will be set to zero.
//              [eType]          -- Seen array type
//              [fileId]         -- fileid if known or fileidInvalid
//              [widParent]      -- Parent workid
//              [fGuaranteedNew] -- TRUE if the caller is under cicat lock
//                                  and has already checked that the file
//                                  is not known yet.
//
//  Returns:    Workid.
//
//  History:    10-Jan-96 KyleP     Added header
//              06-Aug-97 EmilyB    Added fCreate parameter
//              10-Aug-97 EmilyB    Updated to create wids for physical drive
//                                  roots (so they can appear in scope
//                                  hash table)
//              26-Mar-98 KitmanH   If the catalog is r/o, don't LokAdd even
//                                  though the file is not found on disk, just
//                                  return widInvalid
//
//----------------------------------------------------------------------------


WORKID CiCat::PathToWorkId (
    const CLowerFunnyPath & lcaseFunnyPath,
    BOOL           fCreate,
    BOOL &         fNew,
    FILETIME *     pftLastSeen,
    ESeenArrayType eType,
    FILEID         fileId,
    WORKID         widParent,
    BOOL           fGuaranteedNew )
{
    if ( lcaseFunnyPath.IsRemote() )
    {
        CImpersonateSystem impersonate;

        return PathToWorkIdInternal( lcaseFunnyPath,
                              fCreate,
                              fNew,
                              pftLastSeen,
                              eType,
                              fileId,
                              widParent,
                              fGuaranteedNew );
    }
    else
    {
        return PathToWorkIdInternal( lcaseFunnyPath,
                              fCreate,
                              fNew,
                              pftLastSeen,
                              eType,
                              fileId,
                              widParent,
                              fGuaranteedNew );
    }
}

WORKID CiCat::PathToWorkIdInternal(
    const CLowerFunnyPath & lcaseFunnyPath,
    BOOL           fCreate,
    BOOL &         fNew,
    FILETIME *     pftLastSeen,
    ESeenArrayType eType,
    FILEID         fileId,
    WORKID         widParent,
    BOOL           fGuaranteedNew )
{
    //
    // Don't let anyone in until the long initialization is completed.
    //
    if ( !_fInitialized )
        _evtInitialized.Wait();

    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::PathToWorkId - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    if ( !IsEligibleForFiltering( lcaseFunnyPath ) )
        return widInvalid;

    // override const here - unethical, but saves us a copy
    BOOL fRemoveBackSlash = ((CLowerFunnyPath&)lcaseFunnyPath).RemoveBackSlash();

#if CIDBG == 1
    //
    // Check to see if the input path name contains an 8.3 short name
    //
    if (lcaseFunnyPath.IsShortPath( ))
    {
        ciDebugOut(( DEB_IWARN,
                     "PathToWorkId: possible shortname path %ws\n",
                     lcaseFunnyPath.GetActualPath() ));
    }
#endif CIDBG

    TRY
    {
        // =========================================================
        CLock lock ( _mutex );

        BOOL fUsnVolume = VolumeSupportsUsns( lcaseFunnyPath.GetActualPath()[0] );
        WORKID wid;

        if ( fUsnVolume )
        {
            if ( fGuaranteedNew )
            {
                Win4Assert( widInvalid == LokLookupWid( lcaseFunnyPath, fileId ) );
                wid = widInvalid;
            }
            else
            {
                wid = LokLookupWid( lcaseFunnyPath, fileId );
            }

            // If the path was deleted, give up now and return a bogus wid.

            if ( fileIdInvalid == fileId )
                return widInvalid;
        }
        else
        {
            wid = _strings.LokFind( lcaseFunnyPath.GetActualPath() );
        }

        ciDebugOut(( DEB_ITRACE, "pathtoworkid, fCreate %d, wid %#x, fileid %#I64x\n",
                     fCreate, wid, fileId ));

        if ( wid != widInvalid )
        {
            _strings.LokSetSeen( wid, eType );
            if ( pftLastSeen )
                fNew = !_strings.Find( wid, *pftLastSeen );
            else
                fNew = FALSE;
        }
        else if ( fCreate )
        {
            if ( !IsReadOnly() )
            {
                wid = _strings.LokAdd( lcaseFunnyPath.GetActualPath(),
                                       fileId,
                                       fUsnVolume,
                                       widParent );

                if ( fUsnVolume )
                    _fileIdMap.LokAdd( fileId,
                                       wid,
                                       MapPathToVolumeId( lcaseFunnyPath.GetActualPath() ) );

                if ( pftLastSeen )
                    RtlZeroMemory( pftLastSeen, sizeof FILETIME );

                fNew = TRUE;
            }
            else
                wid = widInvalid;
        }
        else
        {
            if ( pftLastSeen )
                RtlZeroMemory( pftLastSeen, sizeof FILETIME );
            fNew = FALSE;
        }

        if ( fRemoveBackSlash )
        {
            // override const here - unethical, but saves us a copy
            ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
        }

        Win4Assert( fCreate || !fNew );

        ciDebugOut(( DEB_ITRACE, "%ws --> wid %d (0x%x)\n", lcaseFunnyPath.GetActualPath(), wid, wid ));
        // =========================================================

        return wid;
    }
    CATCH( CException, e )
    {
        if ( fRemoveBackSlash )
        {
            // override const here - unethical, but saves us a copy
            ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();
        }
        RETHROW();
    }
    END_CATCH

    // Make the compiler happy

    Win4Assert( !"unused codepath" );
    return widInvalid;
} //PathToWorkId

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ComputeRelevantWords, public
//
//  Synopsis:   Computes and returns relevant words for a set of wids
//
//  Arguments:  [cRows]    -- # of rows to compute and in pwid array
//              [cRW]      -- # of rw per wid
//              [pwid]     -- array of wids to work over
//              [partid]   -- partition
//
//  History:    10-May-94 v-dlee  Created
//
//--------------------------------------------------------------------------

CRWStore * CiCat::ComputeRelevantWords(ULONG cRows,ULONG cRW,
                                       WORKID *pwid,PARTITIONID partid)
{
    Win4Assert( !"Not supported in Framework" );

    return 0;
} //ComputeRelevantWords

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::RetrieveRelevantWords, public
//
//  Synopsis:   Retrieves relevant words already computed
//
//  Arguments:  [fAcquire] -- TRUE if ownership is transferred.
//              [partid]   -- partition
//
//  History:    10-May-94 v-dlee  Created
//
//--------------------------------------------------------------------------

CRWStore * CiCat::RetrieveRelevantWords(BOOL fAcquire,PARTITIONID partid)
{
    Win4Assert( !"Not supported in Framework" );
    return 0;
} //RetrieveRelevantWords

//+---------------------------------------------------------------------------
//
//  Member:      CiCat::PidMapToPidRemap, public
//
//  Synopsis:    Converts a pidMapperArray into a pidRemapper
//
//  Arguments:  [pidMap] -- a pid mapper to convert into a pid remapper
//              [pidRemap] -- the converted pid remapper;
//
//  History:     01-Mar-95  DwightKr    Created
//
//----------------------------------------------------------------------------
void CiCat::PidMapToPidRemap( const CPidMapper & pidMap,
                              CPidRemapper & pidRemap )
{
    //
    //  Rebuild the pidRemapper
    //
    pidRemap.ReBuild( pidMap );
}


//+---------------------------------------------------------------------------
//
//  Member:      CiCat::CiState, public
//
//  Synopsis:    Returns state of downlevel CI
//
//  Arguments:   [state] -- buffer to return state into
//
//  History:     14-Dec-95  DwightKr    Created
//
//----------------------------------------------------------------------------

#define setState( field, value ) \
    if ( state.cbStruct >= ( offsetof( CI_STATE, field) +   \
                             sizeof( state.field ) ) )      \
    {                                                       \
        state.field = ( value );                            \
    }


SCODE CiCat::CiState( CI_STATE & state )
{
    //
    // NOTE - We are accessing _xCiManager without explicitly doing an
    // AddRef() because this call is made very frequently. Making a
    // Check about the "Started" state is sufficient - we are cheating
    // but it is a safe cheat.
    //
    SCODE sc = S_OK;

    if ( IsStarted() )
    {
        CIF_STATE   cifState;

        cifState.cbStruct = sizeof( CIF_STATE );
        sc = _xCiManager->GetStatus( &cifState );
        if ( S_OK == sc )
        {

            //
            // Copy the status information from the CIF_STATE format to
            // CI_STATE format.
            //
            state.cbStruct = min( state.cbStruct, sizeof(CI_STATE) );

            setState( cWordList, cifState.cWordList );
            setState( cPersistentIndex, cifState.cPersistentIndex );
            setState( cQueries, cifState.cQueries );
            setState( cDocuments, cifState.cDocuments );
            setState( cSecQDocuments, cifState.cSecQDocuments );
            setState( cFreshTest, cifState.cFreshTest );
            setState( dwMergeProgress, cifState.dwMergeProgress );
            setState( cFilteredDocuments, cifState.cFilteredDocuments );
            setState( dwIndexSize, cifState.dwIndexSize );
            setState( cUniqueKeys, cifState.cUniqueKeys );
            setState( dwPropCacheSize, _propstoremgr.GetTotalSizeInKB() );

            ULONG cTotalDocuments, cPendingScans, stateFlags;
            CatalogState( cTotalDocuments, cPendingScans, stateFlags );

            setState( cTotalDocuments, cTotalDocuments );
            setState( cPendingScans, cPendingScans );

            ULONG eCiState = stateFlags;

            if ( ! IsReadOnly() )
            {
                if ( IsStarting() )
                    eCiState = CI_STATE_STARTING;
                else
                {
                    if ( cifState.eState & CIF_STATE_SHADOW_MERGE )
                        eCiState |= CI_STATE_SHADOW_MERGE;

                    if ( cifState.eState & CIF_STATE_MASTER_MERGE )
                        eCiState |= CI_STATE_MASTER_MERGE;

                    if ( cifState.eState & CIF_STATE_CONTENT_SCAN_REQUIRED )
                        eCiState |= CI_STATE_CONTENT_SCAN_REQUIRED;

                    if ( cifState.eState & CIF_STATE_ANNEALING_MERGE )
                        eCiState |= CI_STATE_ANNEALING_MERGE;

                    if ( cifState.eState & CIF_STATE_INDEX_MIGRATION_MERGE )
                        eCiState |= CI_STATE_INDEX_MIGRATION_MERGE;

                    if ( cifState.eState & CIF_STATE_MASTER_MERGE_PAUSED )
                        eCiState |= CI_STATE_MASTER_MERGE_PAUSED;

                    if ( cifState.eState & CIF_STATE_HIGH_IO )
                        eCiState |= CI_STATE_HIGH_IO;

                    if ( cifState.eState & CIF_STATE_LOW_MEMORY )
                        eCiState |= CI_STATE_LOW_MEMORY;

                    if ( cifState.eState & CIF_STATE_BATTERY_POWER )
                        eCiState |= CI_STATE_BATTERY_POWER;

                    if ( cifState.eState & CIF_STATE_USER_ACTIVE )
                        eCiState |= CI_STATE_USER_ACTIVE;

                    if ( !_usnMgr.IsWaitingForUpdates() )
                        eCiState |= CI_STATE_READING_USNS;
                }
            }

            setState( eState, eCiState );

        }
    }
    else if ( IsShuttingDown() )
        sc = CI_E_SHUTDOWN;
    else
        sc = CI_E_NOT_INITIALIZED;

    return sc;
} //CiState

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::InitIf
//
//  Synopsis:   Initializes CiCat if not already initialized.
//
//  History:    2-27-96   srikants   Created
//
//  Notes:      To reduce lock contention, check to see if we're already
//              initialized without taking the lock.
//
//----------------------------------------------------------------------------

void CiCat::InitIf( BOOL fLeaveCorruptCatalog )
{
    if ( IsInit() )
    {
        if ( !_statusMonitor.IsOk() )
            THROW( CException( _statusMonitor.GetStatus() ) );

        return;
    }

    CLock lock(_mutex);
    CImpersonateSystem impersonate;

    if ( !IsInit() && _statusMonitor.IsOk() && LokExists() )
    {
        SCODE sc = S_OK;

        TRY
        {
            LokInit();
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
            ciDebugOut(( DEB_ERROR, "Error 0x%X while initializing catalog (%ws) \n",
                                    sc, _wcsCatDir ));
        }
        END_CATCH

        if ( S_OK != sc )
        {
            //
            // Normal version changes will be detected much earlier.  A
            // version change detected here is due to corruption.
            //

            if ( IsCiCorruptStatus(sc) || CI_INCORRECT_VERSION == sc )
            {
                if ( fLeaveCorruptCatalog )
                {
                    Win4Assert( !"leaving corrupt catalog" );
                    THROW( CException( sc ) );
                }

                // Win4Assert( !"FSCI(Catalog) Data Corruption" );

                //
                // Log an event that we are doing automatic recovery.
                //

                _statusMonitor.LogEvent( CCiStatusMonitor::eCiRemoved );

                {
                    CImpersonateSystem impersonate;
                    Win4Assert( 0 != _pStorage );
                    _pStorage->DeleteAllFsCiFiles();
                }

                _statusMonitor.Reset();
                LokInit();
                sc = S_OK;
            }
            else
            {
                THROW( CException( sc ) );
            }
        }

        Win4Assert( S_OK == sc );

        _scanMgr.StartRecovery();
    }
    else if ( !_statusMonitor.IsOk() )
    {
        THROW( CException( _statusMonitor.GetStatus() ) );
    }
} //InitIf

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::CreateIf
//
//  Synopsis:   Creates CiCat if not already created.
//
//  History:    2-27-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiCat::CreateIf()
{
    CLock   lock(_mutex);
    if ( !LokExists() )
        LokCreate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::InitOrCreate
//
//  Synopsis:   If there is no ContentIndex, one gets created and intialized
//              If there is a ContentIndex but it is not initialized, it will
//              be initialized.
//
//              Otherwise, nothing is done.
//
//  History:    1-21-96   srikants   Moved from the UpdateDocuments method.
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiCat::InitOrCreate()
{
    CImpersonateSystem impersonate;

    CreateIf();
    InitIf();
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::UpdateDocuments, public
//
//  Synopsis:   Searches a directory and all its sub-directories for files
//              to be updated.
//
//  Arguments:  [wcsRootPath] - directory to start search from
//              [updFlag]     - Flag indicating whether incremental or full
//                              update.
//
//  History:    27-Mar-92 AmyA      Created
//              16-Mar-98 KitmanH   Don't rescan if the catalog is read-only
//
//--------------------------------------------------------------------------

void CiCat::UpdateDocuments ( WCHAR const * wcsRootPath, ULONG updFlag )
{
    if ( IsReadOnly() )
        THROW( CException(STATUS_ACCESS_DENIED) );

    Win4Assert( 0 != wcsRootPath );

    InitOrCreate();

    ciDebugOut (( DEB_ITRACE, "Updating the tree %ws\n", wcsRootPath ));

    ScanOrAddScope( wcsRootPath, FALSE, updFlag, TRUE, TRUE ); // do deletions
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::DoUpdate
//
//  Synopsis:   Synchronously scans the given scope and updates CI with
//              paths from the given scope.  It is assumed that the
//              initialization is already done.
//
//  Arguments:  [pwcsPath] -  Root of the scope to update from.
//              [updFlag]  -  Update flag specifying either incremental
//                            or full.
//              [fDoDeletions] - Should deletion be done ?
//              [fAbort]       - Set to TRUE to abort processing
//              [fProcessRoot] - In the case of a directory, should the root
//                               be filtered ?
//
//  History:    1-21-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::DoUpdate( WCHAR const * pwcPath,
                      ULONG updFlag,
                      BOOL fDoDeletions,
                      BOOL & fAbort,
                      BOOL fProcessRoot )
{
    Win4Assert( 0 != pwcPath );
    Win4Assert( UPD_INCREM == updFlag || UPD_FULL == updFlag );

    CLowerFunnyPath lcaseFunnyRootPath;
    lcaseFunnyRootPath.SetPath( pwcPath );

    // make sure root is given a wid
    // NOTE: this is also done inside the CUpdate ctor

    WORKID widRoot = PathToWorkId( lcaseFunnyRootPath, TRUE );

    CUpdate upd( *this, *(_xCiManager.GetPointer()),
                 lcaseFunnyRootPath, GetPartition(), updFlag == UPD_INCREM,
                 fDoDeletions, fAbort, fProcessRoot );

    upd.EndProcessing();
}


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::DoUpdate
//
//  Synopsis:   Scans all the specified scopes for updates
//
//  Arguments:  [scopes] - Queue of scopes to scan
//              [scanMgr] - a reference to the scan manager
//              [fAbort]  - a reference to a flag that will be set to TRUE
//                          if the scan should be aborted
//
//  History:    1-23-96   srikants   Created
//
//  Notes:      **** Does NOT THROW ****
//
//----------------------------------------------------------------------------

void CiCat::DoUpdate( CScanInfoList & scopes,
                      CCiScanMgr & scanMgr,
                      BOOL & fAbort )
{

    //
    // Performance OPTIMIZATION
    // Modify this later to scan the PropertyStore just once
    // for all the paths in the stack instead of once per path.
    //

    CImpersonateSystem impersonate;

    for ( CFwdScanInfoIter scanInfoIter(scopes);
          !scopes.AtEnd(scanInfoIter);
          scopes.Advance(scanInfoIter) )
    {
        if ( IsShuttingDown() )
        {
            ciDebugOut(( DEB_ITRACE,
                "CiCat::DoUpdate - Shutdown initiated. Stopping scans\n" ));
            break;
        }

        CCiScanInfo * pScanInfo = scanInfoIter.GetEntry();
        Win4Assert( pScanInfo->GetRetries() <= CCiScanInfo::MAX_RETRIES );

        NTSTATUS    status = STATUS_SUCCESS;

        TRY
        {
            if ( scanMgr.IsScopeDeleted( pScanInfo ) )
            {
                RemovePathsFromCiCat( pScanInfo->GetPath(), eScansArray );
                scanMgr.SetDone( pScanInfo );
            }
            else if ( scanMgr.IsRenameDir( pScanInfo ) )
            {
                CLowerFunnyPath lcaseFunnyOldDir, lcaseFunnyNewDir;
                lcaseFunnyOldDir.SetPath( pScanInfo->GetDirOldName() );
                lcaseFunnyNewDir.SetPath( pScanInfo->GetPath() );

                CRenameDir renameDir( *this,
                                      lcaseFunnyOldDir,
                                      lcaseFunnyNewDir,
                                      fAbort,
                                      CI_VOLID_USN_NOT_ENABLED );

                if ( fAbort )
                    break;

                scanMgr.SetScanSuccess( pScanInfo );
            }
            else
            {
                DoUpdate( pScanInfo->GetPath(),
                          pScanInfo->GetFlags(),
                          pScanInfo->IsDoDeletions(),
                          fAbort,
                          pScanInfo->GetProcessRoot() );
                if ( fAbort )
                    break;

                scanMgr.SetScanSuccess( pScanInfo );
            }
        }
        CATCH( CException, e)
        {
            ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in Cicat::DoUpdate\n", e.GetErrorCode() ));

            scanMgr.SetStatus( pScanInfo, e.GetErrorCode() );
            status = e.GetErrorCode();
        }
        END_CATCH

        if ( STATUS_SUCCESS != status )
        {
            HandleError( status );
            if ( _statusMonitor.IsLowOnDisk() )
                break;
        }
    }
} //DoUpdate

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ScanOrAddScope
//
//  Synopsis:   Adds the specified scope to the ContentIndex, if one is not
//              already added.
//
//  Arguments:  [pwszScope]    -  Scope to be added to the ContentIndex
//              [fAdd]         -  If set to TRUE, the scope will be added if
//                                not already present.
//              [updFlag]      -  Flag indicating whether incremental or full
//                                update.
//              [fDoDeletions] -  Set to TRUE if paths in the catalog that were
//                                not found in the scope must be deleted from
//                                CI (garbage collection).
//              [fScanIfNotNew] - If TRUE, the scope is scanned even if
//                                it was already in the scope table.
//              [fCreateShadow] - TRUE if a shadow entry for this scope
//                                should be created in the registry.
//
//  History:    1-21-96   srikants   Created
//              9-16-98   kitmanh    When a new scope is added on the fly,
//                                   register the volume where the scope is
//                                   for device notifications
//
//----------------------------------------------------------------------------

void CiCat::ScanOrAddScope( WCHAR const * pwszScope,
                            BOOL fAdd,
                            ULONG updFlag,
                            BOOL fDoDeletions,
                            BOOL fScanIfNotNew,
                            BOOL fCreateShadow )
{
    Win4Assert( 0 != pwszScope );

    InitOrCreate();

    CLock lockAdmin( _mtxAdmin );

    CLowerFunnyPath lcase( pwszScope );
    if ( lcase.IsShortPath() )
    {
        ciDebugOut(( DEB_WARN, "Converting %ws to long filename ",
                     lcase.GetActualPath() ));

        if ( lcase.ConvertToLongName() )
        {
            ciDebugOut(( DEB_WARN | DEB_NOCOMPNAME, "\t%ws\n",
                         lcase.GetActualPath() ));
        }
        else
        {
            ciDebugOut(( DEB_WARN,
                         "Couldn't convert short filename %ws.\n",
                         lcase.GetActualPath() ));
            THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }
    if ( lcase.GetActualLength() >= MAX_PATH )
    {
        ciDebugOut(( DEB_ERROR, "ScanOrAddScope: Too big (%d) a path (%ws)\n",
                                lcase.GetActualLength(), lcase.GetActualPath() ));
        CCiStatusMonitor::ReportPathTooLong( lcase.GetActualPath() );
        THROW( CException(STATUS_INVALID_PARAMETER) );
    }

    lcase.AppendBackSlash( );

    if ( !IsEligibleForFiltering( lcase ) )
        return ;


    _evtPh2Init.Wait();
    if ( IsShuttingDown() )
        return;

    BOOL fSupportsUsns = VolumeSupportsUsns( lcase.GetActualPath()[0] );

    VOLUMEID volumeId;
    if ( fSupportsUsns )
        volumeId = MapPathToVolumeId( lcase.GetActualPath() );
    else
        volumeId = CI_VOLID_USN_NOT_ENABLED;

    BOOL fInScope = _notify.IsInScope( lcase.GetActualPath() );
    if ( !fInScope && fAdd )
    {
        //
        // Log event
        //

        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_INFORMATION_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_PROOT_ADDED,
                         1 );

        item.AddArg( lcase.GetActualPath() );

        eventLog.ReportEvent( item );

        //
        // Register the volume where the scope is for Device notifcations
        //
        ciDebugOut(( DEB_ITRACE, "Register volume %wc for device notifications\n",
                     pwszScope[0] ));
        if ( L'\\' != toupper(pwszScope[0]) )
            _DrvNotifArray.AddDriveNotification( pwszScope[0] );

        //
        // The given scope is not already in this ContentIndex. It must
        // be added to CI.
        //
        {
            CLock    lock(_mutex);
            // add the path to the persistent list of scopes.
            _scopeTable.AddScope( volumeId,
                                  lcase.GetActualPath(),
                                  fCreateShadow ? _xScopesKey.Get() + SKIP_TO_LM: 0 );
        }

        BOOL fSubScopesRemoved = FALSE;

        //
        // Enable notifications on this scope. Usn scopes are also added to
        // _notify, because the entries in _notify are serialized by the
        // scope table, but the notifications are not turned on for usn
        // scopes.
        //
        FILETIME ftLastScan;
        RtlZeroMemory( &ftLastScan, sizeof(FILETIME) );

        XPtr<CScopeInfo> xScopeInfo;

        if ( fSupportsUsns )
            xScopeInfo.Set( new CScopeInfo( lcase.GetActualPath(),
                                            GetVolumeCreationTime( lcase.GetActualPath() ),
                                            GetVolumeSerialNumber( lcase.GetActualPath() ),
                                            volumeId,
                                            0,
                                            GetJournalId( lcase.GetActualPath() ),
                                            TRUE ) );
        else
            xScopeInfo.Set( new CScopeInfo( lcase.GetActualPath(),
                                            GetVolumeCreationTime( lcase.GetActualPath() ),
                                            GetVolumeSerialNumber( lcase.GetActualPath() ),
                                            ftLastScan ) );

        _notify.AddPath( xScopeInfo.GetReference(), fSubScopesRemoved );

        if ( fSubScopesRemoved )
        {
            //
            // The scope table has some redundant paths (eg f:\foo, f:\bar)
            // and now f:\ has been added. We must get rid of f:\foo and f:\bar
            //
            CLock lock2( _mutex );
            _scopeTable.RemoveSubScopes( lcase.GetActualPath(), _xScopesKey.Get() + SKIP_TO_LM );
        }

        if ( fSupportsUsns )
        {
            //
            // Inform usn manager to do a scan and start monitoring for
            // notifications on this scope
            //

            USN usnStart = 0;
            _usnMgr.AddScope( lcase.GetActualPath(),
                              volumeId,
                              FALSE,     // No need for deletions for new scopes
                              usnStart,
                              FALSE,     // not a full scan
                              FALSE,     // not user-initiated
                              TRUE   );  // new scope
        }
        else
        {
            //
            // trigger a background scan on the scope
            //
            _scanMgr.ScanScope( lcase.GetActualPath(),
                                GetPartition(),
                                UPD_FULL,
                                FALSE,  // don't do deletions
                                FALSE,  // not a delayed scan - immediate
                                TRUE ); // new scope
        }
    }
    else if ( fInScope && fScanIfNotNew )
    {
        //
        // Just force a re-scan with either usn manager or scan manager
        //

        if ( fSupportsUsns )
        {
            USN usnStart = 0;
            BOOL fFull = ( updFlag == UPD_FULL );

            InitUsnTreeScan( lcase.GetActualPath() );
            _usnMgr.AddScope( lcase.GetActualPath(),
                              volumeId,
                              fDoDeletions,
                              usnStart,
                              FALSE,    // not a full USN scan (which deletes all files first)
                              fFull );  // user-initiated if a full scan
        }
        else
        {
            _scanMgr.ScanScope( lcase.GetActualPath(),
                                GetPartition(),
                                updFlag,
                                fDoDeletions,
                                FALSE );   // not a delayed scan - immediate scan
        }
    }
} //ScanOrAddScope

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::IsScopeInCI
//
//  Arguments:  [pwszScope]     -  Scope to be checked
//
//  Returns:    TRUE if [pwszScope] has already been added to content index.
//
//  History:    2-19-96   KyleP      Created
//
//----------------------------------------------------------------------------

BOOL CiCat::IsScopeInCI( WCHAR const * pwszScope )
{
    Win4Assert( 0 != pwszScope );

    InitOrCreate();

    _evtPh2Init.Wait();
    if ( IsShuttingDown() )
    {
        ciDebugOut(( DEB_ERROR, "IsScopeInCI - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    CLock lockAdmin( _mtxAdmin );

    //
    // Terminate the path with a trailing backslash if not already terminated
    // with a backslash.
    //

    CLowerFunnyPath lcase( pwszScope );
    if ( lcase.IsShortPath() )
    {
        ciDebugOut(( DEB_WARN, "Converting %ws to long filename ",
                     lcase.GetActualPath() ));

        if ( lcase.ConvertToLongName() )
        {
            ciDebugOut(( DEB_WARN | DEB_NOCOMPNAME, "\t%ws\n",
                         lcase.GetActualPath() ));
        }
        else
        {
            ciDebugOut(( DEB_WARN,
                         "Couldn't convert short filename %ws.\n",
                         lcase.GetActualPath() ));
            THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }
    if ( lcase.GetActualLength() >= MAX_PATH )
    {
        ciDebugOut(( DEB_ERROR, "Too big (%d) a path (%ws)\n",
                                lcase.GetActualLength(), lcase.GetActualPath() ));
        CCiStatusMonitor::ReportPathTooLong( lcase.GetActualPath() );
        THROW( CException(STATUS_INVALID_PARAMETER) );
    }

    lcase.AppendBackSlash( );

    return _notify.IsInScope( lcase.GetActualPath() );
} //IsScopeInCI


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RemoveScopeFromCI
//
//  Synopsis:   Removes scope permanently from ContentIndex
//
//  Arguments:  [wcsScopeToRemove]  - the scope to remove
//              [fForceRemovalScan] - if true, the scope is scanned and files
//                                    in the scope are removed from the ci
//
//  History:    1-25-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::RemoveScopeFromCI( WCHAR const * wcsScopeToRemove,
                               BOOL          fForceRemovalScan )
{
    CScopeEntry scopeToRemove( wcsScopeToRemove );

    InitOrCreate();

    _evtPh2Init.Wait();
    if ( IsShuttingDown() )
        return;

    CLock lockAdmin( _mtxAdmin );

    //
    // If scope to remove contains special chars, find which scopes need to be
    // rescanned.
    //

    if ( !scopeToRemove.ContainsSpecialChar() )
    {
        ciDebugOut(( DEB_ITRACE, "RemoveThisScope(%ws)\n", scopeToRemove.Get() ));

        RemoveThisScope( scopeToRemove.Get(), fForceRemovalScan );
    }
    else
    {
        if ( !RemoveMatchingScopeTableEntries( wcsScopeToRemove ) )
        {
           // nothing matched, must be file pattern or subdir

           while ( _scopesIgnored.RegExFind( scopeToRemove.Get() ) )
           {

                if ( !scopeToRemove.SetToParentDirectory() )
                {
                   ciDebugOut(( DEB_ITRACE, "Reached Root: %ws, Rescanning \n", scopeToRemove.Get() ));

                   break;
                }
           }

           ciDebugOut(( DEB_ITRACE, "ScanScopeTableEntry(%ws)\n",scopeToRemove.Get() ));

           ScanScopeTableEntry( scopeToRemove.Get() );
        }
    }
} //RemoveScopeFromCI

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::RemoveMatchingScopeTableEntries, private
//
//  Synopsis:   remove any scope table entries that matches input arg.
//
//  Arguments:  [pwszRegXScope] -- input scope to match against
//
//  returns:    TRUE if scope table entries & removed, FALSE otherwise.
//
//  History:    4-12-98     mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CiCat::RemoveMatchingScopeTableEntries( WCHAR const * pwszRegXScope )
{
    CTimeLimit  tl(0,0);
    CDFA        cdfa( pwszRegXScope, tl, FALSE );
    BOOL        bRetVal = FALSE;

    unsigned iBmk = 0;

    WCHAR    awcRoot[MAX_PATH+1];

    while ( !IsShuttingDown() &&
            _scopeTable.Enumerate( awcRoot,
                                   sizeof awcRoot / sizeof WCHAR,
                                   iBmk ) )
    {
        if ( cdfa.Recognize(awcRoot) )
        {
            ciDebugOut(( DEB_ITRACE, "RemoveThisScope(%ws)\n", awcRoot ));

            RemoveThisScope( awcRoot, TRUE );

            bRetVal = TRUE;
        }
    }

    return bRetVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RemoveThisScope
//
//  Synopsis:   Removes scope permanently from ContentIndex
//
//  Arguments:  [wcsPath]           - the scope to remove
//              [fForceRemovalScan] - if true, the scope is scanned and files
//                                    in the scope are removed from the ci
//
//  History:    1-25-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::RemoveThisScope(WCHAR const * wcsPath, BOOL fForceRemovalScan )
{
    CLowerFunnyPath lcase( wcsPath );
    if ( lcase.IsShortPath() )
    {
        ciDebugOut(( DEB_WARN, "Converting %ws to long filename ",
                     lcase.GetActualPath() ));

        if ( lcase.ConvertToLongName() )
        {
            ciDebugOut(( DEB_WARN | DEB_NOCOMPNAME, "\t%ws\n",
                         lcase.GetActualPath() ));
        }
        else
        {
            ciDebugOut(( DEB_WARN,
                         "Couldn't convert short filename %ws.\n",
                         lcase.GetActualPath() ));
            THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }

    //
    // Log event
    //

    CEventLog  eventLog( NULL, wcsCiEventSource );
    CEventItem item( EVENTLOG_INFORMATION_TYPE,
                     CI_SERVICE_CATEGORY,
                     MSG_CI_PROOT_REMOVED,
                     1 );

    item.AddArg( lcase.GetActualPath() );

    eventLog.ReportEvent( item );

    // =================================================
    {
        CLock   lock(_mutex);
        _scopeTable.RemoveScope( lcase.GetActualPath(), _xScopesKey.Get() + SKIP_TO_LM );
    }
    // =================================================

    //
    // Remove the scope from the notification manager to prevent further
    // scan triggers.
    //
    BOOL fInCatalog = TRUE;

    if ( !_notify.RemoveScope( lcase.GetActualPath() ) )
    {
        fInCatalog = FALSE;
        ciDebugOut(( DEB_ERROR, "Path (%ws) not in catalog. Not deleted\n",
                     lcase.GetActualPath() ));
    }

    // Inform the scan manager to stop any in-progress scans on this
    // scope, and remove any files in this scope from the catalog

    if ( fInCatalog || fForceRemovalScan )
    {
        BOOL fSupportsUsns = VolumeSupportsUsns( lcase.GetActualPath()[0] );
        if ( fSupportsUsns )
        {
            //
            // Remove scope from usn manager
            //
            VOLUMEID volumeId = MapPathToVolumeId( lcase.GetActualPath() );
            _usnMgr.RemoveScope( lcase.GetActualPath(), volumeId );
        }
        else
        {
            //
            // Remove scope from scan manager
            //
            _scanMgr.RemoveScope( lcase.GetActualPath() );
        }
    }
} //RemoveThisScope

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::AddVirtualScope, public
//
//  Synopsis:   Add virtual/physical mapping to index
//
//  Arguments:  [vroot]      -- Virtual root
//              [root]       -- Physical root
//              [fAutomatic] -- TRUE for paths tracking Gibraltar
//              [eType]      -- Type of vroot
//              [fVRoot]     -- TRUE if a virtual root, not just a vpath
//              [fIsIndexed] -- TRUE if indexed, FALSE otherwise
//
//  Returns:    TRUE if a change was made.
//
//  History:    2-05-96   KyleP      Created
//
//----------------------------------------------------------------------------

BOOL CiCat::AddVirtualScope(
    WCHAR const * vroot,
    WCHAR const * root,
    BOOL          fAutomatic,
    CiVRootTypeEnum eType,
    BOOL          fVRoot,
    BOOL          fIsIndexed )
{
    CLowcaseBuf lcaseVRoot( vroot );
    CLowerFunnyPath lcaseRoot( root );

    if ( lcaseRoot.IsShortPath() )
    {
        ciDebugOut(( DEB_WARN, "Converting %ws to long filename ",
                     lcaseRoot.GetActualPath() ));

        if ( lcaseRoot.ConvertToLongName() )
        {
            ciDebugOut(( DEB_WARN | DEB_NOCOMPNAME, "\t%ws\n",
                         lcaseRoot.GetActualPath() ));
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                         "Couldn't convert short filename %ws.\n",
                         lcaseRoot.GetActualPath() ));
            THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }

    if ( lcaseRoot.GetActualLength() >= MAX_PATH )
    {
        ciDebugOut(( DEB_ERROR, "Too big (%d) a path (%ws)\n",
                     lcaseRoot.GetActualLength(), lcaseRoot.GetActualPath() ));
        CCiStatusMonitor::ReportPathTooLong( root );
        THROW( CException(STATUS_INVALID_PARAMETER) );
    }

    if ( lcaseVRoot.Length() >= MAX_PATH )
    {
        ciDebugOut(( DEB_ERROR, "Too big (%d) a path (%ws)\n",
                     lcaseVRoot.Length(), lcaseVRoot.Get() ));
        CCiStatusMonitor::ReportPathTooLong( vroot );
        THROW( CException(STATUS_INVALID_PARAMETER) );
    }

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    _evtPh2Init.Wait();
    if ( IsShuttingDown() )
    {
        ciDebugOut(( DEB_ERROR, "AddVirtualScope - Shutdown Initiated\n" ));
        THROW( CException(STATUS_TOO_LATE) );
    }

    CLock lockAdmin( _mtxAdmin );

    BOOL fAdded;

    {
        CLock lock ( _mutex );
        fAdded = _strings.AddVirtualScope( lcaseVRoot.Get(),
                                           lcaseRoot.GetActualPath(),
                                           fAutomatic,
                                           eType,
                                           fVRoot,
                                           fIsIndexed );
    }

    ciDebugOut(( DEB_ITRACE, "Virtual scope %.*ws %s list\n",
                 lcaseVRoot.Length(), lcaseVRoot.Get(),
                 fAdded ? "added to" : "already in" ));

    //
    // If the root was added to the vmap, add it to the scope table
    //

    if ( fVRoot)
    {
        if ( fIsIndexed &&
             ( ( _fIndexW3Roots &&   ( W3VRoot == eType ) ) ||
               ( _fIndexNNTPRoots && ( NNTPVRoot == eType ) ) ||
               ( _fIndexIMAPRoots && ( IMAPVRoot == eType ) ) ) &&
             !IsScopeInCI( root ) )
        {
            AddScopeToCI( root, TRUE );
            ciDebugOut(( DEB_ITRACE, "Physical scope %ws added to list\n", root ));
        }

        if ( !fIsIndexed )
            RemoveVirtualScope( lcaseVRoot.Get(), FALSE, eType, fVRoot, fAdded );
    }

    return fAdded;
} //AddVirtualScope

//+---------------------------------------------------------------------------
//
//  Function:   AreVRootTypesEquiv
//
//  Synopsis:   Returns TRUE if the two enums are equivalent
//
//  Arguments:  [eType]            -- Virtual root
//              [rootType]  -- The other style of enum
//
//  Returns:    TRUE if they are the same, FALSE otherwise
//
//  History:    6-20-97   dlee      Created
//
//----------------------------------------------------------------------------

BOOL AreVRootTypesEquiv(
    CiVRootTypeEnum eType,
    ULONG           rootType )
{
    if ( NNTPVRoot == eType && ( PCatalog::NNTPRoot == rootType ) )
        return TRUE;

    if ( IMAPVRoot == eType && ( PCatalog::IMAPRoot == rootType ) )
        return TRUE;

    if ( W3VRoot == eType && ( 0 == rootType ) )
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RemoveVirtualScope, public
//
//  Synopsis:   Remove virtual/physical mapping to index
//
//  Arguments:  [vroot]             -- Virtual root
//              [fOnlyIfAutomatic]  -- If TRUE, then a manual root will not
//                                     be removed
//              [eType]             -- Type of vroot
//              [fVRoot]            -- TRUE if a vroot, false if a vdir
//              [fForceVPathFixing] -- if TRUE, vpaths are fixed
//
//  History:    2-05-96   KyleP      Created
//
//----------------------------------------------------------------------------

BOOL CiCat::RemoveVirtualScope( WCHAR const * vroot,
                                BOOL fOnlyIfAutomatic,
                                CiVRootTypeEnum eType,
                                BOOL fVRoot,
                                BOOL fForceVPathFixing )
{
    CLowcaseBuf lcaseVRoot( vroot );

    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    _evtPh2Init.Wait();
    if ( IsShuttingDown() )
    {
        ciDebugOut(( DEB_ERROR, "RemoveVirtualScope - Shutdown Initiated\n" ));
        THROW( CException(STATUS_TOO_LATE) );
    }

    if ( lcaseVRoot.Length() >= MAX_PATH )
    {
        ciDebugOut(( DEB_ERROR, "Too big (%d) a path (%ws)\n",
                     lcaseVRoot.Length(), lcaseVRoot.Get() ));
        CCiStatusMonitor::ReportPathTooLong( vroot );
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    CLock lockAdmin( _mtxAdmin );

    BOOL fRemoved;                      // TRUE if virtual root was removed
    BOOL fDelete = FALSE;               // TRUE if physic root should be deleted
    BOOL fChildrenToBeAdded = FALSE;    // TRUE if deletion of super-scope requires
                                        //      addition of sub-scopes.
    CLowerFunnyPath lcaseFunnyPRoot;
    unsigned cwcPRoot = 0;

    {
        CLock lock ( _mutex );

        //
        // Remember the physical root of the virtual root we're
        // about to delete.
        //

        if ( ( _fIndexNNTPRoots && ( NNTPVRoot == eType  ) ) ||
             ( _fIndexW3Roots &&   ( W3VRoot == eType ) ) ||
             ( _fIndexIMAPRoots && ( IMAPVRoot == eType ) ) )
        {
            _strings.VirtualToPhysicalRoot( lcaseVRoot.Get(),
                                            lcaseVRoot.Length(),
                                            lcaseFunnyPRoot,
                                            cwcPRoot );
        }

        fRemoved = _strings.RemoveVirtualScope( lcaseVRoot.Get(),
                                                fOnlyIfAutomatic,
                                                eType,
                                                fVRoot,
                                                fForceVPathFixing );

        ciDebugOut(( DEB_ITRACE, "Virtual scope %.*ws %s list\n",
                     lcaseVRoot.Length(), lcaseVRoot.Get(),
                     fRemoved ? "removed from" : "not in" ));

        // no need to add/remove scopes from the CI if not a vroot

        if ( !fVRoot )
            return fRemoved;

        //
        // If we're running in 'automatic' mode, then we will remove the physical root
        // when the last virtual reference is removed.
        //

        if ( fRemoved &&
             ( ( _fIndexNNTPRoots && ( NNTPVRoot == eType ) ) ||
               ( _fIndexW3Roots &&   ( W3VRoot == eType ) ) ||
               ( _fIndexIMAPRoots && ( IMAPVRoot == eType ) ) ) )
        {
            fDelete = TRUE;
            BOOL fDone = FALSE;

            unsigned iBmk = 0;

            while ( !fDone && fDelete )
            {
                XGrowable<WCHAR> xwcsVRoot;
                unsigned cwcVRoot;

                CLowerFunnyPath lcaseFunnyPRoot2;
                unsigned cwcPRoot2;

                ULONG Type = _strings.EnumerateVRoot( xwcsVRoot,
                                                      cwcVRoot,
                                                      lcaseFunnyPRoot2,
                                                      cwcPRoot2,
                                                      iBmk );

                if ( Type == PCatalog::EndRoot )
                    fDone = TRUE;
                else if ( Type & PCatalog::UsedRoot )
                {
                    if ( cwcPRoot2 == cwcPRoot &&
                         RtlEqualMemory( lcaseFunnyPRoot.GetActualPath(), lcaseFunnyPRoot2.GetActualPath(),
                                         cwcPRoot * sizeof(WCHAR) ) )
                    {
                        ciDebugOut(( DEB_ITRACE, "Keeping physical root %.*ws\n",
                                     cwcPRoot, lcaseFunnyPRoot.GetActualPath() ));
                        fDelete = FALSE;
                    }
                    else if ( cwcPRoot2 > cwcPRoot &&
                              (lcaseFunnyPRoot2.GetActualPath())[cwcPRoot] == L'\\' &&
                              RtlEqualMemory( lcaseFunnyPRoot.GetActualPath(), lcaseFunnyPRoot2.GetActualPath(),
                                              cwcPRoot * sizeof(WCHAR) ) )
                    {
                        fChildrenToBeAdded = TRUE;
                    }
                }
            }
        }
    }

    //
    // Do the dirty deed...
    //

    if ( fDelete )
    {
        Win4Assert(( ( _fIndexNNTPRoots && ( NNTPVRoot == eType ) ) ||
                     ( _fIndexW3Roots &&   ( W3VRoot == eType ) ) ||
                     ( _fIndexIMAPRoots && ( IMAPVRoot == eType ) ) ));

        ciDebugOut(( DEB_ITRACE, "Deleting physical root %ws\n", lcaseFunnyPRoot.GetActualPath() ));
        RemoveScopeFromCI( lcaseFunnyPRoot.GetActualPath(), FALSE );

        if ( fChildrenToBeAdded )
        {
            BOOL fDone = FALSE;

            unsigned iBmk = 0;

            while ( !fDone )
            {
                XGrowable<WCHAR> xwcsVRoot;
                unsigned cwcVRoot;

                ULONG Type = EnumerateVRoot( xwcsVRoot,
                                             cwcVRoot,
                                             lcaseFunnyPRoot,
                                             cwcPRoot,
                                             iBmk );

                if ( Type == PCatalog::EndRoot )
                    fDone = TRUE;
                else if ( ( Type & PCatalog::UsedRoot ) &&
                          ( AreVRootTypesEquiv( eType, Type ) ) )
                {
                    if ( !IsScopeInCI( lcaseFunnyPRoot.GetActualPath() ) )
                    {
                        AddScopeToCI( lcaseFunnyPRoot.GetActualPath(), TRUE );

                        ciDebugOut(( DEB_ITRACE, "Physical sub-scope %ws added to list\n", lcaseFunnyPRoot.GetActualPath() ));
                    }
                }
            }
        }

        //
        // It is possible (though unlikely) that we accidentally deleted a scope
        // that was both a physical and virtual root.  Re-sync physical roots to
        // re-add the physical root.
        //

        SynchWithRegistryScopes( FALSE );
    }

    return fRemoved;
} //RemoveVirtualScope

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::WorkIdToVirtualPath, public
//
//  Synopsis:   Returns a virtual path for a document given its work id.
//
//  Arguments:  [wid]    -- The work id of the document
//              [cSkip]  -- Number of matching virtual roots to skip.
//              [pwcBuf] -- buffer to copy the path
//              [cwc]    -- size of buffer [in/out]
//
//  History:    07-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

unsigned CiCat::WorkIdToVirtualPath( WORKID wid,
                                     unsigned cSkip,
                                     XGrowable<WCHAR> &  xBuf )
{
    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::WorkIdToVirtualPath - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }
    Win4Assert( wid != widInvalid );

    unsigned cwc ;

    if ( !IsStarted() )
        cwc = 0;
    else
        cwc = _strings.FindVirtual( wid, cSkip, xBuf );

    return cwc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CiCat::WorkIdToVirtualPath, public
//
//  Synopsis:   Returns a virtual path for a document given its work id.
//
//  Arguments:  [propRec] -- The property record to use
//              [cSkip]  -- Number of matching virtual roots to skip.
//              [pwcBuf] -- buffer to copy the path
//              [cwc]    -- size of buffer [in/out]
//
//  History:    07-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

unsigned CiCat::WorkIdToVirtualPath( CCompositePropRecord & propRec,
                                     unsigned cSkip,
                                     XGrowable<WCHAR> & xBuf )
{
    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::WorkIdToVirtualPath - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    unsigned cwc;

    if ( !IsStarted() )
        cwc = 0;
    else
       cwc = _strings.FindVirtual( propRec, cSkip, xBuf );

    return cwc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::VirtualToPhysicalRoot, public
//
//  Synopsis:   Given a virtual path, returns a virtual root under that
//              virtual path, and the corresponding physical root.  Will
//              not return overlapping virtual roots.
//
//  Arguments:  [pwcVPath]        -- Virtual path
//              [ccVPath]         -- Size in chars of [pwcVPath]
//              [xwcsVRoot]       -- Virtual root
//              [ccVRoot]         -- Returns count of chars in [xwcsVRoot]
//              [lcaseFunnyPRoot] -- Physical root
//              [ccPRoot]         -- Returns count of actual chars (excluding
//                                   funny path) in [lcaseFunnyPRoot]
//              [iBmk]            -- Bookmark for iteration.
//
//  Returns:    TRUE if match was found.
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CiCat::VirtualToPhysicalRoot( WCHAR const * pwcVPath,
                                   unsigned ccVPath,
                                   XGrowable<WCHAR> & xwcsVRoot,
                                   unsigned & ccVRoot,
                                   CLowerFunnyPath & lcaseFunnyPRoot,
                                   unsigned & ccPRoot,
                                   unsigned & iBmk )
{
    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    return _strings.VirtualToPhysicalRoot( pwcVPath,
                                           ccVPath,
                                           xwcsVRoot,
                                           ccVRoot,
                                           lcaseFunnyPRoot,
                                           ccPRoot,
                                           iBmk );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::EnumerateVRoot, public
//
//  Synopsis:   Iterates all virtual roots.
//
//  Arguments:  [xwcVRoot]        -- Virtual root
//              [ccVRoot]         -- Returns count of chars in [xwcVRoot]
//              [lcaseFunnyPRoot] -- Physical root
//              [ccPRoot]         -- Returns count of actual chars (excluding
//                                   funny path) in [lcaseFunnyPRoot]
//              [iBmk]            -- Bookmark for iteration.
//
//  Returns:    Type of root. PCatalog::EndRoot at end of iteration
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG CiCat::EnumerateVRoot( XGrowable<WCHAR> & xwcVRoot,
                             unsigned & ccVRoot,
                             CLowerFunnyPath & lcaseFunnyPRoot,
                             unsigned & ccPRoot,
                             unsigned & iBmk )
{
    if ( !IsStarted() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    if ( IsShutdown() )
    {
        ciDebugOut(( DEB_ITRACE, "CiCat::EnumerateVRoot - Shutdown Initiated\n" ));
        THROW( CException( STATUS_TOO_LATE ) );
    }

    return _strings.EnumerateVRoot( xwcVRoot,
                                    ccVRoot,
                                    lcaseFunnyPRoot,
                                    ccPRoot,
                                    iBmk );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RemovePathsFromCiCat
//
//  Synopsis:   Removes all the paths below the specified root from the
//              property store. This method must be called ONLY from the
//              scan thread.
//
//  Arguments:  [pwszRoot] - Root of the scope to remove paths from.
//              [eType]    - Seen array type
//
//  History:    1-26-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::RemovePathsFromCiCat( WCHAR const * pwszRoot, ESeenArrayType eType )
{
    // NTRAID#DB-NTBUG9-83756-2000/07/31-dlee removing paths from cicat isn't restartable on crashes

    //
    // Remove it from the hash table and the propertyStore.
    //

    _strings.BeginSeen( pwszRoot, _mutex, eType );
    EndUpdate( TRUE, eType );   // delete the paths.
}



//+---------------------------------------------------------------------------
//
//  Member:     CiCat::SerializeChangesInfo
//
//  Synopsis:   Serializes last scan time and usn flushed info
//
//  History:    20-Aug-97    SitaramR    Created
//
//----------------------------------------------------------------------------

void CiCat::SerializeChangesInfo()
{
    {
        CLock lock( _mutex );
        _notify.UpdateLastScanTimes( _ftLastCLFlush, _usnFlushInfoList );
    }

    //
    // Flush the scope table which will persist the last scan time and usn
    // flush info
    //

    _scopeTable.ProcessChangesFlush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ProcessScansComplete
//
//  Synopsis:   Called when there are no more scans outstanding to update
//              any persistent state information related to scans.
//
//  Arguments:  [fForce]     - Set to TRUE if scope table must be updated
//                             with the scan time even if there were no updates.
//                             This is set when a "force scan" is completed.
//              [fShortWait] - [output] Set to TRUE if the scan thread must
//                             do a wait for a shorter time than the usual 30 minutes.
//                             This is set to TRUE when there is a low resource
//                             situation and the scan thread must wake up
//                             frequently to check if the situation has improved.
//                             This is also set to TRUE when the initialization
//                             is not done yet.
//
//  History:    1-26-96   srikants   Created
//              1-27-97   srikants   Added the fShortWait parameter
//
//----------------------------------------------------------------------------

void CiCat::ProcessScansComplete( BOOL fForce, BOOL & fShortWait )
{
    fShortWait = TRUE;

    if ( IsShuttingDown() || !_fInitialized )
        return;

    SerializeChangesInfo();

    //
    // Always flush the strings table and property store.
    // Property store may get updated without additional documents because
    // of filtering.
    //

    {
        CLock lock( _mutex );

        _fileIdMap.LokFlush();
        _strings.LokFlush();
    }

    _propstoremgr.Flush();

    _notify.ResetUpdateCount();

    //
    // Book-keeping - Schedule any scans if necessary.
    //
    _scopeTable.ScheduleScansIfNeeded( _docStore );

    //
    // See if any scans must be done on network paths with no notifications.
    //
    _notify.ForceNetPathScansIf();

    // NTRAID#DB-NTBUG9-83758-2000/07/31-dlee If failed scans, don't record scans complete

    _scopeTable.RecordScansComplete();

    fShortWait = _scopeTable.IsFullScanNeeded() ||
                 _scopeTable.IsIncrScanNeeded() ||
                 _statusMonitor.IsLowOnDisk();

    // Scans are complete and we won't need that code for awhile

    if ( _regParams.GetMinimizeWorkingSet() )
        SetProcessWorkingSetSize( GetCurrentProcess(),
                                  (SIZE_T) -1,
                                  (SIZE_T) -1 );
} //ProcessScansComplete

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ReScanPath
//
//  Synopsis:   Rescans the given scope. It is called when a notification
//              is lost for a scope.
//
//  Arguments:  [wcsPath] -  The scope to be rescanned. It is assumed that
//              this path is already of interest to CI and so no checks
//              are made to verify that this is a path in CI.
//
//  History:    1-22-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiCat::ReScanPath( WCHAR const * wcsPath, BOOL fDelayed )
{
    _scanMgr.ScanScope( wcsPath, GetPartition(), UPD_INCREM,
                        TRUE,   // do deletions
                        fDelayed    // delayed scan
                        );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::StartUpdate, public
//
//  Synopsis:   Marks start of update
//
//  Arguments:  [time] - (out) the time of the last update of the catalog
//              [pwcsRoot] - Root
//              [fDoDeletions] - Should wids be marked as seen/unseen ?
//              [eType]        - Seen array type
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

void  CiCat::StartUpdate ( FILETIME* time,
                           WCHAR const * pwcsRoot,
                           BOOL fDoDeletions,
                           ESeenArrayType eType )
{
    if ( IsShuttingDown() )
    {
        ciDebugOut(( DEB_ITRACE,
                     "Shutting down in the middle of StartUpdate\n" ));
        THROW( CException(STATUS_TOO_LATE) );
    }

    Win4Assert( IsStarted() );

    if ( fDoDeletions )
        _strings.BeginSeen( pwcsRoot, _mutex, eType );

    _notify.GetLastScanTime( pwcsRoot, *time );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::EndUpdate, public
//
//  Synopsis:   Marks the end of the update
//
//  Arguments:  [fDoDeletions] - if TRUE, unseen files will be deleted and
//                              files not seen before will be added.
//              [eType]       - Seen array type
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

void CiCat::EndUpdate ( BOOL fDoDeletions, ESeenArrayType eType )
{
    USN usn = 0;

    if ( !fDoDeletions )
        return;

    ciDebugOut (( DEB_CAT, "Files not seen:\n" ));

    int cDeletedTotal = 0;
    int cNewTotal = 0;
    const PARTITIONID partId = GetPartition();

    CPropertyStoreWids iter( _propstoremgr );

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
    {
        if ( IsShuttingDown() )
        {
            ciDebugOut(( DEB_WARN,
                         "Shutting down in the middle of EndUpdate\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        // ==================== lock ===================
        CLock lock( _mutex );

        if ( _strings.LokNotSeen( wid, eType ) )
        {
#           if CIDBG == 1
                XGrowable<WCHAR> awc;
                _strings.Find( wid, awc );
                ciDebugOut (( DEB_CAT, "\tdel: %u (0x%x) %ws\n", wid, wid, awc.Get() ));
#           endif

            // Files from USN volumes can only be deleted if the scan was
            // from a USN volume -- only do this work if appropriate.

            if ( eUsnsArray == eType )
            {
                //
                // If the wid is from an ntfs 5.0 volume, then remove it
                // from the file id map.
                //

                PROPVARIANT propVar;
                BOOL fFound = _propstoremgr.ReadPrimaryProperty( wid,
                                                                 pidFileIndex,
                                                                 propVar );
                FILEID fileId = propVar.uhVal.QuadPart;

                if ( fileIdInvalid != fileId )
                {
                    //
                    // File can be added to propstore, then deleted before
                    // the file can be filtered, which means that it's
                    // possible for a file to be in propstore but not in
                    // fileid map.
                    //

                    fFound = _propstoremgr.ReadPrimaryProperty( wid,
                                                                pidVolumeId,
                                                                propVar );

                    Win4Assert( fFound );

                    WORKID widExisting = _fileIdMap.LokFind( fileId, propVar.ulVal );
                    if ( widExisting != widInvalid && wid == widExisting )
                    {
                        //
                        // If wid != widExisting then it means that
                        // LokWriteFileUsnInfo changed the fileid mapping to
                        // a new wid, i.e. fileid now maps to widExisting,
                        // and so the new fileid mapping shouldn't be deleted.
                        //
                        _fileIdMap.LokDelete( fileId, wid );
                    }
                }
            }

            //
            // Delete the wid from strings table and property store
            //

            BOOL fUsnVolume = ( eUsnsArray == eType );
            _strings.LokDelete( 0, wid, fUsnVolume, fUsnVolume );

            //
            // The use of CI_VOLID_USN_NOT_ENABLED below is okay because the
            // usn is 0 and so the real volume id does not matter. In
            // CheckPointChangesFlushed, usns with a value of 0 are ignored.
            // If the real volume id is needed then it needs to be stored
            // in the property store, which is a big overhead.
            //

            CDocumentUpdateInfo info( wid, CI_VOLID_USN_NOT_ENABLED, 0, TRUE );
            _xCiManager->UpdateDocument( &info );

            cDeletedTotal++;
        }
        else if ( _strings.LokSeenNew(wid, eType) )
        {
#           if CIDBG == 1
                XGrowable<WCHAR> awc;
                _strings.Find( wid, awc );
                ciDebugOut (( DEB_CAT, "\tnew: %u (0x%x) %ws\n", wid, wid, awc.Get() ));
#           endif

            CDocumentUpdateInfo info( wid, CI_VOLID_USN_NOT_ENABLED, 0, FALSE );
            _xCiManager->UpdateDocument( &info );

            cNewTotal++;
        }
        // ==================== end lock ===================
    }

    {
        CLock lock( _mutex );
        _strings.LokEndSeen( eType );
    }

    ciDebugOut (( DEB_ITRACE,
                  "%d new documents, %d deleted documents\n",
                  cNewTotal,
                  cDeletedTotal ));
} //EndUpdate

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::HandleError
//
//  Synopsis:   Checks the status code passed and if it indicates corruption,
//              the index will be marked corrupt in-memory as well as on
//              disk. The recovery will happen on a subsequent restart.
//
//  Arguments:  [status] -  The status code to check for corruption.
//
//  History:    3-21-96   srikants   Created
//              3-20-98   kitmanh    Don't Mark catalog corrupt if the catalog
//                                   is read-only
//
//  Notes:      MUST NOT THROW
//
//----------------------------------------------------------------------------

void CiCat::HandleError( NTSTATUS status )
{
    TRY
    {
        if ( IsCiCorruptStatus(status) && !IsReadOnly() )
        {
            CLock   lock(_mutex);

            //
            // If we are initialized and not marked that we are corrupt yet,
            // mark CI corrupt.
            //
            if ( IsInit() )
            {
                //
                // Mark that we are corrupt persistently.
                //
                if ( CI_CORRUPT_DATABASE == status )
                {

                    if ( !_scopeTable.IsCiDataCorrupt() )
                        _scopeTable.MarkCiDataCorrupt();
                }
                else
                {
                    Win4Assert( CI_CORRUPT_CATALOG == status );
                    if ( !_scopeTable.IsFsCiDataCorrupt() )
                        _scopeTable.MarkFsCiDataCorrupt();
                }

                if ( !_statusMonitor.IsCorrupt() )
                {
                    _statusMonitor.ReportFailure( status );
                    _statusMonitor.SetStatus( status );
                }
            }
        }
        else if ( CI_PROPSTORE_INCONSISTENCY == status )
        {
            CLock   lock(_mutex);
            _statusMonitor.ReportPropStoreError();
            _statusMonitor.SetStatus( status );
        }
        else if ( IsDiskLowError(status) )
        {
            NoLokProcessDiskFull();
        }
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Error (0x%X) in CiCat::HandleError\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //HandleError

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::MarkFullScanNeeded
//
//  Synopsis:   Marks that a full scan is needed.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::MarkFullScanNeeded()
{
    _scopeTable.RecordFullScanNeeded();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::MarkIncrScanNeeded
//
//  Synopsis:   Marks that an incremental scan is needed for all the scopes.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::MarkIncrScanNeeded()
{
    _scopeTable.RecordIncrScanNeeded( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ProcessChangesFlush
//
//  Arguments:  [ft]           - Time stamp of the last successful flush.
//              [cEntries ]    - Number of entries in the pUsnEntries.
//              [ppUsnEntries] - Array of USN entries
//
//  Synopsis:   Records the time of the last successful changelog flush, and
//              make a copy of usn flush info.
//
//  History:    1-28-97   srikants   Created
//             05-07-97   SitaramR   Usns
//
//----------------------------------------------------------------------------

void CiCat::ProcessChangesFlush( FILETIME const & ft,
                                 ULONG cEntries,
                                 USN_FLUSH_INFO const * const * ppUsnEntries )
{
    ciDebugOut(( DEB_ITRACE, "ProcessChangesFlush\n" ));

    //
    // We shouldn't flush until Recovery has been performed.
    // Wait for the recovery to be complete before obtaining
    // a lock. Recovery could take a long time.
    //

    _evtPh2Init.Wait();

    // Fix for bug 151799. We will be setting _evtPh2Init if we detect
    // corruption to break a potential deadlock. So we should bail out
    // without flushing if recovery wasn't successfully completed.

    if ( IsShuttingDown() || !IsRecoveryCompleted() )
    {
        ciDebugOut(( DEB_ITRACE, "ProcessChangesFlush abort: shutting down\n" ));
        return;
    }

    CLock lock( _mutex );

    {
        BOOL fAnyInitialScans = ( _scanMgr.AnyInitialScans() ||
                                  _usnMgr.AnyInitialScans() );

        BOOL fIsBackedUpMode = _propstoremgr.IsBackedUpMode();

        if ( !fAnyInitialScans )
        {
            if ( !fIsBackedUpMode )
            {
                ciDebugOut(( DEB_ITRACE, "switch from NotBackedUp to BackedUp\n" ));
                _propstoremgr.MarkBackedUpMode();
            }
        }
        else
        {
            if ( fIsBackedUpMode )
            {
                ciDebugOut(( DEB_ITRACE, "switch from BackedUp to NotBackedUp\n" ));
                _propstoremgr.MarkNotBackedUpMode();
            }
        }
    }

    //
    // Flush the property store so that all documents indexed into it so far
    // will be persisted before the marker is advanced. If we do not flush the
    // prop store before advancing the marker, and if the prop store shut down
    // dirty, we will end up with a few docs that will have to be forced out
    // of the prop store because their wids would be unreliable, and they won't
    // get rescanned because the marker was already advanced.
    //
    // Note: flushing the propertystore manager will reset the backup streams,
    //       so be sure to do this when switching backup modes.
    //

    if ( _propstoremgr.IsBackedUpMode() )
        _propstoremgr.Flush();

    _ftLastCLFlush = ft;

    _usnFlushInfoList.SetUsns( cEntries, ppUsnEntries );

    ScheduleSerializeChanges();
} //ProcessChangesFlush

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ScheduleSerializeChanges
//
//  Synopsis:   Schedules a task with scan manager to serialize changes info
//
//  History:    4-16-96   srikants   Created
//
//----------------------------------------------------------------------------

void CiCat::ScheduleSerializeChanges()
{
    _scanMgr.ScheduleSerializeChanges();
}


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::NoLokProcessDiskFull
//
//  Synopsis:   Processes the disk full situation. Stops any in progress scans
//              and also prevents future scans until the situation eases.
//              Further notifications are also disabled.
//
//  History:    4-16-96   srikants   Created
//
//  Notes:      Don't have a lock on CiCat when calling this
//
//----------------------------------------------------------------------------

void CiCat::NoLokProcessDiskFull()
{
    if ( IsStarted() && !_statusMonitor.IsCorrupt() )
    {
        TRY
        {
            //
            // Don't call _scopeTable.ProcessDiskFull with CiCat lock -
            // there can be a deadlock with the notification manager.
            //

            _scopeTable.ProcessDiskFull( _docStore, GetPartition() );

            //
            // Don't take the lock here.  These are atomic dword updates
            // and the only risk is two debugouts.
            // The resman lock may be held here.
            //

            if ( !_statusMonitor.IsLowOnDisk() )
            {
                ciDebugOut(( DEB_WARN, "CiCat:Entering low disk space state\n" ));
                _statusMonitor.SetDiskFull();
            }
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_ERROR,
                         "Error (0x%X) caught in CiCat::ProcessDiskFull\n" ));
        }
        END_CATCH
    }
} //NoLokProcessDiskFull

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::NoLokClearDiskFull
//
//  Synopsis:   Clears the disk full situation, re-enables notifications and
//              starts a scan on all the paths.
//
//  History:    4-16-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiCat::NoLokClearDiskFull()
{
    if ( IsStarted() && !_statusMonitor.IsCorrupt() )
    {
        if ( _statusMonitor.IsLowOnDisk() )
        {
            //
            // don't obtain cicat lock while calling to scope table - there
            // can be a deadlock with notification manager.
            //
            _scopeTable.ClearDiskFull( _docStore );

            //
            // Don't take the lock here since the resman lock is probably
            // held and this is just an atomic dword write.
            //

            ciDebugOut(( DEB_WARN, "CiCat:Clearing Low DiskSpace\n" ));
            _statusMonitor.ClearLowDiskSpace();
        }
    }
} //NoLokClearDiskFull

//+-------------------------------------------------------------------------
//
//  Function:   GetVRoots
//
//  Synopsis:   Retrieves virtual roots from the given vserver
//
//  Arguments:  [ulInstance] -- the vserver instance
//              [eType]      -- w3/nntp/imap
//              [xDirs]      -- where to write the vroot info
//
//  History:    27-Jan-98 dlee    Created
//
//--------------------------------------------------------------------------

void GetVRoots(
    ULONG                          ulInstance,
    CiVRootTypeEnum                eType,
    XPtr<CIISVirtualDirectories> & xDirs )
{
    //
    // If the vserver instance no longer exists (so the path wasn't found),
    // remove the vroots for that vserver by returning an empty list of
    // vroots.  For any other error, rethrow it.
    //

    TRY
    {
        CMetaDataMgr mdMgr( FALSE, eType, ulInstance );
        xDirs.Set( new CIISVirtualDirectories( eType ) );
        mdMgr.EnumVPaths( xDirs.GetReference() );
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) != e.GetErrorCode() )
            RETHROW();
    }
    END_CATCH
} //GetVRoots

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::SynchWithIIS, private
//
//  Synopsis:   Grovel metabase looking for IIS virtual roots (w3 and/or nntp)
//
//  Arguments:  [fRescanTC] -- if TRUE, rescan the impersonation token cache
//              [fSleep]    -- if TRUE, sleep before doing work.
//
//  Effects:    Automatic virtual roots that are no longer in the metabase
//              (or have changed) are removed here.
//              If Indexing W3 or NNTP is turned off, vroots are removed.
//
//  Notes:      The idea behind the locking is that multiple threads can
//              call this function at once, and only 1 thread should sync
//              at once.  If a thread is syncing and another is waiting
//              on the mutex, the first thread can abort early since the
//              second thread will do the sync.
//
//  History:    15-Feb-95 KyleP     Created
//
//--------------------------------------------------------------------------

void CiCat::SynchWithIIS(
    BOOL fRescanTC,
    BOOL fSleep )
{
    ciDebugOut(( DEB_ITRACE, "SynchWithIIS\n" ));

    //
    // Only need 1 thread waiting for a second thread to abort
    //

    if ( _cIISSynchThreads > 1 )
    {
        ciDebugOut(( DEB_ITRACE, "sync abort really early\n" ));
        return;
    }

    CReferenceCount count( _cIISSynchThreads );

    //
    // Sleep in case other IIS changes are being made in bulk.
    //

    if ( fSleep )
    {
        for ( int i = 0; i < 8; i++ )
        {
            if ( !IsShuttingDown() )
                SleepEx( 1000, TRUE );
        }
    }

    CLock lock( _mtxIISSynch );

    TRY
    {
        //
        // If another thread is above waiting on _mtxIISSynch, abort.
        //

        if ( _cIISSynchThreads > 1 )
        {
            ciDebugOut(( DEB_ITRACE, "sync abort early\n" ));
            count.Decrement();
            return;
        }

        //
        // Enumerate IIS up front and save info in a local copy
        //

        XPtr<CIISVirtualDirectories> xW3VDirs;
        if ( _fIndexW3Roots )
            GetVRoots( _W3SvcInstance, W3VRoot, xW3VDirs );

        XPtr<CIISVirtualDirectories> xNNTPVDirs;
        if ( _fIndexNNTPRoots )
            GetVRoots( _NNTPSvcInstance, NNTPVRoot, xNNTPVDirs );

        XPtr<CIISVirtualDirectories> xIMAPVDirs;
        if ( _fIndexIMAPRoots )
            GetVRoots( _IMAPSvcInstance, IMAPVRoot, xIMAPVDirs );

        XGrowable<WCHAR> xwcsVRoot;
        CLowerFunnyPath lcaseFunnyPRoot;

        unsigned iBmk = 0;
        BOOL fDone = FALSE;

        //
        // First, find any deletions.
        //

        while ( !fDone && !IsShuttingDown() && ( 1 == _cIISSynchThreads ) )
        {
            unsigned cwcVRoot, cwcPRoot;
            ULONG Type = _strings.EnumerateVRoot( xwcsVRoot,
                                                  cwcVRoot,
                                                  lcaseFunnyPRoot,
                                                  cwcPRoot,
                                                  iBmk );

            if ( Type == PCatalog::EndRoot )
                fDone = TRUE;
            else if ( Type & PCatalog::AutomaticRoot )
            {
                BOOL fDelete = FALSE;
                BOOL fIMAP = (0 != (Type & PCatalog::IMAPRoot));
                BOOL fNNTP = (0 != (Type & PCatalog::NNTPRoot));
                Win4Assert( !(fIMAP && fNNTP) );
                BOOL fW3 = !fIMAP && !fNNTP;
                CiVRootTypeEnum eType = fW3 ? W3VRoot : fNNTP ? NNTPVRoot : IMAPVRoot;
                BOOL fNonIndexedVDir = ( 0 != (Type & PCatalog::NonIndexedVDir) );

                if ( ( fNNTP && !_fIndexNNTPRoots ) ||
                     ( fIMAP && !_fIndexIMAPRoots ) ||
                     ( fW3   && !_fIndexW3Roots   ) )
                    fDelete = TRUE;
                else
                {
                    ciDebugOut(( DEB_ITRACE,
                                 "Looking for type %d %ws vroot %ws\n",
                                 Type, GetVRootService( eType ),
                                 xwcsVRoot.Get() ));

                    //
                    // Look up the vpath in the cached metabase list
                    //

                    CIISVirtualDirectories * pDirs = fNNTP ? xNNTPVDirs.GetPointer() :
                                                     fW3 ? xW3VDirs.GetPointer() :
                                                     xIMAPVDirs.GetPointer();
                    Win4Assert( 0 != pDirs );

                    if ( ! pDirs->Lookup( xwcsVRoot.Get(),
                                          cwcVRoot,
                                          lcaseFunnyPRoot.GetActualPath(),
                                          cwcPRoot ) )
                        fDelete = TRUE;
                }

                if ( fDelete )
                {
                    // OPTIMIZATION: if path is a registry scope, migrate
                    // scope from vroot to registry scope.  Otherwise the
                    // files will be deleted, rescanned, and readded.

                    ciDebugOut(( DEB_ITRACE, "removing %ws vroot %ws\n",
                                 GetVRootService( eType ),
                                 xwcsVRoot.Get() ));
                    RemoveVirtualScope( xwcsVRoot.Get(), TRUE, eType, !fNonIndexedVDir );
                }
            }
        }

        //
        // If another thread is above waiting on _mtxIISSynch, abort.
        //

        if ( _cIISSynchThreads > 1 )
        {
            ciDebugOut(( DEB_ITRACE, "sync abort early\n" ));
            count.Decrement();
            return;
        }

        // only set up impersonation and add vroots if indexing w3, nntp, or imap

        if ( _fIndexW3Roots || _fIndexNNTPRoots || _fIndexIMAPRoots )
        {
            if ( !IsShuttingDown() && fRescanTC )
            {
                SignalDaemonRescanTC();
                _impersonationTokenCache.ReInitializeIISScopes(
                    xW3VDirs.GetPointer(),
                    xNNTPVDirs.GetPointer(),
                    xIMAPVDirs.GetPointer() );
            }

            //
            // Now add paths we haven't seen from IIS services
            //

            if ( _fIndexW3Roots && !IsShuttingDown() )
                xW3VDirs->Enum( *this );

            if ( _fIndexNNTPRoots && !IsShuttingDown() )
                xNNTPVDirs->Enum( *this );

            if ( _fIndexIMAPRoots && !IsShuttingDown() )
                xIMAPVDirs->Enum( *this );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Exception 0x%x caught groveling IIS metabase.\n",
                     e.GetErrorCode() ));

        HandleError( e.GetErrorCode() );
    }
    END_CATCH
    ciDebugOut(( DEB_ITRACE, "SynchWithIIS (done)\n" ));
} //SynchWithIIS

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::SynchWithRegistryScopes, private
//
//  Synopsis:   Grovel registry looking for CI scopes to filter
//
//  Arguments:  [fRescanTC] -- if TRUE, rescan the impersonation token cache
//
//  History:    16-Oct-96 dlee     Created
//              30-Jun-98 kitmanh  handle read-only catalogs
//
//--------------------------------------------------------------------------

void CiCat::SynchWithRegistryScopes(
    BOOL fRescanTC )
{
    // All catalogs are named now

    Win4Assert( 0 != GetName() );

    TRY
    {
        ciDebugOut(( DEB_ITRACE, "Reading scopes from '%ws'\n", GetScopesKey() ));
        CRegAccess regScopes( RTL_REGISTRY_ABSOLUTE, GetScopesKey() );

        if ( !IsReadOnly() )
        {
            // First, find any deletions.

            WCHAR awcRoot[MAX_PATH];
            unsigned iBmk = 0;
            BOOL fDone = FALSE;

            //
            // update ignoredscopes table
            //
            while ( !IsShuttingDown() &&
                    _scopesIgnored.Enumerate( awcRoot,
                                              sizeof awcRoot/sizeof WCHAR,
                                              iBmk ) )
            {
                OnIgnoredScopeDelete(awcRoot, iBmk, regScopes);
            }

            //
            // update _scopeTable
            //
            iBmk = 0;

            while ( !IsShuttingDown() &&
                    _scopeTable.Enumerate( awcRoot,
                                           sizeof awcRoot / sizeof WCHAR,
                                           iBmk ) )
            {
                OnIndexedScopeDelete(awcRoot, iBmk, regScopes);
            }

            if ( !IsShuttingDown() )
            {
                if ( fRescanTC )
                {
                    SignalDaemonRescanTC();
                    _impersonationTokenCache.ReInitializeScopes();
                }
            }

            // Now add paths we haven't seen.

            if ( !IsShuttingDown() )
            {
                CRegistryScopesCallBackAdd callback( *this );
                regScopes.EnumerateValues( 0, callback );

                // Do seen processing to remove stale fixups.

                SetupScopeFixups();
            }
        }
        else
        {
            if ( !IsShuttingDown() )
            {
                CRegistryScopesCallBackFillUsnArray callback( *this );
                regScopes.EnumerateValues( 0, callback );
            }
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x caught groveling ci registry.\n",
                     e.GetErrorCode() ));

        HandleError( e.GetErrorCode() );
    }
    END_CATCH

} //SynchWithRegistryScopes


//+-------------------------------------------------------------------------
//
//  Member:     CiCat::OnIndexedScopeDelete, private
//
//  Synopsis:   Grovel registry looking for indexed CI scopes to remove
//
//  Arguments:  [pwcRoot]   -- indexed scope table entry to search for and
//                             possibly remove
//              [iBmk]      -- enumeration index
//              [regScopes] -- registry key to enumerate
//
//  returns:    none.
//
//  History:    16-Oct-96 dlee     Created
//              3-20-98   mohamedn cut from SynchWithRegistryScopes
//
//--------------------------------------------------------------------------

void CiCat::OnIndexedScopeDelete(WCHAR const * pwcRoot, unsigned & iBmk, CRegAccess & regScopes)
{
    ciDebugOut(( DEB_ITRACE, "Looking for on-disk '%ws'\n", pwcRoot ));

    BOOL fDelete = FALSE;
    CRegistryScopesCallBackFind callback( pwcRoot );

    TRY
    {
        regScopes.EnumerateValues( 0, callback );

        // If the physical scope isn't in the registry and it isn't
        // an IIS root, delete it.

        if ( ( !callback.WasFound() ) &&
             ( !_strings.DoesPhysicalRootExist( pwcRoot ) ) )
        {
            fDelete = TRUE;
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x enumerating regscopes for Root '%ws'\n",
                     e.GetErrorCode(),
                     pwcRoot ));

        // No scopes registry key is the likely exception.  Only
        // remove the root if it isn't an IIS root.

        fDelete = !_strings.DoesPhysicalRootExist( pwcRoot );
    }
    END_CATCH

    if ( fDelete )
    {
        ciDebugOut(( DEB_WARN, "removing on-disk root '%ws'\n", pwcRoot ));
        RemoveScopeFromCI( pwcRoot, TRUE );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::OnIgnoredScopeDelete, private
//
//  Synopsis:   Grovel registry looking for excluded CI scopes to remove
//
//  Arguments:  [pwcRoot]   -- ignored scope table entry to search for and
//                             possibly remove
//              [iBmk]      -- enumeration index
//              [regScopes] -- registry key to enumerate
//
//  returns:    none.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

void CiCat::OnIgnoredScopeDelete(WCHAR const * pwcRoot, unsigned & iBmk, CRegAccess & regScopes)
{

    ciDebugOut(( DEB_ITRACE, "OnIgnoredScopeDelete(%ws)\n", pwcRoot ));

    BOOL fDelete = FALSE;
    CRegistryScopesCallBackFind callback( pwcRoot );

    TRY
    {
        regScopes.EnumerateValues( 0, callback );

        if ( !callback.WasFound() )
        {
            fDelete = TRUE;
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x enumerating regscopes for Root '%ws'\n",
                     e.GetErrorCode(),
                     pwcRoot ));

        // No scopes registry key is the likely exception.  Only
        // remove the root if it isn't an IIS root.

        fDelete = !_strings.DoesPhysicalRootExist( pwcRoot );
    }
    END_CATCH

    if ( fDelete )
    {
        ciDebugOut(( DEB_WARN, "removing IgnoredScope '%ws'\n", pwcRoot ));

        //
        // need to rescan scopes that match the regx being removed.
        //

        _scopesIgnored.RemoveElement(pwcRoot);

        iBmk--;

        CScopeEntry deletedIgnoredScope(pwcRoot);

        ciDebugOut(( DEB_ITRACE, "GetScopeToRescan(%ws)\n", deletedIgnoredScope.Get() ));

        ScanScopeTableEntry(deletedIgnoredScope.Get());
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ScanScopeTableEntry, private
//
//  Synopsis:   Initiates a Scan on suitable scope table entries, or passed-in
//              scope.
//
//  Arguments:  [pwszScopeToRescan] -- input scope to rescan
//
//  returns:    none.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

void CiCat::ScanScopeTableEntry(WCHAR const * pwszScopeToRescan)
{
    unsigned iBmk = 0;

    WCHAR    awcRoot[MAX_PATH+1];

    while ( !IsShuttingDown() &&
            _scopeTable.Enumerate( awcRoot,
                                   sizeof awcRoot / sizeof WCHAR,
                                   iBmk ) )
    {
        CScopeMatch scopeToRescan( pwszScopeToRescan, wcslen(pwszScopeToRescan) );

        if ( scopeToRescan.IsPrefix( awcRoot, wcslen(awcRoot) ) )
        {
            ciDebugOut(( DEB_ERROR, "ScanThisScope(%ws)\n", pwszScopeToRescan ));

            ScanThisScope(pwszScopeToRescan);

            break;
        }
        else if ( scopeToRescan.IsInScope( awcRoot, wcslen(awcRoot) ) )
        {
            ciDebugOut(( DEB_ERROR, "ScanThisScope(%ws)\n", awcRoot ));

            ScanThisScope(awcRoot);
        }

    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ScanThisScope, private
//
//  Synopsis:   Forces a scan on the supplied path
//
//  Arguments:  [pwszPath]  -- path to scan
//
//  returns:    none
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

void CiCat::ScanThisScope(WCHAR const * pwszPath)
{
    Win4Assert( pwszPath );

    BOOL fDoDeletions = TRUE;
    BOOL fSupportsUsns = VolumeSupportsUsns( pwszPath[0] );

    VOLUMEID volumeId;

    if ( fSupportsUsns )
        volumeId = MapPathToVolumeId( pwszPath );
    else
        volumeId = CI_VOLID_USN_NOT_ENABLED;

    if ( fSupportsUsns )
    {
        InitUsnTreeScan( pwszPath );

        _usnMgr.AddScope( pwszPath,
                          volumeId,
                          fDoDeletions );
    }
    else
    {
        _scanMgr.ScanScope( pwszPath,
                            GetPartition(),
                            UPD_FULL,
                            fDoDeletions,
                            FALSE );   // not a delayed scan - immediate scan
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::SetupScopeFixups, private
//
//  Synopsis:   Grovel registry looking for CI scopes and setup fixups
//
//  History:    16-Oct-96 dlee     Created
//
//--------------------------------------------------------------------------

void CiCat::SetupScopeFixups()
{
    // is the catalog not named? if so, it isn't in the registry

    if ( 0 == GetName() )
        return;

    TRY
    {
        _scopeFixup.BeginSeen();

        ciDebugOut(( DEB_ITRACE, "Reading scope fixups from '%ws'\n", GetScopesKey() ));
        CRegAccess regScopes( RTL_REGISTRY_ABSOLUTE, GetScopesKey() );

        CRegistryScopesCallBackFixups callback( this );
        regScopes.EnumerateValues( 0, callback );

        _scopeFixup.EndSeen();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x caught groveling ci registry fixups.\n",
                     e.GetErrorCode() ));

        HandleError( e.GetErrorCode() );
    }
    END_CATCH
} //SetupScopeFixups


//
// Support for CI Frame Work
//
//+---------------------------------------------------------------------------
//
//  Member:     CiCat::StartupCiFrameWork
//
//  Synopsis:   Takes the CiManager object pointer and refcounts it.
//
//  Arguments:  [pICiManager] -
//
//  History:    12-05-96   srikants   Created
//
//  Note:       Choose a better name.
//
//----------------------------------------------------------------------------

//
void CiCat::StartupCiFrameWork( ICiManager * pICiManager )
{
    Win4Assert( 0 != pICiManager );
    Win4Assert( 0 == _xCiManager.GetPointer() );

    if ( 0 == _xCiManager.GetPointer() )
    {
        pICiManager->AddRef();
        _xCiManager.Set( pICiManager );
    }

    RefreshRegistryParams();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RefreshRegistryParams
//
//  Synopsis:   Refreshes CI registry parameters.
//
//  History:    12-12-96   srikants   Created
//               1-25-97   mohamedn   ICiAdminParams, ICiAdmin
//  Notes:
//
//----------------------------------------------------------------------------

void CiCat::RefreshRegistryParams()
{

    ICiAdminParams              *pICiAdminParams = 0;
    XInterface<ICiAdminParams>  xICiAdminParams;

    ICiAdmin                    *pICiAdmin = 0;
    XInterface<ICiAdmin>        xICiAdmin;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock   lock(_mutex);

        if ( !IsShuttingDown() && 0 != _xCiManager.GetPointer() )
        {
            // get pICiAdminParams
            SCODE sc = _xCiManager->GetAdminParams( &pICiAdminParams );
            if ( FAILED(sc) )
            {
                Win4Assert( 0 == pICiAdminParams );

                THROW( CException(sc) );
            }

            xICiAdminParams.Set(pICiAdminParams);

            // get pICiAdmin
            sc = _xCiManager->QueryInterface(IID_ICiAdmin,(void **)&pICiAdmin);
            if ( FAILED(sc) )
            {
                 Win4Assert( 0 == pICiAdmin );

                 THROW( CException(sc) );
            }

            xICiAdmin.Set(pICiAdmin);
        }
    }
    // -----------------------------------------------------

    if ( !xICiAdmin.IsNull() )
    {
        SCODE sc = xICiAdmin->InvalidateLangResources();
        if ( FAILED (sc) )
        {
             Win4Assert( !"Failed to InvalidateLangResources\n" );

             THROW( CException(sc) );
        }
    }

    if ( 0 != pICiAdminParams )
        _regParams.Refresh(pICiAdminParams);

    //
    // Did we switch on/off auto-aliasing?
    //

    if ( _fAutoAlias != _regParams.IsAutoAlias() )
    {
        _fAutoAlias = _regParams.IsAutoAlias();
        SynchShares();
    }
} //RefreshRegistryParams

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::MakeBackupOfPropStore
//
//  Synopsis:   Pass through to CPropertyStore::MakeBackupCopy
//
//  Arguments:  [pwszDir]          - The directory in which to create the
//              backup.
//              [pIProgressNotify] -
//              [fAbort]           -
//              [pIWorkIds]        -
//
//  History:    3-26-97   srikants   Created
//              3-12-98   kitmanh    Passed FALSE to the constructor of
//                                   CiStorage, since backup should always
//                                   be writable
//              01-Nov-98 KLam       Pass DiskSpaceToLeave to CiStorage
//
//----------------------------------------------------------------------------

void CiCat::MakeBackupOfPropStore( WCHAR const * pwszDir,
                                   IProgressNotify * pIProgressNotify,
                                   BOOL & fAbort,
                                   ICiEnumWorkids * pIWorkIds )
{
    XPtr<CiStorage> xStorage( new CiStorage( pwszDir,
                                             _xAdviseStatus.GetReference(),
                                             _regParams.GetMinDiskSpaceToLeave(),
                                             CURRENT_VERSION_STAMP,
                                             FALSE) );

    _propstoremgr.MakeBackupCopy( pIProgressNotify,
                               fAbort,
                               xStorage.GetReference(),
                               pIWorkIds,
                               0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::IsDirectory
//
//  Synopsis:   Returns TRUE if the file is a directory
//
//  Arguments:  [pOldFunnyPath] - File to check
//              [pNewFunnyPath] - If a file/dir is renamed, then the attributes
//                                of this file are checked to determine whether
//                                pwcsOldFileName is a directory or not
//
//  History:    20-Mar-96   SitaramR   Created
//
//----------------------------------------------------------------------------

BOOL CiCat::IsDirectory(
    const CLowerFunnyPath * pOldFunnyPath,
    const CLowerFunnyPath * pNewFunnyPath )
{
    BOOL fUsnVolume = IsOnUsnVolume( pOldFunnyPath->GetActualPath() );
    WORKID wid;

    {
        CLock lock( _mutex );

        FILEID fileId = fileIdInvalid;

        if ( fUsnVolume )
            wid = LokLookupWid( *pOldFunnyPath, fileId );
        else
            wid = _strings.LokFind( pOldFunnyPath->GetActualPath() );
    }

    if ( wid == widInvalid )
    {
        if ( pNewFunnyPath == 0 )
            return FALSE;
        else
        {
            //
            // For rename file notifications, use attributes of pwcsNewFileName
            // to determine whether pwcsOldFileName is a directory or not
            //
            ULONG ulFileAttrib = GetFileAttributes( pNewFunnyPath->GetPath() );

            if ( ulFileAttrib == 0xFFFFFFFF )
                return FALSE;
            else
                return ( ulFileAttrib & FILE_ATTRIBUTE_DIRECTORY );
        }
    }
    else
    {
        PROPVARIANT propVar;
        if ( _propstoremgr.ReadPrimaryProperty( wid, pidAttrib, propVar ) )
        {
            if ( propVar.vt == VT_EMPTY )
            {
                //
                // Case where directories are not being filtered
                //
                return FALSE;
            }

            Win4Assert( propVar.vt == VT_UI4 );

            return ( propVar.ulVal & FILE_ATTRIBUTE_DIRECTORY );
        }
        else
            return FALSE;
    }
} //IsDirectory

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::IsOnUsnVolume
//
//  Synopsis:   Is the path on a volume that supports usns
//
//  Arguments:  [pwszPath] - Path to check
//
//  History:    03-Feb-98   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CiCat::IsOnUsnVolume( WCHAR const *pwszPath )
{
    Win4Assert( 0 != pwszPath );

    // Usns are not supported for remote paths

    if ( L'\\' == pwszPath[0] )
        return FALSE;

    // Look in cache of known usn volumes

    for ( unsigned i = 0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == pwszPath[0] )
            return _aUsnVolumes[i].FUsnVolume();
    }

    return FALSE;
} //IsOnUsnVolume

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::VolumeSupportsUsns
//
//  Synopsis:   Checks if the volume supports USNs
//
//  Arguments:  [wcVolume]  -- volume letter to check
//
//  History:    05-May-97   SitaramR   Created
//
//  Notes:      This method has the side-effect of registering this volume
//              for USN processing.
//
//----------------------------------------------------------------------------

BOOL CiCat::VolumeSupportsUsns( WCHAR wcVolume )
{
    //
    // Usns are not supported for remote paths
    //

    if ( L'\\' == wcVolume )
        return FALSE;

    //
    // Look in the cache of known usn volumes
    //

    for ( unsigned i = 0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == wcVolume )
            return _aUsnVolumes[i].FUsnVolume();
    }

    CLock lock( _mutex );

    //
    // Look in the cache again under lock, in case some other thread slipped
    // it in the array.
    //

    for ( i = 0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == wcVolume )
            return _aUsnVolumes[i].FUsnVolume();
    }

    //
    // Find out if it's a USN volume and add the result to the cache
    //

    CImpersonateSystem impersonate;

    BOOL fUsnVolume = FALSE;
    USN_JOURNAL_DATA UsnJournalInfo;
    FILE_FS_VOLUME_INFORMATION VolumeInfo;
    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = wcVolume;

    VolumeInfo.VolumeCreationTime.QuadPart = 0;
    VolumeInfo.VolumeSerialNumber = 0;

    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

    if ( hVolume == INVALID_HANDLE_VALUE )
        fUsnVolume = FALSE;
    else
    {
        SWin32Handle xHandleVolume( hVolume );

        //
        // Look up the volume serial number and create time.  We'll use these
        // later to decide if the volume has been reformatted underneath us.
        // We don't bother to check error, because there's nothing we could
        // do except set fields to 0, which has already been done.
        //

        IO_STATUS_BLOCK iosb;
        NtQueryVolumeInformationFile( hVolume,
                                      &iosb,
                                      &VolumeInfo,
                                      sizeof(VolumeInfo),
                                      FileFsVolumeInformation );

        //
        // This call will only succeed on NTFS NT5 w/ USN Journal enabled.
        //


        NTSTATUS Status = NtFsControlFile( hVolume,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &iosb,
                                           FSCTL_QUERY_USN_JOURNAL,
                                           0,
                                           0,
                                           &UsnJournalInfo,
                                           sizeof(UsnJournalInfo) );

        Win4Assert( STATUS_PENDING != Status );

        if ( NT_SUCCESS(Status) && NT_SUCCESS(iosb.Status) )
            fUsnVolume = TRUE;
        else if ( !IsReadOnly() &&
                  ( STATUS_JOURNAL_NOT_ACTIVE == Status ||
                    STATUS_INVALID_DEVICE_STATE == Status ) )
        {
            //
            // Usn journal not created, create it
            //

            CREATE_USN_JOURNAL_DATA usnCreateData;
            usnCreateData.MaximumSize = _regParams.GetMaxUsnLogSize();
            usnCreateData.AllocationDelta = _regParams.GetUsnLogAllocationDelta();

            Status = NtFsControlFile( hVolume,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &iosb,
                                      FSCTL_CREATE_USN_JOURNAL,
                                      &usnCreateData,
                                      sizeof(usnCreateData),
                                      NULL,
                                      NULL );
            if ( NT_SUCCESS( Status ) && NT_SUCCESS(iosb.Status) )
            {
                Status = NtFsControlFile( hVolume,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &iosb,
                                          FSCTL_QUERY_USN_JOURNAL,
                                          0,
                                          0,
                                          &UsnJournalInfo,
                                          sizeof(UsnJournalInfo) );

                Win4Assert( STATUS_PENDING != Status );

                if ( NT_SUCCESS(Status) && NT_SUCCESS(iosb.Status) )
                    fUsnVolume = TRUE;
                else
                    fUsnVolume = FALSE;
            }
            else
                fUsnVolume = FALSE;
        }
        else
            fUsnVolume = FALSE;
    }

    _aUsnVolumes[ _cUsnVolumes ].Set( wcVolume,
                                      VolumeInfo.VolumeCreationTime.QuadPart,
                                      VolumeInfo.VolumeSerialNumber,
                                      fUsnVolume,
                                      UsnJournalInfo.UsnJournalID );
    _cUsnVolumes++;

    return fUsnVolume;
} //VolumeSupportsUsns

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::GetJournalId, public
//
//  Arguments:  [pwszPath] -- Path to USN-enabled volume
//
//  Returns:    Current USN Journal ID.
//
//  History:    17-Mar-98   KyleP   Created
//
//----------------------------------------------------------------------------

ULONGLONG const & CiCat::GetJournalId( WCHAR const * pwszPath )
{
    static ULONGLONG _zero = 0;

    Win4Assert( L'\\' != pwszPath[0] );

    //
    // Look in cache of known usn volumes
    //

    for ( unsigned i=0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == pwszPath[0] )
            return _aUsnVolumes[i].JournalId();
    }

    Win4Assert( !"Not USN volume!" );

    return _zero;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::GetVolumeCreationTime, public
//
//  Arguments:  [pwszPath] -- Path to volume
//
//  Returns:    Current create time (changed on reformat)
//
//  History:    17-Mar-98   KyleP   Created
//
//----------------------------------------------------------------------------

ULONGLONG const & CiCat::GetVolumeCreationTime( WCHAR const * pwszPath )
{
    static ULONGLONG _zero = 0;

    if ( pwszPath[0] == L'\\' )
    {
        static ULONGLONG ullZero = 0;
        return ullZero;
    }

    //
    // Look in cache of known usn volumes
    //

    for ( unsigned i=0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == pwszPath[0] )
            return _aUsnVolumes[i].CreationTime();
    }

    Win4Assert( !"Not known volume!" );

    return _zero;
}
//+---------------------------------------------------------------------------
//
//  Member:     CiCat::GetVolumeSerialNumber, public
//
//  Arguments:  [pwszPath] -- Path to volume
//
//  Returns:    Current serial number (changed on reformat)
//
//  History:    17-Mar-98   KyleP   Created
//
//----------------------------------------------------------------------------

ULONG CiCat::GetVolumeSerialNumber( WCHAR const * pwszPath )
{
    if ( pwszPath[0] == L'\\' )
        return 0;

    //
    // Look in cache of known usn volumes
    //

    for ( unsigned i=0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].DriveLetter() == pwszPath[0] )
            return _aUsnVolumes[i].SerialNumber();
    }

    Win4Assert( !"Not known volume!" );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::MapPathToVolumeId
//
//  Synopsis:   Maps a path to a volume id
//
//  Arguments:  [pwszPath] -- Path to map
//
//  History:    07-May-97     SitaramR   Created
//
//  Notes:      The volume id is obtained from the drive letter
//
//----------------------------------------------------------------------------

VOLUMEID CiCat::MapPathToVolumeId( const WCHAR *pwszPath )
{
    Win4Assert( wcslen(pwszPath) > 1
                && pwszPath[0] != L'\\'
                && pwszPath[1] == L':' );

    VOLUMEID volId = pwszPath[0];

    Win4Assert( volId <= 0xff );

    return volId;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::ProcessFile
//
//  Synopsis:   Process given file during usn tree traversal. It returns
//              the workid of file which is used to determine if the file
//              should be processed as an update notification.
//
//  Arguments:  [lcaseFunnyPath]  -- Path of file
//              [fileId]          -- Fileid of file
//              [volumeId]        -- Volume id of file
//              [widParent]       -- Workid of parent
//              [wid]             -- Workid of file returned here
//
//  Returns:    TRUE if the file was added to CI
//
//  History:    28-Jul-97   SitaramR   Created
//
//----------------------------------------------------------------------------

BOOL CiCat::ProcessFile( const CLowerFunnyPath & lcaseFunnyPath,
                         FILEID fileId,
                         VOLUMEID volumeId,
                         WORKID widParent,
                         DWORD dwFileAttributes,
                         WORKID & wid )
{
    Win4Assert( 0 != &_mutex );
    CLock lock( _mutex );

    wid = _fileIdMap.LokFind( fileId, volumeId );
    if ( wid == widInvalid )
    {
        BOOL fNew;
        wid = PathToWorkId( lcaseFunnyPath,
                            TRUE,           // Add to CI
                            fNew,
                            0,
                            eUsnsArray,
                            fileId,
                            widParent,
                            TRUE );         // CI doesn't know about this

        if (wid == widInvalid)
        {
            //
            // Unknown file
            //
            return FALSE;
        }

        //
        // New file, don't re-write property store info just written
        //

        LokWriteFileUsnInfo( wid, fileId, FALSE, volumeId, widParent, dwFileAttributes );
        WriteFileAttributes( wid, dwFileAttributes );

        return TRUE;
    }
    else
    {
        //
        // If the path has changed (due to a rename of the file or a parent
        // directory), update the path in the property store.
        //

        // override const here - unethical, but saves us a copy

        CFunnyPath oldPath;
        WorkIdToPath( wid, oldPath );

        BOOL fRemoveBackSlash = ((CLowerFunnyPath&)lcaseFunnyPath).RemoveBackSlash();
        SCODE sc = S_OK;

        if ( ( lcaseFunnyPath.GetActualLength() != oldPath.GetActualLength() ) ||
             ( 0 != memcmp( lcaseFunnyPath.GetActualPath(),
                            oldPath.GetActualPath(),
                            oldPath.GetActualLength() * sizeof WCHAR ) ) )
        {
            ciDebugOut(( DEB_ITRACE, "renaming '%ws' to '%ws' during scan\n",
                         oldPath.GetActualPath(),
                         lcaseFunnyPath.GetActualPath() ));

            PROPVARIANT var;
            var.vt = VT_LPWSTR;
            var.pwszVal = (WCHAR*) lcaseFunnyPath.GetActualPath();
            sc = _propstoremgr.WriteProperty( wid,
                                              pidPath,
                                              *(CStorageVariant const *)(ULONG_PTR)&var );
        }

        // override const here - unethical, but saves us a copy

        if ( fRemoveBackSlash )
            ((CLowerFunnyPath&)lcaseFunnyPath).AppendBackSlash();

        if ( FAILED( sc ) )
            THROW( CException( sc ) );
    }

    return FALSE;
} //ProcessFile                          

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::LokWriteFileUsnInfo
//
//  Synopsis:   Write file's usn info to property store
//
//  Arguments:  [wid]       -- Workid
//              [fileId]    -- Fileid of wid
//              [fWriteToPropStore] -- If TRUE, write to the property store
//              [volumeId]  -- Volume id of wid
//              [widParent] -- Workid of parent
//              [dwFileAttributes] -- Attributes of the file
//
//  History:    05-May-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CiCat::LokWriteFileUsnInfo( WORKID   wid,
                                 FILEID   fileId,
                                 BOOL     fWriteToPropStore,
                                 VOLUMEID volumeId,
                                 WORKID   widParent,
                                 DWORD    dwFileAttributes )
{
    Win4Assert( _mutex.IsHeld() );

    WORKID widExisting = _fileIdMap.LokFind( fileId, volumeId );

    if ( widExisting == widInvalid )
    {
        //
        // Add fileid -> wid map
        //
        _fileIdMap.LokAdd( fileId, wid, volumeId );
    }
    else if ( wid != widExisting )
    {
        //
        // Remove previous stale fileid mapping and add current mapping.
        // This can happen when a file is renamed to a different file
        // during the usn tree traversal.
        //

         ciDebugOut(( DEB_ITRACE,
                      "LokWriteFileUsnInfo, blasting fid %#I64x, %#x to %#x\n",
                      fileId, widExisting, wid ));

        _fileIdMap.LokDelete( fileId, widExisting );
        _fileIdMap.LokAdd( fileId, wid, volumeId );
    }

    if ( fWriteToPropStore )
    {
        PROPVARIANT propVar;
        propVar.vt = VT_UI8;
        propVar.uhVal.QuadPart = fileId;

        XWritePrimaryRecord rec( _propstoremgr, wid );

        SCODE sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                       pidFileIndex,
                                                       *(CStorageVariant const *)(ULONG_PTR)&propVar );
        if (FAILED(sc))
            THROW(CException(sc));

        propVar.vt = VT_UI4;
        propVar.ulVal = volumeId;
        sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                 pidVolumeId,
                                                 *(CStorageVariant const *)(ULONG_PTR)&propVar );
        if (FAILED(sc))
            THROW(CException(sc));

        propVar.ulVal = widParent;
        sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                 pidParentWorkId,
                                                 *(CStorageVariant const *)(ULONG_PTR)&propVar );
        if (FAILED(sc))
            THROW(CException(sc));

        propVar.ulVal = dwFileAttributes;
        sc = _propstoremgr.WritePrimaryProperty( rec.GetReference(),
                                                 pidAttrib,
                                                 *(CStorageVariant const *)(ULONG_PTR)&propVar );
        if (FAILED(sc))
            THROW(CException(sc));
    }
} //LokWriteFileUsnInfo

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::UpdateDuringRecovery, public
//
//  Synopsis:   Updates an individual workid with usn == 0 during prop
//              store recovery.
//
//  Arguments:  [wid]      -- Workid
//              [fileid]   -- File Id. Valid only for NTFS 5.0 volumes.
//              [fDelete]  -- TRUE to indicate deletion. Modify o/w.
//              [pUserData]-- Pointer to CiCat to use for updates.
//
//  History:    06-18-97      KrishnaN     Created
//
//  Notes: This will be called at property store recovery time to cause
//         deletion and modification of wids. The property store will always
//         be flushed before the usn marker is advanced in
//         CheckPointchangesFlushed. Which means that docs newly added to the
//         property store can be deleted with a usn of 0. Using usn of 0 causes
//         the marker to not move forward, but that is OK because the docs
//         being deleted were not marked as having been filtered. As a result,
//         rescan will cause these docs to be picked up agains and scheduled
//         for filtering.
//
//--------------------------------------------------------------------------

void UpdateDuringRecovery( WORKID wid, BOOL fDelete, void const *pUserData )
{
    CiCat *pCiCat = (CiCat *)pUserData;

    Win4Assert(pCiCat);

    pCiCat->Update( wid, pCiCat->GetPartition(), CI_VOLID_USN_NOT_ENABLED, 0,
                    fDelete ? CI_DELETE_OBJ : CI_UPDATE_OBJ);
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::FileIdToPath
//
//  Synopsis:   Converts fileid to path and checks if path is in scope
//
//  Arguments:  [fileId]             -- Fileid of wid
//              [pUsnVolume]         -- Volume
//              [lcaseFunnyPath]     -- Path returned here
//              [fPathInScope]       -- Scope info returned here
//
//  History:    23-Jun-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CiCat::FileIdToPath( FILEID fileId,
                          CUsnVolume *pUsnVolume,
                          CLowerFunnyPath & lcaseFunnyPath,
                          BOOL & fPathInScope )
{
    fPathInScope = FALSE;

    WORKID wid;

    {
        CLock lock( _mutex );

        wid = _fileIdMap.LokFind( fileId, pUsnVolume->VolumeId() );
        if ( widInvalid == wid )
            return;

        #if 0 // valid, but expensive
            PROPVARIANT propVar;
            BOOL fFound = _propstoremgr.ReadPrimaryProperty( wid,
                                                             pidFileIndex,
                                                             propVar );
            Win4Assert( fFound && propVar.uhVal.QuadPart == fileId );
        #endif // CIDBG == 1

        unsigned cc = _strings.Find( wid, lcaseFunnyPath );

        if ( 0 == cc )
            THROW ( CException( STATUS_INVALID_PARAMETER ) );
    }

    if ( !_usnMgr.IsPathIndexed( pUsnVolume, lcaseFunnyPath ) )
        return;

    if ( ! IsEligibleForFiltering( lcaseFunnyPath ) )
        return;

    fPathInScope = TRUE;
} //FileIdToPath

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::FileIdToPath
//
//  Synopsis:   Converts a fileid and volumeid to a path.
//
//  Arguments:  [fileId]       -- Fileid of wid
//              [pUsnVolume]   -- Volume
//              [funnyPath]    -- Path returned here
//
//  Returns:    Size of path (or 0 if not found).
//
//  History:    19-Mar-1998   dlee   Created
//              31-Dec-1998   KyleP  Re-enabled and fixed for > MAX_PATH
//
//----------------------------------------------------------------------------

unsigned CiCat::FileIdToPath( FILEID &          fileId,
                              VOLUMEID          volumeId,
                              CLowerFunnyPath & funnyPath )
{
    Win4Assert( 0 != volumeId );
    Win4Assert( CI_VOLID_USN_NOT_ENABLED != volumeId );
    Win4Assert( fileIdInvalid != fileId );
    Win4Assert( 0 != fileId );

    //
    // Make sure the volume information is faulted in -- it may not exist
    // yet when the catalog is just starting.
    //

    VolumeSupportsUsns( (WCHAR) volumeId );

    //
    // Look for the volume handle
    //

    unsigned cc = 0;
    HANDLE hVolume = INVALID_HANDLE_VALUE;

    for ( unsigned i = 0; i < _cUsnVolumes; i++ )
    {
        if ( _aUsnVolumes[i].VolumeId() == volumeId )
        {
            hVolume = _aUsnVolumes[i].Volume();
            break;
        }
    }

    // Was the volume found in the list of volumes being indexed?

    if ( INVALID_HANDLE_VALUE != hVolume )
    {
        // Put the fileid in the unicode string -- ntfs expects this

        UNICODE_STRING uScope;
        uScope.Buffer = (WCHAR *) &fileId;
        uScope.Length = sizeof fileId;
        uScope.MaximumLength = sizeof fileId;

        OBJECT_ATTRIBUTES ObjectAttr;
        InitializeObjectAttributes( &ObjectAttr,          // Structure
                                    &uScope,              // Name
                                    OBJ_CASE_INSENSITIVE, // Attributes
                                    hVolume,              // Root
                                    0 );                  // Security

        IO_STATUS_BLOCK IoStatus;
        HANDLE h = INVALID_HANDLE_VALUE;
        NTSTATUS Status = NtOpenFile( &h,
                                      FILE_READ_ATTRIBUTES,
                                      &ObjectAttr,
                                      &IoStatus,
                                      FILE_SHARE_READ |
                                          FILE_SHARE_WRITE |
                                          FILE_SHARE_DELETE,
                                      FILE_OPEN_BY_FILE_ID );
        if ( NT_SUCCESS( Status ) )
            Status = IoStatus.Status;

        if ( NT_SUCCESS( Status ) )
        {
            SHandle xHandle( h );

            // retrieve the path info for the file opened by id

            XGrowable<BYTE> xbuf;

            do
            {
                PFILE_NAME_INFORMATION FileName = (PFILE_NAME_INFORMATION) xbuf.Get();
                FileName->FileNameLength = xbuf.SizeOf() - sizeof(FILE_NAME_INFORMATION);

                Status = NtQueryInformationFile( h,
                                                 &IoStatus,
                                                 FileName,
                                                 xbuf.SizeOf(),
                                                 FileNameInformation );

                Win4Assert( STATUS_PENDING != Status );

                if ( NT_SUCCESS( Status ) )
                    Status = IoStatus.Status;

                if ( NT_SUCCESS( Status ) )
                {
                    ULONG Length = FileName->FileNameLength;
                    cc = 2 + Length/sizeof(WCHAR);

                    //
                    // Major cheating here.  The FileNameLength field precedes
                    // the filename itself, and is juuuust big enough to hold
                    // the two character <drive>: preface.
                    //

                    Win4Assert( xbuf.Get() + sizeof(WCHAR)*2 == (BYTE *)&FileName->FileName );
                    WCHAR * pwszPath = (WCHAR *)xbuf.Get();

                    pwszPath[ 0 ] = (WCHAR) volumeId;
                    pwszPath[ 1 ] = L':';

                    funnyPath.SetPath( pwszPath, cc );

                    ciDebugOut(( DEB_ITRACE, "translated fileid %#I64x to path '%ws'\n",
                                 fileId, funnyPath.GetPath() ));

                    break;
                }
                else if ( STATUS_BUFFER_OVERFLOW == Status )
                {
                    xbuf.SetSize( xbuf.SizeOf() * 2 );
                    continue;
                }
                else
                {
                    ciDebugOut(( DEB_WARN, "unable to query filenameinfo: %#x\n",
                                 Status ));
                    THROW( CException( Status ) );
                }
            } while (TRUE);
        }
        else
        {
            // STATUS_INVALID_PARAMETER means the file wasn't found.

            if ( ( !IsSharingViolation( Status ) ) &&
                 ( STATUS_INVALID_PARAMETER != Status ) &&
                 ( STATUS_ACCESS_DENIED != Status ) &&
                 ( STATUS_SHARING_VIOLATION != Status ) &&
                 ( STATUS_IO_REPARSE_TAG_NOT_HANDLED != Status ) &&
                 ( STATUS_DELETE_PENDING != Status ) &&
                 ( STATUS_OBJECT_NAME_NOT_FOUND != Status ) &&
                 ( STATUS_OBJECT_NAME_INVALID != Status) &&
                 ( STATUS_OBJECT_PATH_NOT_FOUND != Status) )
            {
                if ( ( STATUS_VOLUME_DISMOUNTED != Status ) &&
                     ( STATUS_NO_MEDIA_IN_DEVICE != Status ) &&
                     ( STATUS_UNRECOGNIZED_VOLUME != Status ) &&
                     ( STATUS_INSUFFICIENT_RESOURCES != Status ) )
                {
                    ciDebugOut(( DEB_WARN, "unable to open by id: %#x\n", Status ));

                    #if CIDBG == 1
                        ciDebugOut(( DEB_WARN, "error %#x, can't get path for %#I64\n",
                                     Status, fileId ));
    
                        char acTemp[ 200 ];
                        sprintf( acTemp,
                                 "New error %#x from FileIdToPath.  Call DLee",
                                 Status );
                        Win4AssertEx( __FILE__, __LINE__, acTemp );
                    #endif
                }

                THROW( CException( Status ) );
            }
        }
    }
    else
    {
        ciDebugOut(( DEB_WARN, "no volume match for volume %#x\n", volumeId ));
    }

    return cc;
} //FileIdToPath

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::UsnRecordToPathUsingParentId
//
//  Synopsis:   Converts an usn record to path via the parent fileid
//              and checks if path is in scope
//
//  Arguments:  [fileId]         -- Fileid of wid
//              [pUsnVolume]     -- Volume
//              [lowerFunnyPath] -- Path returned here
//              [fPathInScope]   -- Scope info returned here
//              [widParent]      -- Parent wid returned here
//              [fParentMayNotBeIndexed] -- TRUE if the parent directory may
//                                  have the not-indexed attribute, so it's
//                                  not in the fileid map.
//
//  History:    23-Jun-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CiCat::UsnRecordToPathUsingParentId( USN_RECORD *pUsnRec,
                                          CUsnVolume *pUsnVolume,
                                          CLowerFunnyPath & lowerFunnyPath,
                                          BOOL &fPathInScope,
                                          WORKID & widParent,
                                          BOOL fParentMayNotBeIndexed )
{
    //
    // Workid of parent will be widInvalid for files in root directory
    //

    widParent = widInvalid;
    fPathInScope = FALSE;

    WCHAR *pwszFilename = (WCHAR *) (((BYTE *)pUsnRec) + pUsnRec->FileNameOffset);
    unsigned cbFileNameLen = pUsnRec->FileNameLength;

    BOOL fAddParent = FALSE;
    CLowerFunnyPath parentPath;

    if ( pUsnRec->ParentFileReferenceNumber == pUsnVolume->RootFileId() )
    {
        //
        // File is in root directory, so build path by prefixing drive letter
        //
        WCHAR awc[3];
        awc[0] = pUsnVolume->DriveLetter();
        awc[1] = L':';
        awc[2] = L'\\';

        lowerFunnyPath.SetPath( awc, 3 );

        // The root is named "x:\." (the filename is ".")

        if ( pUsnRec->FileReferenceNumber != pUsnRec->ParentFileReferenceNumber )
            lowerFunnyPath.AppendPath( pwszFilename, cbFileNameLen/sizeof(WCHAR) );
    }
    else
    {
        {
            CLock lock( _mutex );

            //
            // Build up the full path by prefixing parent directory
            //

            widParent = _fileIdMap.LokFind( pUsnRec->ParentFileReferenceNumber,
                                            pUsnVolume->VolumeId() );

            if ( widParent == widInvalid )
            {
                if ( fParentMayNotBeIndexed )
                {
                    //
                    // See if the parent directory is marked as non-indexed.
                    // If so proceed with the add, otherwise bail.
                    //

                    ciDebugOut(( DEB_ITRACE, "doing an expensive open!\n" ));

                    unsigned cc = FileIdToPath( pUsnRec->ParentFileReferenceNumber,
                                                pUsnVolume->VolumeId(),
                                                lowerFunnyPath );
                    if ( 0 == cc )
                        return;

                    DWORD dw = GetFileAttributes( lowerFunnyPath.GetActualPath() );

                    if ( 0xffffffff == dw )
                        return;

                    if ( 0 == ( dw & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED ) )
                        return;

                    fAddParent = TRUE;
                    parentPath = lowerFunnyPath;
                }
                else
                {
                    //
                    // Unknown parent, which means that this file is out of
                    // scope or hasn't been scanned yet, hence do nothing
                    //

                    return;
                }
            }
            else
            {
                unsigned cwcPathLen = _strings.Find( widParent, lowerFunnyPath );

                if ( 0 == cwcPathLen )
                    THROW( CException( STATUS_INVALID_PARAMETER ) );

                Win4Assert( cwcPathLen == wcslen(lowerFunnyPath.GetActualPath()) );
            }
        }

        lowerFunnyPath.AppendBackSlash();
        lowerFunnyPath.AppendPath( pwszFilename, cbFileNameLen/sizeof(WCHAR) );
    }

    //
    // Make sure the path is being indexed
    //

    if ( !_usnMgr.IsPathIndexed( pUsnVolume, lowerFunnyPath ) )
        return;

    //
    //  Don't filter catalog files and files in ignored scopes
    //

    if ( ! IsEligibleForFiltering( lowerFunnyPath ) )
        return;

    if ( fAddParent )
    {
        BOOL fNew;
        widParent = PathToWorkId( parentPath,
                                  TRUE,
                                  fNew,
                                  0,
                                  eUsnsArray,
                                  pUsnRec->ParentFileReferenceNumber,
                                  widInvalid, // "go figure"
                                  FALSE );
    }

    fPathInScope = TRUE;
} //UsnRecordToPathUsingParentId

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::LokMarkForDeletion
//
//  Synopsis:   Mark the wid for deletion. Assumes cicat mutex is held.
//
//  Arguments:  [fileId]   -- File id
//              [wid]      -- Workid
//
//  History:    28-Jul-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CiCat::LokMarkForDeletion( FILEID fileId,
                                WORKID wid )
{
    Win4Assert( _mutex.IsHeld() );
    ciDebugOut(( DEB_ITRACE, "delete usn %#I64x wid 0x%x\n", fileId, wid ));

    _fileIdMap.LokDelete( fileId, wid );
    _strings.LokDelete( 0, wid, TRUE, TRUE );
} //LokMarkForDeletion

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::InitUsnTreeScan
//
//  Synopsis:   Initializes the entry in notification manager that a usn
//              for usn tree traversal is starting.
//
//  Arguments:  [pwszPath] -- Scope
//
//  History:    28-Jul-97   SitaramR   Created
//
//  Notes:      PwszPath may not be in notifymgr because it may have been removed
//              by the time we get here.
//
//----------------------------------------------------------------------------

void CiCat::InitUsnTreeScan( WCHAR const *pwszPath )
{
    for ( CCiNotifyIter iter(_notify);
          !iter.AtEnd();
          iter.Advance() )
    {
        if ( AreIdenticalPaths( iter.Get(), pwszPath ) )
        {
            iter.InitUsnTreeScan();

            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::SetUsnTreeScanComplete
//
//  Synopsis:   Writes usn as the restart usn for the given scope
//
//  Arguments:  [pwszPath] -- Scope
//              [usn]      -- Restart usn
//
//  History:    27-Jun-97   SitaramR   Created
//
//  Notes:      PwszPath may not be in notifymgr because it may have been removed
//              by the time we get here.
//
//----------------------------------------------------------------------------

void CiCat::SetUsnTreeScanComplete( WCHAR const *pwszPath, USN usn )
{
    for ( CCiNotifyIter iter(_notify); !iter.AtEnd(); iter.Advance() )
    {
        if ( AreIdenticalPaths( iter.Get(), pwszPath ) )
        {
            iter.SetUsnTreeScanComplete( usn );

            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::SetTreeScanComplete
//
//  Synopsis:   Indicates end of non-USN volume tree scan.  Mostly for
//              updating Volume Id info.
//
//  Arguments:  [pwszPath] -- Scope
//
//  History:    13-Apr-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void CiCat::SetTreeScanComplete( WCHAR const *pwszPath )
{
    for ( CCiNotifyIter iter(_notify); !iter.AtEnd(); iter.Advance() )
    {
        if ( AreIdenticalPaths( iter.Get(), pwszPath ) )
        {
            iter.SetTreeScanComplete();
            break;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CiCat::CheckUsnTreeScan
//
//  Synopsis:   Checks if Usn tree scan has been initialized
//
//  Arguments:  [pwszPath] -- Scope
//
//  History:    8-Sep-97   SitaramR   Created
//
//  Notes:      PwszPath may not be in notifymgr because it may have been removed
//              by the time we get here.
//
//----------------------------------------------------------------------------

#if CIDBG==1

void CiCat::CheckUsnTreeScan( WCHAR const *pwszPath )
{
    for ( CCiNotifyIter iter(_notify);
          !iter.AtEnd();
          iter.Advance() )
    {
        if ( AreIdenticalPaths( iter.Get(), pwszPath ) )
        {
            // This assert is either bogus or hit in cases we don't understand.
            // When there is time, add logging code to see what's up.

            // Win4Assert( iter.FUsnTreeScan() );
            break;
        }
    }
}

#endif


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::DebugPrintWidInfo
//
//  Synopsis:   Debug prints wid info
//
//  Arguments:  [wid] -- Wid to print
//
//  History:    05-Jul-97   SitaramR   Created
//
//----------------------------------------------------------------------------

#if CIDBG == 1
void CiCat::DebugPrintWidInfo( WORKID wid )
{
    XGrowable<WCHAR> xPath;
    unsigned ccSize;

    {
        CLock lock( _mutex );
        ccSize = _strings.Find( wid, xPath );
    }

    if ( ccSize == 0 )
        xPath[0] = 0;

    PROPVARIANT propVar;
    _propstoremgr.ReadPrimaryProperty( wid, pidFileIndex, propVar );
    FILEID fileId = propVar.uhVal.QuadPart;

    _propstoremgr.ReadPrimaryProperty( wid, pidVolumeId, propVar );
    VOLUMEID volumeId = propVar.ulVal;

    _propstoremgr.ReadPrimaryProperty( wid, pidParentWorkId, propVar );
    WORKID widParent = propVar.ulVal;

    ciDebugOut(( DEB_ERROR,
                 "    Wid %#x, fileid %#I64x, volumeId %#x, path %ws, widParent %#x\n",
                 wid,
                 fileId,
                 volumeId,
                 xPath.Get(),
                 widParent ));
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::IsUNCName
//
//  Synopsis:   Determines if a path is a UNC
//
//  Arguments:  [pwszVal]  -- The path to check
//
//  History:    ?   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CiCat::IsUNCName( WCHAR const * pwszVal )
{
    Win4Assert( 0 != pwszVal );
    CPathParser parser(pwszVal);
    return parser.IsUNCName();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::AddShadowScopes, private
//
//  Synopsis:   Re-adds shadow (virtual) scopes to registry.
//
//  History:    12-Oct-1997    KyleP   Created
//
//  Notes:      This code handles the case where the registry got wiped,
//              possibly by an upgrade, but the catalog data still exists.
//
//----------------------------------------------------------------------------

void CiCat::AddShadowScopes()
{
    //
    // Enumerate through the scope table, looking for entries that map
    // into the virtual namespace.
    //

    WCHAR    wcsPRoot[MAX_PATH+1];
    unsigned ccPRoot;

    unsigned iBmk = 0;

    for ( ccPRoot = sizeof(wcsPRoot)/sizeof(WCHAR);
          _scopeTable.Enumerate( wcsPRoot, ccPRoot, iBmk );
          ccPRoot = sizeof(wcsPRoot)/sizeof(WCHAR) )
    {
        if ( _strings.DoesPhysicalRootExist( wcsPRoot ) )
        {
            ciDebugOut(( DEB_FORCE, "Refresh %ws\n", wcsPRoot ));
            _scopeTable.RefreshShadow( wcsPRoot, _xScopesKey.Get() + SKIP_TO_LM );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Class:      CUserPropCallback
//
//  Purpose:    Helper class for CiCat::RecoverUserProperties.  Reads
//              registry entries describing cached properties and adds them
//              to the property store.
//
//  History:    07-Nov-97   KyleP        Created
//
//----------------------------------------------------------------------------

class CUserPropCallback : public CRegCallBack
{
public:

    CUserPropCallback( CiCat & cat, ULONG_PTR ulToken, DWORD dwStoreLevel )
            : _cat( cat ),
              _ulToken( ulToken ),
              _dwStoreLevel( dwStoreLevel )
    {
    }

    NTSTATUS CallBack( WCHAR *pValueName, ULONG uValueType,
                       VOID *pValueData, ULONG uValueLength )
    {
        CParseRegistryProperty ParseProp( pValueName,
                                          uValueType,
                                          pValueData,
                                          uValueLength );

        if ( ParseProp.IsOk() )
        {
            PROPID  pid = _cat.PropertyToPropId( ParseProp.GetFPS(), TRUE );
  
            if ( pidInvalid == pid )
                return STATUS_INVALID_PARAMETER;

            // Silently fail attempts to monkey with built-in properties.

            if ( pidPath             == pid ||
                 pidLastSeenTime     == pid ||
                 pidAttrib           == pid ||
                 pidVirtualPath      == pid ||
                 pidSecurity         == pid ||
                 pidParentWorkId     == pid ||
                 pidSecondaryStorage == pid ||
                 pidFileIndex        == pid ||
                 pidVolumeId         == pid ||
                 pidSize             == pid ||
                 pidWriteTime        == pid )
                return STATUS_SUCCESS;

            if ( _dwStoreLevel == ParseProp.StorageLevel() )
                _cat._propstoremgr.Setup( pid,
                                          ParseProp.Type(),
                                          ParseProp.Size(),
                                          _ulToken,
                                          ParseProp.IsModifiable(),
                                          _dwStoreLevel );

            return STATUS_SUCCESS;
        }
        else
            return STATUS_INVALID_PARAMETER;
    }

private:

    CiCat &   _cat;
    ULONG_PTR _ulToken;
    DWORD     _dwStoreLevel;
};

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RecoverUserProperties, private
//
//  Synopsis:   Re-adds user-defined properties to property cache
//
//  Arguments:  [ulToken]      -- Token for open property metadata transaction
//              [dwStoreLevel] -- Which storage level are we operating on?
//
//  History:    07-Nov-1997    KyleP   Created
//
//----------------------------------------------------------------------------

void CiCat::RecoverUserProperties( ULONG_PTR ulToken, DWORD dwStoreLevel )
{
    TRY
    {
        //
        // Iterate over all the user-defined properties
        //

        XArray<WCHAR> xPropKey;
        BuildRegistryPropertiesKey( xPropKey, GetCatalogName() );

        CRegAccess regProps( RTL_REGISTRY_ABSOLUTE, xPropKey.Get() );

        CUserPropCallback PropCallback( *this, ulToken, dwStoreLevel );

        regProps.EnumerateValues( 0, PropCallback );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "CiCat::RecoverUserProperties: caught 0x%x\n", e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::DeleteUserProperty, private
//
//  Synopsis:   Removes user property definition for registry
//
//  Arguments:  [fps] -- Property to remove
//
//  History:    11-Nov-1997    KyleP   Created
//
//----------------------------------------------------------------------------

void CiCat::DeleteUserProperty( CFullPropSpec const & fps )
{
    TRY
    {
        XArray<WCHAR> xPropKey;
        BuildRegistryPropertiesKey( xPropKey, GetCatalogName() );

        HKEY hkey;
        DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, xPropKey.Get() + SKIP_TO_LM, &hkey );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, xPropKey.Get() ));
        }
        else
        {
            SRegKey xkey( hkey );

            CBuildRegistryProperty PropBuild( fps, 0, 0 );  // Note type and size don't matter.

            RegDeleteValue( hkey, PropBuild.GetValue() );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "CiCat::DeleteUserProperty: caught 0x%x\n", e.GetErrorCode() ));
    }
    END_CATCH
} //DeleteUserProperty

//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RenameFile, public
//
//  Synopsis:   Renames a file
//
//  Arguments:  [lcaseFunnyOldName] -- The old file name
//              [lcaseFunnyNewName] -- The new file name
//              [ulFileAttrib]      -- The new file attributes
//              [volumeId]          -- The volume id of the file
//              [fileId]            -- The file id of the file or fileIdInvalid
//                                   if not a USN volume
//
//  History:    4-Mar-1998    dlee  Moved from cicat.hxx
//
//----------------------------------------------------------------------------

void CiCat::RenameFile(
    const CLowerFunnyPath & lcaseFunnyOldName,
    const CLowerFunnyPath & lcaseFunnyNewName,
    ULONG         ulFileAttrib,
    VOLUMEID      volumeId,
    FILEID        fileId,
    WORKID        widParent )
{
    CLock lock( _mutex );

    if ( lcaseFunnyOldName.IsRemote() )
    {
        CImpersonateSystem impersonate;
        RenameFileInternal(lcaseFunnyOldName,
                           lcaseFunnyNewName,
                           ulFileAttrib,
                           volumeId,
                           fileId,
                           widParent);
    }
    else
    {
        RenameFileInternal(lcaseFunnyOldName,
                          lcaseFunnyNewName,
                          ulFileAttrib,
                          volumeId,
                          fileId,
                          widParent);
    }

} //RenameFile


//+---------------------------------------------------------------------------
//
//  Member:     CiCat::RenameFileInternal, public
//
//  Synopsis:   Renames a file
//
//  Arguments:  [lcaseFunnyOldName] -- The old file name
//              [lcaseFunnyNewName] -- The new file name
//              [ulFileAttrib]      -- The new file attributes
//              [volumeId]          -- The volume id of the file
//              [fileId]            -- The file id of the file or fileIdInvalid
//                                   if not a USN volume
//
//  History:    4-Mar-1998    dlee  Moved from cicat.hxx
//
//----------------------------------------------------------------------------

void CiCat::RenameFileInternal(
    const CLowerFunnyPath & lcaseFunnyOldName,
    const CLowerFunnyPath & lcaseFunnyNewName,
    ULONG         ulFileAttrib,
    VOLUMEID      volumeId,
    FILEID        fileId,
    WORKID        widParent )
{
    BOOL fUsnVolume = IsOnUsnVolume( lcaseFunnyOldName.GetActualPath() );
    WORKID wid;

    if ( fUsnVolume )
        if ( fileIdInvalid == fileId )
        {
            // Since the old file has been deleted, use the new filename,
            // which should have the same fileId
            wid = LokLookupWid( lcaseFunnyNewName, fileId);
            if ( widInvalid == wid )
            {
                // Could not get a valid wid for the new file. Looks like
                // it has been deleted. Abort !!!
                return;
            }
        }
        else
        {
            wid = LokLookupWid( lcaseFunnyOldName, fileId);
        }
    else
        wid = _strings.LokFind( lcaseFunnyOldName.GetActualPath() );

    ciDebugOut(( DEB_ITRACE, "renamefile %#I64x '%ws' to '%ws'\n",
                 fileId, lcaseFunnyOldName.GetActualPath(), lcaseFunnyNewName.GetActualPath() ));

    _strings.LokRenameFile( lcaseFunnyOldName.GetActualPath(),
                            lcaseFunnyNewName.GetActualPath(),
                            wid,
                            ulFileAttrib,
                            volumeId,
                            widParent );
} //RenameFile



//+---------------------------------------------------------------------------
//
//  Member:     CiCat::HasChanged, public
//
//  Returns:    TRUE if [ft] > last filter time
//
//  Arguments:  [wid] -- WorkId
//              [ft]  -- Filetime
//
//  History:    08-Apr-1998    KyleP Created
//
//----------------------------------------------------------------------------

BOOL CiCat::HasChanged( WORKID wid, FILETIME const & ft )
{
    PROPVARIANT propVar;

    if ( !_propstoremgr.ReadPrimaryProperty( wid, pidLastSeenTime, propVar ) ||
         propVar.vt != VT_FILETIME )
        RtlZeroMemory( &propVar.filetime, sizeof(propVar.filetime) );

    return ( *(ULONGLONG *)&ft > *(ULONGLONG *)&propVar.filetime );
}

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEntry::CScopeEntry, public
//
//  Synopsis:   Ctor.
//
//  Arguments:  [pwszScope] -- scope entry to init CScopeEntry
//
//  Notes:      If the passed-in scope contains special chars,
//              only scope preceeding the special char is stored.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

CScopeEntry::CScopeEntry(WCHAR const * pwszScope)
    : _fContainsSpecialChar(FALSE)
{
    Win4Assert( 0 != pwszScope );

    ULONG scopeLen = wcslen( pwszScope );

    //
    // Terminate the path with a trailing backslash if not already terminated.
    //

    _xwcsPath.SetSize( scopeLen + 2 );
    RtlCopyMemory( _xwcsPath.Get(), pwszScope, (scopeLen+1) * sizeof(WCHAR) );
    TerminateWithBackSlash( _xwcsPath.Get(), scopeLen );

    //
    // truncate paths with special chars.
    //

    WCHAR * pwszSpecial = GetSpecialCharLocation();

    if ( pwszSpecial )
    {
       *pwszSpecial = L'\0';

       while ( pwszSpecial >= _xwcsPath.Get() && L'\\' != *pwszSpecial  )
       {
           pwszSpecial--;
       }

       Win4Assert( L'\\' == *pwszSpecial );

       //
       // terminate substring.
       //
       *(pwszSpecial+1) = L'\0';

       _fContainsSpecialChar = TRUE;

       ciDebugOut(( DEB_ITRACE, "CScopeEntry: %ws\n", _xwcsPath.Get() ));
    }

    _cclen = wcslen( _xwcsPath.Get() );
}

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEntry::SetToParentDirectory, public
//
//  Synopsis:   truncates current path to its parent.
//
//  Arguments:  none.
//
//  returns:    TRUE if path was set to parent, FALSE if root was reached.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CScopeEntry::SetToParentDirectory(void)
{

    Win4Assert( _fContainsSpecialChar );

    if ( IsRoot() )
    {
        return FALSE;
    }

    Win4Assert( L'\\' == _xwcsPath[_cclen-1] );

    _xwcsPath[_cclen-1] = L'\0';  // skip last backslash

    WCHAR * pwszTemp = wcsrchr( _xwcsPath.Get(), L'\\' );

    *(pwszTemp+1) = L'\0';

    _cclen = wcslen( _xwcsPath.Get() );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEntry::IsRoot, Private
//
//  Synopsis:   finds if current path is root path
//
//  Arguments:  none.
//
//  Returns:    TRUE if Path is root path, False otherwise.
//
//  History:    3-30-98 mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CScopeEntry::IsRoot(void)
{
    Win4Assert( _fContainsSpecialChar );

    unsigned weight = 0;

    if ( _cclen > 3 && _xwcsPath[1] == L':' )
    {
        weight = 3;
    }

    for ( WCHAR const * pwszTemp = _xwcsPath.Get(); *pwszTemp; pwszTemp++ )
    {
        if ( L'\\' == *pwszTemp )
        {
            weight += 1;
        }
    }

    if ( weight > 4 )
        return FALSE;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEntry::GetSpecialCharLocation, private
//
//  Synopsis:   Finds location of 1st special char of contained scope.
//
//  Arguments:  None.
//
//  returns:    pointer to regx wild card (if one found), null otherwise.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

WCHAR * CScopeEntry::GetSpecialCharLocation()
{
    for ( WCHAR * pwszTemp = _xwcsPath.Get(); *pwszTemp; pwszTemp++ )
    {
        if ( IsSpecialChar(*pwszTemp) )
            return pwszTemp;
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScopeEntry::IsSpecialChar, private
//
//  Synopsis:   determines if input char is regex special char
//
//  Arguments:  [c] -- wchar to test
//
//  returns:    TRUE if input wchar is special regex wchar, FALSE otherwise.
//
//  History:    3-20-98     mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CScopeEntry::IsSpecialChar(WCHAR c)
{
    for ( WCHAR const * pwszTemp = awcSpecialRegex; *pwszTemp; pwszTemp++ )
    {
        if ( c == *pwszTemp )
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Class:      XSmartNetApiBuffer
//
//  Purpose:    Frees buffer allocated by the network APIs
//
//  History:    7/26/00     dlee    created
//
//----------------------------------------------------------------------------

class XSmartNetApiBuffer
{
public:
    XSmartNetApiBuffer( CDynLoadNetApi32 & dlNetApi32, void * p ) :
        _dlNetApi32( dlNetApi32 ), _p( p ) {}

    ~XSmartNetApiBuffer()
    {
        _dlNetApi32.NetApiBufferFree( _p );
    }

private:
    CDynLoadNetApi32 & _dlNetApi32;
    void *             _p;
};

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::AddShares, public
//
//  Synopsis:   Examines shared resources and adds to fixup list.
//
//  Arguments:  [dlNetApi32] -- Dynamically loaded NetApi32 DLL (for performance)
//
//  History:    09-Jun-1998  KyleP   Created
//
//--------------------------------------------------------------------------

void CiCat::AddShares( CDynLoadNetApi32 & dlNetApi32 )
{
    CDynLoadMpr dlMpr;

    HANDLE hEnum = (HANDLE)INVALID_HANDLE_VALUE;

    do
    {
        WCHAR wcsCompName[MAX_COMPUTERNAME_LENGTH+3] = L"\\\\";
        DWORD ccCompName = sizeof(wcsCompName)/sizeof(WCHAR) - 2;

        if ( !GetComputerName(  &wcsCompName[2], &ccCompName ) )
        {
            ciDebugOut(( DEB_ERROR, "Error %u from GetComputerName\n", GetLastError() ));
            break;
        }

        //
        // Open the enumerator
        //

        NETRESOURCE nr;

        nr.dwScope = RESOURCE_GLOBALNET;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
        nr.lpLocalName = 0;
        nr.lpRemoteName = wcsCompName;
        nr.lpComment = 0;
        nr.lpProvider = 0;

        DWORD dwError = dlMpr.WNetOpenEnumW( RESOURCE_GLOBALNET,
                                             RESOURCETYPE_ANY,
                                             0,
                                             &nr,
                                             &hEnum);

        if ( dwError != NO_ERROR )
        {
            ciDebugOut(( DEB_ERROR, "Error %u from WNetOpenEnum\n", dwError ));
            break;
        }

        //
        // Open key for reg refresh.
        //

        HKEY  hkey = (HKEY)INVALID_HANDLE_VALUE;
        dwError = RegOpenKey( HKEY_LOCAL_MACHINE, _xScopesKey.Get() + SKIP_TO_LM, &hkey );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, _xScopesKey.Get() ));
            break;
        }

        SRegKey xKey( hkey );

        //
        // Enumerate all shares
        //

        XArray<BYTE> abBuffer( 4 * 1024 );
        DWORD dwResult;

        do
        {
            NETRESOURCE * pnr = (NETRESOURCE *)abBuffer.GetPointer();
            DWORD cbBuffer = abBuffer.SizeOf();
            DWORD cEntries = 0xFFFFFFFF;

            dwResult = dlMpr.WNetEnumResourceW( hEnum,
                                                &cEntries,
                                                pnr,
                                                &cbBuffer );

            if ( NO_ERROR == dwResult )
            {
                for( unsigned i = 0; i < cEntries; i++ )
                {
                    //
                    // Is this a disk share?
                    //

                    if ( pnr[i].dwType == RESOURCETYPE_DISK &&
                         pnr[i].dwDisplayType == RESOURCEDISPLAYTYPE_SHARE )
                    {
                        //
                        // Find the local physical path.
                        //

                        BYTE * pbShareInfo;

                        DWORD dwError = dlNetApi32.NetShareGetInfo( &wcsCompName[2],                       // Server
                                                                    pnr[i].lpRemoteName + ccCompName + 3,  // Share
                                                                    2,                                     // Level 2
                                                                    &pbShareInfo );                        // Result

                        if ( NO_ERROR == dwError )
                        {
                            XSmartNetApiBuffer xbuf( dlNetApi32, pbShareInfo );

                            SHARE_INFO_2 * psi = (SHARE_INFO_2 *)pbShareInfo;

                            Win4Assert( STYPE_DISKTREE == psi->shi2_type );

                            //
                            // Is the alias already mapped correctly?
                            // If it is, then the alias is correctly recorded
                            // in the registry.  If not, add it.
                            //

                            CLowcaseBuf lcase( psi->shi2_path );

                            if ( !_scopeFixup.IsExactMatch( psi->shi2_path,
                                                        pnr[i].lpRemoteName ) )
                            {
                                if ( _notify.IsInScope( lcase.Get() ) )
                                {
                                    //
                                    // Add scope to registry.
                                    //

                                    RefreshIfShadowAlias( psi->shi2_path,
                                                          pnr[i].lpRemoteName,
                                                          hkey );
                                }
                            }
                            else
                            {
                                if ( !_notify.IsInScope( lcase.Get() ) )
                                {
                                    //
                                    // Remove bogus shadow.
                                    //

                                    DeleteIfShadowAlias( psi->shi2_path, pnr[i].lpRemoteName );
                                }
                            }
                        }
                    }
                }
            }
        }
        while( NO_ERROR == dwResult );
    }
    while ( FALSE );

    if ( hEnum != (HANDLE)INVALID_HANDLE_VALUE )
        dlMpr.WNetCloseEnum( hEnum );
}

//+---------------------------------------------------------------------------
//
//  Method:     CiCat::SynchShares, public
//
//  Synopsis:   Adds/removes fixups to match net shares
//
//  History:    15-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CiCat::SynchShares()
{
    CDynLoadNetApi32 dlNetApi32;

    //
    // First, enumerate the registry and remove automatically added aliases that
    // No longer exist.
    //

    ciDebugOut(( DEB_ITRACE, "Reading scope fixups from '%ws'\n", GetScopesKey() ));

    BOOL fChanged;
    do
    {
        fChanged = FALSE;

        CRegAccess regScopes( RTL_REGISTRY_ABSOLUTE, GetScopesKey() );

        CRegistryScopesCallBackRemoveAlias callback( *this, dlNetApi32, !_fAutoAlias );

        TRY
        {
            regScopes.EnumerateValues( 0, callback );
            fChanged = callback.WasScopeRemoved();
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_WARN,
                         "Exception 0x%x caught groveling ci registry in SynchShares.\n",
                         e.GetErrorCode() ));

            HandleError( e.GetErrorCode() );
        }
        END_CATCH

    } while ( fChanged );

    //
    // Now, enumerate the shares on the machine, and add all the aliases that
    // are not already in the list.
    //

    if ( _fAutoAlias )
        AddShares( dlNetApi32 );
}

//
// Local constants
//

WCHAR const wcsShadowAlias[] = L",,41"; // ,,41 --> Shadow alias, Physical, Indexed

//+---------------------------------------------------------------------------
//
//  Method:     CiCat::DeleteIfShadowAlias, private
//
//  Synopsis:   Deletes shadow scope registry entry
//
//  Arguments:  [pwcsScope] -- Scope to delete
//              [pwcsAlias] -- Alias of [pwcsScope]
//
//  History:    15-May-97   KyleP   Created
//
//  Notes:      Only deletes exact matches (as stored by system)
//
//----------------------------------------------------------------------------

void CiCat::DeleteIfShadowAlias( WCHAR const * pwcsScope, WCHAR const * pwcsAlias )
{
    HKEY  hkey = (HKEY)INVALID_HANDLE_VALUE;
    DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, _xScopesKey.Get() + SKIP_TO_LM, &hkey );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, _xScopesKey.Get() ));
    }

    if ( ERROR_SUCCESS == dwError )
    {
        SRegKey xKey( hkey );

        unsigned ccAlias = wcslen(pwcsAlias);
        unsigned cbAlias = ccAlias * sizeof(WCHAR);

        //
        // See if this is a shadow entry (flags == 2)
        //

        WCHAR wcsValueData[MAX_PATH];
        DWORD cbValueData = sizeof(wcsValueData);

        DWORD dwType;

        //
        // First, try the most obvious candidate (no '<#>' at end)
        //

        dwError = RegQueryValueEx( hkey,                 // Key handle
                                   pwcsScope,            // Name
                                   0,                    // Reserved
                                   &dwType,              // Datatype
                                   (BYTE *)wcsValueData, // Data returned here
                                   &cbValueData );       // Size of data

        if ( ERROR_SUCCESS == dwError &&
             REG_SZ == dwType &&
             cbValueData == ( sizeof(wcsShadowAlias) + cbAlias ) &&
             RtlEqualMemory( wcsValueData + cbValueData/sizeof(WCHAR) - sizeof(wcsShadowAlias)/sizeof(WCHAR),
                             wcsShadowAlias,
                             sizeof(wcsShadowAlias) ) &&
             RtlEqualMemory( wcsValueData, pwcsAlias, cbAlias ) )
        {
            dwError = RegDeleteValue( hkey, pwcsScope );

            if ( ERROR_SUCCESS != dwError ) {
                ciDebugOut(( DEB_ERROR, "Error %d deleting %ws\n", dwError, pwcsScope ));
            }
        }

        //
        // Try it the hard way, via enumeration
        //

        else
        {
            DWORD dwIndex = 0;
            unsigned ccScope = wcslen(pwcsScope);

            do
            {
                WCHAR wcsValueName[MAX_PATH+4];
                DWORD ccValueName = sizeof(wcsValueName)/sizeof(WCHAR);
                cbValueData = sizeof(wcsValueData);

                dwError = RegEnumValue( hkey,                  // handle of key to query
                                        dwIndex,               // index of value to query
                                        wcsValueName,          // address of buffer for value string
                                        &ccValueName,          // address for size of value buffer
                                        0,                     // reserved
                                        &dwType,               // address of buffer for type code
                                        (BYTE *)wcsValueData,  // address of buffer for value data
                                        &cbValueData );        // address for size of data buffer

                dwIndex++;

                if ( ERROR_SUCCESS == dwError &&                      // Call succeeded
                     ccValueName == (ccScope + 3) &&                  // It's long enough (path + '<#>')
                     wcsValueName[ccScope] == L'<' &&                 // It's a special path
                     RtlEqualMemory( wcsValueName, pwcsScope, ccScope * sizeof(WCHAR) ) &&  // To the right scope
                     REG_SZ == dwType &&                              // With a string value
                     cbValueData == ( sizeof(wcsShadowAlias) + cbAlias ) &&
                     RtlEqualMemory( wcsValueData + ccAlias, wcsShadowAlias,
                                     sizeof(wcsShadowAlias) ) &&      // That *is* an auto-alias
                     RtlEqualMemory( wcsValueData, pwcsAlias, cbAlias ) )  // To the right scope
                {
                    dwError = RegDeleteValue( hkey, wcsValueName );

                    if ( ERROR_SUCCESS != dwError ) {
                        ciDebugOut(( DEB_ERROR, "Error %d deleting %ws\n", dwError, wcsValueName ));
                    }

                    break;
                }
            }
            while (ERROR_SUCCESS == dwError );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CiCat::AddShadowAlias, private
//
//  Synopsis:   Adds shadow scope registry entry
//
//  Arguments:  [pwcsScope] -- Scope to add
//              [pwcsAlias] -- Alias
//              [iSlot]     -- Empty <#> slot
//              [hkey]      -- Registry key to catalog
//
//  History:    15-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CiCat::AddShadowAlias( WCHAR const * pwcsScope,
                            WCHAR const * pwcsAlias,
                            unsigned iSlot,
                            HKEY hkey )
{
    //
    // Build string: NAME: <alias>,,41
    //

    XGrowable<WCHAR> xValue;

    unsigned ccAlias = wcslen(pwcsAlias);
    xValue.SetSize( ccAlias + sizeof(wcsShadowAlias)/sizeof(WCHAR) );

    RtlCopyMemory( xValue.Get(), pwcsAlias, ccAlias * sizeof(WCHAR) );
    RtlCopyMemory( xValue.Get() + ccAlias, wcsShadowAlias, sizeof(wcsShadowAlias) );

    WCHAR wcsValueName[MAX_PATH+4];
    unsigned ccScope = wcslen(pwcsScope);

    if ( ccScope + 4 > sizeof(wcsValueName)/sizeof(WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "CiCat::AddShadowAlias: Scope too big (%ws)\n", pwcsScope ));
    }
    else
    {
        RtlCopyMemory( wcsValueName, pwcsScope, ccScope * sizeof(WCHAR) );
        wcsValueName[ccScope]   = L'<';
        wcsValueName[ccScope+1] = iSlot + L'0';
        wcsValueName[ccScope+2] = L'>';
        wcsValueName[ccScope+3] = 0;

        DWORD dwError = RegSetValueEx( hkey,                       // Key
                                       wcsValueName,               // Value name
                                       0,                          // Reserved
                                       REG_SZ,                     // Type
                                       (BYTE *)xValue.Get(),       // Data
                                       ccAlias * sizeof(WCHAR) + sizeof(wcsShadowAlias) ); // Size (in bytes)

        if ( ERROR_SUCCESS != dwError ) {
            ciDebugOut(( DEB_ERROR, "Error %d writing %ws\n", dwError, pwcsScope ));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CiCat::RefreshIfShadow, private
//
//  Synopsis:   Refresh shadow scope registry entry (if blank)
//
//  Arguments:  [pwcsScope] -- Scope to refresh
//              [pwcsAlias] -- Alias
//              [hkey]      -- Registry key to catalog
//
//  History:    11-Oct-97   KyleP   Created
//
//  Notes:      Only refresh blank (missing) entries
//
//----------------------------------------------------------------------------

void CiCat::RefreshIfShadowAlias( WCHAR const * pwcsScope,
                                  WCHAR const * pwcsAlias,
                                  HKEY hkey )
{
    unsigned Empty = 1000; // Just bigger than 9;
    unsigned ccAlias = wcslen(pwcsAlias);
    unsigned cbAlias = ccAlias * sizeof(WCHAR);

    //
    // See if this is a missing entry
    //

    WCHAR wcsData[MAX_PATH];

    DWORD dwType;
    DWORD dwSize = sizeof(wcsData);

    DWORD dwError = RegQueryValueEx( hkey,            // Key handle
                                     pwcsScope,       // Name
                                     0,               // Reserved
                                     &dwType,         // Datatype
                                     (BYTE *)wcsData, // Data returned here
                                     &dwSize );       // Size of data

    if ( ERROR_SUCCESS == dwError &&
         REG_SZ == dwType &&
         dwSize > (ccAlias * sizeof(WCHAR)) &&
         wcsData[ccAlias] == L',' &&
         RtlEqualMemory( pwcsAlias, wcsData, cbAlias ) )
        Empty = 1000;
    else
    {
        WCHAR wcsValueName[MAX_PATH+4];
        unsigned ccScope = wcslen(pwcsScope);

        RtlCopyMemory( wcsValueName, pwcsScope, ccScope * sizeof(WCHAR) );
        wcsValueName[ccScope]   = L'<';
        //wcsValueName[ccScope+1] = L'1';
        wcsValueName[ccScope+2] = L'>';
        wcsValueName[ccScope+3] = 0;

        for ( unsigned i = 0; i < 10; i++ )
        {
            wcsValueName[ccScope+1] = i + L'0';
            dwSize = sizeof(wcsData);

            dwError = RegQueryValueEx( hkey,            // Key handle
                                       wcsValueName,    // Name
                                       0,               // Reserved
                                       &dwType,         // Datatype
                                       (BYTE *)wcsData, // Data returned here
                                       &dwSize );       // Size of data

            if ( ERROR_FILE_NOT_FOUND == dwError && Empty > 9 )
                Empty = i;

            if ( ERROR_SUCCESS == dwError &&
                 REG_SZ == dwType &&
                 dwSize > (ccAlias * sizeof(WCHAR)) &&
                 wcsData[ccAlias] == L',' &&
                 RtlEqualMemory( pwcsAlias, wcsData, cbAlias ) )
            {
                Empty = 1000;
                break;
            }
        }
    }

    if ( Empty < 10 )
        AddShadowAlias( pwcsScope, pwcsAlias, Empty, hkey );
}
//+---------------------------------------------------------------------------
//
//  Member:     CiCat::PropertyRecordToFileId, public
//
//  Synopsis:   Looks up the fileid and volumeid from a property record
//
//  Arguments:  [PropRec]  -- The record to use for the reads
//              [fileId]   -- Returns the fileid of the file
//              [volumeId] -- Returns the volumeid of the file
//
//  Returns:    TRUE if valid fileid and volumeid values were found
//
//  History:    2-April-1998    dlee  created
//
//----------------------------------------------------------------------------

BOOL CiCat::PropertyRecordToFileId(
    CCompositePropRecord & PropRec,
    FILEID &               fileId,
    VOLUMEID &             volumeId )
{
    PROPVARIANT var;
    _propstoremgr.ReadProperty( PropRec, pidFileIndex, var );
    fileId = var.uhVal.QuadPart;

    if ( ( VT_UI8 == var.vt ) && ( fileIdInvalid != fileId ) )
    {
        _propstoremgr.ReadProperty( PropRec, pidVolumeId, var );
        volumeId = var.ulVal;

        ciDebugOut(( DEB_ITRACE,
                     "propertyrecordtofileid, type %#x, volid %#x\n",
                     var.vt, volumeId ));

        return ( ( VT_UI4 == var.vt ) &&
                 ( CI_VOLID_USN_NOT_ENABLED != volumeId ) );
    }

    ciDebugOut(( DEB_ITRACE, "propertyrecordtofileid failed!\n" ));

    return FALSE;
} //PropertyRecordToFileId

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ClearNonStorageProperties, public
//
//  Synopsis:   write VT_EMPTY into the properties in the PropertyStores ( 
//              except the storage properties, e.g. path, filename, etc.) 
//              before a file is reindexed. Thus, if a property value is 
//              deleted from the document, the old values will be wiped out.
//
//  Arguments:  [wid] -- Workid
//
//  History:    06-Oct-2000 KitmanH     Created
//
//--------------------------------------------------------------------------

void CiCat::ClearNonStoragePropertiesForWid( WORKID wid )
{
    if ( widInvalid != wid )
    {
        XWriteCompositeRecord rec( _propstoremgr, wid );
        _propstoremgr.ClearNonStorageProperties( rec.GetReference() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\drvnotif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       DrvNotif.cxx
//
//  Contents:   This class keeps the information of a volume that's
//              registered for device notification.
//
//  History:    23-Jun-98 KitmanH     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <drvnotif.hxx>
#include <dbt.h>

extern SERVICE_STATUS_HANDLE g_hTheCiSvc;

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::CDrvNotificationInfo, public
//
//  Synopsis:   Creates a new instance of CDrvNotificationInfo
//
//  Arguments:  [wcDriveLetter] - the drive letter of the volume
//
//  History:    6-24-98   KitmanH   Created
//
//----------------------------------------------------------------------------

CDrvNotificationInfo::CDrvNotificationInfo(
    WCHAR wcDriveLetter,
    BOOL  fAutoMountMode )
        : _hVol(INVALID_HANDLE_VALUE),
          _wcDriveLetter( wcDriveLetter ),
          _hNotify(INVALID_HANDLE_VALUE),
          _dwVolState(eVolReady),
          _cLockAttempts(0),
          _fAutoMountMode( fAutoMountMode )
{
    WCHAR awc[4];
    wcscpy( awc, L"C:\\" );
    awc[0] = wcDriveLetter;
    _uiDriveType = GetDriveType( awc );
} //CDrvNotificationInfo

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::~CDrvNotificationInfo, public
//
//  Synopsis:   Destrucstor for CDrvNotificationInfo
//
//  History:    6-24-98   KitmanH   Created
//
//----------------------------------------------------------------------------

CDrvNotificationInfo::~CDrvNotificationInfo()
{
    UnregisterNotification();

    CloseVolumeHandle();
} //~CDrvNotificationInfo

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::GetVolumeHandle, private
//
//  Synopsis:   Gets the volume handle and checks if the volume is read-only
//
//  Returns:    TRUE if succeeded, FALSE otherwise
//
//  History:    6-24-98   KitmanH   Created
//
//----------------------------------------------------------------------------

BOOL CDrvNotificationInfo::GetVolumeHandle( )
{
    Win4Assert( INVALID_HANDLE_VALUE == _hVol );
    CloseVolumeHandle();

    ciDebugOut(( DEB_ITRACE, "GetVolumeHandle for %wc\n", _wcDriveLetter ));
    WCHAR wcsVolumePath[] = L"\\\\.\\a:";
    wcsVolumePath[4] = _wcDriveLetter;

    _hVol = CreateFile( wcsVolumePath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( INVALID_HANDLE_VALUE == _hVol )
    {
        ciDebugOut(( DEB_IWARN, "CDrvNotificationInfo::GetVolumeHanlde: LastError is %d\n", GetLastError() ));
        return FALSE;
    }

    ciDebugOut(( DEB_ITRACE, "GetVolumeHanlde succeeded!!\n" ));
    return TRUE;
} //GetVolumeHandle

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::RegisterNotification, public
//
//  Synopsis:   register the volume for device notification
//
//  Returns:    TRUE if the registration is successful, FALSE otherwise
//
//  History:    6-24-98   KitmanH   Created
//
//----------------------------------------------------------------------------

BOOL CDrvNotificationInfo::RegisterNotification()
{
    UnregisterNotification();

    if ( !GetVolumeHandle() )
        return FALSE;

    Win4Assert( 0 != g_hTheCiSvc );
    Win4Assert( INVALID_HANDLE_VALUE != _hVol );

    DEV_BROADCAST_HANDLE DbtHandle;

    ZeroMemory( &DbtHandle, sizeof(DEV_BROADCAST_HANDLE) );

    DbtHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    DbtHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
    DbtHandle.dbch_handle = _hVol;

    ciDebugOut(( DEB_ITRACE, "About to RegisterDeviceNotification...\n" ));

    _hNotify = RegisterDeviceNotification( (HANDLE) g_hTheCiSvc,
                                           &DbtHandle,
                                           DEVICE_NOTIFY_SERVICE_HANDLE );

    //check if the registration succeeded

    if ( 0 == _hNotify )
    {
        ciDebugOut(( DEB_IWARN, "RegisterNotification on '%wc' failed: LastError is %d\n",
                     _wcDriveLetter, GetLastError() ));
        CloseVolumeHandle();
        return FALSE;
    }

    ciDebugOut(( DEB_ITRACE, "RegisterNotification for drive %wc succeeded, handle %#x!\n",
                 _wcDriveLetter, _hNotify ));
    CloseVolumeHandle();
    return TRUE;
} //RegisterNotification

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::UnRegisterNotification, public
//
//  Synopsis:   unregister the volume for device notification
//
//  History:    6-30-98   KitmanH   Created
//
//----------------------------------------------------------------------------

void CDrvNotificationInfo::UnregisterNotification()
{
    if ( INVALID_HANDLE_VALUE != _hNotify )
    {
        BOOL fOK = UnregisterDeviceNotification( _hNotify );

        ciDebugOut(( DEB_ITRACE, "UnregisterDeviceNotification for %wc handle %#x result %d\n",
                     _wcDriveLetter, _hNotify, fOK ));

        _hNotify = INVALID_HANDLE_VALUE;
    }
} //UnregisterNotification

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::ReallyTouch, public
//
//  Synopsis:   Touch the volume, in an attempt to force it to mount
//
//  Returns:    TRUE if the volume appears healthy, FALSE otherwise
//
//  History:    March-9-00   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CDrvNotificationInfo::ReallyTouch()
{
    WCHAR awc[4];
    wcscpy( awc, L"C:\\" );
    awc[0] = _wcDriveLetter;

    WIN32_FILE_ATTRIBUTE_DATA fData;
    return GetFileAttributesEx( awc, GetFileExInfoStandard, &fData );
} //ReallyTouch

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotificationInfo::Touch, public
//
//  Synopsis:   Touch the volume, in an attempt to force it to mount
//
//  Returns:    TRUE if the volume appears healthy, FALSE otherwise
//
//  History:    April-8-99   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CDrvNotificationInfo::Touch()
{
    //
    // The CreateFile or DeviceIoControl causes an infinite mount loop
    // on CD ROM devices.
    //

    if ( IsCDROM() )
        return ReallyTouch();

    BOOL fOk = FALSE;

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = _wcDriveLetter;

    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

    if ( hVolume != INVALID_HANDLE_VALUE )
    {
        SWin32Handle xHandleVolume( hVolume );

        //
        // Is there media in the drive?  This check avoids possible hard-error
        // popups prompting for media.
        //

        ULONG ulSequence;
        DWORD cb = sizeof(ULONG);

        fOk = DeviceIoControl( hVolume,
                               IOCTL_STORAGE_CHECK_VERIFY,
                               0,
                               0,
                               &ulSequence,
                               sizeof(ulSequence),
                               &cb,
                               0 );

        if ( fOk )
            fOk = ReallyTouch();
    }

    return fOk;
} //Touch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\filidmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       filidmap.cxx
//
//  Contents:   FileId to wid mapping using hashed access
//
//  History:    07-May-97   SitaramR    Created
//
//  Notes:      Only ntfs 5.0 wids are added to the file id map because all
//              non-ntfs 5.0 wids map to fileIdInvalid, which means that there
//              will be too many collisions on fileIdInvalid, which will degrade
//              the performance of the hashed access. One drawback of mapping
//              only ntfs 5.0 wids is that the count of wids in fileid map and
//              property store cannot be checked for equality to detect
//              corruption as is done for the strings table. However, there is a
//              correlation between a count mismatch in strings table and in
//              file id map table because the file id map table is flushed before
//              the strings table. As a result, when a corruption is detected
//              in strings table, a corruption error is thrown and the processing
//              for that corruption error reinitializes both strings table and the
//              file id map table.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filidmap.hxx>
#include <mmstrm.hxx>
#include <cistore.hxx>
#include <prpstmgr.hxx>
#include <propiter.hxx>
#include <cicat.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::CFileIdMap
//
//  Synopsis:   Constructor
//
//  Arguments:  [propStoreMgr] -- Property store
//              [cicat]     -- CiCat
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CFileIdMap::CFileIdMap( CPropStoreManager &propStoreMgr )
        : CPersHash( propStoreMgr, FALSE ),
          _cCacheEntries( 0 )
    #if CIDBG == 1
        , _cCacheHits( 0 ),
          _cCacheNegativeHits( 0 ),
          _cCacheMisses( 0 ),
          _cCacheNegativeMisses( 0 )
    #endif
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::FastInit
//
//  Synopsis:   Fast initialization
//
//  Arguments:  [pStorage]   -- Ci storage
//              [pwcsCatDir] -- Catalog directory
//              [pwcsFile]   -- File id file name
//              [version]    -- Content index version
//
//  History:    28-Jul-97     SitaramR       Created
//              13-Mar-98     KitmanH        Passed in True to 
//                                           CPerHash::FastInit to specify 
//                                           that a FileIdMap is wanted 
//
//----------------------------------------------------------------------------

BOOL CFileIdMap::FastInit( CiStorage * pStorage,
                           ULONG version )
{
    return CPersHash::FastInit(pStorage, version, TRUE);  
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::LongInit
//
//  Synopsis:   Initialization that may take a long time
//
//  Arguments:  [version]        -- CI version
//              [fDirtyShutdown] -- Set to TRUE if the previous shutdown
//                                  was dirty.
//
//  History:    28-Jul-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CFileIdMap::LongInit ( ULONG version, BOOL fDirtyShutdown )
{
    CPersHash::LongInit( version, fDirtyShutdown );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::LokFlush
//
//  Synopsis:   Flushes fileid map
//
//  History:    28-Jul-97     SitaramR       Created
//              27-Feb-98     KitmanH        Don't flush if catalog is 
//                                           read-only
//
//----------------------------------------------------------------------------

void CFileIdMap::LokFlush()
{
   if ( !_fIsReadOnly )
       CPersHash::LokFlush();
} //LokFlush

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::AddToCache, private
//
//  Synopsis:   Adds an entry to the cache, or overwrites wid if the
//              entry currently exists.  The oldest entry is bumped out.
//              Caching an entry with widInvalid is valid.
//
//  Arguments:  [fileId]   -- FileId to add
//              [wid]      -- VolumeId to add
//              [volumeId] -- VolumeId to add
//
//  History:    22-Jul-98     dlee       Created
//
//--------------------------------------------------------------------------

void CFileIdMap::AddToCache(
    FILEID & fileId,
    WORKID   wid,
    VOLUMEID volumeId )
{
    // First look for the fileid/volumeid currently in the cache

    for ( unsigned iCache = 0; iCache < _cCacheEntries; iCache++ )
    {
        if ( _aCache[ iCache ].fileId == fileId &&
             _aCache[ iCache ].volumeId == volumeId )
        {
            _aCache[ iCache ].wid = wid;
            return;
        }
    }

    Win4Assert( _cCacheEntries <= cFileIdMapCacheEntries );

    // Bump out the oldest item and put the new item first in the array

    unsigned cToMove;

    if ( _cCacheEntries == cFileIdMapCacheEntries )
    {
        cToMove = cFileIdMapCacheEntries - 1;
    }
    else
    {
        cToMove = _cCacheEntries;
        _cCacheEntries++;
    }

    RtlMoveMemory( & _aCache[ 1 ],
                   & _aCache[ 0 ],
                   sizeof SFileIdMapEntry * cToMove );

    _aCache[0].fileId = fileId;
    _aCache[0].volumeId = volumeId;
    _aCache[0].wid = wid;
} //AddToCache

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::FindInCache, private
//
//  Synopsis:   Locates a workid in the cache given a fileid and volumeid
//
//  Arguments:  [fileId]   -- FileId of entry to find
//              [volumeId] -- VolumeId of entry to find
//              [wid]      -- Returns the workid if found
//
//  Returns:    TRUE if found or FALSE if not found
//
//  History:    22-Jul-98     dlee       Created
//
//--------------------------------------------------------------------------

BOOL CFileIdMap::FindInCache(
    FILEID & fileId,
    VOLUMEID volumeId,
    WORKID & wid )
{
    for ( unsigned iCache = 0; iCache < _cCacheEntries; iCache++ )
    {
        if ( _aCache[ iCache ].fileId == fileId &&
             _aCache[ iCache ].volumeId == volumeId )
        {
            wid = _aCache[ iCache ].wid;

            #if CIDBG == 1
                ciDebugOut(( DEB_USN,
                             "fim::find cache worked %#I64x %#x, vol %wc\n",
                             fileId, wid, volumeId ));

                _cCacheHits++;

                if ( widInvalid == wid )
                    _cCacheNegativeHits++;
            #endif

            return TRUE;
        }
    }

    return FALSE;
} //FindInCache

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::RemoveFromCache, private
//
//  Synopsis:   Removes the item from the cache if it exists
//
//  Arguments:  [fileId] -- FileId of entry to remove (only used for assert)
//              [wid]    -- Workid of entry to remove
//
//  History:    22-Jul-98     dlee       Created
//
//--------------------------------------------------------------------------

void CFileIdMap::RemoveFromCache(
    FILEID & fileId,
    WORKID   wid )
{
    for ( unsigned iCache = 0; iCache < _cCacheEntries; iCache++ )
    {
        if ( _aCache[ iCache ].wid == wid )
        {
            Win4Assert( _aCache[ iCache ].fileId == fileId );

            RtlCopyMemory( & _aCache[ iCache ],
                           & _aCache[ iCache + 1 ],
                           sizeof SFileIdMapEntry * ( _cCacheEntries - iCache - 1 ) );
            _cCacheEntries--;
            break;
        }
    }
} //RemoveFromCache

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::LokFind, private
//
//  Synopsis:   Given fileId, find workid.
//
//  Arguments:  [fileId]   - FileId to locate
//              [volumeId] - Volume id of fileid
//
//  Returns:    Workid of FileId
//
//  History:    07-May-97     SitaramR       Created
//
//  Notes:      File ids are not unique across different volumes, hence the
//              need for volume ids.
//
//--------------------------------------------------------------------------

WORKID CFileIdMap::LokFind( FILEID fileId, VOLUMEID volumeId )
{
    Win4Assert( _fFullInit );
    WORKID wid;

    if ( FindInCache( fileId, volumeId, wid ) )
        return wid;

    #if CIDBG == 1
        _cCacheMisses++;
    #endif 

#ifdef DO_STATS
    unsigned cSearchLen = 0;
#endif

    CShortWidList list( HashFun(fileId), _hTable );

    for ( wid = list.WorkId(); wid != widInvalid; wid = list.NextWorkId() )
    {

#ifdef DO_STATS
        cSearchLen++;
#endif

        XPrimaryRecord rec( _PropStoreMgr, wid );

        PROPVARIANT propVar;
        BOOL fFound = _PropStoreMgr.ReadProperty( rec.GetReference(),
                                                  pidFileIndex,
                                                  propVar );

        ciDebugOut(( DEB_ITRACE, "trying wid %#x, fFound %d, fid %#I64x\n",
                     wid, fFound, propVar.uhVal.QuadPart ));
        if ( fFound && propVar.uhVal.QuadPart == fileId )
        {
            Win4Assert( propVar.vt == VT_UI8 );

            BOOL fFound = _PropStoreMgr.ReadProperty( rec.GetReference(),
                                                      pidVolumeId,
                                                      propVar );

            if ( fFound && propVar.ulVal == volumeId )
            {
                Win4Assert( propVar.vt == VT_UI4 );

#ifdef DO_STATS
                _hTable.UpdateStats( cSearchLen );
#endif

                ciDebugOut(( DEB_USN, "fim::find worked %#I64x %#x, vol %wc\n",
                             fileId, wid, volumeId ));

                AddToCache( fileId, wid, volumeId );
                return wid;
            }
            else
            {
                ciDebugOut(( DEB_USN, "fim::find fileid match, but not volid: %#x, %#x\n",
                             propVar.ulVal, volumeId ));
            }
        }
    }

    ciDebugOut(( DEB_USN, "fim::find failed %#I64x, vol %wc\n", fileId, volumeId ));

    #if CIDBG == 1
        _cCacheNegativeMisses++;
    #endif

    //
    // Often, a new file is looked up multiple times before it is added, so
    // add the widInvalid entry to the cache.  Negative lookups are slow.
    //

    AddToCache( fileId, widInvalid, volumeId );

    return widInvalid;
} //LokFind

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::LokAdd
//
//  Synopsis:   Add a new fileid to wid mapping
//
//  Arguments:  [fileId] -- File Id
//              [wid]    -- Workid
//
//  History:    07-May-97   SitaramR   Created
//
//--------------------------------------------------------------------------

void CFileIdMap::LokAdd( FILEID fileId, WORKID wid, VOLUMEID volumeId )
{
    ciDebugOut(( DEB_USN, "Adding map fileid %#I64x -> wid %x, vol %wc\n",
                 fileId, wid, volumeId ));

    Win4Assert( fileIdInvalid != fileId );
    Win4Assert( _fFullInit );

    //
    // Must grow hash table first, as it grovels through property store.
    //

    if ( _hTable.IsFull() )
        GrowHashTable();

    AddToCache( fileId, wid, volumeId );

    _hTable.Add ( HashFun(fileId), wid );
} //LokAdd

//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::LokDelete
//
//  Synopsis:   Delete file id from table
//
//  Arguments:  [fileId]   -- FileId to remove
//              [wid]      -- Workid to remove
//
//  History:    07-May-97   SitaramR       Created.
//
//----------------------------------------------------------------------------

void CFileIdMap::LokDelete( FILEID fileId, WORKID wid )
{
    ciDebugOut(( DEB_USN, "Removing map fileid %#I64x, %#x\n", fileId, wid ));

    RemoveFromCache( fileId, wid );

    _hTable.Remove( HashFun( fileId ), wid, TRUE );
} //LokDelete
                                       
//+---------------------------------------------------------------------------
//
//  Member:     CFileIdMap::HashAll
//
//  Synopsis:   Re-hash all fileId's (after hash table growth)
//
//  History:    07-May-97    May       Created
//
//----------------------------------------------------------------------------

void CFileIdMap::HashAll()
{
    // Count the number of hash table entries and grow the hash table

    {
        CPropertyStoreWids iter( _PropStoreMgr );

        unsigned cWids = 0;

        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
        {
            if ( _fAbort )
            {
                ciDebugOut(( DEB_WARN,
                             "Stopping FileIdMap::HashAll because of shutdown\n" ));
                THROW( CException(STATUS_TOO_LATE) );
            }

            PROPVARIANT propVar;
            BOOL fFound = _PropStoreMgr.ReadPrimaryProperty( wid, pidFileIndex, propVar );

            // Only ntfs 5.0 wids have valid fileid's
    
            if ( fFound &&
                 ( VT_UI8 == propVar.vt ) &&
                 ( fileIdInvalid != propVar.uhVal.QuadPart ) )
                cWids++;
        }

        GrowToSize( cWids );
    }

    // Add the wids to the hash table

    CPropertyStoreWids iter( _PropStoreMgr );

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
    {
        if ( _fAbort )
        {
            ciDebugOut(( DEB_WARN,
                         "Stopping FileIdMap::HashAll because of shutdown\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        PROPVARIANT propVar;
        BOOL fFound = _PropStoreMgr.ReadPrimaryProperty( wid, pidFileIndex, propVar );

        //
        // Only ntfs 5.0 wids have valid fileid's
        //
        if ( fFound &&
             ( VT_UI8 == propVar.vt ) &&
             ( fileIdInvalid != propVar.uhVal.QuadPart ) )
            _hTable.Add ( HashFun( propVar.uhVal.QuadPart ), wid );
    }

#if 0 

    //
    // Look-up every file to see what the hashing looks like.
    //

    {
        CPropertyStoreWids iter( _PropStoreMgr );

        unsigned cWids = 0;

        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
        {
            XPrimaryRecord rec( _PropStoreMgr, wid );
            PROPVARIANT propVar;
            BOOL fFound = _PropStoreMgr.ReadProperty( rec.GetReference(),
                                                      pidFileIndex,
                                                      propVar );

            // Only ntfs 5.0 wids have valid fileid's
    
            if ( fFound &&
                 ( VT_UI8 == propVar.vt ) &&
                 ( fileIdInvalid != propVar.uhVal.QuadPart ) )
            {
                FILEID fid = propVar.uhVal.QuadPart;
                _PropStoreMgr.ReadProperty( rec.GetReference(),
                                            pidVolumeId,
                                            propVar );
                LokFind( fid, propVar.ulVal );
            }
        }

        ciDebugOut(( DEB_FORCE,
                     "hash: size %d count %d maxchain %d searches %d length %d\n",
                     _hTable.Size(),
                     _hTable.Count(),
                     _hTable._cMaxChainLen,
                     _hTable._cTotalSearches,
                     _hTable._cTotalLength ));
    }
#endif
} //HashAll

//+-------------------------------------------------------------------------
//
//  Member:     CFileIdMap::HashFun
//
//  Synopsis:   Hash function for fileid's
//
//  Arguments:  [fileId] - FileId to hash
//
//  History:    07-May-97     SitaramR     Created
//
//--------------------------------------------------------------------------

unsigned CFileIdMap::HashFun( FILEID fileId )
{
    //
    // The lower 32 bits of the fileid are unique at any given time. The
    // upper 32 bits of the fileid represent a sequence number that is
    // incremented every time one of the lower 32 bits number is reused.
    // So, a good hash function is to simply use the lower 32 bits.
    //

    return (unsigned) fileId;
} //HashFun
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\notifary.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-1999.
//
//  File:       DrvNotifArray.cxx
//
//  Contents:   This file contains the class, CDrvNotifArray.
//
//  History:    15-Jul-98 KitmanH     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <notifary.hxx>

#include <catalog.hxx>
#include <cimbmgr.hxx>
#include <regscp.hxx>
#include <regacc.hxx>
#include "scpfixup.hxx"
#include <catreg.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDrvNotifArray::RegisterCatForNotifInRegistry, public
//
//  Synopsis:   Register all the catalogs for device notifications  
//
//  History:    7-15-98   KitmanH   Created
//              8-14-98   KitmanH   Register for notifications for drives
//                                  on which an indexed scope exists too
//
//----------------------------------------------------------------------------

void CDrvNotifArray::RegisterCatForNotifInRegistry()
{
    HKEY hKey;
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        wcsRegCatalogsSubKey,
                                        0,
                                        KEY_QUERY_VALUE |
                                        KEY_ENUMERATE_SUB_KEYS,
                                        &hKey ) )
    {
        SRegKey xKey( hKey );
        DWORD iSubKey = 0;

        do
        {
            FILETIME ft;
            WCHAR awcName[MAX_PATH];
            DWORD cwcName = sizeof awcName / sizeof WCHAR;
            LONG err = RegEnumKeyEx( hKey,
                                     iSubKey,
                                     awcName,
                                     &cwcName,
                                     0, 0, 0, &ft );

            // either error or end of enumeration

            if ( ERROR_SUCCESS != err )
                break;

            iSubKey++;

            HKEY hCatName;
            if ( ERROR_SUCCESS == RegOpenKeyEx( hKey,
                                                awcName,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hCatName ) )
            {
                SRegKey xCatNameKey( hCatName );

                // Check if the catalog is inactive and can be ignored

                WCHAR awcKey[MAX_PATH];
                wcscpy( awcKey, wcsRegJustCatalogsSubKey );
                wcscat( awcKey, L"\\" );
                wcscat( awcKey, awcName );
    
                CRegAccess reg( RTL_REGISTRY_CONTROL, awcKey );
                BOOL fInactive = reg.Read( wcsCatalogInactive,
                                           CI_CATALOG_INACTIVE_DEFAULT );

                if ( !fInactive )
                {
                    WCHAR awcPath[MAX_PATH];
                    DWORD cbPath = sizeof awcPath;
                    if ( ERROR_SUCCESS == RegQueryValueEx( hCatName,
                                                           wcsCatalogLocation,
                                                           0,
                                                           0,
                                                           (BYTE *)awcPath,
                                                           &cbPath ) )
                    {
                        AddDriveNotification( awcPath[0] );
                        unsigned cwcNeeded = wcslen( wcsRegJustCatalogsSubKey );
                        cwcNeeded += 3; // "\\" x 2 + null termination
                        cwcNeeded += wcslen( awcName );
                        cwcNeeded += wcslen( wcsCatalogScopes );
                                    
                        XArray<WCHAR> xKey( cwcNeeded );
                        wcscpy( xKey.Get(), wcsRegJustCatalogsSubKey );
                        wcscat( xKey.Get(), L"\\" );
                        wcscat( xKey.Get(), awcName );
                        wcscat( xKey.Get(), L"\\" );
                        wcscat( xKey.Get(), wcsCatalogScopes );
                                        
                        CRegAccess regScopes( RTL_REGISTRY_CONTROL, xKey.Get() );
                                    
                        CRegistryScopesCallBackAddDrvNotif callback( this );
                        regScopes.EnumerateValues( 0, callback );
                    }
                }
            }
        } while ( TRUE );
    }
} //RegisterCatForNotifInRegistry

//+-------------------------------------------------------------------------
//
//  Member:     UnregisterDeviceNotifications, public
//
//  Synopsis:   Unregister all the device notifications 
//
//  History:    07-07-98   kitmanh       Created.
//
//--------------------------------------------------------------------------

void CDrvNotifArray::UnregisterDeviceNotifications()
{
    ciDebugOut(( DEB_ITRACE, "Unregister Device Notificaiton On Shutdown\n" ));

    CReleasableLock lock( _mutex );

    for ( unsigned i = 0; i < _aDriveNotification.Count(); i++ )
    {
        CDrvNotificationInfo * pDrvNot = _aDriveNotification.Get(i);
        delete pDrvNot;
    }

    _aDriveNotification.Clear();

    // If the async thread is around, get rid of it

    if ( !_xWorker.IsNull() )
    {
        _fAbort = TRUE;
        ciDebugOut(( DEB_ITRACE, "waking up async register for shutdown\n" ));
        _evtWorker.Set();

        lock.Release();

        ciDebugOut(( DEB_ITRACE, "waiting for async register death\n" ));
        _xWorker->WaitForDeath();
        _xWorker.Free();
        _fAbort = FALSE;
    }
} //UnregisterDeviceNotifications

//+-------------------------------------------------------------------------
//
//  Member:     AddDriveNotification, public
//
//  Synopsis:   Register the volume for device notification. Add an entry in
//              the array _aDriveNotification for record
//
//  Arguments:  [wcDriveLetter] -- DriveLetter of the volume where the 
//                                  catalog resides
//
//  History:    18-May-98 KitmanH    Created
//
//--------------------------------------------------------------------------

void CDrvNotifArray::AddDriveNotification( WCHAR wcDriveLetter, BOOL fNotInRegistry )
{
    // first, look up the table to see if the volume is alreay in the table
 
    if ( FindDriveNotification( wcDriveLetter ) )
    {
        ciDebugOut(( DEB_ITRACE, "Volume %wc is already in the DriveNotification array\n",
                     wcDriveLetter ));
        return;
    }

    // if not in the table, check the volume and add an entry of DriveNotificationInfo
    ciDebugOut(( DEB_ITRACE, "CDrvNotifArray::AddDriveNotification: Adding volume %wc to the DriveNot Array\n", 
                 wcDriveLetter ));

    XPtr <CDrvNotificationInfo> xDrvNotif(new CDrvNotificationInfo( wcDriveLetter,
                                                                    fNotInRegistry )); 

    {
        CLock lockx( _mutex );
        
        if ( xDrvNotif->RegisterNotification() ) 
        {
            _aDriveNotification.Add( xDrvNotif.GetPointer(), 
                                     _aDriveNotification.Count() );

            xDrvNotif->CloseVolumeHandle();
            xDrvNotif.Acquire();            

            ciDebugOut(( DEB_ITRACE, "AddDriveNotification succeeded for DRIVE %wc\n", 
                         wcDriveLetter ));
        }
    }
} //AddDriveNotification

//+-------------------------------------------------------------------------
//
//  Function:   FindDriveNotificationByHandle, public
//  
//  Synopsis:   return the device notification for a particular volume (
//              matching the handle). 
//
//  Arguments:  [hNotify] -- handle for volume when a custom device 
//                           notification occurs
//
//  History:    22-Jun-98 KitmanH    Created
//
//--------------------------------------------------------------------------

CDrvNotificationInfo * CDrvNotifArray::FindDriveNotificationByHandle( HDEVNOTIFY hNotify )
{
    CLock lockx( _mutex );
    for ( unsigned i = 0; i < _aDriveNotification.Count(); i++ )
    {
        CDrvNotificationInfo * pDrvNot = _aDriveNotification.Get(i);
        if ( pDrvNot->GethNotify() == hNotify ) 
            return pDrvNot;
    }

    ciDebugOut(( DEB_ITRACE, "Can't find drive notification in array\n" ));
    return 0; 
} //FindDriveNotificationByHandle


//+-------------------------------------------------------------------------
//
//  Function:   FindDriveNotification, public
//  
//  Synopsis:   return the device notification for a particular volume (
//              matching the handle). 
//
//  Arguments:  [wcDrvLetter] -- Drive Letter for a volume
//
//  History:    01-July-98 KitmanH    Created
//
//--------------------------------------------------------------------------

CDrvNotificationInfo * CDrvNotifArray::FindDriveNotification( WCHAR wcDrvLetter )
{
    CLock lockx( _mutex );
    for ( unsigned i = 0; i < _aDriveNotification.Count(); i++ )
    {
        CDrvNotificationInfo * pDrvNot = _aDriveNotification.Get(i);
        if ( toupper(pDrvNot->GetDrvLetter()) == toupper(wcDrvLetter) ) 
            return pDrvNot;
    }

    ciDebugOut(( DEB_ITRACE, "Can't find drive notification in array\n" ));
    return 0; 
} //FindDriveNotification

//+-------------------------------------------------------------------------
//
//  Function:   CDrvNotifArray::RegisterRemovableDrives, public
//  
//  Synopsis:   Registers all removable drives for notification (except a:
//              and b:).
//
//  History:    26-March-99 dlee   Created
//
//--------------------------------------------------------------------------

void CDrvNotifArray::RegisterRemovableDrives()
{
    // Determine which drives exist in this bitmask

    DWORD dwDriveMask = GetLogicalDrives();
    dwDriveMask >>= 2;

    // loop through all the drives c-z

    for ( WCHAR wc = L'C'; wc <= L'Z'; wc++ )
    {
        DWORD dwTemp = ( dwDriveMask & 1 );
        dwDriveMask >>= 1;

        if ( 0 != dwTemp )
        {
            if ( IsRemovableDrive( wc ) )
                AddDriveNotification( wc, TRUE );
        }
    }
} //RegisterRemovableDrives

//+-------------------------------------------------------------------------
//
//  Function:   CDrvNotifArray::RegisterThread, private
//  
//  Synopsis:   The worker thread function.
//
//  History:    12-April-99 dlee   Created
//
//--------------------------------------------------------------------------

DWORD WINAPI CDrvNotifArray::RegisterThread( void * self )
{
    return ( (CDrvNotifArray *) self)->DoRegisterWork();
} //RegisterThread

//+-------------------------------------------------------------------------
//
//  Function:   CDrvNotifArray::RegisterThread, private
//  
//  Synopsis:   Waits around to be told to register for device notificaitons
//              on volumes not currently registered.
//
//  History:    12-April-99 dlee   Created
//
//--------------------------------------------------------------------------

DWORD CDrvNotifArray::DoRegisterWork()
{
    do
    {
        _evtWorker.Wait();

        CLock lock( _mutex );

        ciDebugOut(( DEB_ITRACE, "async register woke up, _fAbort: %d\n", _fAbort ));

        if ( _fAbort )
            break;

        for ( unsigned i = 0; i < _aDriveNotification.Count(); i++ )
        {
            CDrvNotificationInfo & DrvNot = * _aDriveNotification.Get(i);

            if ( !DrvNot.IsRegistered() )
                DrvNot.RegisterNotification();
        }

        _evtWorker.Reset();
    } while (TRUE);

    return 0;
} //DoRegisterWork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\cinulcat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       CiNulCat.CXX
//
//  Contents:   Content index null catalog.
//
//  Classes:
//
//  History:    09-Jul-1997   KrishnaN    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <regacc.hxx>
#include <cicat.hxx>
#include <cinulcat.hxx>
#include <update.hxx>
#include <pstore.hxx>
#include <pidremap.hxx>
#include <imprsnat.hxx>
#include <docstore.hxx>
#include <cievtmsg.h>
#include <cifailte.hxx>
#include <regscp.hxx>
#include <cifrmcom.hxx>
#include <glbconst.hxx>
#include <cimbmgr.hxx>

#include "catreg.hxx"

//
// Given a registry string like \Registry\Machine\System\CurrentControlSet\...
// you skip the first 18 characters if using w/ HKEY_LOCAL_MACHINE.
//

unsigned const SKIP_TO_LM = 18;


// -------------------------------------------------------------------------
// DO NOT VIOLATE THE FOLLOWING LOCK HIERARCHY
//
// 1. DocStore Lock
// 2. CiNullCat Admin Lock
// 3. CiNullCat Lock
// 4. Resman Lock
// 5. ScopeTable Lock
// 6. NotifyMgr Lock
// 7. ScanMgr Lock
// 8. Propstore write lock
// 9. Propstore lock record
//
// It is okay for a thread to acquire lock at level X and then acquire a lock
// at a level >= X but not locks < X. This will avoid deadlock situations.
//
// SrikantS   - April 25, 1996
// SrikantS   _ Dec 31, 1996 - Added DocStore as the highest level lock
//
// -------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Member:     CiNullCat::SetAdviseStatus, public
//
//  Synopsis:   Taken out of the CiNullCat constructor
//
//  History:    11-May-2001 KitmanH  Taken out from the CiNullCat constructor
//      
//  Note:       The purpose of this function is to prevent circular deleteions
//              of CiNullCat and CClientDocStore. If CClientDocStore throws
//              after StartUpCiFrameWork, CiNullCat should not AddRef to 
//              docstore
//
//--------------------------------------------------------------------------

void CiNullCat::SetAdviseStatus()
{
    // obtain an ICiCAdviseStatus interface pointer to use
    ICiCAdviseStatus    *pAdviseStatus = 0;

    SCODE sc = _docStore.QueryInterface( IID_ICiCAdviseStatus,
                                         (void **) &pAdviseStatus);
    if ( S_OK != sc )
    {
        Win4Assert( 0 == pAdviseStatus );

        THROW( CException(sc) );
    }

    _xAdviseStatus.Set(pAdviseStatus);
}

//+-------------------------------------------------------------------------
//
//  Member:     CiNullCat::CiNullCat, public
//
//  Synopsis:   Creates a new 'content index catalog'
//
//  Arguments:  [wcsCatPath] - root path of catalog
//              [pwcName]    - 0 or name of the catalog from the registry
//
//  History:    10-Mar-92 BartoszM  Created
//              14-mar-92 KyleP     Added Content index object.
//
//--------------------------------------------------------------------------

CiNullCat::CiNullCat ( CClientDocStore & docStore)
        : _ulSignature( LONGSIG( 'c', 'c', 'a', 't' ) ),
          _state(eStarting),
          _docStore(docStore),
          _fInitialized(FALSE),
          _impersonationTokenCache( CINULLCATALOG )
{
    CImpersonateSystem impersonate;

    BuildRegistryScopesKey( _xScopesKey, CINULLCATALOG );

    _impersonationTokenCache.Initialize( CI_ACTIVEX_NAME,
                                         FALSE,
                                         FALSE,
                                         FALSE,
                                         1,
                                         1,
                                         1 );

    // These scopes will be used for query time (un)fixups
    SetupScopeFixups();

    _state = eStarted;

    END_CONSTRUCTION( CiNullCat );

} //CiNullCat

//+---------------------------------------------------------------------------
//
//  Member:     CiNullCat::ShutdownPhase2, public
//
//  Synopsis:   Dismounts the catalog by stopping all activity.
//
//  History:    1-30-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiNullCat::ShutdownPhase2()
{
    CImpersonateSystem impersonate;

    TRY
    {
        // ===================================================
        {
            CLock   lock(_mutex);
            _state = eShutdown;
        }
        // ===================================================

        CLock   lock(_mutex);
        _xCiManager.Free();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "CiNullCat::Shutdown failed with error 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //Shutdown

//+-------------------------------------------------------------------------
//
//  Member:     CiNullCat::~CiNullCat, public
//
//  Synopsis:   Destructor
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

CiNullCat::~CiNullCat ()
{
    if ( !IsShutdown() )
        ShutdownPhase2();
}

//+---------------------------------------------------------------------------
//
//  Member:      CiNullCat::CiState, public
//
//  Synopsis:    Returns state of downlevel CI
//
//  Arguments:   [state] -- buffer to return state into
//
//  History:     14-Dec-95  DwightKr    Created
//
//----------------------------------------------------------------------------

#define setState( field, value ) \
    if ( state.cbStruct >= ( offsetof( CI_STATE, field) +   \
                             sizeof( state.field ) ) )      \
    {                                                       \
        state.field = ( value );                            \
    }

SCODE CiNullCat::CiState( CI_STATE & state )
{
    SCODE sc = S_OK;

    if ( IsStarted() )
    {
        state.cbStruct = min( state.cbStruct, sizeof(CI_STATE) );

        RtlZeroMemory( &state, state.cbStruct );

        setState( dwMergeProgress, 100 );
    }
    else if ( IsShutdown() )
    {
        sc = CI_E_SHUTDOWN;
    }
    else
    {
        sc = CI_E_NOT_INITIALIZED;
    }

    return sc;

}

//+---------------------------------------------------------------------------
//
//  Member:     CiNullCat::HandleError
//
//  Synopsis:   Checks the status code passed and if it indicates corruption,
//              the index will be marked corrupt in-memory as well as on
//              disk. The recovery will happen on a subsequent restart.
//
//  Arguments:  [status] -  The status code to check for corruption.
//
//  History:    3-21-96   srikants   Created
//
//  Notes:      MUST NOT THROW
//
//----------------------------------------------------------------------------

void CiNullCat::HandleError( NTSTATUS status )
{
    Win4Assert(CI_PROPSTORE_INCONSISTENCY != status);
    Win4Assert(!IsDiskLowError(status));
    Win4Assert(!IsCiCorruptStatus(status));

    //
    // We can't be corrupt, so nothing to do here.
    //
} //HandleError

//
// Support for CI Frame Work
//
//+---------------------------------------------------------------------------
//
//  Member:     CiNullCat::StartupCiFrameWork
//
//  Synopsis:   Takes the CiManager object pointer and refcounts it.
//
//  Arguments:  [pICiManager] -
//
//  History:    12-05-96   srikants   Created
//
//  Note:       Choose a better name.
//
//----------------------------------------------------------------------------

//
void CiNullCat::StartupCiFrameWork( ICiManager * pICiManager )
{
    Win4Assert( 0 != pICiManager );
    Win4Assert( 0 == _xCiManager.GetPointer() );

    if ( 0 == _xCiManager.GetPointer() )
    {
        pICiManager->AddRef();
        _xCiManager.Set( pICiManager );
    }

    RefreshRegistryParams();
}

//+---------------------------------------------------------------------------
//
//  Member:     CiNullCat::RefreshRegistryParams
//
//  Synopsis:   Refreshes CI registry parameters.
//
//  History:    12-12-96   srikants   Created
//               1-25-97   mohamedn   ICiAdminParams, ICiAdmin
//  Notes:
//
//----------------------------------------------------------------------------

void CiNullCat::RefreshRegistryParams()
{

    ICiAdminParams              *pICiAdminParams = 0;
    XInterface<ICiAdminParams>  xICiAdminParams;

    ICiAdmin                    *pICiAdmin = 0;
    XInterface<ICiAdmin>        xICiAdmin;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    {
        CLock   lock(_mutex);

        if ( !IsShutdown() && 0 != _xCiManager.GetPointer() )
        {
            // get pICiAdminParams
            SCODE sc = _xCiManager->GetAdminParams( &pICiAdminParams );
            if ( FAILED(sc) )
            {
                Win4Assert( 0 == pICiAdminParams );

                THROW( CException(sc) );
            }

            xICiAdminParams.Set(pICiAdminParams);

            // get pICiAdmin
            sc = _xCiManager->QueryInterface(IID_ICiAdmin,(void **)&pICiAdmin);
            if ( FAILED(sc) )
            {
                 Win4Assert( 0 == pICiAdmin );

                 THROW( CException(sc) );
            }

            xICiAdmin.Set(pICiAdmin);
        }
    }
    // -----------------------------------------------------

    SCODE sc = xICiAdmin->InvalidateLangResources();
    if ( FAILED (sc) )
    {
         Win4Assert( !"Failed to InvalidateLangResources\n" );

         THROW( CException(sc) );
    }

    _regParams.Refresh(pICiAdminParams);
}

//+-------------------------------------------------------------------------
//
//  Member:     CiNullCat::SetupScopeFixups, private
//
//  Synopsis:   Grovel registry looking for CI scopes and setup fixups
//
//  History:    16-Oct-96 dlee     Created
//
//--------------------------------------------------------------------------

void CiNullCat::SetupScopeFixups()
{
    TRY
    {
        ciDebugOut(( DEB_ITRACE, "Reading scope fixups from '%ws'\n", GetScopesKey() ));
        CRegAccess regScopes( RTL_REGISTRY_ABSOLUTE, GetScopesKey() );

        CRegistryScopesCallBackFixups callback( this );
        regScopes.EnumerateValues( 0, callback );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x caught groveling ci registry fixups.\n",
                     e.GetErrorCode() ));

        HandleError( e.GetErrorCode() );
    }
    END_CATCH
} //SetupScopeFixups
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\dellog.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1998
//
//  File:       dellog.cxx
//
//  Contents:   Deletion log for usns
//
//  History:    28-Jul-97   SitaramR    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>

#include "cicat.hxx"
#include "dellog.hxx"

const LONGLONG eSigDelLog = 0x64656c746e6c6f67i64;  // Signature


//+---------------------------------------------------------------------------
//
//  Member:     CFakeVolIdMap::CFakeVolIdMap
//
//  Synopsis:   Constructor
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CFakeVolIdMap::CFakeVolIdMap()
{
    for ( ULONG i=0; i<COUNT_SPECIAL_CHARS; i++)
        _aVolIdSpecial[i] = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFakeVolIdMap::VolIdToFakeVolId
//
//  Synopsis:   Converts a volume id to a fake volume id in the range
//              0..RTL_MAX_DRIVE_LETTERS-1
//
//  History:    28-Jul-97     SitaramR       Created
//
//  Notes:      Drive letters in the range 'a' to 'z' are mapped by subtracting
//              'a', which is the base volume id, i.e. they are in the range
//              0..25 The volume id's for the remaining drive letters are
//              maintained in _aVolIdSpecial, and the fake volume ids for these
//              special drives are in the range 26..RTL_MAX_DRIVE_LETTERS-1.
//
//----------------------------------------------------------------------------

ULONG CFakeVolIdMap::VolIdToFakeVolId( VOLUMEID volumeId )
{
    //
    // Volume ids are obtained by the ascii value of the drive letter
    //
    Win4Assert( volumeId < 0xff );

    if ( volumeId >= VolumeIdBase
         && volumeId-VolumeIdBase < COUNT_ALPHABETS )
    {
        return volumeId-VolumeIdBase;
    }

    //
    // Lookup in _aVolIdSpecial
    //
    for ( ULONG i=0; i<COUNT_SPECIAL_CHARS; i++ )
    {
        if ( _aVolIdSpecial[i] == volumeId )
            return COUNT_ALPHABETS + i;
    }

    for ( i=0; i<COUNT_SPECIAL_CHARS; i++ )
    {
        if ( _aVolIdSpecial[i] == 0 )
        {
            _aVolIdSpecial[i] = volumeId;
            return COUNT_ALPHABETS + i;
        }
    }

    Win4Assert( !"Volume id map overflow" );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFakeVolIdMap::FakeVolIdToVolId
//
//  Synopsis:   Converts a fake volume id in the range 0..RTL_MAX_DRIVE_LETTERS-1
//              to a real volume id
//
//  History:    28-Jul-97     SitaramR       Created
//
//  Notes:      See VolIdToFakeVolId for mapping info.
//
//----------------------------------------------------------------------------

VOLUMEID CFakeVolIdMap::FakeVolIdToVolId( ULONG fakeVolId )
{
    Win4Assert( fakeVolId < RTL_MAX_DRIVE_LETTERS );

    if ( fakeVolId < COUNT_ALPHABETS )
        return VolumeIdBase + fakeVolId;
    else
        return _aVolIdSpecial[fakeVolId-COUNT_ALPHABETS];
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::CDeletionLog
//
//  Synopsis:   Constructor
//
//  Arguments:  [fileIdMap] -- File id map
//              [cicat]     -- Ci catalog
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CDeletionLog::CDeletionLog( CFileIdMap & fileIdMap, CiCat& cicat )
   : _fileIdMap(fileIdMap),
     _cicat(cicat)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::FastInit
//
//  Synopsis:   Initialization
//
//  Arguments:  [pStorage]   -- Ci storage
//              [pwcsCatDir] -- Catalog dir
//              [version]    -- Version #
//
//  History:    28-Jul-97     SitaramR       Created
//              02-Mar-98     KitmanH        Used QueryDeletionlog to obtain a new 
//                                           CMmStream
//
//  Notes:      The persistent format is <vol id><cEntries><entry 1>..<entry cEntries>
//              for each volume id, and each entry has <fileid><wid><usn>.
//
//----------------------------------------------------------------------------

void CDeletionLog::FastInit( CiStorage * pStorage,
                             ULONG version )
{

    XPtr<PMmStream> sStrm( pStorage->QueryDeletionLog() );

    _xPersStream.Set( new CDynStream( sStrm.GetPointer() ) );

    sStrm.Acquire();

    _xPersStream->CheckVersion( *pStorage, version );

    ULONG cVolumes = _xPersStream->Count();
    _xPersStream->InitializeForRead();

    for ( ULONG i=0; i<cVolumes; i++ )
    {
        ULONG cbRead;
        LONGLONG llSig;

        cbRead = _xPersStream->Read( &llSig, sizeof(llSig) );
        if ( cbRead != sizeof(llSig) )
            FatalCorruption( cbRead, sizeof(llSig) );

        if ( eSigDelLog != llSig )
        {
            ciDebugOut(( DEB_ERROR,
                         "CDeletionLog: Signature mismatch 0x%x:0x%x\n",
                         lltoHighPart(llSig),
                         lltoLowPart(llSig) ));
            FatalCorruption( 0, 0 );
        }

        VOLUMEID volumeId;
        cbRead = _xPersStream->Read( &volumeId, sizeof(VOLUMEID) );
        if ( cbRead != sizeof(VOLUMEID) )
            FatalCorruption( cbRead, sizeof(VOLUMEID) );

        ULONG cEntries;
        cbRead = _xPersStream->Read( &cEntries, sizeof(ULONG) );
        if ( cbRead != sizeof(ULONG) )
            FatalCorruption( cbRead, sizeof(ULONG) );

        for ( ULONG j=0; j<cEntries;j++ )
        {
            FILEID fileId;
            cbRead = _xPersStream->Read( &fileId, sizeof(FILEID) );
            if ( cbRead != sizeof(FILEID) )
                FatalCorruption( cbRead, sizeof(FILEID) );

            WORKID wid;
            cbRead = _xPersStream->Read( &wid, sizeof(WORKID) );
            if ( cbRead != sizeof(WORKID) )
                FatalCorruption( cbRead, sizeof(WORKID) );

            USN usn;
            cbRead = _xPersStream->Read( &usn, sizeof(USN) );
            if ( cbRead != sizeof(USN) )
                FatalCorruption( cbRead, sizeof(USN) );

            MarkForDeletion( volumeId,
                             fileId,
                             wid,
                             usn );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::ReInit
//
//  Synopsis:   Empties the deletion log
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDeletionLog::ReInit( ULONG version )
{
    CLock lock(_mutex);

    _xPersStream->SetVersion( version );

    for ( ULONG i=0; i<RTL_MAX_DRIVE_LETTERS; i++ )
        _aDelLogEntryList[i].Clear();

    Flush();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::Flush
//
//  Synopsis:   Serializes the deletion log to disk
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDeletionLog::Flush()
{
    Win4Assert( !_xPersStream.IsNull() );

    CLock lock(_mutex);

    _xPersStream->InitializeForWrite( GetSize() );
    LONGLONG llSig = eSigDelLog;

    ULONG cVolumes = 0;
    for ( ULONG i=0; i<RTL_MAX_DRIVE_LETTERS; i++ )
    {
        if ( _aDelLogEntryList[i].Count() > 0 )
        {
            cVolumes++;

            _xPersStream->Write( &llSig, sizeof(llSig) );

            VOLUMEID volumeId = _fakeVolIdMap.FakeVolIdToVolId( i );
            _xPersStream->Write( &volumeId, sizeof(VOLUMEID) );

            ULONG cEntries = _aDelLogEntryList[i].Count();
            _xPersStream->Write( &cEntries, sizeof(ULONG) );

#if CIDBG==1
            ULONG cEntriesInList = 0;
            USN usnPrev = 0;
#endif

            for ( CDelLogEntryListIter entryListIter( _aDelLogEntryList[i] );
                  !_aDelLogEntryList[i].AtEnd(entryListIter);
                  _aDelLogEntryList[i].Advance( entryListIter) )
            {
                 FILEID fileId = entryListIter->FileId();
                _xPersStream->Write( &fileId, sizeof(FILEID) );

                WORKID wid = entryListIter->WorkId();
                _xPersStream->Write( &wid, sizeof(WORKID) );

                USN usn = entryListIter->Usn();
                _xPersStream->Write( &usn, sizeof(USN) );

#if CIDBG==1
                //
                // Check usn's are monotonically increasing
                //
                cEntriesInList++;
                Win4Assert( entryListIter->Usn() >= usnPrev );
                usnPrev = entryListIter->Usn();
#endif
            }

#if CIDBG==1
            Win4Assert( cEntriesInList == _aDelLogEntryList[i].Count() );
#endif
        }
    }

    _xPersStream->SetCount( cVolumes );
    _xPersStream->Flush();
}



//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::MarkForDeletion
//
//  Synopsis:   Adds a deletion entry
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDeletionLog::MarkForDeletion( VOLUMEID volumeId,
                                    FILEID fileId,
                                    WORKID wid,
                                    USN usn )
{
    CLock lock(_mutex);

    XPtr<CDelLogEntry> xEntry( new CDelLogEntry( fileId, wid, usn ) );
    ULONG fakeVolId = _fakeVolIdMap.VolIdToFakeVolId( volumeId );

    Win4Assert( fakeVolId < RTL_MAX_DRIVE_LETTERS );

    if ( _aDelLogEntryList[fakeVolId].Count() == 0 )
    {
        //
        // Empty list case
        //
        _aDelLogEntryList[fakeVolId].Queue( xEntry.Acquire() );
    }
    else
    {
        CDelLogEntry *pEntryLast = _aDelLogEntryList[fakeVolId].GetLast();
        if ( xEntry->Usn() > pEntryLast->Usn() )
        {
            //
            // If the usn is less than the last entry's usn, then it means that it
            // is a usn that is being replayed, and there is no need to add it
            // to the deletion log again.
            //
            _aDelLogEntryList[fakeVolId].Queue( xEntry.Acquire() );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::ProcessChangesFlush
//
//  Synopsis:   Process the list of changes that has been flushed by
//              framework/changelog and do the actual deletes from
//              the file id map.
//
//  Arguments:  [usnFlushInfoList] -- List of changes flushed
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDeletionLog::ProcessChangesFlush( CUsnFlushInfoList & usnFlushInfoList )
{
    CLock lock( _mutex );

    for ( ULONG i=0; i<usnFlushInfoList.Count(); i++ )
    {
        CUsnFlushInfo *pFlushInfo = usnFlushInfoList.Get(i);

        ULONG fakeVolId = _fakeVolIdMap.VolIdToFakeVolId( pFlushInfo->VolumeId() );

        Win4Assert( fakeVolId < RTL_MAX_DRIVE_LETTERS );

        CDelLogEntryList& entryList = _aDelLogEntryList[fakeVolId];
#if CIDBG==1
        USN usnPrev = 0;
#endif

        CDelLogEntryListIter entryListIter( entryList );
        while ( !entryList.AtEnd( entryListIter ) )
        {
            CDelLogEntry *pEntry = entryListIter.GetEntry();
            entryList.Advance( entryListIter );

#if CIDBG==1
            //
            // Check that usn's are monotonically increasing
            //
            Win4Assert( pEntry->Usn() >= usnPrev );
            usnPrev = pEntry->Usn();
#endif

            if ( pEntry->Usn() <= pFlushInfo->UsnHighest() )
            {
                entryList.RemoveFromList( pEntry );
                _fileIdMap.Delete( pEntry->FileId(), pEntry->WorkId() );
                delete pEntry;
            }
            else
            {
                //
                // Since the list is in increasing usn order, we are done
                // with this volume id.
                //
                break;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::GetSize
//
//  Synopsis:   Returns the size of the serialized stream in bytes
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

ULONG CDeletionLog::GetSize()
{
    //
    // Start with a slop factor
    //
    ULONG ulSize = 1024;

    for ( ULONG i=0; i<RTL_MAX_DRIVE_LETTERS; i++ )
    {
        ulSize += sizeof(VOLUMEID)   // volume id field
                  + sizeof(ULONG)    // cEntries field
                  + _aDelLogEntryList[i].Count() * sizeof(CDelLogEntry);
    }

    return ulSize;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeletionLog::FatalCorruption
//
//  Synopsis:   Handles deletion log corruption
//
//  Arguments:  [cbRead]   -- Count of bytes read
//              [cbToRead] -- Count of bytes to read
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDeletionLog::FatalCorruption( ULONG cbRead, ULONG cbToRead )
{
    Win4Assert( !"Corrupt deletion log" );

    ciDebugOut(( DEB_ERROR,
                 "CDeletionLog: read %d bytes instead of %d\n",
                 cbRead,
                 cbToRead ));

    PStorage & storage = _cicat.GetStorage();
    storage.ReportCorruptComponent( L"Deletion log" );

    THROW( CException( CI_CORRUPT_CATALOG ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\imprsnat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       imprsnat.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-16-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <imprsnat.hxx>
#include <pathpars.hxx>
#include <smatch.hxx>
#include <regacc.hxx>
#include <regevent.hxx>
#include <regscp.hxx>
#include <ciregkey.hxx>
#include <cievtmsg.h>
#include <eventlog.hxx>
#include <cimbmgr.hxx>
#include <lcase.hxx>

#include "cicat.hxx"
#include "catreg.hxx"

// List of logon information, shared between catalogs to help reduce
// the problem of running out of logon instances.

CLogonInfoList g_LogonList;

//+---------------------------------------------------------------------------
//
//  Member:     CLogonInfoList::Empty
//
//  Synopsis:   Empties the logon list
//
//  History:    2-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CLogonInfoList::Empty()
{
    for ( CLogonInfo * pLogonInfo = g_LogonList.Pop();
          0 != pLogonInfo;
          pLogonInfo = g_LogonList.Pop() )
    {
        pLogonInfo->Close();
        delete pLogonInfo;
    }
} //Empty

//+---------------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   A helper function to allocate and copy the source string into
//              a destination string.
//
//  Arguments:  [pSrc] -
//              [cc]   -
//
//  Returns:
//
//  History:    4-08-96   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * CLogonInfo::AllocAndCopy( const WCHAR * pSrc, ULONG & cc )
{
    WCHAR * pDst = 0;
    if ( 0 != pSrc )
    {
        cc = wcslen( pSrc );
        pDst = new WCHAR [cc+1];
        RtlCopyMemory( pDst, pSrc, (cc+1)*sizeof(WCHAR) );
    }
    else
    {
        cc = 0;
    }

    return pDst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLogonInfo::Logon
//
//  Synopsis:   Logon the given user with the given password.
//
//  Arguments:  [pwszUser]     - User name
//              [pwszDomain]   - Domain name
//              [pwszPassword] - Password (in clear text) to use.
//
//  Returns:    Status of the operation.
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD CLogonInfo::Logon( WCHAR const * pwszUser,
                         WCHAR const * pwszDomain,
                         WCHAR const * pwszPassword )
{
    Win4Assert( 0 == _pwszUser );
    Win4Assert( 0 == _pwszDomain );
    Win4Assert( 0 == _pwszPassword );

    _pwszUser = AllocAndCopy( pwszUser, _ccUser );
    _pwszDomain = AllocAndCopy( pwszDomain, _ccDomain );
    _pwszPassword = AllocAndCopy( pwszPassword, _ccPassword );

    Win4Assert( INVALID_HANDLE_VALUE == _hToken );

    DWORD dwError = 0;

    if ( !LogonUser( _pwszUser, _pwszDomain, _pwszPassword,
                     LOGON32_LOGON_INTERACTIVE, //LOGON32_LOGON_NETWORK
                     LOGON32_PROVIDER_DEFAULT,
                     &_hToken
                     ) )
    {
        dwError = GetLastError();
        ciDebugOut(( DEB_ERROR, "Failure to logon user (%ws) domain (%ws). Error 0x%X\n",
                     pwszUser, pwszDomain, dwError ));
        _hToken = INVALID_HANDLE_VALUE;
    }

    return dwError;
} //Logon

//+---------------------------------------------------------------------------
//
//  Member:     CLogonInfo::~CLogonInfo
//
//  Synopsis:   Frees up memory and closes the logon token.
//
//  History:    4-05-96   srikants   Created
//
//----------------------------------------------------------------------------

CLogonInfo::~CLogonInfo()
{
    Win4Assert( IsSingle() );   // must not be on the list

    delete [] _pwszUser;
    delete [] _pwszDomain;
    delete [] _pwszPassword;

    if ( INVALID_HANDLE_VALUE != _hToken )
        CloseHandle( _hToken );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLogonInfo::IsSameUser
//
//  Synopsis:   Tests if the given user and domain match what is stored in
//              this object.
//
//  Arguments:  [pwszUser]   - Name of the user
//              [pwszDomain] - Name of the domain
//
//  Returns:    TRUE if same; FALSE o/w
//
//  History:    4-05-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CLogonInfo::IsSameUser( WCHAR const * pwszUser, WCHAR const * pwszDomain ) const
{
    ULONG ccUser   = pwszUser ? wcslen(pwszUser) : 0;
    ULONG ccDomain = pwszDomain ? wcslen(pwszDomain) : 0;

    if ( ccUser == _ccUser && ccDomain == _ccDomain )
    {
        if ( ccUser != 0  && _wcsicmp( pwszUser, _pwszUser ) != 0 )
            return FALSE;

        if ( ccDomain != 0 && _wcsicmp( pwszDomain, _pwszDomain) != 0 )
            return FALSE;

        return TRUE;
    }
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLogonInfo::IsSamePassword
//
//  Synopsis:   Tests if the given password is same as the one stored in this.
//
//  Arguments:  [pwszPassword] -  Password to compare.
//
//  Returns:    TRUE if passwords match; FALSE o/w
//
//  History:    4-05-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLogonInfo::IsSamePassword( WCHAR const * pwszPassword ) const
{
    ULONG ccPassword = pwszPassword ? wcslen(pwszPassword) : 0;

    if ( ccPassword == _ccPassword )
    {
        return RtlEqualMemory( pwszPassword, _pwszPassword,
                               _ccPassword*sizeof(WCHAR) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IpAddressFromWStr
//
//  Synopsis:   Given an ip address in the form of a.b.c.d, it is converted
//              into a ULONG and returned
//
//  Arguments:  [pwszAddress] -
//
//  History:    7-12-96   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CPhyDirLogonInfo::IpAddressFromWStr( WCHAR const * pwszAddress )
{
    if ( 0 == pwszAddress )
        return CI_DEFAULT_IP_ADDRESS;

    ULONG ipAddress = 0;
    WCHAR const * pwszStart = pwszAddress;

    WCHAR wszField[4];

    for ( unsigned cTok = 0; (cTok < 4) && pwszStart[0]; cTok++ )
    {
        WCHAR const * pwszEnd = wcschr( pwszStart, L'.' );
        if ( 0 == pwszEnd )
            pwszEnd = pwszStart + wcslen( pwszStart );

        ULONG cwc = (ULONG)(pwszEnd - pwszStart);
        if ( cwc > 3 ) // max is 255
        {
            ciDebugOut(( DEB_ERROR, "Bad IP Address %ws\n", pwszAddress ));
            return CI_DEFAULT_IP_ADDRESS;
        }

        RtlCopyMemory( wszField, pwszStart, cwc * sizeof(WCHAR) );
        wszField[cwc] = 0;

        ULONG lField = (ULONG) _wtol( wszField );

        ipAddress <<= 8;    // left shift by 8 bits and or in the new ones
        ipAddress |= (lField & 0xFF);

        if ( 0 != pwszEnd[0] )
            pwszStart = pwszEnd+1;
        else pwszStart = pwszEnd;
    }

    if ( cTok == 4 && pwszStart[0] == 0 )
        return ipAddress;
    else return CI_DEFAULT_IP_ADDRESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhyDirLogonInfo::CPhyDirLogonInfo
//
//  Synopsis:   Constructor for the object that keeps logon information for a
//              specific physical directory
//
//  Arguments:  [pwszPhyDirName] - Name of the physical directory (remote)
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

CPhyDirLogonInfo::CPhyDirLogonInfo( CImpersonationTokenCache & cache,
                                    CImprsObjInfo const & obj,
                                    CLogonInfo * pLogonInfo )
                                    : _cache( cache ),
                                      _pwszDirName(0),
                                      _pwszVirtualRoot(0),
                                      _ccVirtual(0)
{
    Win4Assert( 0 != obj.GetPhysicalPath() );

    CDoubleLink::Close();
    _fIsZombie = FALSE;
    _cRef = 0;

    //
    // Create a local copy of the physical directory, virtual root and
    // save the logon information.
    //
    _pwszDirName = CLogonInfo::AllocAndCopy( obj.GetPhysicalPath(), _cc );
    _phyScope.Init( _pwszDirName, _cc );

    if ( 0 != obj.GetVPath() )
    {
        _pwszVirtualRoot = CLogonInfo::AllocAndCopy( obj.GetVPath(), _ccVirtual );
        _virtualScope.Init( _pwszVirtualRoot, _ccVirtual );
    }

    _pLogonInfo = pLogonInfo;
    if ( 0 != _pLogonInfo )
        _pLogonInfo->Addref();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhyDirLogonInfo::~CPhyDirLogonInfo
//
//  Synopsis:   Free up the memory and release the logon info.
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

CPhyDirLogonInfo::~CPhyDirLogonInfo()
{
    Win4Assert( IsSingle() );   // must not be on the list

    delete [] _pwszDirName;
    delete [] _pwszVirtualRoot;

    if ( 0 != _pLogonInfo )
    {
        _cache.Release( _pLogonInfo );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::CImpersonationTokenCache
//
//  Synopsis:   Constructor of the impersonation token cache.
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

CImpersonationTokenCache::CImpersonationTokenCache(
    WCHAR const * pwcCatName )
: _fIndexW3Roots(FALSE),
  _fIndexNNTPRoots(FALSE),
  _fIndexIMAPRoots(FALSE),
  _W3SvcInstance(1),
  _NNTPSvcInstance(1),
  _IMAPSvcInstance(1),
  _fRemoteSharesPresent(FALSE),
  _pwszComponentName(0)
{
    if ( 0 != pwcCatName )
        wcscpy( _awcCatalogName, pwcCatName );
    else
        _awcCatalogName[0] = 0;

    for ( unsigned i = 0; i < CI_MAX_DRIVES;i++ )
        _aDriveInfo[i] = eUnknown;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::~CImpersonationTokenCache
//
//  Synopsis:   Release the cached information.
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

CImpersonationTokenCache::~CImpersonationTokenCache()
{

    // Release the physical directory list elements
    for ( CPhyDirLogonInfo * pDirInfo = _phyDirList.Pop(); 0 != pDirInfo;
          pDirInfo = _phyDirList.Pop() )
    {
        pDirInfo->Close();
        delete pDirInfo;
    }

    delete [] _pwszComponentName;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::Find
//
//  Synopsis:   Locate impersonation information for the given path.
//
//  Arguments:  [pwszPath] -  Path for which impersonation information is
//              needed.
//
//  Returns:    A pointer to the impersonation if lookup is successful.
//              NULL otherwise.  The returned CPhyDirLogonInfo is AddRefed().
//
//  History:    4-02-96   srikants   Created
//
//              It is assumed that pwszPath is all Lower case.
//
//----------------------------------------------------------------------------

CPhyDirLogonInfo *
CImpersonationTokenCache::Find( WCHAR const * pwszPath, ULONG len )
{

    CPhyDirLogonInfo * pDirInfo = 0;

    // ====================================================
    CLock   lock(_mutex);
    //
    // Try to locate the path in the list
    //
    for ( CFwdPhyDirLogonIter  iter(_phyDirList); !_phyDirList.AtEnd(iter);
         _phyDirList.Advance(iter) )
    {

        if ( iter->IsInScope( pwszPath, len ) )
        {
            pDirInfo = iter.GetEntry();
            break;
        }
    }

    if ( pDirInfo )
    {
        pDirInfo->AddRef();
    }
    // ====================================================

    return pDirInfo;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::Find
//
//  Synopsis:   Finds a directory logon info for the given object after skipping
//              over the specified matched entries.
//
//  Arguments:  [info]  -  Information about the VPath and PhysPath and ip
//              address.
//              [cSkip] -  Number of matching entries to skip
//
//  Returns:
//
//  Modifies:
//
//  History:    7-12-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CPhyDirLogonInfo *
CImpersonationTokenCache::Find( CImprsObjInfo & info, ULONG cSkip )
{

    CPhyDirLogonInfo * pDirInfo = 0;
    ULONG cSkipped = 0;

    // ====================================================
    CLock   lock(_mutex);
    //
    // Try to locate the path in the list
    //
    for ( CFwdPhyDirLogonIter  iter(_phyDirList); !_phyDirList.AtEnd(iter);
         _phyDirList.Advance(iter) )
    {
        if ( iter->IsMatch( info ) )
        {
            if ( cSkipped == cSkip )
            {
                pDirInfo = iter.GetEntry();
                break;
            }
            cSkipped++;
        }
    }

    if ( pDirInfo )
    {
        pDirInfo->AddRef();
    }
    // ====================================================

    return pDirInfo;
}

CPhyDirLogonInfo *
CImpersonationTokenCache::_FindExact( CImprsObjInfo const & info )
{

    CPhyDirLogonInfo * pDirInfo = 0;

    // ====================================================
    CLock   lock(_mutex);
    //
    // Try to locate the path in the list
    //
    for ( CFwdPhyDirLogonIter  iter(_phyDirList); !_phyDirList.AtEnd(iter);
         _phyDirList.Advance(iter) )
    {

        if ( iter->IsSame( info ) )
        {
            pDirInfo = iter.GetEntry();
            break;
        }
    }

    if ( pDirInfo )
    {
        pDirInfo->AddRef();
    }
    // ====================================================

    return pDirInfo;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::_LokFindLogonEntry
//
//  Synopsis:   Looks up a logon entry for the given name and domain.
//
//  Arguments:  [pwszUser]   -
//              [pwszDomain] -
//
//  Returns:
//
//  History:    4-05-96   srikants   Created
//
//----------------------------------------------------------------------------

CLogonInfo *
CImpersonationTokenCache::_LokFindLogonEntry( WCHAR const * pwszUser,
                                              WCHAR const * pwszDomain )
{
    for ( CFwdLogonInfoIter iter(g_LogonList); !g_LogonList.AtEnd(iter);
          g_LogonList.Advance(iter) )
    {
        if ( iter->IsSameUser( pwszUser, pwszDomain ) )
            return iter.GetEntry();
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Class:      CParseAccount
//
//  Purpose:    A class to parse account of the form domain\username
//
//  History:    4-05-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

class CParseAccount
{
    enum { MAX_USER = UNLEN, MAX_DOMAIN = 100 };

public:

    CParseAccount( WCHAR const * pwszAccount );

    WCHAR const * GetUserName() const { return _wszUser; }
    WCHAR const * GetDomainName() const { return _wszDomain; }

    WCHAR * GetUserName()   { return _wszUser; }
    WCHAR * GetDomainName() { return _wszDomain; }

private:

    WCHAR       _wszUser[MAX_USER];
    WCHAR       _wszDomain[MAX_DOMAIN];
};

//+---------------------------------------------------------------------------
//
//  Member:     CParseAccount::CParseAccount
//
//  Synopsis:   Parses a string of form domain\username into domain and
//              username.
//
//  Arguments:  [pwszAccount] -
//
//  History:    4-03-96   srikants   Created
//
//----------------------------------------------------------------------------

CParseAccount::CParseAccount( WCHAR const * pwszAccount )
{
    _wszUser[0] = _wszDomain[0] = 0;

    if ( pwszAccount )
    {
        int len = wcslen(pwszAccount);
        //
        // Separate the domain\user into domain and user
        //
        for ( int i = len-1; i >= 0; i-- )
        {
            if ( L'\\' == pwszAccount[i] )
                break;
        }

        if ( i < 0 )
        {
            //
            // See if there is a forward slash. Some mistaken users specify the
            // userid like that.
            //
            for ( i = len-1; i >= 0; i-- )
            {
                if ( L'/' == pwszAccount[i] )
                    break;
            }
        }

        if ( i > 0 )
        {
            //
            // Copy the domain name
            //
            RtlCopyMemory( _wszDomain, pwszAccount, i * sizeof(WCHAR) );
            _wszDomain[i] = 0;

            //
            // Copy the user name.
            //
            RtlCopyMemory( _wszUser, pwszAccount+i+1, (len-i-1)*sizeof(WCHAR) );
            _wszUser[len-i-1] = 0;
        }
        else
        {
            //
            // No backslash was specified. The entire id is the username and
            // domain is NULL.
            //
            RtlCopyMemory( _wszUser, pwszAccount, len*sizeof(WCHAR) );
            _wszUser[len] = 0;
        }
    }
} //CParseAccount

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::_LokAddDirEntry
//
//  Synopsis:   Adds a new entry to the cache for the given account name.
//
//  Arguments:  [obj]          - The impersonation object info
//              [pwszAccount]  - Name of the account to use for logging on.
//
//  History:    4-03-96   srikants   Created
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::_LokAddDirEntry( CImprsObjInfo const & obj,
                                                WCHAR const * pwszAccount )
{
    //
    // Parse the account name into username and domain.
    //

    CParseAccount parse( pwszAccount );

    _fRemoteSharesPresent = TRUE;

    //
    // Look up the logon entry.
    //

    CLogonInfo * pLogonInfo = _LokFindLogonEntry( parse.GetUserName(),
                                                  parse.GetDomainName() );

    //
    // Create the dir entry and add it to the list of physical directories.
    //

    CPhyDirLogonInfo * pDirInfo = new CPhyDirLogonInfo( *this,
                                                        obj,
                                                        pLogonInfo );

    _phyDirList.Queue( pDirInfo );
} //_LokAddDirEntry

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::IsNetworkDrive
//
//  Synopsis:   Given a drive, check if it is a network drive.
//
//  Arguments:  [pwszPath]    - Path to check.
//
//  Returns:    TRUE if it is a network drive. FALSE o/w
//
//  History:    4-02-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonationTokenCache::IsNetworkDrive( WCHAR const * pwszPath )
{
    CPathParser parser( pwszPath );

    if ( parser.IsUNCName() )
        return TRUE;

    if ( parser.IsDrivePath() )
    {
        WCHAR wDriveLetter = pwszPath[0];

        unsigned iDrive = _GetDriveIndex( wDriveLetter );

        // ====================================================
        CLock   lock(_mutex);

        if ( eUnknown == _aDriveInfo[iDrive] )
        {
            UINT uType = GetDriveType( pwszPath );

            if ( DRIVE_REMOTE == uType )
                _aDriveInfo[iDrive] = eRemote;
            else
                _aDriveInfo[iDrive] = eLocal;
        }

        return eRemote == _aDriveInfo[iDrive];
        // ====================================================
    }
    else
    {
        //
        // If it is neither a UNC nor a drive letter, it is probably
        // a relative name.
        //
        return FALSE;
    }
} //IsNetworkDrive

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::_LokValidateOrAddDirEntry
//
//  Synopsis:   Validates the given path and account. If there is no entry for
//              the given path, a new one is added. If the current entry does
//              not match the given account info, the current one is zombified
//              and a new entry added.
//
//  Arguments:  [pwszPhyPath] - Physical path
//              [pwszAccount] - Account to use for accessing the physical path.
//
//  History:    4-05-96   srikants   Created
//
//----------------------------------------------------------------------------

void
CImpersonationTokenCache::_LokValidateOrAddDirEntry( CImprsObjInfo const & obj,
                                                     WCHAR const * pwszAccount )
{
    CPhyDirLogonInfo * pDirInfo = _FindExact( obj );

    if ( pDirInfo )
    {
        CParseAccount  account( pwszAccount );
        CLogonInfo * pLogonInfo = _LokFindLogonEntry( account.GetUserName(),
                                                      account.GetDomainName() );

        if ( pLogonInfo == pDirInfo->GetLogonInfo() )
        {
            // There is no change in logon information.
            Win4Assert( !pLogonInfo || !pLogonInfo->IsZombie() );
            Release(pDirInfo);
            return;
        }

        //
        // The logon information has changed for this directory.
        // So, we must zombify the current entry and create a new one.
        //
        _phyDirList.RemoveFromList( pDirInfo );
        pDirInfo->Close();
        pDirInfo->Zombify();
        Release( pDirInfo );

        pDirInfo = 0;
    }

    Win4Assert( 0 == pDirInfo );

    _LokAddDirEntry( obj, pwszAccount );
} //_LokValidateOrAddDirEntry

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::_LokValidateOrAddLogonEntry
//
//  Synopsis:   Validate the logon entry. If there is no logon entry for
//              the given account, add a new one. If the current one does not
//              match the given one, zombify the current one and replace it
//              with the new information.
//
//  Arguments:  [pwszUser]     - Username of the account
//              [pwszDomain]   - Domain of the account
//              [pwszPassword] - Password to use for logging this account/
//
//  History:    4-05-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD
CImpersonationTokenCache::_LokValidateOrAddLogonEntry(
                                WCHAR const * pwszUser,
                                WCHAR const * pwszDomain,
                                WCHAR const * pwszPassword )
{
    CLogonInfo * pLogonInfo = _LokFindLogonEntry( pwszUser, pwszDomain );
    if ( pLogonInfo )
    {
        if ( pLogonInfo->IsSamePassword( pwszPassword ) )
            return NO_ERROR;
        //
        // Invalidate the logon information.
        //
        g_LogonList.RemoveFromList( pLogonInfo );
        pLogonInfo->Close();
        pLogonInfo->Zombify();

        pLogonInfo->Addref();
        Release( pLogonInfo );

        pLogonInfo = 0;
    }

    Win4Assert( 0 == pLogonInfo );

    //
    // Create a new logon entry for the user and password.
    //
    pLogonInfo = new CLogonInfo;
    XPtr<CLogonInfo>    xLogonInfo(pLogonInfo);

    DWORD status = pLogonInfo->Logon( pwszUser, pwszDomain, pwszPassword );
    if ( 0 == status )
    {
        xLogonInfo.Acquire();
        g_LogonList.Push( pLogonInfo );
    }

    return status;
} //_LokValidateOrAddLogonEntry

//+---------------------------------------------------------------------------
//
//  Class:      CIISCallBackImp
//
//  Purpose:    Callback to parse IIS scopes and save impersonation
//              information for each.
//
//  History:    30-Oct-96   dlee      created
//
//----------------------------------------------------------------------------

class CIISCallBackImp : public CMetaDataCallBack
{
public:

    CIISCallBackImp( CImpersonationTokenCache & cache ) :
        _cache( cache )
    {
    }

    SCODE CallBack( WCHAR const * pwcVPath,
                    WCHAR const * pwcPPath,
                    BOOL          fIsIndexed,
                    DWORD         dwAccess,
                    WCHAR const * pwcUser,
                    WCHAR const * pwcPassword,
                    BOOL          fIsAVRoot )
    {
        ciDebugOut(( DEB_ITRACE,
                     "CIISCallBackImp checking c '%ws', vp '%ws', pp '%ws' i %d, u '%ws' pw '%ws', isavroot: %d\n",
                     _cache.GetCatalog(),
                     pwcVPath,
                     pwcPPath,
                     fIsIndexed,
                     pwcUser,
                     pwcPassword,
                     fIsAVRoot ));

        // If there's a vroot scope on a remote drive, a username, and a
        // password, save the token info.

        if ( ( fIsAVRoot ) &&
             ( fIsIndexed ) &&
             ( _cache.IsNetworkDrive( pwcPPath ) ) &&
             ( 0 != pwcUser[0] ) )
        {
            ciDebugOut(( DEB_ITRACE, "CIISCallBackImp adding\n" ));

            {
                CParseAccount parser( pwcUser );

                DWORD status =  _cache._LokValidateOrAddLogonEntry(
                                    parser.GetUserName(),
                                    parser.GetDomainName(),
                                    pwcPassword );
                if ( NO_ERROR != status )
                    _cache._WriteLogonFailure( pwcUser, status );
            }

            {
                // normalize both the physical and virtual paths
                // to lowercase

                CLowcaseBuf lcasePhyDir( pwcPPath );
                lcasePhyDir.AppendBackSlash();

                // vpaths in ci always have backslashes, not slashes

                unsigned cwc = wcslen( pwcVPath );
                if ( cwc >= MAX_PATH )
                    return S_OK;

                WCHAR awcVPath[ MAX_PATH ];
                for ( unsigned x = 0; x <= cwc; x++ )
                {
                    if ( L'/' == pwcVPath[x] )
                        awcVPath[ x ] = L'\\';
                    else
                        awcVPath[ x ] = pwcVPath[ x ];
                }

                CLowcaseBuf lcaseVPath( awcVPath );

                CImprsObjInfo info( lcasePhyDir.Get(),
                                    lcaseVPath.Get() );

                _cache._LokValidateOrAddDirEntry( info, pwcUser );
            }
        }

        return S_OK;
    }

private:
    CImpersonationTokenCache & _cache;
};

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::ReInitializeIISScopes
//
//  Synopsis:   ReInitialize the token cache for iis
//
//  History:    2-Sep-97   dlee       created
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::ReInitializeIISScopes(
    CIISVirtualDirectories * pW3Dirs,
    CIISVirtualDirectories * pNNTPDirs,
    CIISVirtualDirectories * pIMAPDirs )
{
    ciDebugOut(( DEB_ITRACE, "reinit iis impersonation fast\n" ));
    CLock lock( _mutex );

    Win4Assert( 0 != _pwszComponentName );

    CImpersonateSystem impersonate;

    if ( _fIndexW3Roots )
    {
        CIISCallBackImp callBack( *this );
        Win4Assert( 0 != pW3Dirs );
        pW3Dirs->Enum( callBack );
    }

    if ( _fIndexNNTPRoots )
    {
        CIISCallBackImp callBack( *this );
        Win4Assert( 0 != pNNTPDirs );
        pNNTPDirs->Enum( callBack );
    }

    if ( _fIndexIMAPRoots )
    {
        CIISCallBackImp callBack( *this );
        Win4Assert( 0 != pIMAPDirs );
        pIMAPDirs->Enum( callBack );
    }
    ciDebugOut(( DEB_ITRACE, "reinit iis impersonation fast (done)\n" ));
} //ReInitializeIISScopes

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::ReInitializeIISScopes
//
//  Synopsis:   ReInitialize the token cache for iis
//
//  History:    4-02-96   srikants   Created
//              2-12-97   dlee       Reimplemented for metabase
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::ReInitializeIISScopes()
{
    ciDebugOut(( DEB_ITRACE, "reinit iis impersonation slow\n" ));
    CLock lock( _mutex );

    Win4Assert( 0 != _pwszComponentName );

    CImpersonateSystem impersonate;

    if ( _fIndexW3Roots )
    {
        TRY
        {
            CIISVirtualDirectories dirs( W3VRoot );
            {
                CMetaDataMgr mdMgr( FALSE, W3VRoot, _W3SvcInstance );
                mdMgr.EnumVPaths( dirs );
            }

            CIISCallBackImp callBack( *this );
            dirs.Enum( callBack );
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_WARN,
                         "exception getting logon info for w3\n" ));
        }
        END_CATCH
    }

    //
    // If the news server is enabled, we have to read the news server
    // virtual roots and process them.
    //

    if ( _fIndexNNTPRoots )
    {
        TRY
        {
            CIISVirtualDirectories dirs( NNTPVRoot );
            {
                CMetaDataMgr mdMgr( FALSE, NNTPVRoot, _NNTPSvcInstance );
                mdMgr.EnumVPaths( dirs );
            }

            CIISCallBackImp callBack( *this );
            dirs.Enum( callBack );
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_WARN,
                         "exception getting logon info for nntp\n" ));
        }
        END_CATCH
    }

    if ( _fIndexIMAPRoots )
    {
        TRY
        {
            CIISVirtualDirectories dirs( IMAPVRoot );
            {
                CMetaDataMgr mdMgr( FALSE, IMAPVRoot, _IMAPSvcInstance );
                mdMgr.EnumVPaths( dirs );
            }

            CIISCallBackImp callBack( *this );
            dirs.Enum( callBack );
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_WARN,
                         "exception getting logon info for imap\n" ));
        }
        END_CATCH
    }
    ciDebugOut(( DEB_ITRACE, "reinit iis impersonation slow (done)\n" ));
} //ReInitializeIISScopes

//+---------------------------------------------------------------------------
//
//  Class:      CRegistryScopesCallBackImp
//
//  Purpose:    Callback to parse registry scopes and save impersonation
//              information for each.
//
//  History:    30-Oct-96   dlee      created
//
//----------------------------------------------------------------------------

class CRegistryScopesCallBackImp : public CRegCallBack
{
public:
    CRegistryScopesCallBackImp(
        CImpersonationTokenCache & cache ) :
        _cache( cache )
    {
    }

    NTSTATUS CallBack( WCHAR *pValueName, ULONG uValueType,
                       VOID *pValueData, ULONG uValueLength)
    {
        TRY
        {
            CParseRegistryScope parse( pValueName,
                                       uValueType,
                                       pValueData,
                                       uValueLength );

            ciDebugOut(( DEB_ITRACE,
                         "CRegistryScopesCallBackImp checking c '%ws', s '%ws' u '%ws' pw '%ws'\n",
                         _cache.GetCatalog(),
                         parse.GetScope(),
                         parse.GetUsername(),
                         parse.GetPassword( _cache.GetCatalog() ) ));

            // If there's a scope on a remote drive, a username, and a
            // password, save the token info.

            if ( ( 0 != parse.GetScope() ) &&
                 ( _cache.IsNetworkDrive( parse.GetScope() ) ) &&
                 ( 0 != parse.GetUsername() ) &&
                 ( 0 != parse.GetPassword( _cache.GetCatalog() ) ) )
            {
                ciDebugOut(( DEB_ITRACE, "CRegistryScopesCallBackImp adding\n" ));

                {
                    CParseAccount parser( parse.GetUsername() );

                    DWORD status =  _cache._LokValidateOrAddLogonEntry(
                                        parser.GetUserName(),
                                        parser.GetDomainName(),
                                        parse.GetPassword( _cache.GetCatalog() ) );
                    if ( NO_ERROR != status )
                        _cache._WriteLogonFailure( parse.GetUsername(), status );
                }

                {
                    CLowcaseBuf lcasePhyDir( parse.GetScope() );
                    lcasePhyDir.AppendBackSlash();

                    CImprsObjInfo info( lcasePhyDir.Get(), 0 );

                    _cache._LokValidateOrAddDirEntry( info, parse.GetUsername() );
                }
            }
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_ERROR,
                         "CRegistryScopesCallBackImp::CallBack caught error 0x%x\n",
                         e.GetErrorCode() ));
        }
        END_CATCH;

        return S_OK;
    }

private:
    CImpersonationTokenCache & _cache;
}; //CRegistryScopesCallBackImp

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::ReInitializeScopes
//
//  Synopsis:   ReInitialize the token cache for remote registry scopes
//
//  History:    10-24-96   dlee   Created
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::ReInitializeScopes()
{
    CLock lock( _mutex );

    Win4Assert( 0 != _pwszComponentName );

    // if the catalog isn't named, it can't have any scopes in the registry

    if ( 0 == _awcCatalogName[0] )
        return;

    CImpersonateSystem impersonate;

    TRY
    {
        XArray<WCHAR> xKey;
        BuildRegistryScopesKey( xKey, _awcCatalogName );
        ciDebugOut(( DEB_ITRACE, "Reading scope impinfo '%ws'\n", xKey.Get() ));
        CRegAccess regScopes( RTL_REGISTRY_ABSOLUTE, xKey.Get() );

        CRegistryScopesCallBackImp callback( *this );
        regScopes.EnumerateValues( 0, callback );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "Exception 0x%x caught groveling ci registry for impersonation info\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //ReInitializeScopes

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationTokenCache::_WriteLogonFailure
//
//  Synopsis:   Writes an event to the event log that a logon failure
//              occurred.
//
//  Arguments:  [pwszUser] - Id of the user
//              [dwError]  - Error
//
//  History:    5-24-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::_WriteLogonFailure( WCHAR const * pwszUser,
                                                   DWORD dwError )
{
    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );

        if ( ERROR_LOGON_TYPE_NOT_GRANTED != dwError )
        {
            CEventItem item( EVENTLOG_ERROR_TYPE,
                             CI_SERVICE_CATEGORY,
                             MSG_CI_REMOTE_LOGON_FAILURE,
                             3 );

            Win4Assert( 0 != _pwszComponentName );

            item.AddArg( _pwszComponentName );
            item.AddArg( pwszUser );
            item.AddError( dwError );
            eventLog.ReportEvent( item );
        }
        else
        {
            //
            // The specified user-id has no interactive logon privilege on
            // this machine.
            //
            CEventItem item( EVENTLOG_ERROR_TYPE,
                             CI_SERVICE_CATEGORY,
                             MSG_CI_NO_INTERACTIVE_LOGON_PRIVILEGE,
                             1 );

            item.AddArg( pwszUser );
            eventLog.ReportEvent( item );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
} //_WriteLogonFailure

//+---------------------------------------------------------------------------
//
//  Method:     CImpersonationTokenCache::Initialize
//
//  Synopsis:   Initializes the token cache.
//
//  History:    4-04-96   srikants   Created
//              10-22-96  dlee       global => member
//
//----------------------------------------------------------------------------

void CImpersonationTokenCache::Initialize(
    WCHAR const * pwszComponent,
    BOOL          fIndexW3Roots,
    BOOL          fIndexNNTPRoots,
    BOOL          fIndexIMAPRoots,
    ULONG         W3SvcInstance,
    ULONG         NNTPSvcInstance,
    ULONG         IMAPSvcInstance )
{
    Win4Assert( 0 == _pwszComponentName );
    unsigned len = wcslen( pwszComponent );
    _pwszComponentName = new WCHAR [len+1];
    RtlCopyMemory( _pwszComponentName, pwszComponent, (len+1)*sizeof(WCHAR) );

    _fIndexW3Roots = fIndexW3Roots;
    _fIndexNNTPRoots = fIndexNNTPRoots;
    _fIndexIMAPRoots = fIndexIMAPRoots;

    _W3SvcInstance = W3SvcInstance;
    _NNTPSvcInstance = NNTPSvcInstance;
    _IMAPSvcInstance = IMAPSvcInstance;

    if ( fIndexW3Roots || fIndexNNTPRoots || fIndexIMAPRoots )
        ReInitializeIISScopes();

    ReInitializeScopes();
} //Initialize

//+---------------------------------------------------------------------------
//
//  Member:     Constructor for CImpersonateRemoteAccess
//
//  History:    4-03-96   srikants   Created
//
//----------------------------------------------------------------------------

CImpersonateRemoteAccess::CImpersonateRemoteAccess(
    CImpersonationTokenCache * pCache ) :
    _pCache( pCache ),
    _pTokenInfo( 0 ),
    _hTokenPrev( INVALID_HANDLE_VALUE ),
    _fMustRevert( FALSE )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateRemoteAccess::_ImpersonateIf
//
//  Synopsis:   Impersonates if necessary for the given path.
//
//  Arguments:  [pwszPath] - Given path.
//
//  History:    4-03-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonateRemoteAccess::_ImpersonateIf( WCHAR const * pwszPath,
                                               WCHAR const * pwszVPath,
                                               ULONG cSkip )
{
    DWORD dwError = 0;

    if ( _pCache->IsNetworkDrive(pwszPath) )
    {
        //
        // If we have already impersonated for the given share, then nothing
        // to do.
        //

        CLowcaseBuf lcasePath( pwszPath );
        lcasePath.AppendBackSlash();

        //
        // It has been assumed that the VPath is already in lowercase and
        // the forward slashes are converted to back slashes.
        //
        CImprsObjInfo obj( lcasePath.Get(), pwszVPath );

        if ( IsImpersonated() )
        {
            Win4Assert( 0 != _pTokenInfo );
            if ( !_pTokenInfo->IsZombie() &&
                 _pTokenInfo->IsMatch(obj) )
            {
                ciDebugOut(( DEB_ITRACE, "Already impersonated for (%ws)\n",
                             lcasePath.Get() ));
                return TRUE;
            }
            else
            {
                Release();  // Release the current impersonation
            }
        }

        BOOL fSuccess = OpenThreadToken( GetCurrentThread(),
                                         TOKEN_QUERY | TOKEN_IMPERSONATE,
                                         TRUE,  // Access check against process
                                         &_hTokenPrev );

        if ( !fSuccess )
        {
            dwError = GetLastError();
            if ( ERROR_NO_TOKEN == dwError )
            {
                //
                // This thread is currently not impersonating anyone.
                //
            }
            else
            {
                ciDebugOut(( DEB_ERROR, "Failed to open thread token. Error %d\n",
                             dwError ));

                THROW( CException( HRESULT_FROM_WIN32(dwError)) );
            }
        }

        //
        // Get the impersonation information for the path.
        //
        _pTokenInfo = _pCache->Find( obj, cSkip );
        if ( 0 == _pTokenInfo )
        {
            ciDebugOut(( DEB_WARN, "There is no %simpersonation info for (%ws)\n",
                                    cSkip > 0 ? "more " : "",
                                    lcasePath.Get() ));
            return FALSE;
        }

        if ( INVALID_HANDLE_VALUE == _pTokenInfo->GetHandle() )
            return FALSE;

        //
        // Impersonate the specified user.
        //
        fSuccess = ImpersonateLoggedOnUser( _pTokenInfo->GetHandle() );
        if ( !fSuccess )
        {
            dwError = GetLastError();
            ciDebugOut(( DEB_WARN, "Error (%d) while impersonating for path (%ws)\n",
                                   dwError, pwszPath ));
            return FALSE;
        }

#if CIDBG == 1

        ciDebugOut(( DEB_ITRACE, "Impersonated successfully for (%ws)\n",
                     pwszPath ));

        CLogonInfo &li = *_pTokenInfo->GetLogonInfo();

        ciDebugOut(( DEB_ITRACE, "  using user %ws\\%ws, password %ws\n",
                     li.GetDomain(), li.GetUser(), li.GetPassword() ));

#endif

        _fMustRevert = TRUE;
    }

    return TRUE;
} //_ImpersonateIf

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateRemoteAccess::Release
//
//  Synopsis:   Releases the resources that were used for impersonation.
//
//  History:    4-04-96   srikants   Created
//
//----------------------------------------------------------------------------

void CImpersonateRemoteAccess::Release()
{
    DWORD   dwError = 0;

    if ( _fMustRevert )
    {
        if ( INVALID_HANDLE_VALUE != _hTokenPrev )
        {
            BOOL fResult = ImpersonateLoggedOnUser( _hTokenPrev );
            if ( !fResult )
            {
                dwError = GetLastError();
                ciDebugOut(( DEB_WARN, "ImpersonateLoggedOnUser failed with error %d\n",
                             dwError ));
            }
        }
        else
        {
            //
            // There was no impersonation token - just revert to self.
            //
            BOOL fResult = RevertToSelf();
            if ( !fResult )
            {
                dwError = GetLastError();
                ciDebugOut(( DEB_ERROR, "RevertToSelf failed with error %d\n",
                             dwError ));
            }
        }
    }

    if ( _pTokenInfo )
        _pCache->Release( _pTokenInfo );

    if ( INVALID_HANDLE_VALUE != _hTokenPrev )
        CloseHandle( _hTokenPrev );

    _fMustRevert = FALSE;
    _pTokenInfo = 0;
    _hTokenPrev = INVALID_HANDLE_VALUE;
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     PImpersonatedWorkItem::ImpersonateAndDoWork
//
//  Synopsis:   Calls the DoIt() virtual method after impersonating.
//
//  Arguments:  [access] -  The remote access object to use for impersonation.
//
//  History:    7-15-96   srikants   Created
//
//  Notes:      Calls the DoIt() method until it either returns TRUE or there
//              is an exception.
//
//----------------------------------------------------------------------------

void PImpersonatedWorkItem::ImpersonateAndDoWork(
                                CImpersonateRemoteAccess & access )
{
    ULONG cSkip = 0;

    if ( _fNetPath )
    {
        while ( TRUE )
        {

            BOOL fSuccess = access.ImpersonateIf( _pwszPath, cSkip, 0 );

            if ( !access.IsTokenFound() )
                THROW( CException( STATUS_LOGON_FAILURE ) );

            if ( fSuccess && DoIt() )
                break;

            cSkip++;
            access.Release();
        }
    }
    else
    {
        if ( access.IsImpersonated() )
        {
            //
            // Just revert back to what it was
            //
            access.Release();
        }

        DoIt();
    }
} //ImpersonateAndDoWork

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonatedGetAttr::DoIt
//
//  Synopsis:   Does the actual work of getting attributes.
//
//  Returns:    TRUE if successful; FALSE if should be retried; THROWS
//              otherwise.
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonatedGetAttr::DoIt()
{
    if ( !GetFileAttributesEx( _funnyPath.GetPath(), GetFileExInfoStandard, &_ffData ) )
    {
        DWORD dwError = GetLastError();
        if ( IsRetryableError( (NTSTATUS) dwError ) )
        {
            return FALSE;
        }
        else
        {
            ciDebugOut(( DEB_ERROR, "Error 0x%X while starting scan on path (%ws)\n",
                         dwError, _funnyPath.GetPath() ));
            THROW( CException( HRESULT_FROM_WIN32(dwError)) );
            return FALSE;
        }
    }
    else return TRUE;
} //DoIt

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonatedGetFileAttr::DoIt
//
//  Synopsis:   Does the actual work of getting attributes.
//
//  Returns:    TRUE if successful; FALSE if should be retried; THROWS
//              otherwise.
//
//  History:    12-05-01   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonatedGetFileAttr::DoIt()
{
    ULONG ulAttr = GetFileAttributes( _funnyPath.GetPath() );

    if ( INVALID_FILE_ATTRIBUTES == ulAttr )
    {
        DWORD dwError = GetLastError();

        if ( IsRetryableError( (NTSTATUS) dwError ) )
        {
            return FALSE;
        }

        ciDebugOut(( DEB_ERROR, "Error %#x while getting file attributes (%ws)\n",
                     dwError, _funnyPath.GetPath() ));
        THROW( CException( HRESULT_FROM_WIN32(dwError)) );
    }

    _ulAttr = ulAttr;

    return TRUE;
} //DoIt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\pershash.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       pershash.cxx
//
//  Contents:   Abstract class for persistent hash table
//
//  History:    07-May-97   SitaramR    Created from strings.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>
#include <cistore.hxx>
#include <propstor.hxx>
#include <propiter.hxx>

#include "pershash.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::CPersHash
//
//  Synopsis:   Constructor
//
//  Arguments:  [PropStore] -- Property store
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CPersHash::CPersHash(
    CPropStoreManager &PropStoreMgr,
    BOOL fAggressiveGrowth )
        : _PropStoreMgr   ( PropStoreMgr ),
          _fIsOpen( FALSE ),
          _hTable( fAggressiveGrowth ),
          _pStreamHash(0),
          _fAbort(FALSE),
          _fFullInit(FALSE),
          _fIsReadOnly(FALSE)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::~CPersHash
//
//  Synopsis:   Destructor
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CPersHash::~CPersHash()
{
    delete _pStreamHash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::FastInit
//
//  Synopsis:   Opens persistent wid hash
//
//  Arguments:  [pStorage]  -- CI storage
//              [version]   -- Content index version
//              [fIsFileIdMap] -- TRUE if the fileidmap, false if the strings
//                                table.
//
//  Returns:    TRUE if table was successfully opened
//
//  History:    07-May-97     SitaramR       Created
//              23-Feb-98     KitmanH        Initialized the value of
//                                           _fIsReadOnly with pStorage
//              27-Feb-98     KitmanH        If _fIsReadOnly, do part of long
//                                           init. i.e. init. hash table but
//                                           not mark dirty
//              13-Mar-98     KitmanH        new flag is added to determine
//                                           the type of hash stream to open
//                                           (fileidmap or strings) and open 
//                                           the CMmStream with the new methods 
//                                           QueryFileIdMap or QueryStringHash.
//
//----------------------------------------------------------------------------

BOOL CPersHash::FastInit( CiStorage * pStorage, ULONG version, BOOL fIsFileIdMap )
{
    _fIsReadOnly = pStorage->IsReadOnly();
     
    XPtr<PMmStream> xStrm;

    if ( fIsFileIdMap )
        xStrm.Set( pStorage->QueryFileIdMap() );
    else
        xStrm.Set( pStorage->QueryStringHash() );

    Win4Assert( 0 == _pStreamHash );
    _pStreamHash = new CDynStream( xStrm.GetPointer() );

    xStrm.Acquire();

    _pStreamHash->CheckVersion( *pStorage, version, _fIsReadOnly );

    _fIsOpen = TRUE;

    if (_fIsReadOnly)
    {
       ULONG htabSize = _pStreamHash->DataSize() / sizeof(WORKID);

       WORKID* table = (WORKID *) (_pStreamHash->Get() + sizeof(FILETIME));
       _hTable.Init( _pStreamHash->Count(), htabSize, table );

       _fFullInit = TRUE;
    }
    return TRUE;
} //FastInit

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::LongInit
//
//  Synopsis:   Initialization that may take a long time
//
//  Arguments:  [version]        -- CI version
//              [fDirtyShutdown] -- Set to TRUE if the previous shutdown
//                                  was dirty.
//
//  History:    07-May-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CPersHash::LongInit( ULONG version, BOOL fDirtyShutdown )
{
    if ( fDirtyShutdown || _pStreamHash->Version() != version || _pStreamHash->IsDirty() )
        ReInit( version );

    _pStreamHash->MarkDirty();

    ULONG htabSize = _pStreamHash->DataSize() / sizeof(WORKID);

    WORKID* table = (WORKID *) (_pStreamHash->Get() + sizeof(FILETIME));
    _hTable.Init ( _pStreamHash->Count(), htabSize, table );

    _fFullInit = TRUE;
} //LongInit

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::Empty
//
//  Synopsis:   Method to empty out any of the initialized members. This is
//              called if corruption is detected and all resources must
//              be released.
//
//  History:    07-May-97    SitaramR   Created
//
//----------------------------------------------------------------------------

void CPersHash::Empty()
{
    delete _pStreamHash;
    _pStreamHash = 0;
    _fIsOpen = FALSE;
    _fFullInit = FALSE;
} //Empty

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::Shutdown
//
//  Synopsis:   Shutdown processing
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------
void CPersHash::Shutdown()
{
    _fAbort = TRUE;

    if ( _fIsOpen && _fFullInit )
        LokFlush();
} //Shutdown

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::ReInit
//
//  Synopsis:   Clears out hash table
//
//  Arguments:  [version]   -- Content index version
//
//  Returns:    TRUE if table was successfully opened.
//
//  History:    07-May-97    SitaramR       Created.
//
//----------------------------------------------------------------------------

BOOL CPersHash::ReInit( ULONG version )
{
    ciDebugOut(( DEB_WARN, "Persistent hash file %s must be recreated\n",
                 _hTable.IsAggressiveGrowth() ? "strings" : "fileid" ));

    if ( !_pStreamHash->isWritable() )
        return FALSE;

    // Re-create stream.

    _pStreamHash->SetVersion( version );

    ciDebugOut(( DEB_ITRACE, "propstore max workid: %d\n",
                 _PropStoreMgr.MaxWorkId() ));

    // Re-hash the entries.  HashAll will determine the size of the stream

    HashAll();
    LokFlush();

    return TRUE;
} //ReInit

//+---------------------------------------------------------------------------
//
//  Member:     CPersHash::LokFlush
//
//  Synopsis:   Flush stream
//
//  History:    07-May-97    SitaramR      Created
//              03-Mar-98    KitmanH       Don't do anything if _fIsReadOnly
//                                         is set.
//
//----------------------------------------------------------------------------

void CPersHash::LokFlush ()
{
    if ( !_fIsReadOnly )
    {
       _pStreamHash->SetCount( _hTable.Count() );
       _pStreamHash->Flush();
    }
} //LokFlush

//+-------------------------------------------------------------------------
//
//  Member:     CPersHash::GrowHashTable
//
//  Synopsis:   Grow the persistent hash and rehash existing entries
//
//  History:    07-May-97    SitaramR     Created
//
//--------------------------------------------------------------------------

void CPersHash::GrowHashTable()
{
    Win4Assert ( _hTable.IsFull() );
    ciDebugOut ((DEB_CAT, "Growing persistent hash table\n" ));

    //
    // Invalidate on-disk version
    //
    _pStreamHash->SetCount(0);
    _pStreamHash->Flush();

    ULONG newSize = _hTable.GrowSize();
    PStorage* pStore = 0;
    _pStreamHash->Grow( *pStore, newSize * sizeof WORKID + sizeof FILETIME );
    _pStreamHash->SetDataSize( newSize * sizeof WORKID );

    _hTable.ReInit( 0, newSize,
                    (WORKID *) ( _pStreamHash->Get() + sizeof FILETIME ) );

    HashAll();

    LokFlush ();
} //GrowHashTable

//+-------------------------------------------------------------------------
//
//  Member:     CPersHash::GrowToSize
//
//  Synopsis:   Grow the persistent hash
//
//  History:    05-March-98    dlee     Created
//
//--------------------------------------------------------------------------

void CPersHash::GrowToSize( unsigned cElements )
{
    ciDebugOut ((DEB_CAT, "Growing persistent hash table\n" ));

    ULONG htabSize = _hTable.GrowSize( cElements );
    PStorage * pStore = 0;
    ULONG cbStream = htabSize * sizeof WORKID + sizeof FILETIME;
    _pStreamHash->Grow( *pStore, cbStream );
    _pStreamHash->Shrink( *pStore, cbStream );
    _pStreamHash->SetDataSize ( htabSize * sizeof WORKID );

    _hTable.ReInit( 0, htabSize,
                    (WORKID *) ( _pStreamHash->Get() + sizeof FILETIME ) );
} //GrowToSize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\notifmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       notifmgr.cxx
//
//  Contents:   Registry and file system change notifications
//
//  History:    14-Jul-97    SitaramR    Created from dlnotify.cxx
//
//  Notes  :    For lock hierarchy and order of acquiring locks, please see
//              cicat.cxx
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <cistore.hxx>
#include <rcstxact.hxx>
#include <imprsnat.hxx>
#include <eventlog.hxx>

#include <docstore.hxx>

#include "cicat.hxx"
#include "update.hxx"
#include "notifmgr.hxx"
#include "scanmgr.hxx"
#include "scopetbl.hxx"

BOOL AreIdenticalPaths( WCHAR const * pwcsPath1, WCHAR const * pwcsPath2 )
{
    ULONG len1 = wcslen( pwcsPath1 );
    ULONG len2 = wcslen( pwcsPath2 );

    return len1 == len2 &&
           RtlEqualMemory( pwcsPath1, pwcsPath2, len1*sizeof(WCHAR) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::CCiNotify
//
//  Synopsis:   Constructor of the single scope notification object CCiNotify.
//
//  Arguments:  [notifyMgr]  -- Notification manager.
//              [wcsScope]   -- Scope of the notification.
//              [cwcScope]   -- Length in chars of [wcsScope]
//              [volumeId]   -- Volume id
//              [ftlastScan] -- Last scan time
//              [usn]        -- Usn
//              [fDeep]      -- Set to TRUE if deep notifications are enabled.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

CCiNotify::CCiNotify( CCiNotifyMgr & notifyMgr,
                      WCHAR const * wcsScope,
                      unsigned cwcScope,
                      VOLUMEID volumeId,
                      ULONGLONG const & VolumeCreationTime,
                      ULONG VolumeSerialNumber,
                      FILETIME const & ftLastScan,
                      USN usn,
                      ULONGLONG const & JournalId,
                      BOOL fUsnTreeScan,
                      BOOL fDeep )
        : CGenericNotify( & notifyMgr.GetCatalog(), wcsScope, cwcScope, fDeep, TRUE ),
          _sigCiNotify(sigCiNotify),
          _notifyMgr(notifyMgr),
          _volumeId(volumeId),
          _VolumeCreationTime( VolumeCreationTime ),
          _VolumeSerialNumber( VolumeSerialNumber ),
          _fUsnTreeScan(fUsnTreeScan)
{
    if ( volumeId == CI_VOLID_USN_NOT_ENABLED )
        _ftLastScan = ftLastScan;
    else
    {
        _usn = usn;
        _JournalId = JournalId;
    }

    _notifyMgr.AddRef();

    XInterface<CCiNotifyMgr> xNotify( &notifyMgr );

    if ( volumeId == CI_VOLID_USN_NOT_ENABLED )
    {
        //
        // Enable file system notifications for non-usn volumes
        //
        EnableNotification();
    }

    xNotify.Acquire();
} //CCiNotify

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::~CCiNotify
//
//  Synopsis:   Destructor
//
//  History:    05-07-97   SitaramR   Added Header
//
//----------------------------------------------------------------------------

CCiNotify::~CCiNotify()
{
    _notifyMgr.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::Abort
//
//  Synopsis:   Marks that an abort is in progress. Also disables further
//              notifications for this scope.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotify::Abort()
{
    _fAbort = TRUE;

    if ( _volumeId == CI_VOLID_USN_NOT_ENABLED )
    {
        //
        // Notifications are enabled only for those volumes that
        // do not support usns.
        //
        DisableNotification();
    }
    else
    {
        //
        // Ctor of CGenericNotify does an AddRef, which is released by
        // the APC for non-usn volumes. For usn volumes do the Release here.
        //
        Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::IsMatch
//
//  Synopsis:   Checks if the given path is within the scope of the notifi-
//              cations. If deep notifications are enabled, it is sufficient
//              for the notification scope to be a subset of the given path.
//              Otherwise, there must be an exact match.
//
//  Arguments:  [wcsPath] - Path to be tested.
//              [len]     - Length of wcsPath.
//
//  Returns:    TRUE if there is a match. FALSE o/w
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiNotify::IsMatch( WCHAR const * wcsPath, ULONG len ) const
{

    CScopeMatch match( GetScope(), ScopeLength() );
    return match.IsInScope( wcsPath, len );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::QueryAsyncWorkItem
//
//  Synopsis:   Creates an async work item to process notifications.
//
//  Arguments:  [pbChanges] - Buffer of changes
//              [cbChanges] - Number of bytes in pbChanges
//              [pwcsRoot]  - The directory root where the change happened.
//
//  Returns:    A pointer to an async work item
//
//  History:    1-03-97   srikants   Moved from hxx file to use the new
//                                   CWorkManager.
//
//----------------------------------------------------------------------------


CCiAsyncProcessNotify * CCiNotifyMgr::QueryAsyncWorkItem(
    BYTE const * pbChanges,
    ULONG cbChanges,
    WCHAR const * pwcsRoot )
{
    XArray<BYTE>  xChanges( cbChanges );
    RtlCopyMemory( xChanges.GetPointer(), pbChanges, cbChanges );

    CWorkManager & workMan = _cicat.GetWorkMan();

    return new CCiAsyncProcessNotify( workMan,
                                      _cicat,
                                      _scanMgr,
                                      xChanges,
                                      pwcsRoot );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::DoIt()
//
//  Synopsis:   Called from APC.
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotify::DoIt()
{
    BOOL fNotifyReEnabled = FALSE;  // Indicates if the notification was reenabled
                                    // successfully
    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {

#if 0
        XPtr<CCiAsyncProcessNotify>  xWorker;
#endif  // 0

        if ( _fAbort )
            ciDebugOut(( DEB_ITRACE, "CiNotification APC: ABORT (IGNORE) 0x%x\n", this ));
        else
        {
            if ( !BufferOverflow() )
            {
                ciDebugOut(( DEB_ITRACE, "CiNotification APC: CHANGES 0x%x\n", this ));
#if 0
                xWorker.Set( _notifyMgr.QueryAsyncWorkItem( GetBuf(),
                                              BufLength(),
                                              GetScope()) );
#else
                _notifyMgr.ProcessChanges( GetBuf(),
                                           GetScope() );
#endif // 0
            }

            // ==================================================
            {
                //
                // Re-enable the notification for this scope.
                //
                CLock   lock(_notifyMgr.GetMutex());
                StartNotification(&status);
                fNotifyReEnabled = SUCCEEDED(status);
            }
            // ==================================================

            if ( BufferOverflow() )
                _notifyMgr.SetupScan( GetScope() );
        }

#if 0
        if ( 0 != xWorker.GetPointer() )
        {
            _notifyMgr.ProcessChanges( xWorker );
        }

#endif  // 0

    }
    CATCH(CException, e)
    {
        ciDebugOut(( DEB_ERROR, "CiNotification APC: CATCH 0x%x\n", e.GetErrorCode() ));
        status = e.GetErrorCode();
    }
    END_CATCH;

    if ( !_fAbort && !fNotifyReEnabled )
    {
        LogNotificationsFailed( status );

        CLock   lock( _notifyMgr.GetMutex() );
        LokClearNotifyEnabled();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotify::ClearNotifyEnabled
//
//  Synopsis:   Clears the flag to indicate that notifications are disabled
//              for this scope. This will permit periodic scanning of scopes
//              by the scan thread.
//
//  History:    5-03-96   srikants   Created
//
//  Notes:      The operation must be done under a lock.
//
//----------------------------------------------------------------------------

void CCiNotify::ClearNotifyEnabled()
{
    CLock   lock( _notifyMgr.GetMutex() );
    LokClearNotifyEnabled();
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootNotify::CVRootNotify, public
//
//  Synopsis:   Constructor for object to watch IIS vroot changes
//
//  Arguments:  [cat]       -- Catalog
//              [eType]     -- Type of vroot
//              [Instance]  -- Instance # of the vserver
//              [notifyMgr] -- Notify manager controller
//
//  History:    2-20-96   KyleP      Created
//
//----------------------------------------------------------------------------

CVRootNotify::CVRootNotify(
    CiCat &         cat,
    CiVRootTypeEnum eType,
    ULONG           Instance,
    CCiNotifyMgr &  notifyMgr )
        : _type( eType ),
          _cat( cat ),
          _notifyMgr( notifyMgr ),
          _mdMgr( FALSE, eType, Instance )
{
    _mdMgr.EnableVPathNotify( this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegistryScopesNotify::CRegistryScopesNotify
//
//  Synopsis:   Constructor for object to watch ci scopes
//
//  Arguments:  [cat] -- Catalog
//
//  History:    10-16-96   dlee      Created
//
//----------------------------------------------------------------------------

CRegistryScopesNotify::CRegistryScopesNotify(
    CiCat &        cat,
    CCiNotifyMgr & notifyMgr )
        : _cat( cat ),
          _notifyMgr( notifyMgr ),
          CRegNotify( cat.GetScopesKey() )
{
    _notifyMgr.AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiRegistryNotify::CCiRegistryNotify
//
//  Synopsis:   Constructor for the CCiRegistryNotify.
//
//  Arguments:  [cat]       -
//              [notifyMgr] -
//
//  History:    12-12-96   srikants   Created
//
//----------------------------------------------------------------------------

CCiRegistryNotify::CCiRegistryNotify(
    CiCat &        cat,
    CCiNotifyMgr & notifyMgr )
        : _cat( cat ),
          _notifyMgr( notifyMgr ),
          CRegNotify( wcsRegAdminTree )
{
    _notifyMgr.AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootNotify::DisableNotification, public
//
//  Synopsis:   Turns off notifications (if on )
//
//  History:    2-13-97   dlee      Created
//
//----------------------------------------------------------------------------

void CVRootNotify::DisableNotification()
{
    // Need TRY since RPC may access violate if iisadmin has gone down

    TRY
    {
        _mdMgr.DisableVPathNotify();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN,
                     "CVRootNotify::DisableNotification caught exception 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegistryScopesNotify::~CRegistryScopesNotify
//
//  Synopsis:   Destructor.
//
//  History:    10-16-96   dlee      Created
//
//----------------------------------------------------------------------------

CRegistryScopesNotify::~CRegistryScopesNotify()
{
    _notifyMgr.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiRegistryNotify::~CCiRegistryNotify
//
//  Synopsis:   Destructor
//
//  History:    12-12-96   srikants   Created
//
//----------------------------------------------------------------------------


CCiRegistryNotify::~CCiRegistryNotify()
{
    _notifyMgr.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CVRootNotify::CallBack, public
//
//  Synopsis:   Callback from metabase connection point
//
//  Arguments:  [fCancel] -- If TRUE, iisadmin is going down, so cancel
//                           notifications and poll for it to come back up.
//
//  History:    2-20-96   KyleP      Created
//              2-13-97   dlee       Updated for metabase
//
//----------------------------------------------------------------------------

SCODE CVRootNotify::CallBack( BOOL fCancel )
{
    if ( fCancel )
    {
        ciDebugOut(( DEB_WARN,
                     "Scheduling worker for '%ws' shutdown...\n",
                     GetVRootService( _type ) ));

        _notifyMgr.CancelIISVRootNotify( _type );

        // note: we may be deleted by now, don't access private data
    }
    else
    {
        ciDebugOut(( DEB_WARN,
                     "Scheduling worker thread for VRoot registry change...\n" ));

        CWorkManager & workMan = _cat.GetWorkMan();
        XInterface<CIISVRootAsyncNotify> xNotify(
            new CIISVRootAsyncNotify( _cat, workMan ) );

        workMan.AddToWorkList( xNotify.GetPointer() );
        xNotify->AddToWorkQueue();
    }

    return S_OK;
} //CallBack

//+---------------------------------------------------------------------------
//
//  Member:     CRegistryScopesNotify::DoIt, public
//
//  Synopsis:   Callback from APC
//
//  History:    10-16-96   dlee      Created
//
//----------------------------------------------------------------------------

void CRegistryScopesNotify::DoIt()
{
    ciDebugOut(( DEB_WARN,
                 "Scheduling worker thread for RegistryScopes registry change...\n" ));

    CWorkManager & workMan = _cat.GetWorkMan();

    CRegistryScopesAsyncNotify * pNotify = new CRegistryScopesAsyncNotify(_cat, workMan);
    workMan.AddToWorkList( pNotify );

    pNotify->AddToWorkQueue();
    pNotify->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiRegistryNotify::DoIt
//
//  Synopsis:   Refreshes the registry parameters
//
//  History:    12-12-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiRegistryNotify::DoIt()
{
    //
    // We don't need a worker thread to do this because it is very
    // quick and simple.
    //
    _cat.RefreshRegistryParams();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::CCiNotifyMgr
//
//  Synopsis:   ctor of the CI notification manager.
//
//  Arguments:  [cicat] - Catalog
//              [scanMgr] - Scan thread manager
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

CCiNotifyMgr::CCiNotifyMgr( CiCat & cicat, CCiScanMgr & scanMgr )
        : _cicat(cicat),
          _scanMgr(scanMgr),
          _nUpdates(0),
          _fAbort(FALSE),
          _evtType(eNone),
          _pRegistryScopesNotify(0),
          _fIISAdminAlive( TRUE ),
          _fTrackW3Svc( FALSE ),
          _fTrackNNTPSvc( FALSE ),
          _fTrackIMAPSvc( FALSE ),
          _W3SvcInstance( 1 ),
          _NNTPSvcInstance( 1 ),
          _IMAPSvcInstance( 1 ),
          _pCiRegistryNotify(0),
#pragma warning( disable : 4355 )      // this used in base initialization
          _thrNotify( NotifyThread, this, TRUE )  // create suspended
#pragma warning( default : 4355 )
{
    _evt.Reset();

    RtlZeroMemory( &_ftLastNetPathScan, sizeof(_ftLastNetPathScan) );

    _thrNotify.SetPriority( THREAD_PRIORITY_ABOVE_NORMAL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::~CCiNotifyMgr
//
//  Synopsis:   dtor of the CI notification manager.
//
//  History:    17 Dec 1997  AlanW    Created
//
//----------------------------------------------------------------------------

CCiNotifyMgr::~CCiNotifyMgr( )
{
    // Be sure the thread will die...
    if (_thrNotify.IsRunning())
        _KillThread();
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::TrackIISVRoots
//
//  Synopsis:   Registers for notification of VRoot registry changes
//
//  Arguments:  [fTrackW3Svc]     -- TRUE if W3 should be tracked
//              [W3SvcInstance]   -- W3 instance # to be tracked.
//              [fTrackNNTPSvc]   -- TRUE if NNTP should be tracked
//              [NNTPSvcInstance] -- NNTP instance # to be tracked.
//              [fTrackIMAPSvc]   -- TRUE if IMAP should be tracked
//              [IMAPSvcInstance] -- IMAP instance # to be tracked.
//
//  History:    2-21-96   KyleP      Created
//              2-13-97   dlee       converted to metabase
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::TrackIISVRoots(
    BOOL  fTrackW3Svc,
    ULONG W3SvcInstance,
    BOOL  fTrackNNTPSvc,
    ULONG NNTPSvcInstance,
    BOOL  fTrackIMAPSvc,
    ULONG IMAPSvcInstance )
{
    CLock   lock(_mutex);
    Win4Assert( _xW3SvcVRootNotify.IsNull() );
    Win4Assert( _xNNTPSvcVRootNotify.IsNull() );
    Win4Assert( _xIMAPSvcVRootNotify.IsNull() );

    _fTrackW3Svc = fTrackW3Svc;
    _W3SvcInstance = W3SvcInstance;
    _fTrackNNTPSvc = fTrackNNTPSvc;
    _NNTPSvcInstance = NNTPSvcInstance;
    _fTrackIMAPSvc = fTrackIMAPSvc;
    _IMAPSvcInstance = IMAPSvcInstance;

    _evtType |= eWatchIISVRoots;
    _evt.Set();
} //TrackIISVRoots

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::TrackScopesInRegistry
//
//  Synopsis:   Registers for notification of scope registry changes
//
//  History:    10/17/96    dlee      Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::TrackScopesInRegistry()
{
    CLock   lock(_mutex);
    Win4Assert( 0 == _pRegistryScopesNotify );

    _evtType |= eWatchRegistryScopes;
    _evt.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::TrackCiRegistry
//
//  Synopsis:   Registers for notifications of CI registry changes.
//
//  History:    12-12-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::TrackCiRegistry()
{
    CLock   lock(_mutex);
    Win4Assert( 0 == _pCiRegistryNotify );

    _evtType |= eWatchCiRegistry;
    _evt.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::CancelIISVRootNotify
//
//  Synopsis:   Cancels notifications on iisadmin since it's going down
//
//  History:    2-13-97   dlee       Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::CancelIISVRootNotify( CiVRootTypeEnum eType )
{
    // after this, we'll poll for the iisadmin svc to start again

    CLock lock( _mutex );

    if ( W3VRoot == eType )
        _evtType |= eUnWatchW3VRoots;
    else if ( NNTPVRoot == eType )
        _evtType |= eUnWatchNNTPVRoots;
    else if ( IMAPVRoot == eType )
        _evtType |= eUnWatchIMAPVRoots;
    else
    {
        Win4Assert( !"invalid IIS vroot notify type!" );
    }

    _evt.Set();
} //CancelIISVRootNotify

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::LokUnWatchIISVServerNoThrow
//
//  Synopsis:   Turns off notifications on W3, NNTP, or IMAP
//
//  History:    2-Sep-97   dlee       created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::LokUnWatchIISVServerNoThrow(
    CVRootNotify * pNotify )
{
    ciDebugOut(( DEB_WARN, "LokUnWatchIISVServer\n" ));

    TRY
    {
        delete pNotify;
    }
    CATCH(CException, e)
    {
        _fIISAdminAlive = FALSE;
        ciDebugOut(( DEB_WARN,
                     "caught exception while tearing down IIS tracking\n" ));
    }
    END_CATCH;
} //LokUnWatchIISVServerNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::LokWatchIISVServerNoThrow
//
//  Synopsis:   Registers for notification of IIS VRoot changes
//
//  History:    2-21-96   KyleP      Created
//              2-13-97   dlee       converted to metabase
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::LokWatchIISVServerNoThrow()
{
    ciDebugOut(( DEB_WARN,
                 "LokWatchIISVServer w3 %d:%d, nntp %d:%d, imap %d:%d\n",
                 _fTrackW3Svc,
                 _W3SvcInstance,
                 _fTrackNNTPSvc,
                 _NNTPSvcInstance,
                 _fTrackIMAPSvc,
                 _IMAPSvcInstance ));

    Win4Assert( _fTrackW3Svc || _fTrackNNTPSvc || _fTrackIMAPSvc );

    BOOL fWasAlive = _fIISAdminAlive;

    // Assume iisadmin is alive and we can get notifications

    _fIISAdminAlive = TRUE;

    TRY
    {
        if ( _fTrackW3Svc && _xW3SvcVRootNotify.IsNull() )
            _xW3SvcVRootNotify.Set( new CVRootNotify( _cicat,
                                                      W3VRoot,
                                                      _W3SvcInstance,
                                                      *this ) );

        if ( _fTrackNNTPSvc  && _xNNTPSvcVRootNotify.IsNull() )
            _xNNTPSvcVRootNotify.Set( new CVRootNotify( _cicat,
                                                        NNTPVRoot,
                                                        _NNTPSvcInstance,
                                                        *this ) );

        if ( _fTrackIMAPSvc  && _xIMAPSvcVRootNotify.IsNull() )
            _xIMAPSvcVRootNotify.Set( new CVRootNotify( _cicat,
                                                        IMAPVRoot,
                                                        _IMAPSvcInstance,
                                                        *this ) );
    }
    CATCH(CException, e)
    {
        _fIISAdminAlive = FALSE;
        ciDebugOut(( DEB_WARN,
                     "caught exception while setting up iis tracking\n" ));
    }
    END_CATCH;

    // did we miss notifications but can catch up now?

    if ( !fWasAlive && _fIISAdminAlive )
    {
        TRY
        {
            ciDebugOut(( DEB_WARN, "Polling IIS: iisadmin woke up\n" ));

            CWorkManager & workMan = _cicat.GetWorkMan();

            XInterface<CIISVRootAsyncNotify> xNotify(
                new CIISVRootAsyncNotify( _cicat, workMan ) );

            workMan.AddToWorkList( xNotify.GetPointer() );
            xNotify->AddToWorkQueue();
        }
        CATCH(CException, e)
        {
            ciDebugOut(( DEB_WARN,
                        "caught exception while setting up iis enumeration\n" ));

            // try again after the timeout

            _fIISAdminAlive = FALSE;
        }
        END_CATCH;
    }
} //LokWatchIISVServerNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::LokWatchRegistryScopesNoThrow
//
//  Synopsis:   Registers for notification of RegistryScopes registry changes
//
//  History:    2-21-96   KyleP      Created
//
//  Notes:      This must be done from thread waiting in alertable mode
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::LokWatchRegistryScopesNoThrow()
{
    TRY
    {
        Win4Assert( 0 == _pRegistryScopesNotify );
        _pRegistryScopesNotify = new CRegistryScopesNotify( _cicat, *this );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN, "_LokWatchRegistryScopesNoThrow caught 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //LokWatchRegistryScopesNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::LokWatchCiRegistryNoThrow
//
//  Synopsis:   Watches for changes in CI registry.
//
//  History:    12-12-96   srikants   Created
//
//----------------------------------------------------------------------------


void CCiNotifyMgr::LokWatchCiRegistryNoThrow()
{
    TRY
    {
        Win4Assert( 0 == _pCiRegistryNotify );
        _pCiRegistryNotify = new CCiRegistryNotify( _cicat, *this );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN, "_LokWatchCiRegistryNoThrow caught 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //LokWatchCiRegistryNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::_KillThread
//
//  Synopsis:   Asks the notification thread to die and waits for its death.
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::_KillThread()
{
    {
        CLock   lock(_mutex);
        _evtType |= eKillThread;
        _evt.Set();
    }

    ciDebugOut(( DEB_ITRACE, "Waiting for death of notify thread\n" ));
    _thrNotify.WaitForDeath();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::Shutdown
//
//  Synopsis:   Shut down notification thread.
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::WaitForShutdown()
{
    //
    // If we never started running, then just bail out.
    //

    if ( _thrNotify.IsRunning() )
    {
        //
        // must wait until all the APCs are aborted.
        //
        _refCount.Wait();

        //
        // Kill the notification thread.
        //
        _KillThread();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::InitiateShutdown
//
//  Synopsis:   Turns off notifications
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::InitiateShutdown()
{
    {
        CLock   lock(_mutex);
        _fAbort = TRUE;
    }

    //
    // Abort registry notification (if any)
    //

    if ( !_xW3SvcVRootNotify.IsNull() )
    {
        _xW3SvcVRootNotify->DisableNotification();
        _xW3SvcVRootNotify.Free();
    }

    if ( !_xNNTPSvcVRootNotify.IsNull() )
    {
        _xNNTPSvcVRootNotify->DisableNotification();
        _xNNTPSvcVRootNotify.Free();
    }

    if ( !_xIMAPSvcVRootNotify.IsNull() )
    {
        _xIMAPSvcVRootNotify->DisableNotification();
        _xIMAPSvcVRootNotify.Free();
    }

    // these are refcounted and needn't be freed

    if ( 0 != _pRegistryScopesNotify )
        _pRegistryScopesNotify->DisableNotification();

    if ( 0 != _pCiRegistryNotify )
        _pCiRegistryNotify->DisableNotification();

    //
    // Abort all the notifications and the APCs queued for that.
    //
    {
        CLock   lock(_mutex);

        for ( CCiNotify * pNotify = _list.Pop();
              0 != pNotify;
              pNotify = _list.Pop() )
        {
            pNotify->Close();
            pNotify->Abort();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::_LokTellThreadToAddScope
//
//  Synopsis:   Sets the event type to add a scope for notifications and
//              wakes up the notification thread.
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::_LokTellThreadToAddScope()
{
    if ( 0 == (eKillThread & _evtType) )
    {
        _evtType |= eAddScopes;
        _evt.Set();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::AddPath
//
//  Synopsis:   Adds a scope for ci notifications. If the given scope (wcsScope)
//              is a superset of any existing scopes, they are removed from
//              the notification list.
//
//  Arguments:  [wcsScope]          -  Scope to be added.
//              [fSubscopesRemoved] -  Set to TRUE if sub-scopes of wcsScope
//                                     were removed as a result of adding wcsScope.
//              [volumeId]          -  Volume id
//              [ftLastScan]        -  Last scan time
//              [usn]               -  Usn
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::AddPath( CScopeInfo const & scopeInfo, BOOL & fSubscopesRemoved )
{
    fSubscopesRemoved = FALSE;

    //
    // Allocate storage for the string and terminate it with the
    // backslash character.
    //

    ULONG len = wcslen( scopeInfo.GetPath() );
    if ( L'\\' != scopeInfo.GetPath()[len-1] )
        len++;

    Win4Assert( len < MAX_PATH );

    XArray<WCHAR> xPath(len+1);
    WCHAR * pwcsPath = xPath.Get();

    wcscpy( pwcsPath, scopeInfo.GetPath() );
    pwcsPath[len-1] = L'\\';
    pwcsPath[len] = 0;

    CLock   lock(_mutex);

    //
    // First see if notifications are already enabled on this path
    // in some other scope.
    //

    for ( CFwdCiNotifyIter iter1(_list); !_list.AtEnd(iter1); _list.Advance(iter1) )
    {
        if (iter1->IsMatch( pwcsPath, len ) )
        {
            Win4Assert( iter1->VolumeId() == scopeInfo.VolumeId() );

            //
            // there is an entry for this scope already. Just enable/start
            // the notification if not already done so.
            //
            if ( iter1->VolumeId() == CI_VOLID_USN_NOT_ENABLED )
                iter1->LokEnableIf();

            return;
        }
    }

    //
    // We have to create a new notification object for this scope.
    //

    XPtr<CScopeInfo> xScopeInfo;

    if ( CI_VOLID_USN_NOT_ENABLED == scopeInfo.VolumeId() )
        xScopeInfo.Set( new CScopeInfo( xPath,
                                        scopeInfo.VolumeCreationTime(),
                                        scopeInfo.VolumeSerialNumber(),
                                        scopeInfo.GetLastScanTime() ) );
    else
        xScopeInfo.Set( new CScopeInfo( xPath,
                                        scopeInfo.VolumeCreationTime(),
                                        scopeInfo.VolumeSerialNumber(),
                                        scopeInfo.VolumeId(),
                                        scopeInfo.Usn(),
                                        scopeInfo.JournalId(),
                                        scopeInfo.FUsnTreeScan() ) );

    _stkScopes.Push( xScopeInfo.GetPointer() );
    xScopeInfo.Acquire();

    //
    // If the new path is going to be a superset of the existing paths,
    // they must be removed.
    //
    CScopeMatch superScope( pwcsPath, len );

    for ( CFwdCiNotifyIter iter2(_list); !_list.AtEnd(iter2);  )
    {
        CCiNotify * pNotify = iter2.GetEntry();
        _list.Advance(iter2);

        //
        // See if the current node is a subset of the new path.
        // If so, remove the current node from the list.
        //
        if ( superScope.IsInScope( pNotify->GetScope(), pNotify->ScopeLength()) )
        {
            fSubscopesRemoved = TRUE;
            pNotify->LokRemove();
        }
    }

    //
    // Wake up the notification thread to add this scope.
    //
    _LokTellThreadToAddScope();
} //AddPath

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::GetLastScanTime
//
//  Synopsis:   Gets the time of the last successful scan for the given scope.
//
//  Arguments:  [wcsScope] - Scope to check. If there is no entry for the
//              given scope, the time of the last successful scan of the
//              super scope of wcsScope will be returned.
//              [ft]       - The filetime of the last successful scan
//              encompassing the given scope.
//
//  Returns:    TRUE if found; FALSE o/w. In case FALSE is returned, ft will
//              be zero filled.
//
//  History:    4-19-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiNotifyMgr::GetLastScanTime( WCHAR const * wcsScope, FILETIME & ft )
{

    RtlZeroMemory( &ft, sizeof(FILETIME) );
    Win4Assert( 0 != wcsScope );

    ULONG len = wcslen( wcsScope );
    Win4Assert( L'\\' == wcsScope[len-1] );

    CLock   lock(_mutex);

    //
    // Look for a scope which encompasses the given scope.
    //

    for ( CFwdCiNotifyIter iter1(_list); !_list.AtEnd(iter1); _list.Advance(iter1) )
    {
        if (iter1->IsMatch( wcsScope, len ) )
        {
            ft = iter1->GetLastScanTime();
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::UpdateLastScanTimes
//
//  Synopsis:   Updates the last scan time of all the paths that have
//              notifications enabled to the time given.
//
//  Arguments:  [ft] - Last successful scan time (all updates until this time
//                     are known for all the scopes with notifications enabled).
//              [usnFlushInfoList] - Usn info list
//
//  History:    4-21-96   srikants   Created
//             05-07-97   SitaramR   Usns
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::UpdateLastScanTimes( FILETIME const & ft,
                                        CUsnFlushInfoList & usnFlushInfoList )
{
    CLock   lock(_mutex);

    for ( CFwdCiNotifyIter iter1(_list); !_list.AtEnd(iter1); _list.Advance(iter1) )
    {
        if ( iter1->LokIsNotifyEnabled() && iter1->VolumeId() == CI_VOLID_USN_NOT_ENABLED )
        {
            if ( ft.dwLowDateTime != 0 || ft.dwHighDateTime != 0 )
                iter1->SetLastScanTime( ft );
        }
        else if ( iter1->VolumeId() != CI_VOLID_USN_NOT_ENABLED
                  && !iter1->FUsnTreeScan() )
        {
            //
            // If an usn tree traversal is going on, then we shouldn't move the usn
            // watermark because if there is a crash now, then we should
            // restart the usn tree traversal from usn 0.
            //

            USN usnCurrent = usnFlushInfoList.GetUsn( iter1->VolumeId() );

            ciDebugOut(( DEB_ITRACE,
                         "CCiNotifyMgr::UpdateLastScanTimes drive %wc, old %#I64x, current %#I64x\n",
                         (WCHAR) iter1->VolumeId(),
                         iter1->Usn(),
                         usnCurrent ));

            if ( usnCurrent != 0 && usnCurrent > iter1->Usn() )
            {
                //
                // Win4Assert( usnCurrent >= iter1->Usn() );
                //
                // We cannot assert the above because after the initial usn tree
                // scan is done, the maxUsn is written to iter1 (CiCat::SetUsnTreeComplete),
                // and there can be usn notifications prior to usn tree scan, i.e. there can
                // be usn's less than maxUsn.
                //

                iter1->SetUsn( usnCurrent );
            }
        }
    }
} //UpdateLastScanTimes

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::ForceNetPathScansIf
//
//  Synopsis:   Forces the scan of network paths with no notifications if
//              the interval for such scans has expired.
//
//  History:    4-21-96   srikants   Created
//
//  Notes:      If the remote machine is running networking software without
//              notifications, we have to periodically scan for changes. This
//              method identifies such paths and schedules scans for them if
//              the minimum interval has expired since the last such scan.
//
//              THIS METHOD MUST BE CALLED ONLY FROM THE SCAN THREAD. IT IS
//              CALLED WHEN THE SCAN THREAD HAS DETECTED THAT THERE ARE NO
//              OUTSTANDING SCANS AND SO IS A GOOD TIME TO SCAN NET PATHS.
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::ForceNetPathScansIf()
{
    CLock   lock(_mutex);

    Win4Assert( sizeof(FILETIME) == sizeof(LONGLONG) );

    LONGLONG ftZero;
    RtlZeroMemory( &ftZero, sizeof(ftZero) );

    LONGLONG ftNow;
    GetSystemTimeAsFileTime( (FILETIME *) &ftNow );

    if ( 0 == CompareFileTime( (FILETIME *) &_ftLastNetPathScan,
                               (FILETIME *) &ftZero ) )
    {
        //
        // We havent't yet started tracking the interval. Just initialize
        // the _ftLastNetPathScan to the current time.
        //
        _ftLastNetPathScan = ftNow;
        return;
    }

    if ( ftNow < _ftLastNetPathScan )
    {
        ciDebugOut(( DEB_WARN, "Time has been set back\n" ));
        _ftLastNetPathScan = ftNow;
        return;
    }

    //
    // See if the interval for force scans has exceeded.
    //
    //
    // Compute the interval in 100 nanosecond interval
    //
    const LONGLONG llInterval =
        _cicat.GetRegParams()->GetForcedNetPathScanInterval() * 60 * 1000 * 10000;

    if ( ftNow - _ftLastNetPathScan >= llInterval )
    {
        ciDebugOut(( DEB_ITRACE, "Forcing scan of net paths with no notifcations\n" ));
        _LokForceScanNetPaths();

        //
        // Reset the last scan time for network paths.
        //
        RtlZeroMemory( &_ftLastNetPathScan, sizeof(_ftLastNetPathScan) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::_LokForceScanNetPaths
//
//  Synopsis:   Forces incremental scans of net paths with no notifications.
//
//  History:    4-21-96   srikants   Created
//
//  Notes:      This method must be called only in the context of the scan
//              thread.
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::_LokForceScanNetPaths()
{
    for ( CFwdCiNotifyIter iter1(_list); !_list.AtEnd(iter1); _list.Advance(iter1) )
    {
        if ( !iter1->LokIsNotifyEnabled() && iter1->VolumeId() == CI_VOLID_USN_NOT_ENABLED )
        {
            //
            // Usn paths have their notifications disabled, but they should not be scanned
            //
            ciDebugOut(( DEB_WARN,
                         "Forcing an incremental scan of path (%ws)\n",
                         iter1->GetScope() ));
            _cicat.ReScanPath( iter1->GetScope(), FALSE );
        }
    }
} //_LokForceScanNetPaths

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::_LokAddScopesNoThrow
//
//  Synopsis:   Takes scopes from the stack and enables notifications for
//              those scopes.
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::_LokAddScopesNoThrow()
{
    TRY
    {
        for ( unsigned i = 0; i < _stkScopes.Count(); i++ )
        {
            CScopeInfo & scopeInfo = *_stkScopes.Get(i);

            if ( !scopeInfo.IsValid() )
                continue;

            WCHAR const * pwcsPath = scopeInfo.GetPath();

            CCiNotify * pNotify = new CCiNotify( *this,
                                                 pwcsPath,
                                                 wcslen(pwcsPath),
                                                 scopeInfo.VolumeId(),
                                                 scopeInfo.VolumeCreationTime(),
                                                 scopeInfo.VolumeSerialNumber(),
                                                 scopeInfo.GetLastScanTime(),
                                                 scopeInfo.Usn(),
                                                 scopeInfo.JournalId(),
                                                 scopeInfo.FUsnTreeScan() );

            //
            // Acquire the path as a sign that we shouldn't try to use it
            // again to add another notification object.
            //

            delete [] scopeInfo.AcquirePath();

            _list.Push( pNotify );
        }

        // empty the stack now

        while ( _stkScopes.Count() > 0 )
        {
            _stkScopes.DeleteTop();
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_WARN, "_LokAddScopesNoThrow caught 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
} //_LokAddScopesNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::_DoNotifications
//
//  Synopsis:   The thread which is responsible for adding notification scopes
//              and processing the notifications. The notification APC will
//              execute in this thread's context.
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::_DoNotifications()
{
    while ( TRUE )
    {
        //
        // Don't do any work until the system has booted
        //

        while ( GetTickCount() < _cicat.GetRegParams()->GetStartupDelay() )
        {
            Sleep( 200 );
            if ( _fAbort )
                break;
        }

        BOOL fWait = FALSE;

        CVRootNotify * pW3Notify = 0;
        CVRootNotify * pNNTPNotify = 0;
        CVRootNotify * pIMAPNotify = 0;

        // ++++++++++++++++ lock obtained +++++++++++++++++++
        {
            CLock   lock(_mutex);
            _evt.Reset();

            Win4Assert( 0 == ( _evtType &
                  ~(eKillThread|eAddScopes|eWatchIISVRoots|
                    eWatchRegistryScopes|eWatchCiRegistry|eUnWatchW3VRoots|
                    eUnWatchNNTPVRoots|eUnWatchIMAPVRoots)) );

            if ( eKillThread & _evtType )
                return;

            if ( _fAbort )
            {
                _evtType = eNone;
            }
            else
            {
                if ( eAddScopes & _evtType )
                {
                    _LokAddScopesNoThrow();
                    _evtType &= ~eAddScopes;
                }

                if ( eWatchIISVRoots & _evtType )
                {
                    LokWatchIISVServerNoThrow();
                    _evtType &= ~eWatchIISVRoots;
                }

                if ( eUnWatchW3VRoots & _evtType )
                {
                    pW3Notify = _xW3SvcVRootNotify.Acquire();
                    _evtType &= ~eUnWatchW3VRoots;
                }

                if ( eUnWatchNNTPVRoots & _evtType )
                {
                    pNNTPNotify = _xNNTPSvcVRootNotify.Acquire();
                    _evtType &= ~eUnWatchNNTPVRoots;
                }

                if ( eUnWatchIMAPVRoots & _evtType )
                {
                    pIMAPNotify = _xIMAPSvcVRootNotify.Acquire();
                    _evtType &= ~eUnWatchIMAPVRoots;
                }

                if ( eWatchRegistryScopes & _evtType )
                {
                    LokWatchRegistryScopesNoThrow();
                    _evtType &= ~eWatchRegistryScopes;
                }

                if ( eWatchCiRegistry & _evtType )
                {
                    LokWatchCiRegistryNoThrow();
                    _evtType &= ~eWatchCiRegistry;
                }
            }

            fWait = ( eNone == _evtType );
        }
        // ---------------- lock released --------------------

        //
        // Free these without holding the lock to avoid a deadlock
        // with iisadmin.
        //

        if ( 0 != pW3Notify )
            LokUnWatchIISVServerNoThrow( pW3Notify );

        if ( 0 != pNNTPNotify )
            LokUnWatchIISVServerNoThrow( pNNTPNotify );

        if ( 0 != pIMAPNotify )
            LokUnWatchIISVServerNoThrow( pIMAPNotify );

        //
        // If we're not watching, turn the flag off
        //

        if ( _xW3SvcVRootNotify.IsNull() &&
             _xNNTPSvcVRootNotify.IsNull() &&
             _xIMAPSvcVRootNotify.IsNull() )
            _fIISAdminAlive = FALSE;

        if ( fWait )
        {
            const DWORD dwFiveMinutes = 1000 * 60 * 5;

            DWORD dwWait = ( ( !_fIISAdminAlive ) &&
                             ( _fTrackW3Svc || _fTrackNNTPSvc || _fTrackIMAPSvc ) ) ?
                           dwFiveMinutes : INFINITE;

            // TRUE: important to get APCs

            ULONG res = _evt.Wait( dwWait, TRUE );

            if ( WAIT_TIMEOUT == res )
            {
                // try again to talk to the iisadmin svc

                CLock lock( _mutex );
                _evtType |= eWatchIISVRoots;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::NotifyThread
//
//  Arguments:  [self] -
//
//  History:    1-18-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD CCiNotifyMgr::NotifyThread( void * self )
{
    SCODE sc = CoInitializeEx( 0, COINIT_MULTITHREADED );

    ((CCiNotifyMgr *) self)->_DoNotifications();

    CoUninitialize();

    ciDebugOut(( DEB_ITRACE, "Terminating notify thread\n" ));

    //
    // This is only necessary if thread is terminated from DLL_PROCESS_DETACH.
    //
    //TerminateThread( ((CCiNotifyMgr *) self)->_thrNotify.GetHandle(), 0 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::ProcessChanges
//
//  Synopsis:   Processes the changes to files.
//
//  Arguments:  [changes] -
//
//  History:    1-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::ProcessChanges( XPtr<CCiAsyncProcessNotify> & xWorker )
{
    CWorkManager & workMan = _cicat.GetWorkMan();

    workMan.AddToWorkList( xWorker.GetPointer() );
    CCiAsyncProcessNotify   *pAsyncNotify = xWorker.Acquire();

#if 0
    //
    // NTRAID#DB-NTBUG9-83784-2000/07/31-dlee FAT notifications don't use APCs -- they are handled by the notification thread
    // There is a problem with lockups in NT. Until we figure
    // that out, don't use worker threads. Just process the notifications
    // in-line in the notification thread.
    //
    pAsyncNotify->AddToWorkQueue();
#else
    pAsyncNotify->DoIt( 0 );
#endif

    pAsyncNotify->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::ProcessChanges
//
//  Synopsis:
//
//  Arguments:  [pbChanges] -
//              [wcsScope]  -
//
//  Returns:
//
//  Modifies:
//
//  History:    3-07-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::ProcessChanges( BYTE const * pbChanges,
                                   WCHAR const * wcsScope )
{

    CCiSyncProcessNotify  notify(_cicat, _scanMgr, pbChanges, wcsScope, _fAbort );
    notify.DoIt();
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::SetupScan
//
//  Synopsis:   Schedules the given path for background scan in the scan
//              thread.
//
//  Arguments:  [pwcsPath] -  The path to be scanned.
//
//  History:    1-19-96   srikants   Created
//
//  Notes:      This method is invoked when the notification buffer overflowed
//              and hence some updates are lost. A rescan is needed to figure
//              out the changed documents.
//
//----------------------------------------------------------------------------

void CCiNotifyMgr::SetupScan( WCHAR const * pwcsPath )
{
    _cicat.ReScanPath( pwcsPath, TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::IsInScope
//
//  Synopsis:   Tests if the given scope is already in the list of scopes
//              being watched for notifications.
//
//  Arguments:  [pwcsPath] - Input path to check.
//
//  Returns:    TRUE if the path is already in a notification scope.
//              FALSE o/w
//
//  History:    1-21-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiNotifyMgr::IsInScope( WCHAR const * pwcsPath )
{
    Win4Assert( 0 != pwcsPath );
    ULONG len = wcslen( pwcsPath );

    CLock   lock(_mutex);

    //
    // First check if it is in the list of paths to be added.
    //
    for ( unsigned i = 0;
          i < _stkScopes.Count();
          i++ )
    {
        if ( !_stkScopes.Get(i)->IsValid() )
            continue;

        WCHAR const * pwcsTmp = _stkScopes.Get(i)->GetPath();

        CScopeMatch match( pwcsTmp, wcslen( pwcsTmp ) );
        if ( match.IsInScope( pwcsPath, len ) )
            return TRUE;
    }

    // next check in the list of notifications
    for ( CFwdCiNotifyIter iter(_list); !_list.AtEnd(iter); _list.Advance(iter) )
    {
        if ( iter->IsMatch( pwcsPath, len ) )
            return TRUE;
    }

    return FALSE;
} //IsInScope

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyMgr::RemoveScope
//
//  Synopsis:   If there is an exact match for the given scope, it will be
//              removed from the notification list.
//
//  Arguments:  [pwcsPath] - The scope to be removed.
//
//  Returns:    TRUE if the scope was found.
//              FALSE if it was not found.
//
//  History:    1-25-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiNotifyMgr::RemoveScope( WCHAR const * pwcsPath )
{
    Win4Assert( 0 != pwcsPath );
    ULONG len = wcslen( pwcsPath );

    CLock   lock(_mutex);

    BOOL fFound = FALSE;

    //
    // First see if there is a match in the list of paths still
    // to be added.
    //
    for ( unsigned i = 0; i < _stkScopes.Count(); i++ )
    {
        CScopeInfo & scopeInfo = *_stkScopes.Get(i);
        if ( !scopeInfo.IsValid() )
            continue;

        if ( AreIdenticalPaths( pwcsPath, scopeInfo.GetPath() ) )
        {
            scopeInfo.Invalidate();
            fFound = TRUE;
        }
    }

    //
    // Next remove from the list of notifications.
    //
    for ( CFwdCiNotifyIter iter(_list); !_list.AtEnd(iter);  )
    {
        CCiNotify * pNotify = iter.GetEntry();
        _list.Advance(iter);

        if ( AreIdenticalPaths(pwcsPath, pNotify->GetScope()) )
        {
            ciDebugOut(( DEB_ITRACE,
                "Removing path (%ws) from notification list\n",
                pNotify->GetScope() ));
            pNotify->LokRemove();
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyIter::SetTreeScanComplete, public
//
//  Synopsis:   Mark a scope as scanned.  Used to update volume version info.
//
//  History:    13-Apr-1998  KyleP  Created
//
//----------------------------------------------------------------------------

void CCiNotifyIter::SetTreeScanComplete()
{
    Win4Assert( !AtEnd() );

    ULONGLONG const & VolumeCreationTime = _notifyMgr._cicat.GetVolumeCreationTime( Get() );
    ULONG             VolumeSerialNumber = _notifyMgr._cicat.GetVolumeSerialNumber( Get() );

    if ( _iNotAdded < _stack.Count() )
        _stack.Get(_iNotAdded)->SetVolumeInfo( VolumeCreationTime, VolumeSerialNumber );
    else
        _iter->SetVolumeInfo( VolumeCreationTime, VolumeSerialNumber );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiNotifyIter::SetUsnTreeScanComplete, public
//
//  Synopsis:   Same as SetTreeScanComplete, but also updates USN info.
//
//  Arguments:  [usnMax] -- New high-water mark.
//
//  History:    13-Apr-1998  KyleP  Created
//
//----------------------------------------------------------------------------

void CCiNotifyIter::SetUsnTreeScanComplete( USN usnMax )
{
    Win4Assert( !AtEnd() );

    ULONGLONG const & JournalId          = _notifyMgr._cicat.GetJournalId( Get() );
    ULONGLONG const & VolumeCreationTime = _notifyMgr._cicat.GetVolumeCreationTime( Get() );
    ULONG             VolumeSerialNumber = _notifyMgr._cicat.GetVolumeSerialNumber( Get() );

    if ( _iNotAdded < _stack.Count() )
    {
        _stack.Get(_iNotAdded)->SetUsnTreeScanComplete( usnMax );
        _stack.Get(_iNotAdded)->SetVolumeInfo( VolumeCreationTime, VolumeSerialNumber );
        _stack.Get(_iNotAdded)->SetJournalId( JournalId );
    }
    else
    {
        _iter->SetUsnTreeScanComplete( usnMax );
        _iter->SetVolumeInfo( VolumeCreationTime, VolumeSerialNumber );
        _iter->SetJournalId( JournalId );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\scopetbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       scopetbl.cxx
//
//  Contents:   Persistent scope table
//
//  History:    14-Jul-97   SitaramR   Created from dlnotify.cxx
//
//  Notes  :    For lock hierarchy and order of acquiring locks, please see
//              cicat.cxx
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <cistore.hxx>
#include <rcstxact.hxx>
#include <imprsnat.hxx>
#include <eventlog.hxx>

#include <docstore.hxx>

#include "cicat.hxx"
#include "update.hxx"
#include "notifmgr.hxx"
#include "scanmgr.hxx"
#include "scopetbl.hxx"

//
// Local constants
//

WCHAR const wcVirtualShadow    = L'3';   // 3   --> Virtual, Indexed
WCHAR const wcsVirtualShadow[] = L",,3"; // ,,3 --> No UNC alias, Virtual, Indexed

//+---------------------------------------------------------------------------
//
//  Method:     DeleteIfShadow, private
//
//  Synopsis:   Deletes shadow scope registry entry
//
//  Arguments:  [pwcsScope] -- Scope to delete
//              [hkey]      -- Registry key to catalog
//
//  History:    15-May-97   KyleP   Created
//
//  Notes:      Only deletes exact matches (as stored by system)
//
//----------------------------------------------------------------------------

void DeleteIfShadow( WCHAR const * pwcsScope, HKEY hkey )
{
    //
    // See if this is a shadow entry (flags == 2)
    //

    WCHAR wcsData[MAX_PATH];

    DWORD dwType;
    DWORD dwSize = sizeof(wcsData);

    DWORD dwError = RegQueryValueEx( hkey,            // Key handle
                                     pwcsScope,       // Name
                                     0,               // Reserved
                                     &dwType,         // Datatype
                                     (BYTE *)wcsData, // Data returned here
                                     &dwSize );       // Size of data

    if ( ERROR_SUCCESS == dwError &&
         REG_SZ == dwType &&
         dwSize >= 8 &&                               // 8 --> ,,#<null>
         wcVirtualShadow == wcsData[dwSize/sizeof(WCHAR) - 2] )
    {
        dwError = RegDeleteValue( hkey, pwcsScope );

        if ( ERROR_SUCCESS != dwError ) {
            ciDebugOut(( DEB_ERROR, "Error %d deleting %ws\n", dwError, pwcsScope ));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     AddShadow, private
//
//  Synopsis:   Adds shadow scope registry entry
//
//  Arguments:  [pwcsScope] -- Scope to add
//              [hkey]      -- Registry key to catalog
//
//  History:    15-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

void AddShadow( WCHAR const * pwcsScope, HKEY hkey )
{
    //
    // Build string: NAME: ,,3
    //

    DWORD dwError = RegSetValueEx( hkey,                       // Key
                                   pwcsScope,                  // Value name
                                   0,                          // Reserved
                                   REG_SZ,                     // Type
                                   (BYTE *)wcsVirtualShadow,   // Data
                                   sizeof(wcsVirtualShadow) ); // Size (in bytes)

    if ( ERROR_SUCCESS != dwError ) {
        ciDebugOut(( DEB_ERROR, "Error %d writing %ws\n", dwError, pwcsScope ));
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     RefreshIfShadow, private
//
//  Synopsis:   Refresh shadow scope registry entry (if blank)
//
//  Arguments:  [pwcsScope] -- Scope to refresh
//              [hkey]      -- Registry key to catalog
//
//  History:    11-Oct-97   KyleP   Created
//
//  Notes:      Only refresh blank (missing) entries
//
//----------------------------------------------------------------------------

void RefreshIfShadow( WCHAR const * pwcsScope, HKEY hkey )
{
    //
    // See if this is a missing entry
    //

    WCHAR wcsData[MAX_PATH];

    DWORD dwType;
    DWORD dwSize = sizeof(wcsData);

    DWORD dwError = RegQueryValueEx( hkey,            // Key handle
                                     pwcsScope,       // Name
                                     0,               // Reserved
                                     &dwType,         // Datatype
                                     (BYTE *)wcsData, // Data returned here
                                     &dwSize );       // Size of data

    //
    // It is, so we should re-add it.
    //

    if ( ERROR_FILE_NOT_FOUND == dwError )
        AddShadow( pwcsScope, hkey );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::~CCiScopeTable
//
//  Synopsis:   ~dtor of the persistent scope table.
//
//  History:    1-21-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCiScopeTable::~CCiScopeTable()
{
    delete _pTable;
}

void CCiScopeTable::_FatalCorruption()
{
    PStorage & storage = _cicat.GetStorage();
    Win4Assert( !"Corrupt scope table" );
    storage.ReportCorruptComponent( L"ScopeTable1" );

    THROW( CException( CI_CORRUPT_CATALOG ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::Empty
//
//  Synopsis:   Empties out the in-memory contents of the scope table for
//              a later re-init.
//
//  History:    3-21-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::Empty()
{
    delete _pTable; _pTable = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::FastInit
//
//  Synopsis:   Quickly initializes the scope table.
//
//  History:    3-21-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::FastInit()
{
    CiStorage * pStorage = (CiStorage *) &_cicat.GetStorage();
    Win4Assert( 0 != pStorage );

    _pTable = pStorage->QueryScopeList(0);

    CRcovStorageHdr & storageHdr = _pTable->GetHeader();

    //
    // read the last scan time.
    //
    storageHdr.GetUserHdr( storageHdr.GetPrimary(), _usrHdr );
    if ( !_hdr.IsInitialized() )
        _hdr.Initialize();

    if ( _hdr.IsFullScanNeeded() )
        _state = eFullScanNeeded;
} //FastInit

//+---------------------------------------------------------------------------
//
//  Class:      CNullAdvise
//
//  Purpose:    Null implementation of ICiCAdviseStatus, for use in opening
//              a CiStorage when advise isn't needed.
//
//  History:    4-6-99   dlee   Created
//
//----------------------------------------------------------------------------

class CNullAdvise : public ICiCAdviseStatus
{
public:
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppiuk ) { return E_NOINTERFACE; }


    STDMETHOD_(ULONG, AddRef) () { return 1; }

    STDMETHOD_(ULONG, Release)() { return 0; }

    STDMETHOD(SetPerfCounterValue)( CI_PERF_COUNTER_NAME name,
                                    long value ) { return S_OK; }

    STDMETHOD(IncrementPerfCounterValue)( CI_PERF_COUNTER_NAME name ) { return S_OK; }

    STDMETHOD(DecrementPerfCounterValue)( CI_PERF_COUNTER_NAME name ) { return S_OK; }

    STDMETHOD(GetPerfCounterValue)( CI_PERF_COUNTER_NAME name,
                                    long * pValue ) { return S_OK; }

    STDMETHOD(NotifyEvent)( WORD  fType,
                            DWORD eventId,
                            ULONG nParams,
                            const PROPVARIANT *aParams,
                            ULONG cbData = 0,
                            void* data   = 0) { return S_OK; }

    STDMETHOD(NotifyStatus)( CI_NOTIFY_STATUS_VALUE status,
                             ULONG nParams,
                             const PROPVARIANT *aParams ) { return S_OK; }
};

//+---------------------------------------------------------------------------
//
//  Function:   GetDriveLetterOfAnyScope
//
//  Synopsis:   Returns the drive letter of the first scope in the catalog or
//              0 on error
//
//  History:    4-6-99   dlee   Created
//
//----------------------------------------------------------------------------

WCHAR GetDriveLetterOfAnyScope( WCHAR const * pwcCatalog )
{
    TRY
    {
        CNullAdvise adviseStatus;
        CiStorage store( pwcCatalog,
                         adviseStatus,
                         0,
                         FSCI_VERSION_STAMP,
                         TRUE );
    
        XPtr<PRcovStorageObj> xTable( store.QueryScopeList( 0 ) );
        CRcovStorageHdr & hdr = xTable->GetHeader();
        ULONG cPaths = hdr.GetCount( hdr.GetPrimary() );
    
        if ( 0 == cPaths )
            return 0;
    
        // read the last scan start time for the scope
    
        CRcovStrmReadTrans xact( xTable.GetReference() );
        xact.Seek(0);
    
        LONGLONG llSig;
        ULONG cbRead = xact.Read( &llSig, sizeof(llSig) );
        if ( cbRead != sizeof(llSig) )
            return 0;
    
        if ( eSigCiScopeTable != llSig )
            return 0;
    
        //
        // Get Volume ID
        //
    
        VOLUMEID volumeId;
        cbRead = xact.Read( &volumeId, sizeof(VOLUMEID) );
        if ( cbRead != sizeof(VOLUMEID) )
            return 0;
    
        //
        // And Volume Creation Time
        //
    
        ULONGLONG VolumeCreationTime = 0;
        cbRead = xact.Read( &VolumeCreationTime, sizeof(VolumeCreationTime) );
        if ( cbRead != sizeof(VolumeCreationTime) )
            return 0;
    
        //
        // And Volume Serial Number
        //
    
        ULONG VolumeSerialNumber = 0;
        cbRead = xact.Read( &VolumeSerialNumber, sizeof(VolumeSerialNumber) );
        if ( cbRead != sizeof(VolumeSerialNumber) )
            return 0;
    
        //
        // Filesystem-Specific stuff.
        //
    
        if ( CI_VOLID_USN_NOT_ENABLED == volumeId )
        {
            //
            // Read filetime for non-usn volumes
            //
            FILETIME ft;
            cbRead = xact.Read( &ft, sizeof(FILETIME) );
            if ( cbRead != sizeof(FILETIME) )
                return 0;
        }
        else
        {
            //
            // Read usn for usn volumes
            //
    
            USN usn;
            cbRead = xact.Read( &usn, sizeof(USN) );
            if ( cbRead != sizeof(USN) )
                return 0;
    
            //
            // And Journal ID
            //
    
            ULONGLONG JournalId = 0;
            cbRead = xact.Read( &JournalId, sizeof(JournalId) );
            if ( cbRead != sizeof(JournalId) )
                return 0;
        }
    
        ULONG cchPath;
        cbRead = xact.Read( &cchPath, sizeof(ULONG) );
        if ( cbRead != sizeof(ULONG) )
            return 0;
    
        if ( 0 == cchPath || cchPath > MAX_PATH )
            return 0;
    
        WCHAR   wcsPath[MAX_PATH+1];
        cbRead = xact.Read( wcsPath, cchPath*sizeof(WCHAR) );
        if ( cchPath*sizeof(WCHAR) != cbRead )
            return 0;
    
        return wcsPath[0];
    }
    CATCH( CException, e )
    {
        // ignore failure -- just fall out returning 0
    }
    END_CATCH;

    return 0;
} //GetDriveOfFirstScope

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::_DeSerialize
//
//  Synopsis:   Reads the scopes from the persistent scope table and adds
//              them to the stack.
//
//  Arguments:  [stk] - (out) - Will have all the paths from the table.
//
//  History:    30-Jan-96   srikants   Created
//              07-May-97   SitaramR   Usns
//              11-Mar-98   KyleP      USN Journal ID
//
//----------------------------------------------------------------------------

void CCiScopeTable::_DeSerialize( CScopeInfoStack & stk )
{
    Win4Assert( 0 != _pTable );

    if ( 0 == _pTable )
        _FatalCorruption();

    CImpersonateSystem impersonate;
    CLock   lock(_mutex);

    CRcovStorageHdr & hdr = _pTable->GetHeader();

    //
    // read the last scan time.
    //

    ULONG nPaths = hdr.GetCount( hdr.GetPrimary() );

    ciDebugOut(( DEB_ITRACE, "CCiScopeTable::_DeSerialize nPaths: %d\n", nPaths ));

    if ( nPaths == 0 )
        return;

    // We have to iterate over the paths and add them to our list
    //
    WCHAR   wcsPath[MAX_PATH+1];
    CRcovStrmReadTrans xact( *_pTable );
    xact.Seek(0);


    XPtr<CScopeInfo>    xScopeInfo;

    for ( ULONG i = 0; i < nPaths; i++ )
    {
        VOLUMEID volumeId;
        FILETIME ft;
        USN usn;
        ULONGLONG JournalId = 0;
        ULONGLONG VolumeCreationTime = 0;
        ULONG VolumeSerialNumber = 0;

        LONGLONG llSig;

        // read the last scan start time for the scope
        ULONG cbRead;

        cbRead = xact.Read( &llSig, sizeof(llSig) );
        if ( cbRead != sizeof(llSig) )
        {
            ciDebugOut(( DEB_ERROR,
                "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                cbRead, sizeof(llSig) ));
            _FatalCorruption();
        }

        if ( eSigCiScopeTable != llSig )
        {
            ciDebugOut(( DEB_ERROR,
                         "CCiScopeTable::_DeSerialize - Signature mismatch 0x%X:0x%X\n",
                         lltoLowPart( llSig ), lltoHighPart( llSig ) ));
            _FatalCorruption();
        }

        //
        // Get Volume ID
        //

        cbRead = xact.Read( &volumeId, sizeof(VOLUMEID) );
        if ( cbRead != sizeof(VOLUMEID) )
        {
            ciDebugOut(( DEB_ERROR,
                         "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                         cbRead,
                         sizeof(VOLUMEID) ));
            _FatalCorruption();
        }

        //
        // And Volume Creation Time
        //

        cbRead = xact.Read( &VolumeCreationTime, sizeof(VolumeCreationTime) );
        if ( cbRead != sizeof(VolumeCreationTime) )
        {
            ciDebugOut(( DEB_ERROR,
                         "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                         cbRead,
                         sizeof(VolumeCreationTime) ));
            _FatalCorruption();
        }

        //
        // And Volume Serial Number
        //

        cbRead = xact.Read( &VolumeSerialNumber, sizeof(VolumeSerialNumber) );
        if ( cbRead != sizeof(VolumeSerialNumber) )
        {
            ciDebugOut(( DEB_ERROR,
                         "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                         cbRead,
                         sizeof(VolumeSerialNumber) ));
            _FatalCorruption();
        }

        //
        // Filesystem-Specific stuff.
        //

        if ( CI_VOLID_USN_NOT_ENABLED == volumeId )
        {
            //
            // Read filetime for non-usn volumes
            //
            cbRead = xact.Read( &ft, sizeof(FILETIME) );
            if ( cbRead != sizeof(FILETIME) )
            {
                ciDebugOut(( DEB_ERROR,
                             "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                             cbRead, sizeof(FILETIME) ));
                _FatalCorruption();
            }
        }
        else
        {
            //
            // Read usn for usn volumes
            //
            cbRead = xact.Read( &usn, sizeof(USN) );
            if ( cbRead != sizeof(USN) )
            {
                ciDebugOut(( DEB_ERROR,
                             "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                             cbRead,
                             sizeof(USN) ));
                _FatalCorruption();
            }

            //
            // And Journal ID
            //

            cbRead = xact.Read( &JournalId, sizeof(JournalId) );
            if ( cbRead != sizeof(JournalId) )
            {
                ciDebugOut(( DEB_ERROR,
                             "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                             cbRead,
                             sizeof(JournalId) ));
                _FatalCorruption();
            }
        }

        ULONG cchPath;
        cbRead = xact.Read( &cchPath, sizeof(ULONG) );
        if ( cbRead != sizeof(ULONG) )
        {
            ciDebugOut(( DEB_ERROR,
                "CCiScopeTable::_DeSerialize - Read %d bytes instead of %d \n",
                cbRead, sizeof(ULONG) ));
            _FatalCorruption();
        }

        if ( 0 == cchPath || cchPath > MAX_PATH )
        {
            ciDebugOut(( DEB_ERROR,
                "CCiScopeTable::_DeSerialize - Illegal path length %d\n", cchPath ));
            _FatalCorruption();
        }

        cbRead = xact.Read( wcsPath, cchPath*sizeof(WCHAR) );
        if ( cchPath*sizeof(WCHAR) != cbRead )
        {
            ciDebugOut(( DEB_ERROR,
                "CCiScopeTable::_DeSerialize - Requested %d bytes. Read %d bytes\n",
                cchPath*sizeof(WCHAR), cbRead ));
            _FatalCorruption();
        }

        cchPath--;   // includes the length of the terminating 0
        if ( 0 != wcsPath[cchPath] || L'\\' != wcsPath[cchPath-1] )
        {
            ciDebugOut(( DEB_ERROR,
                "CCiScopeTable::_DeSerialize - Illegaly formed path %ws \n", wcsPath ));
            _FatalCorruption();
        }


        if ( CI_VOLID_USN_NOT_ENABLED == volumeId )
            xScopeInfo.Set( new CScopeInfo( wcsPath,
                                            VolumeCreationTime,
                                            VolumeSerialNumber,
                                            ft ) );
        else
            xScopeInfo.Set( new CScopeInfo( wcsPath,
                                            VolumeCreationTime,
                                            VolumeSerialNumber,
                                            volumeId,
                                            usn,
                                            JournalId,
                                            (0 == usn) ) );

        stk.Push( xScopeInfo.GetPointer() ); // Push can throw
        xScopeInfo.Acquire();
    }
} //_DeSerialize

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::_Serialize
//
//  Synopsis:   Writes the given stack of scopes to the persistent table.
//
//  Arguments:  [stk] -  Stack of scopes to write.
//
//  History:    1-30-96        srikants   Created
//              28-Jul-1996    AlanW      Allow for invalid scopes, e.g., when
//                                        one is removed in middle of stack
//              05-May-1997    SitaramR   Usns
//
//----------------------------------------------------------------------------

void CCiScopeTable::_Serialize( CScopeInfoStack const & stk )
{
    if ( 0 == _pTable )
    {
        _FatalCorruption();
    }

    CLock   lock(_mutex);

    CRcovStorageHdr & hdr = _pTable->GetHeader();
    CRcovStrmWriteTrans     xact( *_pTable );

    xact.Empty();

    ULONG nPaths = 0;
    FILETIME ft;
    RtlZeroMemory( &ft, sizeof(ft) );
    LONGLONG llSig = eSigCiScopeTable;  // Signature for corruption detection

    for ( unsigned i = 0; i < stk.Count(); i++ )
    {
        CScopeInfo & scopeInfo = *stk.Get(i);
        if ( !scopeInfo.IsValid() )
            continue;

        WCHAR const * pwszScope = scopeInfo.GetPath();

        ULONG cchPath = wcslen( pwszScope ) + 1;
        Win4Assert( cchPath <= MAX_PATH );

#if CIDBG == 1
        if ( wcschr( pwszScope, L'~' ) )
        {
            // Possible shortnames in scope path.  We must only use long names.
            CLowerFunnyPath lowerFunnyPath( pwszScope );

            if ( lowerFunnyPath.IsShortPath( ) )
            {
                ciDebugOut(( DEB_WARN,
                     "CCiScopeTable::_Seiralize: possible shortname path %ws\n",
                             lowerFunnyPath.GetActualPath() ));
            }
        }
#endif // CIDBG == 1

        xact.Append( &llSig, sizeof(llSig) );

        VOLUMEID volumeId = scopeInfo.VolumeId();
        xact.Append( &volumeId, sizeof(VOLUMEID) );

        ULONGLONG const & VolumeCreationTime = scopeInfo.VolumeCreationTime();
        xact.Append( &VolumeCreationTime, sizeof(VolumeCreationTime) );

        ULONG VolumeSerialNumber = scopeInfo.VolumeSerialNumber();
        xact.Append( &VolumeSerialNumber, sizeof(VolumeSerialNumber) );

        if ( scopeInfo.VolumeId() == CI_VOLID_USN_NOT_ENABLED )
        {
            //
            // Write filetime for non-usn volumes
            //
            ft = scopeInfo.GetLastScanTime();
            xact.Append( &ft, sizeof(ft) );
        }
        else
        {
            //
            // Write usn for usn volumes
            //
            USN usn = scopeInfo.Usn();
            xact.Append( &usn, sizeof(USN) );

            ULONGLONG JournalId = scopeInfo.JournalId();
            xact.Append( &JournalId, sizeof(JournalId) );
        }

        xact.Append( &cchPath, sizeof(cchPath) );
        xact.Append( pwszScope, cchPath*sizeof(WCHAR) );
        nPaths++;
    }

    ciDebugOut(( DEB_ITRACE, "_Serialize, nPaths %d\n", nPaths ));

    hdr.SetCount  ( hdr.GetBackup(), nPaths  );
    hdr.SetUserHdr( hdr.GetBackup(), _usrHdr );

    xact.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::_LokScheduleScans
//
//  Synopsis:   Schedules all the scopes for either full or incremental
//              scan depending upon the header information.
//
//  History:    4-15-96   srikants   Moved out of StartUp
//              7-May-97  SitaramR   Usns
//
//----------------------------------------------------------------------------

void CCiScopeTable::_LokScheduleScans( PARTITIONID partId,
                                       BOOL & fSerializeNotifyList )
{
    ciDebugOut(( DEB_ITRACE, "in CCiScopeTable::_LokScheduleScans\n" ));
    fSerializeNotifyList = FALSE;

    {
        //
        // Read the persistent scope list
        //

        CRcovStorageHdr & storageHdr = _pTable->GetHeader();

        //
        // read the last scan time.
        //
        storageHdr.GetUserHdr( storageHdr.GetPrimary(), _usrHdr );
        if ( !_hdr.IsInitialized() )
            _hdr.Initialize();

        CScopeInfoStack stk;

        _DeSerialize( stk );

        ciDebugOut(( DEB_ITRACE, "scope stack count: %d\n", stk.Count() ));

        if ( 0 == stk.Count() )
            return;

        //
        // Enable batch processing in the scan manager. This will result in
        // all the scopes being processed at once and avoid the scan of
        // the property store once per scope.
        //
        XBatchScan  xBatchScans( _scanMgr );
        XBatchUsnProcessing xBatchUsns( _usnMgr );

        for ( ULONG i = 0; i < stk.Count(); i++ )
        {
            CScopeInfo & scopeInfo = *stk.Get(i);
            if ( !scopeInfo.IsValid() )
                continue;

            ciDebugOut(( DEB_ITRACE, "Adding path %ws to CI\n",
                         scopeInfo.GetPath() ));
            BOOL fSubScopesRemoved;

            //
            // Check if there has been a volume format change, e.g.
            // from a non-usn-enabled volume to an usn-enabled
            // volume.
            //

            BOOL fUsnEnabledNow = _cicat.VolumeSupportsUsns( scopeInfo.GetPath()[0] );
            BOOL fUsnEnabledPrev = scopeInfo.VolumeId() != CI_VOLID_USN_NOT_ENABLED;
            if ( fUsnEnabledNow != fUsnEnabledPrev )
            {
                //
                // Volume format has changed, so reset scopeInfo to simulate a fresh
                // scan using the appropriate method for new format.
                //

                 ciDebugOut(( DEB_WARN,
                              "Switching monitoring method for path %ws, due to format change\n",
                              scopeInfo.GetPath() ));

                 if ( fUsnEnabledNow )
                 {
                     VOLUMEID volId = _cicat.MapPathToVolumeId( scopeInfo.GetPath() );
                     scopeInfo.ResetForUsns( volId );
                 }
                 else
                     scopeInfo.ResetForScans();
            }

            //
            // Check if a USN-enabled volume has been opened in NT4.
            //

            if ( fUsnEnabledNow )
            {
                ULONGLONG jidNow  = _cicat.GetJournalId( scopeInfo.GetPath() );
                ULONGLONG jidPrev = scopeInfo.JournalId();

                if ( jidNow != jidPrev )
                {
                    ciDebugOut(( DEB_WARN,
                                 "Scanning USN-enabled volume %ws due to downlevel (NT4) open.\n",
                                 scopeInfo.GetPath() ));

                    scopeInfo.ResetForUsns( scopeInfo.VolumeId(), fUsnEnabledPrev ? scopeInfo.Usn() : 0 );
                }
            }

            //
            // Check to see if the volume has been reformatted.
            //

            BOOL fReformatted = (_cicat.GetVolumeCreationTime( scopeInfo.GetPath() ) != scopeInfo.VolumeCreationTime()) ||
                                (_cicat.GetVolumeSerialNumber( scopeInfo.GetPath() ) != scopeInfo.VolumeSerialNumber());

            if ( fReformatted || IsFullScanNeeded() )
            {
                ciDebugOut(( DEB_WARN, "Scanning newly formatted/trashed volume %ws\n", scopeInfo.GetPath() ));

                if ( CI_VOLID_USN_NOT_ENABLED == scopeInfo.VolumeId() )
                    scopeInfo.ResetForScans();
                else
                {
                    scopeInfo.SetScanNeeded( TRUE );                 // Full scan
                    scopeInfo.ResetForUsns( scopeInfo.VolumeId() );  // From USN = 0
                }
            }

            ciDebugOut(( DEB_ITRACE, "_LokScheduleScans, '%ws'\n",
                         scopeInfo.GetPath() ));

            _notifyMgr.AddPath( scopeInfo, fSubScopesRemoved );

            if ( CI_VOLID_USN_NOT_ENABLED == scopeInfo.VolumeId() )
            {
                ULONG updFlag;
                if ( fReformatted || fUsnEnabledNow != fUsnEnabledPrev )
                {
                    //
                    // Do a full scan if there has been a format change
                    //
                    updFlag = UPD_FULL;
                }
                else
                {
                    //
                    // Use scan info from persistent header of scopetable
                    //
                    if ( IsFullScanNeeded() )
                        updFlag = UPD_FULL;
                    else
                        updFlag = UPD_INCREM;
                }

                _scanMgr.ScanScope( scopeInfo.GetPath(),
                                    partId,
                                    updFlag, // Full or increm update
                                    TRUE,    // do deletions,
                                    TRUE     // delayed scanning
                                   );
            }
            else
            {
                Win4Assert( (0 == scopeInfo.Usn() && scopeInfo.FUsnTreeScan()) ||
                            0 != scopeInfo.Usn() );

                if ( scopeInfo.FUsnTreeScan() )
                {
                    //
                    // An usn of 0 indicates that a scan and subsequent
                    // CheckPointChangesFlushed  for this volume id has not
                    // completed successfully, and hence a scan is needed
                    //

                    ciDebugOut(( DEB_ITRACE, "_LokScheduleScans, AddScope\n" ));
                    _usnMgr.AddScope( scopeInfo.GetPath(),
                                      scopeInfo.VolumeId(),
                                      TRUE,                     // Do deletions
                                      scopeInfo.Usn(),          // Starting USN
                                      scopeInfo.IsFullScan() ); // TRUE --> delete everything first
                }
                else
                {
                    //
                    // Start monitoring for usn notifications. This is the main
                    // performance advantage of usns when compared with the
                    // _scanMgr.ScanScope above --- no scan is needed.
                    //
                    ciDebugOut(( DEB_ITRACE, "_LokScheduleScans, MonitorScope\n" ));
                    _usnMgr.MonitorScope( scopeInfo.GetPath(),
                                          scopeInfo.VolumeId(),
                                          scopeInfo.Usn() );
                }
            }

            if ( fSubScopesRemoved )
                fSerializeNotifyList = TRUE;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::StartUp
//
//  Synopsis:   Starts up the contentIndex scope scanning and notification
//              mechanism for all the scopes that are registered with the
//              content index.
//
//  Arguments:  [notifyMgr] -  The notification manager.
//              [scanMgr]   -  The scan manager.
//              [partId]    -  PartitionId.
//
//  History:    1-21-96   srikants   Created
//
//  Notes:      MUST BE UNDER CICAT LOCK
//
//----------------------------------------------------------------------------

void CCiScopeTable::StartUp( CClientDocStore & docStore ,
                             PARTITIONID partId )
{
    Win4Assert( 0 != _pTable );

    if ( _fInitialized )
        return;

    // ============================ ScopeTable lock ===================
    CLock   lock(_mutex);

    //
    // If there was no full scan needed when it was shutdown last,
    // set up for an incremental scan.
    //
    if ( eNoScan == _state )
        RecordIncrScanNeeded( TRUE );    // fStartup is TRUE

    ScheduleScansIfNeeded( docStore );

    _fInitialized = TRUE;
    // ============================ ScopeTable lock ===================

}



//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::AddScope
//
//  Synopsis:   Registers a scope persistently with CI for scanning and
//              notification.
//
//  Arguments:  [volumeId]           -- Volume id
//              [pwcsScope]          -- The scope to be registered.
//              [pwcsCatScope]       -- If non-zero, name of catalog key under
//                                      which a shadow registry entry should be
//                                      created.
//
//  History:    1-21-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::AddScope( VOLUMEID volumeId,
                              WCHAR const * pwszScope,
                              WCHAR const * pwszCatScope )
{
    ULONG ccPath = wcslen( pwszScope );

    Win4Assert( ccPath < MAX_PATH );
    Win4Assert( L'\\' == pwszScope[ccPath-1] );

#if CIDBG == 1
    if ( wcschr( pwszScope, L'~' ) )
    {
        // Possible shortnames in scope path.  We must only use long names.
        CLowerFunnyPath lowerFunnyPath( pwszScope );

        if ( lowerFunnyPath.IsShortPath( ) )
        {
            ciDebugOut(( DEB_WARN,
                     "CCiScopeTable::AddScope: possible shortname path %ws\n",
                         lowerFunnyPath.GetActualPath() ));
        }
    }
#endif // CIDBG == 1
    Win4Assert( 0 != _pTable );

    if ( 0 == _pTable )
    {
        _FatalCorruption();
    }

    CLock   lock(_mutex);

    CRcovStorageHdr & hdr = _pTable->GetHeader();
    CRcovStrmAppendTrans    xact( *_pTable );

    ULONG nPaths = hdr.GetCount( hdr.GetPrimary() );
    ccPath++;   // increment to include the trailing 0

    LONGLONG llSig = eSigCiScopeTable; // Signature for corruption detection.

    xact.Append( &llSig, sizeof(llSig) );
    xact.Append( &volumeId, sizeof(VOLUMEID) );

    ULONGLONG VolumeCreationTime = _cicat.GetVolumeCreationTime(pwszScope);
    xact.Append( &VolumeCreationTime, sizeof(VolumeCreationTime) );

    ULONG VolumeSerialNumber = _cicat.GetVolumeSerialNumber(pwszScope);
    xact.Append( &VolumeSerialNumber, sizeof(VolumeSerialNumber) );

    if ( volumeId == CI_VOLID_USN_NOT_ENABLED )
    {
        FILETIME ft;
        RtlZeroMemory( &ft, sizeof(ft) );
        xact.Append( &ft, sizeof(ft) );
    }
    else
    {
        USN usn = 0;
        xact.Append( &usn, sizeof(USN) );

        ULONGLONG JournalId = _cicat.GetJournalId( pwszScope );
        xact.Append( &JournalId, sizeof(JournalId) );
    }

    xact.Append( &ccPath, sizeof(ccPath) );
    xact.Append( pwszScope, ccPath*sizeof(WCHAR) );

    nPaths++;
    hdr.SetCount( hdr.GetBackup(), nPaths );

    xact.Commit();

    if ( 0 != pwszCatScope )
    {
        //
        // Build string: NAME: ,,3 --> Virtual, Indexed
        //

        WCHAR wcsScope[] = L",,3";

        HKEY  hkey;
        DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, pwszCatScope, &hkey );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, pwszCatScope ));
        }
        else
        {
            AddShadow( pwszScope, hkey );
            RegCloseKey( hkey );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::_Serialize
//
//  Synopsis:   Serializes the scopes in the notification manager.
//
//  History:    1-25-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::_Serialize()
{
    if ( 0 == _pTable )
    {
        _FatalCorruption();
    }

    CScopeInfoStack stk;

    // ====================== NOTIFY MGR LOCK =========================
    {
        for ( CCiNotifyIter iter( _notifyMgr );
              !iter.AtEnd() && 0 != iter.Get();
              iter.Advance() )
        {
            WCHAR const * pwszScope = iter.Get();
            ULONG ccPath = wcslen( pwszScope );
            ccPath++;      // increment to include trailing 0

            FILETIME ft;
            iter.GetLastScanTime( ft );

            XPtr<CScopeInfo>  xScopeInfo;

            if ( iter.IsDownlevelVolume() )
                xScopeInfo.Set( new CScopeInfo( pwszScope,
                                                iter.VolumeCreationTime(),
                                                iter.VolumeSerialNumber(),
                                                ft ) );
            else
                xScopeInfo.Set( new CScopeInfo( pwszScope,
                                                iter.VolumeCreationTime(),
                                                iter.VolumeSerialNumber(),
                                                iter.VolumeId(),
                                                iter.Usn(),
                                                iter.JournalId(),
                                                iter.FUsnTreeScan() ) );

            stk.Push( xScopeInfo.GetPointer() ); // Push can throw
            xScopeInfo.Acquire();
        }
    }
    // ====================== NOTIFY MGR LOCK =========================

    //
    // If the notification manager is shutting down, it probably gave
    // us an incomplete list of scopes
    //

    if ( _notifyMgr.IsRunning() )
        _Serialize( stk );
    else
        ciDebugOut(( DEB_WARN, "Not serializing scopes; notifymgr is shutdown\n" ));
} //_Serialize

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::_UpdateHeader
//
//  Synopsis:   Updates the on-disk header information based on the in-memory
//              version.
//
//  History:    4-15-96   srikants  Moved into a separate function
//
//----------------------------------------------------------------------------

void CCiScopeTable::_UpdateHeader()
{

    Win4Assert( sizeof(CCiScopeUsrHdr) <= sizeof(CRcovUserHdr) );

    if ( 0 == _pTable )
    {
        _FatalCorruption();
    }

    CRcovStorageHdr & storageHdr = _pTable->GetHeader();
    CRcovStrmAppendTrans     xact( *_pTable );

    if ( !_hdr.IsInitialized() )
        _hdr.Initialize();

    storageHdr.SetUserHdr( storageHdr.GetBackup(), _usrHdr );

    xact.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::ProcessChangesFlush
//
//  Synopsis:   Flushes the scope table, which will
//              write the latest flush time and usn flush info to disk.
//
//  History:    1-26-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::ProcessChangesFlush( )
{
    _Serialize();
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RemoveScope
//
//  Synopsis:   Removes the specified scope from the persistent table.
//
//  Arguments:  [pwcsScope]    --  Scope to be removed.
//              [pwcsCatScope] -- If non-zero, name of catalog key under
//                                which a shadow registry entry should be
//                                created.
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RemoveScope( WCHAR const * pwcsScope,
                                 WCHAR const * pwcsCatScope )
{
    CScopeInfoStack scopes;
    _DeSerialize( scopes );

    for ( unsigned i = 0; i < scopes.Count(); i++ )
    {
        CScopeInfo & scopeInfo = *scopes.Get(i);
        if ( !scopeInfo.IsValid() )
            continue;

        if ( AreIdenticalPaths(pwcsScope, scopeInfo.GetPath()) )
            scopeInfo.Invalidate();
    }

    _Serialize( scopes );

    //
    // Delete any remnant in registry.
    //

    HKEY  hkey;
    DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, pwcsCatScope, &hkey );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, pwcsCatScope ));
    }
    else
    {
        DeleteIfShadow( pwcsScope, hkey );
        RegCloseKey( hkey );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RemoveSubScopes
//
//  Synopsis:   Removes only the sub-scopes of the given scope. The scope
//              itself is NOT removed.
//
//  Arguments:  [pwcsScope]    -- Sub-scopes of the scope to be removed.
//              [pwcsCatScope] -- If non-zero, name of catalog key under
//                                which a shadow registry entry should be
//                                created.
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RemoveSubScopes( WCHAR const * pwcsScope,
                                     WCHAR const * pwcsCatScope )
{
    //
    // Open key for reg deletes.
    //

    HKEY hkey = 0;
    DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, pwcsCatScope, &hkey );

    if ( ERROR_SUCCESS != dwError ) {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, pwcsCatScope ));
    }

    SRegKey xKey( hkey );

    //
    // Search for sub-scopes
    //

    CScopeInfoStack scopes;
    _DeSerialize( scopes );

    CScopeMatch match( pwcsScope, wcslen(pwcsScope) );

    for ( unsigned i = 0;
          i < scopes.Count();
          i++ )
    {
        CScopeInfo & scopeInfo = *scopes.Get(i);
        if ( !scopeInfo.IsValid() )
            continue;

        if ( match.IsInScope( scopeInfo.GetPath(), wcslen(scopeInfo.GetPath()) ) &&
             !AreIdenticalPaths( scopeInfo.GetPath(), pwcsScope ) )
        {
            scopeInfo.Invalidate();

            //
            // Delete any remnant in registry.
            //

            if ( 0 != hkey )
                DeleteIfShadow( scopeInfo.GetPath(), hkey );
        }
    }

    _Serialize( scopes );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RefreshShadow, public
//
//  Synopsis:   Re-adds missing shadow (virtual) scopes to registry.
//
//  Arguments:  [pwcsPScope]   -- Physical scope to re-add (if doesn't exist)
//              [pwcsCatScope] -- Name of catalog key under which a shadow
//                                registry entry should be created.
//
//  History:    12-10-1997   KyleP   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RefreshShadow( WCHAR const * pwcsPScope, WCHAR const * pwcsCatScope )
{
    //
    // Open key for reg refresh.
    //

    HKEY  hkey = 0;
    DWORD dwError = RegOpenKey( HKEY_LOCAL_MACHINE, pwcsCatScope, &hkey );

    if ( ERROR_SUCCESS != dwError ) {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, pwcsCatScope ));
    }

    SRegKey xKey( hkey );

    //
    // Try the refresh
    //

    if ( 0 != hkey )
        RefreshIfShadow( pwcsPScope, hkey );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::ProcessDiskFull
//
//  Synopsis:   Processes disk full condition.
//
//  Arguments:  [scanMgr] -
//              [cci]     -
//              [partId]  -
//
//  History:    4-17-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScopeTable::ProcessDiskFull( CClientDocStore & docStore,
                                     PARTITIONID partId )
{
    CLock   lock(_mutex);

    if ( !_fInitialized )
        return;

    RecordIncrScanNeeded( FALSE );     // fStartup is FALSE
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::ClearDiskFull
//
//  Synopsis:   Processes the clearing of the disk full situation. If there
//              was in incremental scan scheduled, it will be processed.
//
//  Arguments:  [partId] - PartitionId.
//
//  History:    4-21-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScopeTable::ClearDiskFull( CClientDocStore &docStore )
{

    if ( !_fInitialized )
        return;

    ScheduleScansIfNeeded( docStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::MarkCiDataCorrupt, public
//
//  Synopsis:   Persistently marks catalog as corrupt.
//
//  History:    06-May-1998   KyleP   Added header
//
//----------------------------------------------------------------------------

void CCiScopeTable::MarkCiDataCorrupt()
{
    //
    // Abort any in-progress scans and usn updates
    //

    _scanMgr.DisableScan();
    _usnMgr.DisableUpdates();

    //
    // And persistently mark the corruption.
    //

    _hdr.SetCiDataCorrupt();
    _UpdateHeader();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RecordFullScanNeeded
//
//  Synopsis:   Records that a full scan is needed in memory and persistently.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RecordFullScanNeeded()
{
    // =============================================================

    //
    // Note that we call into scan manager from here which will need that
    // to acquire the lock but scan manager never calls into the scope
    // table with the lock held. So, we are okay.
    //
    CLock   lock(_mutex);

    //
    // Abort any in-progress scans and usn updates
    //
    _scanMgr.DisableScan();
    _usnMgr.DisableUpdates();

    //
    // Mark that we need a full scan.
    //
    _state = eFullScanNeeded;

    _hdr.SetFullScanNeeded();
    _UpdateHeader();

    // =============================================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RecordIncrScanNeeded
//
//  Synopsis:   If there is no full scan, it records that an incremental
//              scan is needed.
//
//  Arguments:  [fStartup] -- Is it startup time ?
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RecordIncrScanNeeded( BOOL fStartup )
{


    //
    // Note that we call into scan manager from here which will need that
    // to acquire the lock but scan manager never calls into the scope
    // table with the lock held. So, we are okay.
    //

    // =============================================================
    CLock   lock(_mutex);

    //
    // Abort any in-progress scans and usn updates
    //
    _scanMgr.DisableScan();

    if ( !fStartup )
    {
        //
        // An incremental scan needs to be persistently written at startup,
        // but there is no need to disable updates at startup
        //
        _usnMgr.DisableUpdates();
    }


    //
    // If there is full scan needed or a full scan is going on,
    // we have to do a full scan later. Otherwise, record an
    // incremental scan.
    //
    if ( eFullScanNeeded == _state || eDoingFullScan == _state )
    {
        _state = eFullScanNeeded;
    }
    else
    {
        _state = eIncrScanNeeded;
    }
    // =============================================================

    //
    // We don't have to update the persistent state about incremental
    // scans because we always do an incremental scan on startup.
    //
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::RecordScansComplete
//
//  Synopsis:   Records that any in-progress scan has been completed.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::RecordScansComplete()
{
    // =============================================================
    CLock   lock(_mutex);

    if ( eDoingIncrScan == _state || eDoingFullScan == _state )
    {
        _hdr.ClearFullScanNeeded();
        _UpdateHeader();

        _state = eNoScan;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::ScheduleScansIfNeeded
//
//  Synopsis:   If there is a pending scan and the disk is not full, it
//              schedules the appropriate scan.
//
//  Arguments:  [docStore] - DocStore to use for checking disk space
//                           situation.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScopeTable::ScheduleScansIfNeeded( CClientDocStore & docStore )
{
    Win4Assert( _state >= eNoScan && _state <= eDoingIncrScan );
    ciDebugOut(( DEB_ITRACE, "schedulescansifneeded, _state: %#x\n", _state ));

    BOOL fSerializeNotifyList = TRUE;

    // =============================================================
    {
        //
        // Note that we call into scan manager from here which will need that
        // to acquire the lock but scan manager never calls into the scope
        // table with the lock held. So, we are okay.
        //
        CLock   lock(_mutex);

        if ( eDoingFullScan == _state ||
             eDoingIncrScan == _state ||
             eNoScan        == _state )
        {
            //
            // There is nothing to do.
            //
            return;
        }

        BOOL fLowOnDisk = docStore.VerifyIfLowOnDiskSpace();

        if ( !fLowOnDisk )
        {
            _scanMgr.EnableScan();
            _usnMgr.EnableUpdates();
            _LokScheduleScans( 1, fSerializeNotifyList );

            if ( _state == eFullScanNeeded )
            {
                _state = eDoingFullScan;
                ciDebugOut(( DEB_WARN, "CCiScopeTable - Scheduled a full content scan\n" ));
            }
            else
            {
                _state = eDoingIncrScan;
                ciDebugOut(( DEB_WARN, "CCiScopeTable - Scheduled an incremental content scan\n" ));
            }
        }
    }
    // =============================================================

    if ( fSerializeNotifyList )
        _Serialize();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::Enumerate, public
//
//  Synopsis:   Enumerates entries in the scope table
//
//  Arguments:  [pwcScope]  - Buffer into which scope is written
//              [partId]    - bookmark for enumeration, 0 to rewind
//
//  History:    10/17/96    dlee      Created
//
//----------------------------------------------------------------------------

BOOL CCiScopeTable::Enumerate(
    WCHAR *    pwcScope,
    unsigned   cwc,
    unsigned & iBmk )
{
    CScopeInfoStack scopes;
    _DeSerialize( scopes );

    do
    {
        if ( iBmk >= scopes.Count() )
            return FALSE;

        CScopeInfo & scopeInfo = *scopes.Get( iBmk );

        iBmk++;

        if ( scopeInfo.IsValid() )
        {
            if ( cwc < ( wcslen( scopeInfo.GetPath() ) + 1 ) )
                THROW( CException( STATUS_INVALID_PARAMETER ) );

            wcscpy( pwcScope, scopeInfo.GetPath() );
            return TRUE;
        }
    } while ( TRUE );

    return FALSE;
} //Enumerate

//+----------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::ClearCiDataCorrupt, public
//
//  Synopsis:   Clears corrupted data if the catalog is not read-only
//
//  History:    02/20/98    kitmanh     Moved from scopetbl.hxx
//
//-----------------------------------------------------------------------------

void CCiScopeTable::ClearCiDataCorrupt()
{
    if (!_cicat.IsReadOnly())
    {
        _hdr.ClearCiDataCorrupt();
        _UpdateHeader();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CCiScopeTable::Dump, public
//
//  Synopsis:   dumps scope table
//
//  History:    3-1-98  mohamedn  created
//
//-----------------------------------------------------------------------------

#if CIDBG==1

void CCiScopeTable::Dump()
{
    CScopeInfoStack scopes;
    _DeSerialize( scopes );

    ciDebugOut(( DEB_ERROR, "========= Start ScopesTable =============\n" ));

    for ( unsigned i = 0; i < scopes.Count(); i++ )
    {
        ciDebugOut((DEB_ERROR,"scopetable: %ws\n", (scopes.Get(i))->GetPath() ));

    }

    ciDebugOut(( DEB_ERROR, "========= End ScopesTable =============\n" ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\scpfixup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       scpfixup.cxx
//
//  Contents:   Scope fixup classes to translate local paths to uncs that
//              remote machines can reference.
//
//  History:    09-Jun-1998  KyleP  Moved out of header
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <scpfixup.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::Add, public
//
//  Synopsis:   Adds a new fixup to the list
//
//  Arguments:  [pwcScope] -- Source (local) scope (e.g. c:\)
//              [pwcFixup] -- Fixed up scope (e.g. \\server\share\rootc)
//
//  History:    09-Jun-1998  KyleP   Added header
//
//--------------------------------------------------------------------------

void CScopeFixup::Add( WCHAR const * pwcScope, WCHAR const * pwcFixup )
{
    XPtr<CScopeFixupElem> xElem = new CScopeFixupElem( pwcScope,
                                                       pwcFixup );

    CWriteAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( _aElems[i]->IsMatch( xElem->GetScope() ) )
        {
            //
            // Replace exact matching old fixup with new fixup
            //

            if ( _aElems[i]->IsExactMatch( xElem.GetReference() ) )
            {
                _aElems[i]->SetSeen();
                return;
            }
            else
            {
                //
                // Move the original match down the list.
                //

                CScopeFixupElem * p = _aElems[i];
                _aElems[i] = xElem.Acquire();

                xElem.Set( p );
            }
        }
    }

    _aElems.Add( xElem.GetPointer(), _aElems.Count() );
    xElem.Acquire();
} //Add

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::Remove, public
//
//  Synopsis:   Removes a fixup from the list
//
//  Arguments:  [pwcScope] -- Source (local) scope (e.g. c:\)
//              [pwcFixup] -- Fixed up scope (e.g. \\server\share\rootc)
//
//  History:    09-Jun-1998  KyleP   Created
//
//--------------------------------------------------------------------------

void CScopeFixup::Remove( WCHAR const * pwcScope, WCHAR const * pwcFixup )
{
    CScopeFixupElem Elem( pwcScope, pwcFixup );

    CWriteAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( _aElems[i]->IsExactMatch( Elem ) )
        {
            //
            // Order-preserving delete
            //

            delete _aElems.AcquireAndShrinkAndPreserveOrder( i );
            break;
        }
    }
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::IsExactMatch, public
//
//  Arguments:  [pwcScope] -- Source (local) scope (e.g. c:\)
//              [pwcFixup] -- Fixed up scope (e.g. \\server\share\rootc)
//
//  Returns:    TRUE if both the path and alias exactly match a currently
//              registered pair.
//
//  History:    09-Jun-1998  KyleP   Added header
//
//--------------------------------------------------------------------------

BOOL CScopeFixup::IsExactMatch( WCHAR const * pwcScope,
                                WCHAR const * pwcFixup )
{
    CScopeFixupElem Elem( pwcScope, pwcFixup );

    CReadAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( _aElems[i]->IsExactMatch( Elem ) )
            return TRUE;
    }

    return FALSE;
} //IsExactMatch

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::Fixup, public
//
//  Synopsis:   Converts a local path to an aliased (fixed up) path
//
//  Arguments:  [pwcOriginal] -- Fixed up path (e.g. c:\foo.txt)
//              [pwcResult]   -- Fixed up path (e.g. \\server\share\foo.txt)
//              [cwcResult]   -- Size of [pwcResult]
//              [cSkip]       -- Skip this many matches
//
//  Returns:    Count of characters written to [pwcResult]
//
//  History:    09-Jun-1998  KyleP   Added header
//
//--------------------------------------------------------------------------

unsigned CScopeFixup::Fixup( WCHAR const * pwcOriginal,
                             WCHAR *       pwcResult,
                             unsigned      cwcResult,
                             unsigned      cSkip )
{
    // the path is already lowercase -- don't copy or lowercase it.

    CLowcaseBuf orig( pwcOriginal, TRUE );

    {
        // =========================================================
        CReadAccess lock( _rwLock );

        for ( unsigned i = 0; i < _aElems.Count(); i++ )
        {
            if ( _aElems[i]->IsMatch( orig ) )
            {
                if ( 0 == cSkip )
                    return _aElems[i]->Fixup( orig, pwcResult, cwcResult );
                else
                    cSkip--;
            }
        }
        // =========================================================
    }

    // no fixup available -- just copy the original

    if ( cwcResult > orig.Length() )
    {
        RtlCopyMemory( pwcResult,
                       pwcOriginal,
                       ( orig.Length() + 1 ) * sizeof WCHAR );
        return orig.Length();
    }

    if ( 0 == cSkip )
        return orig.Length() + 1;
    else
        return 0;
} //Fixup

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::InverseFixup, public
//
//  Synopsis:   Converts a fixup to a source path.
//
//  Arguments:  [lcaseFunnyPath] -- Fixed up path (e.g. \\Server\Share\foo.txt)
//                                  Local path (e.g. c:\foo.txt) is also returned here
//
//  History:    09-Jun-1998  KyleP   Added header
//
//--------------------------------------------------------------------------

void CScopeFixup::InverseFixup( CLowerFunnyPath & lcaseFunnyPath )
{
    CReadAccess lock( _rwLock );


    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( _aElems[i]->IsInverseMatch( lcaseFunnyPath ) )
        {
            _aElems[i]->InverseFixup( lcaseFunnyPath );
            break;
        }
    }

} //InverseFixup

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::BeginSeen, public
//
//  Synopsis:   Initiates 'seen processing' for fixups.
//
//  History:    09-Jun-1998  KyleP   Created
//
//--------------------------------------------------------------------------

void CScopeFixup::BeginSeen()
{
    CWriteAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        _aElems[i]->ClearSeen();
    }
} //BeginSeen

//+-------------------------------------------------------------------------
//
//  Member:     CScopeFixup::EndSeen, public
//
//  Synopsis:   Removes any unreferenced fixups
//
//  History:    09-Jun-1998  KyleP   Created
//
//--------------------------------------------------------------------------

void CScopeFixup::EndSeen()
{
    CWriteAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( !_aElems[i]->IsSeen() )
        {
            ciDebugOut(( DEB_ITRACE, "Removing fixup for: %ws\n", _aElems[i]->GetScope().Get() ));

            delete _aElems.AcquireAndShrinkAndPreserveOrder(i);
        }
    }
} //EndSeen
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\removcat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999.
//
//  File:       remcat.cxx
//
//  Contents:   Removable catalog registry support
//
//  Classes:    CRemovableCatalog
//
//  History:    6-Apr-99   dlee       Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <isreg.hxx>
#include <ciregkey.hxx>
#include <removcat.hxx>

extern WCHAR GetDriveLetterOfAnyScope( WCHAR const * pwcCatalog );

//+-------------------------------------------------------------------------
//
//  Method:     CRemovableCatalog::Create, public
//
//  Synopsis:   Creates temporary registry entries for the catalog
//
//  History:    6-Apr-99   dlee       Created.
//
//--------------------------------------------------------------------------

void CRemovableCatalog::Create()
{
    // First, remove any existing values for the catalog

    Destroy();

    // Make the catalog key

    WCHAR awcCat[40];
    MakeCatalogName( awcCat );

    BOOL fExisted;
    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsSubKey );
        reg.CreateKey( awcCat, fExisted );
    }

    // Add values for this catalog under the key

    WCHAR awcCatalog[200];
    wsprintf( awcCatalog, L"%ws\\%ws", wcsRegCatalogsSubKey, awcCat );

    WCHAR awcScopes[ 200 ];
    wsprintf( awcScopes, L"%ws\\%ws", awcCatalog, wcsCatalogScopes );

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, awcCatalog );

        // Set the catalog location

        WCHAR awcLocation[4];
        wcscpy( awcLocation, L"x:\\" );
        awcLocation[0] = _wcDrive;
        reg.Set( wcsCatalogLocation, awcLocation );

        //
        // Make the catalog read-only, mark it as removable, and force
        // path aliases so drive letters in paths returned in queries
        // match the drive letter of the removable drive.
        //

        reg.Set( wcsIsReadOnly, TRUE );
        reg.Set( wcsIsRemovableCatalog, TRUE );
        reg.Set( wcsForcePathAlias, TRUE );

        reg.CreateKey( wcsCatalogScopes, fExisted );
    }

    //
    // Add a fixup for the root of the volume in case the drive letter
    // is different from where the catalog was built.
    //

    WCHAR awcPath[ 20 ];
    wcscpy( awcPath, L"x:\\catalog.wci" );
    awcPath[0] = _wcDrive;
    WCHAR wcScope = GetDriveLetterOfAnyScope( awcPath );

    ciDebugOut(( DEB_ITRACE, "scope drive: '%wc'\n", wcScope ));

    if ( 0 != wcScope )
    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, awcScopes );

        WCHAR awcValue[10];
        wcscpy( awcValue, L"x:\\,," );
        awcValue[0] = _wcDrive;

        WCHAR awcScope[10];
        wcscpy( awcScope, L"x:\\" );
        awcScope[0] = wcScope;

        reg.Set( awcScope, awcValue );
    }
} //Create

//+-------------------------------------------------------------------------
//
//  Method:     CRemovableCatalog::Destroy, public
//
//  Synopsis:   Destroys temporary registry entries for the catalog
//
//  History:    6-Apr-99   dlee       Created.
//
//--------------------------------------------------------------------------

void CRemovableCatalog::Destroy()
{
    // Ignore failures here...

    WCHAR awcCat[40];
    MakeCatalogName( awcCat );

    WCHAR awcCatalog[200];
    wsprintf( awcCatalog, L"%ws\\%ws", wcsRegCatalogsSubKey, awcCat );

    TRY
    {
        // Remove the scopes and properties keys
    
        {
            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, awcCatalog );
            reg.RemoveKey( wcsCatalogScopes );
            reg.RemoveKey( wcsCatalogProperties );
        }
    
        // Remove the catalog key
    
        {
            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsSubKey );
            reg.RemoveKey( awcCat );
        }
    }
    CATCH( CException, e )
    {
        // ignore it -- we tried.
    }
    END_CATCH
} //Destroy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\qcat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       QCAT.CXX
//
//  Contents:   Query catalog -- downlevel catalog w/o CI support
//
//  History:    18-Aug-94   KyleP       Extracted from CiCat
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qcat.hxx>
#include <propspec.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CQCat::CQCat, public
//
//  Synopsis:   Creates a new catalog
//
//  History:    18-Aug-94   KyleP       Extracted from CiCat
//
//--------------------------------------------------------------------------

CQCat::CQCat( WCHAR const * pwcName )
        : _regParams( pwcName )
{
    END_CONSTRUCTION( CQCat );
}

//+-------------------------------------------------------------------------
//
//  Member:     CQCat::~CQCat, public
//
//  Synopsis:   Destructor
//
//  History:    18-Aug-94   KyleP       Extracted from CiCat
//
//--------------------------------------------------------------------------

CQCat::~CQCat ()
{
}

//
// Content-index specific.  Not implemented.
//

PStorage & CQCat::GetStorage ()
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return *((PStorage *)0);
}


WCHAR * CQCat::GetDriveName()
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( 0 );
}

void  CQCat::DisableUsnUpdate( PARTITIONID )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

void  CQCat::EnableUsnUpdate( PARTITIONID  )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

unsigned CQCat::ReserveUpdate( WORKID wid )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
    return 1;
}

void  CQCat::Update( unsigned, WORKID, PARTITIONID, USN, ULONG )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

unsigned CQCat::WorkIdToPath ( WORKID, CFunnyPath & )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( 0 );
}

WORKID CQCat::PathToWorkId ( const CLowerFunnyPath &, const BOOL fCreate )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( widInvalid );
}

void CQCat::SetPartition( PARTITIONID )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

PARTITIONID CQCat::GetPartition() const
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( 0 );
}

CRWStore * CQCat::ComputeRelevantWords( ULONG, ULONG, WORKID *, PARTITIONID )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( 0 );
}

CRWStore * CQCat::RetrieveRelevantWords( BOOL, PARTITIONID )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( 0 );
}

void CQCat::UpdateDocuments( WCHAR const *, ULONG )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

SCODE CQCat::CreateContentIndex()
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );

    return( E_FAIL );
}

void CQCat::EmptyContentIndex()
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
}

void CQCat::PidMapToPidRemap( const CPidMapper & pidMap,
                              CPidRemapper & pidRemap )
{
    Win4Assert( !"Downlevel CI feature called" );
}

SCODE CQCat::CiState( CI_STATE & state )
{
    Win4Assert( !"Downlevel CI feature called" );
    THROW( CException( E_NOTIMPL ) );
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\scanmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       scanmgr.cxx
//
//  Contents:   Scan manager
//
//  History:    14-Jul-97   SitaramR  Created from dlnotify.cxx
//
//  Notes  :    For lock hierarchy and order of acquiring locks, please see
//              cicat.cxx
//
//  DISKFULL HANDLING
//
//  The disk full situation is either detected in RESMAN and information sent
//  up to CICAT or a DISKFULL error is first detected in CICAT and then
//  propagated to RESMAN. As part of diskfull processing in the scope table,
//  existing scans are aborted in scanmanager and future scans are disabled
//  until the diskfull gets cleared up. If DISKFULL is detected at startup
//  time, the scope table enters a "incremental scan required" state and doesn't
//  schedule any scans/notifications until the situation improves.
//
//  If the changelog loses a notification, a DisableUpdates notification is sent
//  to the DocStore. The scan is deferred until an EnableUpdates notification
//  is sent to DocStore.
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <cistore.hxx>
#include <rcstxact.hxx>
#include <imprsnat.hxx>
#include <eventlog.hxx>

#include <docstore.hxx>

#include "cicat.hxx"
#include "update.hxx"
#include "notifmgr.hxx"
#include "scanmgr.hxx"
#include "scopetbl.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::CCiScanMgr
//
//  Synopsis:   ~ctor of the scan manager for downlevel CI. It starts a
//              background thread for doing the scans.
//
//  Arguments:  [cicat] -
//
//  History:    1-19-96   srikants   Created
//              3-03-98   kitmanh    Initialized member _fIsReadOnly with
//                                   cicat.IsReadOnly
//
//  Notes:
//
//----------------------------------------------------------------------------

CCiScanMgr::CCiScanMgr( CiCat & cicat ) :
    _cicat(cicat),
    _fAbort(FALSE),
    _fSerializeChanges(FALSE),
    _state(eStart),
    #pragma warning( disable : 4355 )       // this used in base initialization
    _thrScan( ScanThread, this, TRUE ),     // create suspended
    #pragma warning( default : 4355 )
    _fBatch(FALSE),                         // disable batch processing
    _fAbortScan(FALSE),
    _fScanDisabled(FALSE),
    _fIsReadOnly(cicat.IsReadOnly()),
    _dwLastShareSynch( 0 )
{
    _evtScan.Reset();

    _thrScan.SetPriority( THREAD_PRIORITY_BELOW_NORMAL );
}


CCiScanMgr::~CCiScanMgr()
{
    InitiateShutdown();
    WaitForShutdown();

    // delete any in-progress scan info

    CLock lock( _mutex );

    while ( !_scansInProgress.IsEmpty() )
    {
        delete _scansInProgress.RemoveLast();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::StartRecovery
//
//  Synopsis:   Sets the state to indicate that recovery must be done
//              and wakes up the scan thread.
//
//  History:    3-06-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::StartRecovery()
{
    CLock   lock(_mutex);
    Win4Assert( eStart == _state );
    _state = eDoRecovery;
    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::StartScansAndNotifies
//
//  Synopsis:   Initiates scans and notifications in the document store.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::StartScansAndNotifies()
{
    CLock   lock(_mutex);
    Win4Assert( eRecovered == _state );

    _state = eStartScans;
    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_LokIsScanScheduled
//
//  Synopsis:   Tests if the given scope is already scheduled for a scan.
//
//  Arguments:  [xScanInfo] - Smart pointer to scaninfo
//
//  History:    2-26-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiScanMgr::_LokIsScanScheduled( const XPtr<CCiScanInfo> & xScanInfo )
{
    WCHAR const * pwszNewScope = xScanInfo->GetPath();
    unsigned lenNewScope = wcslen( pwszNewScope );

    for ( CFwdScanInfoIter scanInfoIter(_scansToDo);
          !_scansToDo.AtEnd(scanInfoIter);
          _scansToDo.Advance(scanInfoIter) )
    {
        if ( xScanInfo->LokGetWorkType() == scanInfoIter->LokGetWorkType() )
        {
            WCHAR const * pwszPath = scanInfoIter->GetPath();

            CScopeMatch scope( pwszPath, wcslen(pwszPath) );
            if (scope.IsInScope( pwszNewScope, lenNewScope ))
            {
                ciDebugOut(( DEB_ITRACE,"Scan already scheduled for (%ws)\n",
                             pwszNewScope ));
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::ScanScope
//
//  Synopsis:   Adds the given scope to the list of scopes to scan.
//
//  Arguments:  [xScanInfo] - Will be acquired from the safe pointer if
//                            successfully taken over.
//              [fDelayed]  - Set to TRUE if the scan must not be done
//                            immediately.
//              [fRefiled]  - Set to TRUE if this is a refile or retry scan
//
//  History:    1-23-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::ScanScope(
    XPtr<CCiScanInfo> & xScanInfo,
    BOOL fDelayed,
    BOOL fRefiled )
{
    CLock lock( _mutex );

    if ( xScanInfo->GetRetries() <= CCiScanInfo::MAX_RETRIES &&
         !_LokIsScanScheduled( xScanInfo ) )
    {
        Win4Assert( !xScanInfo->LokIsInFinalState() );
        Win4Assert( xScanInfo->LokIsInScan()
                    || xScanInfo->LokIsDelScope()
                    || xScanInfo->LokIsRenameDir() );

        if ( fRefiled )
        {
            //
            // A scan that has been refiled should be done before new scans
            // to ensure that all scans are done in FIFO order.
            //
            _scansToDo.Push( xScanInfo.GetPointer() );
        }
        else
            _scansToDo.Queue( xScanInfo.GetPointer() );
        xScanInfo.Acquire();

        if ( !fDelayed )
            _evtScan.Set();
    }
    else
    {
        xScanInfo.Free();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::DirAddNotification
//
//  Synopsis:   Schedules the scan of a new directory
//
//  Arguments:  [pwcsDirName] - Directory added
//
//  History:    20-Mar-96      SitaramR      Added header
//
//----------------------------------------------------------------------------

void CCiScanMgr::DirAddNotification( WCHAR const *pwcsDirName )
{
    //
    // Force a full scan of the direcotry, because the directory is new and so
    // it cannot have been scanned before
    //
    XPtr<CCiScanInfo> xScanInfo( _QueryScanInfo( pwcsDirName,
                                                 _cicat.GetPartition(),
                                                 UPD_FULL,
                                                 FALSE ) );
    xScanInfo->SetScan();
    xScanInfo->SetProcessRoot();

    //---------------------------------------------------------
    {
        CLock lock( _mutex );

        _scansToDo.Queue( xScanInfo.GetPointer() );
        xScanInfo.Acquire();

        _evtScan.Set();        // Wake up the scan thread
    }
    //---------------------------------------------------------
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::DirRenameNotification
//
//  Synopsis:   Schedules the scan of a rename directory notification
//
//  Arguments:  [pwcsDirOldName] - Previous name of irectory
//              [pwcsDirNewName] - New name of directory
//
//  History:    20-Mar-96      SitaramR      Added header
//
//----------------------------------------------------------------------------

void CCiScanMgr::DirRenameNotification( WCHAR const *pwcsDirOldName,
                                        WCHAR const *pwcsDirNewName )
{

    BOOL fRenameScheduled = FALSE;

    CLock lock( _mutex );

    for ( CFwdScanInfoIter scanInfoIter( _scansToDo );
          !_scansToDo.AtEnd( scanInfoIter );
          _scansToDo.Advance( scanInfoIter ) )
    {
        //
        // if dirA is renamed to dirB, and then dirB is renamed to dirC, then it is
        // the same as dirA being renamed to dirC.
        //
        // Note: if dirA is renamed to dirB, and then dirB is renamed to dirA, we don't
        // cancel the two renames because it may not yield the same original state. For
        // example, after the first rename if a file, say file1, below dirB is deleted, and
        // then dirB is renamed to dirA, then since the strings table is not aware of the
        // file dirB\file1, no action will be taken, ie the file won't be deleted. By
        // scheduling the two renames one after another the wid corresponding to dirB\file1
        // will be correctly deleted.
        //
        if ( scanInfoIter->LokIsRenameDir()
             && AreIdenticalPaths( scanInfoIter->GetPath(), pwcsDirOldName )
             && !AreIdenticalPaths( scanInfoIter->GetDirOldName(), pwcsDirNewName ) )  // See note above
        {
             //
             // By overwriting dirC over dirB (see example above), we have combined the two rename
             // operations into one rename operation
             //
             scanInfoIter->LokSetPath( pwcsDirNewName );
             fRenameScheduled = TRUE;

             break;
        }
    }


    if ( !fRenameScheduled )
    {
        XPtr<CCiScanInfo> xScanInfo( _QueryScanInfo( pwcsDirNewName,
                                                     _cicat.GetPartition(),
                                                     UPD_INCREM,
                                                     FALSE ) );
        xScanInfo->SetRenameDir();
        xScanInfo->SetDirOldName( pwcsDirOldName );

        ScanScope( xScanInfo, TRUE, FALSE );

        //
        // If this rename operation is interrupted in the middle (because of a
        // subsequent delete or rename) then files/wids under the old directory may
        // still be lying around in the property store. To ensure that all such
        // files/wids are removed, schedule a remove operation for the old directory
        // name.
        //

        _LokScheduleRemove( pwcsDirOldName );
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_QueryScanInfo
//
//  Synopsis:   Returns a new instance of CCiScanInfo
//
//  Arguments:  [pwcsScope]    -- Scope
//              [partId]       -- Partition id
//              [updFlag]      -- Incremental or full update
//              [fDoDeletions] -- Shoud deletions be done ?
//              [fNewScope]    -- TRUE if a new scope
//
//  History:    20-Mar-96      SitaramR      Added header
//
//----------------------------------------------------------------------------

CCiScanInfo *
CCiScanMgr::_QueryScanInfo( WCHAR const * pwcsScope,
                            PARTITIONID partId,
                            ULONG updFlag,
                            BOOL fDoDeletions,
                            BOOL fNewScope )
{
    Win4Assert( 0 != pwcsScope );
    ULONG len = wcslen( pwcsScope );
    Win4Assert( pwcsScope[len-1] == L'\\' );

    XArray<WCHAR> xPath( len+1 );
    RtlCopyMemory( xPath.Get(), pwcsScope, xPath.SizeOf() );
    return new CCiScanInfo( xPath,
                            partId,
                            updFlag,
                            fDoDeletions,
                            CI_VOLID_USN_NOT_ENABLED,
                            0,
                            FALSE,
                            fNewScope );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::ScanScope
//
//  Synopsis:   Adds the given scope with given characteristics to the list
//              of paths to be scanned.
//
//  Arguments:  [pwcsScope]    - path name of scope to be added
//              [partId]       - partition ID
//              [updFlag]      -
//              [fDoDeletions] -
//              [fDelayed]     -
//              [fNewScope] - TRUE if a new scope
//
//  History:    1-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::ScanScope( WCHAR const * pwcsScope,
                            PARTITIONID partId,
                            ULONG updFlag,
                            BOOL  fDoDeletions,
                            BOOL  fDelayed,
                            BOOL fNewScope )
{
    Win4Assert( wcslen(pwcsScope) < MAX_PATH );

    XPtr<CCiScanInfo> xScanInfo( _QueryScanInfo( pwcsScope,
                                                 partId,
                                                 updFlag,
                                                 fDoDeletions,
                                                 fNewScope ) );
    xScanInfo->SetScan();
    xScanInfo->SetProcessRoot();

    ScanScope( xScanInfo, fDelayed, FALSE );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::ScheduleSerializeChanges
//
//  Synopsis:   Schedules a serialize-changes task
//
//  History:    20-Aug-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::ScheduleSerializeChanges()
{
    CLock   lock(_mutex);

    _fSerializeChanges = TRUE;
    _evtScan.Set();
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::InitiateShutdown
//
//  Synopsis:   Initiates the shutdown process.
//
//  History:    2-28-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::InitiateShutdown()
{
    CLock   lock(_mutex);
    _fAbort = TRUE;
    _fAbortScan = TRUE;

    //
    // collect all the paths from the to-do stack.
    //
    while ( _scansToDo.Count() > 0 )
    {
        //
        // delete any pending scans.
        //
        delete _scansToDo.Pop();
    }

    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::WaitForShutdown
//
//  Synopsis:   Waits for the shutdown to complete.
//
//  History:    2-28-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::WaitForShutdown()
{
    //
    // If we never started running, then just bail out.
    //

    if ( _thrScan.IsRunning() )
    {
        ciDebugOut(( DEB_ITRACE, "Waiting for death of scan thread\n" ));
        _thrScan.WaitForDeath();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::SetBatch
//
//  Synopsis:   Sets the flag that batch processing of scans is in progress.
//              Until the flag is turned off, the scan thread will not look
//              at the scopes for scanning.
//
//  History:    1-23-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::SetBatch()
{
    CLock   lock(_mutex);
    _fBatch = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::ClearBatch
//
//  Synopsis:   Clears the batch processing flag and wakes up the scan
//              thread. All the accumulated scopes for scanning will be
//              retrieved by the scan thread and processed.
//
//  History:    1-23-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::ClearBatch()
{
    CLock   lock(_mutex);
    _fBatch = FALSE;
    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::WakeUp
//
//  Synopsis:   Wakes up the scan thread.
//
//  History:    1-23-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::WakeUp()
{
    CLock   lock(_mutex);
    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::ScanThread
//
//  Synopsis:
//
//  Arguments:  [self] -
//
//  History:    1-19-96   srikants   Created
//              3-03-98   kitmanh    Don't _DoScans if catalog is read-only
//
//----------------------------------------------------------------------------

DWORD CCiScanMgr::ScanThread( void * self )
{
    SCODE sc = CoInitializeEx( 0, COINIT_MULTITHREADED );
    ((CCiScanMgr *) self)->_DoScans();
    CoUninitialize();

    ciDebugOut(( DEB_ITRACE, "Terminating scan thread\n" ));

    //
    // This is only necessary if thread is terminated from DLL_PROCESS_DETACH.
    //
    //TerminateThread( ((CCiScanMgr *) self)->_thrScan.GetHandle(), 0 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::SetScanSuccess, public
//
//  Synopsis:   Called on successful completion of scan.
//
//  Arguments:  [pScanInfo] -- Scope that was scanned.
//
//  History:    13-Apr-1998  KyleP  Moved to .cxx and added cicat callback.
//
//----------------------------------------------------------------------------

void CCiScanMgr::SetScanSuccess( CCiScanInfo * pScanInfo )
{
    Win4Assert( 0 != pScanInfo );

    CLock   lock(_mutex);
    if ( !_fAbort && !_fAbortScan )
    {
        pScanInfo->LokSetDone();
        _cicat.SetTreeScanComplete( pScanInfo->GetPath() );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_DoScans
//
//  Synopsis:
//
//  History:    1-19-96   srikants   Created
//              3-25-98   kitmanh    Just set the initialized event and return
//                                   if cat is r/o
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::_DoScans()
{
    if ( IsReadOnly() )
    {
        _cicat.SetEvtInitialized();
        _cicat.SetEvtPh2Init();
        _cicat.SynchWithRegistryScopes();
        return;
    }

    BOOL fContinue = TRUE;

    BOOL fScanned = FALSE;              // set to TRUE if a scan is performed

    while ( fContinue )
    {
        BOOL  fWait = FALSE;            // flag set to TRUE if a wait must be done

        EState workType = eStart;

        BOOL  fShortWait = FALSE;

        BOOL fSerializeChanges = FALSE; // No serialize-changes tasks yet

        NTSTATUS status = STATUS_SUCCESS;

        //
        // Don't do any work until the system has booted
        //

        while ( ( GetTickCount() < _cicat.GetRegParams()->GetStartupDelay() ) &&
                ( eStart != _state ) &&
                ( eDoRecovery != _state ) )
        {
            Sleep( 200 );
            if ( _fAbort )
                break;
        }

        TRY
        {
            XPtr<CCiScanInfo>   xScanInfo;

            // =========================================
            {
                CLock   lock(_mutex);

                if ( _fAbort )
                    break;

                if ( !_fBatch && _LokIsOkToScan() )
                {
                    //
                    // refile any incomplete paths that could not be
                    // refiled due to low resources.
                    //
                    if ( _scansInProgress.Count() > 0 )
                    {
                        _LokEmptyInProgressScans();
                    }

                    //
                    // collect all the paths from the to-do stack.
                    //
                    while ( _scansToDo.Count() > 0 )
                    {
                        // should first save in a safe pointer because the
                        // push can fail.
                        xScanInfo.Set( _scansToDo.Pop() );
                        if ( !_fScanDisabled && !xScanInfo->LokIsInFinalState() )
                        {
                            _scansInProgress.Queue( xScanInfo.GetPointer() );
                            xScanInfo.Acquire();
                        }
                        else
                        {
                            // this scope is deleted
                            xScanInfo.Free();
                        }
                    }

                    if ( 0 == _scansInProgress.Count() )
                        _evtScan.Reset();

                    if ( 0 == _scansInProgress.Count() && _fSerializeChanges )
                    {
                        //
                        // Make local copy of fSerializeChanges for use outside lock. Also
                        // reset _fSerializeChanges since a flush task will be scheduled below.
                        //
                        fSerializeChanges = TRUE;
                        _fSerializeChanges = FALSE;
                    }

                }
                else if ( _LokIsDoRecovery() )
                {
                    _evtScan.Reset();
                    workType = eDoRecovery;
                }
                else if ( _LokIsStartScans() )
                {
                    _evtScan.Reset();
                    workType = eStartScans;
                }
            }
            // =========================================

            //
            // Update fixups.  We have to do this at regular
            // intervals because there is no notification API for
            // share changes.  Check no more often than every 15
            // minutes; this drags in 13 DLLs.
            //

            DWORD cmsDifference = GetTickCount() - _dwLastShareSynch;

            if ( cmsDifference > ( _cicat.GetRegParams()->MaxAutoAliasRefresh() * 1000 * 60 ) )
            {
                //
                // Don't do this in resource-bound situations
                //

                CI_STATE State;
                State.cbStruct = sizeof( State );

                SCODE sc = _cicat.CiState( State );

                if ( SUCCEEDED( sc ) &&
                     ( 0 == ( State.eState & ( CI_STATE_HIGH_IO |
                                               CI_STATE_LOW_MEMORY |
                                               CI_STATE_USER_ACTIVE ) ) ) )
                {
                    _cicat.SynchShares();

                    //
                    // it is OK to modify this outside the class lock because
                    // only one thread performs scans for a catalog at any moment
                    // and there is one CCiScanMgr object per catalog.
                    //
                    _dwLastShareSynch = GetTickCount();
                }
            }

            if ( eDoRecovery == workType )
            {
                //
                // Do the long running initialization.
                //

                Win4Assert( !IsReadOnly() );


                // Note: recovery is now synchronous, but this must be
                // done asynchronously, since the callback to the docstore
                // must be done by a worker thread.
                //_cicat.DoRecovery();

                //
                // Set the state of the scan manager as recovered.
                //
                // ======================================
                {
                    CLock   lock(_mutex);
                    _state = eRecovered;
                }
                // ======================================

                ciDebugOut(( DEB_WARN, "Setting CiCat recovery done...\n" ));

                _cicat.SetRecoveryCompleted();
            }
            else if ( eStartScans == workType )
            {
                _cicat.StartScansAndNotifies();

                CLock   lock(_mutex);
                _state = eNormal;
            }
            else if ( _scansInProgress.Count() > 0 )
            {
                fScanned = TRUE;
                _Scan();
                Win4Assert( 0 == _scansInProgress.Count() || _fAbort );
            }
            else if ( fSerializeChanges )
            {
                _cicat.SerializeChangesInfo();
                fWait = TRUE;
            }
            else
            {
                fWait = TRUE;
            }

            //
            // Do scans complete processing if appropriate.
            //
            if ( fWait &&
                 eNormal == _state &&
                 !_fScanDisabled &&
                 !fSerializeChanges )
            {
                _cicat.ProcessScansComplete( fScanned, fShortWait );
            }
        }
        CATCH (CException, e)
        {
            status = e.GetErrorCode();

            ciDebugOut(( DEB_ERROR,
                "CCiScanMgr::_DoScans. Caught exception 0x%X\n",
                status ));

            if ( CiCat::IsDiskLowError( status )         ||
                 STATUS_INSUFFICIENT_RESOURCES == status ||
                 STATUS_NO_MEMORY == status )
            {
                // delay the execution of the thread until resources are
                // available.
                fWait = TRUE;
            }
            else
            {
                _cicat.HandleError( status );
                fContinue = FALSE;
            }

            // We did not successfully complete recovery, but we need to signal that
            // phase 2 init is complete (albeit unsuccessfully)
            // fix for bug 151799
            if (_cicat.IsCorrupt() && eDoRecovery == workType)
                _cicat.SignalPhase2Completion();
        }
        END_CATCH

        if ( fWait )
        {
            fScanned = FALSE;

            //
            // If we are waiting during long initialization, then have a
            // shorter wait time to see if the error condition has cleared
            // up.
            //
 
            DWORD dwWaitTime = ( (eStart != workType) || fShortWait) ?
                               PREINIT_WAIT : AUTOSCAN_WAIT;
 
            dwWaitTime = min( dwWaitTime,
                              _cicat.GetRegParams()->GetForcedNetPathScanInterval() * 60 * 1000 );
 
            dwWaitTime = min( dwWaitTime,
                              _cicat.GetRegParams()->MaxAutoAliasRefresh() * 1000 * 60  );
 
            _evtScan.Wait( dwWaitTime );
        }
    }
} //_DoScans

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_LokEmptyInProgressScans
//
//  Synopsis:   Removes all the scans from the "in-progress stack" and either
//              deletes them or re-schedules them. If the scan is in its
//              "terminal state", the scan is deleted. If there is a retry
//              it will be re-scheduled.
//
//  History:    1-25-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::_LokEmptyInProgressScans()
{
    //
    // refile any scopes that still need to be worked on.
    //
    while ( _scansInProgress.Count() > 0 )
    {
        if ( _fAbort )
            break;

        XPtr<CCiScanInfo>   xScanInfo( _scansInProgress.RemoveLast() );

        if ( !_fScanDisabled && !xScanInfo->LokIsInFinalState() )
        {

#if CIDBG==1
            if ( xScanInfo->LokIsDelScope() )
            {
                ciDebugOut(( DEB_ITRACE, "Requeing scope (%ws) for removal\n",
                             xScanInfo->GetPath() ));
            }
            else if ( xScanInfo->LokIsRenameDir() )
            {
                ciDebugOut(( DEB_ITRACE, "Requeing scope (%ws) for rename\n",
                             xScanInfo->GetPath() ));
            }
            else
            {
                ciDebugOut(( DEB_ITRACE, "Requeuing scope (%ws) for scan\n",
                         xScanInfo->GetPath() ));
            }
#endif  // CIDBG==1

            ScanScope( xScanInfo,
                       xScanInfo->LokIsRetry(),  // delay for retry
                       TRUE );                   // It's a refiled scan
        }
        else
        {
            xScanInfo.Free();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_Scan
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    1-25-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::_Scan()
{

    // does not THROW
    _cicat.DoUpdate( _scansInProgress, *this, _fAbortScan );

    // =============================================================
    {
        CLock   lock(_mutex);
        _LokEmptyInProgressScans();
        _fAbortScan = FALSE;
    }
    // =============================================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::_LokScheduleRemove
//
//  Synopsis:   Schedules a path for removal.
//
//  Arguments:  [pwscScope] - Scope to be removed from CiCat.
//
//  History:    1-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiScanMgr::_LokScheduleRemove( WCHAR const * pwcsScope )
{
    CCiScanInfo * pScanInfo = _QueryScanInfo( pwcsScope,
                                             _cicat.GetPartition(),
                                             UPD_INCREM, TRUE );
    XPtr<CCiScanInfo>   xScanInfo( pScanInfo );
    pScanInfo->LokSetDelScope();
    ScanScope( xScanInfo, FALSE, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::RemoveScope
//
//  Synopsis:   Removes the scope from any active or in-progress scans and
//              marks it for "deletions". If there is no active or in-progress
//              scan for the scope, a new "deletion scan" will be scheduled.
//
//  Arguments:  [pwcsScope] - The scope to be removed.
//
//  History:    1-25-96   srikants   Created
//
//  Notes:      This method must not only remove the scope from the scheduled
//              scans but also from any currently in-progress scans. It is
//              possible that the scan thread is currently working on the
//              path to be removed. In that case, we set the state of the
//              scope to indicate that it must be aborted.
//
//----------------------------------------------------------------------------

void CCiScanMgr::RemoveScope( WCHAR const * pwcsScope )
{
    //
    // if the given scope is in the list of paths being currently
    // scanned, we must mark it deleted.
    //
    BOOL fRemoved = FALSE;

    // ===========================================================
    {
        CLock   lock(_mutex);
        if ( _fAbort )
            return;

        for ( CFwdScanInfoIter scanInfoIter1( _scansToDo );
              !_scansToDo.AtEnd( scanInfoIter1 );
              _scansToDo.Advance( scanInfoIter1 ) )
        {
            WCHAR const * pwcsPath = scanInfoIter1->GetPath();

            if ( AreIdenticalPaths( pwcsScope, pwcsPath ) )
            {
                fRemoved = TRUE;
                if ( !scanInfoIter1->LokIsDelScope() )
                    scanInfoIter1->LokSetDelScope();
            }
        }

        //
        // Next see in the list of paths being currently scanned.
        //
        for ( CFwdScanInfoIter scanInfoIter2( _scansInProgress );
              !_scansInProgress.AtEnd( scanInfoIter2 );
              _scansInProgress.Advance( scanInfoIter2 ) )
        {
            WCHAR const * pwcsPath = scanInfoIter2->GetPath();

            if ( AreIdenticalPaths( pwcsScope, pwcsPath ) )
            {
                fRemoved = TRUE;

                if ( !scanInfoIter2->LokIsDelScope() )
                {
                    _fAbortScan = TRUE;
                    scanInfoIter2->LokSetDelScope();
                }
            }
        }

        if ( !fRemoved )
        {
            _LokScheduleRemove( pwcsScope );
            fRemoved = TRUE;
        }

        _evtScan.Set();     // wake up the scan thread.

        Win4Assert( fRemoved );
    }
    // ===========================================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::DisableScan
//
//  Synopsis:   Disables further scans and aborts any in progress.
//
//  History:    4-16-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::DisableScan()
{
    CLock   lock(_mutex);

    _fAbortScan   = TRUE;
    _fScanDisabled = TRUE;

    _evtScan.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::EnableScan
//
//  Synopsis:   Re-enables scanning if scanning is currently disabled.
//
//  History:    4-16-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiScanMgr::EnableScan()
{
    CLock   lock(_mutex);
    if ( _fScanDisabled )
    {
        _fScanDisabled = FALSE;
        _evtScan.Set();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiScanMgr::AnyInitialScans
//
//  Synopsis:   Checks if any scans are the result of a new scope
//
//  Returns:    TRUE if any scans are for new scopes
//
//  History:    3-Aug-98   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CCiScanMgr::AnyInitialScans()
{
    for ( CFwdScanInfoIter iter1( _scansToDo );
          !_scansToDo.AtEnd( iter1 );
          _scansToDo.Advance( iter1 ) )
    {
        if ( iter1->IsNewScope() )
            return TRUE;
    }

    for ( CFwdScanInfoIter iter2( _scansInProgress );
          !_scansInProgress.AtEnd( iter2 );
          _scansInProgress.Advance( iter2 ) )
    {
        if ( iter2->IsNewScope() )
            return TRUE;
    }

    return FALSE;
} //AnyInitialScans
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\signore.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-1999.
//
//  File:       signore.cxx
//
//  Contents:   CScopeIgnore methods
//
//  Classes:    CScopeIgnore
//
//  History:    3-1-98  mohamedn    created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "cicat.hxx"

//+-------------------------------------------------------------------------
//
//  Member:    CScopesIgnored::Enumerate(), public
//
//  Synopsis:  enumerates ignoredScopes table
//
//  Arguments: [pwcRoot] -- contains table entries upon return
//             [cwc]     -- buffer lenght of pwcRoot
//             [iBmk]    -- enumeration index
//
//  returns:   TRUE if pwcRoot contains valid table entry. FALSE otherwise.
//
//  History:   3-1-98  mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CScopesIgnored::Enumerate(WCHAR * pwcRoot, unsigned cwc, unsigned & iBmk )
{
    CReadAccess lock( _rwLock );

    while( iBmk <  _aElems.Count() )
    {
        if ( cwc < ( wcslen( _aElems[iBmk]->Get() ) + 1 ) )
            THROW( CException(STATUS_INVALID_PARAMETER ) );

        wcscpy( pwcRoot, _aElems[iBmk]->Get() );

        iBmk++;

        return TRUE;
    }

    return FALSE;
} //Enumerate

//+-------------------------------------------------------------------------
//
//  Member:    CScopesIgnored::RemoveElement(), public
//
//  Synopsis:  removes an element from ignoredScopes table
//
//  Arguments: [pwcScope]   -- scope to remove.
//
//  returns:   none.
//
//  History:   3-1-98  mohamedn    created
//
//--------------------------------------------------------------------------

void CScopesIgnored::RemoveElement(WCHAR const * pwcScope)
{
    CLowcaseBuf lowcaseBuf(pwcScope);

    CWriteAccess lock( _rwLock );

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
    {
        if ( lowcaseBuf.AreEqual(*_aElems[i]) )
        {
            delete _aElems.AcquireAndShrink(i);

            ConstructDFAObject();

            break;
        }
    }
} //RemoveElement

//+-------------------------------------------------------------------------
//
//  Member:    CScopesIgnored::RegExFind(), public
//
//  Synopsis:  finds a regular expression match for the passed in string.
//
//  Arguments: [bufToFind]   -- contains path to search for.
//
//  returns:   TRUE if path was found, FALSE otherwise.
//
//  History:   3-1-98  mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CScopesIgnored::RegExFind( CLowcaseBuf const & bufToFind )
{
    //
    // The DFA may be NULL if we failed to create it while adding or
    // removing a scope.
    //
    // This logic is complicated by the fact that we can't promote from a
    // read lock to a write lock.
    //

    do
    {
        if ( _xDFA.IsNull() )
        {
            CWriteAccess lock( _rwLock );

            if ( _xDFA.IsNull() )
                ConstructDFAObject();
        }

        CReadAccess lock( _rwLock );

        if ( 0 == _aElems.Count() )
            return FALSE;   // no excluded scopes to search

        if ( !_xDFA.IsNull() )
        {    
            BOOL fFound = _xDFA->Recognize( bufToFind.Get() );

            ciDebugOut(( DEB_ITRACE, "%ws is %s Found\n", bufToFind.Get(),
                         fFound ? "" : "not" ));

            return fFound;
        }
    } while ( TRUE );

    // Keep the compiler happy...

    return FALSE;
} //RegExFind

//+-------------------------------------------------------------------------
//
//  Member:     BOOL CScopesIgnored::ConstructDFAObject(), private
//
//  Synopsis:   Creates a new CDFA object
//
//  History:    3-1-98  mohamedn    created
//
//--------------------------------------------------------------------------

void CScopesIgnored::ConstructDFAObject(void)
{
    DWORD bufLen = 0;

    //
    // Generate a single buffer containing all excluded scopes.
    //

    for ( unsigned i = 0; i < _aElems.Count(); i++ )
        bufLen += _aElems[i]->Length() + 2;  // to account for "|," reg-x chars.

    bufLen++;       // null terminator.

    XGrowable<WCHAR>    xExcludeString(4*80);   // 4 lines by 80 wchars each.

    xExcludeString.SetSize(bufLen);

    for ( i = 0, xExcludeString[0] = L'\0' ; i < _aElems.Count(); i++ )
    {
        if ( i > 0 )
            wcscat( xExcludeString.Get(), L"|," );  // add a regX OR separator.

        wcscat( xExcludeString.Get(), _aElems[i]->Get() );
    }

    //
    // Create a new CDFA object, case insensitive with infinite timeout.
    //

    XPtr<CDFA> xDFA(new CDFA( xExcludeString.Get(), _tl, FALSE ) );

    _xDFA.Free();

    _xDFA.Set(xDFA.Acquire());

    ciDebugOut(( DEB_ITRACE, "New RegularExpression: %ws\n", xExcludeString.Get() ));
} //ConstructDFAObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\strings.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       Strings.cxx
//
//  Contents:   Strings and hash table used by cicat
//
//  History:    17-May-1993   BartoszM    Created
//              03-Jan-96     KyleP       Integrate with property cache
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>
#include <cistore.hxx>
#include <prpstmgr.hxx>
#include <propiter.hxx>
#include <propobj.hxx>
#include <pathpars.hxx>
#include <cievtmsg.h>
#include <eventlog.hxx>

#include "cicat.hxx"
#include "usntree.hxx"
#include "strings.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::CStrings, public
//
//  Synopsis:   Simple half of 2-phase construction
//
//  Arguments:  [PropStore] -- Property store.
//              [cicat]     -- Catalog
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CStrings::CStrings( CPropStoreManager & PropStoreMgr, CiCat & cicat )
        : CPersHash( PropStoreMgr, TRUE ),
          _cicat(cicat)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::FastInit
//
//  Synopsis:   Opens persistent hash.
//
//  Arguments:  [wcsCatDir] -- Catalog directory
//              [version]   -- Content index version
//
//  Returns:    TRUE if table was successfully opened.
//
//  History:    27-Dec-95   KyleP       Created.
//              13-Mar-98   KitmanH     Passed in False to CPerHash::FastInit
//                                      to specify that a PersHash is wanted
//
//----------------------------------------------------------------------------

BOOL CStrings::FastInit( CiStorage * pStorage,
                         ULONG version )
{
    CPersHash::FastInit( pStorage, version, FALSE );

    //
    // Intialize virtual/physical map.
    //
    _vmap.Init( pStorage->QueryVirtualScopeList( 0 ) );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::Empty
//
//  Synopsis:   Method to empty out any of the initialized members. This is
//              called if corruption is detected and so all resources must
//              be released.
//
//  History:    3-17-96   srikants   Created
//
//----------------------------------------------------------------------------

void CStrings::Empty()
{
    CPersHash::Empty();

    _vmap.Empty();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::LongInit
//
//  Synopsis:   Initialization that may take a long time
//
//  Arguments:  [version] -  The version of the compiled code.
//              [fDirtyShutdown] - Set to TRUE if the previous shutdown was
//              dirty.
//
//  History:    3-06-96   srikants   Created
//
//----------------------------------------------------------------------------

void CStrings::LongInit( ULONG version, BOOL fDirtyShutdown )
{
    CPersHash::LongInit( version, fDirtyShutdown );

    //
    // On a dirty shutdown, we should revirtualize because the property store
    // may have lost some of the changes made prior to shutdown.
    //
    if ( !_vmap.IsClean() || fDirtyShutdown )
    {
        ciDebugOut(( DEB_WARN, "Virtual mapping suspect.  ReVirtualizing...\n" ));
        ReVirtualize();
        _vmap.MarkClean();
    }
} //LongInit

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::ReInit, public
//
//  Synopsis:   Clears out hash table
//
//  Arguments:  [version]   -- Content index version
//
//  Returns:    TRUE if table was successfully opened.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CStrings::ReInit ( ULONG version )
{
    CPersHash::ReInit( version );

    return TRUE;
} //ReInit

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::LokAdd, public
//
//  Synopsis:   Add a new path without updating the hash table
//              or the persistent count
//
//  Arguments:  [pwcPath]         -- File path
//              [fileId]          -- file id for the file if available.
//              [fUsnVolume]      -- TRUE if the file is from a USN volume
//              [widParent]       -- widInvalid or the parent wid
//              [ulAttrib]        -- file attributes
//              [pftLastSeenTime] -- file last seen time
//
//  History:    19-May-93 BartoszM  Created
//
//--------------------------------------------------------------------------

WORKID CStrings::LokAdd(
    WCHAR const *    pwcPath,
    FILEID           fileId,
    BOOL             fUsnVolume,
    WORKID           widParent,
    ULONG            ulAttrib,
    FILETIME const * pftLastSeenTime )
{
    Win4Assert( _fFullInit );
    Win4Assert( 0 != pwcPath && wcslen(pwcPath) > 0 );
    Win4Assert( L':' == pwcPath[1] || (L'\\' == pwcPath[0] && L'\\' == pwcPath[1]) );

    //
    // Must grow hash table first, as it grovels through property store.
    //

    if ( _hTable.IsFull() )
        GrowHashTable();

    //
    // Store path in new record.
    //

    PROPVARIANT var;
    var.vt = VT_LPWSTR;
    var.pwszVal = (WCHAR *)pwcPath;

    WORKID wid = _PropStoreMgr.WritePropertyInNewRecord( pidPath,
                                                         *(CStorageVariant const *)(ULONG_PTR)&var );

    VOLUMEID volumeId = fUsnVolume ? _cicat.MapPathToVolumeId( pwcPath ) :
                                     CI_VOLID_USN_NOT_ENABLED;

    ciDebugOut(( DEB_ITRACE, "adding volume %#x %s file wid %#x, '%ws'\n",
                 volumeId,
                 fUsnVolume ? "usn" : "fat",
                 wid,
                 pwcPath ));

    if ( !fUsnVolume )
        _hTable.Add ( HashFun(pwcPath), wid );

    ULONG ulVPathId = _vmap.PhysicalPathToId( pwcPath );

    ULONG ulParentWid;
    if ( widInvalid == widParent)
    {
        //
        // If the parent is deleted by now, store the parent as widUnused
        // instead of widInvalid, in an attempt to avoid confusion.
        //

        ulParentWid = LokParentWorkId( pwcPath, fUsnVolume );

        if ( widInvalid == ulParentWid )
            ulParentWid = widUnused;
    }
    else
        ulParentWid = widParent;

    //
    // Open a composite property record for doing all the writes below
    //

    XWriteCompositeRecord rec( _PropStoreMgr, wid );

    //
    //  Initialize the SDID to avoid showing the file before it is
    //  filtered.
    //
    var.vt = VT_UI4;
    var.ulVal = sdidInvalid;
    SCODE sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                                   pidSecurity,
                                                   *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    //
    // Write the fileindex, and other default ntfs properties for non-ntfs 5.0 wids
    //
    var.vt = VT_UI8;
    var.uhVal.QuadPart = fileId;

    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidFileIndex,
                                             *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    var.vt = VT_UI4;
    var.ulVal = volumeId;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidVolumeId,
                                             *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    //
    // Write parent wid to prop store
    //

    var.ulVal = ulParentWid;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidParentWorkId,
                                             *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    //
    // Determine the virtual path.
    //

    var.ulVal = ulVPathId;
    var.vt = VT_UI4;
    sc = _PropStoreMgr.WriteProperty( rec.GetReference(),
                                      pidVirtualPath,
                                      *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));
    //ciDebugOut(( DEB_ITRACE, "%ws --> VPath %d\n", pwcPath, var.ulVal ));

    //
    // Init the last seen time
    //

    if ( 0 == pftLastSeenTime )
        RtlZeroMemory( &var.filetime, sizeof var.filetime );
    else
        var.filetime = *pftLastSeenTime;
    var.vt = VT_FILETIME;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidLastSeenTime,
                                             *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    //
    // Init the attributes
    //

    var.vt = VT_UI4;
    var.ulVal = ulAttrib;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidAttrib,
                                             *(CStorageVariant const *)(ULONG_PTR)&var );
    if (FAILED(sc))
        THROW(CException(sc));

    rec.Free();

    // Update both seen arrays so the new file isn't deleted at the end
    // of the scan.

    if ( _afSeenScans.Size() > 0 )
        SET_SEEN( &_afSeenScans, wid, SEEN_NEW );

    if ( _afSeenUsns.Size() > 0 )
        SET_SEEN( &_afSeenUsns, wid, SEEN_NEW );

    ciDebugOut(( DEB_ITRACE, "lokadd 0x%x, usn volume: %d\n", wid, fUsnVolume ));

    return wid;
} //LokAdd

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::LokDelete, public
//
//  Synopsis:   Delete string from table
//
//  Arguments:  [pwcPath]               -- Path of the document, in lower case
//              [wid]                   -- Workid to remove
//              [fDisableDeletionCheck] -- Should we assert that the deleted
//                                         entry must be found ?
//              [fUsnVolume]            -- TRUE if the file is on a USN volume
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStrings::LokDelete(
    WCHAR const * pwcPath,
    WORKID        wid,
    BOOL          fDisableDeletionCheck,
    BOOL          fUsnVolume )
{
    XGrowable<WCHAR> awc;
    WCHAR const * pwcName = awc.Get();
    BOOL fFound = TRUE;

    if ( !fUsnVolume )
    {
        if ( 0 != pwcPath )
        {
            AssertLowerCase( pwcPath, 0 );
            pwcName = pwcPath;
        }
        else
        {
            fFound = (Find( wid, awc) > 0);
            pwcName = awc.Get();
        }
    }

    if ( fFound )
    {
        _PropStoreMgr.DeleteRecord( wid );
        ciDebugOut(( DEB_ITRACE, "LokDelete 0x%x, usn %d\n", wid, fUsnVolume ));

        if ( !fUsnVolume )
        {
            Win4Assert( 0 != pwcName );
            _hTable.Remove( HashFun( pwcName ), wid, fDisableDeletionCheck );
        }
    }
} //LokDelete

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::LokRenameFile
//
//  Synopsis:   Rename old file to new file
//
//  Arguments:  [pwcsOldFileName] -- Old file name as a funny path or remote path
//              [pwcsNewFileName] -- New file name as a funny path or remote path
//              [ulFileAttib]     -- File attributes of new file
//              [volumeId]        -- Volume id
//
//  History:    20-Mar-96     SitaramR       Created
//
//----------------------------------------------------------------------------

void CStrings::LokRenameFile(
    const WCHAR * pwcsOldFileName,
    const WCHAR * pwcsNewFileName,
    WORKID        wid,
    ULONG         ulFileAttrib,
    VOLUMEID      volumeId,
    WORKID        widParent )
{
    Win4Assert( L':' == pwcsNewFileName[1] ||
                (L'\\' == pwcsNewFileName[0] && L'\\' == pwcsNewFileName[1]) );

    ciDebugOut(( DEB_FSNOTIFY,
                 "CStrings: Renaming file (%ws) to (%ws)\n",
                 pwcsOldFileName,
                 pwcsNewFileName ));

    BOOL fUsnVolume = ( CI_VOLID_USN_NOT_ENABLED != volumeId );

    PROPVARIANT propVar;

    if ( widInvalid == wid )
    {
        ciDebugOut(( DEB_ITRACE, "adding '%ws' via the rename path\n", pwcsNewFileName ));
        wid = LokAdd( pwcsNewFileName, fileIdInvalid, fUsnVolume, widParent );

        propVar.vt = VT_UI4;
        propVar.ulVal = ulFileAttrib;
        SCODE sc = _PropStoreMgr.WritePrimaryProperty( wid,
                                                       pidAttrib,
                                                       *(CStorageVariant const *)(ULONG_PTR)&propVar );
        if (FAILED(sc))
            THROW(CException(sc));

        return;
    }


    // Files from USN volumes aren't in this hash table

    if ( !fUsnVolume )
    {
        _hTable.Remove( HashFun(pwcsOldFileName), wid, FALSE );
        _hTable.Add(  HashFun(pwcsNewFileName), wid );
    }

    if ( widInvalid == widParent )
        widParent =  LokParentWorkId( pwcsNewFileName, fUsnVolume );

    XWriteCompositeRecord rec( _PropStoreMgr, wid );

    propVar.vt = VT_LPWSTR;
    propVar.pwszVal = (WCHAR*)pwcsNewFileName;
    SCODE sc = _PropStoreMgr.WriteProperty( rec.GetReference(),
                                            pidPath,
                                            *(CStorageVariant const *)(ULONG_PTR)&propVar );

    if (FAILED(sc))
        THROW(CException(sc));

    propVar.vt = VT_UI4;
    propVar.ulVal = _vmap.PhysicalPathToId( pwcsNewFileName );
    sc = _PropStoreMgr.WriteProperty( rec.GetReference(),
                                      pidVirtualPath,
                                      *(CStorageVariant const *)(ULONG_PTR)&propVar );

    if (FAILED(sc))
        THROW(CException(sc));

    propVar.ulVal = ulFileAttrib;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidAttrib,
                                             *(CStorageVariant const *)(ULONG_PTR)&propVar );
    if (FAILED(sc))
        THROW(CException(sc));

    propVar.ulVal = widParent;
    sc = _PropStoreMgr.WritePrimaryProperty( rec.GetReference(),
                                             pidParentWorkId,
                                             *(CStorageVariant const *)(ULONG_PTR)&propVar );
    if (FAILED(sc))
        THROW(CException(sc));
} //LokRenameFile

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::HashAll, public
//
//  Synopsis:   Re-hash all strings (after hash table growth)
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStrings::HashAll()
{
    XGrowable<WCHAR> awc;

    // Count the number of hash table entries and grow the hash table

    {
        CPropertyStoreWids iter( _PropStoreMgr );
        unsigned cWids = 0;

        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
        {
            if ( _fAbort )
            {
                ciDebugOut(( DEB_WARN,
                             "Stopping HashAll because of shutdown\n" ));
                THROW( CException(STATUS_TOO_LATE) );
            }

            //
            // Files from USN volumes aren't in the strings table
            //

            PROPVARIANT var;
            if ( _PropStoreMgr.ReadPrimaryProperty( wid, pidFileIndex, var ) &&
                 ( VT_UI8 == var.vt ) &&
                 ( fileIdInvalid != var.uhVal.QuadPart ) )
                continue;

            //
            // It is possible to have a top-level wid in the propstore without
            // a pidPath. This can happen if the system crashes in the middle of
            // WritePropertyInNewRecord, when a new top-level wid has been created
            // but pidPath hasn't yet been written.
            //

            if ( Find( wid, awc ) > 0 )
                cWids++;
            else
                _PropStoreMgr.DeleteRecord( wid );
        }

        GrowToSize( cWids );
    }

    // Add the wids to the hash table

    CPropertyStoreWids iter( _PropStoreMgr );

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
    {
        if ( _fAbort )
        {
            ciDebugOut(( DEB_WARN,
                         "Stopping HashAll because of shutdown\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        //
        // Files from USN volumes aren't in the strings table
        //

        PROPVARIANT var;
        if ( _PropStoreMgr.ReadPrimaryProperty( wid, pidFileIndex, var ) &&
             ( VT_UI8 == var.vt ) &&
             ( fileIdInvalid != var.uhVal.QuadPart ) )
            continue;

        //
        // It is possible to have a top-level wid in the propstore without
        // a pidPath. This can happen if the system crashes in the middle of
        // WritePropertyInNewRecord, when a new top-level wid has been created
        // but pidPath hasn't yet been written.
        //
        if ( Find( wid, awc ) > 0 )
            _hTable.Add ( HashFun( awc.Get() ), wid );
        else
            _PropStoreMgr.DeleteRecord( wid );
    }
} //HashAll

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::AddVirtualScope, public
//
//  Synopsis:   Add new virtual/physical path mapping
//
//  Arguments:  [vroot]      -- Virtual path
//              [root]       -- Physical path
//              [fAutomatic] -- TRUE for root tied to Gibraltar
//              [eType]      -- root type
//              [fVRoot]     -- TRUE if a vroot, not a vdir
//              [fIsIndexed] -- TRUE if should be indexed, FALSE otherwise
//
//  Returns:    TRUE if a change was made.
//
//  History:    05-Feb-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CStrings::AddVirtualScope(
    WCHAR const * vroot,
    WCHAR const * root,
    BOOL          fAutomatic,
    CiVRootTypeEnum eType,
    BOOL          fVRoot,
    BOOL          fIsIndexed )
{
    ULONG idNew;

    if ( _vmap.Add( vroot, root, fAutomatic, idNew, eType, fVRoot, fIsIndexed ) )
    {
        //
        // Log event
        //

        if ( fVRoot && fIsIndexed )
        {
            CEventLog eventLog( NULL, wcsCiEventSource );
            CEventItem item( EVENTLOG_INFORMATION_TYPE,
                             CI_SERVICE_CATEGORY,
                             MSG_CI_VROOT_ADDED,
                             2 );

            item.AddArg( vroot );
            item.AddArg( root );

            eventLog.ReportEvent( item );
        }

        //
        // Add new virtual root to all appropriate objects.
        //

#if CIDBG == 1
        if ( ciInfoLevel & DEB_ITRACE )
        {
            // only directories should have virtual root identifiers
            // of 0xffffffff

            CPropertyStoreWids iter( _PropStoreMgr );
            PROPVARIANT var;
            unsigned cb = 0;
            unsigned cb2 = 0;
            XGrowable<WCHAR> wcPhysPath;
            for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
            {
                if ( _PropStoreMgr.ReadProperty( wid, pidVirtualPath, var, 0, &cb ) &&
                     VT_EMPTY != var.vt &&
                     0xffffffff == var.ulVal &&
                     _PropStoreMgr.ReadProperty( wid, pidAttrib, var, 0, &cb2 ) &&
                     VT_EMPTY != var.vt &&
                     ( 0 == ( var.ulVal & FILE_ATTRIBUTE_DIRECTORY ) ) )
                {
                    Find( wid, wcPhysPath );

                    ciDebugOut(( DEB_ITRACE, "vid 0xffffffff wid 0x%x, path '%ws'\n",
                                 wid, wcPhysPath.Get() ));
                }
            }
        }
#endif // CIDBG == 1

        ULONG idParent = _vmap.Parent( idNew );

        ciDebugOut(( DEB_ITRACE, "idParent 0x%x, idnew 0x%x\n", idParent, idNew ));

        CStorageVariant varNew;
        varNew.SetUI4( idNew );
        Win4Assert( 0xffffffff != idNew );

        CPropertyStoreWids iter( _PropStoreMgr );
        XGrowable<WCHAR> wcPhysPath;

        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
        {
            PROPVARIANT var;
            unsigned cb = 0;

            //
            // Check if the vdir should be changed to the new one
            //

            if ( _PropStoreMgr.ReadProperty( wid, pidVirtualPath, var, 0, &cb ) &&
                 ( VT_EMPTY == var.vt ||
                   var.ulVal == idParent ||
                   ( _vmap.IsNonIndexedVDir( var.ulVal ) &&
                     idNew != _vmap.GetExcludeParent( var.ulVal ) ) ) )
            {
                unsigned cc = Find( wid, wcPhysPath );

                Win4Assert( cc > 0 );

                if ( cc > 0 )
                {
                    if ( _vmap.IsInPhysicalScope( idNew, wcPhysPath.Get(), cc ) )
                    {
                        ciDebugOut(( DEB_ITRACE, "add, %.*ws 0x%x --> VPath 0x%x\n",
                                     cc, wcPhysPath, var.ulVal, idNew ));
                        SCODE sc = _PropStoreMgr.WriteProperty( wid,
                                                                pidVirtualPath,
                                                                varNew );
                        if (FAILED(sc))
                            THROW(CException(sc));
                    }
                }
            }
            else
            {
                // ciDebugOut(( DEB_ITRACE, "ignoring id %d, isnivd %d\n",
                //              var.ulVal, _vmap.IsNonIndexedVDir( var.ulVal ) ));
            }
        }

        _vmap.MarkClean();

        return TRUE;
    }
    else
        return FALSE;
} //AddVirtualScope

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::RemoveVirtualScope, public
//
//  Synopsis:   Remove virtual/physical path mapping
//
//  Arguments:  [vroot]             -- Virtual path
//              [fOnlyIfAutomatic]  -- If TRUE, then a manual root will not
//                                     be removed
//              [eType]             -- type of root
//              [fVRoot]            -- TRUE if a vroot, FALSE if a vdir
//              [fForceVPathFixing] -- forces fixups of removed vpaths
//
//  History:    05-Feb-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CStrings::RemoveVirtualScope( WCHAR const * vroot,
                                   BOOL fOnlyIfAutomatic,
                                   CiVRootTypeEnum eType,
                                   BOOL fVRoot,
                                   BOOL fForceVPathFixing )
{
    ULONG idOld, idNew;

    if ( _vmap.Remove( vroot, fOnlyIfAutomatic, idOld, idNew, eType, fVRoot ) ||
         fForceVPathFixing )
    {
        //
        // Log event
        //

        if ( fVRoot )
        {
            CEventLog eventLog( NULL, wcsCiEventSource );
            CEventItem item( EVENTLOG_INFORMATION_TYPE,
                             CI_SERVICE_CATEGORY,
                             MSG_CI_VROOT_REMOVED,
                             1 );

            item.AddArg( vroot );

            eventLog.ReportEvent( item );
        }

        //
        // Swap virtual root to all appropriate objects.
        //

#if CIDBG == 1
        if ( ciInfoLevel & DEB_ITRACE )
        {
            // only directories should have virtual root identifiers
            // of 0xffffffff

            CPropertyStoreWids iter( _PropStoreMgr );
            PROPVARIANT var;
            unsigned cb = 0;
            unsigned cb2 = 0;
            XGrowable<WCHAR> wcPhysPath;
            for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
            {
                if ( _PropStoreMgr.ReadProperty( wid, pidVirtualPath, var, 0, &cb ) &&
                     VT_EMPTY != var.vt &&
                     0xffffffff == var.ulVal &&
                     _PropStoreMgr.ReadProperty( wid, pidAttrib, var, 0, &cb2 ) &&
                     VT_EMPTY != var.vt &&
                     ( 0 == ( var.ulVal & FILE_ATTRIBUTE_DIRECTORY ) ) )
                {
                    Find( wid, wcPhysPath );

                    ciDebugOut(( DEB_ITRACE, "vid 0xffffffff wid 0x%x, path '%ws'\n",
                                 wid, wcPhysPath.Get() ));
                }
            }
        }
#endif // CIDBG == 1

        CStorageVariant varNew;
        varNew.SetUI4( idNew );

        CPropertyStoreWids iter( _PropStoreMgr );

        BOOL fIsNewExcludeParent = _vmap.IsAnExcludeParent( idNew );
        SCODE sc;

        XGrowable<WCHAR> wcPhysPath;
        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
        {
            PROPVARIANT var;
            unsigned cb = 0;

            //
            // No existing virtual root, or possibility of replacement
            //

            if ( _PropStoreMgr.ReadProperty( wid, pidVirtualPath, var, 0, &cb ) &&
                 var.vt == VT_UI4 && var.ulVal == idOld )
            {
                // If the new vpath has child non-indexed vdirs, the vdir
                // needs to be recomputed from scratch, otherwise, just use
                // the new id.

                if ( fIsNewExcludeParent )
                {
                    BOOL fFound = (Find( wid, wcPhysPath ) > 0);

                    Win4Assert( fFound );

                    if ( fFound )
                    {
                        ULONG idBest = _vmap.PhysicalPathToId( wcPhysPath.Get() );

                        ciDebugOut(( DEB_ITRACE, "removeA: %ws 0x%x --> 0x%x\n",
                                     wcPhysPath, idOld, idBest ));

                        CStorageVariant varNew;
                        varNew.SetUI4( idBest );
                        sc = _PropStoreMgr.WriteProperty( wid,
                                                          pidVirtualPath,
                                                          varNew );
                        if (FAILED(sc))
                            THROW(CException(sc));
                    }
                }
                else
                {
                    #if CIDBG == 1
                        if ( ciInfoLevel & DEB_ITRACE )
                        {
                            XGrowable<WCHAR> wcPhysPath;
                            unsigned cc = Find( wid, wcPhysPath );
                            ciDebugOut(( DEB_ITRACE,
                                         "removeB %.*ws 0x%x --> VPath 0x%x\n",
                                         cc, wcPhysPath.Get(), idOld, idNew ));
                        }
                    #endif // CIDBG == 1

                    sc = _PropStoreMgr.WriteProperty( wid,
                                                      pidVirtualPath,
                                                      varNew );

                    if (FAILED(sc))
                        THROW(CException(sc));
                }
            }
        }

        _vmap.MarkClean();

        return TRUE;
    }
    else
        return FALSE;
} //RemoveVirtualScope

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::FindVirtual, private
//
//  Synopsis:   Given workid, find virtual path.  Version which uses pre-opened
//              property record.
//
//  Arguments:  [PropRec] -- Pre-opened property record.
//              [cSkip]   -- Count of paths to skip.
//              [xBuf]    -- String returned here
//
//  Returns:    0 if string not found ELSE
//              Count of chars in xBuf
//
//  Note:       xBuf is returned as a NULL terminated string
//
//  History:    29-Apr-96   AlanW       Created.
//
//--------------------------------------------------------------------------

unsigned CStrings::FindVirtual(
    CCompositePropRecord & PropRec,
    unsigned cSkip,
    XGrowable<WCHAR> & xBuf )
{
    PROPVARIANT var;
    unsigned cb = 0;
    unsigned cc = 0;

    if ( _PropStoreMgr.ReadProperty( PropRec, pidVirtualPath, var, 0, &cb ) &&
         VT_UI4 == var.vt )
    {
        //
        // Skip the specified number of virtual paths.
        //

        ULONG id = _vmap.FindNthRemoved( var.ulVal, cSkip );

        //
        // Were there that many possible paths?
        //

        if (  0xFFFFFFFF != id )
        {
            //
            // There are two cases for building the path.
            //
            //                 \short\vpath
            //             c:\physical\path
            //     \vpath\longer\than\ppath
            //
            // If the virtual path is *longer* than the physical path, then we can just
            // copy the full physical path starting at such an offset that the virtual
            // path can be blasted on top.
            //
            // If the virtual path is *shorter* than the physical path, then we need
            // to fetch the physical path and shift it left.
            //

            CVMapDesc const & VDesc = _vmap.GetDesc( id );

            // This is either a non-indexed virtual directory
            // or the vdesc has just been marked as not in use
            // though it was in use at the time of FindNthRemoved above.
            // Either way, there is no vpath mapping.
            //
            if ( !VDesc.IsInUse() )
            {
                return 0;
            }

            // NTRAID#DB-NTBUG9-83796-2000/07/31-dlee handling changed vroots can AV if more changes come later.
            // VDesc can go stale or be reused at any time, since
            // it's being used with no lock held.  We may AV in
            // some cases here.

            unsigned ccVPath = VDesc.VirtualLength();
            unsigned ccPPath = VDesc.PhysicalLength();

            if ( ccVPath >= ccPPath )
            {
                unsigned delta = ccVPath - ccPPath;
                XGrowable<WCHAR> xTemp;
                unsigned ccIn = Find( PropRec, xTemp );

                if ( ccIn > 0 )
                {
                    xBuf.SetSize( delta + ccIn + 1 );
                    RtlCopyMemory( xBuf.Get() + delta, xTemp.Get(), ccIn * sizeof( WCHAR ) );

                    Win4Assert( ccIn >= ccPPath );
                    Win4Assert( RtlEqualMemory( xBuf.Get() + delta, VDesc.PhysicalPath(), ccPPath * sizeof(WCHAR) ) );

                    RtlCopyMemory( xBuf.Get(),
                                   VDesc.VirtualPath(),
                                   ccVPath * sizeof(WCHAR) );

                    // Null-terminate
                    //
                    Win4Assert( xBuf.Count() > ccIn + delta );
                    xBuf[cc = ccIn + delta] = 0;
                }
            }
            else
            {
                unsigned delta = ccPPath - ccVPath;
                unsigned ccIn = Find( PropRec, xBuf );

                if ( ccIn >= ccPPath )
                {
                    RtlMoveMemory( xBuf.Get() + ccVPath,
                                   xBuf.Get() + ccPPath,
                                   (ccIn - ccPPath) * sizeof(WCHAR) );
                    RtlCopyMemory( xBuf.Get(),
                                   VDesc.VirtualPath(),
                                   ccVPath * sizeof(WCHAR) );

                    //
                    // Null-terminate
                    //
                    Win4Assert( xBuf.Count() > ccIn - delta );
                    xBuf[cc = ccIn - delta] = 0;
                }
            }
        }
    }
    return cc;
} //FindVirtual

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::ReVirtualize, private
//
//  Synopsis:   Verify or correct all virtual mappings.
//
//  History:    14-Feb-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStrings::ReVirtualize()
{
    //
    // Loop through property cache and verify virtual mapping.
    //

    CPropertyStoreWids iter( _PropStoreMgr );
    XGrowable<WCHAR> wcPhysPath;

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
    {
        //
        // Get path.
        //


        unsigned cc = Find( wid, wcPhysPath );

        //
        // Get existing virtual root.
        //

        PROPVARIANT var;
        unsigned cb = 0;

        if ( cc > 0 && _PropStoreMgr.ReadProperty( wid, pidVirtualPath, var, 0, &cb ) )
        {
            //
            // Do we need to change?
            //

            wcPhysPath[cc] = 0;
            ULONG idNew = _vmap.PhysicalPathToId( wcPhysPath.Get() );

            if ( var.vt == VT_EMPTY || var.ulVal != idNew )
            {
                ciDebugOut(( DEB_ITRACE, "ReVirtualize: %ws --> %u\n", wcPhysPath.Get(), idNew ));

                CStorageVariant varNew;
                varNew.SetUI4( idNew );

                SCODE sc = _PropStoreMgr.WriteProperty( wid,
                                                        pidVirtualPath,
                                                        varNew );
                if (FAILED(sc))
                    THROW(CException(sc));
            }
        }
    }
} //ReVirtualize

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::HashFun, private
//
//  Synopsis:   The hash function used to find strings in _strings[]
//
//  Arguments:  [str] - the string to perform the hash function on
//
//  History:    10-Mar-92 BartoszM  Created
//
//--------------------------------------------------------------------------

unsigned CStrings::HashFun( WCHAR const * pc )
{
    unsigned ulG;

    for ( unsigned ulH=0; *pc; pc++)
    {
        ulH = (ulH << 4) + (*pc);
        if (ulG = (ulH & 0xf0000000))
            ulH ^= ulG >> 24;
        ulH &= ~ulG;
    }

    return ulH;
}


//+-------------------------------------------------------------------------
//
//  Member:     CStrings::LokFind
//
//  Synopsis:   Given string, find workid. This works only for FAT volumes.
//
//  Arguments:  [buf] - String to locate
//
//  Returns:    Workid of [buf]
//
//  History:    27-Dec-95   KyleP       Created.
//
//--------------------------------------------------------------------------

WORKID CStrings::LokFind( WCHAR const * buf )
{
    Win4Assert( _fFullInit );
    Win4Assert( 0 != buf );
    Win4Assert( FALSE == _cicat.IsOnUsnVolume( buf ) );

#ifdef DO_STATS
    unsigned cSearchLen = 0;
#endif  // DO_STATUS

    CShortWidList list( HashFun(buf), _hTable );

    unsigned ccIn = wcslen(buf);

    //Win4Assert( ccIn < MAX_PATH );

    for ( WORKID wid = list.WorkId(); wid != widInvalid; wid = list.NextWorkId() )
    {
        PROPVARIANT var;
        XGrowable<WCHAR> wcTemp;
        //unsigned cc = sizeof(wcTemp) / sizeof(WCHAR);

        // don't even try to find paths that are longer than ccIn
        // account for quad-word align and null-termination by adding 4

        unsigned cc = Find( wid, wcTemp );

#ifdef DO_STATS
        cSearchLen++;
#endif  // DO_STATS



        // Win4Assert( cc <= sizeof(wcTemp) / sizeof(WCHAR) );

        if ( ccIn == cc && RtlEqualMemory( buf, wcTemp.Get(), cc * sizeof(WCHAR) ) )
        {
#ifdef DO_STATS
            _hTable.UpdateStats( cSearchLen );
#endif  // DO_STATS
            return wid;
        }
    }

    return widInvalid;
} //LokFind

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::LokFind
//
//  Synopsis:   Given string, find workid. This works for both FAT and NTFS.
//
//  Arguments:  [lcaseFunnyPath] - Path to locate
//              [fUsnVolume] - Flag to tell whether it's a USN volume or not
//
//  Returns:    Workid of [lcaseFunnyPath]
//
//  History:    18-Aug-98   VikasMan       Created.
//
//--------------------------------------------------------------------------

// inline
WORKID CStrings::LokFind( const CLowerFunnyPath & lcaseFunnyPath, BOOL fUsnVolume )
{
    return ( fUsnVolume ?
                _cicat.PathToWorkId ( lcaseFunnyPath, FALSE ) :
                LokFind( lcaseFunnyPath.GetActualPath() ) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given workid, find the path string.
//
//  Arguments:  [wid]  -- Workid to locate
//              [xBuf] -- String returned here
//
//  Returns:    0 if string not found ELSE
//              Count of chars in xBuf
//
//  Note:       xBuf is returned as a NULL terminated string
//
//  History:    27-Dec-95   KyleP       Created.
//
//--------------------------------------------------------------------------

unsigned CStrings::Find( WORKID wid, XGrowable<WCHAR> & xBuf )
{
    CCompositePropRecord PropRec( wid, _PropStoreMgr );

    return Find( PropRec, xBuf );
} //Find


//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given PropRec, find the path string.
//
//  Arguments:  [PropRec]  -- Property Record
//              [xBuf]     -- String returned here
//
//  Returns:    0 if string not found ELSE
//              Count of chars in xBuf
//
//  Note:       xBuf is returned as a NULL terminated string
//
//  History:    27-Dec-95   KyleP       Created.
//
//--------------------------------------------------------------------------
unsigned CStrings::Find( CCompositePropRecord & PropRec, XGrowable<WCHAR> & xBuf )
{
    unsigned cc = xBuf.Count();

    _Find( PropRec, xBuf.Get(), cc );

    if ( cc > xBuf.Count() )
    {
        // Need more space
        xBuf.SetSize( cc );
        _Find( PropRec, xBuf.Get(), cc );

        // Can't go on asking for more space forever !
        Win4Assert( cc < xBuf.Count() );
    }

    // Either we didn't find or if we did, then it is null terminated
    Win4Assert( 0 == cc || 0 == xBuf[cc] );

    return cc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given workid, find the path string.
//
//  Arguments:  [wid]         -- Workid to locate
//              [funnyPath]   -- String returned here, as funnyPath
//
//  Returns:    0 if string not found ELSE
//              Count of actual chars in funnyPath
//
//  History:    21-May-98   VikasMan    Created.
//
//--------------------------------------------------------------------------
unsigned CStrings::Find( WORKID wid, CFunnyPath & funnyPath )
{
    CCompositePropRecord PropRec( wid, _PropStoreMgr );

    return Find( PropRec, funnyPath );
} //Find

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given workid, find the path string.
//
//  Arguments:  [wid]             -- Workid to locate
//              [lcaseFunnyPath]  -- String returned here, as lcase funnyPath
//
//  Returns:    0 if string not found ELSE
//              Count of actual chars in funnyPath
//
//  History:    21-May-98   VikasMan    Created.
//
//--------------------------------------------------------------------------
unsigned CStrings::Find( WORKID wid, CLowerFunnyPath & lcaseFunnyPath )
{
    CCompositePropRecord PropRec( wid, _PropStoreMgr );

    return Find( PropRec, lcaseFunnyPath );
} //Find

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given PropRec, find the path string.
//
//  Arguments:  [PropRec]     -- Property Record
//              [funnyPath]   -- String returned here, as funnyPath
//
//  Returns:    0 if string not found ELSE
//              Count of actual chars in funnyPath
//
//  History:    21-May-98   VikasMan    Created.
//
//--------------------------------------------------------------------------
unsigned CStrings::Find( CCompositePropRecord & PropRec, CFunnyPath & funnyPath )
{
    XGrowable<WCHAR, MAX_PATH> xBuf;
    unsigned cc = Find( PropRec, xBuf );
    if ( cc > 0 )
    {
        funnyPath.SetPath( xBuf.Get(), cc );
    }
    return cc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Given PropRec, find the path string.
//
//  Arguments:  [PropRec]         -- Property Record
//              [lcaseFunnyPath]  -- String returned here, as lcase funnyPath
//
//  Returns:    0 if string not found ELSE
//              Count of actual chars in funnyPath
//
//  History:    21-May-98   VikasMan    Created.
//
//--------------------------------------------------------------------------
unsigned CStrings::Find( CCompositePropRecord & PropRec, CLowerFunnyPath & lcaseFunnyPath )
{
    XGrowable<WCHAR, MAX_PATH> xBuf;
    unsigned cc = Find( PropRec, xBuf );
    if ( cc > 0 )
    {
        lcaseFunnyPath.SetPath( xBuf.Get(), cc, TRUE );
    }
    return cc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::_Find, private
//
//  Synopsis:   Given workid, find string.  Version which uses pre-opened
//              property record.
//
//  Arguments:  [PropRec] -- Pre-opened property record.
//              [buf]     -- String returned here
//              [cc]      -- On input: size in WCHARs of [buf].  On output,
//                           size required or 0 if string not found.
//
//  History:    03-Apr-96   KyleP       Created.
//
//--------------------------------------------------------------------------

void CStrings::_Find( CCompositePropRecord & PropRec, WCHAR * buf, unsigned & cc )
{
#if 0
    //
    // First try to get the path based on file id and volume id.
    // This only works for files on USN volumes.  Paths from files on USN
    // volumes aren't in the property cache.
    // Sure, this makes FAT lookups slower, but that's the way it goes.
    //

    VOLUMEID volumeId;
    FILEID fileId;

    if ( _cicat.PropertyRecordToFileId( PropRec, fileId, volumeId ) )
    {
        // PropertyRecordToFileId doesn't return a fileid without a volumeid

        Win4Assert( CI_VOLID_USN_NOT_ENABLED != volumeId );

        _cicat.FileIdToPath( fileId, volumeId, buf, cc );
        return;
    }
#endif

    PROPVARIANT var;
    const unsigned cbIn = cc * sizeof(WCHAR);
    unsigned cb = cbIn;

    if ( !_PropStoreMgr.ReadProperty( PropRec, pidPath, var, (BYTE *)buf, &cb ) )
        cc = 0;
    else
    {
        if ( cb <= cbIn )
        {
            Win4Assert( (buf == var.pwszVal && VT_LPWSTR == var.vt) || VT_EMPTY == var.vt);

            //
            // Length returned from ReadProperty may be the QWORD-ALIGNED length.
            // Must adjust to the real length, which will be sans terminating
            // null, and maybe a few bytes more.
            //

            if ( VT_LPWSTR == var.vt )
            {
                //Win4Assert( 0 == (cb & 7) );
                //Win4Assert( cb >= sizeof(LONGLONG) );

                if ( cb < sizeof(LONGLONG) )
                {
                    cc = cb / sizeof(WCHAR) - 1;  // -1 for null
                }
                else
                {
                    cc = cb / sizeof(WCHAR);
                    cc -= sizeof(LONGLONG)/sizeof(WCHAR);

                    while ( 0 != buf[cc] )
                        cc++;
                }

                Win4Assert( 0 == buf[cc] );
                Win4Assert( 0 != buf[cc-1] );
            }
            else
            {
                buf[0] = 0;
                cc = 0;
            }
        }
        else
        {
            //
            // The buffer is not big enough.
            //
            cc = cb/sizeof(WCHAR);
        }
    }
} //Find


//+---------------------------------------------------------------------------
//
//  Member:     CStrings::Find
//
//  Synopsis:   Get the last seen time for the given wid.
//
//  Arguments:  [wid]        -
//              [ftLastSeen] -
//
//  History:    3-19-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CStrings::Find( WORKID wid, FILETIME & ftLastSeen )
{
    PROPVARIANT var;
    unsigned cb;

    BOOL fFound = _PropStoreMgr.ReadPrimaryProperty( wid, pidLastSeenTime, var );
    if ( fFound && ( VT_FILETIME == var.vt ) )
        ftLastSeen = var.filetime;
    else
        RtlZeroMemory( &ftLastSeen, sizeof(ftLastSeen) );

    return fFound;
} //Find

//+-------------------------------------------------------------------------
//
//  Member:     CStrings::BeginSeen, public
//
//  Synopsis:   Begin 'seen' processing.
//
//  Arguments:  [pwcRoot] -- Root path of the seen processing
//              [mutex]   -- Cicat mutex
//              [eType]   -- Seen array type
//
//  History:    27-Dec-95   KyleP       Created
//
//--------------------------------------------------------------------------

void CStrings::BeginSeen(
    WCHAR const *  pwcsRoot,
    CMutexSem &    mutex,
    ESeenArrayType eType )
{
    ciDebugOut(( DEB_ITRACE, "BeginSeen 0x%x\n", eType ));

    //
    // Return time of last *seen* and update to current time.
    //

    CDynArrayInPlace<BYTE> *pafSeen;
    if ( eType == eScansArray )
        pafSeen = &_afSeenScans;
    else
        pafSeen = &_afSeenUsns;

    //
    // Set array.
    //

    CPropertyStoreWids iter( _PropStoreMgr );
    WORKID widIgnore = 0;

    //
    // For doing scope testing.
    //
    ULONG cwcScope =  0 != pwcsRoot ? wcslen(pwcsRoot) : 0;

    CScopeMatch scopeTest( pwcsRoot, cwcScope );

    XGrowable<WCHAR> wcsPath;

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.NextWorkId() )
    {
        CLock   lock(mutex);    // Protect "seen" array.

        if ( _fAbort )
        {
            ciDebugOut(( DEB_WARN,
                         "Stopping BeginSeen because of shutdown\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        //
        // Ignore any missing entries.
        //

        for ( ; widIgnore < wid; widIgnore++ )
            SET_SEEN( pafSeen, widIgnore, SEEN_IGNORE );

        widIgnore++;

        unsigned cc = Find( wid, wcsPath );
        if ( 0 == cc || scopeTest.IsInScope( wcsPath.Get(), cc ) )
            SET_SEEN( pafSeen, wid, SEEN_NOT );
        else
            SET_SEEN( pafSeen, wid, SEEN_YES );
    }

    CLock lock( mutex );        // Protect "seen" array
    for ( ; widIgnore < _PropStoreMgr.MaxWorkId(); widIgnore++ )
        SET_SEEN( pafSeen, widIgnore, SEEN_IGNORE );

    // At the point EndSeen is called, the size of the seen array must
    // be non-zero. if it is not non-zero, set it to be so.

    if (0 == pafSeen->Size())
        pafSeen->SetSize( 10 );

    Win4Assert( pafSeen->Size() > 0 );
} //BeginSeen

//+---------------------------------------------------------------------------
//
//  Member:     CStrings::LokParentWorkId
//
//  Synopsis:   Returns parent workid of given file
//
//  Arguments:  [pwcsFileName] -- File name
//
//  History:    23-Jun-97     SitaramR       Created
//              01-Sep-97     EmilyB         Physical drive roots (c:\) and
//                                           UNC roots (\\emilyb\d) have
//                                           no parent.
//
//----------------------------------------------------------------------------

WORKID CStrings::LokParentWorkId( WCHAR const * pwcsFileName, BOOL fUsnVolume )
{
    //
    // return widInvalid if we're at root of physical drive
    //
    unsigned cwcEnd = wcslen( pwcsFileName ) - 1 ;

    if (cwcEnd < 3)
        return widInvalid; // physical drive root has no parent

    //
    // backup from end of filename to last \ to get parent
    //
    while ( pwcsFileName[cwcEnd] != L'\\'  && cwcEnd > 1)
        cwcEnd--;

    CLowerFunnyPath lcaseFunnyParent;
    lcaseFunnyParent.SetPath( pwcsFileName, cwcEnd );

    //
    // Find parent's wid
    //
    WORKID widParent = LokFind( lcaseFunnyParent, fUsnVolume );

    if (widInvalid == widParent) // if parent didn't have wid, then create one
    {
        //
        // check if we're at root of UNC path - return widInvalid if so
        //
        const WCHAR * pwszParent = lcaseFunnyParent.GetActualPath();

        if (cwcEnd > 2 && pwszParent[0] == L'\\' && pwszParent[1] == L'\\')
        {
           // see if last \ is the 2nd \\ in UNC name
           while ( pwszParent[cwcEnd] != L'\\')
               cwcEnd--;
           if ( 1 == cwcEnd )
               return widInvalid;
        }

        //
        // Now we traverse the path from the left and create all the wids
        // that are needed. We avoid recursion by starting from left.
        //
        unsigned cwcParentLength = lcaseFunnyParent.GetActualLength();
        BOOL fAllPathsInvalidFromNow = FALSE;

        cwcEnd = 2;

        // In case it is a remote path, start traversal after the machine name
        if ( L'\\' == pwcsFileName[0] && L'\\' == pwcsFileName[1] )
        {
            while ( pwcsFileName[cwcEnd] != L'\\' )
                cwcEnd++;
            cwcEnd++;
        }

        for (; cwcEnd < cwcParentLength; cwcEnd++)
        {
            if ( L'\\' == pwcsFileName[cwcEnd] )
            {
                lcaseFunnyParent.SetPath( pwcsFileName, cwcEnd );
                if ( fAllPathsInvalidFromNow ||
                     widInvalid == LokFind( lcaseFunnyParent, fUsnVolume ) )
                {
                    // Since we done't have a wid for this path, it should be
                    // be a valid assumption that all its children also do
                    // not have valid wids
                    fAllPathsInvalidFromNow = TRUE;

                    _cicat.PathToWorkId ( lcaseFunnyParent, TRUE );
                }
            }
        }

        // Now create the final parent wid
        lcaseFunnyParent.SetPath( pwcsFileName, cwcEnd );
        widParent = _cicat.PathToWorkId ( lcaseFunnyParent, TRUE );
    }

    //
    // wid can be widInvalid if the scope is no longer indexed or has
    // been deleted.
    //
    // Win4Assert( widInvalid != widParent );
    //

    return widParent;
} //LokParentWorkId
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\statmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       statmon.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  History:    3-20-96   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop


#include <ciregkey.hxx>
#include <statmon.hxx>
#include <cievtmsg.h>
#include <eventlog.hxx>
#include <pathpars.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CCiStatusMonitor::ReportInitFailure
//
//  Synopsis:   
//
//  Arguments:  [status] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    3-20-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CCiStatusMonitor::ReportInitFailure()
{
    Win4Assert( STATUS_SUCCESS != _status );

    if ( CI_CORRUPT_DATABASE == _status || CI_CORRUPT_CATALOG == _status )
    {
        LogEvent( eCorrupt, _status );    
    }
    else
    {
        LogEvent( eInitFailed, _status );
    }
    _fDontLog = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiStatusMonitor::ReportFailure
//
//  Synopsis:   
//
//  Arguments:  [status] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    3-20-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CCiStatusMonitor::ReportFailure( NTSTATUS status )
{
    if ( !_fDontLog )
    {
        if ( CI_CORRUPT_DATABASE == status || CI_CORRUPT_CATALOG == status )
        {
            LogEvent( eCorrupt, status );    
        }
        else
        {
            LogEvent( eCiError, status );
        }
        _fDontLog = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiStatusMonitor::LogEvent
//
//  Synopsis:   
//
//  Arguments:  [type]   - 
//              [status] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    3-20-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CCiStatusMonitor::LogEvent( EMessageType type, DWORD status, ULONG val )
{
    TRY
    {
        USHORT nParams = 1;
        DWORD  msgId;
    

        USHORT usLevel = EVENTLOG_WARNING_TYPE;

        switch ( type )
        {
            case eCorrupt:
                usLevel = EVENTLOG_ERROR_TYPE;
                msgId = MSG_CI_CORRUPT_INDEX_DOWNLEVEL;
                break;
    
            case eCIStarted:
                usLevel = EVENTLOG_INFORMATION_TYPE;
                msgId = MSG_CI_STARTED;
                break;

            case eInitFailed:
                usLevel = EVENTLOG_ERROR_TYPE;
                msgId = MSG_CI_INIT_INDEX_DOWNLEVEL_FAILED;
                nParams = 2;
                break;
    
            case eCiRemoved:
                usLevel = EVENTLOG_ERROR_TYPE;
                msgId = MSG_CI_CORRUPT_INDEX_DOWNLEVEL_REMOVED;
                break;
    
            case eCiError:
                usLevel = EVENTLOG_ERROR_TYPE;
                msgId = MSG_CI_INDEX_DOWNLEVEL_ERROR;
                nParams = 2;
                break;

            case ePropStoreRecoveryStart:
                usLevel = EVENTLOG_INFORMATION_TYPE;
                msgId = MSG_CI_PROPSTORE_RECOVERY_START;
                break;

            case ePropStoreRecoveryEnd:
                usLevel = EVENTLOG_INFORMATION_TYPE;
                msgId = MSG_CI_PROPSTORE_RECOVERY_COMPLETED;
                break;

            case ePropStoreError:
                usLevel = EVENTLOG_ERROR_TYPE;
                msgId = MSG_CI_PROPSTORE_INCONSISTENT;
                break;

            case ePropStoreRecoveryError:
                msgId = MSG_CI_PROPSTORE_RECOVERY_INCONSISTENT;
                nParams = 2;
                break;

            default:
                ciDebugOut(( DEB_IERROR, "Unknown message type. %d\n", type ));
                return;
        }
    
    
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( usLevel,
                         CI_SERVICE_CATEGORY,
                         msgId,
                         nParams );

        switch (msgId)
        {
            case MSG_CI_CORRUPT_INDEX_DOWNLEVEL:
            case MSG_CI_CORRUPT_INDEX_DOWNLEVEL_REMOVED:
            case MSG_CI_PROPSTORE_INCONSISTENT:
            case MSG_CI_PROPSTORE_RECOVERY_START:
            case MSG_CI_PROPSTORE_RECOVERY_COMPLETED:
            case MSG_CI_STARTED:
                item.AddArg( _wcsCatDir );
                break;

            case MSG_CI_INIT_INDEX_DOWNLEVEL_FAILED:
                item.AddArg( _wcsCatDir );
                item.AddArg( status );
                break;

            case MSG_CI_INDEX_DOWNLEVEL_ERROR:
                item.AddArg( status );
                item.AddArg( _wcsCatDir );
                break;

            case MSG_CI_PROPSTORE_RECOVERY_INCONSISTENT:
                item.AddArg( val );
                item.AddArg( _wcsCatDir );
                break;

            default:
                Win4Assert( !"Impossible case stmt" );
                break;
        }

        eventLog.ReportEvent( item );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
}

void CCiStatusMonitor::ReportPathTooLong( WCHAR const * pwszPath )
{
    TRY
    {
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_ERROR_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_PATH_TOO_LONG,
                         1 );

        item.AddArg( pwszPath );
        eventLog.ReportEvent( item );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%X while writing to event log\n",
                                e.GetErrorCode() ));
    }
    END_CATCH
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\usnmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       usnmgr.cxx
//
//  Contents:   Usn manager
//
//  History:    07-May-97   SitaramR    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <eventlog.hxx>
#include <cievtmsg.h>
#include <smatch.hxx>
#include <cifrmcom.hxx>
#include "cicat.hxx"
#include "notifmgr.hxx"
#include "usnmgr.hxx"
#include "usntree.hxx"

//
// Local constants
//

unsigned const USN_LOG_DANGER_THRESHOLD = 50;

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::CUsnMgr
//
//  Synopsis:   Constructor
//
//  Arguments:  [cicat] -- Catalog
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CUsnMgr::CUsnMgr( CiCat & cicat )
    : _cicat(cicat),
      _fAbort(FALSE),
      _fBatch(FALSE),
#pragma warning( disable : 4355 )               // this used in base initialization
      _thrUsn(UsnThread, this, TRUE),
#pragma warning( default : 4355 )
      _fUpdatesDisabled(FALSE),
      _fDoingRenameTraverse( FALSE ),
      _waitForMultObj(1+RTL_MAX_DRIVE_LETTERS), // 1 for _evtUsn + RTL_MAX_DRIVE_LETTERS drives (a: to z: + few special chars)
      _fWaitingForUpdates( FALSE )
{
    _evtUsn.Reset();
    _thrUsn.SetPriority(THREAD_PRIORITY_BELOW_NORMAL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::~CUsnMgr
//
//  Synopsis:   Destructor
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CUsnMgr::~CUsnMgr()
{
    InitiateShutdown();
    WaitForShutdown();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::GetMaxUSNs, public
//
//  Synopsis:   Updates or adds entries to flushInfoList to reflect the max
//              usn processed for the volumes.
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::GetMaxUSNs( CUsnFlushInfoList & flushInfoList )
{
    for ( CUsnVolumeIter usnVolIter( _usnVolumesToMonitor );
          !_usnVolumesToMonitor.AtEnd( usnVolIter );
          _usnVolumesToMonitor.Advance( usnVolIter ) )
    {
        //
        // Look for the volume and store the highest usn if found.
        //

        BOOL fFound = FALSE;

        for ( unsigned i = 0; i < flushInfoList.Count(); i++ )
        {
            CUsnFlushInfo & info = * ( flushInfoList.Get( i ) );

            if ( usnVolIter->VolumeId() == info.volumeId )
            {
                ciDebugOut(( DEB_ITRACE,
                             "GetMaxUSNs updating vol %wc from %#I64x to %#I64x\n",
                             usnVolIter->DriveLetter(),
                             info.usnHighest,
                             usnVolIter->MaxUsnRead() ));
                info.usnHighest = usnVolIter->MaxUsnRead();
                fFound = TRUE;
                break;
            }
        }

        //
        // If the volume isn't in the list yet, add it.
        //

        if ( !fFound )
        {
            ciDebugOut(( DEB_ITRACE,
                         "GetMaxUSNs adding vol %wc %#I64x\n",
                         usnVolIter->DriveLetter(),
                         usnVolIter->MaxUsnRead() ));
            XPtr<CUsnFlushInfo> xInfo( new CUsnFlushInfo( usnVolIter->VolumeId(),
                                                          usnVolIter->MaxUsnRead() ) );
            flushInfoList.Add( xInfo.GetPointer(), i );
            xInfo.Acquire();
        }
    }
} //GetMaxUSNs

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::AddScope
//
//  Synopsis:   Scans scope and then monitors scope for usn notifications
//
//  Arguments:  [pwcsScope]    -- Scope
//              [volumeId]     -- Volume id
//              [fDoDeletions] -- Should delete processing be done ?
//              [usnStart]     -- "High water mark" of previous activity
//              [fFullScan]    -- TRUE if we should start over from scratch
//              [fUserInitiatedScan] -- TRUE if the user asked for the scan
//              [fNewScope]    -- TRUE if scope was just added to the catalog
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::AddScope( WCHAR const *pwcsScope,
                        VOLUMEID volumeId,
                        BOOL fDoDeletions,
                        USN const & usnStart,
                        BOOL fFullScan,
                        BOOL fUserInitiatedScan,
                        BOOL fNewScope )
{
    Win4Assert( wcslen(pwcsScope) < MAX_PATH );
    XPtr<CCiScanInfo> xScanInfo( QueryScanInfo( pwcsScope,
                                                volumeId,
                                                usnStart,
                                                fDoDeletions,
                                                fUserInitiatedScan,
                                                fNewScope ) );
    xScanInfo->SetScan();
    if ( fFullScan )
        xScanInfo->SetFullUsnScan();

    ScanScope( xScanInfo, FALSE );
} //AddScope

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::MonitorScope
//
//  Synopsis:   Monitors scope for usn notifications, i.e. no scan is done
//
//  Arguments:  [pwcsScope]  - Scope
//              [volumeId]   - Volume id
//              [usnStart]   - Usn to start monitoring from
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::MonitorScope( WCHAR const *pwcsScope,
                            VOLUMEID volumeId,
                            USN usnStart )
{
    Win4Assert( wcslen(pwcsScope) < MAX_PATH );
    XPtr<CCiScanInfo> xScanInfo( QueryScanInfo( pwcsScope,
                                                volumeId,
                                                usnStart,
                                                FALSE ) );
    xScanInfo->SetMonitorOnly();

    ScanScope( xScanInfo, FALSE );
} //MonitorScope

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::RemoveScope
//
//  Synopsis:   Removes usn path from catalog
//
//  Arguments:  [pwscScope] - Scope to be removed
//              [volumeId]  - Volume id
//
//  History:    07-May-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CUsnMgr::RemoveScope( WCHAR const *pwcsScope, VOLUMEID volumeId )
{
    //
    // If the given scope is in the list of paths being currently
    // scanned, we must mark it deleted.
    //
    BOOL fRemoved = FALSE;

    {
        CLock   lock(_mutex);
        if ( _fAbort || _fUpdatesDisabled )
            return;

        for ( CFwdScanInfoIter scanInfoIter1( _usnScansToDo );
              !_usnScansToDo.AtEnd( scanInfoIter1 );
              _usnScansToDo.Advance( scanInfoIter1 ) )
        {
            WCHAR const * pwcsPath = scanInfoIter1->GetPath();

            if ( AreIdenticalPaths( pwcsScope, pwcsPath ) )
            {
                fRemoved = TRUE;
                if ( !scanInfoIter1->LokIsDelScope() )
                    scanInfoIter1->LokSetDelScope();
            }
        }

        if ( !fRemoved )
        {
            LokScheduleRemove( pwcsScope, volumeId );
            fRemoved = TRUE;
        }

        {
            CLock lock(_mutex);
            if ( !_fBatch )
                _evtUsn.Set();     // wake up the usn thread.
        }

        Win4Assert( fRemoved );
    }
} //RemoveScope

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ScanScope
//
//  Synopsis:   Scan the given scopes and then start monitoring for usn
//              notifications
//
//  Arguments:  [xScanInfo] - Scan info
//              [fRefiled]  - Is this a refiled scan ?
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::ScanScope( XPtr<CCiScanInfo> & xScanInfo,
                         BOOL fRefiled )
{
    CLock   lock(_mutex);

#if CIDBG==1
    //
    // Debug code to track down the cause of _fUsnTreeScan assert
    //
    if ( xScanInfo->LokIsInScan() )
        _cicat.CheckUsnTreeScan( xScanInfo->GetPath() );
#endif

    ciDebugOut(( DEB_ITRACE, "CUsnMgr::ScanScope, retries %d\n",
                 xScanInfo->GetRetries() ));

    if ( xScanInfo->GetRetries() > CCiScanInfo::MAX_RETRIES )
    {
        //
        // Log event that scan failed, cleanup and then return
        //
        CEventLog eventLog( NULL, wcsCiEventSource );
        CEventItem item( EVENTLOG_ERROR_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_CONTENTSCAN_FAILED,
                         1 );

        item.AddArg( xScanInfo->GetPath() );
        eventLog.ReportEvent( item );

        CCiScanInfo * pScanInfo = xScanInfo.Acquire();
        delete pScanInfo;

        return;
    }

    if ( LokIsScanScheduled( xScanInfo ) )
    {
        ciDebugOut(( DEB_ITRACE, "CUsnMgr::ScanScope scan was already scheduled\n" ));
        CCiScanInfo * pScanInfo = xScanInfo.Acquire();
        delete pScanInfo;
    }
    else
    {
        Win4Assert( !xScanInfo->LokIsInFinalState() );
        Win4Assert( xScanInfo->LokIsInScan()
                    || xScanInfo->LokIsInFullUsnScan()
                    || xScanInfo->LokIsDelScope()
                    || xScanInfo->LokIsRenameDir()
                    || xScanInfo->LokIsMonitorOnly() );

        ciDebugOut(( DEB_ITRACE,
                     "CUsnMgr::ScanScope scan wasn't already scheduled, fRefiled: %d\n",
                     fRefiled ));
        if ( fRefiled )
        {
            //
            // A scan that has been refiled should be done before new scans to
            // ensure that all scans are done in FIFO order
            //
            _usnScansToDo.Push( xScanInfo.GetPointer() );
        }
        else
            _usnScansToDo.Queue( xScanInfo.GetPointer() );
        xScanInfo.Acquire();

        if ( !_fBatch )
            _evtUsn.Set();
    }
} //ScanScope

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::LokIsScanScheduled
//
//  Synopsis:   Tests if the given scope is already scheduled for a scan.
//
//  Arguments:  [xScanInfo] - Smart pointer to scaninfo
//
//  History:    07-May-97    SitaramR   Created
//
//----------------------------------------------------------------------------

BOOL CUsnMgr::LokIsScanScheduled( const XPtr<CCiScanInfo> & xScanInfo )
{
    WCHAR const * pwszNewScope = xScanInfo->GetPath();
    unsigned lenNewScope = wcslen( pwszNewScope );

    for ( CFwdScanInfoIter scanInfoIter(_usnScansToDo);
          !_usnScansToDo.AtEnd(scanInfoIter);
          _usnScansToDo.Advance(scanInfoIter) )
    {
        if ( xScanInfo->LokGetWorkType() == scanInfoIter->LokGetWorkType() )
        {
            WCHAR const * pwszPath = scanInfoIter->GetPath();

            CScopeMatch scope( pwszPath, wcslen(pwszPath) );
            if (scope.IsInScope( pwszNewScope, lenNewScope ))
            {
                ciDebugOut(( DEB_WARN,
                             "Usn scan already scheduled for (%ws)\n",
                             pwszNewScope ));
                return TRUE;
            }
        }
    }

    return FALSE;
} //LokIsScanScheduled

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::QueryScanInfo, private
//
//  Synopsis:   Returns a new instance of CCiScanInfo
//
//  Arguments:  [pwcsScope]    -- Scope
//              [volumeId]     -- Volume id
//              [usnStart]     -- Start usn
//              [fDoDeletions] -- Shoud deletions be done ?
//              [fUserInitiatedScan] -- TRUE if the user asked for the scan
//              [fNewScope]    -- TRUE if scope was just added to the catalog
//
//  History:    05-May-97      SitaramR      Created
//
//----------------------------------------------------------------------------

CCiScanInfo * CUsnMgr::QueryScanInfo( WCHAR const * pwcsScope,
                                      VOLUMEID volumeId,
                                      USN usnStart,
                                      BOOL fDoDeletions,
                                      BOOL fUserInitiatedScan,
                                      BOOL fNewScope )
{
    Win4Assert( 0 != pwcsScope );

    //
    // Check for remote path
    //
    Win4Assert( pwcsScope[0] != L'\\' );

    ULONG len = wcslen( pwcsScope );
    Win4Assert( pwcsScope[len-1] == L'\\' );

    XArray<WCHAR> xPath( len+1 );
    WCHAR * pwcsLocal = xPath.Get();
    RtlCopyMemory( pwcsLocal, pwcsScope, (len+1)*sizeof(WCHAR) );
    CCiScanInfo * pScanInfo = new CCiScanInfo( xPath,
                                               1,
                                               UPD_FULL,
                                               fDoDeletions,
                                               volumeId,
                                               usnStart,
                                               fUserInitiatedScan,
                                               fNewScope );
    return pScanInfo;
} //QueryScanInfo

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::DisableUpdates
//
//  Synopsis:   Disables all usn updates
//
//  History:    07-May-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CUsnMgr::DisableUpdates()
{
    CLock lock( _mutex );

    _fUpdatesDisabled = TRUE;

    _evtUsn.Set();
}


//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::EnableUpdates
//
//  Synopsis:   Enables usn updates
//
//  History:    07-May-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CUsnMgr::EnableUpdates()
{
    CLock lock( _mutex );

    if ( _fUpdatesDisabled )
    {
        _fUpdatesDisabled = FALSE;

        _evtUsn.Set();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::InitiateShutdown
//
//  Synopsis:   Initiates the shutdown process
//
//  History:    05-May-97      SitaramR      Created
//
//----------------------------------------------------------------------------

void CUsnMgr::InitiateShutdown()
{
    CLock   lock(_mutex);

    _fAbort = TRUE;
    _fUpdatesDisabled = TRUE;

    _usnScansToDo.Clear();

    _evtUsn.Set();
}



//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::WaitForShutdown
//
//  Synopsis:   Waits for shutdown to complete
//
//  History:    05-May-97      SitaramR      Created
//
//----------------------------------------------------------------------------

void CUsnMgr::WaitForShutdown()
{
    //
    // If we never started running, then just bail out.
    //

    if ( _thrUsn.IsRunning() )
    {
        ciDebugOut(( DEB_ITRACE, "Waiting for death of usn thread\n" ));
        _thrUsn.WaitForDeath();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::LokEmptyInProgressScans
//
//  Synopsis:   Removes all the scans from the "in-progress stack" and either
//              deletes them or re-schedules them. If the scan is in its
//              "terminal state", the scan is deleted. If there is a retry
//              it will be re-scheduled.
//
//  History:    07-May-97     SitaramR   Created
//
//----------------------------------------------------------------------------

void CUsnMgr::LokEmptyInProgressScans()
{
    //
    // Refile any scopes that still need to be worked on
    //
    while ( _usnScansInProgress.Count() > 0 )
    {
        if ( _fAbort )
            break;

        XPtr<CCiScanInfo>   xScanInfo( _usnScansInProgress.RemoveLast() );

        if ( _fUpdatesDisabled )
        {
            CCiScanInfo * pScanInfo = xScanInfo.Acquire();
            delete pScanInfo;
        }
        else if ( xScanInfo->LokIsInFinalState() )
        {
            //
            // Scan of scope completed successfully, so start monitoring
            //
            LokAddScopeForUsnMonitoring( xScanInfo );
        }
        else
        {

#if CIDBG==1
            if ( xScanInfo->LokIsDelScope() )
            {
                ciDebugOut(( DEB_ITRACE,
                             "Requeing scope (%ws) for removal\n",
                             xScanInfo->GetPath() ));
            }
            else
            {
                ciDebugOut(( DEB_ITRACE,
                             "Requeuing scope (%ws) for scan\n",
                         xScanInfo->GetPath() ));
            }
#endif  // CIDBG==1

            ScanScope( xScanInfo, TRUE );         // It's a refiled scan
        }
    }
} //LokEmptyInProgressScans

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::LokScheduleRemove
//
//  Synopsis:   Schedules a usn path for removal
//
//  Arguments:  [pwscScope] - Scope to be removed
//              [volumeId]  - Volume id
//
//  History:    07-May-97     SitaramR    Created
//
//----------------------------------------------------------------------------

void CUsnMgr::LokScheduleRemove( WCHAR const * pwcsScope,
                                 VOLUMEID volumeId )
{
    CCiScanInfo * pScanInfo = QueryScanInfo( pwcsScope,
                                             volumeId,
                                             0,
                                             TRUE );
    XPtr<CCiScanInfo>   xScanInfo( pScanInfo );
    pScanInfo->LokSetDelScope();
    ScanScope( xScanInfo, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnsMgr::UsnThread
//
//  Synopsis:   Usn thread start routine
//
//  Arguments:  [self] - This pointer
//
//  History:    07-May-97   SitaramR   Created
//
//----------------------------------------------------------------------------

DWORD CUsnMgr::UsnThread( void * self )
{
    SCODE sc = CoInitializeEx( 0, COINIT_MULTITHREADED );

    ((CUsnMgr *) self)->DoUsnProcessing();

    CoUninitialize();

    ciDebugOut(( DEB_ITRACE, "Terminating usn thread\n" ));

    return 0;
} //UsnThread

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::DoUsnProcessing
//
//  Synopsis:   Main loop of usn thread
//
//  History:    07-May-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CUsnMgr::DoUsnProcessing()
{
    CImpersonateSystem impersonate;

    while ( TRUE )
    {
        //
        // Don't do any work until the system has booted
        //

        while ( GetTickCount() < _cicat.GetRegParams()->GetStartupDelay() )
        {
            Sleep( 200 );
            if ( _fAbort )
                break;
        }

        NTSTATUS status = STATUS_SUCCESS;
        TRY
        {
            XPtr<CCiScanInfo> xScanInfo;

            //--------------------------------------------------------------------
            {
                CLock lock( _mutex );

                if ( _fAbort )
                    break;

                if ( !_fBatch )
                {
                    //
                    // If requests are being batched, then don't process
                    // requests until the _fBatch flag is cleared.
                    //
                    // Refile any incomplete paths that could not be processed due to
                    // low resources
                    //
                    if ( _usnScansInProgress.Count() > 0 )
                        LokEmptyInProgressScans();

                    while ( _usnScansToDo.Count() > 0 )
                    {
                        xScanInfo.Set( _usnScansToDo.Pop() );
                        if ( _fUpdatesDisabled )
                        {
                            delete xScanInfo.Acquire();

                            break;
                        }
                        else
                        {
                            Win4Assert( !xScanInfo->LokIsInFinalState() );

                            _usnScansInProgress.Queue( xScanInfo.GetPointer() );
                            xScanInfo.Acquire();
                        }
                    }

                    if ( _fUpdatesDisabled )
                    {
                        //
                        // Empty usn lists, because usns notifications
                        // are not needed until updates are enabled.
                        //
                        _usnScansToDo.Clear();
                        _usnScansInProgress.Clear();
                        _usnVolumesToMonitor.Clear();
                    }

                    _evtUsn.Reset();
                }
            }
            //--------------------------------------------------------------------

            if ( _usnScansInProgress.Count() > 0 )
            {
                DoUsnScans();
                Win4Assert( _usnScansInProgress.Count() == 0
                            || _fAbort
                            || _fUpdatesDisabled );
            }

            //
            // ProcessUsnNotifications waits for usn notifications and processes
            // them, or it waits until evtUsn is set.  Only do this if there
            // are no more scans to do.
            //

            if ( 0 == _usnScansToDo.Count() )
                ProcessUsnNotifications();
        }
        CATCH (CException, e)
        {
            ciDebugOut(( DEB_ERROR,
                         "CUsnMgr::DoUsnProcessing, caught exception 0x%X\n",
                         e.GetErrorCode() ));

            status = e.GetErrorCode();
        }
        END_CATCH

        if ( status == CI_CORRUPT_CATALOG || status == CI_CORRUPT_DATABASE )
        {
            //
            // Disable further updates until corruption is cleared
            //
            CLock lock( _mutex );

            _fUpdatesDisabled = TRUE;
        }
    }
} //DoUsnProcessing

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::DoUsnScans
//
//  Synopsis:   Does tree walk for any usn scopes that were added
//
//  History:    07-May-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CUsnMgr::DoUsnScans()
{
    //
    // No need for a lock because only this thread modifies _usnScansInProgress
    //

    for ( CFwdScanInfoIter scanInfoIter(_usnScansInProgress);
          !_usnScansInProgress.AtEnd(scanInfoIter);
          _usnScansInProgress.Advance(scanInfoIter) )
    {
        if ( _fAbort || _fUpdatesDisabled )
            break;

        CCiScanInfo *pScanInfo = scanInfoIter.GetEntry();
        Win4Assert( pScanInfo->GetRetries() <= CCiScanInfo::MAX_RETRIES );

        NTSTATUS status = STATUS_SUCCESS;
        TRY
        {
            ICiManager *pCiManager = _cicat.CiManager();

            if ( pScanInfo->LokIsDelScope() )
            {
                _cicat.RemovePathsFromCiCat( pScanInfo->GetPath(), eUsnsArray );

                if ( !_fAbort && !_fUpdatesDisabled )
                {
                    SCODE sc = pCiManager->FlushUpdates();
                    if ( FAILED(sc) )
                        THROW( CException( sc ) );

                    pScanInfo->LokSetDone();
                }
            }
            else if ( pScanInfo->LokIsMonitorOnly() )
            {
                //
                // The scope needs to be monitored only and so set it to done
                //
                pScanInfo->LokSetDone();
            }
            else
            {
                //
                // A starting USN from 0 means this is a first scan, or a
                // complete recovery.  A starting USN > 0 means we are
                // looking for items changed by NT4 and not recorded in
                // the USN log.
                //

                USN usnStart = 0;

                //
                // A full scan is executed after a volume has been reformatted.
                // We first wipe all existing data (which will have incorrect
                // fileid <--> wid mappings) and then do the scan.
                //

                if ( pScanInfo->LokIsInFullUsnScan() )
                {
                    _cicat.RemovePathsFromCiCat( pScanInfo->GetPath(),
                                                 eUsnsArray );

                    if ( !_fAbort && !_fUpdatesDisabled )
                    {
                        SCODE sc = pCiManager->FlushUpdates();
                        if ( FAILED(sc) )
                            THROW( CException( sc ) );
                    }
                }
                else
                    usnStart = pScanInfo->UsnStart();

                ciDebugOut(( DEB_ITRACE, "scan usnstart: %#I64x\n",
                             pScanInfo->UsnStart() ));

                //
                // Use the end of the usn log or the last usn processed by
                // CI for this volume if available.
                //

                USN usnMax = FindCurrentMaxUsn( pScanInfo->GetPath() );

                {
                    ciDebugOut(( DEB_ITRACE,
                                 "usn scan looking for better maxusn than %#I64x\n",
                                 usnMax ));

                    for ( CUsnVolumeIter usnVolIter( _usnVolumesToMonitor );
                          !_usnVolumesToMonitor.AtEnd( usnVolIter );
                          _usnVolumesToMonitor.Advance( usnVolIter ) )
                    {
                        if ( usnVolIter->VolumeId() == pScanInfo->VolumeId() )
                        {
                            ciDebugOut(( DEB_ITRACE,
                                         "usn scan using %#I64x instead of %#I64x\n",
                                         usnVolIter->MaxUsnRead(),
                                         usnMax ));
                            usnMax = usnVolIter->MaxUsnRead();
                            break;
                        }
                    }
                }

                pScanInfo->SetStartUsn( usnMax );

                CLowerFunnyPath lcaseFunnyPath;
                lcaseFunnyPath.SetPath( pScanInfo->GetPath() );

                CUsnTreeTraversal usnTreeTrav( _cicat,
                                               *this,
                                               *pCiManager,
                                               lcaseFunnyPath,
                                               pScanInfo->IsDoDeletions(),
                                               _fUpdatesDisabled,
                                               TRUE,      // Process root
                                               pScanInfo->VolumeId(),
                                               usnStart,
                                               usnMax,
                                               pScanInfo->IsUserInitiated() );
                usnTreeTrav.EndProcessing();

                //
                // Flush updates, because we will be writing usnMax as the
                // restart usn for this scope, and we want to make sure that
                // all updates with usn of 0 are serialized before writing
                // the restart usn.
                //

                if ( !_fAbort && !_fUpdatesDisabled )
                {
                    SCODE sc = pCiManager->FlushUpdates();
                    if ( FAILED(sc) )
                        THROW( CException( sc ) );

                    _cicat.SetUsnTreeScanComplete( pScanInfo->GetPath(), usnMax );

                    //
                    // Make SetUsnTreeScanComplete info persistent by
                    // serializing the scope table.
                    //
                    _cicat.ScheduleSerializeChanges();

                    pScanInfo->LokSetDone();
                }
            }
        }
        CATCH( CException, e)
        {
            ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in CUsnMgr::DoUsnScans\n", e.GetErrorCode() ));

            status = e.GetErrorCode();
        }
        END_CATCH

        if ( status != STATUS_SUCCESS )
        {
            _cicat.HandleError( status );
            break;
        }
    }

    //
    // Requeue failed usn scans
    //

    while ( _usnScansInProgress.Count() > 0 )
    {
        XPtr<CCiScanInfo> xScanInfo( _usnScansInProgress.RemoveLast() );

        if ( _fUpdatesDisabled )
        {
            continue;
        }
        else if ( xScanInfo->LokIsInFinalState() )
        {
            if ( xScanInfo->LokIsDelScope() )
            {
                CLock lock( _mutex );

                LokRemoveScopeFromUsnMonitoring( xScanInfo );

                //
                // All processing for a delete scope has been completed
                //
                CCiScanInfo *pScanInfo = xScanInfo.Acquire();
                delete pScanInfo;
            }
            else
            {
                //
                // Start monitoring for changes on this scope
                //
                CLock lock( _mutex );

                LokAddScopeForUsnMonitoring( xScanInfo );
            }
        }
        else
        {
            //
            // We couldn't complete the scan for this, and so refile
            //
            xScanInfo->SetStartUsn( 0 );
            xScanInfo->IncrementRetries();
            xScanInfo->SetDoDeletions();

            ScanScope( xScanInfo, TRUE );
        }
    }
} //DoUsnScans

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::LokAddScopeForUsnMonitoring
//
//  Synopsis:   Registers a scope for usn notifications
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::LokAddScopeForUsnMonitoring( XPtr<CCiScanInfo> & xScanInfo )
{
    WCHAR const *pwszPath = xScanInfo->GetPath();

    TRY
    {
        //
        // Check that it is not a remote path
        //
        Win4Assert( pwszPath[0] != L'\\' );

        for ( CUsnVolumeIter usnVolIter(_usnVolumesToMonitor);
              !_usnVolumesToMonitor.AtEnd(usnVolIter);
              _usnVolumesToMonitor.Advance(usnVolIter) )
        {
            if ( usnVolIter->DriveLetter() == pwszPath[0] )
            {
                //
                // Add the scope to the list of scopes being monitored
                // on this drive, if it is not already being monitored.
                //

                CScanInfoList & usnScopeList = usnVolIter->GetUsnScopesList();

                for ( CFwdScanInfoIter scanIter1(usnScopeList);
                      !usnScopeList.AtEnd(scanIter1);
                      usnScopeList.Advance(scanIter1) )
                {
                    if ( AreIdenticalPaths( scanIter1->GetPath(), xScanInfo->GetPath() ) )
                         return;

                    CScopeMatch superScope( scanIter1->GetPath(), wcslen( scanIter1->GetPath() ) );
                    if ( superScope.IsInScope( xScanInfo->GetPath(), wcslen( xScanInfo->GetPath() ) ) )
                        return;
                }

                //
                // Remove subscopes as an optimization
                //

                CScopeMatch superScope( xScanInfo->GetPath(), wcslen( xScanInfo->GetPath() ) );

                CFwdScanInfoIter scanIter2(usnScopeList);
                while ( !usnScopeList.AtEnd(scanIter2) )
                {
                    CCiScanInfo *pScanInfo = scanIter2.GetEntry();
                    usnScopeList.Advance(scanIter2);

                    if ( superScope.IsInScope( pScanInfo->GetPath(), wcslen( pScanInfo->GetPath() ) ) )
                    {
                        usnScopeList.RemoveFromList( pScanInfo );
                        delete pScanInfo;
                    }
                }

                if ( xScanInfo->UsnStart() < usnVolIter->MaxUsnRead() )
                {
                    usnVolIter->SetMaxUsnRead( xScanInfo->UsnStart() );

                    //
                    // Cancel pending fsctl (if any) to pick up earlier usn
                    // notifications
                    //
                    usnVolIter->CancelFsctl();
                }

                usnScopeList.Push( xScanInfo.Acquire() );
                return;
            }
        }

        CUsnVolume *pUsnVolume = new CUsnVolume( pwszPath[0], xScanInfo->VolumeId() );
        pUsnVolume->SetMaxUsnRead( xScanInfo->UsnStart() );

        _usnVolumesToMonitor.Push( pUsnVolume );

        CScanInfoList &usnScopeList = pUsnVolume->GetUsnScopesList();
        usnScopeList.Push( xScanInfo.Acquire() );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x trying to monitor USN scope %wc.\n", e.GetErrorCode(), xScanInfo->VolumeId() ));

        HandleError( pwszPath[0], e.GetErrorCode() );
    }
    END_CATCH
} //LokAddScopeForUsnMonitoring

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::LokRemoveScopeFromUsnMonitoring
//
//  Synopsis:   Deregisters a scope from usn notifications
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::LokRemoveScopeFromUsnMonitoring( XPtr<CCiScanInfo> & xScanInfo )
{
    WCHAR const *pwszPath = xScanInfo->GetPath();

    //
    // Check that it is not a remote path
    //
    Win4Assert( pwszPath[0] != L'\\' );

    for ( CUsnVolumeIter usnVolIter(_usnVolumesToMonitor);
          !_usnVolumesToMonitor.AtEnd(usnVolIter);
          _usnVolumesToMonitor.Advance(usnVolIter) )
    {
        if ( usnVolIter->DriveLetter() == pwszPath[0] )
        {
            CScanInfoList & usnScopeList = usnVolIter->GetUsnScopesList();

            CFwdScanInfoIter scanInfoIter(usnScopeList);
            while ( !usnScopeList.AtEnd(scanInfoIter) )
            {
                CCiScanInfo *pScanInfo = scanInfoIter.GetEntry();
                usnScopeList.Advance(scanInfoIter);

                if ( AreIdenticalPaths( pScanInfo->GetPath(), xScanInfo->GetPath() ) )
                {
                    usnScopeList.RemoveFromList( pScanInfo );
                    delete pScanInfo;

                    break;
                }
            }

            //
            // If no more scopes on this usn volume then remove the entry from the
            // list of volumes being monitored.
            //
            if ( usnScopeList.Count() == 0 )
            {
                CUsnVolume *pUsnVolume = usnVolIter.GetEntry();
                _usnVolumesToMonitor.RemoveFromList( pUsnVolume );
                delete pUsnVolume;

                break;
            }
        }
    }
} //LokRemoveScopeFromUsnMonitoring

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ProcessNotifications
//
//  Synopsis:   Wait for usn notifications, and then process them
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::ProcessUsnNotifications()
{
    //
    // No need for a lock because only this thread modifies _usnVolumesToMonitor
    //

    for (;;)
    {
        //
        // Loop by waiting for usn notifications and processing them.
        // Loop returns when _evtUsn is signalled.
        //

        BOOL fWait;        // TRUE --> Every volume is now waiting. (assigned below)
        BOOL fLowResource;

        do
        {
            _waitForMultObj.ResetCount();

            //
            // _evtUsn is the first handle, and so it gets priority if more
            // than one event is signalled.
            //
            _waitForMultObj.AddEvent( _evtUsn.GetHandle() );

            CUsnVolumeIter usnVolIter(_usnVolumesToMonitor);

            //
            // Are we in a high i/o state?  If so, don't read the USN Journal
            //

            fLowResource = IsLowResource();
            fWait = TRUE;

            while ( !_usnVolumesToMonitor.AtEnd(usnVolIter) )
            {
                if ( _fAbort || _fUpdatesDisabled )
                    return;

                CUsnVolume *pUsnVolume = usnVolIter.GetEntry();
                _usnVolumesToMonitor.Advance(usnVolIter);

                if ( !pUsnVolume->IsOnline() )
                    continue;

                ciDebugOut(( DEB_ITRACE, "Drive %wc: %u%% read\n", pUsnVolume->DriveLetter(), pUsnVolume->PercentRead() ));

                if ( fLowResource && pUsnVolume->PercentRead() >= USN_LOG_DANGER_THRESHOLD )
                    continue;

                //
                // Does this volume have something to do now?
                //

                if ( pUsnVolume->FFsctlPending() && WAIT_TIMEOUT != pUsnVolume->WaitFsctl( 0 ) )
                    pUsnVolume->ResetFsctlPending();

                if ( pUsnVolume->FFsctlPending() )
                    _waitForMultObj.AddEvent( pUsnVolume->GetFsctlEvent() );
                else
                {
                    NTSTATUS status = ProcessUsnNotificationsFromVolume( pUsnVolume );

                    switch( status )
                    {
                    case STATUS_PENDING:
                        pUsnVolume->SetFsctlPending();
                        _waitForMultObj.AddEvent( pUsnVolume->GetFsctlEvent() );
                        break;

                    case STATUS_JOURNAL_ENTRY_DELETED:
                        break;

                    case STATUS_SUCCESS:
                        fWait = FALSE;    // More to do, processing bailed to enable round-robin
                        break;

                    default:
                        Win4Assert( !NT_SUCCESS( status ) );
                        HandleError( pUsnVolume, status );
                        break;
                    }
                }
            }
        } while( !fWait );

        if ( _fAbort )
            return;

        //
        // Wait for evtUsn to be signaled or for an usn notification
        //

        DWORD dwTimeout = _cicat.GetRegParams()->GetUsnReadTimeout() * 1000;

        //
        // But only wait forever if we're actually watching notifications...
        //

        if ( 0 == dwTimeout )
        {
            if ( fLowResource )
                dwTimeout = 60 * 1000;
            else
                dwTimeout = INFINITE;
        }

        //
        // If we're in a low resource situation, this is a good place to flush
        // the working set.
        //

        if ( fLowResource && _cicat.GetRegParams()->GetMinimizeWorkingSet() )
            SetProcessWorkingSetSize( GetCurrentProcess(), ~0, ~0 );

        _fWaitingForUpdates = TRUE;
        DWORD dwIndex = _waitForMultObj.Wait( dwTimeout );
        _fWaitingForUpdates = FALSE;

        if ( _fAbort || _fUpdatesDisabled )
            return;

        if ( WAIT_FAILED == dwIndex )
        {
            Win4Assert( !"Waitformultipleobjects failed" );
            ciDebugOut(( DEB_ERROR, "WaitForMultipleObjects failed, 0x%x", GetLastError() ));

            THROW( CException( ) );
        }

        if ( WAIT_OBJECT_0 == dwIndex )
        {
            //
            // _evtUsn has been signaled -- cancel pending requests
            //

            CUsnVolumeIter usnVolIter( _usnVolumesToMonitor );

            while ( !_usnVolumesToMonitor.AtEnd(usnVolIter) )
            {
                CUsnVolume *pUsnVolume = usnVolIter.GetEntry();
                _usnVolumesToMonitor.Advance(usnVolIter);
                pUsnVolume->CancelFsctl();
            }

            return;
        }
        else if ( WAIT_TIMEOUT != dwIndex )
        {
            //
            // Process usn notifications from the volume that was signaled.
            // GetIth does a linear lookup, it can be optimized to index
            // directly into an array of pUsnVolumes.
            //

            unsigned i = dwIndex - WAIT_OBJECT_0 - 1;
            CUsnVolume *pUsnVolume = _usnVolumesToMonitor.GetIth( i );

            //
            // We know the volume is at least the Ith volume, but it may be
            // farther if some volumes were skipped.
            //

            i++;  // Account for control event
            while ( pUsnVolume->GetFsctlEvent() != _waitForMultObj.Get(i) )
                pUsnVolume = (CUsnVolume *)pUsnVolume->Next();

            pUsnVolume->ResetFsctlPending();

            ciDebugOut(( DEB_ITRACE, "PENDING COMPLETED #1 (0x%x)\n", pUsnVolume ));

            if ( !fLowResource || pUsnVolume->PercentRead() < USN_LOG_DANGER_THRESHOLD )
                ProcessUsnLogRecords( pUsnVolume );

            if ( _fAbort || _fUpdatesDisabled )
                return;
        }

        if ( 0 != dwTimeout && !fLowResource )
        {
            //
            // Check to see if there is anything that's sat in the buffer too long.
            //

            LONGLONG ftExpired;
            GetSystemTimeAsFileTime( (FILETIME *)&ftExpired );
            ftExpired -= _cicat.GetRegParams()->GetUsnReadTimeout() * 10000i64;

            CUsnVolumeIter usnVolIter(_usnVolumesToMonitor);

            while( !_usnVolumesToMonitor.AtEnd(usnVolIter) )
            {
                if ( _fAbort || _fUpdatesDisabled )
                    break;

                CUsnVolume *pUsnVolume = usnVolIter.GetEntry();
                _usnVolumesToMonitor.Advance(usnVolIter);

                if ( !pUsnVolume->IsOnline() )
                    continue;

                if ( pUsnVolume->FFsctlPending() && pUsnVolume->PendingTime() <= ftExpired )
                {
                    pUsnVolume->CancelFsctl();

                    ciDebugOut(( DEB_ITRACE, "PENDING CANCELLED #1 (0x%x)\n", pUsnVolume ));

                    NTSTATUS status = ProcessUsnNotificationsFromVolume( pUsnVolume, TRUE ); // TRUE --> Immediate

                    switch( status )
                    {
                    case STATUS_PENDING:
                        pUsnVolume->SetFsctlPending();
                        break;

                    case STATUS_JOURNAL_ENTRY_DELETED:
                        break;

                    case STATUS_SUCCESS:
                        fWait = FALSE;    // More to do, processing bailed to enable round-robin
                        break;

                    default:
                        Win4Assert( !NT_SUCCESS( status ) );
                        HandleError( pUsnVolume, status );
                        break;
                    }
                }
            }
        }
    }
} //ProcessUsnNotifications

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ProcessUsnNotificationsFromVolume
//
//  Synopsis:   Process usn notifications from given volume
//
//  Arguments:  [pUsnVolume] -- Usn volume
//              [fImmediate] -- If TRUE, look for *any* new data in log,
//                              no matter how little.
//              [fWait]      -- If TRUE, wait for data if fImmediate is TRUE
//                              and no data is available.
//
//
//  Returns:    STATUS_PENDING when there are no more usn notifications to be
//              processed, or STATUS_JOURNAL_ENTRY_DELETED when usn records
//              have been removed from log due to shrink from front.
//
//  History:    05-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

NTSTATUS CUsnMgr::ProcessUsnNotificationsFromVolume( CUsnVolume * pUsnVolume,
                                                     BOOL         fImmediate,
                                                     BOOL         fWait )
{
    Win4Assert( pUsnVolume->IsOnline() );

    //
    // No need for a lock because only this thread modifies _usnVolumesToMonitor
    //

    Win4Assert( !pUsnVolume->FFsctlPending() );

    NTSTATUS status;
    unsigned cRetries = 0;  // Unsuccessful read attempts
    unsigned cTries   = 0;  // Successful read attempts

    READ_USN_JOURNAL_DATA usnReadData;
    usnReadData.UsnJournalID = pUsnVolume->JournalId();
    usnReadData.StartUsn = pUsnVolume->MaxUsnRead();
    usnReadData.ReasonMask = ~(USN_REASON_RENAME_OLD_NAME | USN_REASON_COMPRESSION_CHANGE);
    usnReadData.ReturnOnlyOnClose = TRUE;
    usnReadData.Timeout = 0;

    do
    {
        if ( _fAbort || _fUpdatesDisabled )
        {
            //
            // Doesn't matter what status we return because all notifications
            // will be turned off soon.
            //
            return STATUS_TOO_LATE;
        }

        //
        // In immediate mode, read *any* data, else read as requested by client.
        //

        if ( fImmediate )
            usnReadData.BytesToWaitFor = 1;
        else
            usnReadData.BytesToWaitFor = _cicat.GetRegParams()->GetUsnReadMinSize();

        #if CIDBG == 1
            RtlFillMemory( pUsnVolume->GetBuffer(), pUsnVolume->GetBufferSize(), 0x11 );
        #endif

        ciDebugOut(( DEB_ITRACE, "READ #1 (0x%x)\n", pUsnVolume ));

        Win4Assert( !pUsnVolume->FFsctlPending() );

        ciDebugOut(( DEB_ITRACE, "reading usns from %#I64x\n", usnReadData.StartUsn ));

        status = NtFsControlFile( pUsnVolume->VolumeHandle(),
                                  pUsnVolume->GetFsctlEvent(),
                                  NULL,
                                  NULL,
                                  pUsnVolume->IoStatusBlock(),
                                  FSCTL_READ_USN_JOURNAL,
                                  &usnReadData,
                                  sizeof(usnReadData),
                                  pUsnVolume->GetBuffer(),
                                  pUsnVolume->GetBufferSize() );

        if ( fImmediate )
        {
            if ( fWait )
                fImmediate = FALSE;

            //
            // STATUS_PENDING --> nothing in the log.  Go back to regular waits.
            //

            if ( STATUS_PENDING == status )
            {
                ciDebugOut(( DEB_ITRACE, "PENDING CANCELLED #2 (0x%x)\n", pUsnVolume ));
                pUsnVolume->SetFsctlPending();
                pUsnVolume->CancelFsctl();

                // If no journal entries are available and we're not supposed
                // to wait, return now.

                if ( !fWait )
                    return STATUS_SUCCESS;

                continue;
            }
        }

        if ( STATUS_PENDING == status )
            break;

        if ( NT_SUCCESS( status ) )
            status = pUsnVolume->IoStatusBlock()->Status;

        if ( NT_SUCCESS( status ) )
        {
            ciDebugOut(( DEB_ITRACE, "IMMEDIATE COMPLETED #1 (0x%x)\n", pUsnVolume ));
            ProcessUsnLogRecords( pUsnVolume );

            usnReadData.StartUsn = pUsnVolume->MaxUsnRead();

            Win4Assert( usnReadData.ReasonMask == ~(USN_REASON_RENAME_OLD_NAME | USN_REASON_COMPRESSION_CHANGE) );
            Win4Assert( usnReadData.ReturnOnlyOnClose == TRUE );

            //
            // Don't read a single volume too long...
            //

            cTries++;

            if ( cTries > 5 )
            {
                ciDebugOut(( DEB_ITRACE, "Stopping read on drive %wc: to support round-robin\n", pUsnVolume->DriveLetter() ));
                break;
            }
            else
                continue;
        }
        else if ( STATUS_JOURNAL_ENTRY_DELETED == status )
        {
            ciDebugOut(( DEB_ERROR, "STATUS_JOURNAL_ENTRY_DELETED #1 fWait %d, (drive %wc:)\n",
                         fWait, pUsnVolume->DriveLetter() ));

            // Already doing a scan due to missed notifications.

            if ( !fWait )
                return STATUS_JOURNAL_ENTRY_DELETED;

            //
            // STATUS_JOURNAL_ENTRY_DELETED is returned when usn records have
            // been deallocated from the usn journal. This means that we have to
            // do a scan before continuing usn monitoring. Even if some other
            // error code has been returned, the simplest recovery is to restart
            // monitoring.
            //

            XBatchUsnProcessing xBatchUsns( *this );

            CScanInfoList & usnScopeList = pUsnVolume->GetUsnScopesList();
            while ( usnScopeList.Count() > 0 )
            {
                XPtr<CCiScanInfo> xScanInfo( usnScopeList.Pop() );

                xScanInfo->SetStartState();
                xScanInfo->SetScan();
                ciDebugOut(( DEB_ERROR, "journal_entry_deleted, filing a scan for %ws\n", 
                             xScanInfo->GetPath() ));
                xScanInfo->SetStartUsn( pUsnVolume->MaxUsnRead() );
                xScanInfo->SetDoDeletions();
                _cicat.InitUsnTreeScan( xScanInfo->GetPath() );

                ScanScope( xScanInfo, TRUE );
            }

            _usnVolumesToMonitor.RemoveFromList( pUsnVolume );
            delete pUsnVolume;

            return STATUS_JOURNAL_ENTRY_DELETED;
        }
        else
        {
            ciDebugOut(( DEB_WARN, "Usn read fsctl returned 0x%x\n", status ));

            cRetries++;

            if ( cRetries > 10 )
            {
                ciDebugOut(( DEB_WARN, "Giving up on USN read.\n" ));
                break;
            }

            // the fsctl failed -- so try again
            continue;
        }
    } while ( status != STATUS_PENDING );

    return status;
} //ProcessUsnNotificationsFromVolume

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ProcessUsnLogRecords
//
//  Synopsis:   Process usn notifications from usn records in buffer
//
//  Arguments:  [pUsnVolume] -- Usn volume that contains the buffer
//
//  History:    05-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnMgr::ProcessUsnLogRecords( CUsnVolume *pUsnVolume )
{
    Win4Assert( pUsnVolume->IsOnline() );

    //
    // No need for a lock because only this thread modifies _usnVolumesToMonitor
    //

    USN usnNextStart;
    USN_RECORD * pUsnRec = 0;

    ciDebugOut(( DEB_ITRACE, "process usns, Status 0x%x, Bytes %d\n",
                 pUsnVolume->IoStatusBlock()->Status,
                 pUsnVolume->IoStatusBlock()->Information ));

    if ( !NT_SUCCESS( pUsnVolume->IoStatusBlock()->Status ) )
    {
        //
        // If we cancelled the notification request (usually because
        // we're going into a mode where we wait for a lot of bytes instead
        // of just 1 byte), just ignore processing the request.
        //

        if ( STATUS_CANCELLED != pUsnVolume->IoStatusBlock()->Status )
        {
            ciDebugOut(( DEB_WARN, "Error 0x%x reading USN Journal\n", pUsnVolume->IoStatusBlock()->Status ));
            Win4Assert( STATUS_INVALID_PARAMETER != pUsnVolume->IoStatusBlock()->Status );
        }

        return;
    }


    DWORD dwByteCount = (DWORD)pUsnVolume->IoStatusBlock()->Information;
    if ( dwByteCount != 0 )
    {
        usnNextStart = *(USN *)pUsnVolume->GetBuffer();
        pUsnRec = (USN_RECORD *)((PCHAR)pUsnVolume->GetBuffer() + sizeof(USN));
        dwByteCount -= sizeof(USN);
    }

    if ( 0 == pUsnRec )
        return;

    ICiManager *pCiManager = _cicat.CiManager();
    Win4Assert( pCiManager );

    while ( dwByteCount != 0 )
    {
        if ( _fAbort || _fUpdatesDisabled )
            return;

        //
        // Check that usn's from journal are greater than the start usn
        //

        #if CIDBG == 1
        if ( pUsnRec->Usn < pUsnVolume->MaxUsnRead() )
        {
            ciDebugOut(( DEB_ERROR,
                         "volume %wc pUsnRec = 0x%x, USN = %#I64x, Max USN = %#I64x\n",
                         pUsnVolume->VolumeId(), pUsnRec, pUsnRec->Usn,
                         pUsnVolume->MaxUsnRead() ));

            Win4Assert( pUsnRec->Usn >= pUsnVolume->MaxUsnRead() );

            Sleep( 30 * 1000 );
        }

        Win4Assert( pUsnRec->Usn >= pUsnVolume->MaxUsnRead() );

        if ( pUsnRec->RecordLength > 10000 )
        {
            ciDebugOut(( DEB_ERROR, "pUsnRec = 0x%x, RecordLength = %u\n", pUsnRec, pUsnRec->RecordLength ));
        }

        Win4Assert( pUsnRec->RecordLength <= 10000 );
        #endif

        if ( 0 == (pUsnRec->SourceInfo & (USN_SOURCE_AUXILIARY_DATA | USN_SOURCE_DATA_MANAGEMENT)) &&
             ( 0 == (pUsnRec->FileAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) ||
               0 != (pUsnRec->Reason & USN_REASON_INDEXABLE_CHANGE) ) )
        {
            //
            // Indexable bit==0 means index the file, because the bit is set to 0
            // by default on an upgrade from Ntfs 4.0 to Ntfs 5.0. We want the
            // the default behavior to be index-all-files to ensure backward
            // compatibility.
            //

            if ( pUsnRec->Reason & USN_REASON_RENAME_NEW_NAME )
            {
                CLowerFunnyPath lcaseFunnyOldPath;
                BOOL fOldPathInScope;
                _cicat.FileIdToPath( pUsnRec->FileReferenceNumber,
                                     pUsnVolume,
                                     lcaseFunnyOldPath,
                                     fOldPathInScope );

                CLowerFunnyPath lcaseFunnyNewPath;
                BOOL fNewPathInScope;
                WORKID widParent;
                #if CIDBG == 1
                    widParent = widUnused;
                #endif

                //
                // Try hard to find a parent directory, since it may
                // not be in the index if it is marked as not-indexed.
                //

                _cicat.UsnRecordToPathUsingParentId( pUsnRec,
                                                     pUsnVolume,
                                                     lcaseFunnyNewPath,
                                                     fNewPathInScope,
                                                     widParent,
                                                     TRUE );
                Win4Assert( widUnused != widParent );

                if ( pUsnRec->FileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                {
                    //
                    // Directory rename or add or delete. Directory operations are
                    // (re)tried a certain number of times, after which a failure
                    // event is logged.
                    //
                    const MAX_RETRIES = 5;
                    XGrowable<WCHAR> xFileName;

                    for (unsigned i=0; i<MAX_RETRIES; i++)
                    {
                        TRY
                        {
                            if ( fOldPathInScope )
                            {
                                if ( fNewPathInScope )
                                {
                                    ciDebugOut(( DEB_USN, "Renaming directory %ws to %ws\n", lcaseFunnyOldPath.GetPath(), lcaseFunnyNewPath.GetPath() ));

                                    CRenameDir( _cicat,
                                                lcaseFunnyOldPath,
                                                lcaseFunnyNewPath,
                                                _fUpdatesDisabled,
                                                pUsnVolume->VolumeId() );

                                    _cicat.Update( lcaseFunnyNewPath,
                                                   pUsnRec->FileReferenceNumber,
                                                   widParent,
                                                   pUsnRec->Usn,
                                                   pUsnVolume,
                                                   FALSE );
                                    break;
                                }
                                else
                                {
                                    CLowcaseBuf lcaseOldPath( lcaseFunnyOldPath.GetActualPath() );
                                    lcaseOldPath.AppendBackSlash();

                                    ciDebugOut(( DEB_USN, "Removing directory %ws\n", lcaseOldPath.Get() ));

                                    _cicat.RemovePathsFromCiCat( lcaseOldPath.Get(), eUsnsArray );

                                    if ( _fAbort || _fUpdatesDisabled )
                                    {
                                        return;
                                    }

                                    SCODE sc = pCiManager->FlushUpdates();
                                    if ( FAILED(sc) )
                                        THROW( CException( sc ) );

                                    break;
                                }
                            }
                            else
                            {
                                if ( fNewPathInScope )
                                {
                                    lcaseFunnyNewPath.AppendBackSlash();

                                    ciDebugOut(( DEB_USN, "Adding directory %ws\n", lcaseFunnyNewPath.GetPath() ));

                                    _fDoingRenameTraverse = TRUE;
                                    CUsnTreeTraversal usnTreeTrav( _cicat,
                                                                   *this,
                                                                   *pCiManager,
                                                                   lcaseFunnyNewPath,
                                                                   FALSE,         // No deletions
                                                                   _fUpdatesDisabled,
                                                                   TRUE,          // Process root
                                                                   pUsnVolume->VolumeId() );
                                    usnTreeTrav.EndProcessing();
                                    _fDoingRenameTraverse = FALSE;

                                    if ( _fAbort || _fUpdatesDisabled )
                                        return;

                                    SCODE sc = pCiManager->FlushUpdates();
                                    if ( FAILED(sc) )
                                        THROW( CException( sc ) );

                                    break;
                                }
                                else
                                {
                                    //
                                    // Both old and new paths are out of scope.  We *still* have to
                                    // determine whether this rename caused a top-level indexed scope
                                    // to either exist or cease to exist.
                                    //

                                    CheckTopLevelChange( pUsnVolume, pUsnRec->FileReferenceNumber );

                                    break;
                                }
                            }
                        }
                        CATCH( CException, e )
                        {
                            _fDoingRenameTraverse = FALSE;
#if CIDBG==1
                            //
                            // pUsnRec->FileName is not null terminated, so copy
                            // and null terminate.
                            //
                            unsigned cbFileNameLen = pUsnRec->FileNameLength;

                            xFileName.SetSizeInBytes( cbFileNameLen + 2 );

                            RtlCopyMemory( xFileName.Get(),
                                           (WCHAR *)(((BYTE *)pUsnRec) + pUsnRec->FileNameOffset),
                                           cbFileNameLen );
                            xFileName[cbFileNameLen/sizeof(WCHAR)] = 0;

                            ciDebugOut(( DEB_ERROR,
                                         "Exception 0x%x while doing directory rename/add/delete of %ws\n",
                                         e.GetErrorCode(),
                                         xFileName.Get() ));
#endif
                        }
                        END_CATCH
                    }   // for

                    if ( i == MAX_RETRIES )
                    {
                        CEventLog eventLog( NULL, wcsCiEventSource );
                        CEventItem item( EVENTLOG_ERROR_TYPE,
                                         CI_SERVICE_CATEGORY,
                                         MSG_CI_CONTENTSCAN_FAILED,
                                         1 );

                        //
                        // pUsnRec->FileName is not null terminated, so copy
                        // and null terminate.
                        //
                        unsigned cbFileNameLen = pUsnRec->FileNameLength;
                        xFileName.SetSizeInBytes( cbFileNameLen + 2 );

                        RtlCopyMemory( xFileName.Get(),
                                       (WCHAR *)(((BYTE *)pUsnRec) + pUsnRec->FileNameOffset),
                                       cbFileNameLen );
                        xFileName[cbFileNameLen/sizeof(WCHAR)] = 0;

                        item.AddArg( xFileName.Get() );
                        eventLog.ReportEvent( item );
                    }
                }
                else // if reason & FILE_ATTRIBUTE_DIRECTORY
                {
                    //
                    // File rename or add or delete
                    //

                    if ( fOldPathInScope )
                    {
                        if ( fNewPathInScope )
                        {
                            ciDebugOut(( DEB_USN, "Renaming file %ws to %ws\n",
                                         lcaseFunnyOldPath.GetActualPath(), lcaseFunnyNewPath.GetActualPath() ));

                            _cicat.RenameFile( lcaseFunnyOldPath,
                                               lcaseFunnyNewPath,
                                               pUsnRec->FileAttributes,
                                               pUsnVolume->VolumeId(),
                                               pUsnRec->FileReferenceNumber,
                                               widParent );

                            _cicat.Update( lcaseFunnyNewPath,
                                           pUsnRec->FileReferenceNumber,
                                           widParent,
                                           pUsnRec->Usn,
                                           pUsnVolume,
                                           FALSE );
                        }
                        else
                        {
                            _cicat.Update( lcaseFunnyOldPath,
                                           pUsnRec->FileReferenceNumber,
                                           widParent,
                                           pUsnRec->Usn,
                                           pUsnVolume,
                                           TRUE );
                        }
                    }
                    else
                    {
                        if ( fNewPathInScope )
                        {
                            _cicat.Update( lcaseFunnyNewPath,
                                           pUsnRec->FileReferenceNumber,
                                           widParent,
                                           pUsnRec->Usn,
                                           pUsnVolume,
                                           FALSE );
                        }
                        else
                        {
                            //
                            // Both old and new paths are out of scope, so do nothing
                            //
                        }
                    }
                }
            }
            else
            {
                Win4Assert( pUsnRec->Reason & USN_REASON_CLOSE );

                if ( 0 != (pUsnRec->Reason & ~(USN_REASON_CLOSE | USN_REASON_COMPRESSION_CHANGE | USN_REASON_RENAME_OLD_NAME ) ) )
                {
                    CLowerFunnyPath lcaseFunnyPath;
                    BOOL fPathInScope = FALSE;
                    WORKID widParent = widInvalid;

                    CReleasableLock lock( _cicat.GetMutex() );

                    WORKID wid = _cicat.FileIdToWorkId( pUsnRec->FileReferenceNumber,
                                                        pUsnVolume->VolumeId() );

                    if ( 0 != ( pUsnRec->Reason & USN_REASON_FILE_DELETE ) ||
                         0 != ( pUsnRec->FileAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED ) )
                    {
                        //
                        // File delete.  Don't delete directories that go from
                        // indexed to non-indexed since there may be files
                        // below them that are indexed.
                        //

                        if ( ( widInvalid != wid ) )
                        {
                            CDocumentUpdateInfo docInfo( wid,
                                                         pUsnVolume->VolumeId(),
                                                         pUsnRec->Usn,
                                                         TRUE );
                            pCiManager->UpdateDocument( &docInfo );
    
                            if ( ! ( ( pUsnRec->FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                                     ( pUsnRec->Reason & USN_REASON_INDEXABLE_CHANGE ) ) )
                            {
                                _cicat.LokMarkForDeletion( pUsnRec->FileReferenceNumber,
                                                           wid );
                            }
                            else
                            {
                                ciDebugOut(( DEB_ITRACE, "usn notify not deleting a ni directory\n" ));
                            }
                        }
                    }
                    else
                    {
                        //
                        // File create or modify
                        //

                        Win4Assert( pUsnRec->Reason & USN_REASON_CLOSE );

                        if ( widInvalid == wid )
                        {
                            _cicat.UsnRecordToPathUsingParentId( pUsnRec,
                                                                 pUsnVolume,
                                                                 lcaseFunnyPath,
                                                                 fPathInScope,
                                                                 widParent,
                                                                 ( 0 != ( pUsnRec->Reason & USN_REASON_INDEXABLE_CHANGE ) ) );

                            if ( fPathInScope )
                                _cicat.Update( lcaseFunnyPath,
                                               pUsnRec->FileReferenceNumber,
                                               widParent,
                                               pUsnRec->Usn,
                                               pUsnVolume,
                                               FALSE,  // not a delete
                                               &lock ); // guaranteed new file
                            else if ( pUsnRec->FileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                            {
                                //
                                // This might be a top-level directory.  No parent id to
                                // look up, but still the root of the tree.
                                //

                                lock.Release();

                                CheckTopLevelChange( pUsnVolume, pUsnRec->FileReferenceNumber );
                            }
                        }
                        else
                        {
                            lock.Release();

                            CDocumentUpdateInfo docInfo( wid,
                                                         pUsnVolume->VolumeId(),
                                                         pUsnRec->Usn,
                                                         FALSE );
                            pCiManager->UpdateDocument( &docInfo );
                        }
                    }   // if fPathInScope
                }   // if reason is one we care about
            }   // if-else reason & reason_new_name
        }   // pUsnRec->fileattr & file_attr_content_indexed

        if ( pUsnRec->RecordLength <= dwByteCount )
        {
            dwByteCount -= pUsnRec->RecordLength;

            //#if CIDBG == 1
            #if 0
                ULONG cb = pUsnRec->RecordLength;
                RtlFillMemory( pUsnRec, cb, 0xEE );
                pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + cb );
            #else
                pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + pUsnRec->RecordLength );
            #endif
        }
        else
        {
            Win4Assert( !"Bogus dwByteCount" );

            ciDebugOut(( DEB_ERROR,
                         "Usn read fsctl returned bogus dwByteCount, 0x%x\n",
                         dwByteCount ));

            THROW( CException( STATUS_UNSUCCESSFUL ) );
        }
    }

    pUsnVolume->SetMaxUsnRead( usnNextStart );
} //ProcessUsnLogRecords

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::FindCurrentMaxUsn
//
//  Synopsis:   Find the current max usn for the volume with pwcsScope
//
//  Arguments:  [pwcsScope] - Scope
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

USN CUsnMgr::FindCurrentMaxUsn( WCHAR const * pwcsScope )
{
    Win4Assert( pwcsScope );

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = pwcsScope[0];
    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );
    if ( hVolume == INVALID_HANDLE_VALUE )
        THROW( CException( STATUS_UNSUCCESSFUL ) );

    SWin32Handle xHandleVolume( hVolume );

    IO_STATUS_BLOCK iosb;
    USN_JOURNAL_DATA UsnJournalInfo;
    NTSTATUS Status = NtFsControlFile( hVolume,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &iosb,
                                       FSCTL_QUERY_USN_JOURNAL,
                                       0,
                                       0,
                                       &UsnJournalInfo,
                                       sizeof(UsnJournalInfo) );

    Win4Assert( STATUS_PENDING != Status );

    if ( NT_SUCCESS(Status) )
        Status = iosb.Status;

    if ( NT_ERROR(Status) )
    {
        //
        // Usn journal should have been created already
        //

        ciDebugOut(( DEB_ERROR,
                     "Usn read fsctl returned 0x%x\n",
                     Status ));

        THROW( CException( Status ) );
    }

    return UsnJournalInfo.NextUsn;
} //FindCurrentMaxUsn

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::SetBatch
//
//  Synopsis:   Sets the batch flag, which means that the usn thread will not
//              be signalled to start processing requests until the batch
//              flag is cleared.
//
//  History:    27-Jun-97     SitaramR     Created
//
//----------------------------------------------------------------------------

void CUsnMgr::SetBatch()
{
    CLock   lock(_mutex);
    _fBatch = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ClearBatch
//
//  Synopsis:   Clears the batch processing flag and wakes up the usn
//              thread and the accumulated scans processed.
//
//  History:    27-Jun-97     SitaramR     Created
//
//----------------------------------------------------------------------------

void CUsnMgr::ClearBatch()
{
    CLock   lock(_mutex);
    _fBatch = FALSE;
    _evtUsn.Set();
}

struct SVolumeUsn
{
    VOLUMEID volumeId;
    USN      usn;
};

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::ProcessUsnLog, public
//
//  Synopsis:   Processes all records in the USN log for all volumes.
//              This is so that we don't have to rescan when a scan
//              completes
//
//  Arguments:  [fAbort]  -- Bail if TRUE
//              [volScan] -- Volume Id of volume current being scanned (will
//                           be added to volumes processed).
//              [usnScan] -- USN on [volScan] at which monitoring will commence
//                           when scan is complete.
//
//  History:    28-May-98     dlee     Created
//
//----------------------------------------------------------------------------

void CUsnMgr::ProcessUsnLog( BOOL & fAbort, VOLUMEID volScan, USN & usnScan )
{
    if ( _fDoingRenameTraverse )
        return;

    CDynArrayInPlace<SVolumeUsn> aVolumeUsns;

    //
    // Add the volume actively being scanned.  No point in monitoring others with
    // pending scans, since they will be scanned anyway.
    //

    aVolumeUsns[0].volumeId = volScan;
    aVolumeUsns[0].usn = usnScan;

    //
    // Add all the volumes being monitored
    //

    {                                                                   // Save stack, by overloading usnVolIter
        for ( CUsnVolumeIter usnVolIter(_usnVolumesToMonitor);          // with the one farther down the function...
              !_usnVolumesToMonitor.AtEnd(usnVolIter);
              _usnVolumesToMonitor.Advance(usnVolIter) )
        {
            Win4Assert( !usnVolIter->FFsctlPending() );

            VOLUMEID volumeId = usnVolIter->VolumeId();
            USN usn = usnVolIter->MaxUsnRead();

            for ( unsigned i = 0; i < aVolumeUsns.Count(); i++ )
            {
                if ( aVolumeUsns[i].volumeId == volumeId )
                {
                    aVolumeUsns[i].usn = __min( aVolumeUsns[i].usn, usn );
                    break;
                }
            }

            if ( i == aVolumeUsns.Count() )
            {
                aVolumeUsns[ i ].volumeId = volumeId;
                aVolumeUsns[ i ].usn = usn;
            }
        }
    }

    //
    // Take this list, and create temporary volume objects.
    //

    CUsnVolumeList usnVolumesToProcess;

    for ( unsigned i = 0; i < aVolumeUsns.Count(); i++ )
    {
        CUsnVolume * pusnVolume = new CUsnVolume( (WCHAR) aVolumeUsns[i].volumeId, aVolumeUsns[i].volumeId );
        pusnVolume->SetMaxUsnRead( aVolumeUsns[i].usn );

        usnVolumesToProcess.Push( pusnVolume );
    }

    //
    // Process USNs for the volumes until they are all out of danger
    //

    BOOL fSomethingChanged = FALSE;
    int  priOriginal;
    unsigned cInDanger = 0;
    BOOL fFirst = TRUE;

    do
    {
        cInDanger = 0;

        for ( CUsnVolumeIter usnVolIter(usnVolumesToProcess);
              !usnVolumesToProcess.AtEnd(usnVolIter);
              usnVolumesToProcess.Advance(usnVolIter) )
        {
            CUsnVolume *pUsnVolume = usnVolIter.GetEntry();

            // Process the usn notifications for the volume.

            ULONG ulPct = pUsnVolume->PercentRead();

            // If the journal is entirely empty, it's not in danger.

            if ( !fFirst && ( 0 == ulPct ) && ( 0 == pUsnVolume->MaxUsnRead() ) )
                continue;

            // If we're in danger of a log overflow, process records.

            if ( ulPct < (fSomethingChanged ? USN_LOG_DANGER_THRESHOLD + 5 : USN_LOG_DANGER_THRESHOLD ) )
            {
                ciDebugOut(( DEB_ITRACE, "Drive %wc: in danger (%u%%)\n",
                             pUsnVolume->DriveLetter(), pUsnVolume->PercentRead() ));

                cInDanger++;

                if ( !fSomethingChanged )
                {
                    //
                    // Boost the priority to try and catch up before we fall farther behind.
                    // Normally, this thread runs at below normal priority.
                    //

                    priOriginal = GetThreadPriority( GetCurrentThread() );
                    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST );
                    fSomethingChanged = TRUE;
                }

                // TRUE == immediate processing
                // FALSE == don't wait for notifications

                NTSTATUS Status = ProcessUsnNotificationsFromVolume( pUsnVolume, TRUE, FALSE );

                Win4Assert( STATUS_PENDING != Status );

                //
                // Even if this is STATUS_JOURNAL_ENTRY_DELETED, we might as
                // well abort the scan.  Another will have been scheduled.
                //

                if ( !NT_SUCCESS(Status) )
                {
                    ciDebugOut(( DEB_ERROR, "Error %#x from ProcessUsnNotificationsFromVolume during scan\n", Status ));
                    THROW( CException( Status ) );
                }
            }

            fFirst = FALSE;

            ciDebugOut(( DEB_ITRACE, "Drive %wc: %u%% read (scan)\n",
                         pUsnVolume->DriveLetter(), ulPct ));
        }
    } while ( !fAbort && cInDanger > 0 );

    //
    // Update the max USNs
    //

    if ( fSomethingChanged )
    {
        //
        // Reset thread priority.
        //

        if ( THREAD_PRIORITY_ERROR_RETURN != priOriginal )
            SetThreadPriority( GetCurrentThread(), priOriginal );

        for ( CUsnVolumeIter usnVolIter(usnVolumesToProcess);
              !usnVolumesToProcess.AtEnd(usnVolIter);
              usnVolumesToProcess.Advance(usnVolIter) )
        {
            //
            // Patch the USN for the scan
            //

            if ( volScan == usnVolIter->VolumeId() )
                usnScan = usnVolIter->MaxUsnRead();

            for ( CFwdScanInfoIter scanInfoIter(_usnScansInProgress);
                  !_usnScansInProgress.AtEnd(scanInfoIter);
                  _usnScansInProgress.Advance(scanInfoIter) )
            {
                CCiScanInfo & scanInfo = * scanInfoIter.GetEntry();

                if ( scanInfo.VolumeId() == usnVolIter->VolumeId() )
                {
                    ciDebugOut(( DEB_ITRACE,
                                 "usn updating scan usn on %wc: from %#I64x to %#I64x\n",
                                 (WCHAR)scanInfo.VolumeId(),
                                 scanInfo.UsnStart(),
                                 usnVolIter->MaxUsnRead() ));
                    scanInfo.SetStartUsn( usnVolIter->MaxUsnRead() );
                }
            }

            // Patch the USN for the monitored volume

            for ( CUsnVolumeIter usnVolIter2(_usnVolumesToMonitor);
                  !_usnVolumesToMonitor.AtEnd(usnVolIter2);
                  _usnVolumesToMonitor.Advance(usnVolIter2) )
            {
                if ( usnVolIter->VolumeId() == usnVolIter2->VolumeId() )
                {
                    ciDebugOut(( DEB_ITRACE,
                                 "usn updating monitor volume %wc: from %#I64x to %#I64x\n",
                                 usnVolIter->DriveLetter(),
                                 usnVolIter->MaxUsnRead(),
                                 usnVolIter->MaxUsnRead() ));
                    usnVolIter2->SetMaxUsnRead( usnVolIter->MaxUsnRead() );
                }
            }
        }
    }
} //ProcessUsnLog

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::HandleError, public
//
//  Synopsis:   Error reporting / handling for USN log read errors.
//
//  Arguments:  [pUsnVolume] -- Volume which could not be read.
//              [Status]     -- Failure code.
//
//  History:    04-Jun-1998   KyleP  Created
//
//----------------------------------------------------------------------------

void CUsnMgr::HandleError( CUsnVolume * pUsnVolume, NTSTATUS Status )
{
    HandleError( pUsnVolume->DriveLetter(), Status );

    if ( STATUS_TOO_LATE != Status )
        pUsnVolume->MarkOffline();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::HandleError, public
//
//  Synopsis:   Error reporting / handling for USN log read errors.
//
//  Arguments:  [wcDrive] -- Volume which could not be read.
//              [Status]  -- Failure code.
//
//  History:    04-Jun-1998   KyleP  Created
//
//----------------------------------------------------------------------------

void CUsnMgr::HandleError( WCHAR wcDrive, NTSTATUS Status )
{
    Win4Assert( STATUS_SUCCESS != Status );

    if ( STATUS_TOO_LATE != Status )
    {
        CEventLog eventLog( NULL, wcsCiEventSource );

        CEventItem item( EVENTLOG_WARNING_TYPE,
                         CI_SERVICE_CATEGORY,
                         MSG_CI_USN_LOG_UNREADABLE,
                         2 );

        WCHAR wszDrive[] = L"A:";
        wszDrive[0] = wcDrive;

        item.AddArg( wszDrive );
        item.AddError( Status );

        eventLog.ReportEvent( item );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::IsPathIndexed, public
//
//  Synopsis:   Returns TRUE if the path is being indexed on a USN volume.
//
//  Arguments:  [pUsnVolume]     -- The volume to use when checking
//              [lcaseFunnyPath] -- The path to check
//
//  Returns:    TRUE if the path is in a current scan or in pUsnVolume.
//
//  History:    12-Jun-98     dlee     Created
//
//----------------------------------------------------------------------------

BOOL CUsnMgr::IsPathIndexed(
    CUsnVolume *  pUsnVolume,
    CLowerFunnyPath & lcaseFunnyPath )
{
    //
    // First check the volume object given
    //

    CScanInfoList & usnScopeList = pUsnVolume->GetUsnScopesList();

    for ( CFwdScanInfoIter iter( usnScopeList );
          !usnScopeList.AtEnd(iter);
          usnScopeList.Advance(iter) )
    {
        CScopeMatch scopeMatch( iter->GetPath(),
                                wcslen( iter->GetPath() ) );

        if ( scopeMatch.IsInScope( lcaseFunnyPath.GetActualPath(), lcaseFunnyPath.GetActualLength() ) )
            return TRUE;
    }

    //
    // Check the scans in progress list
    //

    for ( CFwdScanInfoIter scanInfoIter(_usnScansInProgress);
          !_usnScansInProgress.AtEnd(scanInfoIter);
          _usnScansInProgress.Advance(scanInfoIter) )
    {
        CCiScanInfo & scanInfo = * scanInfoIter.GetEntry();

        WCHAR const * pwcScanPath = scanInfo.GetPath();

        CScopeMatch scopeMatch( pwcScanPath, wcslen( pwcScanPath ) );

        if ( scopeMatch.IsInScope( lcaseFunnyPath.GetActualPath(), lcaseFunnyPath.GetActualLength() ) )
            return TRUE;
    }

    return FALSE;
} //IsPathIndexed

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::IsLowResource, private
//
//  Synopsis:   Determine if either memory or i/o resources are low.
//
//  Returns:    TRUE if in a low resource condition.
//
//  History:    22-Jun-1998   KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CUsnMgr::IsLowResource()
{
    if ( _cicat.GetRegParams()->DelayUsnReadOnLowResource() )
    {
        CI_STATE State;
        State.cbStruct = sizeof( State );

        SCODE sc = _cicat.CiState( State );

        if ( SUCCEEDED( sc ) )
            return ( 0 != (State.eState & ( CI_STATE_HIGH_IO |
                                            CI_STATE_LOW_MEMORY |
                                            CI_STATE_USER_ACTIVE ) ) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::AnyInitialScans
//
//  Synopsis:   Checks if any scans are the result of a new scope
//
//  Returns:    TRUE if any scans are for new scopes
//
//  History:    3-Aug-98   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CUsnMgr::AnyInitialScans()
{
    for ( CFwdScanInfoIter iter1( _usnScansToDo );
          !_usnScansToDo.AtEnd( iter1 );
          _usnScansToDo.Advance( iter1 ) )
    {
        if ( iter1->IsNewScope() )
            return TRUE;
    }

    for ( CFwdScanInfoIter iter2( _usnScansInProgress );
          !_usnScansInProgress.AtEnd( iter2 );
          _usnScansInProgress.Advance( iter2 ) )
    {
        if ( iter2->IsNewScope() )
            return TRUE;
    }

    return FALSE;
} //AnyInitialScans

//+---------------------------------------------------------------------------
//
//  Member:     CUsnMgr::CheckTopLevelChange, private
//
//  Synopsis:   Checks if renames or creates *above* top level scopes need
//              processing (because they affect top level).
//
//  Arguments:  [pUsnVolume]          -- USN volume change affects
//              [FileReferenceNumber] -- File ID of changing file
//
//  History:    08-Jan-1999   KyleP   Created
//
//----------------------------------------------------------------------------

void CUsnMgr::CheckTopLevelChange( CUsnVolume * pUsnVolume,
                                   ULONGLONG & FileReferenceNumber )
{
    //
    // Convert file ID to path.
    //

    CLowerFunnyPath fpRenamed;

    if ( 0 != _cicat.FileIdToPath( FileReferenceNumber, pUsnVolume->VolumeId(), fpRenamed ) )
    {
        CScopeMatch SMatch( fpRenamed.GetActualPath(), fpRenamed.GetActualLength() );

        //
        // Iterate through the top level scopes for this volume.
        //

        CScanInfoList & Scopes = pUsnVolume->GetUsnScopesList();

        for ( CFwdScanInfoIter ScopesIter( Scopes );
              !Scopes.AtEnd( ScopesIter );
              Scopes.Advance( ScopesIter ) )
        {
            if ( _fAbort || _fUpdatesDisabled )
                return;

            WCHAR const * pwcsPath = ScopesIter->GetPath();
            unsigned ccPath = wcslen(pwcsPath);

            //
            // Any top level scope that is underneath the rename must not have been
            // read before, so we need to add all the files.
            //

            if ( SMatch.IsInScope( pwcsPath, ccPath ) )
            {
                ICiManager *pCiManager = _cicat.CiManager();

                CLowerFunnyPath fpNew( pwcsPath, ccPath, TRUE );
                fpNew.AppendBackSlash();

                ciDebugOut(( DEB_USN, "Adding directory %ws\n", fpNew.GetActualPath() ));

                _fDoingRenameTraverse = TRUE;
                CUsnTreeTraversal usnTreeTrav( _cicat,
                                               *this,
                                               *pCiManager,
                                               fpNew,
                                               FALSE,         // No deletions
                                               _fUpdatesDisabled,
                                               TRUE,          // Process root
                                               pUsnVolume->VolumeId() );
                usnTreeTrav.EndProcessing();
                _fDoingRenameTraverse = FALSE;

                if ( _fAbort || _fUpdatesDisabled )
                    return;

                SCODE sc = pCiManager->FlushUpdates();

                if ( FAILED(sc) )
                    THROW( CException( sc ) );
            }

            //
            // Conversely, if the top level scope no longer exists, files must be
            // removed from the catalog.  The LokIsInFinalState check is to keep
            // us from retrying the same delete > once.
            //

            WIN32_FIND_DATA ffData;

            if ( !GetFileAttributesEx( pwcsPath, GetFileExInfoStandard, &ffData ) &&
                 ScopesIter->LokIsInFinalState() )
            {
                ScopesIter->SetStartState();

                CLowerFunnyPath fpOld( pwcsPath, ccPath, TRUE );
                fpOld.AppendBackSlash();
                ICiManager *pCiManager = _cicat.CiManager();

                ciDebugOut(( DEB_USN, "Removing directory %ws\n", fpOld.GetActualPath() ));

                _cicat.RemovePathsFromCiCat( fpOld.GetActualPath(), eUsnsArray );

                if ( _fAbort || _fUpdatesDisabled )
                    return;

                SCODE sc = pCiManager->FlushUpdates();

                if ( FAILED(sc) )
                    THROW( CException( sc ) );
            }
        }
    }
} //CheckTopLevelChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\usnvol.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       usnvol.cxx
//
//  Contents:   Usn volume info
//
//  History:    07-May-97   SitaramR    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntopen.hxx>

#include "usnvol.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CUsnVolume::CUsnVolume
//
//  Synopsis:   Constructor
//
//  Arguments:  [wcDriveLetter]   -- Drive letter
//              [volumeId]        -- Volume id
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CUsnVolume::CUsnVolume( WCHAR wcDriveLetter, VOLUMEID volumeId )
        : _hVolume(INVALID_HANDLE_VALUE),
          _wcDriveLetter(wcDriveLetter),
          _usnMaxRead(0),
          _volumeId(volumeId),
          _fileIdRoot(fileIdInvalid),
          _fFsctlPending(FALSE),
          _fOnline(TRUE)
{
    Win4Assert( volumeId != CI_VOLID_USN_NOT_ENABLED );

    //
    // Find the file id of root of volume
    //

    WCHAR wszRootPath[] = L"a:\\.";
    wszRootPath[0] = wcDriveLetter;

    HANDLE rootHandle = CiNtOpen( wszRootPath,
                                  FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  0 );

    SHandle xHandle( rootHandle );

    IO_STATUS_BLOCK iosb;
    ULONGLONG readBuffer[200];

    NTSTATUS status = NtFsControlFile( rootHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &iosb,
                                       FSCTL_READ_FILE_USN_DATA,
                                       NULL,
                                       NULL,
                                       &readBuffer,
                                       sizeof(readBuffer) );

    if ( NT_SUCCESS( status ) )
        status = iosb.Status;

    if ( NT_SUCCESS( status ) )
    {
        USN_RECORD *pUsnRec = (USN_RECORD *)((PCHAR) &readBuffer);

        //
        // Root is its own parent
        //
        Win4Assert( pUsnRec->FileReferenceNumber == pUsnRec->ParentFileReferenceNumber );

        _fileIdRoot = pUsnRec->FileReferenceNumber;
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "Unable to read usn info of root, 0x%x\n", status ));

        THROW( CException( status ) );
    }

    //
    // Create the volume handle that will be used for usn fsctls
    //

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = wcDriveLetter;

    _hVolume = CreateFile( wszVolumePath,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( _hVolume == INVALID_HANDLE_VALUE )
    {
        ciDebugOut(( DEB_ERROR, "Usn volume open failed, 0x%x", GetLastError() ));

        THROW( CException() );
    }

    //
    // Get the Journal ID
    //

    USN_JOURNAL_DATA UsnJournalInfo;

    status = NtFsControlFile( _hVolume,
                              NULL,
                              NULL,
                              NULL,
                              &iosb,
                              FSCTL_QUERY_USN_JOURNAL,
                              0,
                              0,
                              &UsnJournalInfo,
                              sizeof(UsnJournalInfo) );

    if ( status == STATUS_PENDING )
    {
        Win4Assert( !"Synchronous usn read returned status_pending" );
        _JournalID = 0;
    }
    else
    {
        if ( NT_SUCCESS( status ) )
            status = iosb.Status;

        if ( NT_SUCCESS(status) )
            _JournalID = UsnJournalInfo.UsnJournalID;
        else
            _JournalID = 0;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CUsnVolume::~CUsnVolume
//
//  Synopsis:   Destructor
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CUsnVolume::~CUsnVolume()
{
    Win4Assert( _hVolume != INVALID_HANDLE_VALUE );

    CancelFsctl();
    CloseHandle( _hVolume );
}



//+---------------------------------------------------------------------------
//
//  Member:     CUsnVolume::CancelFsctl
//
//  Synopsis:   Cancels any pending fsctls
//
//  History:    05-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CUsnVolume::CancelFsctl()
{
    if ( _fFsctlPending )
    {
        IO_STATUS_BLOCK iosb;
        NTSTATUS status = NtCancelIoFile( _hVolume, &iosb );

        if ( STATUS_SUCCESS != status )
        {
            ciDebugOut(( DEB_ERROR,
                         "NtCancelIoFile pending usn fsctl failed: %#x\n",
                         status ));
        }

        _evtFsctl.Wait( INFINITE );
        _fFsctlPending = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUsnVolume::PercentRead, public
//
//  Synopsis:   Compute current position in USN Journal
//
//  Returns:    Percentage through readable portion of USN Journal.
//
//  History:    22-Jun-98     KyleP       Created
//
//----------------------------------------------------------------------------

ULONG CUsnVolume::PercentRead()
{
    USN usnPct;

    if ( 0 == _usnMaxRead )
    {
        usnPct = 0;
    }
    else
    {
        USN_JOURNAL_DATA UsnJournalInfo;
        IO_STATUS_BLOCK iosb;

        NTSTATUS Status = NtFsControlFile( _hVolume,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &iosb,
                                           FSCTL_QUERY_USN_JOURNAL,
                                           0,
                                           0,
                                           &UsnJournalInfo,
                                           sizeof(UsnJournalInfo) );

        if ( Status == STATUS_PENDING )
        {
            Win4Assert( !"Synchronous usn read returned status_pending" );
            usnPct = 0;
        }
        else
        {
            if ( NT_SUCCESS( Status ) )
                Status = iosb.Status;

            if ( NT_SUCCESS(Status) )
            {
                //
                // Don't go negative.  If we've ran off the end (and will get
                // STATUS_JOURNAL_ENTRY_DELETED when reading the journal)
                // just report 0%
                //

                if ( _usnMaxRead >= UsnJournalInfo.FirstUsn )
                {
                    USN usnNum;
                    usnNum = _usnMaxRead - UsnJournalInfo.FirstUsn;

                    //
                    // Add 1 to avoid divide-by-zero errors.
                    //

                    USN usnDen = UsnJournalInfo.NextUsn - UsnJournalInfo.FirstUsn + 1;

                    usnPct = usnNum * 100 / usnDen;
                }
                else
                    usnPct = 0;
            }
            else
                usnPct = 0;
        }
    }

    Win4Assert( usnPct >= 0 && usnPct <= 100 );

    return (ULONG)usnPct;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\usntree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000
//
//  File:       usntree.cxx
//
//  Contents:   Tree traversal for usn scopes
//
//  History:    07-May-97   SitaramR    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntopen.hxx>
#include <pathpars.hxx>
#include <cifrmcom.hxx>
#include <funypath.hxx>

#include "cicat.hxx"
#include "usntree.hxx"
#include "usnmgr.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::CUsnTreeTraversal
//
//  Synopsis:   Constructor
//
//  Arguments:  [cicat]        -- Catalog
//              [ciManager]    -- CI manager
//              [lcaseFunnyRootPath] -- Root of scope
//              [fDoDeletions] -- Should deletions be done ?
//              [fAbort]       -- Abort flag
//              [fProcessRoot] -- Process root ?
//              [volumeId]     -- Volume id
//              [usnLow]       -- Ignore files with USN < [usnLow]
//              [usnHigh]      -- Ignore files with USN > [usnHigh]
//              [fUserInitiated] -- TRUE if the user asked for this
//
//  History:    07-May-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CUsnTreeTraversal::CUsnTreeTraversal( CiCat& cicat,
                                      CUsnMgr & usnMgr,
                                      ICiManager & ciManager,
                                      const CLowerFunnyPath & lcaseFunnyRootPath,
                                      BOOL fDoDeletions,
                                      BOOL & fAbort,
                                      BOOL fProcessRoot,
                                      VOLUMEID volumeId,
                                      USN const & usnLow,
                                      USN const & usnHigh,
                                      BOOL fUserInitiated )
        : CTraverse( cicat, fAbort, fProcessRoot ),
          _usnLow( usnLow ),
          _usnHigh( usnHigh ),
          _cicat(cicat),
          _usnMgr( usnMgr ),
          _ciManager(ciManager),
          _cDoc(0),
          _fDoDeletions(fDoDeletions),
          _volumeId(volumeId),
          _cProcessed(0),
          _fUserInitiated( fUserInitiated )
{
    BOOL fRootDeleted = FALSE;

    DWORD dw = GetFileAttributes( lcaseFunnyRootPath.GetPath() );
    if ( 0xffffffff == dw )
    {
        DWORD dwErr = GetLastError();
        ciDebugOut(( DEB_WARN,
                     "CUpdate::CUpdate(b) can't get attrinfo: %d, for %ws\n",
                     dwErr, lcaseFunnyRootPath.GetPath() ));
        if ( ERROR_FILE_NOT_FOUND == dwErr || ERROR_PATH_NOT_FOUND == dwErr )
            fRootDeleted = TRUE;
    }

    _docList.SetPartId ( 1 );
    FILETIME fTime;
    _cicat.StartUpdate( &fTime, lcaseFunnyRootPath.GetActualPath(), fDoDeletions, eUsnsArray );

    // Make sure EndProcessing deletes all the files in the scope

    if ( fRootDeleted )
    {
        _status = STATUS_NO_MORE_FILES;
        return;
    }

    ciDebugOut(( DEB_ITRACE, "usntree: usnlow %#I64x, usnHigh %I64x\n",
                 usnLow, usnHigh ));

    if ( _fDoDeletions )
    {
        WORKID wid = _cat.PathToWorkId( lcaseFunnyRootPath, eUsnsArray, fileIdInvalid );

        //
        // Workid is invalid for root, such as f:\
        //
        if ( wid != widInvalid )
            _cicat.Touch( wid, eUsnsArray );
    }

    DoIt( lcaseFunnyRootPath );
} //CUsnTreeTraversal

//+---------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::ProcessFile
//
//  Synopsis:   Processes the given file and adds it to the list of changed
//              documents if necessary.
//
//  Arguments:  [lcaseFunnyPath] -  Path of the file to be processed.
//
//  Returns:    TRUE if successful
//
//  History:    07-May-97   SitaramR    Created
//
//----------------------------------------------------------------------------

BOOL CUsnTreeTraversal::ProcessFile( const CLowerFunnyPath & lcaseFunnyPath )
{
    ciDebugOut(( DEB_USN, "Usn process file %ws\n", lcaseFunnyPath.GetActualPath() ));

    USN usn;
    FILEID fileId;
    WORKID widParent;
    FILETIME ftLastChange;

    BOOL fOk = GetUsnInfo( lcaseFunnyPath,
                           _cicat,
                           _volumeId,
                           usn,
                           fileId,
                           widParent,
                           ftLastChange );

    if ( fOk )
    {
        WORKID wid;

        BOOL fAdded = _cicat.ProcessFile( lcaseFunnyPath,
                                          fileId,
                                          _volumeId,
                                          widParent,
                                          _pCurEntry->Attributes(),
                                          wid );

        ciDebugOut(( DEB_ITRACE,
                     "wid %d(%x), fAdded %d, _fUserInitiated %d, usn %#I64x,"
                     " _usnLow %#I64x, _usnHigh %#I64x\n",
                     wid, wid, fAdded, _fUserInitiated, usn,
                       _usnLow, _usnHigh ));

        if ( widInvalid != wid )
        {
#if 0 // NOTE: we can't use this optimization because we don't know why the
      //       USN is higher than _usnHigh.  We might later choose to not
      //       filter based on this USN change.
            if ( usn > _usnHigh )
            {
                // Modified since scan began.  Don't file twice.
                _cicat.Touch( wid, eUsnsArray );
            }
            else
#endif // 0
            if ( _fUserInitiated || ( 0 == usn ) )
            {
                // User asked to filter everything or NT4 create
                Add ( wid );
            }
            else if ( 0 == _usnLow )
            {
                // Initial scan -- filter if we added the file OR
                // if the file has changed since we filtered it last.

                if ( fAdded || _cicat.HasChanged( wid, ftLastChange ) )
                {
                    Add ( wid );
                }
                else
                {
                    // Make sure we don't delete it!
                    _cicat.Touch(wid, eUsnsArray);
                }
            }
            else if ( usn >= _usnLow )
            {
                Add ( wid );
            }
            else if ( _cicat.HasChanged( wid, ftLastChange ) )
            {
                // NT4 Modify
                Add( wid );
            }
            else
            {
                // Make sure we don't delete it!
                _cicat.Touch(wid, eUsnsArray);
            }
        }
    }

    return TRUE;
} //ProcessFile

//+-------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::TraversalIdle, public
//
//  Synopsis:   Called when a directory is about to be traversed, when
//              the traversal code isn't buffering any paths.  This makes
//              it a good time to check the USN log, since the Win32 file
//              enumeration code buffers files within a given directory.
//
//  Arguments:  [fStalled] -- TRUE implies scanning halted due to resource
//                            constraints.  Only critical work should be done.
//
//  History:    16-Jun-98    dlee    Created
//
//--------------------------------------------------------------------------

void CUsnTreeTraversal::TraversalIdle( BOOL fStalled )
{
    //
    // Every now and then, go empty the USN logs so they won't overflow
    // during the scan.
    //

    if ( _cProcessed > 1000 || fStalled )
    {
        ciDebugOut(( DEB_USN, "CUsnTreeTraversal: ProcessUsnLog\n" ));
        _usnMgr.ProcessUsnLog( _fAbort, _volumeId, _usnHigh );

        if ( _cProcessed > 1000 )
            _cProcessed = 0;
    }
} //ProcessDirectoryTraversal

//+-------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::Add
//
//  Synopsis:   Add wid for update to doclist
//
//  Arguments:  [wid] -- Workid
//
//  History:    07-May-97    SitaramR    Created
//
//--------------------------------------------------------------------------

void CUsnTreeTraversal::Add( WORKID wid )
{
    _cicat.Touch(wid, eUsnsArray);

    ciDebugOut(( DEB_USN, " Add %d(%x) as doc %d\n", wid, wid, _cDoc ));

    //
    // Use an usn of 0, because we are adding wids in tree order, not usn order
    //
    _docList.Set ( _cDoc, wid, 0, _volumeId );

    _cDoc++;

    if (_cDoc == CI_MAX_DOCS_IN_WORDLIST)
    {
        _cProcessed += _cDoc;

        _docList.LokSetCount ( _cDoc );

        _cicat.AddDocuments( _docList );

        _docList.LokClear();
        _docList.SetPartId ( 1 );
        _cDoc = 0;

        // NTRAID#DB-NTBUG9-83800-2000/07/31-dlee notifications can be missed if > 10k files in a directory
        //
        // This will hit if a directory has > 10k files.  In this case, we
        // need to read the USN log so it won't overflow, but we may
        // mis-interpret the scan since the Win32 enumeration API buffers
        // a small number of files during the enumeration.  This is a lesser
        // of 2 evils fix.  A file will be falsely added to the catalog if it
        // is in the enumeration buffer buffer, then deleted before it
        // is processed.  This window has existed on FAT for a long time
        // and hasn't been hit.
        //

        if ( _cProcessed > 10000 )
        {
            ciDebugOut(( DEB_USN, "Add: ProcessUsnLog\n" ));
            _usnMgr.ProcessUsnLog( _fAbort, _volumeId, _usnHigh );
            _cProcessed = 0;
        }
    }
} //Add

//+---------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::IsEligibleForTraversal
//
//  Synopsis:   Checks to see if the current directory is eligible for
//              traversal.
//
//  Arguments:  [lcaseFunnyDir] - Directory path
//
//  History:    07-May-97   SitaramR   Created
//
//----------------------------------------------------------------------------

BOOL CUsnTreeTraversal::IsEligibleForTraversal( const CLowerFunnyPath & lcaseFunnyDir ) const
{
    return _cicat.IsEligibleForFiltering( lcaseFunnyDir );
}

//+-------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::EndProcessing
//
//  Synopsis:   Flush final updates to catalog
//
//  History:    07-May-97    SitaramR    Created
//
//--------------------------------------------------------------------------

void CUsnTreeTraversal::EndProcessing()
{
    ciDebugOut(( DEB_ITRACE,
                 "CUsnTreeTraversal__EndProcessing, _fAbort %d, _cDoc %d, _status %#x\n",
                 _fAbort, _cDoc, _status ));

    if ( !_fAbort )
    {
        if ( _cDoc != 0 )
        {
            _docList.LokSetCount ( _cDoc );
            _cicat.AddDocuments( _docList );
            _docList.LokClear();
            _docList.SetPartId ( 1 );
            _cDoc = 0;
        }

        if ( STATUS_NO_MORE_FILES == _status )
        {
            ciDebugOut(( DEB_ITRACE, "_fDoDeletions %d\n", _fDoDeletions ));
            _cat.EndUpdate( _fDoDeletions, eUsnsArray );
        }
        else if ( STATUS_SUCCESS != _status )
        {
            ciDebugOut(( DEB_ERROR, "Error %#x while traversing\n",
                         _status ));
            THROW( CException( _status ) );
        }
    }
} //EndProcessing

//+-------------------------------------------------------------------------
//
//  Member:     CUsnTreeTraversal::GetUsnInfo
//
//  Synopsis:   Returns fileid etc info for given file
//
//  Arguments:  [funnyPath]     -- Path to file
//              [cicat]         -- Catalog
//              [volumeId]      -- Volume id
//              [usn]           -- Usn returned here
//              [fileId]        -- FileId returned here
//              [widParent]     -- Workid of parent returned here
//              [ftLastChange]  -- Time of last change (data, EA, security, ...)
//
//  History:    07-May-97    SitaramR    Created
//
//  Notes:      The routine doesn't throw, it returns false to indicate that
//              the tree traversal must continue after skipping over the
//              current file.
//
//--------------------------------------------------------------------------

BOOL CUsnTreeTraversal::GetUsnInfo( const CFunnyPath & funnyPath,
                                    CiCat &cicat,
                                    VOLUMEID volumeId,
                                    USN &usn,
                                    FILEID &fileId,
                                    WORKID &widParent,
                                    FILETIME &ftLastChange )
{
    HANDLE hFile;
    NTSTATUS status = CiNtOpenNoThrow( hFile,
                                       funnyPath.GetPath(),
                                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE |
                                       FILE_SHARE_DELETE,
                                       0 );

    if ( !NT_SUCCESS( status ) )
    {
        // File may have been deleted, in use etc, so skip processing the file.

        ciDebugOut(( DEB_ITRACE,
                     "File open for %ws get usn info failed (0x%x)\n",
                     funnyPath.GetPath(), status ));

        #if CIDBG == 1
        if ( IsSharingViolation( status ) ||
               STATUS_ACCESS_DENIED == status ||
               STATUS_INVALID_PARAMETER == status ||
               STATUS_DELETE_PENDING == status ||
               STATUS_UNRECOGNIZED_VOLUME == status ||
               STATUS_INSUFFICIENT_RESOURCES == status ||
               STATUS_OBJECT_PATH_NOT_FOUND == status ||
               STATUS_OBJECT_NAME_NOT_FOUND == status ||
               STATUS_IO_REPARSE_TAG_NOT_HANDLED == status ||
               STATUS_NO_MEDIA_IN_DEVICE == status || // junction points can hit this
               STATUS_OBJECT_NAME_INVALID == status ) 
            return FALSE;
        else
        {
            #if CIDBG == 1
                char szTemp[200];
                sprintf( szTemp, "New error 0x%x from NtCreateFile in ::GetUsnInfo.  Call dlee or hit 'g'", status );
                Win4AssertEx(__FILE__, __LINE__, szTemp);
            #endif

            // THROW( CException( status ) );
        }
        #endif

        return FALSE;
    }

    SHandle xFile( hFile );


    // NTRAID#DB-NTBUG9-83802-2000/07/31-dlee File names are limited to 400 characters when reading USN records

    IO_STATUS_BLOCK iosb;
    ULONGLONG readBuffer[100];
    USN_RECORD *pUsnRecord;
    status = NtFsControlFile( hFile,
                              NULL,
                              NULL,
                              NULL,
                              &iosb,
                              FSCTL_READ_FILE_USN_DATA,
                              NULL,
                              NULL,
                              &readBuffer,
                              sizeof(readBuffer) );

    if ( NT_SUCCESS( status ) )
        status = iosb.Status;

    if ( NT_SUCCESS( status ) )
    {
        FILE_BASIC_INFORMATION BasicInfo;
        status = NtQueryInformationFile( hFile,
                                         &iosb,
                                         &BasicInfo,
                                         sizeof(BasicInfo),
                                         FileBasicInformation );

        if ( NT_SUCCESS( status ) )
            status = iosb.Status;

        if ( NT_SUCCESS( status ) )
        {
            pUsnRecord = (USN_RECORD *) &readBuffer;
            fileId = pUsnRecord->FileReferenceNumber;

            //
            // If not indexed, return FALSE unless it's a directory and it's
            // already in the index.  We need to leave these in case there
            // are files below the directory.
            //

            if ( ( 0 != (pUsnRecord->FileAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) ) )
            {
                if ( 0 == (pUsnRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                    return FALSE;

                WORKID wid = cicat.FileIdToWorkId( fileId, volumeId );

                if ( widInvalid == wid )
                    return FALSE;

                ciDebugOut(( DEB_ITRACE, "leaving special-case directory\n" ));
            }

            usn = pUsnRecord->Usn;

            //
            // Workid of parent will be widInvalid for files in root directory
            //
            widParent = cicat.FileIdToWorkId( pUsnRecord->ParentFileReferenceNumber,
                                              volumeId );

            ftLastChange = *(FILETIME *)&BasicInfo.ChangeTime;
        }
        else
        {
            // NTRAID#DB-NTBUG9-83804-2000/07/31-dlee When a lookup of USN info fails during a USN scan due to low resources we don't abort the scan
            //
            // Incorrect behavior if out of resources -- we need to
            // restart the scan!
            //
            //         Need to handle reparse point errors like
            //         STATUS_IO_REPARSE_TAG_NOT_HANDLED.  For now, ignore
            //

            ciDebugOut(( DEB_ITRACE, "NtQueryInformationFile failed, 0x%x\n", status ));

            return FALSE;
        }
    }
    else
    {

        // NTRAID#DB-NTBUG9-83804-2000/07/31-dlee When a lookup of USN info fails during a USN scan due to low resources we don't abort the scan

        // incorrect behavior if out of resources -- we need to
        // restart the scan!
        //
        // Need to handle reparse point errors like
        // STATUS_IO_REPARSE_TAG_NOT_HANDLED.  For now, ignore
        //

        ciDebugOut(( DEB_ITRACE, "File usn read fsctl failed, 0x%x\n", status ));

        return FALSE;
    }

    return TRUE;
} //GetUsnInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\update.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   UPDATE.CXX
//
//  Contents:   Content Index Update
//
//  History:    19-Mar-92   AmyA        Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <imprsnat.hxx>
#include <pathpars.hxx>
#include <cifrmcom.hxx>
#include <lcase.hxx>

#include "cicat.hxx"
#include "update.hxx"

//+---------------------------------------------------------------------------
//
//  Class:      CImpersonatedFindFirst
//
//  Purpose:    A class that is capable of repeatedly trying to do a find
//              first until there is success or is not retryable any more.
//              Changes impersonation between attempts.
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

class CImpersonatedFindFirst: public PImpersonatedWorkItem
{

public:

    CImpersonatedFindFirst( const CFunnyPath & funnyPath, HANDLE & h )
            : PImpersonatedWorkItem( funnyPath.GetActualPath() ),
              _funnyPath( funnyPath ),
              _h(h)
    {

    }


    BOOL OpenFindFirst( CImpersonateRemoteAccess & remoteAccess );

    BOOL DoIt();        // virtual

private:

    HANDLE &            _h;
    const CFunnyPath &  _funnyPath;
};

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonatedFindFirst::OpenFindFirst
//
//  Synopsis:   Opens the first first handle, impersonating as necessary.
//
//  Arguments:  [remoteAccess] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonatedFindFirst::OpenFindFirst(
                                CImpersonateRemoteAccess & remoteAccess )
{
    BOOL fSuccess = TRUE;

    TRY
    {
        ImpersonateAndDoWork( remoteAccess );
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "OpenFindFirst (%ws) failed with error (0x%X)\n",
                     _funnyPath.GetPath(), e.GetErrorCode() ));
        fSuccess = FALSE;
    }
    END_CATCH

    return fSuccess;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonatedFindFirst::DoIt
//
//  Synopsis:   The worker method that does the work in the context of
//              impersonation.
//
//  Returns:    TRUE if successful; FALSE if should be retried; THROWS
//              otherwise.
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonatedFindFirst::DoIt()
{
    //
    // Open directory
    //

    NTSTATUS Status =
        CiNtOpenNoThrow( _h,
                         _funnyPath.GetPath(),
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

    if ( !NT_SUCCESS(Status) )
    {
        if ( IsRetryableError( Status ) )
            return FALSE;
        else
        {
            THROW( CException( Status ) );
        }
    }

    return TRUE;
} //DoIt

//+---------------------------------------------------------------------------
//
//  Member:     CTraverse::CTraverse
//
//  Synopsis:   Constructor of the CTraverse class.
//
//  Arguments:  [fAbort]   - A reference to an abort triggering variable.
//
//  History:    3-15-96   srikants   Split from CUpdate
//
//----------------------------------------------------------------------------

CTraverse::CTraverse( CiCat & cat,
                      BOOL & fAbort,
                      BOOL fProcessRoot )
        : _cat( cat ),
          _fAbort(fAbort),
          _fProcessRoot(fProcessRoot),
          _cProcessed( 0 ),
          _xbBuf( FINDFIRST_SIZE ),
          _pCurEntry( 0 ),
          _status( STATUS_SUCCESS )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraverse::DoIt
//
//  Synopsis:   Traverses the tree from the given root and invokes the
//              "ProcessFile" method on all the files found. Also, before
//              starting to traverse a directory, it calls the
//              "IsEligibleForTraversal()" method on that.
//
//  Arguments:  [lcaseFunnyRootPath] - The path to traverse.
//
//  History:    3-15-96   srikants   Split from CUpdate constructor
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTraverse::DoIt( const CLowerFunnyPath & lcaseFunnyRootPath )
{
    Push( lcaseFunnyRootPath );

    if ( _fProcessRoot )
    {
        Win4Assert( 0 == _pCurEntry );

        // Note this is a bit of a hack.  Only the attributes field is valid.

        _pCurEntry = (CDirEntry *)_xbBuf.GetPointer();

        ULONG ulAttrib = 0;

        if ( CImpersonateRemoteAccess::IsNetPath( lcaseFunnyRootPath.GetActualPath() ) )
        {
            CImpersonateRemoteAccess remote( _cat.GetImpersonationTokenCache() );
            CImpersonatedGetFileAttr getAttr( lcaseFunnyRootPath );

            getAttr.DoWork( remote );
            ulAttrib = getAttr.GetAttr();
        }
        else
        {
            ulAttrib = GetFileAttributes( lcaseFunnyRootPath.GetPath() );
        }

        _pCurEntry->SetAttributes( ulAttrib );

        //
        // If we got an error value for file attributes, then substitute zero
        // because we don't want the directory bit to be turned on
        //

        if ( INVALID_FILE_ATTRIBUTES == _pCurEntry->Attributes() )
            _pCurEntry->SetAttributes( 0 );

        if ( !ProcessFile( lcaseFunnyRootPath ) )
            return;
    }

    CImpersonateRemoteAccess remote( _cat.GetImpersonationTokenCache() );

    for (;;)
    {
        XPtr<CLowerFunnyPath> xLowerFunnyPath;

        if ( !Pop( xLowerFunnyPath ) )
            break;

        if ( !Traverse(xLowerFunnyPath, remote))
            break;
    }
} //DoIt

//+---------------------------------------------------------------------------
//
//  Member:     CTraverse::Traverse
//
//  Synopsis:   Traverses the specified directory.
//
//  Arguments:  [dir] -
//
//  History:    3-15-96   srikants   Split from CUpdate::Traverse
//
//----------------------------------------------------------------------------

BOOL CTraverse::Traverse (XPtr<CLowerFunnyPath> & xLowerFunnyPath, CImpersonateRemoteAccess & remote )
{
    if ( !IsEligibleForTraversal( xLowerFunnyPath.GetReference() ) )
    {
        ciDebugOut (( DEB_ITRACE, "Traverse skipping %ws\n", xLowerFunnyPath->GetActualPath() ));
        return TRUE;
    }

    TraversalIdle();

    CFullPath fullPath( xLowerFunnyPath->GetActualPath(), xLowerFunnyPath->GetActualLength() );

    ciDebugOut (( DEB_ITRACE, "Traversing %ws\n", fullPath.GetBuf()));

    ULONG cSkip = 0;

    HANDLE h;

    if ( CImpersonateRemoteAccess::IsNetPath( xLowerFunnyPath->GetActualPath() ) )
    {
        CImpersonatedFindFirst findFirst( fullPath.GetFunnyPath(), h );

        if ( !findFirst.OpenFindFirst( remote ) )
            return TRUE;
    }
    else
    {
        //
        // Open directory
        //

        NTSTATUS Status =
            CiNtOpenNoThrow( h,
                             xLowerFunnyPath->GetPath(),
                             FILE_LIST_DIRECTORY | SYNCHRONIZE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

        if ( !NT_SUCCESS(Status) )
            return TRUE;
    }

    SHandle xHandle(h);

    //
    // First enumeration
    //

    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;

    Status = NtQueryDirectoryFile( h,                      // File
                                   0,                      // Event
                                   0,                      // APC routine
                                   0,                      // APC context
                                   &IoStatus,              // I/O Status
                                   _xbBuf.GetPointer(),    // Buffer
                                   _xbBuf.SizeOf(),        // Buffer Length
                                   FileBothDirectoryInformation,
                                   0,                      // Multiple entry
                                   0,                      // Filename
                                   1 );                    // Restart scan

    if ( NT_SUCCESS(Status) )
        Status = IoStatus.Status;

    //
    // If there are no more files or we don't have access to any more files
    // in this branch of the tree, just continue traversing.  Otherwise throw.
    //

    if ( !NT_SUCCESS(Status) )
    {
        if ( STATUS_NO_MORE_FILES == Status ||
             STATUS_NO_SUCH_FILE  == Status ||
             STATUS_ACCESS_DENIED == Status )
            return TRUE;

        THROW( CException( Status ) );
    }

    _pCurEntry = (CDirEntry *)_xbBuf.GetPointer();
    BOOL fMore = TRUE;

    ULONG ulScanBackoff = _cat.GetRegParams()->GetScanBackoff();

    do
    {
        //
        // Sleep for a while to let other I/O get through if appropriate.
        //
        // For reference, with 105,000 files on a free build, here are the
        // scan times ( for mod of 50 and sleep(200) * ulScanBackoff )
        //
        // ScanBackoff  Time (min:sec)
        // -----------  --------------
        //  0            8:40
        //  1           18:03
        //  3           43:11
        //

        if ( 0 != ulScanBackoff )
        {
            if ( ulScanBackoff > CI_SCAN_BACKOFF_MAX_RANGE )
            {
                //
                // These values are reserved for future use.
                //
            }
            else if ( ( _cProcessed % 50 ) == 0 )
            {
                for ( unsigned i = 0; !_fAbort && i < ulScanBackoff; i++ )
                    Sleep( 100 );

                //
                // If we're running ahead of filtering, then let's take a break.
                // What's the point in running up a big change log for no reason?
                //
                // Attempt to keep primary and secondary store pages in memory.
                // The primary store keeps 1489 records per 64k page and the
                // secondary by default keeps 140.  By keeping the scan
                // thread only a little ahead of the filter thread we
                // thrash less.
                //

                unsigned cLoops = 0;

                while ( !_fAbort )
                {
                    CI_STATE State;
                    State.cbStruct = sizeof State;

                    SCODE sc = _cat.CiState( State );

                    if ( FAILED(sc) ||
                         ( (State.cDocuments - State.cSecQDocuments) < 200 &&
                           ( 0 == (State.eState & ( CI_STATE_HIGH_IO |
                                                    CI_STATE_LOW_MEMORY |
                                                    CI_STATE_USER_ACTIVE ) ) ) ) )
                        break;

                    //
                    // Only call TraverseIdle if filtering has been stalled
                    // for a long time -- every 60 seconds or so.
                    //

                    cLoops++;

                    if ( 0 == ( cLoops % 30 ) )
                        TraversalIdle( TRUE ); // TRUE --> Stalled (not scanning)

                    //
                    // Sleep for a few of seconds, checking for abort.
                    //

                    for ( unsigned i = 0; !_fAbort && i < 3; i++ )
                        Sleep( 100 );
                }
            }
        }

        _cProcessed++;

        //
        // Get out?
        //

        if ( _fAbort )
        {
            ciDebugOut(( DEB_ITRACE, "Aborting scan in the middle\n" ));
            break;
        }

        fullPath.MakePath( _pCurEntry->Filename(), _pCurEntry->FilenameSize() / sizeof(WCHAR) );

        BOOL fSkipFile = FALSE;

        // If it's a directory and not a reparse point, push it on the stack

        if ( ( 0 != ( _pCurEntry->Attributes() & FILE_ATTRIBUTE_DIRECTORY ) ) &&
             ( 0 == ( _pCurEntry->Attributes() & FILE_ATTRIBUTE_REPARSE_POINT ) ) )
        {
            if ( _pCurEntry->Filename()[0] == L'.' &&
                 ( _pCurEntry->FilenameSize() == sizeof(WCHAR) ||
                   (_pCurEntry->Filename()[1] == L'.' && _pCurEntry->FilenameSize() == sizeof(WCHAR) * 2 ) ) )
            {
                fSkipFile = TRUE;
            }
            else
            {
                // Neither "." nor ".." directories

                Push( fullPath.GetFunnyPath() );
            }
        }

        if ( !fSkipFile )
            if ( !ProcessFile( fullPath.GetFunnyPath() ) )
            {
                _status = HRESULT_FROM_WIN32( GetLastError() );
                return FALSE;
            }

        _pCurEntry = _pCurEntry->Next();

        if ( 0 == _pCurEntry )
        {
            Status = NtQueryDirectoryFile( h,                      // File
                                           0,                      // Event
                                           0,                      // APC routine
                                           0,                      // APC context
                                           &IoStatus,              // I/O Status
                                           _xbBuf.GetPointer(),    // Buffer
                                           _xbBuf.SizeOf(),        // Buffer Length
                                           FileBothDirectoryInformation,
                                           0,                      // Multiple entry
                                           0,                      // Filename
                                           0 );                    // Continue scan

            if ( NT_SUCCESS(Status) )
                Status = IoStatus.Status;

            if ( NT_SUCCESS( Status ) )
                _pCurEntry = (CDirEntry *)_xbBuf.GetPointer();
            else
                fMore = FALSE;
        }
    } while ( fMore );

    if ( !_fAbort )
    {
        if ( STATUS_NO_SUCH_FILE == Status )
            Status = STATUS_NO_MORE_FILES;

        _status = Status;

        return STATUS_NO_MORE_FILES == _status;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CUpdate::CUpdate, public
//
//  Synopsis:   Perform update of scope.  All work done from constructor.
//
//  Arguments:  [cat]                -- Catalog
//              [lcaseFunnyRootPath] -- Root of scope
//              [PartId]             -- Partition id
//              [fIncrem]            -- TRUE if this is an incremental update
//
//  History:    04-Jan-96  KyleP    Added header
//
//--------------------------------------------------------------------------

CUpdate::CUpdate ( CiCat& cat,
                   ICiManager & ciManager,
                   const CLowerFunnyPath & lcaseFunnyRootPath,
                   PARTITIONID PartId,
                   BOOL fIncrem,
                   BOOL fDoDeletions,
                   BOOL & fAbort,
                   BOOL fProcessRoot )
        : CTraverse( cat, fAbort, fProcessRoot ),
          _ciManager(ciManager),
          _cDoc(0),
          _PartId(PartId),
          _fIncrem(fIncrem),
          _fDoDeletions(fDoDeletions)
{
    ciDebugOut(( DEB_ITRACE, "CUpdate::CUpdate root: '%ws', fAbort: %d\n",
                 lcaseFunnyRootPath.GetActualPath(), fAbort ));

    BOOL fRootDeleted = FALSE;

    //
    // If the rootPath is a network path, it is possible that the connection
    // is down. _cat.StartUpdate() is a fairly expensive operation because it
    // involves scanning the whole property store.
    // Before doing any further processing, just check if we can
    // open the path and get some information on it.
    //
    // Also, check that the root of the scope exists.  If not, delete the
    // files in the scope
    //

    if ( CImpersonateRemoteAccess::IsNetPath( lcaseFunnyRootPath.GetActualPath() ) )
    {
        CImpersonateRemoteAccess remote( _cat.GetImpersonationTokenCache() );

        TRY
        {
            CImpersonatedGetAttr    getAttr( lcaseFunnyRootPath );
            getAttr.DoWork( remote );
        }
        CATCH( CException, e )
        {
            ciDebugOut(( DEB_WARN,
                         "CUpdate::CUpdate(a) can't get attrinfo: %#x, for %ws\n",
                         e.GetErrorCode(),  lcaseFunnyRootPath.GetActualPath()));
            if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) != e.GetErrorCode() ||
                 HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) != e.GetErrorCode())
                RETHROW();

            fRootDeleted = TRUE;
        }
        END_CATCH;
    }
    else
    {
        DWORD dw = GetFileAttributes( lcaseFunnyRootPath.GetPath() );
        if ( 0xffffffff == dw )
        {
            DWORD dwErr = GetLastError();
            ciDebugOut(( DEB_WARN,
                         "CUpdate::CUpdate(b) can't get attrinfo: %d, for %ws\n",
                         dwErr, lcaseFunnyRootPath.GetPath()));
            if ( ERROR_FILE_NOT_FOUND == dwErr || ERROR_PATH_NOT_FOUND == dwErr )
                fRootDeleted = TRUE;
        }
    }

    _docList.SetPartId ( _PartId );
    _cat.StartUpdate( &_timeLastUpd, lcaseFunnyRootPath.GetActualPath(), fDoDeletions, eScansArray );

    // Make sure EndProcessing deletes all the files in the scope

    if ( fRootDeleted )
    {
        _status = STATUS_NO_MORE_FILES;
        return;
    }

    //
    // This is a bit of a kludge.  If we're doing an incremental update, we
    // will not *update* the root, but we need to mark it as seen so it
    // won't get deleted.
    //

    if ( _fDoDeletions )
    {
        WORKID wid = _cat.PathToWorkId( lcaseFunnyRootPath, eScansArray, fileIdInvalid );

        //
        // Workid is invalid for root, such as f:\
        //
        //NOTE: LokSetSeen is called by PathToWorkId
        //if ( wid != widInvalid )
        //    _cat.Touch( wid, eScansArray );
    }

#   if CIDBG == 1
        SYSTEMTIME time;
        RtlZeroMemory( &time, sizeof(time) );
        FileTimeToSystemTime( &_timeLastUpd, &time );

        TIME_ZONE_INFORMATION tzinfo;
        GetTimeZoneInformation( &tzinfo );

        SYSTEMTIME timeLocal;
        SystemTimeToTzSpecificLocalTime( &tzinfo, &time, &timeLocal );

        ciDebugOut(( DEB_ITRACE, "Begin update.  Last update %4d/%02d/%02d  %02d:%02d:%02d.%d\n",
                     timeLocal.wYear,
                     timeLocal.wMonth,
                     timeLocal.wDay,
                     timeLocal.wHour,
                     timeLocal.wMinute,
                     timeLocal.wSecond,
                     timeLocal.wMilliseconds ));
#   endif

    DoIt( lcaseFunnyRootPath );
} //CUpdate

//+-------------------------------------------------------------------------
//
//  Member:     CUpdate::EndProcessing, public
//
//  Synopsis:   Flush final updates to catalog.
//
//  History:    04-Jan-96  KyleP    Added header
//
//--------------------------------------------------------------------------
void CUpdate::EndProcessing()
{
    ciDebugOut(( DEB_ITRACE,
                 "CUpdate::EndProcessing, _fAbort: %d, _status %#x\n",
                 _fAbort,
                 _status ));
    if ( !_fAbort )
    {
        if ( _cDoc != 0 )
        {
            _docList.LokSetCount ( _cDoc );
            _cat.AddDocuments( _docList );
            _docList.LokClear();
            _docList.SetPartId ( _PartId );
            _cDoc = 0;
        }

        if ( STATUS_NO_MORE_FILES == _status )
        {
            _cat.EndUpdate( _fDoDeletions, eScansArray );
        }
        else if ( STATUS_SUCCESS != _status )
        {
            ciDebugOut(( DEB_ERROR, "Error %#x while traversing\n",
                         _status ));
            THROW( CException( _status ) );
        }
    }
} //EndProcessing

//+---------------------------------------------------------------------------
//
//  Member:     CUpdate::ProcessFile
//
//  Synopsis:   Processes the given file and adds it to the list of changed
//              documents if necessary.
//
//  Arguments:  [lcaseFunnyPath] -  Path of the file to be processed.
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    3-15-96   srikants   Split from CUpdate::Traverse
//
//----------------------------------------------------------------------------

BOOL CUpdate::ProcessFile( const CLowerFunnyPath & lcaseFunnyPath )
{
    if (lcaseFunnyPath.IsRemote()) 
    {
        // Need to impersonate only for the remote case
        CImpersonateSystem impersonate;

        return ProcessFileInternal(lcaseFunnyPath);
    }
    else
       return ProcessFileInternal(lcaseFunnyPath);
} //ProcessFile


//+---------------------------------------------------------------------------
//
//  Member:     CUpdate::ProcessFileInternal
//
//  Synopsis:   Processes the given file and adds it to the list of changed
//              documents if necessary.
//
//  Arguments:  [lcaseFunnyPath] -  Path of the file to be processed.
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    3-15-96   srikants   Split from CUpdate::Traverse
//
//----------------------------------------------------------------------------

BOOL CUpdate::ProcessFileInternal( const CLowerFunnyPath & lcaseFunnyPath )
{
    //
    // Add path without committing it
    //

    FILETIME    ftLastSeen = { 0,0 };
    BOOL fNew;
    WORKID wid = _cat.PathToWorkId( lcaseFunnyPath,
                                    TRUE,
                                    fNew,
                                    _fIncrem ? &ftLastSeen : 0,
                                    eScansArray,
                                    fileIdInvalid );

    if (wid == widInvalid)
        return TRUE;

    //
    // Decide if file has been updated.
    //

    LONG result = -1;

    if ( _fIncrem && !fNew && !CiCat::IsMaxTime( ftLastSeen ) )
    {
        //
        // Use the bigger of the last seen time and time of last update
        // to compare the current time of the file.
        //

        if ( ( ( 0 != ftLastSeen.dwLowDateTime ) ||
               ( 0 != ftLastSeen.dwHighDateTime ) ) &&
             ( CompareFileTime( &_timeLastUpd, &ftLastSeen ) > 0 ) )
        {
            ftLastSeen = _timeLastUpd;
        }

        //
        // On FAT volumes, ChangeTime is always 0.  On NTFS, ChangeTime
        // can be more recent than ModifyTime (alias LastWriteTime) if the
        // change was to the ACLs of a file, in which case we need to
        // honor the change.
        //

        FILETIME ftLastDelta;
        if ( 0 == _pCurEntry->ChangeTime() )
            ftLastDelta = _pCurEntry->ModifyTimeAsFILETIME();
        else
            ftLastDelta = _pCurEntry->ChangeTimeAsFILETIME();

        result = CompareFileTime( &ftLastSeen, &ftLastDelta );
    }

    if (result < 0) // The file is newer than the catalog
    {
        ciDebugOut(( DEB_CAT, "Update %ws\n", lcaseFunnyPath.GetActualPath() ));

        _cat.WriteFileAttributes( wid, _pCurEntry->Attributes() );
        Add ( wid );
    }

    return TRUE;
} //ProcessFileInternal

//+---------------------------------------------------------------------------
//
//  Member:     CUpdate::IsEligibleForTraversal
//
//  Synopsis:   Checks to see if the current directory is eligible for
//              traversal.
//
//  Arguments:  [lcaseFunnyDir] -
//
//  History:    3-15-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CUpdate::IsEligibleForTraversal( const CLowerFunnyPath & lcaseFunnyDir ) const
{
    return _cat.IsEligibleForFiltering( lcaseFunnyDir );
}

//+-------------------------------------------------------------------------
//
//  Member:     CUpdate::Add, public
//
//  Synopsis:   Add wid for update to doclist
//
//  Arguments:  [wid] -- Workid
//
//  History:    04-Jan-96  KyleP    Added header
//
//--------------------------------------------------------------------------

void CUpdate::Add( WORKID wid )
{
    _cat.Touch(wid, eScansArray);
    USN usn = 0;

    _docList.Set ( _cDoc, wid, usn, CI_VOLID_USN_NOT_ENABLED );
    _cDoc++;

    if (_cDoc == CI_MAX_DOCS_IN_WORDLIST)
    {
        _docList.LokSetCount ( _cDoc );

        _cat.AddDocuments( _docList );

        _docList.LokClear();
        _docList.SetPartId ( _PartId );
        _cDoc = 0;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CRenameDir::CRenameDir
//
//  Synopsis:   Constructor
//
//  Arguments:  [strings]               --  Strings class
//              [lowerFunnyDirOldName]  -- Old directory
//              [lowerFunnyDirNewName]  -- Renamed directory
//              [fAbort]                -- Set to TRUE for aborting
//              [volumeId]              -- Volume id
//
//  History:    20-Mar-96    SitaramR   Created
//
//----------------------------------------------------------------------------

CRenameDir::CRenameDir( CiCat & cicat,
                        const CLowerFunnyPath & lowerFunnyDirOldName,
                        const CLowerFunnyPath & lowerFunnyDirNewName,
                        BOOL & fAbort,
                        VOLUMEID volumeId )
      : CTraverse( cicat, fAbort, TRUE ),
        _cicat(cicat),
        _volumeId(volumeId),
        _lowerFunnyDirOldName( lowerFunnyDirOldName )
{
    _lowerFunnyDirOldName.AppendBackSlash();
    _uLenDirOldName = _lowerFunnyDirOldName.GetActualLength();
    _uLenDirNewName = lowerFunnyDirNewName.GetActualLength();


    //
    // Recursive traversal of renamed dir (include the renamed dir also)
    //
    DoIt( lowerFunnyDirNewName );
}



//+---------------------------------------------------------------------------
//
//  Member:     CRenameDir::ProcessFile
//
//  Synopsis:   Update indexes to reflect new file name
//
//  Arguments:  [lcaseFunnyFileNewName]  -  File name
//
//  History:    20-Mar-96    SitaramR   Created
//
//----------------------------------------------------------------------------

BOOL CRenameDir::ProcessFile( const CLowerFunnyPath & lcaseFunnyFileNewName )
{
    unsigned uLenFileNewName = lcaseFunnyFileNewName.GetActualLength();
    Win4Assert( uLenFileNewName >= _uLenDirNewName );


    _lowerFunnyDirOldName.Truncate( _uLenDirOldName );
    _lowerFunnyDirOldName.AppendBackSlash();

    unsigned posNewFileNameStart = _uLenDirNewName;

    if ( L'\\' == lcaseFunnyFileNewName.GetActualPath()[posNewFileNameStart] )
    {
        posNewFileNameStart++;
    }
    _lowerFunnyDirOldName.AppendPath( lcaseFunnyFileNewName.GetActualPath() + posNewFileNameStart,
                                      uLenFileNewName - posNewFileNameStart );

    _lowerFunnyDirOldName.RemoveBackSlash();

    CLowerFunnyPath lcaseFunnyFileNewName2( lcaseFunnyFileNewName );
    lcaseFunnyFileNewName2.RemoveBackSlash();

    _cicat.RenameFile( _lowerFunnyDirOldName,
                       lcaseFunnyFileNewName2,
                       _pCurEntry->Attributes(),
                       _volumeId,
                       fileIdInvalid );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\vmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       VMap.cxx
//
//  Contents:   Virtual <--> physical path map.
//
//  Classes:    CVMap
//
//  History:    05-Feb-96   KyleP       Created
//
//  Notes:      Automatic and manual roots have the following relationship.
//
//              1. If a root is purely manual (e.g. not in Gibraltar), then
//                 addition is only by the user, and deletion really deletes
//                 the root.  A placeholder is not maintained in the vroot
//                 list.
//
//              2. If a root is purely automatic, then it is always used,
//                 and is added and removed in complete sync with Gibraltar.
//
//              3. If a root was manual and was automatically added, the 'in-use'
//                 state from pure-manual mode is maintained.
//
//              4. If a root was automatic and was manually added, it is
//                 always set to 'in-use'.
//
//              5. If a root was both manual and automatic and automaticlly
//                 deleted the deletion occurs.  Period.
//
//              6. If a root was both manual and automatic and manually deleted,
//                 the root is kept as an out-of-use placeholder.
//
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rcstxact.hxx>
#include <rcstrmit.hxx>

#include <vmap.hxx>
#include <funypath.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CVMapDesc::Init, public
//
//  Synopsis:   Initialize virtual root descriptor
//
//  Arguments:  [pVRoot]     -- Virtual root
//              [ccVRoot]    -- Size in chars of [pwcVRoot]
//              [pPRoot]     -- Physical root
//              [ccPRoot]    -- Size in chars of [pwcPRoot]
//              [idParent]   -- Link to parent
//              [fAutomatic] -- TRUE for root tied to IIS
//              [eType]      -- VRoot type
//              [fIsIndexed] -- TRUE if the item should be indexed (used)
//              [fNonIndexedVDir] -- TRUE if a non-indexed virtual directory
//
//  History:    11-Feb-96 KyleP     Created
//              24 Nov 99 KLam      Don't pre-reference zero length strings.
//
//--------------------------------------------------------------------------

void CVMapDesc::Init( WCHAR const * pVRoot,
                      ULONG ccVRoot,
                      WCHAR const * pPRoot,
                      ULONG ccPRoot,
                      ULONG idParent,
                      BOOL fAutomatic,
                      CiVRootTypeEnum eType,
                      BOOL fIsIndexed,
                      BOOL fNonIndexedVDir )
{
    Win4Assert( ccVRoot < MAX_PATH );
    Win4Assert( ccPRoot < MAX_PATH );

    RtlCopyMemory(  _wcVScope, pVRoot, ccVRoot * sizeof(WCHAR ) );
    RtlCopyMemory(  _wcPScope, pPRoot, ccPRoot * sizeof(WCHAR ) );

    _ccVScope = ccVRoot;
    _ccPScope = ccPRoot;
    if ( (0 == _ccVScope) || (_wcVScope[_ccVScope - 1] != L'\\') )
        _wcVScope[_ccVScope++] = L'\\';

    if ( (0 == _ccPScope) || (_wcPScope[_ccPScope - 1] != L'\\') )
        _wcPScope[_ccPScope++] = L'\\';

    // null-terminate these for readability

    _wcVScope[ _ccVScope ] = 0;
    _wcPScope[ _ccPScope ] = 0;

    _idParent = idParent;

    if ( fAutomatic )
        _Type = PCatalog::AutomaticRoot;
    else
        _Type = PCatalog::ManualRoot;

    if ( fIsIndexed )
        _Type |= PCatalog::UsedRoot;

    if ( fNonIndexedVDir )
        _Type |= PCatalog::NonIndexedVDir;

    #if CIDBG == 1
        if ( fNonIndexedVDir )
            Win4Assert( !fIsIndexed );
    #endif // CIDBG == 1

    if ( NNTPVRoot == eType )
        _Type |= PCatalog::NNTPRoot;
    else if ( IMAPVRoot == eType )
        _Type |= PCatalog::IMAPRoot;
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CVMapDesc::IsVirtualMatch, public
//
//  Synopsis:   Virtual scope test
//
//  Arguments:  [pVPath]  -- Virtual path
//              [ccVPath] -- Size in chars of [pVPath]
//
//  Returns:    TRUE if [pVPath] is an exact match (sans slash)
//
//  History:    11-Feb-96 KyleP     Created
//              24 Nov 99 KLam      Don't pre-reference zero length strings.
//
//--------------------------------------------------------------------------

BOOL CVMapDesc::IsVirtualMatch( WCHAR const * pVPath, unsigned ccVPath ) const
{
    //
    // Adjust for possible lack of terminating backslash.
    //

    unsigned ccComp;

    if ( (0 == ccVPath) || (pVPath[ccVPath-1] != L'\\') )
        ccComp = _ccVScope - 1;
    else
        ccComp = _ccVScope;

    //
    // Compare strings.
    //

    if ( ccComp == ccVPath )
        return RtlEqualMemory( _wcVScope, pVPath, ccVPath * sizeof(WCHAR) );
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CVMapDesc::IsPhysicalMatch, public
//
//  Synopsis:   Physical scope test
//
//  Arguments:  [pPPath]  -- Virtual path
//              [ccPPath] -- Size in chars of [pPPath]
//
//  Returns:    TRUE if [pPPath] is an exact match (sans slash)
//
//  History:    11-Feb-96 KyleP     Created
//              24 Nov 99 KLam      Don't pre-reference zero length strings.
//
//--------------------------------------------------------------------------

BOOL CVMapDesc::IsPhysicalMatch( WCHAR const * pPPath, unsigned ccPPath ) const
{
    //
    // Adjust for possible lack of terminating backslash.
    //

    unsigned ccComp;

    if ( (0 == ccPPath) || (pPPath[ccPPath-1] != L'\\') )
        ccComp = _ccPScope - 1;
    else
        ccComp = _ccPScope;

    //
    // Compare strings.
    //

    if ( ccComp == ccPPath )
        return RtlEqualMemory( _wcPScope, pPPath, ccPPath * sizeof(WCHAR) );
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::CVMap, public
//
//  Synopsis:   Null ctor for 2-phase initialization
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

CVMap::CVMap()
{
    END_CONSTRUCTION( CVMap );
}

void CVMap::Empty()
{
    delete _xrsoMap.Acquire();
    _aMap.Clear();
}

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::Init, public
//
//  Synopsis:   2nd half of 2-phase initialization
//
//  Arguments:  [pobj] -- Recoverable storage for descriptors
//
//  Returns:    TRUE if map was shut down cleanly
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CVMap::Init( PRcovStorageObj * pobj )
{
    _xrsoMap.Set( pobj );

    //
    // Initialize array.
    //

    CRcovStorageHdr & hdr = _xrsoMap->GetHeader();

    struct CRcovUserHdr data;
    hdr.GetUserHdr( hdr.GetPrimary(), data );

    RtlCopyMemory( &_fDirty, &data._abHdr, sizeof(_fDirty) );

    //
    // Load records into memory.
    //

    CRcovStrmReadTrans xact( _xrsoMap.GetReference() );
    CRcovStrmReadIter  iter( xact, sizeof( CVMapDesc ) );

    unsigned i = 0;

    while ( !iter.AtEnd() )
    {
        iter.GetRec( &_aMap[i] );
        i++;
    }

    if (_aMap.Count() != hdr.GetCount( hdr.GetPrimary() ) )
    {
        ciDebugOut(( DEB_ERROR,
                     "_aMap.Count() == %d, hdr.GetCount(...) = %d\n",
                     _aMap.Count(),  hdr.GetCount( hdr.GetPrimary() ) ));
    }

    Win4Assert( _aMap.Count() == hdr.GetCount( hdr.GetPrimary() ) );

    RecomputeNonIndexedInfo();

    DumpVMap();

    return !_fDirty;
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::RecomputeNonIndexedInfo, private
//
//  Synopsis:   Rebuilds _aExcludeParent when vroot info changes
//
//  History:    1-Apr-97 dlee     Created
//
//--------------------------------------------------------------------------

void CVMap::RecomputeNonIndexedInfo()
{
    // blow away existing info and create it all again

    _aExcludeParent.Clear();

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
        _aExcludeParent[i] = INVALID_VMAP_INDEX;

    // look for non-indexed vdirs, and note the vroot that matches
    // both virtual and physical paths.

    for ( i = 0; i < _aMap.Count(); i++ )
    {
        if ( !_aMap[i].IsFree() &&
             _aMap[i].IsNonIndexedVDir() )
        {
            unsigned int ccBestMatch = 0;

            for ( unsigned r = 0; r < _aMap.Count(); r++ )
            {
                // if 'i' is in both virtual and physical paths of 'r',
                // make 'r' the exclude parent of 'i'.

                if ( i != r &&
                     !_aMap[r].IsFree() &&
                     !_aMap[r].IsNonIndexedVDir() )
                {
                    // -1 since we don't need to match on the '\' at the end

                    if ( _aMap[r].IsInPhysicalScope( _aMap[i].PhysicalPath(),
                                                     _aMap[i].PhysicalLength() - 1 ) )
                    {
                        if ( ( _aMap[r].VirtualLength() < _aMap[i].VirtualLength() ) &&
                             ( _aMap[r].IsVirtualMatch( _aMap[i].VirtualPath(),
                                                        _aMap[r].VirtualLength() ) ) )
                        {
                            ciDebugOut(( DEB_ITRACE, "nivd %ws found match %ws, old cc %d\n",
                                         _aMap[i].VirtualPath(),
                                         _aMap[r].VirtualPath(),
                                         ccBestMatch ));

                            if ( _aMap[r].VirtualLength() > ccBestMatch )
                            {
                                _aExcludeParent[i] = r;
                                ccBestMatch = _aMap[r].VirtualLength();
                            }
                        }
                    }
                }
            }
        }
    }
} //RecomputeNonIndexedInfo

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::DumpVMap, private
//
//  Synopsis:   Dumps the current state of the vmap table
//
//  History:    1-Apr-97 dlee     Created
//
//--------------------------------------------------------------------------

void CVMap::DumpVMap()
{
#if CIDBG == 1
    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        ciDebugOut(( DEB_ITRACE,
                     "vmap 0x%x, isfree %d parent 0x%x\n",
                     i, _aMap[i].IsFree(), _aMap[i].Parent() ));

        if ( !_aMap[i].IsFree() )
            ciDebugOut(( DEB_ITRACE,
                         "    expar: 0x%x, nonivdir %d, inuse %d, manual %d, auto %d, nntp %d, imap %d, vpath '%ws', ppath '%ws'\n",
                         _aExcludeParent[i],
                         _aMap[i].IsNonIndexedVDir(),
                         _aMap[i].IsInUse(),
                         _aMap[i].IsManual(),
                         _aMap[i].IsAutomatic(),
                         _aMap[i].IsNNTP(),
                         _aMap[i].IsIMAP(),
                         _aMap[i].VirtualPath(),
                         _aMap[i].PhysicalPath() ));
    }
#endif // CIDBG
} //DumpVMap

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::Add, public
//
//  Synopsis:   Add new virtual/physical mapping
//
//  Arguments:  [vroot]      -- New virtual root
//              [root]       -- Place in physical hierarchy
//              [fAutomatic] -- TRUE for root tied to Gibraltar
//              [idNew]      -- Id of new root returned here
//              [eType]      -- vroot type
//              [fVRoot]     -- TRUE if a vroot, not a vdir
//              [fIsIndexed] -- TRUE if it should be indexed, FALSE otherwise
//
//  Returns:    TRUE if scope was added or changed
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CVMap::Add( WCHAR const * vroot,
                 WCHAR const * root,
                 BOOL fAutomatic,
                 ULONG & idNew,
                 CiVRootTypeEnum eType,
                 BOOL fVRoot,
                 BOOL fIsIndexed )
{
    Win4Assert( eType == W3VRoot ||
                eType == NNTPVRoot ||
                eType == IMAPVRoot );

    Win4Assert( !fIsIndexed || fVRoot );

    CLock   lock(_mutex);

    unsigned ccVRoot = wcslen(vroot);
    unsigned ccPRoot = wcslen(root);

    Win4Assert( ccVRoot < MAX_PATH );
    Win4Assert( ccPRoot < MAX_PATH );

    ULONG idParent = INVALID_VMAP_INDEX;
    ULONG ccParent = 0;

    idNew = INVALID_VMAP_INDEX;
    BOOL fWasInUse = FALSE;
    BOOL fWasAutomatic = FALSE;
    BOOL fWasManual = FALSE;
    BOOL fPRootChanged = TRUE;
    BOOL fWasNonIndexedVDir = FALSE;
    ULONG idOldParent = INVALID_VMAP_INDEX;

    //
    // Find virtual parent.
    //

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        //
        // Is the new entry already in the list?
        //

        if ( !_aMap[i].IsFree() )
        {
            //
            // Should we even consider this entry?
            //

            if ( (W3VRoot == eType) && !_aMap[i].IsW3() )
                continue;

            if ( (NNTPVRoot == eType) && !_aMap[i].IsNNTP() )
                continue;

            if ( (IMAPVRoot == eType) && !_aMap[i].IsIMAP() )
                continue;

            if ( _aMap[i].IsVirtualMatch( vroot, ccVRoot ) )
            {
                //
                // Collect stats:
                //

                fWasInUse = _aMap[i].IsInUse();
                fWasAutomatic = _aMap[i].IsAutomatic();
                fWasManual = _aMap[i].IsManual();
                fWasNonIndexedVDir = _aMap[i].IsNonIndexedVDir();
                fPRootChanged = !_aMap[i].IsPhysicalMatch( root, ccPRoot );
                idOldParent = _aMap[i].Parent();

                ciDebugOut(( DEB_ITRACE,
                             "vroot '%ws', fWasInUse %d, fIsIndexed %d, fWasNonIndexedVDir %d\n",
                             vroot, fWasInUse, fIsIndexed, fWasNonIndexedVDir ));

                //
                // If there is no change, we can return w/o doing anything.
                //

                if ( ( ( fWasInUse && fIsIndexed ) || ( !fWasInUse && !fIsIndexed ) ) &&
                     ( (fWasNonIndexedVDir && !fVRoot) || (!fWasNonIndexedVDir && fVRoot) ) &&
                     ( (fAutomatic && fWasAutomatic) || (!fAutomatic && fWasManual) ) &&
                     !fPRootChanged )
                {
                    ciDebugOut(( DEB_ITRACE, "no change for '%ws'\n", vroot ));
                    return FALSE;
                }
                else
                {
                    ciDebugOut(( DEB_ITRACE, "modified vroot entry for '%ws'\n", vroot ));
                    idNew = i;
                    break;
                }
            }

            //
            // Is this a longer physical path match?
            //

            unsigned ccMatch = _aMap[i].PhysicalMatchLen( root );

            if ( ccMatch > ccParent && ccMatch <= ccPRoot )
            {
                ccParent = ccMatch;
                idParent = i;
            }
        }
        else
        {
            idNew = i;
            continue;
        }
    }

    //
    // Add new root.
    //

    CRcovStorageHdr & hdr = _xrsoMap->GetHeader();
    CRcovStrmWriteTrans xact( _xrsoMap.GetReference() );
    CRcovStrmWriteIter  iter( xact, sizeof(CVMapDesc) );

    Win4Assert( _aMap.Count() == hdr.GetCount( hdr.GetPrimary() ) );

    //
    // This may be a new record.
    //

    BOOL  fAppend;

    if ( idNew == INVALID_VMAP_INDEX )
    {
        ciDebugOut(( DEB_ITRACE, "new vroot entry for '%ws'\n", vroot ));
        idNew = _aMap.Count();
        fAppend = TRUE;
    }
    else
        fAppend = FALSE;

    _aMap[idNew].Init( vroot,
                       ccVRoot,
                       root,
                       ccPRoot,
                       idParent,
                       fAutomatic,
                       eType,
                       fIsIndexed,
                       !fVRoot );

    //
    // This may have been an upgrade (not a new root), so add back previous state.
    //

    if ( fWasAutomatic )
        _aMap[idNew].SetAutomatic();

    if ( fWasManual )
        _aMap[idNew].SetManual();

    //
    // Write out changes.
    //
    if ( fAppend )
        iter.AppendRec( &_aMap[idNew] );
    else
        iter.SetRec( &_aMap[idNew], idNew );
    //
    // Look for roots that used to point at parent.  They may need to be changed.
    // Only bother if root was not previously in use.
    //

    Win4Assert( !_fDirty );
    _fDirty = (fWasInUse != _aMap[idNew].IsInUse() || fPRootChanged);

    //
    // Put this root in the hierarchy.
    //

    if ( _fDirty && fVRoot )
    {
        for ( i = 0; i < _aMap.Count(); i++ )
        {
            if ( _aMap[i].IsFree() || !_aMap[i].IsInUse() )
                continue;

            //
            // If physical root changed, then we need to adjust a lot of parent pointers.
            // Stage one is equivalent to removing the old root.
            //

            if ( fPRootChanged && _aMap[i].Parent() == idNew )
            {
                Win4Assert( i != idNew );
                ciDebugOut(( DEB_ITRACE, "VRoot %d has new parent %d\n", i, idNew ));

                _aMap[i].SetParent( idOldParent );

                iter.SetRec( &_aMap[i], i );
            }

            if ( _aMap[i].Parent() != idParent )
                continue;

            if ( i == idNew )
                continue;

            //
            // Is this a longer physical path match?
            //

            unsigned ccMatch = _aMap[i].PhysicalMatchLen( root );

            if ( ccMatch >= ccPRoot )
            {
                ciDebugOut(( DEB_ITRACE, "VRoot %d has new parent %d\n", i, idNew ));

                _aMap[i].SetParent( idNew );

                iter.SetRec( &_aMap[i], i );
            }
        }
    }

    //
    // Finish transaction
    //

    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &_fDirty, sizeof(_fDirty) );

    hdr.SetUserHdr( hdr.GetBackup(), data );
    hdr.SetCount( hdr.GetBackup(), _aMap.Count() );

    xact.Commit();

    RecomputeNonIndexedInfo();
    DumpVMap();

    return _fDirty;
} //Add

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::Remove, public
//
//  Synopsis:   Remove virtual/physical mapping
//
//  Arguments:  [vroot]            -- New virtual root
//              [fOnlyIfAutomatic] -- If TRUE, then a manual root will not
//                                    be removed
//              [idOld]            -- Id which was removed
//              [idNew]            -- Id which replaces [idOld] (farther up physical path)
//              [eType]            -- VRoot type
//              [fVRoot]           -- TRUE if a vroot, FALSE if a vdir
//
//  Returns:    TRUE if scope was removed
//
//  History:    11-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CVMap::Remove( WCHAR const * vroot,
                    BOOL fOnlyIfAutomatic,
                    ULONG & idOld,
                    ULONG & idNew,
                    CiVRootTypeEnum eType,
                    BOOL fVRoot )
{
    Win4Assert( eType == W3VRoot ||
                eType == NNTPVRoot ||
                eType == IMAPVRoot );

    CLock   lock(_mutex);

    unsigned ccVRoot = wcslen(vroot);

    //
    // Find id of root.
    //

    idOld = INVALID_VMAP_INDEX;

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        BOOL fSameType = ( ( ( W3VRoot == eType ) && _aMap[i].IsW3() ) ||
                           ( ( NNTPVRoot == eType ) && _aMap[i].IsNNTP() ) ||
                           ( ( IMAPVRoot == eType ) && _aMap[i].IsIMAP() ) );

        if ( !_aMap[i].IsFree() &&
             fSameType &&
             _aMap[i].IsVirtualMatch( vroot, ccVRoot ) )
        {
            idOld = i;
            break;
        }
    }

    if ( idOld == INVALID_VMAP_INDEX )
        return FALSE;

    BOOL fWasInUse = _aMap[idOld].IsInUse();

    //
    // Turn off either automatic bit or manual bit.
    //

    if ( fOnlyIfAutomatic )
    {
        //
        // When a root is deleted by Gibraltar, it is *really* deleted.
        //

        _aMap[idOld].ClearAutomatic();
        _aMap[idOld].ClearManual();
        _aMap[idOld].ClearInUse();
    }
    else
    {
        //
        // If this is an automatic root, then put the
        // root under manual control (to keep it deleted),
        // otherwise clear the manual flag to free up the entry.
        //

        if ( _aMap[idOld].IsAutomatic() )
            _aMap[idOld].SetManual();
        else
            _aMap[idOld].ClearManual();

        _aMap[idOld].ClearInUse();
    }

    idNew = _aMap[i].Parent();

    //
    // Make persistent changes
    //

    CRcovStorageHdr & hdr = _xrsoMap->GetHeader();
    CRcovStrmWriteTrans xact( _xrsoMap.GetReference() );
    CRcovStrmWriteIter  iter( xact, sizeof(CVMapDesc) );

    if ( !_aMap[idOld].IsAutomatic() && !_aMap[idOld].IsManual() )
        _aMap[idOld].Delete();

    iter.SetRec( &_aMap[idOld], idOld );

    //
    // Look for roots that used to point here.  They will need to be changed.
    // Change *only* if we really decided we're not tracking this root.
    // Only bother if we really stopped using the root.
    //

#   if CIDBG == 1
    if( _aMap[idOld].IsFree() )
        Win4Assert( !_aMap[idOld].IsInUse() );
#   endif

    if ( !_aMap[idOld].IsInUse() && fWasInUse )
    {
        for ( i = 0; i < _aMap.Count(); i++ )
        {
            if ( _aMap[i].IsFree() )
                continue;

            if ( _aMap[i].Parent() == idOld )
            {
                ciDebugOut(( DEB_ITRACE, "VRoot %d has new parent %d\n", i, idNew ));

                _aMap[i].SetParent( idNew );

                iter.SetRec( &_aMap[i], i );
            }
        }
    }

    //
    // Finish transaction
    //

    Win4Assert( !_fDirty );
    ciDebugOut(( DEB_ITRACE, "fVRoot, isinuse %d, wasinuse %d\n",
                 _aMap[idOld].IsInUse(), fWasInUse ));
    _fDirty = (!fVRoot || !_aMap[idOld].IsInUse() && fWasInUse);
    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &_fDirty, sizeof(_fDirty) );

    hdr.SetUserHdr( hdr.GetBackup(), data );
    hdr.SetCount( hdr.GetBackup(), _aMap.Count() );

    xact.Commit();

    RecomputeNonIndexedInfo();
    DumpVMap();

    ciDebugOut(( DEB_ITRACE, "vmap::remove fDirty: %d\n", _fDirty ));

    return _fDirty;
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::MarkClean, public
//
//  Synopsis:   Used to indicate all modifications based on path
//              addition/removal are complete.
//
//  History:    14-Feb-96 KyleP     Added header
//
//--------------------------------------------------------------------------

void CVMap::MarkClean()
{
    CLock   lock(_mutex);

    CRcovStorageHdr & hdr = _xrsoMap->GetHeader();
    CRcovStrmAppendTrans xact( _xrsoMap.GetReference() );

    _fDirty = FALSE;
    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &_fDirty, sizeof(_fDirty) );

    hdr.SetUserHdr( hdr.GetBackup(), data );
    hdr.SetCount( hdr.GetBackup(), _aMap.Count() );

    xact.Commit();
} //MarkClean

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::PhysicalPathToId, private
//
//  Synopsis:   Given a physical path, find the virtual root that should
//              be associated with it.
//
//  Arguments:  [path]             -- Physical path
//              [fNonIndexedVDirs] -- If TRUE, returns 0xffffffff or a
//                                    non-indexed vdir.  If FALSE, returns
//                                    an indexed vroot or 0xffffffff.
//
//  Returns:    Id of virtual root
//
//  History:    11-Feb-96 KyleP     Added header
//
//--------------------------------------------------------------------------

ULONG CVMap::PhysicalPathToId(
    WCHAR const * path,
    BOOL          fNonIndexedVDirs )
{
    //
    // Find virtual parent.
    //

    unsigned ccPath = wcslen(path);

    ULONG idParent = INVALID_VMAP_INDEX;
    ULONG ccParent = 0;

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        if ( _aMap[i].IsFree() ||
             ( !fNonIndexedVDirs && !_aMap[i].IsInUse() ) ||
             ( fNonIndexedVDirs && !_aMap[i].IsNonIndexedVDir() ) )
            continue;

        if ( !fNonIndexedVDirs )
        {
            BOOL fIgnore = FALSE;

            for ( unsigned x = 0; x < _aExcludeParent.Count(); x++ )
            {
                // If 'i' is a parent that should be excluded because the
                // file is in a non-indexed vdir of vroot 'i', ignore it.

                if ( i == _aExcludeParent[x] )
                {
                    Win4Assert( _aMap[x].IsNonIndexedVDir() );
                    if ( _aMap[x].IsInPhysicalScope( path, ccPath ) )
                    {
                        fIgnore = TRUE;
                        break;
                    }
                }
            }

            if ( fIgnore )
                continue;
        }

        //
        // Is this a longer physical path match?
        //

        unsigned ccMatch = _aMap[i].PhysicalMatchLen( path );

        if ( ccMatch > ccParent && ccMatch < ccPath )
        {
            ccParent = ccMatch;
            idParent = i;
        }
        else if ( ccMatch > 0 && ccMatch == ccParent )
        {
            //
            // Consider the case of multiple virtual roots pointing to the
            // same place in the physical heirarchy:
            //
            //                v0
            //                  \
            //                   \
            //       v1 -> v2 -> v3
            //
            // Files under v1/v2/v3 must be tagged with id v1, or we will
            // not recognize v1 as a valid virtual root for the file.  So
            // if we happened to find v2 or v3 first, we need to swap
            // roots if we can get to the old best match from the new best
            // match by traversing parent links.
            //

            for ( unsigned id = _aMap[i].Parent();
                  id != INVALID_VMAP_INDEX;
                  id = _aMap[id].Parent() )
            {
                //
                // Have we traversed up the tree?
                //

                if ( _aMap[id].PhysicalLength() < ccParent )
                    break;

                //
                // Did we find the previous parent?
                //

                if ( id == idParent )
                    break;
            }

            if ( id == idParent )
                idParent = i;
        }
    }

    return idParent;
} //PhysicalPathToId

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::PhysicalPathToId, public
//
//  Synopsis:   Given a physical path, find the virtual root that should
//              be associated with it.
//
//  Arguments:  [path] -- Physical path
//
//  Returns:    Id of virtual root
//
//  History:    11-Feb-96 KyleP     Added header
//
//--------------------------------------------------------------------------

ULONG CVMap::PhysicalPathToId( WCHAR const * path )
{
    CLock   lock(_mutex);

    // first try an indexed vroot, but settle for a non-indexed-vdir

    ULONG id = PhysicalPathToId( path, FALSE );

    if ( INVALID_VMAP_INDEX == id )
        id = PhysicalPathToId( path, TRUE );

    return id;
} //PhysicalPathToId

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::VirtualToPhysicalRoot, public
//
//  Synopsis:   Given a virtual path, returns corresponding physical root.
//              Unlike the iterative version of this method, this version
//              requires an exact match on virtual root.
//
//  Arguments:  [pwcVRoot] -- Virtual root
//              [ccVRoot]  -- Size in chars of [pwcVRoot]
//              [lcaseFunnyPRoot] -- Physical root
//              [ccPRoot]         -- returns actual count of chars in  [lcaseFunnyPRoot]
//
//  Returns:    TRUE if match was found.
//
//  History:    11-Feb-96  KyleP    Created
//              15 Mar 96  AlanW    Fixed bugs in enumeration which missed
//                                  some roots and erroneously added others.
//
//--------------------------------------------------------------------------

BOOL CVMap::VirtualToPhysicalRoot( WCHAR const * pwcVRoot,
                                   unsigned ccVRoot,
                                   CLowerFunnyPath & lcaseFunnyPRoot,
                                   unsigned & ccPRoot )
{
    //
    // Find id of root.
    //

    unsigned iBmk = INVALID_VMAP_INDEX;

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        if ( !_aMap[i].IsFree() &&
             _aMap[i].IsVirtualMatch( pwcVRoot, ccVRoot ) )
        {
            iBmk = i;
            break;
        }
    }

    if ( iBmk == INVALID_VMAP_INDEX )
        return FALSE;

    //
    // Copy out physical root.
    //

    ccPRoot = _aMap[iBmk].PhysicalLength() - 1;

    //
    // Special case root.
    //

    if ( _aMap[iBmk].PhysicalPath()[1] == L':' )
    {
        if ( ccPRoot == 2 )
            ccPRoot++;
    }
    else
    {
        unsigned cSlash = 0;

        for ( unsigned i = 0; i < ccPRoot && cSlash < 4; i++ )
        {
            if ( _aMap[iBmk].PhysicalPath()[i] == L'\\' )
                cSlash++;
        }

        if ( cSlash < 4 )
        {
            Win4Assert( cSlash == 3 );
            ccPRoot++;
        }
    }

    lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), ccPRoot );

    return TRUE;
} //VirtualToPhysicalRoot

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::VirtualToPhysicalRoot, public
//
//  Synopsis:   Given a virtual path, returns a virtual root under that
//              virtual path, and the corresponding physical root.  Will
//              not return overlapping virtual roots.
//
//              There may be multiple virtual roots that match the virtual
//              path passed in, so this should be called in a loop until
//              FALSE is returned.  The [iBmk] should be zero for the first
//              call in the iteration.
//
//  Arguments:  [pwcVPath]  -- Virtual path
//              [ccVPath]   -- Size in chars of [pwcVPath]
//              [xwcsVRoot] -- Virtual root
//              [ccVRoot]   -- returns count of chars in [xwcsVRoot]
//              [lcaseFunnyPRoot] -- Physical root
//              [ccPRoot]   -- Size in actual chars of [lcaseFunnyPRoot]
//              [iBmk]      -- Bookmark for iteration.
//
//  Returns:    TRUE if match was found.
//
//  History:    11-Feb-96  KyleP    Created
//              15 Mar 96  AlanW    Fixed bugs in enumeration which missed
//                                  some roots and erroneously added others.
//              24 Nov 99  KLam     Don't pre-reference zero length strings.
//
//--------------------------------------------------------------------------

BOOL CVMap::VirtualToPhysicalRoot( WCHAR const * pwcVPath,
                                   unsigned ccVPath,
                                   XGrowable<WCHAR> & xwcsVRoot,
                                   unsigned & ccVRoot,
                                   CLowerFunnyPath & lcaseFunnyPRoot,
                                   unsigned & ccPRoot,
                                   unsigned & iBmk )
{

    CLock   lock(_mutex);


    //
    // Path must be terminated with a backslash, or the path can be of
    // 0 characters.
    //

    XGrowable<WCHAR> xwcTemp;

    if ( (0 != ccVPath) && (pwcVPath[ccVPath-1] != L'\\') )
    {
        xwcTemp.SetSize( ccVPath + 1 );
        RtlCopyMemory( xwcTemp.Get(), pwcVPath, ccVPath * sizeof(WCHAR) );
        xwcTemp[ccVPath] = L'\\';

        pwcVPath = xwcTemp.Get();
        ccVPath++;
    }

    CScopeMatch Match( pwcVPath, ccVPath );

    for ( ; iBmk < _aMap.Count(); iBmk++ )
    {
        if ( _aMap[iBmk].IsFree() || !_aMap[iBmk].IsInUse() )
            continue;

        //
        // Possible match?
        //

        if ( Match.IsInScope( _aMap[iBmk].VirtualPath(),
                              _aMap[iBmk].VirtualLength() ) )
        {
            //
            // The virtual root is a match.  If there is a parent of
            // this virtual root in the physical name space, ignore this
            // one in favor of the other one, farther up the tree (as long
            // as the parent root is also a scope match).
            //

            for ( unsigned idParent = _aMap[ iBmk ].Parent();
                  idParent != INVALID_VMAP_INDEX;
                  idParent = _aMap[idParent].Parent() )
            {
                if ( Match.IsInScope( _aMap[idParent].VirtualPath(),
                                      _aMap[idParent].VirtualLength() ) )
                    break;
            }

            //
            // Did we get all the way to the top of chain without
            // finding another match?
            //

            if ( idParent == INVALID_VMAP_INDEX )
                break;
        }

        if ( Match.IsPrefix( _aMap[iBmk].VirtualPath(),
                             _aMap[iBmk].VirtualLength() ) )
        {
            //
            // The virtual root is a prefix of the path.  Return it only
            // if there is not some other vroot that is a better match.
            //

            BOOL fBetterMatch = FALSE;
            for ( unsigned iRoot = 0;
                  !fBetterMatch && iRoot < _aMap.Count();
                  iRoot++ )
            {
                if ( iRoot == iBmk ||
                     _aMap[iRoot].IsFree() )
                    continue;

                if ( _aMap[iBmk].VirtualLength() < _aMap[iRoot].VirtualLength() &&
                    Match.IsPrefix( _aMap[iRoot].VirtualPath(),
                                    _aMap[iRoot].VirtualLength() ) )
                {
                    fBetterMatch = TRUE;
                }
            }

            //
            //  Was there no better match?  If so, return this root.
            //
            if ( ! fBetterMatch )
                break;
        }
    }

    if ( iBmk < _aMap.Count() )
    {
        if ( ccVPath > _aMap[iBmk].VirtualLength() )
        {
            ccVRoot = ccVPath;
            xwcsVRoot.SetBuf( pwcVPath, ccVPath );

            unsigned ccExtra = ccVPath - _aMap[iBmk].VirtualLength();
            ccPRoot = _aMap[iBmk].PhysicalLength() + ccExtra;

            lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), _aMap[iBmk].PhysicalLength() );
            lcaseFunnyPRoot.AppendPath( pwcVPath + _aMap[iBmk].VirtualLength(), ccExtra );
        }
        else
        {
            ccVRoot = _aMap[iBmk].VirtualLength();
            xwcsVRoot.SetBuf( _aMap[iBmk].VirtualPath(), ccVRoot * sizeof(WCHAR) );

            lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), ccPRoot = _aMap[iBmk].PhysicalLength() );
        }
        iBmk++;
        return TRUE;
    }
    else
        return FALSE;
} //VirtualToPhysicalRoot

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::VirtualToAllPhysicalRoots, public
//
//  Synopsis:   Like VirtualToPhysicalRoot, except returns all matches
//              (rather than just the highest parent which matches)
//              and also returns non-indexed matches.  Returns type
//              in ulType so caller can decide what to do with
//              non-indexed matches.
//
//  Arguments:  [pwcVPath]  -- Virtual path
//              [ccVPath]   -- Size in chars of [pwcVPath]
//              [xwcsVRoot] -- Virtual root
//              [ccVRoot]   -- returns count of chars in [pwcVRoot]
//              [lcaseFunnyPRoot] -- Physical root
//              [ccPRoot]   -- returns count of actual chars in [lcaseFunnyPRoot]
//              [ulType]    -- Match type
//              [iBmk]      -- Bookmark for iteration.
//
//  Returns:    TRUE if match was found.
//
//  History:    01-Sep-97     Emilyb   Created
//
//--------------------------------------------------------------------------

BOOL CVMap::VirtualToAllPhysicalRoots( WCHAR const * pwcVPath,
                                       unsigned ccVPath,
                                       XGrowable<WCHAR> & xwcsVRoot,
                                       unsigned & ccVRoot,
                                       CLowerFunnyPath & lcaseFunnyPRoot,
                                       unsigned & ccPRoot,
                                       ULONG & ulType,
                                       unsigned & iBmk )
{

    CLock   lock(_mutex);


    //
    // Path must be terminated with a backslash, or the path can be of
    // 0 characters.
    //

    XGrowable<WCHAR> xwcTemp;

    if ( ( 0 != ccVPath ) && ( pwcVPath[ccVPath-1] != L'\\' ) )
    {
        xwcTemp.SetSize( ccVPath + 1 );
        RtlCopyMemory( xwcTemp.Get(), pwcVPath, ccVPath * sizeof(WCHAR) );
        xwcTemp[ccVPath] = L'\\';

        pwcVPath = xwcTemp.Get();
        ccVPath++;
    }

    CScopeMatch Match( pwcVPath, ccVPath );

    for ( ; iBmk < _aMap.Count(); iBmk++ )
    {
        if ( _aMap[iBmk].IsFree() )
            continue;

        //
        // Possible match?
        //

        if ( Match.IsInScope( _aMap[iBmk].VirtualPath(),
                              _aMap[iBmk].VirtualLength() ) )
        {
            break;
        }

        if ( Match.IsPrefix( _aMap[iBmk].VirtualPath(),
                             _aMap[iBmk].VirtualLength() ) )
        {
            //
            // The virtual root is a prefix of the path.  Return it only
            // if there is not some other vroot that is a better match.
            //

            BOOL fBetterMatch = FALSE;
            for ( unsigned iRoot = 0;
                  !fBetterMatch && iRoot < _aMap.Count();
                  iRoot++ )
            {
                if ( iRoot == iBmk ||
                     _aMap[iRoot].IsFree() )
                    continue;

                if ( _aMap[iBmk].VirtualLength() < _aMap[iRoot].VirtualLength() &&
                    Match.IsPrefix( _aMap[iRoot].VirtualPath(),
                                    _aMap[iRoot].VirtualLength() ) )
                {
                    fBetterMatch = TRUE;
                }
            }

            //
            //  Was there no better match?  If so, return this root.
            //
            if ( ! fBetterMatch )
                break;
        }
    }


    if ( iBmk < _aMap.Count() )
    {
        if ( ccVPath > _aMap[iBmk].VirtualLength() )
        {
            ccVRoot = ccVPath;
            xwcsVRoot.SetBuf( pwcVPath, ccVPath );

            unsigned ccExtra = ccVPath - _aMap[iBmk].VirtualLength();
            ccPRoot = _aMap[iBmk].PhysicalLength() + ccExtra;

            lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), _aMap[iBmk].PhysicalLength() );
            lcaseFunnyPRoot.AppendPath( pwcVPath + _aMap[iBmk].VirtualLength(), ccExtra );
        }
        else
        {
            ccVRoot = _aMap[iBmk].VirtualLength();
            xwcsVRoot.SetBuf( _aMap[iBmk].VirtualPath(), ccVRoot );

            lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), ccPRoot = _aMap[iBmk].PhysicalLength() );
        }
        ulType = _aMap[iBmk].RootType();

        iBmk++;
        return TRUE;
    }
    else
        return FALSE;
} //VirtualToAllPhysicalRoots


//+-------------------------------------------------------------------------
//
//  Member:     CVMap::EnumerateRoot, public
//
//  Synopsis:   Enumerate all virtual paths
//
//  Arguments:  [xwcVRoot] -- Virtual root
//              [ccVRoot]  -- returns count of chars in [xwcVRoot]
//              [lcaseFunnyPRoot] -- Physical root as funny path
//              [ccPRoot]  -- returns count of actual chars in [lcaseFunnyPRoot]
//              [iBmk]     -- Bookmark for iteration.
//
//  Returns:    Type of root (Manual or Automatic)
//
//  History:    15-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG CVMap::EnumerateRoot( XGrowable<WCHAR> & xwcVRoot,
                            unsigned & ccVRoot,
                            CLowerFunnyPath & lcaseFunnyPRoot,
                            unsigned & ccPRoot,
                            unsigned & iBmk )
{

    CLock   lock(_mutex);

    for ( ; iBmk < _aMap.Count(); iBmk++ )
    {
        if ( !_aMap[iBmk].IsFree() )
            break;
    }

    if ( iBmk < _aMap.Count() )
    {
        ccVRoot = _aMap[iBmk].VirtualLength() - 1;

        //
        // Special case root.
        //

        if ( 0 == ccVRoot )
            ccVRoot++;

        xwcVRoot.SetSize( ccVRoot + 1 );
        xwcVRoot.SetBuf( _aMap[iBmk].VirtualPath(), ccVRoot );
        xwcVRoot[ccVRoot] = 0;

        ccPRoot = _aMap[iBmk].PhysicalLength() - 1;

        //
        // Special case root.
        //

        if ( _aMap[iBmk].PhysicalPath()[1] == L':' )
        {
            if ( ccPRoot == 2 )
                ccPRoot++;
        }
        else
        {
            unsigned cSlash = 0;

            for ( unsigned i = 0; i < ccPRoot && cSlash < 4; i++ )
            {
                if ( _aMap[iBmk].PhysicalPath()[i] == L'\\' )
                    cSlash++;
            }

            if ( cSlash < 4 )
            {
                Win4Assert( cSlash == 3 );
                ccPRoot++;
            }
        }


        lcaseFunnyPRoot.SetPath( _aMap[iBmk].PhysicalPath(), ccPRoot );

        ULONG eType = _aMap[iBmk].RootType();

        iBmk++;

        return eType;
    }
    else
        return (ULONG) PCatalog::EndRoot;
} //EnumerateRoot

//+-------------------------------------------------------------------------
//
//  Member:     CVMap::DoesPhysicalRootExist, public
//
//  Synopsis:   Determines whether a physical root is in the table
//
//  Arguments:  [pwcPRoot] -- Physical root to find
//
//  Returns:    TRUE if the physical root exists in the table
//
//  History:    16-Oct-96 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CVMap::DoesPhysicalRootExist(
    WCHAR const * pwcPRoot )
{
    unsigned cwcPRoot = wcslen( pwcPRoot );

    for ( unsigned i = 0; i < _aMap.Count(); i++ )
    {
        if ( !_aMap[i].IsFree() &&
             !_aMap[i].IsNonIndexedVDir() &&
             _aMap[i].IsPhysicalMatch( pwcPRoot, cwcPRoot ) )
            return TRUE;
    }

    return FALSE;
} //DoesPhysicalRootExist
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cicat\volinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       VolInfo.cxx
//
//  Contents:   Grab bag for volume-wide information
//
//  History:    28-Jul-98   KyleP       Pulled from cicat.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "volinfo.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CVolumeInfo::Set, public
//
//  Synopsis:   Associate a volume with the CVolumeInfo
//
//  Arguments:  [wc]           -- Drive letter of volume
//              [CreationTime] -- Creation time of volume
//              [SerialNumber] -- Volume serial number
//              [fUsnVolume]   -- TRUE if volume supports USNs
//              [JournalId]    -- USN Journal ID (if appropriate)
//
//  History:    28-Jul-1998    KyleP     Pulled from cicat.hxx
//
//----------------------------------------------------------------------------

void CVolumeInfo::Set( WCHAR             wc,
                       ULONGLONG const & CreationTime,
                       ULONG             SerialNumber,
                       BOOL              fUsnVolume,
                       ULONGLONG const & JournalId )
{
    _wch = wc;
    _fUsnVolume = fUsnVolume;
    _JournalId = JournalId;
    _CreationTime = CreationTime;
    _SerialNumber = SerialNumber;

    WCHAR awcTmp[10];
    wcscpy( awcTmp, L"\\\\.\\k:" );
    awcTmp[ 4 ] = wc;

    HANDLE h = CreateFile( awcTmp,
                           FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           0,
                           OPEN_EXISTING,
                           0, 0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        ciDebugOut(( DEB_WARN, "Error %u opening %wc:\n", GetLastError(), wc ));

        _JournalId = 0;
        _CreationTime = 0;
        _SerialNumber = 0;
    }

    _xVolume.Set( h );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cidso\datasrc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       datasrc.cxx
//
//  Contents:   Class factory description
//
//  History:    3-30-97     MohamedN   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <datasrc.hxx>
#include <session.hxx>
#include <cidbprop.hxx>     // CDbProperties
#include <dbprpini.hxx>     // CGetDbInitProps

// Datasource object interfaces that support ISupportErrorInfo
static const GUID* apDataSrcErrInt[] =
{
    &IID_IDBCreateSession,
    &IID_IDBInitialize,
    &IID_IDBProperties,
    &IID_IPersist,
    &IID_IDBInfo,
};
static const ULONG cDataSrcErrInt  = NUMELEM( apDataSrcErrInt );

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::CDataSrc
//
//  Synopsis:   ctor
//
//  Arguments:  pUnkOuter   - outer unknown
//
//  History:    3-30-97     mohamedn    Created
//             10-05-97     danleg      _ErrorInfo
//             10-30-97     danleg      Prop info for Initialize/Uninitialize
//  Notes:
//
//----------------------------------------------------------------------------

CDataSrc::CDataSrc( IUnknown *  pUnkOuter,
                    IUnknown ** ppUnkInner )
                                          : _cSessionCount(0),
                                            _fDSOInitialized(FALSE),
                                            _fGlobalViewsCreated(FALSE),
                                            _xIPVerify(new CImpIParserVerify()),
                                            _UtlProps(_xIPVerify.GetPointer()),
#pragma warning(disable : 4355)
                                            _impIUnknown(this),
                                            _ErrorInfo( * ((IUnknown *) (IDBInitialize *) this), _mtxDSO )
#pragma warning(default : 4355)
{
    _pUnkOuter = pUnkOuter ? pUnkOuter : (IUnknown *) &_impIUnknown;
    _ErrorInfo.SetInterfaceArray( cDataSrcErrInt, apDataSrcErrInt );

    // SQL Text Parser
    // @devnote: The following is allocated since its existence is controlled
    // by AddRef and Release.
    SCODE sc = MakeIParser(((IParser**)_xIParser.GetQIPointer()));
    if( FAILED(sc) )
        THROW( CException(sc) );

    _UtlPropInfo.ExposeMinimalSets();
    _UtlProps.ExposeMinimalSets();

    *ppUnkInner = (IUnknown *) &_impIUnknown;
    (*ppUnkInner)->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::~CDataSrc
//
//  Synopsis:   d-ctor
//
//  Arguments:
//
//  History:    3-30-97     mohamedn    Created
//             10-30-97     danleg      Prop info for Initialize/Uninitialize
//----------------------------------------------------------------------------

CDataSrc::~CDataSrc()
{
    _UtlPropInfo.ExposeMaximalSets();
    _UtlProps.ExposeMaximalSets();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataSrc::RealQueryInterface
//
//  Synopsis:   Supports IID_IUnknown,
//                       IID_IDBInitialize,
//                       IID_IDBProperties,
//                       IID_IDBIPersist,
//                       IID_IDBCreateSession
//                       IID_IDBInfo
//
//  History:    03-30-97    mohamedn    created
//              09-05-97    danleg      added IDBInfo & ISupportErrorInfo
//              01-29-98    danleg      non delegating QI when not aggregated
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::RealQueryInterface(REFIID riid, void **ppvObj )
{

    SCODE sc = S_OK;

    if ( !ppvObj )
    return E_INVALIDARG;


    if ( riid == IID_IUnknown )
    {
        *ppvObj = (void *)  ( (IUnknown *) (IDBInitialize *) this );
    }
    else if ( riid == IID_IDBInitialize )
    {
        *ppvObj = (void *) (IDBInitialize *) this;
    }
    else if ( riid == IID_IDBProperties )
    {
        *ppvObj = (void *) (IDBProperties *) this;
    }
    else if ( riid == IID_IPersist )
    {
        *ppvObj = (void *) (IPersist *) this;
    }
    else if ( riid == IID_IDBCreateSession )
    {
        //
        // The following interfaces are supported only if DSO is initialized
        //

        // Make sure we don't get uninitialized
        if ( _fDSOInitialized )
        {
            *ppvObj = (void *) (IDBCreateSession *) this;
        }
        else
        {
            *ppvObj = 0;
            sc = E_UNEXPECTED;    // per OLE DB spec.
        }
    }
    else if ( riid == IID_IDBInfo )
    {
        *ppvObj = (void *) (IDBInfo *) this;
    }
    else if ( riid == IID_ISupportErrorInfo )
    {
        *ppvObj = (void *) ((IUnknown *) (ISupportErrorInfo *) &_ErrorInfo);
    }
    else
    {
        *ppvObj = 0;
        sc = E_NOINTERFACE;
    }

    return sc;

} // QueryInterface

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::Initialize
//
//  Synopsis:   changes the DSO state to Initialized.
//
//  Arguments:
//
//  History:    3-30-97     mohamedn    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::Initialize()
{

    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxDSO );

        if ( !_fDSOInitialized )
        {
            // Expose non-init propsets
            sc = _UtlProps.ExposeMaximalSets();
            if ( SUCCEEDED(sc) )
            {
                // Expose propinfo for non-init propsets
                _UtlPropInfo.ExposeMaximalSets();

                // OK, now we're initialized.
                _fDSOInitialized = TRUE;
            }
            else
            {
                THROW( CException(sc) );
            }
        }
        else
        {
            THROW( CException(DB_E_ALREADYINITIALIZED) );
        }
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBInitialize );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::Uninitialize
//
//  Synopsis:   changes the DSO state to Uninitialized.
//
//  Arguments:
//
//  History:    3-30-97     mohamedn    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::Uninitialize()
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxDSO );

        if ( 0 == _cSessionCount )
        {
            // Hide non-init propsets
            _UtlProps.ExposeMinimalSets();

            _UtlPropInfo.ExposeMinimalSets();

            // Mark DSO as uninitialized
            _fDSOInitialized = FALSE;
        }
        else
        {
            THROW( CException(DB_E_OBJECTOPEN) );
        }
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBInitialize );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataSrc::GetProperties
//
//  Synopsis:   gets IDBProperties
//
//  Arguments:  [cPropertyIDSets]  - number of desired property set IDs or 0
//              [pPropIDSets]      - array of desired property set IDs or NULL
//              [pcPropertySets]   - number of property sets returned
//              [prgPropertySets]  - array of returned property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED, E_INVALIDARG.
//
//  History:     3-30-97    mohamedn    Created
//              10-30-97    danleg      Chaned to use the Monarch prop code
//
//--------------------------------------------------------------------------

STDMETHODIMP CDataSrc::GetProperties
    (
    ULONG               cPropertySets,
    const DBPROPIDSET   rgPropertySets[],
    ULONG *             pcProperties,
    DBPROPSET **        prgProperties
    )
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxDSO );

        // Check Arguments
        _UtlProps.GetPropertiesArgChk( cPropertySets,
                                       rgPropertySets,
                                       pcProperties,
                                       prgProperties );

        // Note that CUtlProps knows about initialization,
        // so we don't have to here.
        sc = _UtlProps.GetProperties( cPropertySets,
                                      rgPropertySets,
                                      pcProperties,
                                      prgProperties );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataSrc::SetProperties
//
//  Synopsis:   sets IDBProperties
//
//  Arguments:  [cPropertySets]   - number of property sets
//              [rgPropertySets]  - array of property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED, E_INVALIDARG.
//
//  History:    03-30-97    mohamedn        created
//              10-30-97    danleg          Changed to use Monarch's prop code
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::SetProperties
    (
    ULONG cPropertySets,
    DBPROPSET rgPropertySets[]
    )
{
    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();


    // Quick return if the Count of Properties is 0
    if( cPropertySets == 0 )
        return S_OK;

    SCODE               sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XArray<DBPROPSET>   xaDbPropSet;
        ULONG               iNewSet, iSet, iProp;

        CLock lck( _mtxDSO );

        _UtlProps.SetPropertiesArgChk( cPropertySets, rgPropertySets );

        // We need to handle the DBINIT properties specially after being initialized.
        // - they should be treated as NOTSETTABLE at this point.
        if( _fDSOInitialized )
        {
            Win4Assert( cPropertySets );

            bool fFoundDBINIT = false;

            // Allocate a DBPROPSET structure of equal size
            xaDbPropSet.Init( cPropertySets );

            for( iNewSet=0,iSet=0; iSet<cPropertySets; iSet++ )
            {
                // Remove any DBPROPSET_DBINIT values and mark them all
                // as not settable
                if( rgPropertySets[iSet].guidPropertySet == DBPROPSET_DBINIT )
                {
                    fFoundDBINIT = true;

                    for(iProp=0; iProp<rgPropertySets[iSet].cProperties; iProp++)
                    {
                        rgPropertySets[iSet].rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                    }
                }
                else
                {
                    // If not DBPROPSET_DBINIT then copy the DBPROPSET values
                    RtlCopyMemory( &(xaDbPropSet[iNewSet++]), &rgPropertySets[iSet], sizeof(DBPROPSET) );
                }
            }

            // If we have no propertyset to pass on to the property handler,
            // we can exit
            if( 0 == iNewSet )
            {
                sc = DB_E_ERRORSOCCURRED;
            }
            else
            {
                sc = _UtlProps.SetProperties( iNewSet, xaDbPropSet.GetPointer() );

                // If we have determined that one of the property sets was DBINIT, we may
                // need to fixup the returned hr value.
                if( fFoundDBINIT && (sc == S_OK) )
                    sc = DB_S_ERRORSOCCURRED;
            }
        }
        else
        {
            // Note that CUtlProps knows about initialization, so we don't
            // have to here. This sets members _bstrCatalog and _bstrMachine
            // in CMDSProps
            sc = _UtlProps.SetProperties( cPropertySets, rgPropertySets );
        }

        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} // CDatasrc::SetProperties


//+---------------------------------------------------------------------------
//
//  Function:   CDataSrc::GetPropertyInfo
//
//  Synopsis:   sets IDBProperties
//
//  Arguments:  [cPropertyIDSets]       - number of property sets
//              [rgPropertyIDSets]      - array of property sets
//              [pcPropertyInfoSets]    - count of properties returned
//              [prgPropertyInfoSets]   - property information returned
//              [ppDescBuffer]          - buffer for returned descriptions
//
//  Returns:
//
//  History:    10-28-97    danleg              created from Monarch
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::GetPropertyInfo
    (
    ULONG             cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG *           pcPropertyInfoSets,
    DBPROPINFOSET **  prgPropertyInfoSets,
    OLECHAR **        ppDescBuffer
    )
{
    ULONG       ul;
    ULONG       cSpecialPropertySets = 0;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Initialize
    if( pcPropertyInfoSets )
        *pcPropertyInfoSets     = 0;
    if( prgPropertyInfoSets )
        *prgPropertyInfoSets    = 0;
    if( ppDescBuffer )
        *ppDescBuffer           = 0;

    // Check Arguments, on failure post HRESULT to error queue
    if( ((cPropertyIDSets > 0) && !rgPropertyIDSets ) ||
        !pcPropertyInfoSets || !prgPropertyInfoSets )
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBProperties );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ul=0; ul<cPropertyIDSets; ul++)
    {
        if( rgPropertyIDSets[ul].cPropertyIDs &&
            !(rgPropertyIDSets[ul].rgPropertyIDs) )
            return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBProperties );
    }

    //check the count of special propertySets
    for(ul=0; ul<cPropertyIDSets; ul++)
    {
        if( (rgPropertyIDSets[ul].guidPropertySet ==DBPROPSET_DATASOURCEALL) ||
            (rgPropertyIDSets[ul].guidPropertySet ==DBPROPSET_DATASOURCEINFOALL) ||
            (rgPropertyIDSets[ul].guidPropertySet ==DBPROPSET_DBINITALL) ||
            (rgPropertyIDSets[ul].guidPropertySet ==DBPROPSET_ROWSETALL) ||
            (rgPropertyIDSets[ul].guidPropertySet ==DBPROPSET_SESSIONALL) )
            cSpecialPropertySets++;
    }

    // if used SpecialPropertySets with non-special Propertysets
    if ((cSpecialPropertySets > 0) && (cSpecialPropertySets < cPropertyIDSets))
    {
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBProperties );
    }

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxDSO );

        sc =  _UtlPropInfo.GetPropertyInfo( cPropertyIDSets,
                                            rgPropertyIDSets,
                                            pcPropertyInfoSets,
                                            prgPropertyInfoSets,
                                            ppDescBuffer );
        if ( FAILED(sc) )
            THROW( CException(sc) );

    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::CreateGlobalViews
//
//  Synopsis:   Creates global views (FILEINFO, WEBINFO etc.).  These views
//              are removed when the IParser object goes away.
//
//  Arguments:
//
//  History:    01-09-98    danleg      Created
//
//----------------------------------------------------------------------------

void CDataSrc::CreateGlobalViews( IParserSession * pIPSession )
{
    SCODE sc = S_OK;
extern const LPWSTR s_pwszPredefinedViews;

    DBCOMMANDTREE * pDBCOMMANDTREE = 0;
    XInterface<IParserTreeProperties> xIPTProperties;

    LCID lcid = GetDSPropsPtr()->GetValLong( CMDSProps::eid_DBPROPSET_DBINIT,
                                             CMDSProps::eid_INIT_LCID );

    sc = pIPSession->ToTree( lcid,
                             s_pwszPredefinedViews,
                             &pDBCOMMANDTREE,
                             xIPTProperties.GetPPointer() );

    if ( FAILED(sc) )
        THROW( CException(sc) );

    _fGlobalViewsCreated = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::DupImpersonationToken, public
//
//  Synopsis:   Clients calling CreateSession can be impersonated.  One such
//              client, SQL Server's Distributed Query Processor, stays 
//              impersonated only for the duration of the call to CreateSession.
//              
//              This routine is called from CreateSession and caches the 
//              impersonation token.  This token is used to get back the security
//              context of the client during CreateCommand/OpenRowset.
//
//  Arguments:  
//
//  History:    09-01-98        danleg          Created
//
//  Notes:      Revisit if OLE DB defines "Integrated Security" differently in
//              the future, or defines a better security scheme.
//
//----------------------------------------------------------------------------

void CDataSrc::DupImpersonationToken
    (
    HANDLE & hToken
    )
{
    DWORD               dwLength = 0;
    NTSTATUS            status = STATUS_SUCCESS;
    TOKEN_STATISTICS    TokenInformation;
        HANDLE                          hTempToken;

    status = NtOpenThreadToken( GetCurrentThread(),
                                TOKEN_QUERY |
                                  TOKEN_DUPLICATE |
                                  TOKEN_IMPERSONATE,
                                TRUE,
                                &hTempToken );

    if ( !NT_SUCCESS(status) )
    {   
        if ( STATUS_NO_TOKEN == status )
        {
            status = NtOpenProcessToken( GetCurrentProcess(),
                                         TOKEN_QUERY |
                                            TOKEN_DUPLICATE |
                                            TOKEN_IMPERSONATE,
                                         &hTempToken );
        }
        
        if ( !NT_SUCCESS(status) )
        {
            vqDebugOut(( DEB_ERROR, 
                         "DupImpersonationToken failed to get token, %x\n",
                         status ));
            THROW( CException(status) );
        }
    }

        SHandle xHandle( hTempToken );

    HANDLE                      hNewToken = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES           ObjAttr;
    SECURITY_QUALITY_OF_SERVICE qos;

    qos.Length              = sizeof( SECURITY_QUALITY_OF_SERVICE  );
    qos.ImpersonationLevel  = SecurityImpersonation;
    qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    qos.EffectiveOnly       = FALSE;

    InitializeObjectAttributes( &ObjAttr,
                                NULL,
                                0,
                                NULL,
                                NULL );
    ObjAttr.SecurityQualityOfService = &qos;

    status = NtDuplicateToken( hTempToken,
                               TOKEN_IMPERSONATE |
                                 TOKEN_QUERY |
                                 TOKEN_DUPLICATE,
                               &ObjAttr,
                               FALSE,
                               TokenImpersonation,
                               &hNewToken );

    if ( !NT_SUCCESS(status) )
    {
        vqDebugOut(( DEB_ERROR,
                     "DupImpersonationToken failed to duplicate token, %x\n",
                     status ));
        THROW( CException(HRESULT_FROM_WIN32(status)) );
    }

    hToken = hNewToken;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::CreateSession
//
//  Synopsis:   Associates a session with the DSO.
//
//  Arguments:  [pUnkOuter]     - controlling unknown
//              [riid]          - interface requested
//              [ppDBSession]   - contains returned interface pointer
//
//  History:    3-30-97     mohamedn    Created
//              1-10-98     danleg      Added global views
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::CreateSession( IUnknown *   pUnkOuter,
                                      REFIID       riid,
                                      IUnknown **  ppDBSession )
{
    _ErrorInfo.ClearErrorInfo();

    if ( !ppDBSession )
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBCreateSession );
    else
        *ppDBSession = 0;

    if ( !_fDSOInitialized )
        return _ErrorInfo.PostHResult( E_UNEXPECTED, IID_IDBCreateSession );

    if (0 != pUnkOuter && riid != IID_IUnknown)
        return _ErrorInfo.PostHResult( DB_E_NOAGGREGATION, IID_IDBCreateSession );

    SCODE       sc          = S_OK;
    HANDLE      hToken      = INVALID_HANDLE_VALUE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XInterface<IColumnMapperCreator>  xColMapCreator;
        XInterface<IParserSession>        xIPSession;

        CLock lck( _mtxDSO );

        DupImpersonationToken( hToken );

        //
        // Service Components set DBPROP_RESETDATASOURCE to indicate that the DSO has been
        // pooled.  We need to reset the IParser object because it maintains state valid
        // across sessions (eg. views)
        //
        LONG lResetVal = _UtlProps.GetValLong( CMDSProps::eid_DBPROPSET_DATASOURCE,
                                               CMDSProps::eid_DBPROPVAL_RESETDATASOURCE);

        if ( DBPROPVAL_RD_RESETALL == lResetVal )
        {
            // make sure there aren't any outstanding sessions when doing this.

            if ( 0 != _cSessionCount )
                THROW( CException( E_INVALIDARG ) );

            _xIParser.Free();
            sc = MakeIParser( _xIParser.GetPPointer() );
            if ( FAILED(sc) )
                THROW( CException(sc) );

            _UtlProps.SetValLong( CMDSProps::eid_DBPROPSET_DATASOURCE,
                                  CMDSProps::eid_DBPROPVAL_RESETDATASOURCE,
                                  0L );
        }

        //
        // Create an IParserSession object to pass to the session
        //
        _xIPVerify->GetColMapCreator( xColMapCreator.GetPPointer() );

        sc = _xIParser->CreateSession( &DBGUID_MSSQLTEXT,
                                       GetDSPropsPtr()->GetValString(
                                              CMDSProps::eid_DBPROPSET_DBINIT,
                                              CMDSProps::eid_DBPROPVAL_INIT_LOCATION),
                                       _xIPVerify.GetPointer(),
                                       xColMapCreator.GetPointer(),
                                       xIPSession.GetPPointer() );
        if ( FAILED(sc) )
            THROW( CException(sc) );

        LPCWSTR pwszCatalog = 0;

        pwszCatalog = GetDSPropsPtr()->GetValString(
                                    CMDSProps::eid_DBPROPSET_DATASOURCE,
                                    CMDSProps::eid_DBPROPVAL_CURRENTCATALOG);

        sc = xIPSession->SetCatalog( pwszCatalog );
        if( FAILED(sc) )
            THROW( CException(sc) );

        //
        // Predefined views -- only once per DSO
        //
        if ( !_fGlobalViewsCreated )
            CreateGlobalViews( xIPSession.GetPointer() );

        //
        // Create the session object
        //
        XInterface<IUnknown>    xUnkInner;
        CDBSession *pDBSession = new CDBSession( *this,
                                                 pUnkOuter,
                                                 xUnkInner.GetPPointer(),
                                                 xIPSession.GetPointer(),
                                                 hToken );

        // NOTE: pDBSession is the same object as xUnkInner.
        sc = xUnkInner->QueryInterface( riid, (void **) ppDBSession );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH(CException, e)
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBCreateSession );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDataSrc::GetClassID
//
//  Synopsis:   Return the CLSID for this server object
//
//  Arguments:  [pClassID]
//
//  History:    3-30-97     mohamedn    Created
//             10-28-97     danleg      added _ErrorInfo
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::GetClassID    ( CLSID *pClassID )
{
    _ErrorInfo.ClearErrorInfo();

    if (pClassID)
    {
        RtlCopyMemory( pClassID, &CLSID_CiFwDSO, sizeof(CLSID) );
        return S_OK;
    }
    else
        return _ErrorInfo.PostHResult( E_FAIL, IID_IPersist );
}

//============================================================================
//  LITERAL INFO Constants
//============================================================================
// The following are constants that define literals that don't change..  When the buffer
// to return literal information is allocated, it is initialized with this string and
// then when a particular literal is asked for; a pointer in these values is used.

static const LPWSTR LIT_BUFFER                   = L"\"\0.\0%\0_\0[]\0[]\0";
static const ULONG  LIT_QUOTE_VALID_OFFSET       = 0;
static const ULONG  LIT_CATALOG_SEP_VALID_OFFSET = LIT_QUOTE_VALID_OFFSET + NUMELEM(L"\"");
static const ULONG  LIT_PERCENT_VALID_OFFSET     = LIT_CATALOG_SEP_VALID_OFFSET + NUMELEM(L".");
static const ULONG  LIT_UNDERSCORE_VALID_OFFSET  = LIT_PERCENT_VALID_OFFSET + NUMELEM(L"%");
static const ULONG  LIT_ESCAPE_PERCENT_OFFSET    = LIT_UNDERSCORE_VALID_OFFSET + NUMELEM(L"_");
static const ULONG  LIT_ESCAPE_UNDERSCORE_OFFSET = LIT_ESCAPE_PERCENT_OFFSET + NUMELEM(L"[]");
static const ULONG  LIT_CCH_INITIAL_BUFFER       = LIT_ESCAPE_UNDERSCORE_OFFSET + NUMELEM(L"[]");
static const ULONG  LIT_CB_INITIAL_BUFFER        = LIT_CCH_INITIAL_BUFFER * sizeof(WCHAR);

// List of unique Keywords that OLE DB does not define.
static const WCHAR s_pwszKeyWords[] = {L"ARRAY,COERCE,CONTAINS,DEEP,DERIVATIONAL,"
                                       L"EXCLUDE,FORMSOF,FREETEXT,INFLECTIONAL,"
                                       L"ISABOUT,MATCHES,NEAR,PARAGRAPH,PASSTHROUGH,"
                                       L"PROPERTYNAME,PROPID,RANKMETHOD,SENTENCE,"
                                       L"SCOPE,SEARCH,SHALLOW,SOUNDEX,THESAURUS,"
                                       L"TRAVERSAL,TYPE,WEIGHT,WORD"};

//+---------------------------------------------------------------------------
//
//  Function:   CDataSrc::GetKeywords
//
//  Synopsis:   returns a list of provider specific keywords
//
//  Arguments:  [ppwszKeywords]   - string containing returned list of comma
//                                  separated keywords
//
//  Returns:    HRESULT indicating the status of the method
//              S_OK | Keyword list retrieved
//              E_FAIL | Provider specific error (ODBC call failed)
//              E_OUTOFMEMORY | Buffer could not be allocated for the keywords.
//              E_INVALIDARG | Arguments did not match specification
//
//  History:    09-05-97    danleg      created from Monarch project
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::GetKeywords(LPOLESTR* ppwszKeywords)
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxDSO );

        // Check arguments
        if( ppwszKeywords )
        {
            *ppwszKeywords = 0;

            // Check that object is initialized
            if( _fDSOInitialized )
            {
                XArrayOLE<WCHAR>   xpwszKeyWords( NUMELEM(s_pwszKeyWords) );
                RtlCopyMemory( xpwszKeyWords.GetPointer(),
                               s_pwszKeyWords,
                               sizeof(s_pwszKeyWords) );

                *ppwszKeywords = xpwszKeyWords.Acquire();

            }
            else
            {
                vqDebugOut(( DEB_TRACE, "Initialization must occur before IDBInfo can be called\n" ));
                sc = E_UNEXPECTED;
            }
        }
        else
        {
            sc = E_INVALIDARG;
        }

        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBInfo );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataSrc::GetLiteralInfo
//
//  Synopsis:   Retreives information about literals.  Their length, and special
//              characters and whether they are actually supported.
//
//  Arguments:  [cLiterals]         - Number of literals being asked about
//              [rgLiterals]        - Array of literals being asked about
//              [pcLiteralInfo]     - Contains returned number of literals
//              [prgLiteralInfo]    - Contains returned literal information
//              [ppCharBuffer]      - Buffer for returned string values
//
//  Returns:    HRESULT indicating the status of the method
//              S_OK            | Keyword list retrieved
//              E_FAIL          | Provider specific error (ODBC call failed)
//              E_OUTOFMEMORY   | Buffer could not be allocated for the keywords.
//              E_INVALIDARG    | Arguments did not match specification
//
//  History:    09-05-97    danleg      created from Monarch project
//
//----------------------------------------------------------------------------

STDMETHODIMP CDataSrc::GetLiteralInfo
    (
    ULONG cLiterals,
    const DBLITERAL rgLiterals[],
    ULONG* pcLiteralInfo,
    DBLITERALINFO** prgLiteralInfo,
    OLECHAR**   ppCharBuffer
    )
{
    SCODE           sc = S_OK;

const DWORD LITERAL_NORESTRICTIONS      = 0x00000001;
const DWORD LITERAL_FAILURE             = 0x00000002;
const DWORD LITERAL_SUCCESS             = 0x00000004;

const static DBLITERAL s_rgSupportedLiterals[] = {
        DBLITERAL_BINARY_LITERAL, DBLITERAL_CATALOG_NAME, DBLITERAL_CATALOG_SEPARATOR,
        DBLITERAL_CHAR_LITERAL, DBLITERAL_COLUMN_NAME, DBLITERAL_CORRELATION_NAME,
        DBLITERAL_ESCAPE_PERCENT, DBLITERAL_ESCAPE_UNDERSCORE,
        DBLITERAL_LIKE_PERCENT, DBLITERAL_LIKE_UNDERSCORE, DBLITERAL_TABLE_NAME,
        DBLITERAL_TEXT_COMMAND, DBLITERAL_VIEW_NAME, DBLITERAL_QUOTE_PREFIX,
                DBLITERAL_QUOTE_SUFFIX
        };

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Initialize
    if( pcLiteralInfo )
        *pcLiteralInfo  = 0;
    if( prgLiteralInfo )
        *prgLiteralInfo = 0;
    if( ppCharBuffer )
        *ppCharBuffer   = 0;

    // Check Arguments
    if( ((cLiterals > 0) && !rgLiterals) ||
        !pcLiteralInfo ||
        !ppCharBuffer ||
        !prgLiteralInfo )
    {
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBInfo );
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        ULONG           ulDex,
                        ulNew;
        DWORD           dwStatus = 0;
        DBLITERALINFO*  pdbLitInfo;

        CLock lck( _mtxDSO );

        // We must be initialized
        if( !_fDSOInitialized )
        {
            vqDebugOut(( DEB_TRACE, "Initialization must occur before IDBInfo can be called\n" ));
            return _ErrorInfo.PostHResult( E_UNEXPECTED, IID_IDBInfo );
        }

        // Allocate Memory for literal information
        if( cLiterals == 0 )
        {
            dwStatus |= LITERAL_NORESTRICTIONS;
            cLiterals = NUMELEM( s_rgSupportedLiterals );
            rgLiterals = s_rgSupportedLiterals;
        }

        XArrayOLE<DBLITERALINFO>        xaLiteralInfo( cLiterals );
        XArrayOLE<WCHAR>                xaCharBuffer( LIT_CCH_INITIAL_BUFFER );

        // Initialize the first part of the buffer with our
        // static set of literal information
        RtlCopyMemory( xaCharBuffer.GetPointer(), LIT_BUFFER, LIT_CB_INITIAL_BUFFER );

        // Process each of the DBLITERAL values that are in the
        // restriction array or that we potentially could support
        for(ulDex=0, ulNew=0; ulDex<cLiterals; ulDex++)
        {
            pdbLitInfo                           = &(xaLiteralInfo[ulNew]);
            pdbLitInfo->lt                       = rgLiterals[ulDex];
            pdbLitInfo->fSupported               = TRUE;
            pdbLitInfo->pwszLiteralValue         = 0;
            pdbLitInfo->pwszInvalidChars         = 0;
            pdbLitInfo->pwszInvalidStartingChars = 0;

            switch( rgLiterals[ulDex] )
            {
                case DBLITERAL_TEXT_COMMAND:
                case DBLITERAL_CHAR_LITERAL:
                case DBLITERAL_BINARY_LITERAL:
                case DBLITERAL_TABLE_NAME:
                    pdbLitInfo->cchMaxLen = ~0;
                    break;

                case DBLITERAL_CATALOG_NAME:
                case DBLITERAL_COLUMN_NAME:
                case DBLITERAL_CORRELATION_NAME:
                case DBLITERAL_VIEW_NAME:
                    pdbLitInfo->cchMaxLen = 128;
                    break;


                case DBLITERAL_CATALOG_SEPARATOR:
                    pdbLitInfo->cchMaxLen = 1;      // L'.';
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_CATALOG_SEP_VALID_OFFSET;
                    break;
                case DBLITERAL_ESCAPE_PERCENT:
                    pdbLitInfo->cchMaxLen = 2;      // L"[]";
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_ESCAPE_PERCENT_OFFSET;
                    break;
                case DBLITERAL_ESCAPE_UNDERSCORE:
                    pdbLitInfo->cchMaxLen = 2;      // L"[]";
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_ESCAPE_UNDERSCORE_OFFSET;
                    break;
                case DBLITERAL_LIKE_PERCENT:
                    pdbLitInfo->cchMaxLen = 1;      // L'%';
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_PERCENT_VALID_OFFSET;
                    break;
                case DBLITERAL_LIKE_UNDERSCORE:
                    pdbLitInfo->cchMaxLen = 1;      // L'_';
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_UNDERSCORE_VALID_OFFSET;
                    break;
                case DBLITERAL_QUOTE_PREFIX:
                                case DBLITERAL_QUOTE_SUFFIX:
                    pdbLitInfo->cchMaxLen = 1;      // L'"';
                    pdbLitInfo->pwszLiteralValue = xaCharBuffer.GetPointer() + LIT_QUOTE_VALID_OFFSET;
                    break;
                default:
                    pdbLitInfo->cchMaxLen = 0;
                    // If we are given a dbLiteral that we do not
                    // support, just set the fSupport flag false
                    // and continue on.
                    pdbLitInfo->fSupported = FALSE;
                    break;
            }

            // If we are returning all the supported literals, then
            // we need to drop any that are fSupported = FALSE;
            if( dwStatus & LITERAL_NORESTRICTIONS )
            {
                if( pdbLitInfo->fSupported == FALSE )
                    continue;
            }
            else
            {
                if( pdbLitInfo->fSupported == FALSE )
                    dwStatus |= LITERAL_FAILURE;
                else
                    dwStatus |= LITERAL_SUCCESS;
            }

            ulNew++;
        }

        sc = (dwStatus & LITERAL_FAILURE) ?
                ((dwStatus & LITERAL_SUCCESS) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED) :
                S_OK;

        *pcLiteralInfo  = ulNew;

        // We only want to return the string buffer if it
        // is a success
        if ( SUCCEEDED(sc) )
            *ppCharBuffer   = xaCharBuffer.Acquire();

        // We want to return the LiteralInfo on success and on
        // a DB_E_ERRORSOCCURRED failure
        if ( SUCCEEDED(sc) || (sc == DB_E_ERRORSOCCURRED) )
            *prgLiteralInfo = xaLiteralInfo.Acquire();

        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBInfo );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cidso\dsocf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       dsocf.cxx
//
//  Contents:   Class factory for ole-db DSO
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "dsocf.hxx"
#include "datasrc.hxx"

//
//  We keep count of the number of filter objects that we've created
//  to let OLE know when this DLL is finally free.
//

extern long gulcInstances;

// {F9AE8980-7E52-11d0-8964-00C04FD611D7 }

extern "C" const GUID CLSID_CiFwDSO = CLSID_INDEX_SERVER_DSO;

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::CDataSrcObjectCF
//
//  Synopsis:   DSO class factory constructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//+-------------------------------------------------------------------------

CDataSrcObjectCF::CDataSrcObjectCF()
    : _RefCount( 1 )
{
    InterlockedIncrement( &gulcInstances );

    END_CONSTRUCTION ( CDataSrcObjectCF );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::~CDataSrcObjectCF()
//
//  Synopsis:   DSO class factory destructor
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

CDataSrcObjectCF::~CDataSrcObjectCF()
{
    Win4Assert( _RefCount == 0);
    Win4Assert( gulcInstances != 0 );

    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::AddRef()
//
//  Synopsis:   Increments refcount
//
//  History:    6-Jan-1997  markz   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDataSrcObjectCF::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    6-Jan-1997  markz   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDataSrcObjectCF::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;

}   //  Release

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    6-Jan-1997  MarkZ   Created
//              01-30-98    danleg  return E_INVALIDARG if ppvObject is bad
//
//--------------------------------------------------------------------------

STDMETHODIMP CDataSrcObjectCF::QueryInterface(
    REFIID riid,
    PVOID* ppvObject )
{
    if ( !ppvObject )
        return E_INVALIDARG;

    if ( IID_IUnknown == riid )
    {
        AddRef( );
        *ppvObject = (PVOID) ((IUnknown *) this );
        return S_OK;
    }
    else if ( IID_IClassFactory == riid)
    {
        AddRef( );
        *ppvObject = (PVOID) ((IClassFactory *) this );
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::CreateInstance
//
//  Synopsis:   Create new DSO instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CDataSrcObjectCF::CreateInstance(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    PVOID    *  ppvObject )
{
    CDataSrc  * pDataSrc = 0;
    SCODE       sc       = S_OK;

    if (!ppvObject)
        return ResultFromScode(E_INVALIDARG);

    if( pUnkOuter && riid != IID_IUnknown )
		return ResultFromScode(E_NOINTERFACE);


    TRANSLATE_EXCEPTIONS;

    TRY
    {
        //
        //  Create the new object
        //
        XInterface<IUnknown>    xInnerUnk;
        pDataSrc = new CDataSrc( pUnkOuter, xInnerUnk.GetPPointer() );

        //
        //  Obtain the new interface.  NOTE: pDatasrc is the same object as xInnerUnk
        //
        sc = xInnerUnk->QueryInterface( riid , ppvObject );

    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pDataSrc );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = E_OUTOFMEMORY;
            break;
        default:
            sc = E_UNEXPECTED;
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataSrcObjectCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    6-Jan-1997  MarkZ   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CDataSrcObjectCF::LockServer( BOOL fLock )
{
    if (fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cidso\parsver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       parsver.cxx
//
//  Contents:   IParserVerify implementation
//
//  History:    11-06-97        danleg      Created
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

#include <parsver.hxx>
#include <cmdcreat.hxx>     // CSimpleCommandCreator

// Constants -----------------------------------------------------------------

static const GUID clsidCICommandCreator = CLSID_CISimpleCommandCreator;


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::CImpIParserVerify, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

CImpIParserVerify::CImpIParserVerify() : _cRef(1)
{
    _xISimpleCommandCreator.Set( new CSimpleCommandCreator() );
}


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::QueryInterface, public
//
//  Synopsis:   Returns a pointer to a specified interface. Callers use 
//              QueryInterface to determine which interfaces the called 
//              object supports. 
//
//  Returns:    S_OK            Interface is supported and ppvObject is set
//              E_NOINTERFACE   Interface is not supported
//              E_INVALIDARG    One or more arguments are invalid 
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP CImpIParserVerify::QueryInterface
    (
    REFIID riid,                //@parm IN | Interface ID of the interface being queried for. 
    LPVOID * ppv                //@parm OUT | Pointer to interface that was instantiated      
    )
{
    if( ppv == NULL )
        return E_INVALIDARG;

    if( (riid == IID_IUnknown) ||
        (riid == IID_IParserVerify) )
        *ppv = (LPVOID)this;
    else
        *ppv = NULL;


    //  If we're going to return an interface, AddRef it first
    if( *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::AddRef, public
//
//  Synopsis:   Increments a persistence count for the object
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CImpIParserVerify::AddRef (void)
{
    return InterlockedIncrement( (long*) &_cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::Release, public
//
//  Synopsis:   Decrements the persistence count for the object and if it is 0, 
//              the object destroys itself.
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CImpIParserVerify::Release (void)
{
    ULONG cRef;

    Win4Assert( _cRef > 0 );
    if( !(cRef = InterlockedDecrement( (long *) &_cRef)) )
    {
        delete this;
        return 0;
    }

    return cRef;
}


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::VerifyMachine, public
//
//  Synopsis:   Called by the parser to verify that the machine name is valid
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP CImpIParserVerify::VerifyMachine(
    LPCWSTR pcwszMachine
    )
{
    return _xISimpleCommandCreator->VerifyCatalog(pcwszMachine, NULL);
}


//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::VerifyCatalog, public
//
//  Synopsis:   Called by the parser to verify that the catalog name is valid
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP CImpIParserVerify::VerifyCatalog(
    LPCWSTR pcwszMachine,
    LPCWSTR pcwszCatalog
    )
{
    return _xISimpleCommandCreator->VerifyCatalog(pcwszMachine, pcwszCatalog);
}

  
//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::GetDefaultCatalog, public
//
//  Synopsis:   Retrieve the default catalog name
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

STDMETHODIMP CImpIParserVerify::GetDefaultCatalog   
    ( 
    LPWSTR  pwszCatalogName, 
    ULONG   cwcIn, 
    ULONG * pcwcOut 
    )
{
    Win4Assert( !_xISimpleCommandCreator.IsNull() );
    return _xISimpleCommandCreator->GetDefaultCatalog( pwszCatalogName,
                                                       cwcIn,
                                                       pcwcOut );
}
  

//+-------------------------------------------------------------------------
//
//  Member:     CImpIParserVerify::GetColMapperCreator, public
//
//  Synopsis:   Retrieve an IColumnMapperCreator interface pointer
//
//  History:    11-20-97    danleg      Created from Monarch
//
//--------------------------------------------------------------------------

void CImpIParserVerify::GetColMapCreator
    (
    IColumnMapperCreator** ppIColMapCreator
    )
{
    SCODE  sc = S_OK;

    if ( ppIColMapCreator )
    {
        *ppIColMapCreator = 0;

        sc = _xISimpleCommandCreator->QueryInterface( IID_IColumnMapperCreator,
                                                     (void **) ppIColMapCreator );
    }
    else
        sc = E_INVALIDARG;

    if ( FAILED(sc) )
        THROW( CException(sc) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cidso\session.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       session.cxx
//
//  Contents:   TSession interfaces.
//
//  History:    3-30-97     MohamedN   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define DBINITCONSTANTS
#include <mparser.h>
#undef DBINITCONSTANTS

#include <session.hxx>
#include <stdqspec.hxx>     // CQuerySpec

// Constants -----------------------------------------------------------------
// Session object interfaces that support ISupportErrorInfo
static const GUID* apSessionErrInt[] = 
{
    &IID_IDBCreateCommand,
    &IID_IGetDataSource,
    &IID_IOpenRowset,
    &IID_ISessionProperties,
};
static const ULONG cSessionErrInt       = NUMELEM( apSessionErrInt );

//+---------------------------------------------------------------------------
//
//  Class:      CDBSession::CDBSession
//
//  Purpose:    ctor
//
//  History:    3-30-97     MohamedN   Created
//
//  Notes: 
//
//----------------------------------------------------------------------------

CDBSession::CDBSession( CDataSrc &  dataSrc, 
                        IUnknown *  pUnkOuter,
                        IUnknown ** ppUnkInner,
                        IParserSession * pIPSession,
                        HANDLE      hToken ) : 
        _dataSrc(dataSrc),
#pragma warning(disable : 4355) // 'this' in ctor
        _impIUnknown(this),
        _ErrorInfo( * ((IUnknown *) (IOpenRowset *) this), _mtxSess ),
#pragma warning(default : 4355) // 'this' in ctor.
        _xSessionToken( hToken )
{
    _pUnkOuter  = pUnkOuter ? pUnkOuter : (IUnknown *) &_impIUnknown;
  
    _ErrorInfo.SetInterfaceArray( cSessionErrInt, apSessionErrInt );    

    _dataSrc.AddRef();
    _dataSrc.IncSessionCount();

    //
    // SQL Text Parser
    //
    Win4Assert( pIPSession );
    _xIPSession.Set( pIPSession );
    _xIPSession->AddRef();

    *ppUnkInner = (IUnknown *) &_impIUnknown;
    (*ppUnkInner)->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Class:      CDBSession::~CDBSession
//
//  Purpose:    dtor
//
//  History:    3-30-97     MohamedN   Created
//
//  Notes: 
//
//----------------------------------------------------------------------------

CDBSession::~CDBSession()
{
    _dataSrc.DecSessionCount();
    _dataSrc.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDBSession::RealQueryInterface
//
//  Synopsis:   Supports IID_IUnknown,
//                       IID_IGetDataSource,
//                       IID_IOpenRowset,
//                       IID_ISessionProperties,
//                       IID_IDBCreateCommand
//                       IID_ISupportErrorInfo
//
//  History:    03-30-97    mohamedn    created
//              10-18-97    danleg      added ISupportErrorInfo Support
//              01-29-98    danleg      non delegating QI when not aggregated
//----------------------------------------------------------------------------

STDMETHODIMP CDBSession::RealQueryInterface(REFIID riid, void **ppvObj )
{
    SCODE sc = S_OK;
    
    if ( !ppvObj )
        return E_INVALIDARG;

    *ppvObj = 0;

    if ( riid == IID_IUnknown )
    {
        *ppvObj = (void *) ( (IUnknown *) (IOpenRowset *) this );
    }
    else if ( riid == IID_IGetDataSource )
    {
        *ppvObj = (void *) (IGetDataSource *) this;
    }
    else if ( riid == IID_ISessionProperties )
    {
        *ppvObj = (void *) (ISessionProperties *) this;
    }
    else if ( riid == IID_IOpenRowset )
    {
        *ppvObj = (void *) (IOpenRowset *) this;
    }
    else if ( riid == IID_IDBCreateCommand )
    {
        *ppvObj = (void *) (IDBCreateCommand *) this;
    }
    else if ( riid == IID_ISupportErrorInfo )
    {
        *ppvObj = (void *) ((IUnknown *) (ISupportErrorInfo *) &_ErrorInfo);
    }
    else
    {
        *ppvObj = 0;
        sc = E_NOINTERFACE;
    }

    return sc;
} //RealQueryInterface

//+---------------------------------------------------------------------------
//
//  Method:     CDBSession::GetDataSource
//
//  Synopsis:   obtains the owning data source object
//
//  Arguments:  [riid]          - interface to bind
//              [ppDataSource]  - interface returned here
//
//  returns:    S_OK, E_NOINTERFACE
//
//  History:     3-30-97    mohamedn    Created
//              11-20-97    danleg      QI on OuterUnk 
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CDBSession::GetDataSource( REFIID riid, IUnknown ** ppDataSource )
{

    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Check Function Arguments
    if ( 0 == ppDataSource )
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IGetDataSource );
    
    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxSess );

        *ppDataSource = 0;

        sc = (_dataSrc.GetOuterUnk())->QueryInterface( riid, (void **)ppDataSource );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IGetDataSource );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDBSession::GetProperties
//
//  Synopsis:   gets ISessionProperties
//
//  Arguments:  [cPropertyIDSets]  - number of desired property set IDs or 0
//              [pPropIDSets]      - array of desired property set IDs or NULL
//              [pcPropertySets]   - number of property sets returned
//              [prgPropertySets]  - array of returned property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED, E_INVALIDARG.
//
//  History:    03-30-97    mohamedn    Created
//              10-30-97    danleg      Changed to use common property code 
//--------------------------------------------------------------------------

STDMETHODIMP CDBSession::GetProperties(ULONG cPropertySets, const DBPROPIDSET rgPropertySets[],
                                       ULONG* pcProperties, DBPROPSET** prgProperties)
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxSess );

        _UtlProps.GetPropertiesArgChk( cPropertySets,
                                       rgPropertySets,
                                       pcProperties,
                                       prgProperties );

        sc = _UtlProps.GetProperties( cPropertySets,
                                      rgPropertySets,
                                      pcProperties,
                                      prgProperties );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_ISessionProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDBSession::SetProperties
//
//  Synopsis:   sets ISessionProperties
//
//  Arguments:  [cPropertySets]   - number of property sets
//              [rgPropertySets]  - array of property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED, E_INVALIDARG.
//
//  History:    03-30-97    mohamedn      created
//              10-28-97    danleg        Changed to use common property code
//----------------------------------------------------------------------------

STDMETHODIMP CDBSession::SetProperties(ULONG cPropertySets, DBPROPSET rgPropertySets[])
{
    SCODE sc = S_OK;

    // Win4Assert( _pCUtlProps );

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Quick return if the Count of Properties is 0
    if( cPropertySets == 0 )
        return S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxSess );

        _UtlProps.SetPropertiesArgChk( cPropertySets, rgPropertySets );

        sc = _UtlProps.SetProperties( cPropertySets,
                                      rgPropertySets);
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_ISessionProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDBSession::CreateCommand
//
//  Synopsis:   Creates an ICommand object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppCommand] -- Interface returned here
//
//
//  returns:    SCODE of success or failure.
//
//  History:    03-30-97     mohamedn    Created
//              11-03-97     danleg      Aggregation support & error posting
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CDBSession::CreateCommand
    (
    IUnknown *  pUnkOuter, 
    REFIID      riid, 
    IUnknown ** ppCommand
    )
{
    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Check Function Arguments
    if ( 0 == ppCommand )
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IDBCreateCommand );

    if (0 != pUnkOuter && riid != IID_IUnknown)  
        return _ErrorInfo.PostHResult( DB_E_NOAGGREGATION, IID_IDBCreateCommand );  

    *ppCommand          = 0;
    SCODE        sc     = S_OK;
    CQuerySpec * pQuery = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        IUnknown * pUnkInner = 0;

        // Serialize access to this object.
        CLock lck( _mtxSess );

        pQuery = new CQuerySpec( pUnkOuter, &pUnkInner, this );

        XInterface<IUnknown> xUnkInner( pUnkInner );

        if ( IID_IUnknown == riid )
        {
            *ppCommand = pUnkInner;
        }
        else
        {
            sc = pUnkInner->QueryInterface( riid, (void **)ppCommand );
            if ( FAILED(sc) )
            {
                Win4Assert( 0 == *ppCommand );
                THROW( CException(sc) );
            }
        }
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IDBCreateCommand );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;
    
    return sc;
} //CreateCommand
 


//
// Constants used by OpenRowset
//
static const WCHAR BASE_SELECT[]    = L"SELECT Path, FileName, Size, Write,"\
                                      L"Attrib, DocTitle, DocAuthor, DocSubject,"\
                                      L"DocKeywords, Characterization FROM "\
                                      L"SCOPE('SHALLOW TRAVERSAL OF %s')";

//Approx. size (Includes space for NULL-TERMINATOR, do not subtract this out)
const ULONG APPROX_CCH_BASE_SELECT      = sizeof(BASE_SELECT) / sizeof(WCHAR);  

//+---------------------------------------------------------------------------
//
//  Method:     CDBSession::OpenRowset
//
//  Synopsis:   Opens and returns a rowset that includes all rows from 
//              a single base table
//
//  Arguments:  [pUnkOuter]      - Controlling unknown, if any
//              [pTableID]       - Table to open
//              [pIndexID]       - DBID of the index
//              [riid]           - Interface to return
//              [cPropertySets]  - Count of properties
//              [rgPropertySets] - Array of property values
//              [ppRowset]       - Where to return interface
//
//  Returns:    S_OK          - The method succeeded
//              E_INVALIDARG  - pTableID and pIndexId were NULL
//              E_FAIL        - Provider-specific error
//              DB_E_NOTABLE  - Specified table does not exist in current Data
//                              Data Source object
//              E_OUTOFMEMORY - Out of memory
//              E_NOINTERFACE - The requested interface was not available
//
//  History:    10-26-97    danelg     Created from Monarch
//
//----------------------------------------------------------------------------

STDMETHODIMP CDBSession::OpenRowset
    (
    IUnknown *  pUnkOuter,
    DBID     *  pTableID,
    DBID     *  pIndexID,
    REFIID      riid,
    ULONG       cPropertySets,
    DBPROPSET   rgPropertySets[],
    IUnknown ** ppRowset
    )
{
    ULONG                   ul, ul2;
    SCODE                   sc          = S_OK;
    SCODE                   scProp      = S_OK;

    // Clear previous Error Object for this thread
    _ErrorInfo.ClearErrorInfo();

    // Intialize Buffer
    if( ppRowset )
        *ppRowset = NULL;

    if ( 0 != pUnkOuter && IID_IUnknown != riid )
        return _ErrorInfo.PostHResult( DB_E_NOAGGREGATION, IID_IOpenRowset );
    
    // Check Arguments
    if( (!pTableID && !pIndexID) )
        return _ErrorInfo.PostHResult( E_INVALIDARG, IID_IOpenRowset );

    // We only accept NULL for pIndexID
    if( pIndexID )
        return _ErrorInfo.PostHResult( DB_E_NOINDEX, IID_IOpenRowset );

    // If the eKind is not known to use, basically it
    // means we have no table identifier
    if( (!pTableID) ||
        (pTableID->eKind != DBKIND_NAME) ||
        ((pTableID->eKind == DBKIND_NAME) && (!(pTableID->uName.pwszName))) ||
        (wcslen(pTableID->uName.pwszName) == 0) )
        return _ErrorInfo.PostHResult( DB_E_NOTABLE, IID_IOpenRowset );

    // We do not allow the riid to be IID_NULL
    if( riid == IID_NULL )
        return _ErrorInfo.PostHResult( E_NOINTERFACE, IID_IOpenRowset );


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // Serialize access to this object.
        CLock lck( _mtxSess );

        XInterface<ICommandText>    xICmdText;
        IUnknown *                  pUnkInner;

        // Check Arguments for use by properties
        CUtlProps::SetPropertiesArgChk( cPropertySets, rgPropertySets );

        //
        // pUnkOuter is the outer unkown from the user on the Session 
        // object.  Don't use pUnkOuter for the Command object here.
        //
        XInterface<CQuerySpec>  xQuery(
            new CQuerySpec(0, &pUnkInner, this) );

        // Tell the command object to post errors as IOpenRowset
        xQuery->ImpersonateOpenRowset();

        // Construct and set Command.  Allocate buffer for SQL Statement
        XArray<WCHAR> xwszBuff( wcslen(pTableID->uName.pwszName) + APPROX_CCH_BASE_SELECT );

        //@devnote: swprintf not supported on win95?
        swprintf( xwszBuff.Get(), BASE_SELECT, pTableID->uName.pwszName );   

        sc = pUnkInner->QueryInterface( IID_ICommandText, 
                                        xICmdText.GetQIPointer() );
        if( SUCCEEDED(sc) )
        {
            Win4Assert( !xICmdText.IsNull() );

            sc = xICmdText->SetCommandText( DBGUID_SQL, xwszBuff.Get() );

            // Process properties
            if ( SUCCEEDED(sc) && cPropertySets > 0)
            {
                sc = SetOpenRowsetProperties(xICmdText.GetPointer(), 
                                            cPropertySets, rgPropertySets);
                scProp = sc;        // Save this retcode.
            }

            // Execute the SQL Statement if we were given a ppRowset
            if ( SUCCEEDED(sc) && ppRowset )
            {
                sc = xICmdText->Execute( pUnkOuter, riid, 0, 0, ppRowset );
                if ( DB_E_ERRORSOCCURRED == sc && (cPropertySets > 0) )
                {
                    sc = MarkOpenRowsetProperties((xICmdText.GetPointer()), 
                                            cPropertySets, rgPropertySets);
                }
            }
        }
    
        sc = (sc == S_OK) ? scProp : sc;
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
    CATCH( CException, e )
    {
        sc = _ErrorInfo.PostHResult( e, IID_IOpenRowset );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDBSession::SetOpenRowsetProperties, private
//
//  Synopsis:   Loop through the passed in properties andmark those in error.
//              Used by OpenRowset()
//
//  History:    10-31-97        briants      Created
//
//----------------------------------------------------------------------------

SCODE CDBSession::SetOpenRowsetProperties(
    ICommandText*   pICmdText,
    ULONG       cPropertySets,
    DBPROPSET   rgPropertySets[]
    )
{
    Win4Assert( pICmdText != NULL );
    XInterface<ICommandProperties>  xICmdProp;

    SCODE sc = pICmdText->QueryInterface( IID_ICommandProperties, 
                               (void **) xICmdProp.GetQIPointer() );
    if( SUCCEEDED(sc) )
    {
        Win4Assert( !xICmdProp.IsNull() );

        sc = xICmdProp->SetProperties( cPropertySets, rgPropertySets );
        if ( (DB_E_ERRORSOCCURRED == sc) || (DB_S_ERRORSOCCURRED == sc) )
        {
            // If all the properties set were OPTIONAL then we can set our status to 
            // DB_S_ERRORSOCCURED and continue
            for(ULONG ul=0;ul<cPropertySets; ul++)
            {
                for(ULONG ul2=0;ul2<rgPropertySets[ul].cProperties; ul2++)
                {
                    // Check for a required property that failed, if found, we must return
                    // DB_E_ERRORSOCCURRED
                    if( (rgPropertySets[ul].rgProperties[ul2].dwStatus != DBPROPSTATUS_OK) &&
                        (rgPropertySets[ul].rgProperties[ul2].dwOptions != DBPROPOPTIONS_OPTIONAL) )
                        return DB_E_ERRORSOCCURRED;
                }
            }
            sc = DB_S_ERRORSOCCURRED;
        }
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDBSession::MarkOpenRowsetProperties, private
//
//  Synopsis:   Loop through the passed in properties andmark those in error.
//              Used by OpenRowset()
//
//  History:    10-31-97    briants     Created
//
//----------------------------------------------------------------------------

SCODE CDBSession::MarkOpenRowsetProperties(
    ICommandText* pICmdText,
    ULONG       cPropertySets,
    DBPROPSET   rgPropertySets[]
    )
{
    Win4Assert( pICmdText != NULL );
    XInterface<ICommandProperties>  xICmdProp;

    DBPROPSET *             pPropSets = 0;
    ULONG                   cPropSets = 0;
    DBPROPIDSET             dbPropIdSet[1];

    dbPropIdSet[0].guidPropertySet  = DBPROPSET_PROPERTIESINERROR;
    dbPropIdSet[0].cPropertyIDs     = 0;
    dbPropIdSet[0].rgPropertyIDs    = 0;

    SCODE sc = pICmdText->QueryInterface( IID_ICommandProperties, 
                               (void **) xICmdProp.GetQIPointer() );
    if( SUCCEEDED(sc) )
    {
        Win4Assert( !xICmdProp.IsNull() );
        sc = xICmdProp->GetProperties( 1, 
                                   dbPropIdSet, 
                                   &cPropSets, 
                                   &pPropSets );
        if( SUCCEEDED(sc) )
        {
            XArrayOLEInPlace<CDbPropSet>   xPropSets;
            xPropSets.Set( cPropSets, (CDbPropSet *)pPropSets );
            
            // Loop through all the properties in error and see if one 
            // of the passed in properties matches. If it matches, then 
            // transfer the in error status.
            for(ULONG iSet=0; iSet<cPropSets; iSet++)
            {
                if( 0 == xPropSets[iSet].rgProperties ||
                    0 == xPropSets[iSet].cProperties )
                    continue;

                for(ULONG iProp=0; iProp<xPropSets[iSet].cProperties; iProp++)
                {
                    MarkPropInError( cPropertySets, 
                                     rgPropertySets, 
                                     &(xPropSets[iSet].guidPropertySet),
                                     &(xPropSets[iSet].rgProperties[iProp]) );
            
                    // Clear variant value
                    VariantClear(&(xPropSets[iSet].rgProperties[iProp].vValue));
                }
                // Free the memory as we go through them
//              CoTaskMemFree(xPropSets[iSet].rgProperties);
            }
        }
    }

    return sc;
}           

//+---------------------------------------------------------------------------
//
//  Member:     CDBSession::MarkPropInError, private
//
//  Synopsis:   Loop through the passed in properties andmark those in error.
//              Used by OpenRowset()
//
//  History:    10-31-97        danleg      Created
//
//----------------------------------------------------------------------------

void CDBSession::MarkPropInError
    (
    ULONG       cPropertySets,
    DBPROPSET*  rgPropertySets,
    GUID*       pguidPropSet,
    DBPROP*     pProp
    )
{
    ULONG iSet, iProp;

    Win4Assert( rgPropertySets );

    for(iSet=0; iSet<cPropertySets; iSet++)
    {
        if( (rgPropertySets[iSet].guidPropertySet != *pguidPropSet) ||
            (0 == rgPropertySets[iSet].rgProperties) ||
            (0 == rgPropertySets[iSet].cProperties) )
            continue;

        for(iProp=0; iProp<rgPropertySets[iSet].cProperties; iProp++)
        {
            if( (rgPropertySets[iSet].rgProperties[iProp].dwPropertyID == pProp->dwPropertyID) &&
                (rgPropertySets[iSet].rgProperties[iProp].dwStatus == DBPROPSTATUS_OK) )
            {
                rgPropertySets[iSet].rgProperties[iProp].dwStatus = pProp->dwStatus;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser::CImpersonateSessionUser, public
//
//  Purpose:    ctor
//
//  History:    01-23-99    danleg      Created
//
//----------------------------------------------------------------------------

CImpersonateSessionUser::CImpersonateSessionUser( HANDLE hToken ) :
    _fImpersonated( FALSE ),
    _xSessionToken( INVALID_HANDLE_VALUE ),
    _xPrevToken( INVALID_HANDLE_VALUE )
{
    if ( INVALID_HANDLE_VALUE != hToken )
    {
        HANDLE hTempToken = DupToken( hToken );
        if ( INVALID_HANDLE_VALUE != hTempToken )
            _xSessionToken.Set( hTempToken );

        CachePrevToken();
        Impersonate();
    }
} //CImpersonateSessionUser

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser::~CImpersonateSessionUser, public
//
//  Synopsis:   dtor
//
//  History:    01-23-99    danleg      Created
//
//----------------------------------------------------------------------------

CImpersonateSessionUser::~CImpersonateSessionUser()
{
    TRY
    {
        Revert();
    }
    CATCH( CException, e )
    {
        //
        // Ignore failures in unwind paths -- the query will fail.  If we
        // can't revert here the ole db client has to realize the thread
        // may be in a bad state after a query failure.
        //
    }
    END_CATCH

    BOOL fSuccess = TRUE;
} //~CImpersonateSessionUser

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser::Revert, public
//
//  Synopsis:   Reverts the thread to the original state
//
//  History:    02-11-02    dlee      Created from ~, so we have a form that
//                                    can fail.
//
//----------------------------------------------------------------------------

void CImpersonateSessionUser::Revert()
{
    BOOL fSuccess = TRUE;

    if ( INVALID_HANDLE_VALUE == _xPrevToken.Get() )
    {
        //
        // There is no need to revert to self here if we didn't impersonate
        // in the first place -- if there was no token or there was no
        // session object.  If you revert here then IIS threads become
        // system.
        //

        if ( _fImpersonated )
        {
            fSuccess = RevertToSelf();

            if ( fSuccess )
                _fImpersonated = FALSE;
        }
    }
    else
    {
        fSuccess = ImpersonateLoggedOnUser( _xPrevToken.Get() );

        _xPrevToken.Free();
    }

    if ( !fSuccess )
    {
        DWORD dwError = GetLastError();

        vqDebugOut(( DEB_ERROR, 
                     "CImpersonateSessionUser::Revert: Impersonation failed with error %d\n",
                     dwError ));

        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
} //Revert

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser:: DupToken, private
//
//  Synopsis:   Duplicate the session token for the current thread
//
//  History:    01-23-99    danleg      Created
//
//----------------------------------------------------------------------------

HANDLE CImpersonateSessionUser::DupToken( HANDLE hToken )
{
    SECURITY_QUALITY_OF_SERVICE qos;
    qos.Length              = sizeof( SECURITY_QUALITY_OF_SERVICE  );
    qos.ImpersonationLevel  = SecurityImpersonation;
    qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    qos.EffectiveOnly       = FALSE;

    OBJECT_ATTRIBUTES           ObjAttr;
    InitializeObjectAttributes( &ObjAttr,
                                NULL,
                                0,
                                NULL,
                                NULL );
    ObjAttr.SecurityQualityOfService = &qos;

    HANDLE hNewToken = INVALID_HANDLE_VALUE;
    NTSTATUS status = NtDuplicateToken( hToken,
                                        TOKEN_IMPERSONATE|TOKEN_QUERY,
                                        &ObjAttr,
                                        FALSE,
                                        TokenImpersonation,
                                        &hNewToken );

    if ( !NT_SUCCESS(status) )
    {
        vqDebugOut(( DEB_ERROR,
                     "DupToken failed to duplicate token, %x\n",
                     status ));

        THROW( CException( status ) );
    }

    return hNewToken;
} //DupToken

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser:: CachePrevToken, private
//
//  Synopsis:   If the current thread is already impersonated, cache its
//              impersonation token so it can be restored later.
//
//  History:    01-23-99    danleg      Created
//
//----------------------------------------------------------------------------

void CImpersonateSessionUser::CachePrevToken()
{
    DWORD               dwLength;
    TOKEN_STATISTICS    TokenInformation;
    HANDLE              hToken = INVALID_HANDLE_VALUE;

    NTSTATUS status = NtOpenThreadToken( GetCurrentThread(),
                                         TOKEN_QUERY |
                                           TOKEN_DUPLICATE |
                                           TOKEN_IMPERSONATE,
                                         TRUE,
                                         &hToken);
    if ( NT_SUCCESS(status) )
    {
        SHandle xHandle( hToken );

        // 
        // If this thread is already impersonated, cache its impersonation
        // token and impersonate using the session (i.e. logon) token
        //
        status = NtQueryInformationToken ( hToken,
                                           TokenStatistics,
                                           (LPVOID)&TokenInformation,
                                           sizeof TokenInformation,
                                           &dwLength);

        if ( NT_SUCCESS(status) )
        {
            if ( TokenInformation.TokenType == TokenImpersonation )
            {
                HANDLE hTempToken = DupToken( hToken );

                if ( INVALID_HANDLE_VALUE != hTempToken )
                    _xPrevToken.Set( hTempToken );
            }
        }
        else // NtQueryInformation failed
        {
            vqDebugOut(( DEB_ERROR, 
                         "CImpersonateSessionUser failed to query token information, %x\n",
                         status ));

            THROW( CException( status ) );
        }
    }
    else // NtOpenThreadToken failed
    {
        //
        // If it's STATUS_NO_TOKEN then there isn't anything to capture and we
        // can ignore impersonation for this query.
        //

        if ( STATUS_NO_TOKEN != status )
        {
            vqDebugOut(( DEB_ERROR,
                         "CImpersonateSessionUser failed to open thread token, %x\n",
                         status ));

            THROW( CException( status ) );
        }
    }
} //CachePrevToken

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSessionUser::Impersonate, private
//
//  Synopsis:   Impersonate the user who created the OLE DB session.
//
//  History:    01-23-99    danleg      Created
//
//----------------------------------------------------------------------------

void CImpersonateSessionUser::Impersonate()
{
    if ( INVALID_HANDLE_VALUE == _xSessionToken.Get() )
        return;

    BOOL fSuccess = ImpersonateLoggedOnUser( _xSessionToken.Get() );

    if ( fSuccess )
        _fImpersonated = TRUE;
    else
    {
        DWORD dwError = GetLastError();
        vqDebugOut(( DEB_ERROR, 
                     "CImpersonateSessionUser failed to impersonate, %d\n",
                     dwError ));

        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
} //Impersonate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmcom\enumstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       enumstr.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  History:    3-19-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <enumstr.hxx>



//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::QueryInterface
//
//  Synopsis:   
//
//  Arguments:  [riid]      - 
//              [ppvObject] - 
//
//  Returns:    
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CEnumString::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IEnumString == riid )
        *ppvObject = (void *)((IEnumString *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumString::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumString::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release

//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::Clone
//
//  Synopsis:   Makes a copy of this object.
//
//  Arguments:  [ppEnumStr] - If successful, will have the refcounted pointer
//              to IEnumString interface.
//
//  Returns:    S_OK if successful; Failure code otherwise.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumString::Clone( IEnumString ** ppEnumStr )
{
    SCODE sc = S_OK;

    TRY
    {
        CEnumString * pCopy = new CEnumString( _aStr.Size() );

        for ( unsigned i = 0; i < _cValid; i++ )
            pCopy->Append( _aStr[i] );    

        *ppEnumStr = pCopy;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR, "CEnumString::Clone failed. Error (0x%X)\n", sc ));
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::Next
//
//  Synopsis:   Retrieves the specified number of strings. If there are
//              fewer strings than requested, then the returned number is
//              indicated in the pceltFetched parameter.
//
//  Arguments:  [celt]         - 
//              [rgelt]        - 
//              [pceltFetched] - 
//
//  Returns:    S_OK if fetched celt.
//              S_FALSE otherwise.
//
//  History:    3-19-97   srikants   Created
//
//  Notes:      No copies are being made, but pointers to internal data.
//              Also, this is not OLE memory but if it is read-only memory,
//              it doesn't matter.
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumString::Next( ULONG celt,
                                LPOLESTR * rgelt,
                                ULONG * pceltFetched )
{        
    Win4Assert( _iCurrEnum <= _cValid );

    *pceltFetched = 0;

    while ( (_iCurrEnum < _cValid) && ( (*pceltFetched) < celt ) )
    {
        rgelt[(*pceltFetched)++] = _aStr.Get(_iCurrEnum++);
    }

    ULONG cAdded = *pceltFetched;
    while ( cAdded < celt )
        rgelt[cAdded++] = 0;    // Must fill the remaining with NULLs.    

    return *pceltFetched == celt ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::Skip
//
//  Synopsis:   Skips the requested number of elements.
//
//  Arguments:  [celt] - Number of elements to skip.
//
//  Returns:    S_OK if skipped the specified number; S_FALSE o/w
//
//  History:    3-19-97   srikants   Created
//
//  Notes:      If we cannot skip as many as requested, we don't skip any.
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumString::Skip( ULONG celt )
{
    Win4Assert( _iCurrEnum <= _cValid );

    if ( _iCurrEnum + celt <= _cValid )
    {
        _iCurrEnum += celt;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumString::Append
//
//  Synopsis:   Appends the given string to the collection.
//
//  Arguments:  [pwszString] - 
//
//  History:    3-19-97   srikants   Created
//
//----------------------------------------------------------------------------

void CEnumString::Append( WCHAR const * pwszString )
{
    Win4Assert( 0 != pwszString );
    unsigned cwc = wcslen( pwszString ) + 1;

    XArray<WCHAR>  xwszCopy( cwc );
    RtlCopyMemory( xwszCopy.GetPointer(), pwszString, cwc * sizeof WCHAR );

    _aStr.Add( xwszCopy.GetPointer(), _cValid );
    xwszCopy.Acquire();
    _cValid++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::QueryInterface
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CEnumWorkid::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( RtlEqualMemory( &riid, &IID_IUnknown, sizeof(REFIID)) )
    {
        AddRef();
        *ppvObject = (void *)((IUnknown *)this);
        return S_OK;
    }
    else if ( RtlEqualMemory( &riid, &IID_ICiEnumWorkids, sizeof(REFIID)) )
    {
        AddRef();
        *ppvObject = (void *)((ICiEnumWorkids *)this);
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumWorkid::AddRef()
{
    InterlockedIncrement(&_refCount);

    return (ULONG) _refCount;
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumWorkid::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;

}  //Release


//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::Next
//
//  Synopsis:   Retrieves the specified number of workids. If there are
//              fewer workids than requested, then the returned number is
//              indicated in the pceltFetched parameter.
//
//  Arguments:  [celt]         -  Number of elements requested
//              [rgelt]        -  Array to fill the workids in
//              [pceltFetched] -  Number fetched.
//
//  Returns:    S_OK if fetched celt.
//              S_FALSE otherwise.
//
//  History:    3-19-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumWorkid::Next( ULONG celt,
                                WORKID * rgelt,
                                ULONG * pceltFetched )
{        
    Win4Assert( _iCurrEnum <= _cValid );

    *pceltFetched = 0;

    while ( (_iCurrEnum < _cValid) && ( (*pceltFetched) < celt ) )
    {
        rgelt[(*pceltFetched)++] = _aWorkids.Get(_iCurrEnum++);
    }

    ULONG cAdded = *pceltFetched;
    while ( cAdded < celt )
        rgelt[cAdded++] = 0;    // Must fill the remaining with NULLs.    

    return *pceltFetched == celt ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::Skip
//
//  Synopsis:   Skips the requested number of elements.
//
//  Arguments:  [celt] - Number of elements to skip.
//
//  Returns:    S_OK if skipped the specified number; S_FALSE o/w
//
//  History:    3-19-97   srikants   Created
//
//  Notes:      If we cannot skip as many as requested, we don't skip any.
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumWorkid::Skip( ULONG celt )
{
    Win4Assert( _iCurrEnum <= _cValid );

    if ( _iCurrEnum + celt <= _cValid )
    {
        _iCurrEnum += celt;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumWorkid::Append
//
//  Synopsis:   Appends the given string to the collection.
//
//  Arguments:  [wid] - Appends the given workid to the collection.
//
//  History:    3-19-97   srikants   Created
//
//----------------------------------------------------------------------------

void CEnumWorkid::Append( WORKID wid )
{
    _aWorkids.Add( wid, _cValid );
    _cValid++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmcom\fwevent.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       fwevent.cxx
//
//  Contents:   CFwEventItem Class
//
//  History:    02-Jan-97   mohamedn    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciintf.h>
#include <fwevent.hxx>


//+-------------------------------------------------------------------------
//
//  Method:     CFwEventItem::CFwEventItem
//
//  Purpose:    Encapsulates all information pertaining to a given event
//              and invokes ICiCAdviseStatus::NotifyEvent method.
//
//  Arguments:  [fType  ] - Type of event
//              [eventId] - Message file event identifier
//              [cArgs]   - Number of substitution arguments being passed
//              [cbData ] - number of bytes in supplemental raw data.
//              [data   ] - pointer to block of supplemental data.
//
//  History:    02-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------

CFwEventItem::CFwEventItem( WORD   fType,
                            DWORD  eventId,
                            WORD   cArgs,
                            DWORD  dataSize, 
                            void * data  ) :
                            _fType(fType),
                            _eventId(eventId),
                            _nParams(cArgs),
                            _nParamsUsed(0),
                            _dataSize(dataSize), 
                            _data(data)
{
    _pPv = new PROPVARIANT[_nParams];

    memset(_pPv, 0, sizeof(PROPVARIANT) * _nParams);

    END_CONSTRUCTION(CFwEventItem);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFwEventItem::~CFwEventItem
//
//  Purpose:    destructor, deallocates any allocated memory.
//
//  History:    02-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------
CFwEventItem::~CFwEventItem()
{

    for ( WORD i = 0; i < _nParamsUsed; i++ )
    {
        switch (_pPv[i].vt)
        {
            case VT_LPSTR:
                            delete _pPv[i].pszVal;
                            
                            _pPv[i].pszVal = 0;
                            
                            break;
                            
            case VT_LPWSTR:
                            delete _pPv[i].pwszVal;
                            
                            _pPv[i].pwszVal = 0;
                            
                            break;
                            
            case VT_UI4:
                            break;
                           
            default:        // should never be hit
                            Win4Assert( !"~CFwEventItem, default case should never be hit"); 
        }
        
    } 
    
    // delete the PROPVARIANT array we allocated.
    delete [] _pPv;
    
    _pPv    = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFwEventItem::AddArg
//
//  Synopsis:   Adds wcsString to embed in the eventlog message.
//
//  Arguments:  [wcsString] - wide char string to be added
//
//  History:    02-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------
void CFwEventItem::AddArg( const WCHAR * wcsString )
{
     Win4Assert( _nParamsUsed < _nParams );
     Win4Assert( 0 != wcsString );

     _pPv[_nParamsUsed].vt = VT_LPWSTR;

     ULONG cc = wcslen(wcsString) + 1;

     _pPv[_nParamsUsed].pwszVal = new WCHAR [cc];

     RtlCopyMemory( _pPv[_nParamsUsed].pwszVal, wcsString, cc * sizeof(WCHAR) ); 	

     _nParamsUsed++;
}

//+-------------------------------------------------------------------------
//
//  Member:      CFwEventItem::AddArg
//
//  Synopsis:    adds pszString to embed in the eventlog message.
//
//  Arguments:  [pszString] - null terminated ASCII string to be added
//
//  History:     02-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------
void CFwEventItem::AddArg( const CHAR * pszString )
{
    Win4Assert( _nParamsUsed < _nParams );
    Win4Assert( 0 != pszString );

    _pPv[_nParamsUsed].vt = VT_LPSTR;
 
    ULONG cc = strlen(pszString) + 1;  
    
    _pPv[_nParamsUsed].pszVal = new CHAR [cc];

    RtlCopyMemory( _pPv[_nParamsUsed].pszVal, pszString, cc * sizeof(CHAR) );
    
    _nParamsUsed++;

}

//+-------------------------------------------------------------------------
//
//  Member:     CFwEventItem::AddArg
//
//  Synopsis:   adds ulValue to embed in the eventlog message.
//
//  Arguments:  [ulValue] - unsigned long value to be added.
//
//  History:    02-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------
void CFwEventItem::AddArg( const ULONG ulValue )
{
      Win4Assert( _nParamsUsed < _nParams );

      _pPv[_nParamsUsed].vt    = VT_UI4;

      _pPv[_nParamsUsed].ulVal = ulValue;

      _nParamsUsed++;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFwEventItem::ReportEvent
//
//  Synopsis:   Invokes ICiCAdviseStatus::NotifyEvent method.            
//
//  Arguments:  [adviseStatus] - reference to ICiCAdviseStatus
//
//  History:    02-Jan-96   mohamedn    Created
//
//--------------------------------------------------------------------------
void CFwEventItem::ReportEvent(ICiCAdviseStatus & adviseStatus) 
{

   Win4Assert( _nParamsUsed == _nParams );

   SCODE sc = 0;

   sc = adviseStatus.NotifyEvent(   _fType,
                                    _eventId,
                                    _nParams,
                                    _pPv,
                                    _dataSize,
                                    _data);
                              
    if (sc != S_OK)
    {
        // Don't throw an exception here...
        
        ciDebugOut(( DEB_ERROR, "adviseStatus.Notify() error: 0x%X\n",
                     sc ));

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmcom\workman.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       workman.cxx
//
//  Contents:   Manages a queue of work items and supports aborting during
//              shutdown.
//
//  History:    12-23-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <workman.hxx>

CWorkManager::~CWorkManager()
{
    AbortWorkItems();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkManager::RemoveFromWorkList
//
//  Synopsis:   Removes the given work item from the worklist.
//
//  Arguments:  [pItem] -  Item to be removed from the work list.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CWorkManager::RemoveFromWorkList( CFwAsyncWorkItem * pItem )
{
    Win4Assert( 0 != pItem );
    CLock   lock(_mutex);

    //
    // If the item has already been removed from the list
    // (by an abort thread), don't remove it here.
    //
    if ( !pItem->IsSingle() )
    {
        _workList.RemoveFromList( pItem );
        pItem->Close();
        pItem->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkManager::AddToWorkList
//
//  Synopsis:   Adds the given work item to the work list.
//
//  Arguments:  [pItem] - Item to be added to the work list.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:      It is up to the caller to get the work item scheduled.
//
//----------------------------------------------------------------------------

void CWorkManager::AddToWorkList( CFwAsyncWorkItem * pItem )
{
    Win4Assert( 0 != pItem );

    CLock   lock(_mutex);

    if ( _fShutdown )
    {
        ciDebugOut(( DEB_ITRACE, "AddToWorkList - Shutdown Initiated\n" ));
        pItem->Close();
        pItem->Abort();
    }
    else
    {
        pItem->AddRef();
        _workList.Push( pItem );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWorkManager::AbortWorkItems
//
//  Synopsis:   Aborts async workitems in the work list.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CWorkManager::AbortWorkItems()
{
    // ====================================================
    CLock   lock(_mutex);

    _fShutdown = TRUE;

    for ( CFwAsyncWorkItem * pItem = _workList.RemoveLast();
          0 != pItem;
          pItem = _workList.RemoveLast() )
    {
        pItem->Close();
        pItem->Abort();
        pItem->Release();
    }
    // ====================================================
}

//+---------------------------------------------------------------------------
//
//  Member:      ~ctor of CFwAsyncWorkItem
//
//  Synopsis:   Initializes the double link element and refcounts the
//              CCiManager.
//
//  Arguments:  [ciManager] - 
//
//  History:    2-27-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CFwAsyncWorkItem::CFwAsyncWorkItem( CWorkManager & workMan,
                                    CWorkQueue & workQueue ) :
    PWorkItem( esigFwAsyncWorkItem ),
    _workMan(workMan),
    _workQueue(workQueue),
    _refCount(1),
    _fAbort(FALSE),
    _fOnWorkQueue(FALSE)
{
    CDoubleLink::Close();
    _workMan.AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFwAsyncWorkItem::~CFwAsyncWorkItem
//
//  Synopsis:   Releases the ciManager.
//
//  History:    2-27-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CFwAsyncWorkItem::~CFwAsyncWorkItem()
{
    _workMan.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFwAsyncWorkItem::Done
//
//  Synopsis:   Removes from the ciManager list of workitems. This is called
//              at the end of the "DoIt()" method.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CFwAsyncWorkItem::Done()
{
    Win4Assert( _refCount > 0 );
    Win4Assert( !_fOnWorkQueue );

    _workMan.RemoveFromWorkList( this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFwAsyncWorkItem::AddToWorkQueue
//
//  Synopsis:   Adds the item to the work queue.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CFwAsyncWorkItem::AddToWorkQueue()
{

    CLock   lock(_mutex);
    Win4Assert( !_fOnWorkQueue );

    if ( !_fAbort )
    {
        Win4Assert( !IsSingle() );  // it must be on the ciManager list
        _fOnWorkQueue = TRUE;
        _workQueue.Add( this );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFwAsyncWorkItem::Abort
//
//  Synopsis:   Aborts the work item. Removes it from the work queue if
//              necessary.
//
//  History:    2-26-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CFwAsyncWorkItem::Abort()
{
    //
    // It must be removed from the ciManager list before calling
    // abort.
    //

    CLock   lock(_mutex);

    Win4Assert( IsSingle() );
    _fAbort = TRUE;

    if ( _fOnWorkQueue )
    {
        _fOnWorkQueue = FALSE;
        _workQueue.Remove(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmcom\rptcrpt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       rptcrpt.cxx
//
//  Contents:   CFwCorruptionEvent Class
//
//  History:    14-Jan-97   mohamedn    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cievtmsg.h>   
#include <alocdbg.hxx>
#include <rptcrpt.hxx>
#include <fwevent.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CFwCorruptionEvent::CFwCorruptionEvent 
//
//  Purpose:    encapsulates packaging an eventlog item and a stack trace
//              to be posted in the eventlog via CDmFwEventItem class.
//
//  Arguments:  [pwszVolumeName] - Volume name from pStorage->GetVolumeName()
//              [pwszComponent]  - string to be displayed in eventlog
//              [adviseStatus ]  - a reference to ICiCAdviseStatus interface
//
//  History:    14-Jan-97   MohamedN    Created
//
//--------------------------------------------------------------------------

CFwCorruptionEvent::CFwCorruptionEvent( WCHAR const       *   pwszVolumeName,
                                        WCHAR const       *   pwszComponent,
                                        ICiCAdviseStatus  &   adviseStatus  )
{
                     
    TRY
    {
                     
        CDmFwEventItem    item(   EVENTLOG_INFORMATION_TYPE,
                                  MSG_CI_CORRUPT_INDEX_COMPONENT,                                
                                  3 );
                                
        item.AddArg ( pwszComponent );
        item.AddArg ( pwszVolumeName);
    
        char szStackTrace[4096];
    
        GetStackTrace( szStackTrace,sizeof(szStackTrace));

        item.AddArg( szStackTrace );
    
        item.ReportEvent(adviseStatus);
    }
    CATCH ( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in ReportCorruption::ReportCorruption(3)\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmcom\frmutils.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       frmutils.cxx
//
//  Contents:   Utility classes and functions for the frame work and
//              client code.
//
//  History:    12-09-96   srikants   Created
//              20-Nov-98  KLam       Removed CDiskFreeStatus::GetDiskSpace
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


#include <frmutils.hxx>
#include <sstream.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDiskFreeStatus::UpdateDiskLowInfo
//
//  Synopsis:   Updates disk low state information by checking the
//              disk free space situation.
//
//  History:    12-09-96   srikants   Created
//              20-Nov-98  KLam       Call disk info GetDiskSpace
//
//----------------------------------------------------------------------------

void CDiskFreeStatus::UpdateDiskLowInfo()
{
    __int64 diskTotal, diskRemaining;

    _driveInfo.GetDiskSpace( diskTotal, diskRemaining );
    BOOL fLowOnDisk = FALSE;

    if ( !_fIsLow )
    {
        fLowOnDisk = diskRemaining < lowDiskWaterMark;
    }
    else
    {
       fLowOnDisk = diskRemaining < highDiskWaterMark;
    }

    //
    // It is okay to read it without mutex as it is only a heuristic.
    //
    if ( fLowOnDisk && !_fIsLow )
    {
        ciDebugOut(( DEB_WARN, "****YOU ARE RUNNING LOW ON DISK SPACE****\n"));
        ciDebugOut(( DEB_WARN, "****PLEASE FREE UP SOME SPACE        ****\n"));
    }
    else if ( _fIsLow && !fLowOnDisk )
    {
        ciDebugOut(( DEB_WARN, "****DISK SPACE FREED UP              ****\n"));
    }

    _fIsLow = fLowOnDisk;

}

//+---------------------------------------------------------------------------
//
//  Function:   AllocHeapAndCopy
//
//  Synopsis:   Allocates memory from heap and copies the source string into
//              the destination buffer. The destination buffer ownership
//              is given to the caller.
//
//  Arguments:  [pSrc] - [in]  source string.
//              [cc]   - [out] Number of characters in the string, excluding the
//              terminating NULL.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * AllocHeapAndCopy( WCHAR const * pSrc, ULONG & cc )
{
    WCHAR * pDst = 0;

    if ( 0 != pSrc )
    {
        cc = wcslen( pSrc );
        pDst = new WCHAR [cc+1];
        RtlCopyMemory( pDst, pSrc, (cc+1)*sizeof(WCHAR) );
    }
    else
    {
        cc = 0;
    }

    return pDst;
}

//+---------------------------------------------------------------------------
//
//  Function:   PutWString
//
//  Synopsis:   Serializes the given WCHAR string into the serializer.
//
//  Arguments:  [stm]     - Serializer
//              [pwszStr] - String to serialize.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

void PutWString( PSerStream & stm, WCHAR const * pwszStr )
{
    ULONG cwc = (0 != pwszStr) ? wcslen( pwszStr ) : 0;

    stm.PutULong( cwc );
    if (cwc)
        stm.PutWChar( pwszStr, cwc );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocHeapAndGetWString
//
//  Synopsis:   DeSerizlizes a WCHAR string from the deserializer, allocates
//              memory and copies the string into it.
//
//  Arguments:  [stm] - DeSerializer Stream
//
//  Returns:    NULL if there was no string
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * AllocHeapAndGetWString( PDeSerStream & stm )
{
    ULONG cwc = stm.GetULong();

    // Guard against attack

    if ( 0 == cwc || cwc > 65536 )
    {
        return 0;
    }

    WCHAR * pwszStr = new WCHAR [cwc+1];

    stm.GetWChar( pwszStr, cwc );
    pwszStr[cwc] = L'\0';

    return pwszStr;
}

//+---------------------------------------------------------------------------
//
//  Function :  CFwPerfTime::CFwPerfTime
//
//  Purpose :   Constructor
//
//  Arguments : [SizeDivisor]    -- Raw (byte) size divided by this.
//              [TimeMultiplier] -- Raw (millisecond) time multiplied by this.
//
//  History :   23-Mar-94     t-joshh     Created
//              31-Jan-95     KyleP       Added unit adjustment
//              06-Jan-97     Srikants    Adapted to framework
//
//----------------------------------------------------------------------------
CFwPerfTime::CFwPerfTime ( ICiCAdviseStatus * pAdviseStatus,
                           CI_PERF_COUNTER_NAME name,
                           int SizeDivisor, int TimeMultiplier )
        : _llSizeDivisor( SizeDivisor ),
          _llTimeMultiplier( TimeMultiplier ),
          _counterVal(0),
          _name(name),
          _pAdviseStatus(pAdviseStatus)
{
   _liStartTime.QuadPart = 0;

   Win4Assert( _llSizeDivisor > 0 );
   Win4Assert( _llTimeMultiplier > 0 );
}

//+---------------------------------------------------------------------------
//
//  Function :  CFwPerfTime::TStart
//
//  Purpose :   Start counting the time
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------
void CFwPerfTime::TStart ()
{
   _liStartTime.LowPart = GetTickCount();
}

//+---------------------------------------------------------------------------
//
//  Function :  CFwPerfTime::TStop
//
//  Purpose :   Stop counting the time and evaluate the result
//
//  Arguments : [dwValue]
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------
void CFwPerfTime::TStop( DWORD dwValue )
{
    LARGE_INTEGER liStop;
    liStop.LowPart = GetTickCount();

    ULONG ulDiff = liStop.LowPart - _liStartTime.LowPart;


    LARGE_INTEGER liVal;

    //
    // If the time difference is negative, then use the value from
    // the perfmon data.
    //
    if ( ulDiff <= 0 )
    {
        SCODE sc = _pAdviseStatus->GetPerfCounterValue( _name, &_counterVal );
        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_ERROR, "GetPerfCounterValue failed (0x%X)\n",
                         sc ));
            return;
        }
    }

    if ( dwValue > 0 )
    {
        if ( ulDiff > 0 )
            liVal.QuadPart = dwValue / ulDiff;
        else
            liVal.QuadPart = _counterVal * _llSizeDivisor / _llTimeMultiplier;
    }
    else
    {
        if ( ulDiff > 0 )
            liVal.QuadPart = ulDiff;
        else
            liVal.QuadPart = _counterVal * _llSizeDivisor / _llTimeMultiplier;
    }

    liVal.QuadPart = liVal.QuadPart * _llTimeMultiplier / _llSizeDivisor;

    Win4Assert( liVal.HighPart == 0 );

    _counterVal = liVal.LowPart;
    SCODE sc = _pAdviseStatus->SetPerfCounterValue( _name, _counterVal ); 

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "SetPerfCounterValue failed (0x%X)\n",
                     sc ));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\cifrmres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       cifrmres.h
//
//--------------------------------------------------------------------------

#if !defined( __CIFRMRES_H__ )
#define __CIFRMRES_H__

#define MSG_CLASS_BINARY_FILE        500
#define MSG_CLASS_ASCII_FILE         501
#define MSG_CLASS_BAT_FILE           502
#define MSG_CLASS_CMD_FILE           503
#define MSG_CLASS_IDQ_FILE           504
#define MSG_CLASS_INI_FILE           505
#define MSG_CLASS_INX_FILE           506
#define MSG_CLASS_REG_FILE           507
#define MSG_CLASS_INF_FILE           508
#define MSG_CLASS_VBS_FILE           509

#endif // __CIFRMRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\cifwexp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cifwexp.cxx
//
//  Contents:   Additional exports from this dll.
//
//  History:    2-26-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cifwexp.hxx>
#include "fatquery.hxx"
#include <tfilt.hxx>
#include <defbreak.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   MakeGenericQueryForDocStore
//
//  Synopsis:   Creates an internal query for in-process binding to an ICommand
//
//  Arguments:  [pDbProperties] - Pointer to the properties to be used.
//              [pDocStore]     - Pointer to the doc store to query
//              [ppQuery]       - [out] Pointer to the query object.
//
//  History:    4-22-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

SCODE MakeGenericQueryForDocStore( IDBProperties * pDbProperties,
                                   ICiCDocStore * pDocStore,
                                   PIInternalQuery ** ppQuery )
{
    if ( 0 == pDbProperties || 0 == ppQuery )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    TRY
    {
        *ppQuery = new CGenericQuery( pDbProperties, pDocStore );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR,
                     "Catastrophic error 0x%x in MakeGenericQueryForDocStore\n",
                     e.GetErrorCode() ));
        *ppQuery = 0;
        sc = GetOleError( e );
    }
    END_CATCH;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\fatquery.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       FATQuery.cxx
//
//  Contents:   IInternalQuery interface
//
//  History:    18-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fatquery.hxx>
#include <pidmap.hxx>
#include <coldesc.hxx>
#include <lang.hxx>
#include <qparse.hxx>
#include <cci.hxx>
#include <rowset.hxx>
#include <query.hxx>
#include <seqquery.hxx>
#include <qoptimiz.hxx>
#include <cifailte.hxx>

#include <dbprputl.hxx>
#include <dbprpini.hxx>
#include <ciframe.hxx>
#include <pidcvt.hxx>
#include <proprst.hxx>

static const GUID guidQuery = PSGUID_QUERY;

extern CLocateDocStore g_DocStoreLocator;

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  Returns:    Error.  No rebind from this class is supported.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenericQuery::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if ( IID_IUnknown == ifid )
    {
        *ppiuk = (void *)((IUnknown *)this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenericQuery::AddRef(void)
{
    return InterlockedIncrement( (long *)&_ref );
}

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenericQuery::Release(void)
{
    long l = InterlockedDecrement( (long *)&_ref );
    if ( l <= 0 )
    {
        // delete self

        vqDebugOut(( DEB_ITRACE,
                     "FAT IInternalQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
}


//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::Execute, public
//
//  Synopsis:   Executes a query.  Helper for ICommand::Execute.
//
//  Arguments:  [pUnkOuter]    -- Outer unknown
//              [pRestriction] -- Query restriction
//              [pidmap]       -- pid mapper for output, sort, category columns
//              [rColumns]     -- Output columns in IRowset
//              [rSort]        -- Initial sort
//              [xProps]       -- Rowset properties (query flags)
//              [rCateg]       -- Categorization specification
//              [cRowsets]     -- # of rowsets
//              [ppUnknowns]   -- IUnknown pointers returned here
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  Returns:    Throws on error
//
//  History:    26 Nov 1995    AlanW     Created
//
//--------------------------------------------------------------------------

void CGenericQuery::Execute( IUnknown *             pUnkOuter,
                             RESTRICTION *          pRestriction,
                             CPidMapperWithNames &  pidmap,
                             CColumnSet &           rColumns,
                             CSortSet &             rSort,
                             XPtr<CMRowsetProps>  & xProps,
                             CCategorizationSet &   rCateg,
                             ULONG                  cRowsets,
                             IUnknown **            ppUnknowns,
                             CAccessorBag &         aAccessors,
                             IUnknown *             pUnkCreator )
{
#if 1
    Win4Assert( FALSE );
#else

    SCODE sc = S_OK;                                
                                                    
    TRY
    {
        if (0 == ppUnknowns)
            THROW( CException( E_INVALIDARG ));

        if ( cRowsets != 1 + (rCateg.Count() ? rCateg.Count() : 0) )
            THROW( CException( E_INVALIDARG ));

        if (_QueryUnknown.IsQueryActive())
        {
            vqDebugOut(( DEB_ERROR,
                         "CGenericQuery: Query already active.\n" ));

            // pec variance: only if query changed

            THROW( CException( DB_E_OBJECTOPEN ));
        }

        //
        // Parameter checking.
        //

        *ppUnknowns = 0;           // in case of error or exception

        //
        // Convert parsed query into low-level query understood by
        // the Query/CI engine.  This process expands the query tree and
        // also maps GUID\DISPID and GUID\NAME style property names to
        // a ULONG pid.
        //

        //
        // Duplicate the output column set.
        //

        XColumnSet ColDup( new CColumnSet ( rColumns.Count() ) );

        for ( unsigned i = 0; i < rColumns.Count(); i++ )
        {
            ColDup->Add( rColumns.Get(i), i );
        }

        //
        // get a pointer to CLangList
        //

        CLangList           * pLangList = 0;
        ICiManager          * pICiManager = 0;
        ICiFrameworkQuery   * pICiFrameworkQuery = 0;

        XInterface<ICiManager>          xICiManager;
        XInterface<ICiFrameworkQuery>   xICiFrameworkQuery;

        SCODE sc = _xDocStore->GetContentIndex(&pICiManager);
        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }
        else
        {
            xICiManager.Set(pICiManager);
        }

        sc = xICiManager->QueryInterface(IID_ICiFrameworkQuery,(void **)&pICiFrameworkQuery);
        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }
        else
        {
            xICiFrameworkQuery.Set(pICiFrameworkQuery);
        }

        sc = xICiFrameworkQuery->GetLangList( (void **) &pLangList);
        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        //
        // end of getting a pointer to the langlist
        //

        //
        // Set up a property mapper.  Used for restriction parsing and sort/output
        // column translation.
        //

        XInterface<IPropertyMapper> xPropMapper;

        sc = _xDocStore->GetPropertyMapper( xPropMapper.GetPPointer() );

        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR, "CGenericQuery::Execute, GetPropertyMapper error 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        //
        // Adjust pidmap to translate properties.  NOTE: Undone in CATCH for failure case.
        //

        CPidConverter PidConverter( xPropMapper.GetPointer() );

        pidmap.SetPidConverter( &PidConverter );

        XRestriction rstParsed;
        DWORD dwQueryStatus = 0;
        if ( pRestriction )
        {
            CQParse    qparse( pidmap, *pLangList );    // Maps name to pid

            rstParsed.Set( qparse.Parse( (CRestriction *)pRestriction ) );

            DWORD dwParseStatus = qparse.GetStatus();

            if ( ( 0 != ( dwParseStatus & CI_NOISE_PHRASE ) ) &&
                 ( ((CRestriction *)pRestriction)->Type() != RTVector ) )
            {
                vqDebugOut(( DEB_WARN, "Query contains phrase composed "
                                        "entirely of noise words.\n" ));
                THROW( CException( QUERY_E_ALLNOISE ) );
            }

            const DWORD dwCiNoise = CI_NOISE_IN_PHRASE | CI_NOISE_PHRASE;
            if ( 0 != ( dwCiNoise & dwParseStatus ) )
                dwQueryStatus |= STAT_NOISE_WORDS;
        }

        //
        //  Duplicate the sort definition.
        //

        XSortSet SortDup;

        // Only create a sort duplicate if we have a sort spec AND it
        // actually contains anything.

        if ( 0 != rSort.Count() )
        {
            SortDup.Set( new CSortSet ( rSort.Count() ) );
            for ( unsigned i = 0; i < rSort.Count(); i++ )
            {
                SortDup->Add( rSort.Get(i), i );
            }
        }

        //
        // Duplicate the categorization specification
        //

        XCategorizationSet CategDup;

        if (cRowsets > 1)
            CategDup.Set( new CCategorizationSet ( rCateg ) );

        //
        // Re-map property ids.
        //

        //
        // TODO: Get rid of this whole pid remap thing.  We should
        //       really be able to do it earlier now that the pidmap
        //       can be set up to convert fake to real pids.
        //

        XInterface<CPidRemapper> pidremap( new CPidRemapper( pidmap,
                                                             xPropMapper,
                                                             0, // rstParsed.GetPointer(),
                                                             ColDup.GetPointer(),

                                                             SortDup.GetPointer() ) );

        //
        //  WorkID may be added to the columns requested in SetBindings.
        //  Be sure it's in the pidremap from the beginning.
        //
        CFullPropSpec psWorkId(guidQuery, DISPID_QUERY_WORKID);
        pidremap->NameToReal( &psWorkId );

        XInterface<PQuery> xQuery;
        XArray<ULONG> aCursors(cRowsets);

        ICiQueryPropertyMapper *pQueryPropMapper;
        sc = pidremap->QueryInterface( IID_ICiQueryPropertyMapper,
                                       (void **) &pQueryPropMapper );
        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR, "DoCreateQuery - QI for property mapper failed 0x%x\n", sc ));

            THROW ( CException( sc ) ) ;
        }

        XInterface<ICiQueryPropertyMapper> xQueryPropMapper( pQueryPropMapper );

        ICiCQuerySession *pQuerySession;
        SCODE scode = _xDocStore->GetQuerySession( &pQuerySession );

        if ( FAILED(scode) )
        {
            vqDebugOut(( DEB_ERROR, "CGenericQuery::Execute - QI failed 0x%x\n", scode ));

            THROW ( CException( scode ) ) ;
        }

        XInterface<ICiCQuerySession> xQuerySession( pQuerySession );

        //
        // Initialize the query session
        //
        xQuerySession->Init( pidmap.Count(),
                             (FULLPROPSPEC const * const *)pidmap.GetPointer(),
                             _xDbProperties.GetPointer(),
                             xQueryPropMapper.GetPointer() );


        //
        // Optimize query.
        //

        CRowsetProperties Props;
        Props.SetDefaults( xProps->GetPropertyFlags(),
                           xProps->GetMaxOpenRows(),
                           xProps->GetMemoryUsage(),
                           xProps->GetMaxResults(),
                           xProps->GetCommandTimeout() );

        XQueryOptimizer xqopt( new CQueryOptimizer( xQuerySession,
                                                    _xDocStore.GetPointer(),
                                                    rstParsed,
                                                    ColDup.GetReference(),
                                                    SortDup.GetPointer(),
                                                    pidremap.GetReference(),
                                                    Props,
                                                    dwQueryStatus ) );

        vqDebugOut(( DEB_ITRACE, "Query has %s1 component%s\n",
                     xqopt->IsMultiCursor() ? "> " : "",
                     xqopt->IsMultiCursor() ? "(s)" : "" ));
        vqDebugOut(( DEB_ITRACE, "Current component of query %s fully sorted\n",
                     xqopt->IsFullySorted() ? "is" : "is not" ));
        vqDebugOut(( DEB_ITRACE, "Current component of query %s positionable\n",
                     xqopt->IsPositionable() ? "is" : "is not" ));

        if ( (xProps->GetPropertyFlags() & eLocatable) == 0 )
        {
            //
            // If all components are fully sorted, then
            // it doesn't matter how many there are.  A
            // merge could be done.  But be careful, you
            // need an ordering even with a null sort.
            //
            // Categorized queries must go through bigtable for now
            // If someday we support categorizations that don't require
            // sorting then change this check.
            //
            if ( ( !xqopt->IsMultiCursor() ) &&
                 ( xqopt->IsFullySorted() )  &&
                 ( 1 == cRowsets  ) )
            {
                xQuery.Set( new CSeqQuery( xqopt,
                                           ColDup,
                                           aCursors.GetPointer(),
                                           pidremap,
                                           _xDocStore.GetPointer() ) );
            }
            else
            {
                xQuery.Set( new CAsyncQuery( xqopt,
                                             ColDup,
                                             SortDup,
                                             CategDup,
                                             cRowsets,
                                             aCursors.GetPointer(),
                                             pidremap,
                                             FALSE,
                                             _xDocStore.GetPointer(),
                                             0 ) );
            }
        }
        else
        {
            xQuery.Set( new CAsyncQuery( xqopt,
                                         ColDup,
                                         SortDup,
                                         CategDup,
                                         cRowsets,
                                         aCursors.GetPointer(),
                                         pidremap,
                                         (xProps->GetPropertyFlags() & eWatchable) != 0,
                                         _xDocStore.GetPointer(),
                                         0 ) );
        }

        //
        //  If we've been instructed to create a non-asynchronous cursor,
        //  then we don't return to the caller until we have the first
        //  row.  In the case of a sorted sequential cursor (which is
        //  implemented with a table), we wait until the query is
        //  complete.
        //

        if ( (xProps->GetPropertyFlags() & eAsynchronous) == 0 )
        {
            //
            // An event would be better than these Sleeps...
            //

            ULONG sleepTime = 500;

            while ( TRUE )
            {
                DBCOUNTITEM ulDenominator;
                DBCOUNTITEM ulNumerator;
                DBCOUNTITEM cRows;
                BOOL  fNewRows;
                xQuery->RatioFinished( 0,
                                       ulDenominator,
                                       ulNumerator,
                                       cRows,
                                       fNewRows );

                if ( ulNumerator == ulDenominator )
                    break;

                Sleep( sleepTime );

                sleepTime *= 2;
                sleepTime  = min( sleepTime, 4000 );
            }
        }

        // Make rowsets for each level in the hierarchy (usually 1).
        // Rowset 0 is the top of the hierarchy.

        _QueryUnknown.ReInit();
        CRowsetArray apRowsets( cRowsets );
        XArray<IUnknown *> xapUnknowns( cRowsets );

        CMRowsetProps & OrigProps = xProps.GetReference();

#ifdef CI_FAILTEST
        NTSTATUS failStatus = CI_CORRUPT_CATALOG;
        ciFAILTEST( failStatus );
#endif // CI_FAILTEST

        for (unsigned r = 0; r < cRowsets; r++)
        {
            XPtr<CMRowsetProps> xTmp;
  
            if ( 0 != r )
            {
                xTmp.Set( new CMRowsetProps( OrigProps ) );
                xTmp->SetChaptered( TRUE );
            }

        if ( 1 != cRowsets && 0 == r )
            xProps->SetChaptered( FALSE );
    
            apRowsets[r] = new CRowset(   pUnkOuter,
                                          &xapUnknowns[r],
                                          (r == (cRowsets - 1)) ?
                                            rColumns :
                                            rCateg.Get(r)->GetColumnSet(),
                                          pidmap,
                                          xQuery.GetReference(),
                                          (IUnknown &) _QueryUnknown,
                                          0 != r,
                                          ( 0 == r ) ? xProps : xTmp,
                                          aCursors[r],
                                          aAccessors,
                                          pUnkCreator );
        }

        for (r = 0; r < cRowsets; r++)
        {
            if (r < cRowsets-1)
                apRowsets[r]->SetRelatedRowset( apRowsets[r+1] );
            ppUnknowns[r] = (IRowset *) xapUnknowns[r];
        }

        // xQuery goes out of scope, doing a Release() on it.
        // Each rowset above has done an AddRef() on it and they own it.

        _QueryUnknown.ReInit( cRowsets, apRowsets.Acquire() );
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%X while executing query\n",
                     e.GetErrorCode() ));

        pidmap.SetPidConverter( 0 );

        ICiManager *pCiManager = 0;
        sc = _xDocStore->GetContentIndex( &pCiManager );
        if ( SUCCEEDED( sc ) )
        {
            //
            // GetContentIndex may fail during shutdown
            //
            ICiFrameworkQuery * pIFwQuery = 0;

            sc = pCiManager->QueryInterface( IID_ICiFrameworkQuery,
                                             (void **) &pIFwQuery );
            pCiManager->Release();
            if ( pIFwQuery )
            {
                pIFwQuery->ProcessError( e.GetErrorCode() );
                pIFwQuery->Release();
            }
        }

        RETHROW();
    }
    END_CATCH

    pidmap.SetPidConverter( 0 );
#endif
} //Execute

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::CGenericQuery, public
//
//  Synopsis:   Opens file system directory for query
//
//  Arguments:  [pDbProperties] -- Properties to be used for this query
//
//  History:    18-Jun-93 KyleP     Created
//              22-Apr-97 KrishnaN  Changed header block
//
//--------------------------------------------------------------------------

CGenericQuery::CGenericQuery( IDBProperties * pDbProperties )
        : PIInternalQuery( 0 ),
#pragma warning(disable : 4355) // 'this' in a constructor
          _QueryUnknown( * ((IUnknown *) this) )
#pragma warning(default : 4355) // 'this' in a constructor
{
    pDbProperties->AddRef();
    _xDbProperties.Set( pDbProperties );

    //
    // Locate the DocStore for the given set of properties.
    //
    ICiCDocStoreLocator * pLocator = g_DocStoreLocator.Get();

    if ( 0 == pLocator )
    {
        //
        // Determine the GUID of the docstore locator from the query and
        // use it.
        //
        CGetDbProps dbProps;
        dbProps.GetProperties( pDbProperties,
                               CGetDbProps::eClientGuid );

        GUID const * pGuidClient = dbProps.GetClientGuid();
        if ( 0 == pGuidClient )
        {
            ciDebugOut(( DEB_ERROR, "The DocStoreLocator Guid is invalid\n" ));
            THROW( CException( E_INVALIDARG ) );
        }

        pLocator = g_DocStoreLocator.Get( *pGuidClient );
    }

    Win4Assert( pLocator != 0 );

    XInterface<ICiCDocStoreLocator> xLocator( pLocator );

    ICiCDocStore *pDocStore;
    SCODE sc = xLocator->LookUpDocStore( pDbProperties, &pDocStore, TRUE );
    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ITRACE, "Failed to locate doc store. Error (0x%X)\n",
                     sc ));
        THROW( CException(sc) );
    }

    Win4Assert( pDocStore != 0 );
    _xDocStore.Set( pDocStore );

    AddRef();
} //CGenericQuery

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::CGenericQuery, public
//
//  Synopsis:   Opens file system directory for query
//
//  Arguments:  [pDbProperties] -- Properties to be used for this query
//              [pDocStore]     -- Docstore to query against
//
//  History:    22-Apr-97 KrishnaN     Created
//
//--------------------------------------------------------------------------

CGenericQuery::CGenericQuery( IDBProperties * pDbProperties,
                              ICiCDocStore * pDocStore )
        : PIInternalQuery( 0 ),
#pragma warning(disable : 4355) // 'this' in a constructor
          _QueryUnknown( * ((IUnknown *) this) )
#pragma warning(default : 4355) // 'this' in a constructor
{
    pDbProperties->AddRef();
    _xDbProperties.Set( pDbProperties );

    Win4Assert( pDocStore != 0 );
    pDocStore->AddRef();
    _xDocStore.Set( pDocStore );

    AddRef();
} //CGenericQuery

//+-------------------------------------------------------------------------
//
//  Member:     CGenericQuery::~CGenericQuery, public
//
//  Synopsis:   Required virtual destructor
//
//  History:    17-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

CGenericQuery::~CGenericQuery()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\dllreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       dllreg.cxx
//
//  Contents:   Null and Plain Text filter registration
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>
#include <langreg.hxx>
#include <cifrmres.h>
#include <strres.hxx>

StringResource srBinaryFile = { MSG_CLASS_BINARY_FILE };

SClassEntry aTheNullClasses[] =
{
    { L".386",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".AudioCD",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".DeskLink",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".Folder",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".MAPIMail",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ZFSendToTarget",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".aif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".aifc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".aiff",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".aps",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".asf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".asx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".au",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".avi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bin",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bkf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bmp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bsc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cab",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cda",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cgm",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".com",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cpl",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cur",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dbg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dct",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dib",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dl_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dll",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".drv",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dvd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".emf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".eps",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ex_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".exe",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".exp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".eyb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".fnd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".fnt",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".fon",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ghi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".gif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".gz",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".hqx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".icm",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ico",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".idb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ilk",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".imc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".in_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".inv",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ivf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jbf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jfif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jpe",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jpeg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jpg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".latex",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".lib",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".m14",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".m1v",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".m3u",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mdb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mid",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".midi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mmf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mov",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".movie", L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mp2",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mp2v",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mp3",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mpa",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mpe",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mpeg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mpg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mpv2",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".msg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mv",    L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mydocs",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ncb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".obj",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".oc_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ocx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pch",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pdb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pds",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pic",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pma",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pmc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pml",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pmr",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".png",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".psd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".res",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rle",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rmi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rpc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rsp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sbr",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sc2",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sit",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".snd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sr_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sy_",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sym",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sys",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tar",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tgz",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tiff",  L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tlb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tsp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ttc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ttf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".vbx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".vxd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wav",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wax",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wll",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wlt",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wm",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wma",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmv",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmz",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wsz",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wvx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".xbm",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".xix",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".z",     L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".z96",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".zip",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
};

SHandlerEntry const TheNullHandler =
{
    L"{098f2470-bae0-11cd-b579-08002b30bfeb}",
    L"Null persistent handler",
    L"{c3278e90-bea7-11cd-b579-08002b30bfeb}"
};

SFilterEntry const TheNullFilter =
{
    L"{c3278e90-bea7-11cd-b579-08002b30bfeb}",
    L"Null filter",
    L"query.dll",
    L"Both"
};

DEFINE_SOFT_REGISTERFILTER( TheNull,
                            TheNullHandler,
                            TheNullFilter,
                            aTheNullClasses )

StringResource srAsciiFile = { MSG_CLASS_ASCII_FILE };
StringResource srBatFile   = { MSG_CLASS_BAT_FILE };
StringResource srCmdFile   = { MSG_CLASS_CMD_FILE };
StringResource srIdqFile   = { MSG_CLASS_IDQ_FILE };
StringResource srIniFile   = { MSG_CLASS_INI_FILE };
StringResource srInxFile   = { MSG_CLASS_INX_FILE };
StringResource srRegFile   = { MSG_CLASS_REG_FILE };
StringResource srInfFile   = { MSG_CLASS_INF_FILE };
StringResource srVbsFile   = { MSG_CLASS_VBS_FILE };

SClassEntry aPlainTextClasses[] =
{
    // .dic files are marked as txtfiles by Office install

    { L".dic", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".txt", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".wtx", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".bat", L"batfile",   L"MS-DOS Batch File",              L"{89bcb7a5-6119-101a-bcb7-00dd010655af}", L"MS-DOS Batch File" },
    { L".cmd", L"cmdfile",   L"Windows Command Script",         L"{89bcb7a6-6119-101a-bcb7-00dd010655af}", L"Windows Command Script" },
    { L".idq", L"idqfile",   L"Microsoft Query parameter file", L"{961c1130-89ad-11cf-88a1-00aa004b9986}", L"Microsoft Query parameter file" },
    { L".ini", L"inifile",   L"Configuration Settings",         L"{8c9e8e1c-90f0-11d1-ba0f-00a0c906b239}", L"Configuration Settings" },
    { L".inx", L"inxfile",   L"Setup Settings",                 L"{95876eb0-90f0-11d1-ba0f-00a0c906b239}", L"Setup Settings" },
    { L".reg", L"regfile",   L"Registration Entries",           L"{9e704f44-90f0-11d1-ba0f-00a0c906b239}", L"Registration Entries" },
    { L".inf", L"inffile",   L"Setup Information",              L"{9ed4692c-90f0-11d1-ba0f-00a0c906b239}", L"Setup Information" },
    { L".vbs", L"VBSFile",   L"VBScript Script File",           L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"VBScript Script File" },

    // new entries from the Shell group

    { L".asm", L"asmfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".c",   L"cfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".cpp", L"cppfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".cxx", L"cxxfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".def", L"deffile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".h",   L"hfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".hpp", L"hppfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".hxx", L"hxxfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".idl", L"idlfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".inc", L"incfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".js",  L"jsfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".log", L"logfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".pl",  L"plfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".rc",  L"rcfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".rtf", L"rtffile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".url", L"urlfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".xml", L"xmlfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
    { L".xsl", L"xlsfile", L"",     L"{87db1ada-aa39-11d1-829f-00a0c906b239}", L"" },
};

SHandlerEntry const PlainTextHandler =
{
    L"{5e941d80-bf96-11cd-b579-08002b30bfeb}",
    L"Plain Text persistent handler",
    L"{c1243ca0-bf96-11cd-b579-08002b30bfeb}"
};

SFilterEntry const PlainTextFilter =
{
    L"{c1243ca0-bf96-11cd-b579-08002b30bfeb}",
    L"Plain Text filter",
    L"query.dll",
    L"Both"
};

DEFINE_SOFT_REGISTERFILTER( PlainText,
                            PlainTextHandler,
                            PlainTextFilter,
                            aPlainTextClasses )

//
// Extra entries for CI Framework.  They happen to have the same form as the
// filter entries.
//

SLangRegistry const NeutralWordBreaker = {
    L"Neutral",
    0,
    {   L"{369647e0-17b0-11ce-9950-00aa004bbb1f}",
        L"Neutral Word Breaker",
        L"query.dll",
        L"Both" },
    {   0, 0, 0, 0 }
};

SFilterEntry const NullStemmer_CHS =
{
    L"{78fe669a-186e-4108-96e9-77b586c1332f}",
    L"Content Index Null Stemmer",
    L"query.dll",
    L"Both"
};


SFilterEntry const NullStemmer_CHT =
{
    L"{78fe669a-186e-4108-96e9-77b586c1332f}",
    L"Content Index Null Stemmer",
    L"query.dll",
    L"Both"
};

SFilterEntry const FrameworkControl =
{
    L"{1E9685E6-DB6D-11d0-BB63-00C04FC2F410}",
    L"Content Index Framework Control Object",
    L"query.dll",
    L"Both"
};

SFilterEntry const ISearchCreator =
{
    L"{1F247DC0-902E-11D0-A80C-00A0C906241A}",
    L"Content Index ISearch Creator Object",
    L"query.dll",
    L"Both"
};

extern HANDLE g_hCurrentDll;

extern "C" STDAPI CifrmwrkDllRegisterServer(void)
{
    CDynLoadUser32 dlUser32;

    HINSTANCE hInst = (HINSTANCE) g_hCurrentDll;

    //
    // Try to load string resources.
    //

    srBinaryFile.Init( hInst, dlUser32 );
    srAsciiFile.Init( hInst, dlUser32 );
    srBatFile.Init( hInst, dlUser32 );
    srCmdFile.Init( hInst, dlUser32 );
    srIdqFile.Init( hInst, dlUser32 );
    srIniFile.Init( hInst, dlUser32 );
    srInxFile.Init( hInst, dlUser32 );
    srRegFile.Init( hInst, dlUser32 );
    srInfFile.Init( hInst, dlUser32 );
    srVbsFile.Init( hInst, dlUser32 );

    //
    // Adjust static definitions
    //

    for ( unsigned i = 0; i < sizeof(aTheNullClasses)/sizeof(aTheNullClasses[0]); i++ )
    {
        aTheNullClasses[i].pwszDescription = aTheNullClasses[i].pwszClassIdDescription = STRINGRESOURCE(srBinaryFile);
    }

    aPlainTextClasses[0].pwszDescription = aPlainTextClasses[0].pwszClassIdDescription = STRINGRESOURCE(srAsciiFile);
    aPlainTextClasses[1].pwszDescription = aPlainTextClasses[1].pwszClassIdDescription = STRINGRESOURCE(srAsciiFile);
    aPlainTextClasses[2].pwszDescription = aPlainTextClasses[2].pwszClassIdDescription = STRINGRESOURCE(srAsciiFile);
    aPlainTextClasses[3].pwszDescription = aPlainTextClasses[3].pwszClassIdDescription = STRINGRESOURCE(srBatFile);
    aPlainTextClasses[4].pwszDescription = aPlainTextClasses[4].pwszClassIdDescription = STRINGRESOURCE(srCmdFile);
    aPlainTextClasses[5].pwszDescription = aPlainTextClasses[5].pwszClassIdDescription = STRINGRESOURCE(srIdqFile);
    aPlainTextClasses[6].pwszDescription = aPlainTextClasses[6].pwszClassIdDescription = STRINGRESOURCE(srIniFile);
    aPlainTextClasses[7].pwszDescription = aPlainTextClasses[7].pwszClassIdDescription = STRINGRESOURCE(srInxFile);
    aPlainTextClasses[8].pwszDescription = aPlainTextClasses[8].pwszClassIdDescription = STRINGRESOURCE(srRegFile);
    aPlainTextClasses[9].pwszDescription = aPlainTextClasses[9].pwszClassIdDescription = STRINGRESOURCE(srInfFile);
    aPlainTextClasses[10].pwszDescription = aPlainTextClasses[10].pwszClassIdDescription = STRINGRESOURCE(srVbsFile);

    //
    // Register classes
    //

    long dwErr = ERROR_SUCCESS;
    SCODE sc = TheNullRegisterServer();

    if ( S_OK == sc )
        sc = PlainTextRegisterServer();

    if ( S_OK == sc )
        dwErr = RegisterALanguageResource( NeutralWordBreaker );

    if ( S_OK == sc && ERROR_SUCCESS == dwErr )
        dwErr = RegisterAFilter( NullStemmer_CHS );

    if ( S_OK == sc && ERROR_SUCCESS == dwErr )
        dwErr = RegisterAFilter( NullStemmer_CHT );

    if ( S_OK == sc && ERROR_SUCCESS == dwErr )
        dwErr = RegisterAFilter( FrameworkControl );

    if ( S_OK == sc && ERROR_SUCCESS == dwErr )
        dwErr = RegisterAFilter( ISearchCreator );

    return S_OK != sc ? sc :
                        (ERROR_SUCCESS == dwErr ? S_OK : SELFREG_E_CLASS );
} //CifrmwrkDllRegisterServer

extern "C" STDAPI CifrmwrkDllUnregisterServer(void)
{
    SCODE sc = TheNullUnregisterServer();
    SCODE sc2 = PlainTextUnregisterServer();
    long dw3 = UnRegisterALanguageResource( NeutralWordBreaker );
    long dw4 = UnRegisterAFilter( NullStemmer_CHS );
    long dw5 = UnRegisterAFilter( NullStemmer_CHT );
    long dw6 = UnRegisterAFilter( FrameworkControl );
    long dw7 = UnRegisterAFilter( ISearchCreator );

    if ( FAILED( sc ) )
        return sc;

    if ( FAILED( sc2 ) )
        return sc2;

    if ( ERROR_SUCCESS != dw3 )
        return S_FALSE;

    if ( ERROR_SUCCESS != dw4 )
        return S_FALSE;

    if ( ERROR_SUCCESS != dw5 )
        return S_FALSE;

    if ( ERROR_SUCCESS != dw6 )
        return S_FALSE;

    if ( ERROR_SUCCESS != dw7 )
        return S_FALSE;

    return S_OK;
} //CifrmwrkDllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF


$(_OBJ_DIR)\$(TARGET_DIRECTORY)\cifrmwrk.def: cifrmwrk.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       exports.cxx
//
//  Contents:   Code to export filter and word breaker class factories
//
//  History:    15-Aug-1994     SitaramR   Created
//
//  Notes:      Copied from txtifilt.hxx and then modified
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <classid.hxx>
#include <nullfilt.hxx>
#include <txtifilt.hxx>
#include <defbreak.hxx>
#include <cicontrl.hxx>
#include <isrchcf.hxx>
#include <nullstem.hxx>

CLSID clsidNlCiControl = CLSID_NLCiControl;

// 78fe669a-186e-4108-96e9-77b586c1332f
CLSID clsidNullStemmer = { 0x78fe669a, 0x186e, 0x4108, {0x96, 0xe9, 0x77, 0xb5, 0x86, 0xc1, 0x33, 0x2f} };

//+-------------------------------------------------------------------------
//
//  Function:   CifrmwrkDllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter or a word breaker class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE CifrmwrkDllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    TRY
    {
        if ( CLSID_CTextIFilter == cid || CLSID_CTextClass == cid )
            pResult = (IUnknown *)new CTextIFilterCF;
        else if ( CLSID_CNullIFilter == cid )
            pResult = (IUnknown *)new CNullIFilterCF;
        else if ( CLSID_Neutral_WBreaker == cid )
            pResult = (IUnknown *)new CDefWordBreakerCF;
        else if ( clsidCiControl == cid || clsidNlCiControl == cid )
            pResult = (IUnknown *) new CCiControlObjectCF;
        else if ( clsidISearchCreator == cid)
            pResult = (IUnknown *) new CCiISearchCreatorCF;
        else if ( clsidNullStemmer == cid)
            pResult = (IUnknown *) new CNullStemmerCF;
        else
        {
            ciDebugOut(( DEB_ITRACE, "DllGetClassObject: no such interface found\n" ));
            pResult = 0;
            sc = E_NOINTERFACE;
        }
    }
    CATCH(CException, e)
    {
        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    if (0 != pResult) {
        sc = pResult->QueryInterface( iid, ppvObj );
        pResult->Release( );
    }

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\secutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//  File:       secutil.cxx
//
//  Contents:   security utility routines
//
//  History:    10-April-98 dlee   Created from 4 other copies in NT
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


#include "secutil.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   InitAllowedAce
//
//  Synopsis:   Assignes the ACE values into the allowed ACE
//
//  Arguments:  [pAllowedAce]  - Supplies a pointer to the ACE that is
//                               initialized.
//              [AceSize]      - Supplies the size of the ACE in bytes.
//              [InheritFlags] - Supplies ACE inherit flags.
//              [AceFlags]     - Supplies ACE type specific control flags.
//              [Mask]         - Supplies the allowed access masks.
//              [pAllowedSid]  - Supplies the pointer to the SID of user/
//                               group which is allowed the specified access.
//
//  History:    10-April-98   dlee       Stole from 4 other places in NT
//
//--------------------------------------------------------------------------

void InitAllowedAce(
    ACCESS_ALLOWED_ACE * pAllowedAce,
    USHORT               AceSize,
    BYTE                 InheritFlags,
    BYTE                 AceFlags,
    ACCESS_MASK          Mask,
    SID *                pAllowedSid )
{
    pAllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAllowedAce->Header.AceSize = AceSize;
    pAllowedAce->Header.AceFlags = AceFlags | InheritFlags;
    pAllowedAce->Mask = Mask;

    if ( !CopySid( GetLengthSid( pAllowedSid ),
                   &(pAllowedAce->SidStart),
                   pAllowedSid ) )
        THROW( CException() );
} //InitAllowedAce

//+-------------------------------------------------------------------------
//
//  Function:   InitDeniedAce
//
//  Synopsis:   Assignes the ACE values into the denied ACE
//
//  Arguments:  [pDeniedAce]   - Supplies a pointer to the ACE that is
//                               initialized.
//              [AceSize]      - Supplies the size of the ACE in bytes.
//              [InheritFlags] - Supplies ACE inherit flags.
//              [AceFlags]     - Supplies ACE type specific control flags.
//              [Mask]         - Supplies the allowed access masks.
//              [pDeniedSid]   - Supplies the pointer to the SID of user/
//                               group which is denied the specified access.
//
//  History:    10-April-98   dlee       Stole from 4 other places in NT
//
//--------------------------------------------------------------------------

void InitDeniedAce(
    ACCESS_DENIED_ACE * pDeniedAce,
    USHORT              AceSize,
    BYTE                InheritFlags,
    BYTE                AceFlags,
    ACCESS_MASK         Mask,
    SID *               pDeniedSid )
{
    pDeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    pDeniedAce->Header.AceSize = AceSize;
    pDeniedAce->Header.AceFlags = AceFlags | InheritFlags;
    pDeniedAce->Mask = Mask;

    if( !CopySid( GetLengthSid( pDeniedSid ),
                  &(pDeniedAce->SidStart),
                  pDeniedSid ) )
        THROW( CException() );
} //InitDeniedAce

//+-------------------------------------------------------------------------
//
//  Function:   InitAuditAce
//
//  Synopsis:   Assignes the ACE values into the audit ACE
//
//  Arguments:  [pAuditAce]    - Supplies a pointer to the ACE that is
//                               initialized.
//              [AceSize]      - Supplies the size of the ACE in bytes.
//              [InheritFlags] - Supplies ACE inherit flags.
//              [AceFlags]     - Supplies ACE type specific control flags.
//              [Mask]         - Supplies the allowed access masks.
//              [pAuditSid]    - Supplies the pointer to the SID of user/
//                               group which is audited
//
//  History:    10-April-98   dlee       Stole from 4 other places in NT
//
//--------------------------------------------------------------------------

void InitAuditAce(
    ACCESS_ALLOWED_ACE * pAuditAce,
    USHORT               AceSize,
    BYTE                 InheritFlags,
    BYTE                 AceFlags,
    ACCESS_MASK          Mask,
    SID *                pAuditSid )
{
    pAuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    pAuditAce->Header.AceSize = AceSize;
    pAuditAce->Header.AceFlags = AceFlags | InheritFlags;
    pAuditAce->Mask = Mask;

    if ( !CopySid( GetLengthSid( pAuditSid ),
                   &(pAuditAce->SidStart),
                   pAuditSid ) )
        THROW( CException() );
} //InitAuditAce

//+-------------------------------------------------------------------------
//
//  Function:   CiCreateSecurityDescriptor
//
//  Synopsis:   Creates a security descriptor from input data
//
//  Arguments:  [pAceData] - Array of input data
//              [cAces]    - Count of items in pAceData
//              [OwnerSid] - 0 or the owner of the descriptor
//              [GroupSid] - 0 or group of the descriptor
//              [xAcls]    - Resulting absolute SECURITY_DESCRIPTOR,
//                           allocated to the required size.
//
//  History:    10-April-98   dlee   Stole from 4 other places in NT
//
//--------------------------------------------------------------------------

void CiCreateSecurityDescriptor( ACE_DATA const * const pAceData,
                                 ULONG                  cAces,
                                 SID *                  pOwnerSid,
                                 SID *                  pGroupSid,
                                 XArray<BYTE> &         xAcls )
{
    //
    // This function returns a pointer to memory dynamically allocated to
    // hold the absolute security descriptor, the DACL, the SACL, and all
    // the ACEs:
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    DWORD cbDacl = sizeof ACL;
    DWORD cbSacl = sizeof ACL;
    DWORD cbMaxAce = 0;

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for ( DWORD i = 0; i < cAces; i++ )
    {
        DWORD cbAce = GetLengthSid( pAceData[i].pSid );

        switch (pAceData[i].AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
                cbAce += sizeof ACCESS_ALLOWED_ACE;
                cbDacl += cbAce;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                cbAce += sizeof ACCESS_DENIED_ACE;
                cbDacl += cbAce;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                cbAce += sizeof SYSTEM_AUDIT_ACE;
                cbSacl += cbAce;
                break;

            default:
                Win4Assert( FALSE );
        }

        cbMaxAce = __max( cbMaxAce, cbAce );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    DWORD cbTotal = SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( cbDacl != sizeof ACL )
        cbTotal += cbDacl;

    if ( cbSacl != sizeof ACL )
        cbTotal += cbSacl;

    xAcls.Init( cbTotal );
    SECURITY_DESCRIPTOR *pAbsoluteSd = (SECURITY_DESCRIPTOR *) xAcls.Get();

    //
    // Initialize the Dacl and Sacl
    //

    BYTE *pbCurrent = (BYTE *) pAbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;
    ACL *pDacl = 0;   // Pointer to the DACL portion of above buffer
    ACL *pSacl = 0;   // Pointer to the SACL portion of above buffer

    if ( sizeof ACL != cbDacl )
    {
        pDacl = (ACL *) pbCurrent;
        pbCurrent += cbDacl;

        if( !InitializeAcl( pDacl, cbDacl, ACL_REVISION ) )
            THROW( CException() );
    }

    if ( sizeof ACL != cbSacl )
    {
        pSacl = (ACL *) pbCurrent;
        pbCurrent += cbSacl;

        if ( !InitializeAcl( pSacl, cbSacl, ACL_REVISION ) )
            THROW( CException() );
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    // This is usually pretty small
    //

    XGrowable<BYTE> xMaxAce( cbMaxAce );

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for ( i = 0; i < cAces; i++ )
    {
        DWORD cbAce = GetLengthSid( pAceData[i].pSid );
        ACL *pCurrentAcl;

        switch (pAceData[i].AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
                cbAce += sizeof ACCESS_ALLOWED_ACE;
                pCurrentAcl = pDacl;
                InitAllowedAce( (ACCESS_ALLOWED_ACE *) xMaxAce.Get(),
                                (USHORT) cbAce,
                                pAceData[i].InheritFlags,
                                pAceData[i].AceFlags,
                                pAceData[i].Mask,
                                pAceData[i].pSid );
                break;

            case ACCESS_DENIED_ACE_TYPE:
                cbAce += sizeof ACCESS_DENIED_ACE;
                pCurrentAcl = pDacl;
                InitDeniedAce( (ACCESS_DENIED_ACE *) xMaxAce.Get(),
                               (USHORT) cbAce,
                               pAceData[i].InheritFlags,
                               pAceData[i].AceFlags,
                               pAceData[i].Mask,
                               pAceData[i].pSid );
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                cbAce += sizeof SYSTEM_AUDIT_ACE;
                pCurrentAcl = pSacl;

                // Audit uses ACCESS_ALLOWED_ACE

                InitAuditAce( (ACCESS_ALLOWED_ACE *) xMaxAce.Get(),
                              (USHORT) cbAce,
                              pAceData[i].InheritFlags,
                              pAceData[i].AceFlags,
                              pAceData[i].Mask,
                              pAceData[i].pSid );
                break;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        if ( !AddAce( pCurrentAcl,
                      ACL_REVISION,
                      MAXULONG,
                      xMaxAce.Get(),
                      cbAce ) )
            THROW( CException() );
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = pOwnerSid
    // Group = pGroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if ( !InitializeSecurityDescriptor( pAbsoluteSd,
                                        SECURITY_DESCRIPTOR_REVISION ) ||
         !SetSecurityDescriptorOwner( pAbsoluteSd,
                                      pOwnerSid,
                                      FALSE ) ||
         !SetSecurityDescriptorGroup( pAbsoluteSd,
                                      pGroupSid,
                                      FALSE ) ||
         !SetSecurityDescriptorDacl( pAbsoluteSd,
                                     TRUE,
                                     pDacl,
                                     FALSE ) ||
         !SetSecurityDescriptorSacl( pAbsoluteSd,
                                     FALSE,
                                     pSacl,
                                     FALSE ) )
        THROW( CException() );
} //CiCreateSecurityDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\dll\srequest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       srequest.cxx
//
//  Contents:   Server side of catalog/query requests
//
//  Classes:    CPipeServer
//              CRequestServer
//              CRequestQueue
//
//  Functions:  StartCiSvcWork
//              StopCiSvcWork
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cci.hxx>
#include <query.hxx>
#include <rstprop.hxx>
#include <pickle.hxx>
#include <worker.hxx>
#include <propspec.hxx>
#include <seqquery.hxx>
#include <rowseek.hxx>
#include <srequest.hxx>
#include <propvar.h>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <imprsnat.hxx>
#include <driveinf.hxx>

#include <qparse.hxx>
#include <dbprputl.hxx>
#include <cidbprop.hxx>
#include <ciframe.hxx>
#include <cisvcfrm.hxx>
#include <lang.hxx>

#include <fsciexps.hxx>
#include <pidcvt.hxx>
#include <cisvcex.hxx>

#include <fsciclnt.h>

#include "secutil.hxx"

extern CLocateDocStore g_svcDocStoreLocator;
extern CStaticMutexSem g_mtxStartStop;

CRequestQueue * g_pRequestQueue = 0;

const CRequestServer::ProxyMessageFunction CRequestServer::_aMsgFunctions[] =
{
    DoConnect,
    DoDisconnect,
    DoCreateQuery,
    DoFreeCursor,
    DoGetRows,
    DoRatioFinished,
    DoCompareBmk,
    DoGetApproximatePosition,
    DoSetBindings,
    DoGetNotify,
    DoSendNotify,
    DoSetWatchMode,
    DoGetWatchInfo,
    DoShrinkWatchRegion,
    DoRefresh,
    DoGetQueryStatus,
    DoObsolete,                  //WidToPath
    DoCiState,
    DoObsolete,                  //BeginCacheTransaction
    DoObsolete,                  //SetupCache
    DoObsolete,                  //EndCacheTransaction
    DoObsolete,                  //AddScope
    DoObsolete,                  //RemoveScope
    DoObsolete,                  //AddVirtualScope
    DoObsolete,                  //RemoveVirtualScope
    DoForceMerge,
    DoAbortMerge,
    DoObsolete,                  //SetPartition
    DoFetchValue,
    DoWorkIdToPath,
    DoUpdateDocuments,
    DoGetQueryStatusEx,
    DoRestartPosition,
    DoStopAsynch,
    DoStartWatching,
    DoStopWatching,
    DoSetCatState
};

const BOOL CRequestServer::_afImpersonate[] =
{
    TRUE,   //    DoConnect,
    FALSE,  //    DoDisconnect,
    TRUE,   //    DoCreateQuery,
    FALSE,  //    DoFreeCursor,
    TRUE,   //    DoGetRows,
    FALSE,  //    DoRatioFinished,
    FALSE,  //    DoCompareBmk,
    FALSE,  //    DoGetApproximatePosition,
    FALSE,  //    DoSetBindings,
    FALSE,  //    DoGetNotify,
    FALSE,  //    DoSendNotify,
    FALSE,  //    DoSetWatchMode,
    FALSE,  //    DoGetWatchInfo,
    FALSE,  //    DoShrinkWatchRegion,
    FALSE,  //    DoRefresh,
    FALSE,  //    DoGetQueryStatus,
    FALSE,  //    DoObsolete,                  //DoWidToPath,
    FALSE,  //    DoCiState,
    TRUE,   //    DoBeginCacheTransaction,
    TRUE,   //    DoSetupCache,
    TRUE,   //    DoEndCacheTransaction,
    FALSE,  //    DoObsolete,                  //AddScope
    FALSE,  //    DoObsolete,                  //RemoveScope
    FALSE,  //    DoObsolete,                  //AddVirtualScope
    FALSE,  //    DoObsolete,                  //RemoveVirtualScope
    TRUE,   //    DoForceMerge,
    TRUE,   //    DoAbortMerge,
    FALSE,  //    DoObsolete,                  //SetPartition
    TRUE,   //    DoFetchValue,
    TRUE,   //    DoWorkIdToPath,
    TRUE,   //    DoUpdateDocuments,
    FALSE,  //    DoGetQueryStatusEx,
    FALSE,  //    DoRestartPosition,
    FALSE,  //    DoStopAsynch,
    FALSE,  //    DoStartWatching,
    FALSE,  //    DoStopWatching,
    TRUE,   //    DoSetCatState
};

//+-------------------------------------------------------------------------
//
//  Member:     CPipeServer::CPipeServer, public
//
//  Synopsis:   Constructor for a server pipe.  The pipe is created such
//              that any client can connect.
//
//  Arguments:  [pwcName]                 - Name for the pipe
//              [cmsDefaultClientTimeout] - Default timeout for clients
//                                          trying to get a pipe instance
//              [pSecurityDescriptor]     - Security for the pipe
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

CPipeServer::CPipeServer(
    const WCHAR *         pwcName,
    ULONG                 cmsDefaultClientTimeout,
    SECURITY_DESCRIPTOR * pSecurityDescriptor ) :
    _eventWrite( (HANDLE) 0 ) // defer creation of the notification event
{
    RtlZeroMemory( &_overlapped, sizeof _overlapped );

    SECURITY_ATTRIBUTES saPipeSecurity;
    saPipeSecurity.nLength = sizeof SECURITY_ATTRIBUTES;
    saPipeSecurity.bInheritHandle = FALSE;
    saPipeSecurity.lpSecurityDescriptor = pSecurityDescriptor;

    // note: the read/write buffers are allocated from non-paged pool,
    //       and are grown if too small to reflect usage

    _hPipe = CreateNamedPipe( pwcName,
                              PIPE_ACCESS_DUPLEX |
                                  FILE_FLAG_OVERLAPPED,
                              PIPE_TYPE_MESSAGE |
                                  PIPE_READMODE_MESSAGE |
                                  PIPE_WAIT,
                              PIPE_UNLIMITED_INSTANCES,
                              1024,      // read buffer size
                              2048,      // write buffer size
                              cmsDefaultClientTimeout,
                              &saPipeSecurity );

    if ( INVALID_HANDLE_VALUE == _hPipe )
        THROW( CException() );

    prxDebugOut(( DEB_ITRACE, "created pipe 0x%x\n", _hPipe ));
} //CPipeServer

//+-------------------------------------------------------------------------
//
//  Member:     CPipeServer::Connect, public
//
//  Synopsis:   Enables a client to connect to the pipe.
//
//  Returns:    TRUE if connected, FALSE if GetEvent() will be signalled
//              on connection, or throws on error.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

BOOL CPipeServer::Connect()
{
    prxDebugOut(( DEB_ITRACE, "connecting from pipe 0x%x\n", _hPipe ));

    _overlapped.hEvent = _event.GetHandle();
    BOOL fEventWait = ConnectNamedPipe( _hPipe, &_overlapped );

    if ( !fEventWait )
    {
        DWORD dwError = GetLastError();

        prxDebugOut(( DEB_ITRACE, "CPipeServer::Connect.. GetLastError() == %d\n", dwError ));

        if ( ERROR_PIPE_CONNECTED == dwError )
            return TRUE;
        else if ( ERROR_IO_PENDING != dwError )
            THROW( CException() );
    }

    return FALSE;
} //Connect

//+-------------------------------------------------------------------------
//
//  Member:     CPipeServer::ReadRemainingSync, public
//
//  Synopsis:   Reads the remainder of a message from the pipe (if any)
//
//  Arguments:  [pvSoFar]  - Part of the message read so far
//              [cbSoFar]  - in:  # of bytes read so far for the message
//                           out: # bytes total in message
//
//  Returns:    Pointer to memory containing entire message or 0 if
//              there really wasn't anything more to read
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

BYTE * CPipeServer::ReadRemainingSync(
    void *  pvSoFar,
    DWORD & cbSoFar )
{
    DWORD cbLeft;

    if ( ! PeekNamedPipe( _hPipe, 0, 0, 0, 0, &cbLeft ) )
        THROW( CException() );

    if ( 0 == cbLeft )
    {
        prxDebugOut(( DEB_WARN, "peek says no more to read\n" ));
        return 0;
    }

    XArray<BYTE> xMsg( cbSoFar + cbLeft );
    RtlCopyMemory( xMsg.Get(), pvSoFar, cbSoFar );

    CEventSem evt;
    OVERLAPPED o;
    RtlZeroMemory( &o, sizeof o );
    o.hEvent = evt.GetHandle();

    DWORD cbRead;
    if ( ! ReadFile( _hPipe,
                     xMsg.Get() + cbSoFar,
                     cbLeft,
                     &cbRead,
                     &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( !GetOverlappedResult( _hPipe,
                                       &o,
                                       &cbRead,
                                       TRUE ) )
                THROW( CException() );
        }
        else
            THROW( CException() );
    }

    Win4Assert( cbRead == cbLeft );
    cbSoFar += cbLeft;
    return xMsg.Acquire();
} //ReadRemainingSync

//+-------------------------------------------------------------------------
//
//  Member:     CPipeServer::WriteSync, public
//
//  Synopsis:   Does a synchronous write to a pipe.  There can be at most
//              one caller at a time to this method.
//
//  Arguments:  [pv] - Buffer to write
//              [cb] - # of bytes to write
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeServer::WriteSync(
    void * pv,
    DWORD  cb )
{
    prxDebugOut(( DEB_ITRACE, "WriteSync on this 0x%x, pipe 0x%x\n",
                  this, _hPipe ));

    OVERLAPPED o;
    RtlZeroMemory( &o, sizeof o );

    // Create and keep the event, since if we do it once (for notifications)
    // we'll likely do it again soon.

    if ( 0 == _eventWrite.GetHandle() )
        _eventWrite.Create();

    o.hEvent = _eventWrite.GetHandle();

    if ( ! WriteFile( _hPipe, pv, cb, 0, &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            DWORD cbWritten;
            if ( !GetOverlappedResult( _hPipe,
                                       &o,
                                       &cbWritten,
                                       TRUE ) )
                THROW( CException() );

            Win4Assert( cbWritten == cb );
        }
        else
            THROW( CException() );
    }
    prxDebugOut(( DEB_ITRACE, "WriteSync completed on this 0x%x, pipe 0x%x\n",
                  this, _hPipe ));
} //WriteSync

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::CRequestServer, public
//
//  Synopsis:   Constructor for the request server
//
//  Arguments:  [pwcPipe]                 - Name of the pipe to use
//              [cmsDefaultClientTimeout] - Timeout for clients waiting for
//                                          and instance
//              [requestQueue]            - The 1 and only request queue
//              [workQueue]               - The work queue
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

CRequestServer::CRequestServer(
    const WCHAR *   pwcPipe,
    ULONG           cmsDefaultClientTimeout,
    CRequestQueue & requestQueue,
    CWorkQueue &    workQueue ) :
    CPipeServer( pwcPipe,
                 cmsDefaultClientTimeout,
                 requestQueue.GetSecurityDescriptor() ),
    PWorkItem( sigCRequestServer ),
    _state( pipeStateNone ),
    _cRefs( 1 ),
    _iClientVersion( 0 ),
    _pQuery( 0 ),
    _fClientIsRemote( FALSE ),
    _pWorkThread( 0 ),
    _hWorkThread( INVALID_HANDLE_VALUE ),
    _cbFetchedValueSoFar( 0 ),
    _cbPendingWrite( 0 ),
    _scPendingStatus( S_OK ),
    _requestQueue( requestQueue ),
    _workQueue( workQueue ),
    _pevtDone( 0 ),
    _dwLastTouched( GetTickCount() )
{
    requestQueue.AddToListNoThrow( this );
} //CRequestServer

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::Release, public
//
//  Synopsis:   Releases and if approprate deletes the object
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::Release()
{
    Win4Assert( 0 != _cRefs );

    CLock lock( _requestQueue.GetTheMutex() );

    // Since the AddRef() is not done under lock (and we don't want to)
    // InterlockedDecrement is used even though we're under lock.

    if ( 0 == InterlockedDecrement( & _cRefs ) )
    {
        _requestQueue.RemoveFromListNoThrow( this );

        // If someone is waiting for this to go out of the list,
        // tell them now.

        if ( 0 != _pevtDone )
        {
            _pevtDone->Set();
            _pevtDone = 0;
        }

        delete this;
    }
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoIt, public
//
//  Synopsis:   Implements the work queue DoIt method by scheduling
//              the first read from the client of the pipe.  The work queue
//              is needed since apc completion routines must be run by
//              the thread that submitted the i/o.
//
//  Arguments:  [pThread] - Thread being used (for refcounting)
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::DoIt(
    CWorkThread *pThread )
{
    TRY
    {
        Win4Assert( pipeStateNone == _state );
        Win4Assert( 0 == _pWorkThread );
        Win4Assert( INVALID_HANDLE_VALUE == _hWorkThread );
        prxDebugOut(( DEB_ITRACE, "doit CRequestServer %p\n", this ));

        _pWorkThread = pThread;
        _hWorkThread = pThread->GetThreadHandle();
        _workQueue.AddRef( pThread );
        _state = pipeStateRead;

        Read( _Buffer(), _BufferSize(), APCRoutine );

        if ( IsBeingRemoved() )
            CancelIO();
    }
    CATCH( CException, ex )
    {
        prxDebugOut(( DEB_ITRACE,
                      "failed initial read error 0x%x, pipe %p\n",
                      ex.GetErrorCode(),
                      GetPipe() ));

        _state = pipeStateNone;
        _requestQueue.RecycleRequestServerNoThrow( this );
    }
    END_CATCH;
} //DoIt

//+-------------------------------------------------------------------------
//
//  Function:   TranslateOldPropsToNewProps
//
//  Synopsis:   Translates ver 5 client properties into version 6+ props
//
//  Arguments:  [oldProps]    - source of translated values
//              [newProps]    - destination of translated values
//
//  History:    31-May-97   dlee       Created.
//
//--------------------------------------------------------------------------

void TranslateOldPropsToNewProps(
    CDbProperties & oldProps,
    CDbProperties & newProps )
{
    const GUID guidFsClientPropset = DBPROPSET_FSCIFRMWRK_EXT;
    const GUID guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

    // pluck out the catalog and scope information from the old set

    WCHAR *pwcCatalog = 0;
    BSTR bstrMachine = 0;
    CDynArrayInPlace<ULONG> aDepths(2);
    CDynArrayInPlace<WCHAR *> aScopes(2);
    LONG lQueryType = 0;

    for ( ULONG i = 0; i < oldProps.Count(); i++ )
    {
        CDbPropSet & propSet = oldProps.GetPropSet( i );
        DBPROPSET *pSet = propSet.CastToStruct();

        if ( guidQueryCorePropset == pSet->guidPropertySet )
        {
            ULONG cProp = pSet->cProperties;
            DBPROP * pProp = pSet->rgProperties;

            for ( ULONG p = 0; p < pSet->cProperties; p++, pProp++ )
            {
                PROPVARIANT &v = (PROPVARIANT &) pProp->vValue;
                switch ( pProp->dwPropertyID )
                {
                    case DBPROP_MACHINE :
                    {
                        Win4Assert( VT_BSTR == v.vt );
                        if ( VT_BSTR == v.vt )
                            bstrMachine = v.bstrVal;
                        break;
                    }
                }
            }
        }
        else if ( guidFsClientPropset == pSet->guidPropertySet )
        {
            ULONG cProp = pSet->cProperties;
            DBPROP * pProp = pSet->rgProperties;

            for ( ULONG p = 0; p < pSet->cProperties; p++, pProp++ )
            {
                PROPVARIANT &v = (PROPVARIANT &) pProp->vValue;
                switch ( pProp->dwPropertyID )
                {
                    case DBPROP_CI_INCLUDE_SCOPES :
                    {
                        Win4Assert( (VT_VECTOR|VT_LPWSTR) == v.vt );
                        if ( (VT_VECTOR|VT_LPWSTR) == v.vt )
                            for ( ULONG s = 0; s < v.calpwstr.cElems; s++ )
                                aScopes[s] = v.calpwstr.pElems[s];
                        break;
                    }
                    case DBPROP_CI_DEPTHS :
                    {
                        Win4Assert( (VT_VECTOR|VT_I4) == v.vt );
                        if ( (VT_VECTOR|VT_I4) == v.vt )
                            for ( ULONG s = 0; s < v.cal.cElems; s++ )
                                aDepths[s] = v.cal.pElems[s];
                        break;
                    }
                    case DBPROP_CI_CATALOG_NAME :
                    {
                        Win4Assert( VT_LPWSTR == v.vt );
                        if ( VT_LPWSTR == v.vt )
                            pwcCatalog = v.pwszVal;
                        break;
                    }
                    case DBPROP_CI_QUERY_TYPE :
                    {
                        Win4Assert( VT_I4 == v.vt );
                        lQueryType = v.lVal;
                        break;
                    }
                }
            }
        }
    }

    if ( 0 == pwcCatalog ||
         0 == bstrMachine )
        THROW( CException( STATUS_INVALID_PARAMETER_MIX ) );

    prxDebugOut(( DEB_ITRACE,
                  "Converting old props to new props, catalog '%ws'",
                  pwcCatalog ));

    prxDebugOut(( DEB_ITRACE,
                  "type %d, %d scopes, %d depths\n",
                  lQueryType,
                  aScopes.Count(),
                  aDepths.Count() ));

    // create a new set of properties based on the old info

    CDynArrayInPlace<BSTR> aBSTR( aScopes.Count() + 2 );

    DBPROPSET aNewSet[2];
    DBPROP aFSProps[4];
    RtlZeroMemory( aFSProps, sizeof aFSProps );
    aNewSet[0].cProperties = 0;
    aNewSet[0].guidPropertySet = guidFsClientPropset;
    aNewSet[0].rgProperties = aFSProps;

    aFSProps[0].dwPropertyID = DBPROP_CI_CATALOG_NAME;
    aFSProps[0].vValue.vt = VT_BSTR;
    aFSProps[0].vValue.bstrVal = SysAllocString( pwcCatalog );
    aBSTR[ aBSTR.Count() ] = aFSProps[0].vValue.bstrVal;
    aNewSet[0].cProperties++;

    aFSProps[1].dwPropertyID = DBPROP_CI_QUERY_TYPE;
    aFSProps[1].vValue.vt = VT_I4;
    aFSProps[1].vValue.lVal = lQueryType;
    aNewSet[0].cProperties++;

    DBPROP & propDepth = aFSProps[ aNewSet[0].cProperties ];

    propDepth.dwPropertyID = DBPROP_CI_DEPTHS;

    SAFEARRAY saDepth = { 1,                      // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)aDepths.GetPointer(), // The data
                          { aDepths.Count(), 0 } };       // Bounds (element count, low bound)

    if ( 1 == aDepths.Count() )
    {
        propDepth.vValue.vt = VT_I4;
        propDepth.vValue.lVal = aDepths[0];
        aNewSet[0].cProperties++;
    }
    else if ( aDepths.Count() > 1 )
    {
        propDepth.vValue.vt = ( VT_ARRAY | VT_I4 );
        propDepth.vValue.parray = & saDepth;
        aNewSet[0].cProperties++;
    }

    DBPROP & propScope = aFSProps[ aNewSet[0].cProperties ];

    propScope.dwPropertyID = DBPROP_CI_INCLUDE_SCOPES;

    SAFEARRAY saScope = { 1,                      // Dimension
                          FADF_AUTO | FADF_BSTR,  // Flags: on stack, contains BSTRs
                          sizeof(BSTR),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)0, // The data
                          { aScopes.Count(), 0 } };       // Bounds (element count, low bound)

    if ( 1 == aScopes.Count() )
    {
        propScope.vValue.vt = VT_BSTR;
        BSTR bstr = SysAllocString( aScopes[ 0 ] );
        aBSTR[ aBSTR.Count() ] = bstr;
        propScope.vValue.bstrVal = bstr;
        aNewSet[0].cProperties++;
    }
    else if ( aScopes.Count() > 1 )
    {
        propScope.vValue.vt = ( VT_ARRAY | VT_BSTR );
        propScope.vValue.parray = & saScope;

        BSTR * pBSTR = (BSTR *) aBSTR.GetPointer();
        pBSTR += aBSTR.Count();

        for ( ULONG x = 0; x < aScopes.Count(); x++ )
            aBSTR[ aBSTR.Count() ] = SysAllocString( aScopes[ x ] );

        saScope.pvData = (void *) pBSTR;
        aNewSet[0].cProperties++;
    }

    DBPROP aQueryProps[1];
    RtlZeroMemory( aQueryProps, sizeof aQueryProps );
    aNewSet[1].cProperties = 1;
    aNewSet[1].guidPropertySet = guidQueryCorePropset;
    aNewSet[1].rgProperties = aQueryProps;

    aQueryProps[0].dwPropertyID = DBPROP_MACHINE;
    aQueryProps[0].vValue.vt = VT_BSTR;
    aQueryProps[0].vValue.bstrVal = bstrMachine;

    // Verify all the bstrs were allocated

    for ( ULONG iBstr = 0; iBstr < aBSTR.Count(); iBstr++ )
    {
        if ( 0 == aBSTR[ iBstr ] )
        {
            for ( ULONG i = 0; i < aBSTR.Count(); i++ )
            {
                if ( 0 != aBSTR[ i ] )
                    SysFreeString( aBSTR[ i ] );
            }

            THROW( CException( E_OUTOFMEMORY ) );
        }
    }

    SCODE sc = newProps.SetProperties( 2, aNewSet );

    for ( ULONG ibstr = 0; ibstr < aBSTR.Count(); ibstr++ )
        SysFreeString( aBSTR[ ibstr ] );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //TranslateOldPropsToNewProps

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoConnect, private
//
//  Synopsis:   Handles a connect message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoConnect(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    CPMConnectIn &request = * (CPMConnectIn *) _ActiveBuffer();
    XPtrST<BYTE> xTemp( _xTempBuffer.Acquire() );

    Win4Assert( pmConnect == request.GetMessage() );

    // guard against attack

    Win4Assert( 0 == _pQuery );
    Win4Assert( _xDocStore.IsNull() );
    if ( !_xDocStore.IsNull() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    // save the client version, isRemote, machine name, and user name

    _iClientVersion = request.GetClientVersion();

    // don't support old clients

    if ( GetClientVersion() < 5 )
        THROW( CException( STATUS_INVALID_PARAMETER_MIX ) );

    request.ValidateCheckSum( GetClientVersion(), cbRequest );

    _fClientIsRemote = request.IsClientRemote();
    WCHAR *pwcMachine = request.GetClientMachineName();
    ULONG cwcMachine = 1 + wcslen( pwcMachine );

    // Check if the machine name looks mal-formed

    if ( ( cwcMachine * sizeof WCHAR ) >= __min( 1024, cbRequest ) )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    WCHAR *pwcUser = request.GetClientUserName();
    ULONG cwcUser = 1 + wcslen( pwcUser );

    // Check if the user name looks mal-formed

    if ( ( ( cwcMachine + cwcUser ) * sizeof WCHAR ) >= __min( 1024, cbRequest ) )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    _xClientMachine.Init( cwcMachine );
    RtlCopyMemory( _xClientMachine.Get(),
                   pwcMachine,
                   _xClientMachine.SizeOf() );

    _xClientUser.Init( cwcUser );
    RtlCopyMemory( _xClientUser.Get(),
                   pwcUser,
                   _xClientUser.SizeOf() );

    //
    // Retreive the db properties.
    //

    if ( 5 == GetClientVersion() )
    {
        // unmarshall the old-style properties, and translate into
        // the new-style properties

        if ( request.GetBlobSize() > 0 )
        {
            if ( request.GetBlobSize() >= cbRequest )
                THROW( CException( STATUS_INVALID_PARAMETER ) );

            CMemDeSerStream stmDeser( request.GetBlobStartAddr(),
                                      request.GetBlobSize() );

            XInterface<CDbProperties> xOldDbP( new CDbProperties );
            if ( xOldDbP.IsNull() || ! xOldDbP->UnMarshall( stmDeser ) )
                THROW( CException( E_OUTOFMEMORY ) );

            XInterface<CDbProperties> xNewDbP( new CDbProperties );
            if ( xNewDbP.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );
            TranslateOldPropsToNewProps( xOldDbP.GetReference(),
                                         xNewDbP.GetReference() );
            _xDbProperties.Set( xNewDbP.Acquire() );
        }
    }
    else
    {
        Win4Assert( GetClientVersion() >= 6 );

        if ( GetClientVersion() < 5 )
            THROW( CException( STATUS_INVALID_PARAMETER ) );

        if ( request.GetBlob2Size() > 0 )
        {
            if ( ( 0 == request.GetBlob2StartAddr() ) ||
                 ( ( request.GetBlobSize() + request.GetBlob2Size() ) >= cbRequest ) )
                THROW( CException( STATUS_INVALID_PARAMETER ) );

            CMemDeSerStream stmDeser( request.GetBlob2StartAddr(),
                                      request.GetBlob2Size() );

            XInterface<CDbProperties> xDbP( new CDbProperties );
            if ( xDbP.IsNull() || !xDbP->UnMarshall( stmDeser ) )
                THROW( CException( E_OUTOFMEMORY ) );

            _xDbProperties.Set( xDbP.Acquire() );
        }
    }

    prxDebugOut(( DEB_ITRACE|DEB_PRX_LOG,
                  "connect clientver %d, remote %d, machine '%ws', user '%ws'\n",
                  _iClientVersion,
                  _fClientIsRemote,
                  pwcMachine,
                  pwcUser ));

    XInterface<ICiCDocStoreLocator> xLocator( _requestQueue.DocStoreLocator() );
    Win4Assert( !xLocator.IsNull() );

    CPMConnectOut & reply = *(CPMConnectOut *) _Buffer();
    cbToWrite = sizeof reply;
    reply.ServerVersion() = pmServerVersion;

    //
    // Never fault in the docstore since docstores have been opened by now.
    //

    Win4Assert( _requestQueue.AreDocStoresOpen() );

    ICiCDocStore * pDocStore = 0;
    SCODE sc = xLocator->LookUpDocStore( _xDbProperties.GetPointer(),
                                         &pDocStore,
                                         TRUE );

    if ( SUCCEEDED(sc) )
    {
        // sc will be CI_S_NO_DOCSTORE if this is the CIADMIN catalog

        if ( 0 != pDocStore )
        {
            _xDocStore.Set( pDocStore );

            // This QI is just about guaranteed to work.

            XInterface<ICiCAdviseStatus> xAdviseStatus;
            sc = pDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                            xAdviseStatus.GetQIPointer() );
            if ( S_OK != sc )
                THROW( CException(sc) );

            xAdviseStatus->IncrementPerfCounterValue( CI_PERF_RUNNING_QUERIES );
        }
    }
    else
        reply.SetStatus( CI_E_NO_CATALOG );

    return stateContinue;
} //DoConnect

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoDisconnect, private
//
//  Synopsis:   Handles a disconnect message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  Returns:    stateDisconnect -- the connection will be closed
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoDisconnect(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    CProxyMessage &msg = * (CProxyMessage *) _Buffer();
    Win4Assert( pmDisconnect == msg.GetMessage() );

    return stateDisconnect;
} //DoDisconnect

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoCreateQuery, private
//
//  Synopsis:   Handles a create query message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoCreateQuery(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    // if this hits, there is probably a cursor refcounting bug

    Win4Assert( 0 == _pQuery );

    if ( _xDocStore.IsNull() ||
         ( 0 != _pQuery ) )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    XInterface<ICiCDocStoreEx>  xDocStoreEx;

    SCODE sc = _xDocStore->QueryInterface( IID_ICiCDocStoreEx,
                                           xDocStoreEx.GetQIPointer() );

    if ( SUCCEEDED(sc) )
    {
        BOOL fNoQuery = FALSE;

        sc = xDocStoreEx->IsNoQuery( &fNoQuery );

        if ( S_OK == sc )
        {
            if ( fNoQuery )
                THROW( CException( QUERY_S_NO_QUERY ) );
        }
        else
            THROW ( CException( sc ) );

    }
    else
        THROW ( CException( sc ) );

    RequestState state = stateContinue;

    // The request is either in the standard buffer or the temp buffer.
    // Take ownership of the temp buffer.

    CPMCreateQueryIn &request = * (CPMCreateQueryIn *) _ActiveBuffer();
    XPtrST<BYTE> xTemp( _xTempBuffer.Acquire() );

    // marshalling / unmarshalling is inconsistent if alignment is different

    Win4Assert( isQWordAligned( &request ) );
    Win4Assert( isQWordAligned( request.Data() ) );

    request.ValidateCheckSum( GetClientVersion(), cbRequest );

    // unpickle the query

    XColumnSet         cols;
    XRestriction       rst;
    XSortSet           sort;
    XCategorizationSet categ;
    CRowsetProperties  Props;
    XPidMapper         pidmap;

    UnPickle( GetClientVersion(),
              cols,
              rst,
              sort,
              categ,
              Props,
              pidmap,
              (BYTE *) request.Data(),
              cbRequest - sizeof CProxyMessage );

    if ( Props.GetMaxResults() > 0 && Props.GetFirstRows() > 0 )
        THROW( CException( E_INVALIDARG ) );
 
    // Compute # of cursors to create and where to put them

    unsigned cCursors = 1;
    if ( 0 != categ.GetPointer() )
        cCursors += categ->Size();

    // verify the output buffer is large enough

    if ( _BufferSize() <
         ( cCursors * sizeof ULONG + sizeof CPMCreateQueryOut ) )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    // get reference to CLangList to pass to CQParse objects...

    XInterface<ICiManager> xICiManager;

    sc = _xDocStore->GetContentIndex( xICiManager.GetPPointer() );
    if ( FAILED(sc) )
        THROW( CException(sc) );

    XInterface<ICiFrameworkQuery> xICiFrameworkQuery;
    sc = xICiManager->QueryInterface( IID_ICiFrameworkQuery,
                                      xICiFrameworkQuery.GetQIPointer() );
    if ( FAILED(sc) )
        THROW( CException(sc) );

    CLangList * pLangList = 0;
    sc = xICiFrameworkQuery->GetLangList((void**)&pLangList);
    if ( FAILED(sc) )
        THROW( CException(sc) );

    //
    // Set up a property mapper.  Used for restriction parsing and sort/output
    // column translation.
    //

    XInterface<IPropertyMapper> xPropMapper;
    sc = _xDocStore->GetPropertyMapper( xPropMapper.GetPPointer() );

    if ( FAILED( sc ) )
    {
         vqDebugOut(( DEB_ERROR, "CRequestServer::DoCreateQuery, GetPropertyMapper failed\n" ));
         THROW( CException( sc ) );
    }

    //
    // Adjust pidmap to translate properties.
    //

    CPidConverter PidConverter( xPropMapper.GetPointer() );
    pidmap->SetPidConverter( &PidConverter );

    // parse the query -- expand phrases, etc.

    XRestriction rstParsed;
    DWORD dwQueryStatus = 0;
    if ( !rst.IsNull() )
    {
        CQParse qparse( pidmap.GetReference(), *pLangList );
        rstParsed.Set( qparse.Parse( rst.GetPointer() ) );

        DWORD dwParseStatus = qparse.GetStatus();

        if ( ( 0 != ( dwParseStatus & CI_NOISE_PHRASE ) ) &&
             ( rst->Type() != RTVector ) &&
             ( rst->Type() != RTOr ) )
        {
            vqDebugOut(( DEB_WARN, "Query contains phrase composed "
                                   "entirely of noise words.\n" ));
            THROW( CException( QUERY_E_ALLNOISE ) );
        }

        const DWORD dwCiNoise = CI_NOISE_IN_PHRASE | CI_NOISE_PHRASE;
        if ( 0 != ( dwCiNoise & dwParseStatus ) )
            dwQueryStatus |= STAT_NOISE_WORDS;
    }

    //
    // Re-map property ids.
    //

    //
    // TODO: Get rid of this whole pid remap thing.  We should
    //       really be able to do it earlier now that the pidmap
    //       can be set up to convert fake to real pids.
    //

    XInterface<CPidRemapper> pidremap( new CPidRemapper( pidmap.GetReference(),
                                                         xPropMapper,
                                                         0, // rstParsed.GetPointer(),
                                                         cols.GetPointer(),
                                                         sort.GetPointer() ) );

    //
    // WorkID may be added to the columns requested in SetBindings.
    // Be sure it's in the pidremap from the beginning.
    //

    CFullPropSpec psWorkId( guidQuery, DISPID_QUERY_WORKID );
    pidremap->NameToReal( &psWorkId );

    XInterface<ICiQueryPropertyMapper> xQueryPropMapper;
    sc = pidremap->QueryInterface( IID_ICiQueryPropertyMapper,
                                   xQueryPropMapper.GetQIPointer() );
    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR, "DoCreateQuery - QI for property mapper failed 0x%x\n", sc ));
        THROW ( CException( sc ) ) ;
    }

    XInterface<ICiCQuerySession> xQuerySession;
    sc = _xDocStore->GetQuerySession( xQuerySession.GetPPointer() );
    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR, "DoCreateQuery - GetQuerySession failed 0x%x\n", sc ));
        THROW ( CException( sc ) ) ;
    }

    //
    // Initialize the query session
    //
    sc = xQuerySession->Init( 0,
                              0,
                              _xDbProperties.GetPointer(),
                              xQueryPropMapper.GetPointer() );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    //
    // Optimize the query
    //

    XQueryOptimizer xqopt( new CQueryOptimizer( xQuerySession,
                                                _xDocStore.GetPointer(),
                                                rstParsed,
                                                cols.GetReference(),
                                                sort.GetPointer(),
                                                pidremap.GetReference(),
                                                Props,
                                                dwQueryStatus ) );

    prxDebugOut(( DEB_ITRACE, "Query has %s1 component%s\n",
                  xqopt->IsMultiCursor() ? "> " : "",
                  xqopt->IsMultiCursor() ? "s" : "" ));
    prxDebugOut(( DEB_ITRACE, "Current component of query %s fully sorted\n",
                  xqopt->IsFullySorted() ? "is" : "is not" ));
    prxDebugOut(( DEB_ITRACE, "Current component of query %s positionable\n",
                  xqopt->IsPositionable() ? "is" : "is not" ));
    prxDebugOut(( DEB_ITRACE, "Rowset props flags: 0x%x\n",
                  Props.GetPropertyFlags() ));
    prxDebugOut(( DEB_ITRACE, "Rowset props maxresults: %d\n",
                  Props.GetMaxResults() ));
    prxDebugOut(( DEB_ITRACE, "Rowset props cmdtimeout: %d\n",
                  Props.GetCommandTimeout() ));

    CPMCreateQueryOut &reply = * (CPMCreateQueryOut *) _Buffer();
    ULONG *aCursors = reply.GetCursors();

    reply.IsWorkIdUnique() = xqopt->IsWorkidUnique();

    reply.SetServerCookie( (ULONG_PTR) this );

    // create either a true sequential or bigtable query

    if ( ( (Props.GetPropertyFlags() & eLocatable) == 0) &&
         ( !xqopt->IsMultiCursor() )             &&
         ( xqopt->IsFullySorted() )              &&
         ( 0 == categ.GetPointer() ) )
    {
        _pQuery = new CSeqQuery( xqopt,
                                 cols,
                                 aCursors,
                                 pidremap,
                                 _xDocStore.GetPointer() );
        reply.IsTrueSequential() = TRUE;
    }
    else
    {
        reply.IsTrueSequential() = FALSE;

        // If we've been instructed to create a synchronous cursor,
        // put the request into a pending state

        BOOL fSync = ( 0 == ( Props.GetPropertyFlags() & eAsynchronous ) );

        XInterface<CRequestServer> xMe;

        if ( fSync )
        {
            // Refcount ourselves in case the async write fails and
            // the request server is recycled before this thread returns.

            AddRef();
            xMe.Set( this );
            state = statePending;
            _state = pipeStatePending;
            _scPendingStatus = S_OK;
            _cbPendingWrite = sizeof CPMCreateQueryOut +
                              ( sizeof ULONG * cCursors );
        }

        TRY
        {
            CRequestQueue & requestQueue = _requestQueue;

            PQuery *pQ = new CAsyncQuery( xqopt,
                                          cols,
                                          sort,
                                          categ,
                                          cCursors,
                                          aCursors,
                                          pidremap,
                                          (Props.GetPropertyFlags() & eWatchable) != 0,
                                          _xDocStore.GetPointer(),
                                          fSync ? this : 0 );

            // If synchronous, the query may be done and freed
            // by the client app by now.  the CRequestServer is still
            // valid due to the AddRef above.

            if ( fSync )
                requestQueue.IncrementPendingItems();
            else
                _pQuery = pQ;
        }
        CATCH( CException, e )
        {
            _pQuery = 0;
            _state = pipeStateRead;
            RETHROW();
        }
        END_CATCH
    }

    cbToWrite = sizeof CPMCreateQueryOut + ( sizeof ULONG * cCursors );

    return state;
} //DoCreateQuery

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoFreeCursor, private
//
//  Synopsis:   Handles a free cursor message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoFreeCursor(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMFreeCursorIn &request = * (CPMFreeCursorIn *) _Buffer();
    CPMFreeCursorOut &reply = * (CPMFreeCursorOut *) _Buffer();

    reply.CursorsRemaining() = _pQuery->FreeCursor( request.GetCursor() );

    // The client is allowed to serially do multiple queries on 1 connection.
    // The way a query is released is by freeing all of its cursors.
    // If this is the last cursor reference to the query, delete the query.

    if ( 0 == reply.CursorsRemaining() )
        FreeQuery();

    cbToWrite = sizeof reply;

    return stateContinue;
} //DoFreeCursor

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetRows, private
//
//  Synopsis:   Handles a get rows message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//              12-Nov-99   KLam       Adjust results for Win64 server to
//                                     Win32 client.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetRows(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMGetRowsIn & request = * (CPMGetRowsIn *) _Buffer();
    request.ValidateCheckSum( GetClientVersion(), cbRequest );

    //  The input buffer must be as large as the parameter buffer
    //  plus the size of the serialized seek description.

    Win4Assert( _BufferSize() >= sizeof CPMGetRowsOut + request.GetSeekSize() );

    if ( _BufferSize() < sizeof CPMGetRowsOut + request.GetSeekSize() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    unsigned cbReserved = request.GetReservedSize();
    unsigned cbRowWidth = request.GetRowWidth();
    unsigned cbClientRead = request.GetReadBufferSize();
    unsigned cRowsToTransfer = request.GetRowsToTransfer();
    BOOL fFwdFetch = request.GetFwdFetch();
    ULONG_PTR ulClientBase = request.GetClientBase();
    ULONG hCursor = request.GetCursor();

    // validate params agains attack

    if ( 0 == cbRowWidth ||
         cbRowWidth > cbClientRead ||
         cbReserved >= cbClientRead )
    {
        Win4Assert( 0 != cbRowWidth );
        Win4Assert( cbRowWidth <= cbClientRead );
        Win4Assert( cbReserved < cbClientRead );
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    // Deserialize the row seek description

    Win4Assert( isQWordAligned( (void*) UIntToPtr( cbReserved ) ) );
    Win4Assert( isQWordAligned( request.GetDesc() ) );
    CMemDeSerStream stmDeser( request.GetDesc(), request.GetSeekSize() );
    XPtr<CRowSeekDescription> pRowSeek;
    UnmarshallRowSeekDescription( stmDeser, GetClientVersion(), pRowSeek, FALSE );

    CPMGetRowsOut *pReply;

    // use a temporary buffer if the client is doing a large read

    if ( cbClientRead <= _BufferSize() )
    {
        pReply = (CPMGetRowsOut *) _Buffer();
    }
    else
    {
        _xTempBuffer.Init( cbClientRead );
        pReply = new( _xTempBuffer.Get() ) CPMGetRowsOut;
    }

    #if CIDBG == 1
        RtlFillMemory( ( (BYTE *) pReply ) + sizeof CPMGetRowsOut,
                         cbClientRead - sizeof CPMGetRowsOut,
                         0xca );
    #endif // CIDBG == 1

    // cbReserved includes room for the the CPMGetRowsOut and the marshalled
    // seek description.  All other space in the buffer is for row data.

    unsigned cbRealRowWidth = cbRowWidth;

#ifdef _WIN64
    if ( !IsClient64() ) // replying to a 32 bit client
        cbRealRowWidth = _cbRowWidth64;
#endif

    CFixedVarBufferAllocator Alloc( pReply,
                                    ulClientBase,
                                    cbClientRead,
                                    cbRealRowWidth,
                                    cbReserved );

    CGetRowsParams Fetch( cRowsToTransfer,
                          fFwdFetch,
                          cbRealRowWidth,
                          Alloc );
    XPtr<CRowSeekDescription> xRowSeekOut;

    SCODE scRet = _pQuery->GetRows( hCursor,
                                    pRowSeek.GetReference(),
                                    Fetch,
                                    xRowSeekOut );

    if ( ( SUCCEEDED( scRet ) ) ||
         ( ( STATUS_BUFFER_TOO_SMALL == scRet ) && ( Fetch.RowsTransferred() > 0 ) ) )
    {
        if ( STATUS_BUFFER_TOO_SMALL == scRet )
            pReply->SetStatus( DB_S_BLOCKLIMITEDROWS );
        else
            pReply->SetStatus( scRet );

        pReply->RowsReturned() = Fetch.RowsTransferred();

#ifdef _WIN64
        if ( !IsClient64() ) // replying to a 32 bit client
        {
            // Reply + CPMGetRowsOut + seek info => table info
            BYTE *pbResults = ((BYTE *)pReply) + cbReserved;

            unsigned cbResults = cbClientRead - cbReserved;
            unsigned cRows = Fetch.RowsTransferred();
            
            //
            // Adjust the sizes of the results to fit for a Win32 client
            //
            FixRows ( (BYTE *)pReply, pbResults, cbResults,
                      ulClientBase, cRows, cbRowWidth );
        }
#endif

        //
        // We can't say everything is ok and fetch 0 rows.  This assert was
        // added because we hit this situation on the client side during
        // stress.
        //

        Win4Assert( ! ( ( S_OK == scRet ) &&
                        ( 0 == Fetch.RowsTransferred() ) ) );

        if ( xRowSeekOut.IsNull() )
        {
            ULONG *pul = (ULONG *) pReply->GetSeekDesc();
            *pul = 0;
        }
        else
        {
            Win4Assert( ( xRowSeekOut->MarshalledSize() +
                          sizeof CPMGetRowsOut ) <= cbReserved );
            CMemSerStream stmMem( pReply->GetSeekDesc(),
                                  xRowSeekOut->MarshalledSize() );
            xRowSeekOut->Marshall( stmMem );
        }

        // Have to transfer the entire buffer since variable data is
        // written from the top of the buffer down, and fixed data from
        // the bottom of the buffer up.

        cbToWrite = cbClientRead;
    }
    else
    {
        // This exception is too commmon in testing...

        QUIETTHROW( CException( scRet ) );
    }

    prxDebugOut(( DEB_ITRACE, "status at end of getrows: 0x%x\n",
                  pReply->GetStatus() ));

    return stateContinue;
} //DoGetRows

#ifdef _WIN64

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::FixRows, private
//
//  Synopsis:   Adjusts Win64 rows into Win32 rows.
//
//  Arguments:  [pbReply]       - Reply buffer
//              [pbResults]     - Buffer containting result data
//              [cbResults]     - Number of bytes in results buffer
//              [ulpClientBase] - Offset of buffer on the client
//              [cRows]         - Count of rows
//              [cbRowWidth]    - Bytes in a row
//
//  History:    12-Nov-99   KLam     created
//
//--------------------------------------------------------------------------
void CRequestServer::FixRows ( BYTE * pbReply,
                               BYTE * pbResults,
                               ULONG cbResults,
                               ULONG_PTR ulpClientBase,
                               ULONG cRows,
                               ULONG cbRowWidth )
{
    prxDebugOut(( DEB_ITRACE,
                  "64bit server replying to 32bit client, fixing rows!\n" ));

    Win4Assert( !IsClient64() );

    unsigned cCols = _xCols64->Count();
    
    // Save the result buffer
    BYTE *pbCurrentResults = new BYTE[cbResults];
    XPtrST<BYTE> xbCurrentResults( pbCurrentResults );

    prxDebugOut(( DEB_ITRACE, 
                  "\tCopying %d bytes from 0x%I64x to 0x%I64x\n",
                  cbResults, pbResults, pbCurrentResults ));

    memcpy( pbCurrentResults, pbResults, cbResults );

#if CIDBG == 1
    RtlFillMemory( pbResults,
                   cRows * _cbRowWidth64,
                   0xba );
#endif  // CIDBG == 1

    prxDebugOut(( DEB_ITRACE, 
                  "\tReturning %d rows and %d cols each row being %d bytes (32bit: %d) for a total of %d in a %d bytes buffer\n",
                  cRows, cCols, _cbRowWidth64, cbRowWidth, cRows * _cbRowWidth64, cbResults ));

    prxDebugOut(( DEB_ITRACE, 
                  "\t64bit results are at: 0x%I64x 32bit results will be at: 0x%I64x\n",
                  pbCurrentResults, pbResults ));

    // Fix the results
    for ( unsigned iRow = 0; iRow < cRows; iRow++ )
    {
        prxDebugOut(( DEB_ITRACE, "\n\tRow: %d   Reply Buffer: 0x%I64x  Data Buffer: 0x%I64x\n",
                      iRow, pbCurrentResults, pbResults ));
        for ( unsigned iCol = 0; iCol < cCols; iCol++ )
        {
            prxDebugOut(( DEB_ITRACE, "\n\t\tColumn: %d\n", iCol ));
            prxDebugOut(( DEB_ITRACE, "\t\t_xCols64 0x%I64x\t_xCols32 0x%I64x\n", 
                          _xCols64.GetPointer(), _xCols32.GetPointer() ));

            CTableColumn *pCol64 = _xCols64->Get(iCol);
            CTableColumn *pCol32 = _xCols32->Get(iCol);

            if ( pCol64->IsValueStored() )
            {
                ULONG cbSize32 = 0;
                if ( pCol64->GetStoredType() == VT_VARIANT )
                {
                    PROPVARIANT *pVar64 = (PROPVARIANT *) (pbCurrentResults + pCol64->GetValueOffset());
                    PROPVARIANT32 *pVar32 = (PROPVARIANT32 *) (pbResults + pCol32->GetValueOffset());

                    prxDebugOut(( DEB_ITRACE,
                                  "\t\t Col64 Data: 0x%I64x Offset: %d Col32 Data: 0x%I64x Offset: %d\n", 
                                  pVar64, pCol64->GetValueOffset(), pVar32, pCol32->GetValueOffset() ));

                    cbSize32 = sizeof( PROPVARIANT32 ) + 
                               ((CTableVariant *)pVar64)->VarDataSize32( pbReply, ulpClientBase );
                    pVar32->wReserved2 = (WORD) cbSize32;

                    FixVariantPointers ( pVar32, pVar64, pbReply, ulpClientBase );
                }
                else if ( pCol64->GetStoredType() == VT_I4 )
                {
                    ULONG *pul64 = (ULONG *) (pbCurrentResults + pCol64->GetValueOffset());
                    ULONG *pul32 = (ULONG *) (pbResults + pCol32->GetValueOffset());

                    prxDebugOut(( DEB_ITRACE,
                                  "\t\t VT_I4: %d Col64 Data: 0x%I64x Offset: %d Col32 Data: 0x%I64x Offset: %d\n", 
                                  *pul64, pul64, pCol64->GetValueOffset(), pul32, pCol32->GetValueOffset() ));

                    cbSize32 = 4;
                    *pul32 = *pul64;
                }
                else
                {
                    // Unhandled type
                    Win4Assert ( pCol64->GetStoredType() == VT_I4 ||
                                 pCol64->GetStoredType() == VT_VARIANT );

                }

                if ( pCol64->IsStatusStored() )
                {
                    BYTE *pbStatus64 = (BYTE *) (pbCurrentResults + pCol64->GetStatusOffset());
                    BYTE *pbStatus32 = (BYTE *) (pbResults + pCol32->GetStatusOffset());
                    *pbStatus32 = *pbStatus64;
                    prxDebugOut (( DEB_ITRACE, "\t\tStatus = 0x%x\n", *pbStatus32 ));
                }

                if ( pCol64->IsLengthStored() )
                {
                    LONG *plLength64 = (LONG *) (pbCurrentResults + pCol64->GetLengthOffset());
                    LONG *plLength32 = (LONG *) (pbResults + pCol32->GetLengthOffset());
                    prxDebugOut (( DEB_ITRACE, "\t\tSize32 = %d Size64 = %d\n", cbSize32, *plLength64  ));
                    *plLength32 = cbSize32;
                    prxDebugOut (( DEB_ITRACE, "\t\tLength = %d\n", *plLength32 ));
                }
            }
        }
        
        // Move to the next row
        pbResults += cbRowWidth;
        pbCurrentResults += _cbRowWidth64;
    }
}  // FixRows

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::FixVariantPointers, private
//
//  Synopsis:   Adjusts Win64 variants to fit into Win32 variants.
//
//  Arguments:  [pVar32]        - Pointer to 32 bit variant
//              [pVar64]        - Pointer to 64 bit variant
//              [pbResults]     - Buffer containing variant data
//              [ulClientBase]  - Offset of buffer on the client
//
//  History:    21-Oct-99   KLam     created
//              13-Feb-2000 KLam     assert needed to check element not pointer
//              15-Feb-2000 DLee     DECIMAL is special case (16 bits)
//
//--------------------------------------------------------------------------

void CRequestServer::FixVariantPointers ( PROPVARIANT32 *pVar32,
                                          PROPVARIANT *pVar64,
                                          BYTE *pbResults,
                                          ULONG_PTR ulClientBase )
{
    pVar32->vt = pVar64->vt;

    // reference or a vector or an array
    if ( CTableVariant::IsByRef ( pVar64->vt ) || 0 != (pVar64->vt & (VT_VECTOR | VT_ARRAY)) )
    {
        // blob used here as a generic holder for a size and pointer
        pVar32->blob.cbSize = pVar64->blob.cbSize;
        pVar32->blob.pBlob = (PTR32)(UINT_PTR) (pVar64->blob.pBlobData);

        prxDebugOut(( DEB_ITRACE,
                      "\t\t Fixing reference. ClientBase: 0x%I64x Buffer: 0x%I64x at 0x%x\n", 
                      ulClientBase, pbResults, pVar32->blob.pBlob ));

        if ( VT_LPWSTR == pVar64->vt ||
             VT_LPSTR == pVar64->vt ||
             VT_BSTR == pVar64->vt )
            prxDebugOut(( DEB_ITRACE, "\t\tvt: %d pStr: 0x%I64x\n",
                          pVar64->vt,
                          ((UINT_PTR)pVar64->calpwstr.pElems - ulClientBase) + pbResults ));
        else
            prxDebugOut(( DEB_ITRACE, "\t\tvt: %d size: 0x%I64x pBlob: 0x%I64x\n",
                          pVar64->vt, pVar64->blob.cbSize, pVar64->blob.pBlobData ));

        // Vector of strings
        if ( (VT_VECTOR|VT_LPWSTR) == pVar64->vt ||
             (VT_VECTOR|VT_LPSTR) == pVar64->vt ||
             (VT_VECTOR|VT_BSTR) == pVar64->vt )
        {
            // Get a pointer to the vector in the variable section of the return buffer
            void ** ppvVector = (void **)( ((UINT_PTR)pVar64->calpwstr.pElems - ulClientBase ) + pbResults );
            ULONG * pulVector = (ULONG *) ppvVector;

            prxDebugOut(( DEB_ITRACE, "\t\t Fixing vector 0x%I64x\n", ppvVector ));

            for ( unsigned iElement = 0; iElement < pVar64->calpwstr.cElems; ++iElement )
                pulVector[iElement] = (ULONG) (UINT_PTR) (ppvVector[iElement]);
        }
        // Vector of variants
        else if ( (VT_VARIANT|VT_VECTOR) == pVar64->vt ) // not currently supported
        {
            PROPVARIANT * pVarVector64 = (PROPVARIANT *)( ((UINT_PTR)pVar64->capropvar.pElems - ulClientBase ) + pbResults );
            PROPVARIANT32 * pVarVector32 = (PROPVARIANT32 *) pVarVector64;

            // Recursively fix each variant in the vector
            for ( unsigned iVarElement = 0; iVarElement < pVar64->capropvar.cElems; ++iVarElement )
                FixVariantPointers ( &pVarVector32[iVarElement],
                                     &pVarVector64[iVarElement],
                                     pbResults,
                                     ulClientBase );
        }
        // Arrays (Safearrays)
        else if ( ( 0 != (VT_ARRAY & pVar64->vt) ) || 
                  ( VT_SAFEARRAY == (pVar64->vt & VT_TYPEMASK) ) )
        {
            // Get a pointer to the vector in the variable section of the return buffer
            SAFEARRAY * psa = (SAFEARRAY *)(( (UINT_PTR)pVar64->pparray - ulClientBase ) + pbResults );
            SAFEARRAY32 * psa32 = (SAFEARRAY32 *) psa;
            psa32->pvData = (PTR32) (UINT_PTR) psa->pvData;
            // memmove is smart enough to move the overlapping bytes first
            memmove ( psa32->rgsabound, 
                      psa->rgsabound, 
                      psa32->cDims * sizeof (SAFEARRAYBOUND) );

            if ( VT_BSTR == (pVar64->vt & VT_TYPEMASK) )
            {
                // Pointing to an array of 32bit pointers so adjust the size
                psa32->cbElements = sizeof ( PTR32 ); 

                // Get the number of elements in the safe array
                unsigned cBstrElements = psa32->rgsabound[0].cElements;
                for ( unsigned j = 1; j < psa32->cDims; j++ )
                    cBstrElements *= psa32->rgsabound[j].cElements;

                ULONG *pulBstr = (ULONG *) ((psa32->pvData - ulClientBase) + pbResults );
                void **ppvBstr = (void **) pulBstr;

                for ( j = 0; j < cBstrElements; j++ )
                {
                    // Make sure Win64 isn't passing to big of a pointer
                    if ( 0 != (((ULONG_PTR)ppvBstr[j]) & 0xFFFFFFFF00000000) )
                    {
                        prxDebugOut(( DEB_ERROR, "Non 32 bit pointer 0x%I64x !!!\n",
                                      (ULONG_PTR)ppvBstr[j] ));
                        Win4Assert( 0 == (((ULONG_PTR)ppvBstr[j]) & 0xFFFFFFFF00000000) );
                    }

                    pulBstr[j] = (ULONG) (ULONG_PTR) ppvBstr[j];
                }
            }
            else if ( VT_VARIANT == (pVar64->vt & VT_TYPEMASK) )
            {
                // Pointing to an array of 32bit variants so adjust the size
                psa32->cbElements = sizeof ( PROPVARIANT32 ); 

                // Get the number of elements in the safe array
                unsigned cVariants = psa32->rgsabound[0].cElements;
                for ( unsigned j = 1; j < psa32->cDims; j++ )
                    cVariants *= psa32->rgsabound[j].cElements;

                PROPVARIANT * avar64 = (PROPVARIANT *) ((psa32->pvData - ulClientBase) + pbResults );
                PROPVARIANT32 * avar32 = (PROPVARIANT32 *) avar64;

                prxDebugOut(( DEB_ITRACE, "\t\t Found %d Variants at 0x%I64x\n", cVariants, avar64 ));

                // Recursively fix each variant in the array
                for ( unsigned v = 0; v < cVariants; v++ )
                    FixVariantPointers ( &avar32[v],
                                         &avar64[v],
                                         pbResults,
                                         ulClientBase );
            }
        }
    }
    else if ( VT_DECIMAL == pVar64->vt )
    {
        RtlCopyMemory ( pVar32, pVar64, sizeof PROPVARIANT32 );
    }
    else
    {
        pVar32->uhVal = (ULONGLONG)(UINT_PTR) pVar64->pulVal;

        prxDebugOut(( DEB_ITRACE, "\t\tvt: %d value: 0x%I64x\n\n",
                      pVar64->vt, pVar64->uhVal ));
    }
} //FixVariantPointers
#endif // _WIN64

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoRestartPosition, private
//
//  Synopsis:   Handles a restart position message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    17-Apr-97   emilyb     created
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoRestartPosition(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMRestartPositionIn & request = * (CPMRestartPositionIn *) _Buffer();

    _pQuery->RestartPosition( request.GetCursor(),
                              request.GetChapter() );

    return stateContinue;
} //DoRestartPosition

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoStopAsynch, private
//
//  Synopsis:   Handles a stop processing of async rowset message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    17-Apr-97   emilyb     created
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoStopAsynch(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMStopAsynchIn & request = * (CPMStopAsynchIn *) _Buffer();

    _pQuery->StopAsynch( request.GetCursor() );

    return stateContinue;
} //DoStopAsynch

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoStartWatching, private
//
//  Synopsis:   Handles a start watch all behavior for rowset message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    17-Apr-97   emilyb     created
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoStartWatching(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMStartWatchingIn & request = * (CPMStartWatchingIn *) _Buffer();

    _pQuery->StartWatching( request.GetCursor() );

    return stateContinue;
} //DoStartWatching

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoStopWatching, private
//
//  Synopsis:   Handles a stop watch all behavior for rowset message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    17-Apr-97   emilyb     created
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoStopWatching(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMStopWatchingIn & request = * (CPMStopWatchingIn *) _Buffer();

    _pQuery->StopWatching( request.GetCursor() );

    return stateContinue;
} //DoStopWatching

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoRatioFinished, private
//
//  Synopsis:   Handles a ratio finished message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoRatioFinished(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMRatioFinishedIn &request = * (CPMRatioFinishedIn *) _Buffer();
    CPMRatioFinishedOut &reply = * (CPMRatioFinishedOut *) _Buffer();

    DBCOUNTITEM den, num, rows;

    _pQuery->RatioFinished( request.GetCursor(),
                            den,
                            num,
                            rows,
                            reply.NewRows() );

    reply.Denominator() = (ULONG) den;
    reply.Numerator() = (ULONG) num;
    reply.RowCount() = (ULONG) rows;

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoRatioFinished

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoCompareBmk, private
//
//  Synopsis:   Handles a compare bookmark message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoCompareBmk(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMCompareBmkIn &request = * (CPMCompareBmkIn *) _Buffer();
    CPMCompareBmkOut &reply = * (CPMCompareBmkOut *) _Buffer();

    _pQuery->Compare( request.GetCursor(),
                      request.GetChapter(),
                      request.GetBmkFirst(),
                      request.GetBmkSecond(),
                      reply.Comparison() );

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoCompareBmk

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetApproximatePosition, private
//
//  Synopsis:   Handles a get approximate position message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetApproximatePosition(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMGetApproximatePositionIn &request = * (CPMGetApproximatePositionIn *)_Buffer();
    CPMGetApproximatePositionOut &reply = * (CPMGetApproximatePositionOut *)_Buffer();

    DBCOUNTITEM cNum,cDen;

    _pQuery->GetApproximatePosition( request.GetCursor(),
                                     request.GetChapter(),
                                     request.GetBmk(),
                                     & cNum,
                                     & cDen );

    reply.Numerator() = (ULONG) cNum;
    reply.Denominator() = (ULONG) cDen;

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoGetApproximatePosition

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoSetBindings, private
//
//  Synopsis:   Handles a set bindings message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//              05-Oct-99   KLam       Handle Win32 client to Win64 server
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoSetBindings(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    Win4Assert( 0 != _pQuery || IsBeingRemoved() );

    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    // The request is either in the standard buffer or the temp buffer.
    // Take ownership of the temp buffer.

    CPMSetBindingsIn &request = * (CPMSetBindingsIn *) _ActiveBuffer();
    XPtrST<BYTE> xTemp( _xTempBuffer.Acquire() );

    Win4Assert( isQWordAligned( request.GetDescription() ) );

    request.ValidateCheckSum( GetClientVersion(), cbRequest );

    CMemDeSerStream stmDeser( request.GetDescription(),
                              request.GetBindingDescLength() );

    XPtr<CPidMapper> Pidmap( new CPidMapper() );

    XPtr<CTableColumnSet> Cols( new CTableColumnSet ( stmDeser,
                                                      Pidmap.GetReference() ) );

#ifdef _WIN64    

    // Create a new TableColumnSet with 64-bit sizes
    if ( !IsClient64() )
    {
        prxDebugOut(( DEB_ITRACE, "32bit client querying 64bit server, fixing columns!\n" ));

        //
        // The client gave us a 32-bit column description
        // Fix the column descriptions to work on Win64
        //
        FixColumns ( Cols.Acquire() );

        _cbRowWidth32 = request.GetRowLength();

        // SetBindings with the 64 bit table
        _pQuery->SetBindings( request.GetCursor(),
                              _cbRowWidth64,
                              _xCols64.GetReference(),
                              Pidmap.GetReference() );

        prxDebugOut(( DEB_ITRACE, "\tRow Length: Win32 %d Win64 %d\n", _cbRowWidth32, _cbRowWidth64 ));
        prxDebugOut(( DEB_ITRACE, "\t\t_xCols64 0x%I64x\n\t\t_xCols32 0x%I64x\n", 
                      _xCols64.GetPointer(), _xCols32.GetPointer() ));
    }
    else
    {
#endif

    _pQuery->SetBindings( request.GetCursor(),
                          request.GetRowLength(),
                          Cols.GetReference(),
                          Pidmap.GetReference() );

#ifdef _WIN64
    }
#endif

    return stateContinue;


} //DoSetBindings

#ifdef _WIN64
//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::FixColumns, private
//
//  Synopsis:   Adjusts a Win32 column description to a Win64 column description
//              and saves both descriptions
//
//  Arguments:  [pCols32]   - 32 bit table column set description
//
//  History:    12-Nov-99   KLam       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::FixColumns ( CTableColumnSet * pCols32 )
{
    USHORT iEnd = 0;
    USHORT iAlignment;

    // Make sure these were freed from FreeQuery
    if ( !_xCols64.IsNull() && !_xCols32.IsNull() )
        THROW ( CException( STATUS_INVALID_PARAMETER ) );

    // Create a 64 bit column description
    _xCols64.Set( new CTableColumnSet ( pCols32->Count() ) );
    _xCols32.Set( pCols32 );

    for (unsigned iCol = 0; iCol < _xCols32->Count(); iCol++)
    {
        CTableColumn *pColumn = _xCols32->Get(iCol);

        VARTYPE vt = pColumn->GetStoredType();

        Win4Assert ( VT_VARIANT == vt|| VT_I4 == vt );

        XPtr<CTableColumn> xColumn64 (new CTableColumn( iCol ));

        if ( pColumn->IsValueStored() )
        {

            prxDebugOut(( DEB_ITRACE, 
                          "\n\tFound value type: %d width: %d offset: %d\n",
                          pColumn->GetStoredType(), pColumn->GetValueSize(), pColumn->GetValueOffset() ));

            if ( VT_VARIANT == vt )
            {
                iAlignment = (USHORT)AlignBlock ( iEnd, sizeof(LONGLONG) );
                iEnd = iAlignment + sizeof (PROPVARIANT);

                xColumn64->SetValueField( VT_VARIANT,
                                          iAlignment,
                                          sizeof (PROPVARIANT) );
            }
            else if ( VT_I4 == vt )
            {
                iAlignment = (USHORT)AlignBlock ( iEnd, sizeof(ULONG) );
                iEnd = iAlignment + sizeof (ULONG);

                xColumn64->SetValueField( VT_I4,
                                          iAlignment,
                                          sizeof (ULONG) );
            }

            prxDebugOut(( DEB_ITRACE, 
                          "\t  Replacing with width: %d offset: %d\n",
                          xColumn64->GetValueSize(), xColumn64->GetValueOffset() )); 
        }

        if ( pColumn->IsStatusStored() )
        {
            prxDebugOut(( DEB_ITRACE, 
                          "\tFound status width: %d offset: %d\n",
                          pColumn->GetStatusSize(), pColumn->GetStatusOffset() ));

            iAlignment = (USHORT)AlignBlock ( iEnd, sizeof (BYTE) );
            iEnd = iAlignment + sizeof (BYTE);

            xColumn64->SetStatusField( iAlignment, sizeof (BYTE) );

            prxDebugOut(( DEB_ITRACE, 
                          "\t  Replacing with width: %d offset: %d\n",
                          xColumn64->GetStatusSize(), xColumn64->GetStatusOffset() )); 
        }

        if ( pColumn->IsLengthStored() )
        {
            prxDebugOut(( DEB_ITRACE, 
                          "\tFound length width: %d offset: %d\n",
                          pColumn->GetLengthSize(), pColumn->GetLengthOffset() ));

            iAlignment = (USHORT)AlignBlock ( iEnd, sizeof (ULONG) );
            iEnd = iAlignment + sizeof (ULONG);

            xColumn64->SetLengthField( iAlignment, sizeof (ULONG) );

            prxDebugOut(( DEB_ITRACE, 
                          "\t  Replacing with width: %d offset: %d\n",
                          xColumn64->GetLengthSize(), xColumn64->GetLengthOffset() )); 
        }

        // Store the column in the column set
        _xCols64->Add( xColumn64.GetPointer(), iCol );
        xColumn64.Acquire();
    }

    _cbRowWidth64 = AlignBlock( iEnd, sizeof(ULONGLONG) );

} // FixColumns
#endif // _WIN64

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetNotify, private
//
//  Synopsis:   Handles a get notify message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetNotify(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    // _pQuery will be zero if the notify thread comes in after the last
    // FreeCursor.  This is a rare non-fatal condition and it is ok to
    // throw an error.

    if ( 0 == _pQuery )
        QUIETTHROW( CException( STATUS_INVALID_PARAMETER ) );

    CProxyMessage &msg = * (CProxyMessage *) _Buffer();
    Win4Assert( pmGetNotify == msg.GetMessage() );

    CNotificationSync sync( this );
    DBWATCHNOTIFY wn;
    SCODE sc = _pQuery->GetNotifications( sync, wn );

    // If STATUS_PENDING, just return the pmGetNotify and the client will
    // be expecting 0 or 1 pmSendNotify messages at some later time.
    // Otherwise, the notification is available and it is returned here.

    if ( STATUS_PENDING != sc )
    {
        Win4Assert( S_OK == sc ); // GetNotifications throws on failure

        CPMSendNotifyOut *pReply = new( _Buffer() ) CPMSendNotifyOut( wn );
        cbToWrite = sizeof CPMSendNotifyOut;
    }

    return stateContinue;
} //DoGetNotify

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoSendNotify, private
//
//  Synopsis:   Handles a send notify message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoSendNotify(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    Win4Assert( FALSE && !"pmSendNotify is server to client only!" );
    return stateDisconnect;
} //DoSendNotify

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoSetWatchMode, private
//
//  Synopsis:   Handles a set watch mode message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoSetWatchMode(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMSetWatchModeIn &request = * (CPMSetWatchModeIn *) _Buffer();

    HWATCHREGION hRegion = request.GetRegion();
    _pQuery->SetWatchMode( &hRegion, request.GetMode() );

    CPMSetWatchModeOut &reply = * (CPMSetWatchModeOut *) _Buffer();
    reply.Region() = hRegion;
    cbToWrite = sizeof reply;

    return stateContinue;
} //DoSetWatchMode

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetWatchInfo, private
//
//  Synopsis:   Handles a get watch info message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetWatchInfo(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMGetWatchInfoIn &request = * (CPMGetWatchInfoIn *) _Buffer();
    CPMGetWatchInfoOut &reply = * (CPMGetWatchInfoOut *) _Buffer();

    DBCOUNTITEM cRows;

    _pQuery->GetWatchInfo( request.GetRegion(),
                           & reply.Mode(),
                           & reply.Chapter(),
                           & reply.Bookmark(),
                           & cRows );

    reply.RowCount() = (ULONG) cRows;

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoGetWatchInfo

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoShrinkWatchRegion, private
//
//  Synopsis:   Handles a shrink watch region message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoShrinkWatchRegion(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMShrinkWatchRegionIn &request = * (CPMShrinkWatchRegionIn *) _Buffer();

    _pQuery->ShrinkWatchRegion( request.GetRegion(),
                                request.GetChapter(),
                                request.GetBookmark(),
                                request.GetRowCount() );

    return stateContinue;
} //DoShrinkWatchRegion

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoRefresh, private
//
//  Synopsis:   Handles a refresh message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoRefresh(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    _pQuery->Refresh();

    return stateContinue;
} //DoRefresh

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetQueryStatus, private
//
//  Synopsis:   Handles a get query status message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetQueryStatus(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMGetQueryStatusIn &request = * (CPMGetQueryStatusIn *) _Buffer();
    CPMGetQueryStatusOut &reply = * (CPMGetQueryStatusOut *) _Buffer();

    _pQuery->GetQueryStatus( request.GetCursor(),
                             reply.QueryStatus() );

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoGetQueryStatus

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoGetQueryStatusEx, private
//
//  Synopsis:   Handles a get query status message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoGetQueryStatusEx(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMGetQueryStatusExIn &request = * (CPMGetQueryStatusExIn *) _Buffer();
    CPMGetQueryStatusExOut &reply = * (CPMGetQueryStatusExOut *) _Buffer();

    DBCOUNTITEM den, num, iBmk, cRows;

    _pQuery->GetQueryStatusEx( request.GetCursor(),
                               reply.QueryStatus(),
                               reply.FilteredDocuments(),
                               reply.DocumentsToFilter(),
                               den,
                               num,
                               request.GetBookmark(),
                               iBmk,
                               cRows );

    reply.RatioFinishedDenominator() = (ULONG) den;
    reply.RatioFinishedNumerator() = (ULONG) num;
    reply.RowBmk() = (ULONG) iBmk;
    reply.RowsTotal() = (ULONG) cRows;

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoGetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoCiState, private
//
//  Synopsis:   Handles a ci state message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoCiState(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    CPMCiStateInOut &request = * (CPMCiStateInOut *) _Buffer();

    if ( _xDocStore.IsNull() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    XInterface<IFsCiAdmin> xFsCiAdmin;
    SCODE sc = _xDocStore->QueryInterface( IID_IFsCiAdmin,
                                           xFsCiAdmin.GetQIPointer() );

    if ( S_OK == sc )
    {
        sc = xFsCiAdmin->CiState( &(request.GetState()) );
        request.SetStatus( sc );
    }

    cbToWrite = sizeof CProxyMessage + request.GetState().cbStruct;
    return stateContinue;
} //DoCiState

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoObsolete, private
//
//  Synopsis:   Handles an obsolete message
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoObsolete(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    // This request is obsolete

    THROW( CException( STATUS_INVALID_PARAMETER ) );
    return stateDisconnect;
} //DoObsolete

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoForceMerge, private
//
//  Synopsis:   Handles a force merge message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoForceMerge(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    VerifyThreadHasAdminPrivilege();

    if ( _xDocStore.IsNull() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMForceMergeIn &request = * (CPMForceMergeIn *) _Buffer();

    XInterface<IFsCiAdmin> xFsCiAdmin;
    SCODE sc = _xDocStore->QueryInterface( IID_IFsCiAdmin,
                                           xFsCiAdmin.GetQIPointer() );

    if ( SUCCEEDED(sc) )
        sc = xFsCiAdmin->ForceMerge( request.GetPartID() );

    if ( !SUCCEEDED(sc) )
        THROW( CException(sc) );

    return stateContinue;
} //DoForceMerge

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoAbortMerge, private
//
//  Synopsis:   Handles an abort merge message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoAbortMerge(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    VerifyThreadHasAdminPrivilege();

    if ( _xDocStore.IsNull() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMAbortMergeIn &request = * (CPMAbortMergeIn *) _Buffer();

    XInterface<IFsCiAdmin> xFsCiAdmin;
    SCODE sc = _xDocStore->QueryInterface( IID_IFsCiAdmin,
                                           xFsCiAdmin.GetQIPointer() );

    if ( SUCCEEDED(sc) )
        sc = xFsCiAdmin->AbortMerge( request.GetPartID() );

    if ( !SUCCEEDED(sc) )
        THROW( CException(sc) );

    return stateContinue;
} //DoAbortMerge

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoSetCatState, private
//
//  Synopsis:   Handles a SetCiCatState message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    14-Apr-98   kitmanh       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoSetCatState(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    ciDebugOut(( DEB_ITRACE, "DoSetCatState is called\n" ));
    VerifyThreadHasAdminPrivilege();

    CPMSetCatStateIn &request = * (CPMSetCatStateIn *) _Buffer();
    CPMSetCatStateOut &reply = * (CPMSetCatStateOut *) _Buffer();

    XInterface<ICiCDocStoreLocator> xLocator( _requestQueue.DocStoreLocator() );
    Win4Assert( !xLocator.IsNull() );

    BOOL fAbsUnWritable = FALSE; //temp value
    DWORD dwOldState;

    // hack to check if all catalogs are up, catalog name is ignored
    if ( CICAT_ALL_OPENED == request.GetNewState() )
    {
        reply.GetOldState() = _requestQueue.AreDocStoresOpen(); // make a constant
        cbToWrite = sizeof reply;
        return stateContinue;
    }
    // end of hack

    ICiCDocStore * pDocStore = 0;

    // Make sure we have a valid catalog name

    WCHAR *szCatalog = request.GetCatName();

    if ( 0 == szCatalog )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    unsigned cwc = wcslen( szCatalog );

    if ( ( 0 == cwc) || ( cwc >= ( MAX_PATH-1 ) ) )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    // check old state of docstore

    SCODE sc = xLocator->GetDocStoreState( szCatalog,
                                           &pDocStore,
                                           &dwOldState );
    reply.GetOldState() = dwOldState;

    if ( SUCCEEDED(sc) )
    {
        _xDocStore.Set( pDocStore );

        if ( 0 != pDocStore )
        {
            // This QI is just about guaranteed to work.

            XInterface<ICiCAdviseStatus> xAdviseStatus;

            sc = pDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                            xAdviseStatus.GetQIPointer() );
            if ( S_OK != sc )
                THROW( CException(sc) );

            xAdviseStatus->IncrementPerfCounterValue( CI_PERF_RUNNING_QUERIES );
        }

        //Push an item onto the _stateChangeArray for the (make this a function name DoDisConnect

        SCWorkItem newItem;

        ciDebugOut(( DEB_ITRACE, "request.GetNewState == %d\n", request.GetNewState() ));

        switch ( request.GetNewState() )
        {
            case CICAT_GET_STATE:
                break;
            case CICAT_STOPPED:
                if ( 0 == (CICAT_STOPPED & dwOldState) )
                {
                    newItem.type = eStopCat;
                    newItem.pDocStore = _xDocStore.GetPointer();
                    _requestQueue.AddSCItem( &newItem , 0 );
                    xLocator->AddStoppedCat( dwOldState, request.GetCatName() );
                    CLock lock( g_mtxStartStop );
                    sc = StopFWCiSvcWork( eStopCat );
                }

                break;

            case CICAT_READONLY:
                ciDebugOut(( DEB_ITRACE, "New state is CICAT_READONLY\n" ));
                if ( 0 == (CICAT_READONLY & dwOldState) )
                {
                    newItem.type = eCatRO;
                    newItem.pDocStore = _xDocStore.GetPointer();

                    if ( 0 != (CICAT_STOPPED & dwOldState) )
                    {
                        ciDebugOut(( DEB_ITRACE, "DoSetCatState, restarting a stopped cat\n" ));
                        ciDebugOut(( DEB_ITRACE, "DoSetCatState.. newItem.StoppedCat is %ws\n", request.GetCatName() ));
                        _requestQueue.AddSCItem( &newItem, request.GetCatName() );
                    }
                    else
                        _requestQueue.AddSCItem( &newItem , 0 );

                    CLock lock( g_mtxStartStop );
                    sc = StopFWCiSvcWork( eCatRO );
                }

                ciDebugOut(( DEB_ITRACE, "Done setting CICAT_READONLY\n" ));
                break;

            case CICAT_WRITABLE:

                if ( 0 == (CICAT_WRITABLE & dwOldState) )
                {
                    sc = xLocator->IsMarkedReadOnly( request.GetCatName(), &fAbsUnWritable );
                    if ( FAILED(sc) )
                        THROW( CException(sc) );

                    ciDebugOut(( DEB_ITRACE, "DoSetCatState.. IsMarkedReadOnly is %d\n", fAbsUnWritable ));

                    if ( CICAT_STOPPED == dwOldState )
                    {
                        if ( !fAbsUnWritable )
                        {
                            sc = xLocator->IsVolumeOrDirRO( request.GetCatName(), &fAbsUnWritable );
                            if ( FAILED(sc) )
                                THROW( CException(sc) );
                        }

                        ciDebugOut(( DEB_ITRACE, "DoSetCatState.. fAbsUnWritable is %d\n", fAbsUnWritable ));
                    }

                    if ( fAbsUnWritable )
                    {
                        //Catalog cannot be open for r/w, open as r/o instead
                        //can't throw, must finish work
                        newItem.type = eCatRO;
                    }
                    else
                        newItem.type = eCatW;

                    newItem.pDocStore = _xDocStore.GetPointer();
                    if ( CICAT_STOPPED == dwOldState )
                    {
                        ciDebugOut(( DEB_ITRACE, "DoSetCatState, restarting a stopped cat\n" ));
                        ciDebugOut(( DEB_ITRACE, "DoSetCatState.. newItem.StoppedCat is %ws\n", request.GetCatName() ));
                        _requestQueue.AddSCItem( &newItem, request.GetCatName() );
                    }
                    else
                        _requestQueue.AddSCItem( &newItem, 0 );

                    CLock lock( g_mtxStartStop );
                    sc = StopFWCiSvcWork( newItem.type );
                }

                break;

            case CICAT_NO_QUERY:
                if ( 0 == (CICAT_NO_QUERY & dwOldState) )
                {
                    newItem.type = eNoQuery;

                    sc = xLocator->IsMarkedReadOnly( request.GetCatName(), &fAbsUnWritable );
                    if ( FAILED(sc) )
                        THROW( CException(sc) );

                    ciDebugOut(( DEB_ITRACE, "DoSetCatState.. IsMarkedReadOnly is %d\n", fAbsUnWritable ));

                    if ( 0 != (CICAT_STOPPED & dwOldState) )
                    {
                        if ( !fAbsUnWritable )
                        {
                            sc = xLocator->IsVolumeOrDirRO( request.GetCatName(), &fAbsUnWritable );
                            if ( FAILED(sc) )
                                THROW( CException(sc) );
                        }
                        ciDebugOut(( DEB_ITRACE, "DoSetCatState(NoQuery).. fAbsUnWritable is %d\n", fAbsUnWritable ));
                    }

                    if ( fAbsUnWritable )
                    {
                        //The catalog is absolutely unwritable, opening for ReadOnly instead
                        //can't throw here, since work needs to be done.
                        newItem.fNoQueryRW = FALSE;
                    }
                    else
                        newItem.fNoQueryRW = TRUE;

                    newItem.pDocStore = _xDocStore.GetPointer();
                    if ( 0 != (CICAT_STOPPED & dwOldState) )
                        _requestQueue.AddSCItem( &newItem, request.GetCatName() );
                    else
                        _requestQueue.AddSCItem( &newItem, 0 );

                    CLock lock( g_mtxStartStop );
                    sc = StopFWCiSvcWork( newItem.type );
                }
                break;

            default:
                THROW( CException( STATUS_INVALID_PARAMETER ) );
        }
    }

    ciDebugOut(( DEB_ITRACE, "DoSetCatState sc is %d or %#x\n", sc ));

    if ( !SUCCEEDED(sc) )
        THROW( CException(sc) );

    cbToWrite = sizeof reply;
    return stateContinue;
} //DoSetCatState


//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoFetchValue, private
//
//  Synopsis:   Retrieves a value from the property cache
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoFetchValue(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMFetchValueIn &request = * (CPMFetchValueIn *) _Buffer();
    request.ValidateCheckSum( GetClientVersion(), cbRequest );

    WORKID wid = request.GetWID();
    DWORD cbSoFar = request.GetSoFar();
    DWORD cbPropSpec = request.GetPSSize();
    DWORD cbChunk = request.GetChunkSize();

    // if this is the first request for the value, fetch the value

    if ( 0 == cbSoFar )
    {
        _xFetchedValue.Free();
        _cbFetchedValueSoFar = 0;

        Win4Assert( isQWordAligned( request.GetPS() ) );
        CMemDeSerStream stmDeser( request.GetPS(), cbPropSpec );
        CFullPropSpec ps( stmDeser );
        if ( !ps.IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );

        PROPVARIANT var;
        if ( !_pQuery->FetchDeferredValue( wid, ps, var ) || var.vt == VT_EMPTY )
        {
            //
            // FetchDeferredValue does a security check to make sure the client has access
            // to this wid.  A hacker could pass in a wid not returned in a query.
            //
            CPMFetchValueOut &reply = * (CPMFetchValueOut *) _Buffer();
            reply.ValueExists() = FALSE;
            cbToWrite = sizeof reply;
            return stateContinue;
        }

        // marshall the property value and save it in _xFetchedValue

        SPropVariant xvar( &var );
        ULONG cb = 0;
        StgConvertVariantToProperty( &var,
                                     CP_WINUNICODE,
                                     0,
                                     &cb,
                                     pidInvalid,
                                     FALSE,
                                     0 );
        _xFetchedValue.Init( cb );
        StgConvertVariantToProperty( &var,
                                     CP_WINUNICODE,
                                     (SERIALIZEDPROPERTYVALUE *)_xFetchedValue.Get(),
                                     &cb,
                                     pidInvalid,
                                     FALSE,
                                     0 );
    }

    // send a chunk (or all) of the marshalled property value

    Win4Assert( cbSoFar == _cbFetchedValueSoFar );
    Win4Assert( 0 != _xFetchedValue.Get() );

    DWORD cbToGo = _xFetchedValue.SizeOf() - _cbFetchedValueSoFar;
    Win4Assert( sizeof CPMFetchValueOut < cbChunk );
    DWORD cbValToWrite = __min( cbChunk - sizeof CPMFetchValueOut, cbToGo );
    cbToWrite = sizeof CPMFetchValueOut + cbValToWrite;

    CPMFetchValueOut *pReply;
    if ( cbToWrite <= _BufferSize() )
    {
        pReply = (CPMFetchValueOut *) _Buffer();
    }
    else
    {
        _xTempBuffer.Init( cbToWrite );
        pReply = new( _xTempBuffer.Get() ) CPMFetchValueOut;
    }

    pReply->ValueExists() = TRUE;
    pReply->ValueSize() = cbValToWrite;
    pReply->MoreExists() = ( cbValToWrite != cbToGo );
    RtlCopyMemory( pReply->Value(),
                   _xFetchedValue.Get() + _cbFetchedValueSoFar,
                   cbValToWrite );
    _cbFetchedValueSoFar += cbValToWrite;

    if ( !pReply->MoreExists() )
    {
        _xFetchedValue.Free();
        _cbFetchedValueSoFar = 0;
    }

    return stateContinue;
} //DoFetchValue

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoWorkIdToPath, private
//
//  Synopsis:   Converts a wid to a path.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoWorkIdToPath(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    if ( 0 == _pQuery )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMWorkIdToPathIn &request = * (CPMWorkIdToPathIn *) _Buffer();
    CFunnyPath funnyPath;

    _pQuery->WorkIdToPath( request.GetWorkId(), funnyPath );

    CPMWorkIdToPathOut &reply = * (CPMWorkIdToPathOut *) _Buffer();

    cbToWrite = sizeof reply;
    if ( 0 != funnyPath.GetActualLength() )
    {
        reply.Any() = TRUE;
        ULONG cbPath = (funnyPath.GetActualLength()+1) * sizeof(WCHAR);
        RtlCopyMemory( reply.Path(), funnyPath.GetActualPath(), cbPath );
        cbToWrite += cbPath;
    }
    else
    {
        reply.Any() = FALSE;
    }

    return stateContinue;
} //DoWorkIdToPath

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoUpdateDocuments, private
//
//  Synopsis:   Handles an update documents message.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::DoUpdateDocuments(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    VerifyThreadHasAdminPrivilege();

    if ( _xDocStore.IsNull() )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    CPMUpdateDocumentsIn &request = * (CPMUpdateDocumentsIn *) _Buffer();

    XInterface<IFsCiAdmin> xFsCiAdmin;
    SCODE sc = _xDocStore->QueryInterface( IID_IFsCiAdmin,
                                           xFsCiAdmin.GetQIPointer() );

    if ( wcslen( request.GetRootPath() ) >= MAX_PATH )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    if ( SUCCEEDED(sc) )
        sc = xFsCiAdmin->UpdateDocuments( request.GetRootPath(),
                                          request.GetFlag() );

    if ( !SUCCEEDED(sc) )
        THROW( CException(sc) );

    return stateContinue;
} //DoUpdateDocuments

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::HandleRequestNoThrow, private
//
//  Synopsis:   Processes a request.  This method can't throw.  If there
//              is any problem with the request, set the status code
//              in the message to reflect the problem.
//
//  Arguments:  [cbRequest] - Size of the request in _Buffer()
//              [cbToWrite] - On output, set to the # of bytes to write if
//                            other than sizeof CProxyMessage.
//
//  Returns:    FALSE if the connection with the client should be terminated,
//              TRUE otherwise.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

RequestState CRequestServer::HandleRequestNoThrow(
    DWORD   cbRequest,
    DWORD & cbToWrite )
{
    // buffers must be 8-byte aligned on both sides of the proxy or the
    // marshalling/unmarshalling will be inconsistent.

    Win4Assert( isQWordAligned( _Buffer() ) );

    CProxyMessage &msg = * (CProxyMessage *) _Buffer();

    // Require that messages sent from clients have status set to S_OK,
    // as the reply message is in the same buffer and there is no need
    // to re-write the S_OK.

    Win4Assert( S_OK == msg.GetStatus() );

    RequestState state = stateContinue;

    TRY
    {
        Win4Assert( _xTempBuffer.SizeOf() > _BufferSize() ||
                    _xTempBuffer.IsNull() );

        int iMsg = msg.GetMessage() - pmConnect;

        if ( ( iMsg < 0 ) || ( iMsg >= cProxyMessages ) )
            THROW( CException( STATUS_INVALID_PARAMETER ) );

        // Don't impersonate when not necessary -- it's slow

        XPipeImpersonation impersonate;

        if ( _afImpersonate[ iMsg ] )
            impersonate.Impersonate( GetPipe() );

        SetLastTouchedTime( GetTickCount() );

        state = ( this->*( _aMsgFunctions[ iMsg ] ) )( cbRequest,
                                                       cbToWrite );

        prxDebugOut(( DEB_ITRACE,
                      "finish msg %d, cb %d, sc 0x%x, to pipe 0x%x\n",
                      msg.GetMessage(),
                      cbToWrite,
                      msg.GetStatus(),
                      GetPipe() ));
    }
    CATCH( CException, ex )
    {
        prxDebugOut(( DEB_ITRACE,
                      "HandleRequestNoThrow rs 0x%x msg %d caught 0x%x\n",
                      this,
                      msg.GetMessage(),
                      ex.GetErrorCode() ));

        msg.SetStatus( ex.GetErrorCode() );
        cbToWrite = sizeof CProxyMessage;

        _xTempBuffer.Free();
    }
    END_CATCH;

    return state;
} //HandleRequestNoThrow

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::DoAPC, private
//
//  Synopsis:   This method is called when an i/o operation is completed,
//              whether successfully or not.  If there was an error,
//              this method terminates the connection.
//
//  Arguments:  [dwError]       - Win32 error code for i/o operation
//              [cbTransferred] - # of bytes read or written
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::DoAPC(
    DWORD dwError,
    DWORD cbTransferred )
{
    prxDebugOut(( DEB_ITRACE, "apc %s t 0x%x p 0x%x msg %d cb %d err %d\n",
                  pipeStateRead == _state ? "read" :
                      pipeStateWrite == _state ? "write" : "none",
                  GetCurrentThreadId(),
                  GetPipe(),
                  * (int *) _Buffer(),
                  cbTransferred,
                  dwError ));

    // Ownership of the item is with the apc:  either issue another i/o
    // or recycle the request server.

    TRY
    {
        // if the apc operation completed with an error, abort the connection

        if ( 0 != dwError )
            QUIETTHROW( CException( HRESULT_FROM_WIN32( dwError ) ) );

        if ( IsBeingRemoved() )
            THROW( CException( STATUS_TOO_LATE ) );

        if ( pipeStateRead == _state )
        {
            // if the entire message didn't fit in the buffer (eg, there was
            // a large restriction) read the rest of the message.

            if ( _BufferSize() == cbTransferred )
            {
                prxDebugOut(( DEB_ITRACE, "more data available\n" ));
                BYTE *p = ReadRemainingSync( _Buffer(), cbTransferred );

                //
                // ReadRemainingSync returns 0 if there was an exact fit
                // into _Buffer, so there was nothing left to read.
                //

                if ( 0 != p )
                {
                    _xTempBuffer.Set( cbTransferred, p );
                    prxDebugOut(( DEB_ITRACE, "total msg cb: %d\n",
                                  cbTransferred ));

                    // Only certain msgs expect the input buffer to be in
                    // _xTempBuffer.  Fail if it's not one of these msgs.

                    int pm = * (int *)  _xTempBuffer.Get();
                    Win4Assert( ( pmCreateQuery == pm ) ||
                                ( pmConnect     == pm ) ||
                                ( pmSetBindings == pm ) );

                    if ( pmCreateQuery != pm &&
                         pmConnect     != pm &&
                         pmSetBindings != pm )
                        THROW( CException( STATUS_INVALID_PARAMETER ) );
                }
            }

            #if CIDBG == 1
                prxDebugOut(( DEB_PRX_MSGS,
                              "proxy read %d bytes at %p\n",
                              cbTransferred, _ActiveBuffer() ));
            #endif // CIDBG == 1

            #if CI_PIPE_TESTING
            
                if ( 0 != _requestQueue._pTraceRead )
                    (*_requestQueue._pTraceRead)( GetPipe(),
                                                  cbTransferred,
                                                  _ActiveBuffer() );
            
            #endif // CI_PIPE_TESTING
            
            // The read completed, process the request

            DWORD cbToWrite = sizeof CProxyMessage;
            RequestState state = HandleRequestNoThrow( cbTransferred, cbToWrite );

            if ( stateContinue == state )
            {
                Win4Assert( cbToWrite >= sizeof CProxyMessage );
                Win4Assert( ( cbToWrite <= _BufferSize() ) ||
                            ( !_xTempBuffer.IsNull() ) );
                Win4Assert( ( cbToWrite > _BufferSize() ) ||
                            ( _xTempBuffer.IsNull() ) );
                Win4Assert( ( _xTempBuffer.IsNull() ) ||
                            ( cbToWrite == _xTempBuffer.SizeOf() ) );

                _state = pipeStateWrite;

                #if CIDBG == 1
                    prxDebugOut(( DEB_PRX_MSGS,
                                  "proxy writing %d bytes at %p\n",
                                  cbToWrite, _ActiveBuffer() ));
                #endif // CIDBG == 1

                void * pvToWrite = _ActiveBuffer();

                #if CI_PIPE_TESTING
                
                    void * pvToWriteOrg = pvToWrite;
                    DWORD cbToWriteOrg = cbToWrite;

                    if ( 0 != _requestQueue._pTraceBefore )
                        (*_requestQueue._pTraceBefore)( GetPipe(),
                                                        cbToWriteOrg,
                                                        pvToWriteOrg,
                                                        cbToWrite,
                                                        pvToWrite );

                
                #endif // CI_PIPE_TESTING

                Write( pvToWrite, cbToWrite, APCRoutine );

                #if CI_PIPE_TESTING
                
                    if ( 0 != _requestQueue._pTraceAfter )
                        (*_requestQueue._pTraceAfter)( GetPipe(),
                                                       cbToWriteOrg,
                                                       pvToWriteOrg,
                                                       cbToWrite,
                                                       pvToWrite );
                
                #endif // CI_PIPE_TESTING
                
                if ( IsBeingRemoved() )
                    CancelIO();
            }
            else if ( stateDisconnect == state )
            {
                Win4Assert( _xTempBuffer.IsNull() );
                _state = pipeStateNone;
                _requestQueue.RecycleRequestServerNoThrow( this );
            }
            else
            {
                Win4Assert( statePending == state );
            }
        }
        else
        {
            Win4Assert( pipeStateWrite == _state );

            // cleanup temp buffer if allocated for the write

            _xTempBuffer.Free();

            // the write completed, so schedule another read

            _state = pipeStateRead;
            Read( _Buffer(), _BufferSize(), APCRoutine );

            if ( IsBeingRemoved() )
                CancelIO();
        }
    }
    CATCH( CException, ex )
    {
        prxDebugOut(( DEB_WARN,
                      "exception in APC error %#x, this %#x, pipe %#x\n",
                      ex.GetErrorCode(),
                      this,
                      GetPipe() ));

        // disconnect the pipe (and the query if it exists)

        _state = pipeStateNone;
        _requestQueue.RecycleRequestServerNoThrow( this );
    }
    END_CATCH;
} //DoAPC

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::APCRoutine, private, static
//
//  Synopsis:   This method is called when an i/o operation is completed.
//
//  Arguments:  [dwError]       - Win32 error code for i/o operation
//              [cbTransferred] - # of bytes read or written
//              [pOverlapped]   - Points to the overlapped for the i/o
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void WINAPI CRequestServer::APCRoutine(
    DWORD        dwError,
    DWORD        cbTransferred,
    LPOVERLAPPED pOverlapped )
{

    // It would be a programming error to take an exception here, and it
    // has never been hit.  Leave the check in for checked builds.

#if CIDBG == 1
    TRY
    {
#endif

        // The request server was saved in the hEvent field, which the
        // Win32 doc says is a good place for a user's APC data

        CRequestServer &serv = * (CRequestServer *) (CPipeServer *)
                               ( pOverlapped->hEvent );
        serv.DoAPC( dwError, cbTransferred );

#if CIDBG == 1
    }
    CATCH( CException, e )
    {
        prxDebugOut(( DEB_ERROR, "exception in APCRoutine: 0x%x\n",
                      e.GetErrorCode() ));
        Win4Assert( !"caught an unexpected exception in an apc" );
    }
    END_CATCH;
#endif
} //APCRoutine

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::CancelAPCRoutine, private/static
//
//  Synopsis:   Called in an APC when a connection should be cancelled
//
//  Arguments:  [dwParam] - The request server
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void WINAPI CRequestServer::CancelAPCRoutine(
    DWORD_PTR dwParam )
{
    TRY
    {
        CRequestServer * pServer = (CRequestServer *) dwParam;
        XInterface<CRequestServer> xServer( pServer );

        prxDebugOut(( DEB_ITRACE,
                      "Canceling server 0x%x io pipe 0x%x\n",
                      pServer, pServer->GetPipe() ));

        // Freeing a pending query will result in the request server
        // being cleaned up, since _fShutdown/BeingRemoved is TRUE.
        // Cancelling pending IO will cause the IO APC routine to be
        // called with an error completion status, which will clean up
        // the request server.

        if ( pipeStatePending == pServer->_state )
            pServer->FreeQuery();
        else if ( pipeStateNone != pServer->_state )
            pServer->CancelIO();
    }
    CATCH( CException, e )
    {
        prxDebugOut(( DEB_ERROR, "cancelapc caught 0x%x\n",
                      e.GetErrorCode() ));
        Win4Assert( !"CancelAPC caught an exception" );
    }
    END_CATCH
} //CancelAPCRoutine

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::Quiesce, private
//
//  Synopsis:   Called by the APC when a query with notifications quiesces
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::Quiesce()
{
    TRY
    {
        prxDebugOut(( DEB_ITRACE,
                      "Quiescing server 0x%x io pipe 0x%x\n",
                      this, GetPipe() ));

        Win4Assert( pipeStatePending == _state );

        // If we're shutting down or the server is disconnecting the client
        // for being idle for too long, abort now.

        if ( _requestQueue.IsShutdown() || IsBeingRemoved() )
            THROW( CException( STATUS_TOO_LATE ) );

        // the long-running operation completed, so do the write

        _xTempBuffer.Free();

        Win4Assert( 0 != _pQuery );
        _state = pipeStateWrite;

        //
        // If the first call to Quiesce is to tell us that the asynch
        // query execution failed, free the query.
        //

        if ( FAILED ( _scPendingStatus ) )
            FreeQuery();

        CProxyMessage &msg = * (CProxyMessage *) _Buffer();
        msg.SetStatus( _scPendingStatus );

        Write( (BYTE *) _Buffer(), _cbPendingWrite, APCRoutine );

        // Note that the state of these may have changed after the check above

        if ( IsBeingRemoved() )
            CancelIO();
    }
    CATCH( CException, ex )
    {
        prxDebugOut(( DEB_ITRACE,
                      "quiesce write error 0x%x, pipe 0x%x\n",
                      ex.GetErrorCode(),
                      GetPipe() ));

        _state = pipeStateNone;
        _requestQueue.RecycleRequestServerNoThrow( this );
    }
    END_CATCH;
} //Quiesce

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::QuiesceAPCRoutine, private/static
//
//  Synopsis:   Called in an APC when a query with notifications quiesces
//
//  Arguments:  [dwParam] - The request server
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void WINAPI CRequestServer::QuiesceAPCRoutine(
    ULONG_PTR dwParam )
{
    CRequestServer & Server = * (CRequestServer *) dwParam;
    Server.Quiesce();
} //QuiesceAPCRoutine

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::QueryQuiesced, public
//
//  Synopsis:   Called when a synchronous query is quiesced, so the pending
//              request can be completed by the thread that created the query.
//
//  History:    16-Feb-97   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::QueryQuiesced(
    BOOL  fSuccess,
    SCODE sc )
{
    // only complete the work if the query is truly quiesced

    if ( fSuccess || _requestQueue.IsShutdown() || IsBeingRemoved() )
    {
        Win4Assert( IsBeingRemoved() || 0 != _pQuery || _requestQueue.IsShutdown() );
        Win4Assert( pipeStatePending == _state );

        _scPendingStatus = sc;
        _requestQueue.DecrementPendingItems();

        QueueUserAPC( CRequestServer::QuiesceAPCRoutine,
                      GetWorkerThreadHandle(),
                      (ULONG_PTR) this );
    }
} //QueryQuiesced

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::CompleteNotification, public
//
//  Synopsis:   This is called by a query worker thread when a notification
//              should be delivered to the client.
//
//  Arguments:  [dwChangeType] - The notification
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::CompleteNotification(
    DWORD dwChangeType )
{
    // _pQuery can be 0 if the query is in the process of being deleted,
    // since _pQuery is set to 0 before it's actually deleted in FreeQuery(),
    // and queries that haven't quiesced yet always quiesce on destruction.

    if ( 0 != _pQuery )
    {
        CPMSendNotifyOut notify( dwChangeType );
        WriteSync( &notify, sizeof notify );
    }
} //CompleteNotification

//+-------------------------------------------------------------------------
//
//  Member:     CRequestServer::Cleanup, public
//
//  Synopsis:   Frees data and refcounts associated with the request server.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestServer::Cleanup()
{
    FreeQuery();
    _xTempBuffer.Free();
    _fClientIsRemote = FALSE;
    _state = pipeStateNone;
    _cbPendingWrite = 0;
    _scPendingStatus = S_OK;

    _xClientMachine.Free();
    _xClientUser.Free();

    // Remove the refcount on the thread since it no longer has to process
    // APCs on behalf of this request server.

    if ( 0 != _pWorkThread )
    {
        _hWorkThread = INVALID_HANDLE_VALUE;
        _workQueue.Release( _pWorkThread );
        _pWorkThread = 0;
    }

    _xDbProperties.Free();

    if ( !_xDocStore.IsNull() )
    {
        XInterface<ICiCAdviseStatus> xAdviseStatus;
        SCODE sc = _xDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                               xAdviseStatus.GetQIPointer() );

        // It would be a bug if this QI actually failed.

        if ( S_OK == sc )
            xAdviseStatus->DecrementPerfCounterValue( CI_PERF_RUNNING_QUERIES );

        _xDocStore.Free();
    }
} //Cleanup

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::CRequestQueue, public
//
//  Synopsis:   Constructs a request queue
//
//  Arguments:  [cMaxCachedServerItems]    -- max # of cached pipe objects
//              [cMaxSimultaneousRequests] -- max # of simultaneous pipes
//
//  History:    16-Sep-96   dlee       Created.
//              30-Mar-98   kitmanh    Initialized _fNetPause
//                                     and _fNetContinue to FALSE
//
//--------------------------------------------------------------------------

CRequestQueue::CRequestQueue(
    unsigned     cMaxCachedServerItems,
    unsigned     cMaxSimultaneousRequests,
    unsigned     cmsDefaultClientTimeout,
    BOOL         fMinimizeWorkingSet,
    unsigned     cMinClientIdleTime,
    unsigned     cmsStartupDelay,
    const GUID & guidDocStoreClient ) :
    _guidDocStoreClient( guidDocStoreClient ),
    _cMaxSimultaneousRequests( cMaxSimultaneousRequests ),
    _cmsDefaultClientTimeout( cmsDefaultClientTimeout ),
    _fMinimizeWorkingSet( fMinimizeWorkingSet ),
    _cMinClientIdleTime( cMinClientIdleTime ),
    _cmsStartupDelay( cmsStartupDelay ),
    _fDocStoresOpen( FALSE ),
    _fShutdown( FALSE ),
    _cBusyItems( 0 ),
    _cPendingItems( 0 ),
    _workQueue( 1, CWorkQueue::workQueueRequest ),
    _tableActiveServers( cMaxSimultaneousRequests ),
    _queueCachedServers( cMaxCachedServerItems ),
    _fNetPause( FALSE ),
    _fNetContinue( FALSE ),
    _fNetStop( FALSE )
{

#if CI_PIPE_TESTING

    _pTraceBefore = 0;
    _pTraceAfter = 0;
    _pTraceRead = 0;
    _hTraceDll = LoadLibraryEx( L"cipipetrace.dll", 0,
                                LOAD_WITH_ALTERED_SEARCH_PATH );

    if ( 0 != _hTraceDll )
    {
        _pTraceBefore = (PipeTraceServerBeforeCall)
                        GetProcAddress( _hTraceDll, "ServerBefore" );
        _pTraceAfter = (PipeTraceServerAfterCall)
                        GetProcAddress( _hTraceDll, "ServerAfter" );
        _pTraceRead = (PipeTraceServerReadCall)
                        GetProcAddress( _hTraceDll, "ServerRead" );
    }

#endif // CI_PIPE_TESTING

    _workQueue.Init();

    //
    // Read the worker queue registry settings in the SYSTEM context
    // and initialize the parameters.
    //
    ULONG cMaxActiveThreads, cMinIdleThreads;
    _workQueue.GetWorkQueueRegParams( cMaxActiveThreads,
                                      cMinIdleThreads );
    _workQueue.RefreshParams( cMaxActiveThreads, cMinIdleThreads );

    //
    // The security checks for the pipe are done in this order:
    //   The system account can create instances of this pipe.
    //   No-one can write DAC or OWNER, or create pipe instances.
    //   Everyone can read, write, and synchronize around this pipe.
    //
    // Actual query result and admin security checking is done when the
    // requests are made, and are based on the pipe impersonation.
    //
    // This data really is const, but the Win32 security APIs don't do const.
    //

    static SID sidLocalSystem = { SID_REVISION,
                                  1,
                                  SECURITY_NT_AUTHORITY,
                                  SECURITY_LOCAL_SYSTEM_RID };
    static SID sidWorld = { SID_REVISION,
                            1,
                            SECURITY_WORLD_SID_AUTHORITY,
                            SECURITY_WORLD_RID };

    // NTRAID#DB-NTBUG9-83834-2000/07/31-dlee No way to protect Indexing Service named pipes.
    // FILE_CREATE_PIPE_INSTANCE no longer works, so we can't include
    // it in the AceData.  There is no good way to secure the pipe.

    ACE_DATA AceData[] =
    {
        //{ ACCESS_ALLOWED_ACE_TYPE, 0, 0,
        //  FILE_CREATE_PIPE_INSTANCE,
        //  &sidLocalSystem },
        { ACCESS_DENIED_ACE_TYPE, 0, 0,
          WRITE_DAC | WRITE_OWNER /*| FILE_CREATE_PIPE_INSTANCE */,
          &sidWorld },
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
          &sidWorld },
    };
    const ULONG cAces = sizeof AceData / sizeof ACE_DATA;

    CiCreateSecurityDescriptor( AceData,
                                cAces,
                                &sidLocalSystem,
                                &sidLocalSystem,
                                _xSecurityDescriptor );
} //CRequestQueue

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::RecycleRequestServerNoThrow, public
//
//  Synopsis:   A request server has become available.  Either delete it
//              or cache it for use later.  There is a transfer of ownership.
//
//  Arguments:  [pServer] - The request server to be reused or deleted
//
//  History:    16-Sep-96   dlee       Created.
//
//  Notes:      This method must not throw.
//
//--------------------------------------------------------------------------

void CRequestQueue::RecycleRequestServerNoThrow(
    CRequestServer * pServer )
{
    Win4Assert( pServer->NoOutstandingAPCs() );

    CServerItem item( pServer );

    BOOL fDisconnectOk = pServer->Disconnect();
    if ( !fDisconnectOk )
    {
        prxDebugOut(( DEB_WARN, "Disconnect of server 0x%x failed %d\n",
                      pServer, GetLastError() ));
    }

    pServer->Cleanup();

    // Only try to reuse the server if the refcount is 1 (it's available).
    // The only reason the refcount might not be 1 is if we took an exception
    // in DoIt(). Wake up the main thread if a request server is available.

    if ( pServer->IsAvailable() )
    {
        // The Add will fail if the cache is full or there is an admin
        // operation like shutdown going on.

        if ( _queueCachedServers.Add( item ) )
            _event.Set();
    }

    long cCurrent = InterlockedDecrement( &_cBusyItems );

    // If no request servers are to be cached and we've fallen just
    // under the ceiling on the # of items, set the event so the main
    // thread can wake up and create another request server.

    if ( ( !_fShutdown ) &&
         ( 0 == _queueCachedServers.MaxRequests() ) &&
         ( cCurrent == (long) ( _cMaxSimultaneousRequests - 1 ) ) )
        _event.Set();
} //RecycleRequestServerNoThrow

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::OpenAllDocStores, private
//
//  Synopsis:   Tells the DocStore admin to open all docstores if they
//              aren't open yet.
//
//  History:    19-Jun-98   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestQueue::OpenAllDocStores()
{
    if ( !_fDocStoresOpen )
    {
        XInterface<ICiCDocStoreLocator> xLocator( DocStoreLocator() );
        Win4Assert( !xLocator.IsNull() );

        // Ignore failures to open docstores -- the docstore is responsible

        xLocator->OpenAllDocStores();

        _fDocStoresOpen = TRUE;
    }
} //OpenAllDocStores

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::DocStoreLocator, public
//
//  Synopsis:   Retrieves the Doc Store Locator for the client
//
//  History:    19-Jun-98   dlee       Created.
//
//--------------------------------------------------------------------------

ICiCDocStoreLocator * CRequestQueue::DocStoreLocator()
{
    return g_svcDocStoreLocator.Get( _guidDocStoreClient );
} //DocStoreLocator

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::DoWork, public
//
//  Synopsis:   This is the main loop for the CI service.  It makes
//              available pipes to which clients can connect.  When the
//              _evtStateChange event is triggered, the method exits.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestQueue::DoWork()
{
    // Throw away all that startup code

    SetProcessWorkingSetSize( GetCurrentProcess(), ~0, ~0 );

    HANDLE ah[2];
    ah[0] = _evtStateChange.GetHandle();

    do
    {
        CServerItem item;

        TRY
        {
            // If a cached server item is available, use it.  Otherwise,
            // create a non-cached item if we are under the limit.

            prxDebugOut(( DEB_ITRACE, "cached/busy items: %d / %d\n",
                          _queueCachedServers.Count(), _cBusyItems ));

            if ( ( !_queueCachedServers.AcquireTop( item ) ) &&
                 ( _cBusyItems < (LONG) _cMaxSimultaneousRequests ) )
                item.Create( CI_SERVER_PIPE_NAME,
                             _cmsDefaultClientTimeout,
                             *this,
                             _workQueue );

            if ( 0 != item.Get() )
            {
                // make sure it doesn't get thrown away right away

                item.Get()->SetLastTouchedTime( GetTickCount() );
                InterlockedIncrement( & _cBusyItems );
                BOOL fConnected = item.Get()->Connect();

                // if it's not connected yet, we have to wait on an event

                if ( !fConnected )
                {
                    prxDebugOut(( DEB_ITRACE,
                                  "waiting for connect of pipe 0x%x\n",
                                  item.Get()->GetPipe() ));

                    ah[1] = item.Get()->GetEvent();
                    DWORD dwTimeout = _fMinimizeWorkingSet ? 30000 : INFINITE;

                    DWORD dw;
                    do
                    {
                        //
                        // If catalogs haven't been opened yet due to the
                        // startup delay and it's a good time, open them.
                        //

                        if ( !_fDocStoresOpen )
                        {
                            if ( GetTickCount() >= _cmsStartupDelay )
                            {
                                OpenAllDocStores();
                            }
                            else
                            {
                                dwTimeout = 0;
                                DWORD dwTC = GetTickCount();
                                if ( _cmsStartupDelay > dwTC )
                                    dwTimeout += ( _cmsStartupDelay - dwTC );
                            }
                        }

                        // event 0 -- shutdown
                        // event 1 -- a client connected

                        dw = WaitForMultipleObjectsEx( 2,
                                                       ah,
                                                       FALSE,
                                                       dwTimeout,
                                                       FALSE );

                        // if an event triggered, handle it

                        if ( WAIT_TIMEOUT != dw )
                            break;

                        // If there isn't anything else going on, trim our
                        // working set, and back off on the next time

                        if ( 1 == _cBusyItems )
                        {
                            dwTimeout = 120000; // 2 minutes
                            SetProcessWorkingSetSize( GetCurrentProcess(), ~0, ~0 );
                        }
                    } while ( TRUE );

                    Win4Assert( ( 0 == dw ) || ( 1 == dw ) );

                    if ( 0 == dw )
                    {
                        item.Free();
                        InterlockedDecrement( & _cBusyItems );
                        break; // out of the do loop
                    }
                    else if ( 1 != dw )
                        THROW( CException() );

                    item.Get()->ResetEvent();
                }

                //
                // Open the docstores now since the connection will not
                // force in a catalog if it's for administration.
                //

                OpenAllDocStores();

                _workQueue.Add( item.Get() );
                item.Acquire();

                //
                // Fix for 123796. If we have no more request servers left
                // we should attempt to free one from an idle client.
                //

                if ( _cBusyItems == (LONG) _cMaxSimultaneousRequests )
                    WrestReqServerFromIdleClient();
            }
            else
            {
                //
                // Wait for a request server to become available, either
                // in the cache or under the max ceiling.
                // event 0 -- shutdown
                // event 1 -- request server is available
                // timeout: look for an idle connection to destroy
                //

                prxDebugOut(( DEB_ITRACE, "wait for RequestServer\n" ));

                DWORD dwTimeout = ( _cBusyItems == (LONG) _cMaxSimultaneousRequests ) ?
                                  10000 : INFINITE;

                ah[1] = _event.GetHandle();
                DWORD dw = WaitForMultipleObjectsEx( 2,
                                                     ah,
                                                     FALSE,
                                                     dwTimeout,
                                                     FALSE );

                prxDebugOut(( DEB_ITRACE, "wfsoex wakeup: %d\n", dw ));

                Win4Assert(( 0 == dw || 1 == dw || WAIT_TIMEOUT == dw));

                if ( WAIT_TIMEOUT == dw )
                    WrestReqServerFromIdleClient();
                else if ( 0 == dw )
                    break; // out of the do loop
                else if ( 1 != dw )
                    THROW( CException() );
            }
        }
        CATCH( CException, ex )
        {
            prxDebugOut(( DEB_WARN, "DoWork exception error 0x%x\n",
                          ex.GetErrorCode() ));

            if ( 0 != item.Get() )
            {
                item.Free();
                InterlockedDecrement( & _cBusyItems );
            }
        }
        END_CATCH;
    } while ( TRUE );

    Shutdown();
} //DoWork

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::WrestReqServerFromIdleClient, private
//
//  Synopsis:   Looks for connection that have been idle for more than
//              a predetermined amt of time. Flags the worst offender
//              and kicks it off to pave way for a new connection.
//
//  History:    03-Feb-98   KrishnaN       Created.
//
//--------------------------------------------------------------------------

void CRequestQueue::WrestReqServerFromIdleClient()
{
    // look for the most idle connection that crossed the threshold

    //
    // We could be a little more efficient if we kick out the
    // first eligible idle client instead of looking for the most
    // idle one.  But this is infrequent enough and not a big enough
    // problem that it's worth fixing.
    //

    XInterface<CRequestServer> xIdle;

    {
        CRequestServer * pMostIdleServer = 0;
        DWORD dwCurrentTick = GetTickCount();
        DWORD dwMaxIdleTime = 0;

        CLock lock( _mutex );
    
        for ( ULONG i = 0; i < _tableActiveServers.Size(); i++ )
        {
            CRequestServer *pServer = _tableActiveServers.GetEntry( i );
    
            if ( !_tableActiveServers.IsFree( pServer ) &&
                 INVALID_HANDLE_VALUE != pServer->GetWorkerThreadHandle() )
            {
                DWORD dwLast = pServer->GetLastTouchedTime();
    
                // The windows tick count wraps around every 50 days.
                // Unsigned arithmetic accounts for that, so we don't have to.
    
                DWORD dwIdleTime = dwCurrentTick - dwLast;
    
                if ( dwIdleTime > _cMinClientIdleTime &&
                     dwIdleTime > dwMaxIdleTime )
                {
                    dwMaxIdleTime = dwIdleTime;
                    pMostIdleServer = pServer;
                }
            }
        }

        if ( 0 != pMostIdleServer )
        {
            pMostIdleServer->AddRef();
            xIdle.Set( pMostIdleServer );
        }
    }

    if ( !xIdle.IsNull() )
    {
        // Make sure this isn't in the cache or it won't get deleted

        _queueCachedServers.DisableAdditions();
        FreeCachedServers();

        // Disconnect this most-idle connection
    
        CEventSem evt;
        xIdle->BeingRemoved( &evt );
    
        // Attempt to cancel it if it's still associated with a worker thread

        HANDLE hThrd = xIdle->GetWorkerThreadHandle();
        if ( INVALID_HANDLE_VALUE != hThrd )
        {
            DWORD dwRet = QueueUserAPC( CRequestServer::CancelAPCRoutine,
                                        hThrd,
                                        (ULONG_PTR) xIdle.GetPointer() );
            Win4Assert( 0 != dwRet );

            xIdle.Acquire();
        }

        // Wait for the connection to completely go away

        xIdle.Free();
        evt.Wait();

        _queueCachedServers.EnableAdditions();

        prxDebugOut(( DEB_ITRACE, "Successfully disconnected an idle client.\n" ));
    }
} //WrestReqServerFromIdleClient

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::FreeCachedServers, private
//
//  Synopsis:   Removes all cached request servers
//
//  History:    01-July-99   dlee       Created from existing code
//
//--------------------------------------------------------------------------

void CRequestQueue::FreeCachedServers()
{
    CServerItem item;
    while ( _queueCachedServers.AcquireTop( item ) )
        item.Free();
} //FreeCachedServers

//+-------------------------------------------------------------------------
//
//  Member:     CRequestQueue::ShutdownActiveServers, private
//
//  Synopsis:   Cancels pending IO on each active request server.  It may
//              be that a given request server has no IO pending, and
//              that will be taken care of when the IO is requested.
//
//  Arguments:  [pDocStore] - pointer to a docstore
//              if pDocStore == NULL, shutdown all active servers
//
//  History:    19-May-97   dlee       Created.
//              24-Apr-98   kitmanh    Shut down active servers associated
//                                     with the specified docstore
//
//  Note:       Always addref to everyone in the first loop, since the
//              in the 2nd loop, the smart pointer xServer will release
//              the pServer when it's out of scope, whether the docstore
//              matches or not.
//
//--------------------------------------------------------------------------

void CRequestQueue::ShutdownActiveServers( ICiCDocStore * pDocStore )
{
    ciDebugOut(( DEB_ITRACE, "ShutdownActiveServers is called\n" ));

    // AddRef all outstanding request servers so they won't go away

    {
        CLock lock( _mutex );

        for ( ULONG i = 0; i < _tableActiveServers.Size(); i++ )
        {
            CRequestServer *pServer = _tableActiveServers.GetEntry( i );

            if ( !_tableActiveServers.IsFree( pServer ) )
                pServer->AddRef();
        }
    }

    // Make sure whatever request servers are freed aren't in the cache

    _queueCachedServers.DisableAdditions();
    FreeCachedServers();

    //
    // For each of the active request servers, file an APC so that the io
    // for that thread will be canceled by that thread, and so that
    // pending queries are cancelled.  No items will be added to
    // _tableActiveServers during this loop, but items may be deleted.
    //

    for ( ULONG i = 0; i < _tableActiveServers.Size(); i++ )
    {
        CRequestServer *pServer = _tableActiveServers.GetEntry( i );

        if ( !_tableActiveServers.IsFree( pServer ) )
        {
            XInterface<CRequestServer> xServer( pServer );

            // The thread handle will be invalid if no worker thread is yet
            // associated or the association has been terminated.  In either
            // case by definition there can be no outstanding APCs.

            // Note that the thread can't go away from under us since all
            // threads in the worker pool were addref'ed earlier

            // Disconnect it even if it has no docstore since it may be
            // processing a connect and be about to get a docstore.

            if ( ( 0 == pDocStore ) ||
                 ( pServer->GetDocStore() == 0 ) ||
                 ( pServer->GetDocStore() == pDocStore ) )
            {
                CEventSem evt;
                pServer->BeingRemoved( &evt );

                HANDLE hThread = pServer->GetWorkerThreadHandle();

                if ( INVALID_HANDLE_VALUE != hThread &&
                     QueueUserAPC( CRequestServer::CancelAPCRoutine,
                                   hThread,
                                   (ULONG_PTR) pServer ) )
                    xServer.Acquire();

                // Wait for the client to stop using the docstore

                xServer.Free();
                evt.Wait();
            }
        }
    }

    _queueCachedServers.EnableAdditions();
} //ShutdownActiveServers

//+-------------------------------------------------------------------------
//
//  Method:     CRequestQueue::Shutdown
//
//  Synopsis:   Cleans up after the request queue.  Can't throw.
//              handles both net stop and net pause
//
//  History:    16-Sep-96   dlee       Created.
//              30-Mar-98   kitmanh    Don't shutdown workqueue if we're
//                                     doing a net pause or a net continue
//              06-25-98    kitmanh    Update
//
//--------------------------------------------------------------------------

void CRequestQueue::Shutdown()
{
    prxDebugOut(( DEB_ITRACE, "Shutdown\n" ));

    // Make sure the worker threads don't go away

    _workQueue.AddRefWorkThreads();

    unsigned i = 0;
    SCWorkItem WorkItem;

    {
        CLock lock( _mutex );

        if ( _fNetStop )
            _fShutdown = TRUE;

        if ( _stateChangeArray.Count() > 0 )
            WorkItem = _stateChangeArray.Get(i);
        else
        {
            ciDebugOut(( DEB_ITRACE, "Shutdown:: eNetStop\n" ));

            // No workitems exist, must be net stop, pause or continue
            // create a stop work item with NULL docstore

            WorkItem.type = eNetStop;  // note: workitem.type is not really
                                       // important here

            ciDebugOut(( DEB_ITRACE, "WorkItem.type is %d\n", WorkItem.type ));
            WorkItem.pDocStore = 0;
            WorkItem.StoppedCat = 0;
        }
    }

    ciDebugOut(( DEB_ITRACE, "WorkItem.Count is %d\n", _stateChangeArray.Count() ));

    do
    {
        ciDebugOut(( DEB_ITRACE, "i is %d\n", i ));

        // now loop thru the workitem list and do the work

        i++;

        if ( 0 == WorkItem.StoppedCat )
            ShutdownActiveServers( WorkItem.pDocStore );

        {
            CLock lock( _mutex );

            if ( i < _stateChangeArray.Count() )
                WorkItem = _stateChangeArray.Get(i);
        }
    } while ( i < _stateChangeArray.Count() );

    if ( _fNetStop || _fNetPause || _fNetContinue )
    {
        if ( _stateChangeArray.Count() > 0 )
        {
            // No workitem has been created at the top of the function,
            // thus need to run ShutdownActiveServers here

            ShutdownActiveServers( 0 );
        }

        Win4Assert( !_queueCachedServers.Any() );
        Win4Assert( !_tableActiveServers.Any() );
        Win4Assert( 0 == _cBusyItems );
        Win4Assert( 0 == _cPendingItems );
    }

    _workQueue.ReleaseWorkThreads();

    if ( _fNetStop )
        _workQueue.Shutdown();
} //Shutdown

//+---------------------------------------------------------------------------
//
//  Function:   StartFWCiSvcWork
//
//  Synopsis:   Is the main server loop. Is called by the cisvc to receive
//              requests and demultiplex on them.
//
//  Arguments:  [lock] -- to be released when it's ok to call StopFWCiSvcWork
//
//  History:    1-30-97   srikants   Created
//              4-13-98   kitmanh    Moved the creation of CRequestQueue to
//                                   StartCisvcWork and passed the pointer
//                                   in from StartCisvcWork to initialize
//                                   g_pRequestQueue
//
//  Notes:      Must be called in the SYSTEM context without any impersonation.
//
//----------------------------------------------------------------------------

SCODE StartFWCiSvcWork( CReleasableLock & lock,
                        CRequestQueue * pRequestQueue,
                        CEventSem & evt )
{
    ciDebugOut(( DEB_ITRACE, "StartFWCiSvcWork is called\n" ));

    SCODE sc = S_OK;

    TRY
    {
        ciDebugOut(( DEB_ITRACE, "NetPaused == %d and NetContinued == %d\n",
                     pRequestQueue->IsNetPause(), pRequestQueue->IsNetContinue() ));

        g_pRequestQueue = pRequestQueue;
        evt.Set();
        lock.Release();

        ciDebugOut(( DEB_ITRACE, "evtPauseContinue is set\n" ));
        ciDebugOut(( DEB_ITRACE, "StartFWCisvcWork.. About to DoWork()\n" ));

        g_pRequestQueue->DoWork();

        ciDebugOut(( DEB_ITRACE, "StartFWCisvcWork.. Just fell out from DoWork\n" ));
        ciDebugOut(( DEB_ITRACE, "g_pRequestQueue->IsShutdown() is %d\n",
                     g_pRequestQueue->IsShutdown() ));

        // Check if a netpause or netcontinue is requested during DoWork()
        if ( g_pRequestQueue->IsShutdown() &&
             ! ( g_pRequestQueue->IsNetPause() || g_pRequestQueue->IsNetContinue() ) )
        {
            g_svcDocStoreLocator.Shutdown();

            //
            // Shutdown the Content Index work queue.
            //

            TheWorkQueue.Shutdown();
        }
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Terminating - DoCiSvcServerWork(). Error 0x%X\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    ciDebugOut(( DEB_ITRACE, "Request lock for resetting g_pRequestQueue to 0\n" ));
    lock.Request();
    ciDebugOut(( DEB_ITRACE, "Got lock\n" ));
    g_pRequestQueue = 0;
    ciDebugOut(( DEB_ITRACE, "About to release lock\n" ));
    lock.Release();

    return sc;
} //StartFWCiSvcWork

//+---------------------------------------------------------------------------
//
//  Function:   StopFWCiSvcWork
//
//  Synopsis:   Stops the server work. It is the Shutdown method called by
//              cisvc to stop the work.
//
//  Arguments:  [type]  -- type of work to do
//              [wcVol] -- volume letter (for eLockVol only)
//
//  History:    1-30-97   srikants   Created
//              3-30-98   kitmanh    If we're doing a net pause, set
//                                   _fNetPause member in the CRequestQueue
//
//----------------------------------------------------------------------------

SCODE StopFWCiSvcWork( ECiSvcActionType type, 
                       CReleasableLock * pLock, 
                       CEventSem * pEvt,
                       WCHAR wcVol )
{
    ciDebugOut(( DEB_ITRACE, "StopFWCiSvcWork.. type == %d\n", type ));
    
    SCODE sc = S_OK;

    // for the case where a shutdown occurs while the service is restarting
    // for pausing, continuing, stopping a catalog

    if ( eNetStop == type && 0 == g_pRequestQueue ) 
    {
       //block until g_pRequestQueue is non-zero
       ciDebugOut(( DEB_ITRACE, "0 == g_pRequestQueue\n" ));
       ciDebugOut(( DEB_ITRACE, "StopFWCiSvcWork: Release the lock\n" ));
       ciDebugOut(( DEB_ITRACE, "Block on g_pevtPauseContinue for eNetStop\n" ));
       
       //this lock need to be released, so the lock can be grabbed by the
       //thread just done shutting down to finish restarting (calling 
       //StartFWCiSvcWork)
       pLock->Release();
       pEvt->Wait();
       ciDebugOut(( DEB_ITRACE, "Done waiting on g_pevtPauseContinue\n" ));
       pLock->Request();
       ciDebugOut(( DEB_ITRACE, "StopFWCiSvcWork requested the lock\n" ));
    }

    if ( 0 != g_pRequestQueue )
    {
        ciDebugOut(( DEB_ITRACE, "0 != g_pRequestQueue\n" ));
        ciDebugOut(( DEB_ITRACE, "g_pRequestQueue->IsShutdown() is %d\n", g_pRequestQueue->IsShutdown()  ));        
        
        // Ignore all events if shutdown is initialized
        if ( g_pRequestQueue->IsShutdown() )
            return STATUS_TOO_LATE;

        XInterface<ICiCDocStoreLocator> xLocator( g_pRequestQueue->DocStoreLocator() );
        Win4Assert( !xLocator.IsNull() );

        switch ( type )
        {
        case eNetPause:
            g_pRequestQueue->SetNetPause();
            break;

        case eNetContinue:
            g_pRequestQueue->SetNetContinue();
            break;

        case eNetStop:
            g_pRequestQueue->SetNetStop();
            break;

        case eCatRO:
        case eCatW:
        case eStopCat:
        case eNoQuery:
            break;

        case eLockVol:
            sc = xLocator->StopCatalogsOnVol( wcVol, g_pRequestQueue );
            ciDebugOut(( DEB_ITRACE, "After StopCatalogsOnVol\n" ));
            break;

        case eUnLockVol:
            sc = xLocator->StartCatalogsOnVol( wcVol, g_pRequestQueue );
            ciDebugOut(( DEB_ITRACE, "After StartCatalogsOnVol\n" ));
            break;

        default:
            Win4Assert( !"StopFWCiSvcWork is called with invalid ECisvcActionType" );
        }
        ciDebugOut(( DEB_ITRACE, "Time to WakeForStateChange; type = %d\n", type ));
        g_pRequestQueue->WakeForStateChange();
    }
    else
    {
        ciDebugOut(( DEB_ITRACE, "g_pRequestQueue->IsShutdown() is 0\n" ));        
    }

    return sc;
} //StopFWCiSvcWork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\docname_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "docname.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\cimanger.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       cimanger.cxx
//
//  Contents:   The Content Index manager object implementing the
//              ICiManager interface.
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cci.hxx>
#include <prcstob.hxx>
#include <glbconst.hxx>
#include <idxtab.hxx>
#include <enumstr.hxx>

#include "cimanger.hxx"
#include "dmnslave.hxx"

CCiManager::CCiManager( ICiCDocStore * pICiCDocStore )
:_sigCiManger(sigCiManger),
 _refCount(1),
 _state(STARTING),
 _reason(INVALID_REASON),
 _pcci(0),
 _startupFlags(0),
 _fInProc(FALSE),
 _pFilterDaemon(0),
 _pPidLookupTable(0),
 _fNullContentIndex( FALSE )
{
    Win4Assert( pICiCDocStore );

    pICiCDocStore->AddRef();
    _xDocStore.Set( pICiCDocStore );

    ICiCAdviseStatus    *pAdviseStatus = 0;

    SCODE sc = _xDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                           (void **) &pAdviseStatus);
    if ( S_OK != sc )
    {
        Win4Assert( 0 != pAdviseStatus );

        THROW(CException(sc) );
    }

    _xAdviseStatus.Set(pAdviseStatus);

    ICiCLangRes *pICiCLangRes;

    sc = pICiCDocStore->QueryInterface(IID_ICiCLangRes, (void **) &pICiCLangRes);
    if ( FAILED(sc) )
    {
        Win4Assert( !"QI on ICiCLangRes failed" );
        THROW (CException(sc));
    }

    XInterface<ICiCLangRes>  xCiCLangRes(pICiCLangRes);

    _xLangList.Set( new CLangList(pICiCLangRes) );

    CCiAdminParams * pAdminParams = new CCiAdminParams( _xLangList.GetPointer() );
    _xAdminParams.Set( pAdminParams );

    CCiFrameworkParams * pFrameParams = new CCiFrameworkParams( pAdminParams );
    _xFrameParams.Set( pFrameParams );
}

CCiManager::~CCiManager()
{
    Win4Assert( 0 == _refCount );

    delete _pFilterDaemon;
    delete _pcci;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::QueryInterface
//
//  Synopsis:   Returns interfaces to IID_IUknown, IID_ICiManager,
//              IID_ICiStartup, IID_ICiAdmin, IID_ICiFrameworkQuery,
//              IID_ISimpleCommandCreator
//
//  History:    11-27-96   srikants   Created
//               2-14-97   mohamedn   ICiAdmin and ICiFrameworkQuery
//              04-23-97   KrishnaN   Exposed IID_ISimpleCommandCreator
//              04-23-97   KrishnaN   Replaced RtlEqualMemory with ==
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ISimpleCommandCreator == riid )
        *ppvObject = (void *)((ISimpleCommandCreator *)this);
    else if ( IID_ICiManager == riid )
        *ppvObject = (void *)((ICiManager *)this);
    else if ( IID_ICiStartup == riid )
        *ppvObject = (void *)((ICiStartup *)this);
    else if ( IID_ICiAdmin == riid )
        *ppvObject = (void *)((ICiAdmin *)this);
    else if ( IID_ICiFrameworkQuery == riid )
        *ppvObject = (void *)((ICiFrameworkQuery *)this);
    else if ( IID_ICiPersistIncrFile == riid )
        *ppvObject = (void *)((ICiPersistIncrFile *)this);
    else if ( (IID_ICiIndexNotification == riid )
              && !_xIndexNotifTable.IsNull() )
    {
        return _xIndexNotifTable->QueryInterface( riid, ppvObject );
    }
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiManager *) this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiManager::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiManager::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;

}  //Release


//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::GetStatus
//
//  Synopsis:   Retrieves the Content Index status
//
//  Arguments:  [pCiState] -
//
//  History:    1-08-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::GetStatus(CIF_STATE *pCiState)
{
    Win4Assert( 0 != pCiState );

    SCODE sc = S_OK;

    if ( 0 != _pcci )
        _pcci->CiState( *pCiState );
    else
        sc = CI_E_NOT_INITIALIZED;

    return sc;

}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::Empty
//
//  Synopsis:   Empties all the contents of the Content Index.
//
//  History:    1-08-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::Empty()
{
    SCODE sc = S_OK;

    if ( 0 != _pcci )
        _pcci->Empty();
    else
        sc = CI_E_NOT_INITIALIZED;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::Shutdown
//
//  Synopsis:   Shuts down Content Index. Cannot initiate any more queries after
//              this.
//
//  Returns:    SCODE of the operation.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::Shutdown()
{
    SCODE sc = S_OK;

    // =======================================
    {
        CLock   lock(_mutex);
        if ( IsShutdown() )
            return CI_E_SHUTDOWN;
        _state = SHUTDOWN;
    }
    // =======================================

    _saveTracker.SetAbort();

    if ( _pFilterDaemon )
        _pFilterDaemon->InitiateShutdown();

    if ( _pcci )
        _pcci->Dismount();

    //
    // Wait for the death of the filter daemon thread.
    //
    if ( _pFilterDaemon )
        _pFilterDaemon->WaitForDeath();

    _saveTracker.WaitForCompletion();

    //
    // Shutdown buffered notifications in push filtering,
    // _after_ the filter thread has terminated.
    //
    if ( !_xIndexNotifTable.IsNull() )
        _xIndexNotifTable->Shutdown();

    _xPropMapper.Free();
    _xDocStore.Free();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::UpdateDocument
//
//  Synopsis:   Schedules a document for update and filtering.
//
//  Arguments:  [pInfo] - Information about the document to be updated.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::UpdateDocument(
    const CI_DOCUMENT_UPDATE_INFO * pInfo )
{
    if ( _xIndexNotifTable.IsNull() )
        return UpdDocumentNoThrow( pInfo );
    else
    {
        // Win4Assert( !"UpdateDocument is not available in push filtering" );
        ciDebugOut ((DEB_ERROR,
                     "UpdateDocument is not available in push filtering, wid = 0x%x\n",
                     pInfo->workId ));

        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::StartupNullContentIndex
//
//  Synopsis:   Starts up the NULL content index.
//
//  Arguments:  [pwszCiDirectory] - Starting directory for storing CI data.
//              [pStartupInfo]    - Startup information.
//              [pIProgressNotify]  - Progress notification i/f
//              [pfAbort]           - Ptr to flag controlling abort.
//
//  History:    Jul-09-97   KrishnaN   Created
//
//  Notes:      The thread calling this MUST be in the SYSTEM/ADMINISTRATIVE
//              context, ie, have the highest privilege needed for Content Index.
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::StartupNullContentIndex(
    CI_STARTUP_INFO * pStartupInfo,
    IProgressNotify  *pIProgressNotify,
    BOOL  * pfAbort )
{
    // Anything but null for the second param...
    return StartupContentIndex(TRUE, CINULLCATALOG, pStartupInfo, pIProgressNotify, pfAbort);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::StartupContentIndex
//
//  Synopsis:   Starts up the content index using the startup parameters
//              provided.
//
//  Arguments:  [pwszCiDirectory] - Starting directory for storing CI data.
//              [pStartupInfo]    - Startup information.
//              [pIProgressNotify]  - Progress notification i/f
//              [pfAbort]           - Ptr to flag controlling abort.
//
//  History:    12-09-96   srikants   Created
//
//  Notes:      The thread calling this MUST be in the SYSTEM/ADMINISTRATIVE
//              context, ie, have the highest privilege needed for Content Index.
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::StartupContentIndex(
    const WCHAR * pwszCiDirectory,
    CI_STARTUP_INFO * pStartupInfo,
    IProgressNotify  *pIProgressNotify,
    BOOL  * pfAbort )
{
    return StartupContentIndex(FALSE, pwszCiDirectory, pStartupInfo, pIProgressNotify, pfAbort);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::StartupContentIndex
//
//  Synopsis:   Starts up the content index using the startup parameters
//              provided.
//
//  Arguments:  [fNullContentIndex] - Null content index?
//              [pwszCiDirectory]   - Starting directory for storing CI data.
//              [pStartupInfo]      - Startup information.
//              [pIProgressNotify]  - Progress notification i/f
//              [pfAbort]           - Ptr to flag controlling abort.
//
//  History:    12-09-96   srikants   Created
//              02-17-98   kitmanh    Passed fReadOnly into CiStorage
//                                    constructor
//              01-Nov-98  KLam       Passed DiskSpaceToLeave to CiStorage
//
//  Notes:      The thread calling this MUST be in the SYSTEM/ADMINISTRATIVE
//              context, ie, have the highest privilege needed for Content Index.
//
//----------------------------------------------------------------------------

SCODE CCiManager::StartupContentIndex(
    BOOL fNullContentIndex,
    const WCHAR * pwszCiDirectory,
    CI_STARTUP_INFO * pStartupInfo,
    IProgressNotify  *pIProgressNotify,
    BOOL  * pfAbort )
{
    Win4Assert( !CImpersonateSystem::IsImpersonated() );
    Win4Assert( 0 != pwszCiDirectory && 0 != pStartupInfo );

    _fNullContentIndex = fNullContentIndex;

    CLock   lock(_mutex);

    if ( STARTING != _state )
    {
        return CI_E_INVALID_STATE;
    }

    _startupFlags = pStartupInfo->startupFlags;

    BOOL fPushFiltering = FALSE;

    if (!fNullContentIndex)
    {

        _fInProc = pStartupInfo->startupFlags & CI_CONFIG_INPROCESS_FILTERING;
        fPushFiltering = pStartupInfo->startupFlags & CI_CONFIG_PUSH_FILTERING;

        if ( fPushFiltering && !_fInProc )
        {
            Win4Assert( !"Simple filtering is supported only with in process filtering" );

            return E_INVALIDARG;
        }
    }


    SCODE sc = S_OK;

    TRY
    {
        if ( !fNullContentIndex && fPushFiltering )
        {
            XInterface<ICiCDocStore> xDocStore( _xDocStore.GetPointer() );
            xDocStore->AddRef();

            _xIndexNotifTable.Set( new CIndexNotificationTable( this,
                                                                xDocStore ) );
        }

        BOOL fEnableFiltering =
            pStartupInfo->startupFlags & CI_CONFIG_ENABLE_INDEXING;

        // If this is a null content index, filtering should be disabled.
        Win4Assert( (fNullContentIndex && !fEnableFiltering) || !fNullContentIndex);

        if ( 0 == _pcci )
        {
            CLowcaseBuf lcaseDir( pwszCiDirectory );

            //
            // Make a copy to be acquired by CCiManager.
            //
            XArray<WCHAR> xDirCopy( lcaseDir.Length()+1 );

            if (!fNullContentIndex)
            {
                RtlCopyMemory( xDirCopy.GetPointer(), lcaseDir.Get(), xDirCopy.SizeOf() );

                //
                // Create a PStorage object for CI framework data.
                //
                if ( 0 == _xStorage.GetPointer() )
                {
                    BOOL fReadOnly = (pStartupInfo->startupFlags & CI_CONFIG_READONLY) ? TRUE : FALSE;

                    CiStorage * pStorage = new CiStorage( lcaseDir.Get(),
                                                          _xAdviseStatus.GetReference(),
                                                          _xFrameParams->GetMinDiskSpaceToLeave(),
                                                          CURRENT_VERSION_STAMP, 
                                                          fReadOnly );
                    _xStorage.Set( pStorage );
                }
            }
            //
            // Try to obtain a property mapper from the docstore. If successful,
            // we don't have to create one. O/W, we create a property mapper.
            //
            XInterface<IPropertyMapper>  xPropMapper;
            IPropertyMapper * pPropMapper = 0;

            if ( pStartupInfo->startupFlags & CI_CONFIG_PROVIDE_PROPERTY_MAPPER )
            {
                xPropMapper.Set( _LokCreatePropertyMapper() );
            }
            else
            {
                SCODE scPropMapper = _xDocStore->GetPropertyMapper( &pPropMapper );
                if ( !SUCCEEDED(scPropMapper) )
                {
                    ciDebugOut(( DEB_ERROR,
                    "DocStore Is not providing property mapper. Error 0x%X\n",
                    scPropMapper ));
                    THROW( CException( E_INVALIDARG ) );
                }

                xPropMapper.Set( pPropMapper );
            }

            //
            // Update the worker queue registry settings.
            //
            _UpdateQueryWorkerQueueParams();

            //
            // Save the CLSID of the client manager in daemon process.
            //
            _clsidDmnClientMgr = pStartupInfo->clsidDaemonClientMgr;

            if (!fNullContentIndex)
            {
                if ( !_xIndexNotifTable.IsNull() )
                _xIndexNotifTable->AddRef();
                XInterface<CIndexNotificationTable> xNotifTable( _xIndexNotifTable.GetPointer() );

                _pcci = new CCI( _xStorage.GetReference(),
                             _xFrameParams.GetReference(),
                             _xDocStore.GetPointer(),
                             *pStartupInfo,
                             xPropMapper.GetPointer(),
                             xNotifTable );

                _xCiDir.Set( xDirCopy.Count(), xDirCopy.Get() );
                xDirCopy.Acquire();
            }

            _xPropMapper.Set( xPropMapper.Acquire() );


            //
            // Move to the next state depending upon the startup options.
            //
            if ( fEnableFiltering )
            {
                //
                // Check the disk free space situation.
                //
                _state = READY_TO_FILTER;

            }
            else
            {
                _state  = FILTERING_DISABLED;
                _reason = DISABLED_ON_STARTUP;
            }
        }
        else
        {
            sc = CI_E_ALREADY_INITIALIZED;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH


    return sc;

}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_LokGetStartFilteringError
//
//  Synopsis:   Determines the error code to be returned in the
//              StartFiltering() method based upon the current state.
//
//  Returns:
//
//  History:    12-10-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CCiManager::_LokGetStartFilteringError() const
{
    Win4Assert( READY_TO_FILTER != _state );

    if ( FILTERING_DISABLED == _state )
    {
        Win4Assert( INVALID_REASON != _reason );

        if ( DISABLED_ON_STARTUP == _state )
        {
            return CI_E_FILTERING_DISABLED;
        }
        else if ( DISABLED_FOR_DISK_FULL == _reason )
        {
            return CI_E_DISK_FULL;
        }
        else
        {
            return CI_E_INVALID_STATE;
        }
    }
    else if ( FILTERING_ENABLED == _state )
    {
        return S_OK;    // already enabled.
    }
    else
    {
        return CI_E_INVALID_STATE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::StartFiltering
//
//  Synopsis:   Start the filtering process
//
//  Arguments:  [cbData] - Count of bytes in startup data
//              [pbData] - Pointer to startup data
//
//  Returns:    CI_E_DISK_FULL if the disk is full and so filtering cannot be
//              started.
//
//              CI_E_FILTERING_DISABLED if filtering was disabled in the startup
//              options.
//
//              CI_E_INVALID_STATE if this is not a valid call in this state.
//              Usually signifies that shutdown is in progress.
//
//  History:    12-09-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::StartFiltering(
    ULONG cbData,
    BYTE const * pbData )
{
    SCODE sc = S_OK;

    // ==============================================================
    {
        CLock   lock(_mutex);

        if ( READY_TO_FILTER != _state )
        {
            return _LokGetStartFilteringError();
        }

        TRY
        {
            if ( 0 == _pFilterDaemon )
            {
                CSharedNameGen  nameGen( _xCiDir.Get() );

                _pFilterDaemon = new CDaemonSlave( *this,
                                               _pcci,
                                               _xCiDir.Get(),
                                               nameGen,
                                               _clsidDmnClientMgr );
            }

            _pFilterDaemon->StartFiltering( pbData, cbData);

            _state = FILTERING_ENABLED;
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH
    }
    // ==============================================================

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::FlushUpdates
//
//  Synopsis:   Flushes all update notifications to disk
//
//  Returns:    S_OK if successful; error code otherwise.
//
//  History:    27-Jun-97    SitaramR   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::FlushUpdates()
{
    SCODE sc = S_OK;

    TRY
    {
        if ( IsShutdown() )
            sc = CI_E_SHUTDOWN;
        else
            _pcci->FlushUpdates();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "FlushUpdates - caught exception 0x%x\n",
                     sc ));
    }
    END_CATCH

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::ForceMerge
//
//  Synopsis:   Forces a master merge on the content index.
//
//  Arguments:  [mt] -- Merge type (shadow, master, etc.)
//
//  Returns:    S_OK if successfully forced; error code otherwise.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::ForceMerge( CI_MERGE_TYPE mt )
{
    SCODE sc = S_OK;

    if ( 0 != _pcci )
    {
        Win4Assert( STARTING != _state );
        sc = _pcci->ForceMerge( partidDefault, mt );
    }
    else
    {
        sc = CI_E_NOT_INITIALIZED;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::AbortMerge
//
//  Synopsis:   Aborts any in progress merge on the content index.
//
//  Returns:    S_OK if successfully forced; error code otherwise.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::AbortMerge()
{
    SCODE sc = S_OK;

    if ( 0 != _pcci )
    {
        Win4Assert( STARTING != _state );
        sc = _pcci->AbortMerge( partidDefault );
    }
    else
    {
        sc = CI_E_NOT_INITIALIZED;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::IsQuiesced
//
//  Synopsis:   Tests if Content Index is quiesced (no activity). ContentIndex
//              is considered quiesced if there are no outstanding documents
//              to filter, there is only one index and there are no wordlists.
//
//  Arguments:  [pfState] -  Set to TRUE if it CI is quiesced; FALSE o/w
//
//  History:    1-08-97   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiManager::IsQuiesced( BOOL * pfState )
{

    Win4Assert( 0 != pfState );

    CIF_STATE ciState;
    ciState.cbStruct = sizeof ciState;

    SCODE sc =  GetStatus( &ciState );
    if ( S_OK == sc )
    {
        *pfState = 0 == ciState.eState &&
                   0 == ciState.cWordList &&
                   0 == ciState.cDocuments &&
                   0 == ciState.cFreshTest &&
                   ciState.cPersistentIndex <= 1;
    }

    return sc;
}

//
// ICiPersistIncrFile methods
//
//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::Save
//
//  Synopsis:   Saves the Content Index data in the directory provided.
//              An incremental save for the first time will actually be a full
//              save.
//
//  Arguments:  [pwszSaveDirectory] - The directory in which to save the backup
//              data. This directory MUST be on a local drive and security protected.
//              It is recommended that this directory has the same security set as the
//              current content index directory. Also, it MUST be on a local drive.
//              [fFull]             - Set to TRUE if a full save is being requested.
//              [pIProgressNotify]  - Interface to give progress notification.
//              [pfAbort]           - This flag will be set to TRUE by the caller if
//              the caller wants the operation to be aborted before completion.
//              [ppWorkidList]      - On output, will have the list of changed workids.
//              On a full save, this list may be empty in which case the caller must
//              assume that all the know workids have changed.
//              [ppFileList]        - On output, will be set to the filelist enumerator.
//              [pfFull]            - Set to TRUE if a FULL save was done.
//              [pfCallerOwnsFiles] - Set to TRUE if the caller has the responsibility to
//              clean up the files.
//
//  Returns:    S_OK if successful
//              Other error code as appropriate.
//
//  History:    3-20-97   srikants   Created
//              01-Nov-98 KLam       Added DiskSpaceToLeave to CiStorage constructor
//
//  Notes:      Handle DISK_FULL as a special case.
//              Right now there is no restartability - if an operation fails in
//              the middle due to any problem, the whole operation is aborted
//              and the partially created files are deleted. We should do some
//              logging to indicate the progress made so far and have a notion of
//              restartability. The time I have does not permit doing the
//              restartability - SriKants - 3-20-97
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::Save(
                    const WCHAR *pwszSaveDirectory,
                    BOOL fFull,
                    IProgressNotify  *pIProgressNotify,
                    BOOL  *pfAbort,
                    ICiEnumWorkids  ** ppWorkidList,
                    IEnumString ** ppFileList,
                    BOOL * pfFull,
                    BOOL * pfCallerOwnsFiles)

{

    Win4Assert( !CImpersonateSystem::IsImpersonated() );

    if ( !_IsIncrIndexingEnabled() )
        return CI_E_INVALID_STATE;

    if ( 0 == _pcci )
        return CI_E_INVALID_STATE;

    if ( IsShutdown() )
        return CI_E_SHUTDOWN;

    //=====================================
    {
        //
        // There can be only one instance of "Save()" running at
        // any time.
        //
        CLock   lock(_mutex);
        if ( !_saveTracker.LokIsTracking() )
        {
            _saveTracker.LokStartTracking( pIProgressNotify, pfAbort );
        }
        else
        {
            return CI_E_INVALID_STATE;
        }
    }
    //=====================================

    SCODE sc = S_OK;

    TRY
    {

        if ( !_IsValidSaveDirectory( pwszSaveDirectory ) )
        {
            ciDebugOut(( DEB_ERROR, "Invalid Save Directory (%ws)\n",
                                    pwszSaveDirectory ));
            THROW( CException( E_INVALIDARG ) );
        }

        XInterface<ICiEnumWorkids>  xEnumWorkids;

        XPtr<CiStorage> xStorage(
            new CiStorage( pwszSaveDirectory,
                          _xAdviseStatus.GetReference(),
                          _xFrameParams->GetMinDiskSpaceToLeave(),
                          CURRENT_VERSION_STAMP ));

        //
        // Until we have a restartable save, nuke all the files in the specified
        // directory.
        //
        xStorage->DeleteAllFiles();

        BOOL fIsFull = fFull;
        SCODE sc = _pcci->BackupCiData( xStorage.GetReference(),
                                        fIsFull,                 // in-out parameter
                                        xEnumWorkids,
                                        _saveTracker );

        if ( !SUCCEEDED(sc) )
        {
            THROW( CException(sc) );
        }

        //
        // If we provided the property mapper, we must copy that too.
        //
        if ( 0 != _pPidLookupTable )
            _CreateBackupOfPidTable( xStorage.GetReference(), _saveTracker );

        //
        // Create an enumerated list of the files created in this save.
        //
        CEnumString * pEnumStr = new CEnumString;
        XInterface<IEnumString> xEnumStr( pEnumStr );
        CiStorage::EnumerateFilesInDir( pwszSaveDirectory, *pEnumStr );

        //
        // Setup the return parameter values.
        //
        *ppWorkidList = xEnumWorkids.Acquire();
        *ppFileList = xEnumStr.Acquire();
        *pfFull = fIsFull;
        *pfCallerOwnsFiles = TRUE;
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Error in CCiManager::Save. (0x%X)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    //=====================================
    {
        CLock   lock(_mutex);
        _saveTracker.LokStopTracking();
    }
    //=====================================

    return sc;

}


// ICiFrameWorkQuery interface - interface that is internal to the
// framework indexing and querying only.
//

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::ProcessError
//
//  Synopsis:   Processes the error code. Only the corruption error is of
//              interest to notify the content index which in turn will
//              notify the client.
//
//  Arguments:  [lErrorCode] -
//
//  History:    1-08-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::ProcessError( long lErrorCode )
{
    if ( IsCiCorruptStatus( lErrorCode ) && 0 != _pcci )
        _pcci->MarkCorruptIndex();

    return S_OK;
}

//
// ISimpleCommandCreator methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::CreateICommand, public
//
//  Synopsis:   Exposes an ICommand from the framework.
//
//  Arguments:  [ppiCommand] - Transports back an instance of the ICommand
//
//  History:    04-22-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiManager::CreateICommand (IUnknown ** ppIUnknown, IUnknown * pOuterUnk)
{
    if (0 == ppIUnknown)
    {
        ciDebugOut((DEB_ERROR, "Invalid ppICommand passed to CCiManager::CreateICommand"));
        return E_INVALIDARG;
    }

    *ppIUnknown = 0;

    if ( 0 ==_xDocStore.GetPointer() )
        return E_NOINTERFACE;

    return MakeLocalICommand(ppIUnknown, _xDocStore.GetPointer(), pOuterUnk);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::VerifyCatalog, public
//
//  Synopsis:   Validate catalog location
//
//  Arguments:  [pwszMachine]     -- Machine on which catalog exists
//              [pwszCatalogName] -- Catalog Name
//
//  Returns:    S_OK for now...
//
//  History:    22-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiManager::VerifyCatalog( WCHAR const * pwszMachine,
                                                   WCHAR const * pwszCatalogName )
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::GetDefaultCatalog, public
//
//  Synopsis:   Determine 'default' catalog for system
//
//  Arguments:  [pwszCatalogName] -- Catalog Name
//              [cwcIn]           -- Size in characters of [pwszCatalogName]
//              [pcwcOut]         -- Size of catalog name
//
//  Returns:    E_NOTIMPL
//
//  History:    22-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CCiManager::GetDefaultCatalog( WCHAR * pwszCatalogName,
                                                       ULONG cwcIn, ULONG * pcwcOut )
{
    return E_NOTIMPL;
}

//
// Non-Interface methods
//

void CCiManager::ProcessCiDaemonTermination( SCODE sc )
{
    CLock   lock(_mutex);

    if ( _xDocStore.GetPointer() )
    {
        _state = READY_TO_FILTER;
        sc = _xDocStore->ProcessCiDaemonTermination(sc);
        if ( !SUCCEEDED(sc) )
        {
            ciDebugOut(( DEB_ERROR,
                         "ICiCDocStore::ProcessCiDaemonTermination returned 0x%X\n",
                         sc ));
            THROW( CException( sc ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_LokCreatePropertyMapper
//
//  Synopsis:   Creates a property mapper object.
//
//  History:    1-31-97   srikants   Created
//
//----------------------------------------------------------------------------

IPropertyMapper * CCiManager::_LokCreatePropertyMapper()
{
    Win4Assert( 0 == _xPropMapper.GetPointer() );
    Win4Assert( 0 == _pPidLookupTable );

    XPtr<CPidLookupTable> xPidTable( new CPidLookupTable );

    PRcovStorageObj * pObj = _xStorage->QueryPidLookupTable(0);

    // Init takes ownership regardless of whether it succeeds.

    if ( !xPidTable->Init( pObj ) )
    {
        ciDebugOut ((DEB_ERROR, "Failed init of PidTable\n"));
        THROW (CException(CI_CORRUPT_CATALOG));
    }

    IPropertyMapper * pMapper = new CFwPropertyMapper( xPidTable.GetReference(),
                                                       _fNullContentIndex, // map std props only?
                                                       TRUE // Own the pid table
                                                     );
    _pPidLookupTable = xPidTable.Acquire();

    return pMapper;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_CreateBackupOfPidTable
//
//  Synopsis:   Creates a copy of the pid table.
//
//  Arguments:  [storage] - Storage to use
//              [tracker] - Progress Tracker
//
//  History:    3-20-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiManager::_CreateBackupOfPidTable( CiStorage & storage,
                                          PSaveProgressTracker & tracker )
{
    Win4Assert( 0 != _pPidLookupTable );

    PRcovStorageObj * pObj = storage.QueryPidLookupTable(0);
    XPtr<PRcovStorageObj> xObj(pObj);

    _pPidLookupTable->MakeBackupCopy( *pObj, tracker );

}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_UpdateQueryWorkerQueueParams
//
//  Synopsis:   Updates the worker queue parameters
//
//  History:    1-03-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiManager::_UpdateQueryWorkerQueueParams()
{
    //
    // Getting these from the registry is fine for Indexing Service,
    // but will be fixed in the PKM codebase.
    //

    ULONG cMaxActiveThreads, cMinIdleThreads;
    TheWorkQueue.GetWorkQueueRegParams( cMaxActiveThreads,
                                        cMinIdleThreads );
    TheWorkQueue.RefreshParams( cMaxActiveThreads, cMinIdleThreads );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::UpdDocumentNoThrow
//
//  Synopsis:   Real worker function that schedules a document for update
//              and filtering. This is called directly in push filtering.
//
//  Arguments:  [pInfo] - Information about the document to be updated.
//
//  History:    15-Mar-97     SitaramR      Created
//
//  Notes:      Does not throw because this is simply a worker function
//              for UpdateDocument
//
//----------------------------------------------------------------------------

SCODE CCiManager::UpdDocumentNoThrow( const CI_DOCUMENT_UPDATE_INFO * pInfo )
{
    Win4Assert( 0 != pInfo );

    SCODE sc = S_OK;

    TRY
    {
        if ( 0 == _pcci  )
            sc = CI_E_NOT_INITIALIZED;
        else
        {
            ULONG hint = _pcci->ReserveUpdate( pInfo->workId );

            ULONG action = CI_UPDATE_OBJ;
            if ( CI_UPDATE_DELETE == pInfo->change )
                action = CI_DELETE_OBJ;

            sc = _pcci->Update( hint,
                                pInfo->workId,
                                partidDefault,
                                pInfo->usn,
                                pInfo->volumeId,
                                action );
        }
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR,
                     "CCiManager::UpdDocument - Error 0x%X\n",
                     e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_IsValidLoadDirectory
//
//  Synopsis:   Verifies that the given directory is a valid directory.
//              It ensures that files INDEX.000, INDEX.001, INDEX.002
//              are in the directory.
//
//  Arguments:  [pwszDirPath] - Directory path to verify.
//
//  Returns:    TRUE if valid; FALSE o/w; May throw exceptions.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CCiManager::_IsValidSaveDirectory( WCHAR const * pwszDirPath )
{
    //
    // Confirm that it is a local drive.
    //
    UINT driveType = CiStorage::DetermineDriveType( pwszDirPath );
    if ( DRIVE_FIXED != driveType )
    {
        ciDebugOut(( DEB_ERROR,
                     "The given path (%ws) is not a local fixed disk\n",
                     pwszDirPath ));
        THROW( CException( E_INVALIDARG ) );
    }

    const MAX_DIR_PATH = MAX_PATH - 13; // Leave room for "\\8.3"


    DWORD dwFileAttributes = GetFileAttributes( pwszDirPath );
    if ( 0xFFFFFFFF == dwFileAttributes )
        return FALSE;

    return dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiManager::_CompareIncrDataSequence
//
//  Synopsis:   Compares the sequence number information stored in the
//              current catalog and the information in the new files.
//
//  Arguments:  [pwszNewFilesDir] - Directory where the new INDEX.* files
//              are located.
//
//  Returns:    TRUE if they match. FALSE o/w
//
//  History:    3-19-97   srikants   Created
//              01-Nov-98 KLam       Added DiskSpaceToLeave to CiStorage constructor
//
//----------------------------------------------------------------------------

BOOL CCiManager::_CompareIncrDataSequence( WCHAR const * pwszNewFilesDir )
{
    Win4Assert( !_xStorage.IsNull() );

    //
    // Create a new CiStorage for the target directory.
    //
    XPtr<CiStorage>   xStorage(
            new CiStorage( pwszNewFilesDir,
                           _xAdviseStatus.GetReference(),
                           _xFrameParams->GetMinDiskSpaceToLeave(),
                           CURRENT_VERSION_STAMP) );

    //
    // Create the index table for the current storage location.
    //
    CTransaction    xact;
    XPtr<CIndexTable> xCurrTable(
                        new CIndexTable( _xStorage.GetReference(), xact ));

    XPtr<CIndexTable> xNewTable(
                        new CIndexTable( xStorage.GetReference(), xact ));

    unsigned currVersion, newVersion;
    BOOL     fFullSave;

    xCurrTable->GetUserHdrInfo( currVersion, fFullSave ); // fFullSave is ignored
    xNewTable->GetUserHdrInfo( newVersion, fFullSave );

    ciDebugOut(( DEB_WARN, "%s\nCurrent Version = %d\n New Version = %d\n",
                  fFullSave ? "FullSave" : "Incr. Save",
                  currVersion, newVersion ));

    if ( fFullSave )
    {
        //
        // For FULL save, any version is fine.
        return TRUE;
    }
    else
    {
        //
        // For an incremental save, the seqnums in the source and
        // destination must match. Otherwise, it should be ignored.
        //
        return currVersion == newVersion;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\cicontrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cicontrl.cxx
//
//  Contents:   Contains the implementation of ICiControl interface.
//
//  History:    1-17-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

#include "cicontrl.hxx"
#include "cimanger.hxx"

const GUID clsidCiControl = CLSID_CiControl;

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CCiControlObject::QueryInterface
//
//  Synopsis:   Returns interfaces to IID_IUknown, IID_ICiControl
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiControlObject::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiControl == riid )
        *ppvObject = (void *)((ICiControl *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiControl *) this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CCiControlObject::AddRef
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiControlObject::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCiControlObject::Release
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiControlObject::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;

}  //Release


//+---------------------------------------------------------------------------
//
//  Member:     CCiControlObject::CreateContentIndex
//
//  Synopsis:   Creates a new Content Index and associates it with the
//              ICiCDocStore provided.
//
//  Arguments:  [pICiCDocStore] - DocStore to associate with
//              [ppICiManager]  - On output, if successful will have the
//              ICiManager interface.
//
//  History:    1-17-97   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiControlObject::CreateContentIndex(
        ICiCDocStore *  pICiCDocStore,
        ICiManager   ** ppICiManager )
{
    *ppICiManager = 0;

    SCODE sc = S_OK;
    if ( 0 == pICiCDocStore )
        return E_INVALIDARG;    

    TRY
    {
        CCiManager * pCiManager = new CCiManager( pICiCDocStore );
        *ppICiManager = pCiManager;
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Failed to create CCiManager. Error (0x%X)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Construction and destruction
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::CCiControlObjectCF
//
//  Synopsis:   Storage Filter Object class factory constructor
//
//  History:    17-Jan-1997  Srikants   Created
//
//+-------------------------------------------------------------------------

CCiControlObjectCF::CCiControlObjectCF()
    : _RefCount( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::~CCiControlObjectCF
//
//  Synopsis:   Storage Filter Object class factory destructor
//
//  History:    6-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

CCiControlObjectCF::~CCiControlObjectCF()
{
    Win4Assert( _RefCount == 0);
    Win4Assert( gulcInstances != 0 );
    
    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiControlObjectCF::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    6-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiControlObjectCF::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;

}   //  Release

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiControlObjectCF::QueryInterface( 
    REFIID riid,
    PVOID* ppvObject )
{
    Win4Assert( 0 != ppvObject );
    
    if ( IID_IUnknown == riid ) {
        AddRef( );
        *ppvObject = (PVOID) ((IUnknown *) this );
        return S_OK;
    } else if ( IID_IClassFactory == riid) {
        AddRef( );
        *ppvObject = (PVOID) ((IClassFactory *) this );
        return S_OK;
    } else {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::CreateInstance
//
//  Synopsis:   Create new CStorageFilterObject instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiControlObjectCF::CreateInstance( 
    IUnknown * pUnkOuter,
    REFIID riid,
    PVOID * ppvObject )
{

    if ( 0 != pUnkOuter )
        return ResultFromScode( CLASS_E_NOAGGREGATION );    

    CCiControlObject * pObject = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        //
        //  Create the new object
        //
        
        pObject = new CCiControlObject;

        //
        //  Obtain the new interface
        //
        
        sc = pObject->QueryInterface( riid , ppvObject );

        //
        //  Regardless of whether the QueryInterface succeeded, we
        //  release the object.
        //
        
        pObject->Release();  
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pObject );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiControlObjectCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiControlObjectCF::LockServer( BOOL fLock )
{
    if (fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\ciframe.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ciframe.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <frmutils.hxx>
#include <lang.hxx>
#include <worker.hxx>

#include "ciframe.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::QueryInterface
//
//  Arguments:  [riid]      -- Interface ID
//              [ppvObject] -- Object returned here
//
//  Returns:    S_OK if [riid] found.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiAdminParams::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    *ppvObject = 0;

    if ( IID_ICiAdminParams == riid )
        *ppvObject = (void *)((ICiAdminParams *)this);
    else if ( IID_ICiAdmin == riid )
        *ppvObject = (void *)((ICiAdmin *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *)(ICiAdminParams *)this);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiAdminParams::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCiCDocName::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiAdminParams::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::GetValue
//
//  Synopsis:   Gets the parameter value, if it is a DWORD type.
//
//  Arguments:  [param]    - [in]  Parameter to retrive
//              [pdwValue] - [out] The value of the parameter.
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if wrong parameters.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiAdminParams::GetValue(
    CI_ADMIN_PARAMS param,
    DWORD * pdwValue )
{
    Win4Assert( 0 != pdwValue );

    if ( param < CI_AP_MAX_DWORD_VAL )
    {
        *pdwValue = (DWORD) _adwParams[ param ];
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::GetValue
//
//  Synopsis:   Gets the parameter value, if it is a DWORD type.
//
//  Arguments:  [param]    - [in]  Parameter to retrive
//              [pdwValue] - [out] The value of the parameter.
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if wrong parameters.
//
//  History:    10-Jun-97   KyleP      Added header, MaxFileSize in KB.
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiAdminParams::GetInt64Value( CI_ADMIN_PARAMS param, __int64 * pValue )
{
    Win4Assert( 0 != pValue );

    if ( !IsValidParam(param) )
        return E_INVALIDARG;

    if ( param < CI_AP_MAX_DWORD_VAL )
    {
        *pValue = _adwParams[param];
    }
    else
    {
        //
        // Currently, there are no non-dword values.
        //

        Win4Assert( param < CI_AP_MAX_DWORD_VAL );
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::SetValues
//
//  Synopsis:   calls CCiAdminParams::SetValue() for each of the property
//              variant values.
//
//  Arguments:  [ULONG nParams]         - [in] number of elements in the array.
//              [PROPVARIANT *]         - [in] array of property variants of
//                                        size CI_AP_MAX_VAL containing
//                                        new CI settings.
//              [CI_ADMIN_PARAMS *]     - [in] array of CI_ADMIN_PARAMS values
//                                        used as indices in teh prop variant array.
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if wrong parameters (returned from SetParamValue()).
//
//  History:    1-24-97   mohamedn   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiAdminParams::SetValues(ULONG nParams,
                                       const PROPVARIANT     *  aParamVals,
                                       const CI_ADMIN_PARAMS *  aParamNames)
{
    SCODE sc = S_OK;

    for ( ULONG i = 0; i < nParams; i++)
    {
        switch ( aParamNames[i] )
        {
           case CI_AP_MAX_DWORD_VAL:
           case CI_AP_MAX_VAL:
               continue;    //  values are place holders.

           default:
               Win4Assert( aParamNames[i] < CI_AP_MAX_VAL );

               sc = SetParamValue( aParamNames[i], aParamVals+i );

               if (sc != S_OK)
                   return sc;
        }
    }
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::SetValue
//
//  Synopsis:   Sets the value of the given parameter, if it is a DWORD type.
//
//  Arguments:  [param]   - [in] Parameter
//              [dwValue] - [in] Value to set
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if wrong parameters.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiAdminParams::SetValue(
    CI_ADMIN_PARAMS param,
    DWORD dwValue )
{

    SCODE sc = S_OK;

    // =================================================================
    CLock   lock(_mutex);

    if ( param < CI_AP_MAX_DWORD_VAL )
        _adwParams[param] = _GetValueInRange( param, dwValue );
    else
        sc = E_INVALIDARG;

    // =================================================================

    return sc;
}
//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::SetParamValue
//
//  Synopsis:   Sets the value of a parameter, given a DWORD
//
//  Arguments:  [param]     - [in] Parameter
//              [pvarValue] - [in] Value
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if bad parameter.
//
//  History:    11-27-96   srikants   Created
//
//-----------------------------------------------------------------------


STDMETHODIMP CCiAdminParams::SetParamValue(
    CI_ADMIN_PARAMS param,
    PROPVARIANT const * pvarValue )
{
    Win4Assert( 0 != pvarValue );

    SCODE sc = S_OK;

    // =================================================================

    CLock lock( _mutex );

    CStorageVariant const * pVar = ConvertToStgVariant( pvarValue );

    if ( param < CI_AP_MAX_DWORD_VAL )
    {
        Win4Assert( VT_I4  == pvarValue->vt ||
                    VT_UI4 == pvarValue->vt );

        long lVal = *pVar;
        _adwParams[param] = (DWORD) *pVar;
    }
    else
    {
        //
        // Currently no non-dword values.
        //

        Win4Assert( param < CI_AP_MAX_DWORD_VAL );

        sc = E_INVALIDARG;
    }

    // =================================================================

    return sc;
}
//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::GetParamValue
//
//  Synopsis:   Retrieves the value of a parameter as a variant.
//
//  Arguments:  [param]     -  [in]  Parameter
//              [ppvarValue] - [out] Value on return
//
//  Returns:    S_OK if successful;
//              E_INVALIDARG if bad parameters.
//              E_OUTOFMEMORY if no memory.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiAdminParams::GetParamValue(
    CI_ADMIN_PARAMS param,
    PROPVARIANT ** ppvarValue )
{
    Win4Assert( 0 != ppvarValue );

    if ( !IsValidParam(param) )
        return E_INVALIDARG;

    if ( param < CI_AP_MAX_DWORD_VAL )
    {
        CStorageVariant * pVar = new CStorageVariant( (long) _adwParams[param] );
        *ppvarValue = ConvertToPropVariant( pVar );
    }
    else
    {
        //
        // Currently no non-dword parameters.
        //

        Win4Assert( param < CI_AP_MAX_DWORD_VAL );
    }

    if ( *ppvarValue )
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::IsSame
//
//  Synopsis:   Tests if the value for the parameter specified is same as
//              the one given.
//
//  Arguments:  [param]     - [in]  Parameter
//              [pvarValue] - [in]  Value given by the caller
//              [pfSame]    - [out] TRUE if the value contained is same as
//                            the one passed; FALSE o/w
//
//  Returns:    S_OK if successful
//              E_INVALIDARG if bad parameter.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CCiAdminParams::IsSame(
    CI_ADMIN_PARAMS param,
    const PROPVARIANT * pvarValue,
    BOOL * pfSame )
{
    Win4Assert( pvarValue );
    Win4Assert( pfSame );

    CStorageVariant const * pVar = ConvertToStgVariant( pvarValue );

    if ( param < CI_AP_MAX_DWORD_VAL )
    {
        DWORD dwVal = *pVar;
        *pfSame = ( dwVal == _adwParams[param] );
    }
    else
    {
        //
        // Currently no non-dword parameters.
        //

        Win4Assert( param < CI_AP_MAX_DWORD_VAL );

        return E_INVALIDARG;
    }

    return S_OK;

}

STDMETHODIMP CCiAdminParams::InvalidateLangResources()
{
    if ( 0 != _pLangList )
        _pLangList->InvalidateLangResources();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiAdminParams::CCiAdminParams
//
//  Synopsis:   Constructor of the CI admin parameters. Sets the values to
//              default values.
//
//  History:    12-02-96   srikants   Created
//
//----------------------------------------------------------------------------

CCiAdminParams::CCiAdminParams( CLangList * pLangList )
    : _refCount( 1 ),
      _pLangList( pLangList )
{
    RtlZeroMemory( &_adwParams, sizeof(_adwParams) );

    //
    // Initialize the default values of all parameters.
    //
    for ( unsigned i = 0; i < CI_AP_MAX_DWORD_VAL; i++ )
    {
        _adwParams[i] = _adwRangeParams[i]._dwDefault;
    }

    //
    // Add assertions to verify that the default values are correct.
    //

#if 0
    Win4Assert( _adwRangeParams[CI_AP_XXXX]._dwDefault ==
                CI_XXXX_DEFAULT );

  { CI_XXXX_DEFAULT, CI_XXXX_DEFAULT,
    CI_XXXX_DEFAULT },

#endif  // 0


    Win4Assert( _adwRangeParams[CI_AP_MERGE_INTERVAL]._dwDefault ==
                CI_MAX_MERGE_INTERVAL_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_UPDATES]._dwDefault ==
                CI_MAX_UPDATES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_WORDLISTS]._dwDefault ==
                CI_MAX_WORDLISTS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_SIZE_MERGE_WORDLISTS]._dwDefault ==
                CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_WORDLIST_SIZE]._dwDefault ==
                CI_MAX_WORDLIST_SIZE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_WORDLIST_MEMORY]._dwDefault ==
                CI_MIN_WORDLIST_MEMORY_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_LOW_RESOURCE_SLEEP]._dwDefault ==
                CI_LOW_RESOURCE_SLEEP_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_WORDLIST_MEMORY_LOAD]._dwDefault ==
                CI_MAX_WORDLIST_MEMORY_LOAD_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_FRESH_COUNT]._dwDefault ==
                CI_MAX_FRESHCOUNT_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_SHADOW_INDEX_SIZE]._dwDefault ==
                CI_MAX_SHADOW_INDEX_SIZE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_DISK_FREE_FORCE_MERGE]._dwDefault ==
                CI_MIN_DISKFREE_FORCE_MERGE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_SHADOW_FREE_FORCE_MERGE]._dwDefault ==
                CI_MAX_SHADOW_FREE_FORCE_MERGE_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_INDEXES]._dwDefault ==
                CI_MAX_INDEXES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_IDEAL_INDEXES]._dwDefault ==
                CI_MAX_IDEAL_INDEXES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_MERGE_IDLE_TIME]._dwDefault ==
                CI_MIN_MERGE_IDLE_TIME_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_PENDING_DOCUMENTS]._dwDefault ==
                CI_MAX_PENDING_DOCUMENTS_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MASTER_MERGE_TIME]._dwDefault ==
                CI_MASTER_MERGE_TIME_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_QUEUE_CHUNKS]._dwDefault ==
                CI_MAX_QUEUE_CHUNKS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MASTER_MERGE_CHECKPOINT_INTERVAL]._dwDefault ==
                CI_MASTER_MERGE_CHECKPOINT_INTERVAL_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FILTER_BUFFER_SIZE]._dwDefault ==
                CI_FILTER_BUFFER_SIZE_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_FILTER_RETRIES]._dwDefault ==
                CI_FILTER_RETRIES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FILTER_RETRY_INTERVAL]._dwDefault ==
                CI_FILTER_RETRY_INTERVAL_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_IDLE_QUERY_THREADS]._dwDefault ==
                CI_MIN_IDLE_QUERY_THREADS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_ACTIVE_QUERY_THREADS]._dwDefault ==
                CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_QUERY_TIMESLICE]._dwDefault ==
                CI_MAX_QUERY_TIMESLICE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_QUERY_EXECUTION_TIME]._dwDefault ==
                CI_MAX_QUERY_EXECUTION_TIME_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_RESTRICTION_NODES]._dwDefault ==
                CI_MAX_RESTRICTION_NODES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_CLUSTERINGTIME]._dwDefault ==
                CI_CLUSTERINGTIME_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_FILESIZE_MULTIPLIER]._dwDefault ==
                CI_MAX_FILESIZE_MULTIPLIER_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_DAEMON_RESPONSE_TIMEOUT]._dwDefault ==
                CI_DAEMON_RESPONSE_TIMEOUT_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FILTER_DELAY_INTERVAL]._dwDefault ==
                CI_FILTER_DELAY_INTERVAL_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FILTER_REMAINING_THRESHOLD]._dwDefault ==
                CI_FILTER_REMAINING_THRESHOLD_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MAX_CHARACTERIZATION]._dwDefault ==
                CI_MAX_CHARACTERIZATION_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_FILESIZE_FILTERED]._dwDefault ==
                CI_MAX_FILESIZE_FILTERED_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_WORDLIST_IO]._dwDefault ==
                CI_MAX_WORDLIST_IO_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_WORDLIST_RESOURCE_CHECK_INTERVAL]._dwDefault ==
                CI_WORDLIST_RESOURCE_CHECK_INTERVAL_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_STARTUP_DELAY]._dwDefault ==
                CI_STARTUP_DELAY_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_GENERATE_CHARACTERIZATION]._dwDefault ==
                CI_GENERATE_CHARACTERIZATION_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_SECQ_FILTER_RETRIES]._dwDefault ==
                CI_SECQ_FILTER_RETRIES_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MIN_WORDLIST_BATTERY]._dwDefault ==
                CI_MIN_WORDLIST_BATTERY_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_THREAD_PRIORITY_MERGE]._dwDefault ==
                CI_THREAD_PRIORITY_MERGE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_THREAD_PRIORITY_FILTER]._dwDefault ==
                CI_THREAD_PRIORITY_FILTER_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_THREAD_CLASS_FILTER]._dwDefault ==
                CI_THREAD_CLASS_FILTER_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_EVTLOG_FLAGS]._dwDefault ==
                CI_EVTLOG_FLAGS_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MISC_FLAGS]._dwDefault ==
                CI_MISC_FLAGS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_GENERATE_RELEVANT_WORDS]._dwDefault ==
                CI_GENERATE_RELEVANT_WORDS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS]._dwDefault ==
                CI_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_FILTER_DIRECTORIES]._dwDefault ==
                CI_FILTER_DIRECTORIES_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_FILTER_CONTENTS]._dwDefault ==
                CI_FILTER_CONTENTS_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_MAX_DAEMON_VM_USE]._dwDefault ==
                CI_MAX_DAEMON_VM_USE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_WORDLIST_USER_IDLE]._dwDefault ==
                CI_WORDLIST_USER_IDLE_DEFAULT );
    Win4Assert( _adwRangeParams[CI_AP_IS_ENUM_ALLOWED]._dwDefault ==
                CI_IS_ENUM_ALLOWED_DEFAULT );

    Win4Assert( _adwRangeParams[CI_AP_MIN_DISK_SPACE_TO_LEAVE]._dwDefault ==
                CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT );
}

// ---------------------------------------------------------------------------
// Array of the min, max, default values for the DWORD parameters.
// Organize the array as sets of 4 for readability.
// ---------------------------------------------------------------------------

const CI_ADMIN_PARAMS_RANGE CCiAdminParams::_adwRangeParams[CI_AP_MAX_DWORD_VAL] =
{

  { CI_MAX_MERGE_INTERVAL_MIN, CI_MAX_MERGE_INTERVAL_MAX,
    CI_MAX_MERGE_INTERVAL_DEFAULT },
  { CI_MAX_UPDATES_MIN, CI_MAX_UPDATES_MAX,
    CI_MAX_UPDATES_DEFAULT },
  { CI_MAX_WORDLISTS_MIN, CI_MAX_WORDLISTS_MAX,
    CI_MAX_WORDLISTS_DEFAULT },
  { CI_MIN_SIZE_MERGE_WORDLISTS_MIN, CI_MIN_SIZE_MERGE_WORDLISTS_MAX,
    CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT },

  { CI_MAX_WORDLIST_SIZE_MIN, CI_MAX_WORDLIST_SIZE_MAX,
    CI_MAX_WORDLIST_SIZE_DEFAULT },
  { CI_MIN_WORDLIST_MEMORY_MIN, CI_MIN_WORDLIST_MEMORY_MAX,
    CI_MIN_WORDLIST_MEMORY_DEFAULT },
  { CI_LOW_RESOURCE_SLEEP_MIN, CI_LOW_RESOURCE_SLEEP_MAX,
    CI_LOW_RESOURCE_SLEEP_DEFAULT },
  { CI_MAX_WORDLIST_MEMORY_LOAD_MIN, CI_MAX_WORDLIST_MEMORY_LOAD_MAX,
    CI_MAX_WORDLIST_MEMORY_LOAD_DEFAULT },

  { CI_MAX_FRESHCOUNT_MIN, CI_MAX_FRESHCOUNT_MAX,
    CI_MAX_FRESHCOUNT_DEFAULT },
  { CI_MAX_SHADOW_INDEX_SIZE_MIN, CI_MAX_SHADOW_INDEX_SIZE_MAX,
    CI_MAX_SHADOW_INDEX_SIZE_DEFAULT },
  { CI_MIN_DISKFREE_FORCE_MERGE_MIN, CI_MIN_DISKFREE_FORCE_MERGE_MAX,
    CI_MIN_DISKFREE_FORCE_MERGE_DEFAULT },
  { CI_MAX_SHADOW_FREE_FORCE_MERGE_MIN, CI_MAX_SHADOW_FREE_FORCE_MERGE_MAX,
    CI_MAX_SHADOW_FREE_FORCE_MERGE_DEFAULT },

  { CI_MAX_INDEXES_MIN, CI_MAX_INDEXES_MAX,
    CI_MAX_INDEXES_DEFAULT },
  { CI_MAX_IDEAL_INDEXES_MIN, CI_MAX_IDEAL_INDEXES_MAX,
    CI_MAX_IDEAL_INDEXES_DEFAULT },
  { CI_MIN_MERGE_IDLE_TIME_MIN, CI_MIN_MERGE_IDLE_TIME_MAX,
    CI_MIN_MERGE_IDLE_TIME_DEFAULT },
  { CI_MAX_PENDING_DOCUMENTS_MIN, CI_MAX_PENDING_DOCUMENTS_MAX,
    CI_MAX_PENDING_DOCUMENTS_DEFAULT },

  { CI_MASTER_MERGE_TIME_MIN, CI_MASTER_MERGE_TIME_MAX,
    CI_MASTER_MERGE_TIME_DEFAULT },
  { CI_MAX_QUEUE_CHUNKS_MIN, CI_MAX_QUEUE_CHUNKS_MAX,
    CI_MAX_QUEUE_CHUNKS_DEFAULT },
  { CI_MASTER_MERGE_CHECKPOINT_INTERVAL_MIN,
    CI_MASTER_MERGE_CHECKPOINT_INTERVAL_MAX,
    CI_MASTER_MERGE_CHECKPOINT_INTERVAL_DEFAULT },
  { CI_FILTER_BUFFER_SIZE_MIN, CI_FILTER_BUFFER_SIZE_MAX,
    CI_FILTER_BUFFER_SIZE_DEFAULT },


  { CI_FILTER_RETRIES_MIN, CI_FILTER_RETRIES_MAX,
    CI_FILTER_RETRIES_DEFAULT },
  { CI_FILTER_RETRY_INTERVAL_MIN, CI_FILTER_RETRY_INTERVAL_MAX,
    CI_FILTER_RETRY_INTERVAL_DEFAULT },
  { CI_MIN_IDLE_QUERY_THREADS_MIN, CI_MIN_IDLE_QUERY_THREADS_MAX,
    CI_MIN_IDLE_QUERY_THREADS_DEFAULT },
  { CI_MAX_ACTIVE_QUERY_THREADS_MIN, CI_MAX_ACTIVE_QUERY_THREADS_MAX,
    CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT },


  { CI_MAX_QUERY_TIMESLICE_MIN, CI_MAX_QUERY_TIMESLICE_MAX,
    CI_MAX_QUERY_TIMESLICE_DEFAULT },
  { CI_MAX_QUERY_EXECUTION_TIME_MIN, CI_MAX_QUERY_EXECUTION_TIME_MAX,
    CI_MAX_QUERY_EXECUTION_TIME_DEFAULT },
  { CI_MAX_RESTRICTION_NODES_MIN, CI_MAX_RESTRICTION_NODES_MAX,
    CI_MAX_RESTRICTION_NODES_DEFAULT },
  { CI_CLUSTERINGTIME_MIN, CI_CLUSTERINGTIME_MAX,
    CI_CLUSTERINGTIME_DEFAULT },

  { CI_MAX_FILESIZE_MULTIPLIER_MIN, CI_MAX_FILESIZE_MULTIPLIER_MAX,
    CI_MAX_FILESIZE_MULTIPLIER_DEFAULT },
  { CI_DAEMON_RESPONSE_TIMEOUT_MIN, CI_DAEMON_RESPONSE_TIMEOUT_MAX,
    CI_DAEMON_RESPONSE_TIMEOUT_DEFAULT },
  { CI_FILTER_DELAY_INTERVAL_MIN, CI_FILTER_DELAY_INTERVAL_MAX,
    CI_FILTER_DELAY_INTERVAL_DEFAULT },
  { CI_FILTER_REMAINING_THRESHOLD_MIN, CI_FILTER_REMAINING_THRESHOLD_MAX,
    CI_FILTER_REMAINING_THRESHOLD_DEFAULT },

  { CI_MAX_CHARACTERIZATION_MIN, CI_MAX_CHARACTERIZATION_MAX,
    CI_MAX_CHARACTERIZATION_DEFAULT },
  { CI_MAX_FRESH_DELETES_MIN, CI_MAX_FRESH_DELETES_MAX,
    CI_MAX_FRESH_DELETES_DEFAULT },
  { CI_MAX_WORDLIST_IO_MIN, CI_MAX_WORDLIST_IO_MAX,
    CI_MAX_WORDLIST_IO_DEFAULT },
  { CI_WORDLIST_RESOURCE_CHECK_INTERVAL_MIN, CI_WORDLIST_RESOURCE_CHECK_INTERVAL_MAX,
    CI_WORDLIST_RESOURCE_CHECK_INTERVAL_DEFAULT },

  { CI_STARTUP_DELAY_MIN, CI_STARTUP_DELAY_MAX,
    CI_STARTUP_DELAY_DEFAULT },
  { CI_GENERATE_CHARACTERIZATION_MIN, CI_GENERATE_CHARACTERIZATION_MAX,
    CI_GENERATE_CHARACTERIZATION_DEFAULT },
  { CI_MIN_WORDLIST_BATTERY_MIN, CI_MIN_WORDLIST_BATTERY_MAX,
    CI_MIN_WORDLIST_BATTERY_DEFAULT },
  { 0,0xFFFFFFFF,
    (DWORD) CI_THREAD_PRIORITY_MERGE_DEFAULT },

  { 0, 0,
    (DWORD) CI_THREAD_PRIORITY_FILTER_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_THREAD_CLASS_FILTER_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_EVTLOG_FLAGS_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_MISC_FLAGS_DEFAULT },

  { 0,0xFFFFFFFF,
    CI_GENERATE_RELEVANT_WORDS_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_FILTER_DIRECTORIES_DEFAULT },
  { 0,0xFFFFFFFF,
    CI_FILTER_CONTENTS_DEFAULT },

  { 0, 0xFFFFFFFF,
    CI_MAX_FILESIZE_FILTERED_DEFAULT },
  { 0, 0xFFFFFFFF,
    CI_MIN_CLIENT_IDLE_TIME },
  { CI_MAX_DAEMON_VM_USE_MIN, CI_MAX_DAEMON_VM_USE_MAX,
    CI_MAX_DAEMON_VM_USE_DEFAULT },
  { CI_SECQ_FILTER_RETRIES_MIN, CI_SECQ_FILTER_RETRIES_MAX,
    CI_SECQ_FILTER_RETRIES_DEFAULT },

  { CI_WORDLIST_USER_IDLE_MIN, CI_WORDLIST_USER_IDLE_MAX,
    CI_WORDLIST_USER_IDLE_DEFAULT },
  { 0, 0xFFFFFFFF,
    CI_IS_ENUM_ALLOWED_DEFAULT },
  { CI_MIN_DISK_SPACE_TO_LEAVE_MIN, CI_MIN_DISK_SPACE_TO_LEAVE_MAX,
    CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT },

// End of DWORD values
};

// global c++ objects are evil, sick, and wrong.

CWorkQueue TheWorkQueue( 2, CWorkQueue::workQueueQuery );
CLocateDocStore g_DocStoreLocator;
CLocateDocStore g_svcDocStoreLocator;

void InitializeDocStore(void)
{
    TheWorkQueue.Init();
    g_DocStoreLocator.Init();
    g_svcDocStoreLocator.Init();
}


//+---------------------------------------------------------------------------
//
//  Member:     CLocateDocStore::Get
//
//  Synopsis:   Gets the docstore locator with the given clsid.
//
//  History:    1-17-97   srikants   Created
//
//----------------------------------------------------------------------------

ICiCDocStoreLocator * CLocateDocStore::Get( GUID const & guidDocStoreLocator )
{
    if ( !_fShutdown )
    {
        CLock lock( _mutex );

        if ( 0 == _pDocStoreLocator )
        {
            SCODE sc = CoCreateInstance( guidDocStoreLocator,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_ICiCDocStoreLocator,
                                         (void **) &_pDocStoreLocator );

            if ( FAILED(sc) )
            {
                ciDebugOut(( DEB_ERROR,
                             "Failed to create ICiCDocStoreLocator (0x%X) \n",
                             sc ));
                THROW( CException( sc ) );
            }
        }

        _pDocStoreLocator->AddRef();
    }

    return _pDocStoreLocator;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocateDocStore::Shutdown
//
//  Synopsis:   Shutsdown the Content Index Framework side of the things.
//              This shuts down the whole Content Index. If there are
//              multiple instances of CI in the same process, this affects
//              all the instances.
//
//  History:    3-20-97   srikants   Created
//
//----------------------------------------------------------------------------

void CLocateDocStore::Shutdown()
{
    CLock lock( _mutex );

    if ( _pDocStoreLocator )
    {
       //
       // Shutdown on the docstore locator  must be called only once.
       //
        if ( !_fShutdown )
            _pDocStoreLocator->Shutdown();

        _pDocStoreLocator->Release();
        _pDocStoreLocator = 0;
    }

    _fShutdown = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\dmnslave.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dmnslave.cxx
//
//  Contents:   The slave thread that executes executes commands on behalf of
//              the DownLevel daemon process.
//
//  History:    1-31-96   srikants   Created
//              1-06-97   srikants   Renamed to dmnslave.cxx from dlslave.cxx
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <cci.hxx>
#include <glbconst.hxx>

#include "dmnslave.hxx"
#include "cimanger.hxx"

const WCHAR * wcsCiDaemonImage = L"%systemroot%\\system32\\cidaemon.exe";

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::GetInheritableHandle
//
//  Synopsis:   Creates an inheritable handle of this process for
//              synchronization purposes only.
//
//  Arguments:  [hTarget] - The inherited handle.
//
//  Returns:    STATUS_SUCCESS if successful.
//              An error code otherwise.
//
//  History:    2-02-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD CDaemonSlave::GetInheritableHandle( HANDLE & hTarget )
{
    HANDLE hSelf = GetCurrentProcess();

    BOOL fSuccess = DuplicateHandle( hSelf,         // source process
                                     hSelf,         // source handle
                                     hSelf,         // destination process
                                     &hTarget,      // target handle
                                     SYNCHRONIZE,   // desired access
                                     TRUE,          // inheritable
                                     0              // dwOptions
                                   );

    if (fSuccess)
        return STATUS_SUCCESS;

    return GetLastError();
} //GetInheritableHandle

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::CDaemonSlave ~ctor
//
//  Synopsis:   Constructor of the class that is manages the slave thread
//              in CI. This thread will execute the commands specified by
//              the DownLevel Daemon process.
//
//  Arguments:  [cicat]       -
//              [pwcsCatRoot] -  Catalog path.
//              [nameGen]     -  mutex name
//              [pwcsCatName] - 0 or the friendly name
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

CDaemonSlave::CDaemonSlave(
     CCiManager & ciManager,
     CCI * pCci,
     WCHAR const * pwcsCatRoot,
     CSharedNameGen & nameGen,
     const GUID & clsidDaemonClientMgr)
: _ciManager(ciManager),
  _pCci(pCci),
#pragma warning( disable : 4355 )       // this used in base initialization
 _thrSlave(SlaveThread, this, TRUE),
#pragma warning( default : 4355 )
 _fAbort(FALSE),
 _smemMutex( nameGen.GetMutexName() ),
 _sharedMem( nameGen.GetSharedMemName(),MAX_DL_SHARED_MEM),
 _evtCi( nameGen.GetCiEventName() ),
 _evtDaemon( nameGen.GetDaemonEventName() ),
 _pProcess(0),
 _hParent(INVALID_HANDLE_VALUE),
 _state(eDeathNotified),
 _daemonExitStatus(0),
 _cbStartupData(0),
 _clsidDaemonClientMgr(clsidDaemonClientMgr)
{
    //
    // Initialize both the events to be in an "unsignalled" state.
    //
    _evtCi.Reset();
    _evtDaemon.Reset();

    //
    // Initialize the shared memory.
    //
    _pLayout = (CFilterSharedMemLayout *) _sharedMem.Map();
    _pLayout->Init();

    Win4Assert( 0 != pwcsCatRoot );
    ULONG len = wcslen( pwcsCatRoot );
    _wszCatRoot.Init( len+1 );
    RtlCopyMemory( _wszCatRoot.GetPointer(), pwcsCatRoot, (len+1) * sizeof(WCHAR) );

    DWORD dwError = GetInheritableHandle( _hParent );
    if ( STATUS_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Cannot duplicate a handle to self. Error 0x%X\n",
                     dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError) ) );
    }

    Win4Assert( INVALID_HANDLE_VALUE != _hParent );

    SHandle xSafeHandle(_hParent);

    //
    // First resume the slave thread and then resume the daemon process.
    // The slave should run at a lower priority than queries.
    //
    if ( IDLE_PRIORITY_CLASS == _ciManager._GetFrameworkParams().GetThreadClassFilter() )
    {
        _thrSlave.SetPriority( THREAD_PRIORITY_BELOW_NORMAL );
    }
    else
    {
        _thrSlave.SetPriority( THREAD_PRIORITY_NORMAL );
    }

    _thrSlave.Resume();

    xSafeHandle.Acquire();

    END_CONSTRUCTION( CDaemonSlave );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::StartFiltering
//
//  Synopsis:   Signal to indicate that it is okay to start the daemon
//              process.
//
//  History:    12-30-96   srikants   Created
//
//----------------------------------------------------------------------------
void CDaemonSlave::StartFiltering(
    BYTE const * pbStartupData,
    ULONG cbStartupData )
{
    // ====================================================
    CLock   lock(_mutex);

    if ( eReadyToStart == _state || eRunning == _state )
        return;

    if ( eDeathNotified != _state )
    {
        ciDebugOut(( DEB_ERROR,
                    "StartFiltering called in an invalid state (%d)\n",
                    _state ));

        THROW( CException( CI_E_INVALID_STATE ) );
    }

    //
    // Make a local copy of the startup data.
    //
    if ( _xbStartupData.Count() < cbStartupData )
    {
        _xbStartupData.Free();
        _xbStartupData.Set( cbStartupData,
                            new BYTE [cbStartupData] );
    }

    RtlCopyMemory( _xbStartupData.GetPointer(), pbStartupData, cbStartupData );
    _cbStartupData = cbStartupData;

    _state = eReadyToStart;
    _evtCi.Set();
    // ====================================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::StartProcess
//
//  Synopsis:   Creates the DL daemon process if it is not already started.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::StartProcess()
{
    if ( 0 == _pProcess )
    {
        WCHAR  wszCommandLine[ MAX_PATH + 50 ];
        swprintf( wszCommandLine,L"%ls %ls \"%ls\" %ul %ul",
                  DL_DAEMON_EXE_NAME,
                  DL_DAEMON_ARG1_W,
                  _wszCatRoot.GetPointer(),
                  _sharedMem.SizeLow(),
                  GetCurrentProcessId() );

        XInterface<ICiCAdviseStatus> xAdviseStatus;

        SCODE sc = _ciManager._xDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                                          xAdviseStatus.GetQIPointer() );
        if ( S_OK != sc )
        {
            Win4Assert( xAdviseStatus.IsNull() );

            THROW( CException( sc ) );
        }

        SECURITY_ATTRIBUTES *pSA = 0;

        _pProcess = new CProcess( DL_DAEMON_EXE_NAME,
                                  wszCommandLine,
                                  TRUE,   // suspended
                                  *pSA,
                                  FALSE, // make it detached
                                  xAdviseStatus.GetPointer() );

        TRY
        {
            _pProcess->AddDacl( GENERIC_ALL );
        }
        CATCH( CException, e )
        {
            //
            // If we can't add the DACL, then delete the process and rethrow
            // the exception.
            //

            delete _pProcess;
            _pProcess = 0;

            RETHROW();
        }
        END_CATCH
    }
} //StartProcess

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::~CDaemonSlave
//
//  Synopsis:   Destructor of the CDaemonSlave class. Kills the slave thread
//              and then kills the daemon process.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

CDaemonSlave::~CDaemonSlave()
{
    _fAbort = TRUE;

    //
    // Kill the thread first. Otherwise, the process will be recreated
    // by the thread.
    //
    KillThread();
    KillProcess();

    //
    // Close the handle to ourselves.
    //
    CloseHandle(_hParent);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::KillProcess
//
//  Synopsis:   Kills the downlevel daemon process.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::KillProcess()
{
    // =====================================================
    CLock lock(_mutex);

    if ( _pProcess )
    {
        //
        // Get the process exit code.
        //
        SaveDaemonExitCode();

        TRY
        {
            delete _pProcess;
            _pProcess = 0;

            _state = eDied;
            _ciManager.ProcessCiDaemonTermination(  _daemonExitStatus );
            _state = eDeathNotified;
        }
        CATCH ( CException, e )
        {
            ciDebugOut(( DEB_ERROR, "Error while killing process. 0x%X\n",
                         e.GetErrorCode() ));
        }
        END_CATCH

        _evtCi.Reset();
        _pProcess = 0;
    }

    //
    // The process has either not started at all (_pProcess==0), or it has been notified, or it
    // has died.
    //
    Win4Assert(  eReadyToStart == _state
                 || eDeathNotified == _state
                 || eDied == _state );
    // =====================================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::RestartDaemon
//
//  Synopsis:   Starts the daemon process.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::RestartDaemon()
{
    Win4Assert( eReadyToStart == _state );
    StartProcess();
    _pProcess->Resume();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::KillThread
//
//  Synopsis:   Kills the slave thread.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::KillThread()
{
    _evtCi.Set();
    _thrSlave.WaitForDeath();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::InitiateShutdown
//
//  Synopsis:   Initiates the shutdown of the slave thread.
//
//  History:    12-30-96   srikants   Added comment header.
//
//----------------------------------------------------------------------------
void CDaemonSlave::InitiateShutdown()
{
    _fAbort = TRUE;
    _evtCi.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::SlaveThread
//
//  Synopsis:   The slave thread in CI.
//
//  Arguments:  [self] -
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD CDaemonSlave::SlaveThread( void * self )
{
    ((CDaemonSlave *) self)->DoWork();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterReady
//
//  Synopsis:   Executes the FilterReady() call on behalf of the DL Daemon.
//
//  Returns:    Status of the operation.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterReady()
{
    CFilterReadyLayout & data = _pLayout->GetFilterReady();
    Win4Assert( data.IsValid() );


    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );
    ULONG cb = 0;

    do
    {
        cb = data.GetCount();
        BYTE * docBuffer = data.GetBuffer();
        ULONG cMaxDocs = data.GetMaxDocs();

        if ( 0 != _pCci )
        {
            status  = _pCci->FilterReady( docBuffer, cb, cMaxDocs );
        }
        else
        {
            status = STATUS_NOT_FOUND;
        }

        _ciManager._HandleFilterReadyStatus( status );
    }
    while ( FILTER_S_DISK_FULL == status );

    data.SetCount( cb );
    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterMore
//
//  Synopsis:   Executes the FilterMore() call.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterMore()
{
    CFilterMoreDoneLayout & data = _pLayout->GetFilterMore();
    Win4Assert( data.IsValid() );

    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );

    if ( 0 != _pCci )
    {
        STATUS const * pStatus = data.GetStatusArray();
        ULONG  cStatus = data.GetCount();
        status  = _pCci->FilterMore( pStatus, cStatus );
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterDataReady
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterDataReady()
{
    CFilterDataLayout & data = _pLayout->GetFilterDataReady();
    Win4Assert( data.IsValid() );


    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );

    if ( 0 != _pCci )
    {
        BYTE const * pEntryBuf = data.GetBuffer();
        ULONG  cb = data.GetSize();
        status  = _pCci->FilterDataReady( pEntryBuf, cb );
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterDone
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterDone()
{

    CFilterMoreDoneLayout & data = _pLayout->GetFilterDone();
    Win4Assert( data.IsValid() );

    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );

    if ( 0 != _pCci )
    {
        STATUS const * pStatus = data.GetStatusArray();
        ULONG  cStatus = data.GetCount();
        status  = _pCci->FilterDone( pStatus, cStatus );
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterStoreValue
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterStoreValue()
{
    CFilterStoreValueLayout & data = _pLayout->GetFilterStoreValueLayout();
    Win4Assert( data.IsValid() );

    CMemDeSerStream deSer( data.GetBuffer(), data.GetCount() );

    CFullPropSpec ps( deSer );

    if ( !ps.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    CStorageVariant var( deSer );

    if ( !var.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    WORKID widFake = data.GetWorkid();

    BOOL fSuccess;
    _pCci->FilterStoreValue( widFake, ps, var, fSuccess );
    data.SetStatus( fSuccess );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FilterStoreSecurity
//
//  History:    06 Feb 96    AlanW    Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FilterStoreSecurity()
{
    CFilterStoreSecurityLayout & data = _pLayout->GetFilterStoreSecurityLayout();
    Win4Assert( data.IsValid() );

    PSECURITY_DESCRIPTOR pSD = data.GetSD();
    ULONG cbSD = data.GetCount();

    WORKID widFake = data.GetWorkid();

    BOOL fSuccess;
    _pCci->FilterStoreSecurity( widFake, pSD, cbSD, fSuccess );
    data.SetStatus( fSuccess );

    return S_OK;
} //FilterStoreSecurity

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC to PROPID
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::FPSToPROPID()
{
    CFPSToPROPIDLayout & data = _pLayout->GetFPSToPROPID();
    Win4Assert( data.IsValid() );

    CMemDeSerStream deSer( data.GetBuffer(), data.GetCount() );

    CFullPropSpec fps( deSer );

    if ( !fps.IsValid() )
        return E_INVALIDARG;

    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );

    if ( 0 != _pCci )
    {
        status = _pCci->FPSToPROPID( fps, *(PROPID *)data.GetBuffer() );

        unsigned cb;

        if ( SUCCEEDED(status) )
            cb =  sizeof(PROPID);
        else
            cb = 0;

        data.SetCount( cb  );
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }

    return status;
} //FPSToPROPID

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::GetClientStartupData
//
//  Synopsis:   Retrieves the client startup data.
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDaemonSlave::GetClientStartupData()
{
    CFilterStartupDataLayout & data = _pLayout->GetStartupData();
    Win4Assert( data.IsValid() );

    SCODE status = S_OK;

    Win4Assert( 0 != _pCci );

    if ( 0 != _pCci )
    {
        data.SetData( _clsidDaemonClientMgr,
                      _xbStartupData.GetPointer(),
                      _cbStartupData );
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }

    return status;
} //GetClientStartupData

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::DoSlaveWork
//
//  Synopsis:   The "de-multiplexor" which figures out what work was signalled
//              by the daemon process.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::DoSlaveWork()
{
    if ( _fAbort )
        return;

    CIPLock  lock(_smemMutex);

    Win4Assert( 0 != _pLayout );

    CFilterSharedMemLayout::EFilterWorkType workType = _pLayout->GetWorkType();

    SCODE status = S_OK;

    TRY
    {
        switch ( workType )
        {
            case CFilterSharedMemLayout::eNone:
                break;


            case CFilterSharedMemLayout::eFilterReady:
            {
                status = FilterReady();
                break;
            }

            case CFilterSharedMemLayout::eFilterDataReady:
            {
                status = FilterDataReady();
                break;
            }

            case CFilterSharedMemLayout::eFilterMore:
            {
                status = FilterMore();
                break;
            }

            case CFilterSharedMemLayout::eFilterDone:
            {
                status = FilterDone();
                break;
            }

            case CFilterSharedMemLayout::eFilterStoreValue:
            {
                status = FilterStoreValue();
                break;
            }

            case CFilterSharedMemLayout::eFilterStoreSecurity:
            {
                status = FilterStoreSecurity();
                break;
            }

            case CFilterSharedMemLayout::eFPSToPROPID:
            {
                status = FPSToPROPID();
                break;
            }

            case CFilterSharedMemLayout::eFilterStartupData:
            {
                status = GetClientStartupData();
                break;
            }

            default:
                ciDebugOut(( DEB_ERROR, "Unknown work code from daemon\n",
                             workType ));
                Win4Assert( !"Unknown work code");
                status = STATUS_INVALID_PARAMETER;
                break;
        }
    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();

        ciDebugOut(( DEB_WARN,
                     "Error (0x%X) caught while doing slave work\n",
                     status ));

        if ( IsCiCorruptStatus( e.GetErrorCode() ) )
            RETHROW();

    }
    END_CATCH

    if ( IsDiskLowError(status) )
    {
        BOOL fLow;
        _pCci->VerifyIfLowOnDiskSpace(fLow);
    }

    //
    // Set the status of the operation and wake up the daemon process.
    //
    _pLayout->SetStatus( status );
    _evtDaemon.Set();
} //DoSlaveWork

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::DoStateMachineWork
//
//  Synopsis:   Does state machine book keeping work. If necessary, it will
//              restart the cidaemon process.
//
//  History:    12-30-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::DoStateMachineWork()
{
    // =======================================
    CLock   lock(_mutex);

    Win4Assert( eRunning != _state );

    if ( _state == eReadyToStart && !IsProcessLowOnResources() )
    {
        RestartDaemon();
        _state = eRunning;
    }
    else if ( _state == eDied )
    {
        _ciManager.ProcessCiDaemonTermination( _daemonExitStatus );
        _state = eDeathNotified;
    }
    // =======================================
} //DoStateMachineWork

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::SaveDaemonExitCode
//
//  Synopsis:   Saves the exit code of the daemon process.
//
//  History:    12-30-96   srikants   Created
//
//----------------------------------------------------------------------------
void CDaemonSlave::SaveDaemonExitCode()
{
    Win4Assert( 0 != _pProcess );

    HANDLE hProcess = _pProcess->GetHandle();
    DWORD dwExitCode;

    if ( GetExitCodeProcess( hProcess, &dwExitCode ) )
        _daemonExitStatus = dwExitCode;
    else
        _daemonExitStatus = E_FAIL;
} //SaveDaemonExitCode

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::IsProcessLowOnResources
//
//  Synopsis:   Tests if the daemon process died because of being low on
//              resources.
//
//  Returns:    Returns TRUE if the daemon process died with low resource
//              condition (low on memory or disk). FALSE o/w.
//
//  History:    3-11-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CDaemonSlave::IsProcessLowOnResources() const
{
    Win4Assert( 0 == _pProcess );

    return _IsResourceLowError( _daemonExitStatus );
}

//+---------------------------------------------------------------------------
//
//  Functions:  IsInDebugger
//
//  Synopsis:   Tests if a process is being debugged
//
//  Arguments:  [hProcess] -- The process handle to test.
//
//  Returns:    Returns TRUE if the process is being debugged.
//
//  History:    4-23-98   dlee  Created
//
//----------------------------------------------------------------------------

BOOL IsInDebugger( HANDLE hProcess )
{
    PROCESS_BASIC_INFORMATION bi;
    NTSTATUS s = NtQueryInformationProcess( hProcess,
                                            ProcessBasicInformation,
                                            (PVOID) &bi,
                                            sizeof bi,
                                            0 );

    if ( STATUS_SUCCESS != s )
        return FALSE;

    PEB Peb;
    if ( ReadProcessMemory( hProcess, bi.PebBaseAddress, &Peb, sizeof PEB, 0 ) )
        return Peb.BeingDebugged;

    return FALSE;
} //IsInDebugger

//+---------------------------------------------------------------------------
//
//  Member:     CDaemonSlave::DoWork
//
//  Synopsis:   Main worker thread.
//
//  History:    1-31-96   srikants   Created
//
//----------------------------------------------------------------------------

void CDaemonSlave::DoWork()
{
    const  cHandles = 2;
    HANDLE aHandles[cHandles];

    const iCiWork = 0;          // Index of the ci work event.
    const iDaemonProcess = 1;   // Index of the daemon process.

    aHandles[iCiWork] = _evtCi.GetHandle();

    BOOL fContinue = TRUE;

    while ( fContinue )
    {
        if ( !_fAbort )
        {
            TRY
            {
                DWORD nHandles = 1;

                if ( 0 != _pProcess )
                {
                    aHandles[iDaemonProcess] = _pProcess->GetHandle();
                    nHandles++;
                }

                DWORD timeout = _ciManager._GetFrameworkParams().GetDaemonResponseTimeout() * 60 * 1000;

                DWORD status = WaitForMultipleObjects( nHandles,
                                                       aHandles,
                                                       FALSE,
                                                       timeout );

                if ( WAIT_FAILED == status )
                {
                    ciDebugOut(( DEB_ERROR, "WaitForMultipleObjects failed with error 0x%X\n",
                                 GetLastError() ));
                    //
                    // Don't restart the daemon process immediately. Wait for
                    // the timeout period.
                    //
                    KillProcess();
                }
                else if ( WAIT_TIMEOUT == status )
                {
                    // The process is probably looping. We should kill it and
                    // restart.

                    if ( eRunning == _state )
                    {
                        if ( 0 != _pProcess )
                        {
                            BOOL fDbg = IsInDebugger( _pProcess->GetHandle() );

                            ciDebugOut(( DEB_ERROR,
                                         "Daemon is looping, killing? %s\n",
                                         fDbg ? "no" : "yes" ));

                            if ( !fDbg )
                                KillProcess();
                        }
                    }
                    else
                    {
                        DoStateMachineWork();
                    }
                }
                else
                {
                    //
                    // An event was signalled.
                    //

                    DWORD iWake = status - WAIT_OBJECT_0;

                    if ( iCiWork == iWake )
                    {
                        //
                        // We have been given some work. Do it.
                        //
                        // =========================================
                        {
                            CLock lock(_mutex);
                            _evtCi.Reset();
                        }
                        // =========================================

                        if ( eRunning == _state )
                            DoSlaveWork();
                        else
                            DoStateMachineWork();
                    }
                    else if ( iDaemonProcess == iWake )
                    {
                        //
                        // The daemon process died.
                        //
                        ciDebugOut(( DEB_ERROR, "Daemon process died\n" ));
                        KillProcess();
                    }
                }
            }
            CATCH(CException, e )
            {
                ciDebugOut(( DEB_ERROR, "Error in the Slave Thread - 0x%X\n",
                             e.GetErrorCode() ));

                _ciManager.ProcessError( e.GetErrorCode() );

                if ( IsCiCorruptStatus( e.GetErrorCode() ) )
                {
                    KillProcess();
                    fContinue = FALSE;
                }
            }
            END_CATCH
        }
        else
        {
            fContinue = FALSE;
        }
    }
} //DoWork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\cicntrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cicntrl.hxx
//
//  Contents:   The Content Index control object implementing the
//              ICiControl interface.
//
//  Classes:    CCiControl
//
//  History:    12-03-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "cicntrl.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\dmnproxy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dlproxy.cxx
//
//  Contents:   Proxy class which is used by the Daemon process
//              to communicate with the CI process.
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dmnproxy.hxx>
#include <memser.hxx>
#include <memdeser.hxx>
#include <sizeser.hxx>
#include <ciole.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStoreValueLayout::Init
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CFilterStoreValueLayout::Init( ULONG cbMax, WORKID widFake,
                                     CFullPropSpec const & ps,
                                     CStorageVariant const & var )
{
    _sig5 = eFilterSig5;
    _cbMax = cbMax - FIELD_OFFSET( CFilterStoreValueLayout, _ab );
    _widFake = widFake;

    CSizeSerStream  sizeSer;
    _fSuccess = FALSE;

    ps.Marshall( sizeSer );
    var.Marshall( sizeSer );

    if ( sizeSer.Size() > _cbMax )
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    _cb = sizeSer.Size();

    CMemSerStream   ser( GetBuffer(), _cb );
    ps.Marshall( ser );
    var.Marshall( ser );
    ser.AcqBuf();

    return S_OK;

} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStoreSecurityLayout::Init
//
//  Synopsis:   Initialize a buffer for the FilterStoreSecurity call
//
//  Arguments:  [cbMax]   - size in bytes of [this]
//              [widFake] - fake WORKID of file to apply security to
//              [pSD]     - pointer to a self-relative security descriptor
//              [cbSD]    - size in bytes of [pSD]
//
//  History:    06 Feb 96   AlanW    Created
//
//----------------------------------------------------------------------------

void CFilterStoreSecurityLayout::Init( ULONG cbMax,
                                       WORKID widFake,
                                       PSECURITY_DESCRIPTOR pSD,
                                       ULONG cbSD )
{
    _sig8 = (ULONG) eFilterSig8;
    _cbMax = cbMax - FIELD_OFFSET( CFilterStoreSecurityLayout, _ab );
    _widFake = widFake;
    _fSuccess = FALSE;

    _sdid = 0;

    if ( cbSD > _cbMax )
    {
        THROW( CException( STATUS_BUFFER_TOO_SMALL ) );
    }

    _cb = cbSD;
    RtlCopyMemory( &_ab, pSD, cbSD );
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStoreValueLayout::Get
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

void CFilterStoreValueLayout::Get( WORKID & widFake, CFullPropSpec & ps,
                                   CStorageVariant & var )
{
    Win4Assert( IsValid() );
    widFake = _widFake;

    CMemDeSerStream deSer( GetBuffer(), _cb );

    // It's a little slow to do this, but it doesn't dominate filter time.

    CFullPropSpec   psLocal( deSer );
    CStorageVariant varLocal( deSer );

    ps = psLocal;
    var = varLocal;
} //Get

//+---------------------------------------------------------------------------
//
//  Member:     CFPSToPROPIDLayout::Init, public
//
//  Synopsis:   Initialize buffer for transfer (FPSToPROPID operation)
//
//  Arguments:  [cbMax] -- Size of buffer used in later marshalling
//              [fps]   -- Propspec to be marshalled
//
//  History:    30-Dec-1997   KyleP    Created
//
//----------------------------------------------------------------------------

void CFPSToPROPIDLayout::Init( ULONG cbMax, CFullPropSpec const & fps )
{
    _sig6 = eFilterSig6;
    _cbMax = cbMax - FIELD_OFFSET( CFPSToPROPIDLayout, _ab );

    //
    // Serialize the pidmap
    //
    CSizeSerStream  sizeSer;
    fps.Marshall( sizeSer );

    if ( sizeSer.Size() > _cbMax )
    {
        THROW( CException( STATUS_BUFFER_TOO_SMALL ) );
    }

    Win4Assert( cbMax >= sizeof(PROPID) );

    _cb = sizeSer.Size();
    CMemSerStream   ser( GetBuffer(), _cb );
    fps.Marshall( ser );
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::CGenericCiProxy
//
//  Synopsis:   Constructor for the proxy object used by Ci Daemon Process
//              to communicate with ContentIndex (in a different process).
//
//  History:    2-02-96   srikants   Created
//
//  Notes:      All the above handles are of the objects created by the
//              parent CI process with an "inheritable" attribute. The handles
//              are communicated to the daemon process as command line args
//              and used here.
//
//----------------------------------------------------------------------------

CGenericCiProxy::CGenericCiProxy(
    CSharedNameGen & nameGen,
    DWORD dwMemSize,
    DWORD parentId )
:_mutex( nameGen.GetMutexName() ),
 _sharedMem( nameGen.GetSharedMemName(), dwMemSize ),
 _evtCi( 0, nameGen.GetCiEventName() ),
 _evtDaemon( 0, nameGen.GetDaemonEventName() ),
 _cHandles(2)
{

    _pLayout = (CFilterSharedMemLayout *) _sharedMem.Map();
    Win4Assert( _pLayout->IsValid() );

    _aWait[iDaemon] = _evtDaemon.GetHandle();

    HANDLE hParent = OpenProcess( SYNCHRONIZE, FALSE, parentId );

    if ( 0 == hParent )
    {
        DWORD dwError = GetLastError();
        ciDebugOut(( DEB_ERROR,
                     "Failed to get parent process handle. Error %d\n",
                     dwError ));
        THROW( CException( HRESULT_FROM_WIN32(dwError) ) );
    }

    _aWait[iParent] = hParent;
    _evtDaemon.Reset();
} //CGenericCiProxy

CGenericCiProxy::~CGenericCiProxy()
{
    CloseHandle( _aWait[iParent] );
} //~CGenericCiProxy

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::_WaitForResponse
//
//  Synopsis:   Waits on the parent handle and the work done event. If the
//              parent handle signals, then an exception will be thrown.
//
//  History:    2-02-96   srikants   Created
//              18-Dec-97 KLam       Added call to CCIOle::FlushIdle when wait
//                                   times out.
//----------------------------------------------------------------------------
void CGenericCiProxy::_WaitForResponse()
{
    const DWORD dwWSTimeout = 20000;
    DWORD dwTimeout = TRUE ? dwWSTimeout : INFINITE;
    BOOL fFirstIdle = TRUE;

    do
    {
        //
        // Since ill-behaved filters and anything that uses mshtml creates
        // windows, we have to process messages or broadcast messages
        // will hang.
        //

        DWORD status = MsgWaitForMultipleObjects( _cHandles,  // num handles
                                                  _aWait,     // array of handles
                                                  FALSE,      // wake up if any is set
                                                  dwTimeout,  // Timeout
                                                  QS_ALLEVENTS );

        DWORD iStatus = status - WAIT_OBJECT_0;

        if ( iStatus == _cHandles )
        {
            // Deal with the window message for this thread.

            MSG msg;

            while ( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) )
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }
        else if ( WAIT_TIMEOUT == status )
        {
            // Throw away IFilters we haven't used in awhile

            CCiOle::FlushIdle();

            if ( fFirstIdle )
            {
                //
                // Unload dlls like mshtml that get dragged in via thumbmail
                // generation.
                //

                CoFreeUnusedLibraries();

                // Throw ourselves out of the working set.

                SetProcessWorkingSetSize( GetCurrentProcess(), -1, -1 );

                dwTimeout = 2 * 60 * 1000;
                fFirstIdle = FALSE;
            }
        }
        else if ( WAIT_FAILED == status )
        {
            DWORD dwError = GetLastError();
            ciDebugOut(( DEB_ERROR, "Daemon - WaitFailed. Error %d\n", dwError ));
            THROW( CException() );
        }
        else if ( iParent == iStatus )
        {
            ciDebugOut(( DEB_ERROR, "Daemon - Parent process died abruptly\n" ));
            THROW( CException( STATUS_NOT_FOUND ) );
        }
        else
        {
            Win4Assert( iDaemon == iStatus );
            _evtDaemon.Reset();
            break;
        }
    }
    while( TRUE );
} //_WaitForResponse

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterReady
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterReady( BYTE * docBuffer, ULONG & cb,
                                    ULONG cMaxDocs )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterReadyLayout & data = _pLayout->GetFilterReady();
        data.Init( _pLayout->GetMaxVarDataSize(),  cb, cMaxDocs );
        _LokGiveWork( CFilterSharedMemLayout::eFilterReady );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterReadyLayout & data = _pLayout->GetFilterReady();

        Win4Assert( data.IsValid() );

        status = _pLayout->GetStatus();

        if ( NT_SUCCESS(status) )
        {
            if ( data.GetCount() <= cb )
            {
                cb = data.GetCount();
                RtlCopyMemory( docBuffer, data.GetBuffer(), cb );
            }
            else
            {
                // need more memory

                cb = data.GetCount();
            }
        }
        else
        {
            THROW( CException(status) );
        }
    }

    return status;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterDataReady
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterDataReady( BYTE const * pEntryBuf, ULONG cb )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterDataLayout & data = _pLayout->GetFilterDataReady();
        data.Init( pEntryBuf, cb );
        _LokGiveWork( CFilterSharedMemLayout::eFilterDataReady );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterDataLayout & data = _pLayout->GetFilterDataReady();

        Win4Assert( data.IsValid() );
        status = _pLayout->GetStatus();
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterMore
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterMore( STATUS const * aStatus, ULONG cStatus )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterMoreDoneLayout & data = _pLayout->GetFilterMore();
        data.Init( aStatus, cStatus );
        _LokGiveWork( CFilterSharedMemLayout::eFilterMore );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterMoreDoneLayout & data = _pLayout->GetFilterMore();
        Win4Assert( data.IsValid() );
        status = _pLayout->GetStatus();
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterDone
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterDone( STATUS const * aStatus, ULONG cStatus )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterMoreDoneLayout & data = _pLayout->GetFilterDone();
        data.Init( aStatus, cStatus );
        _LokGiveWork( CFilterSharedMemLayout::eFilterDone );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterMoreDoneLayout & data = _pLayout->GetFilterDone();
        Win4Assert( data.IsValid() );
        status = _pLayout->GetStatus();
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterStoreValue
//
//  History:    1-30-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterStoreValue( WORKID widFake,
                                         CFullPropSpec const & ps,
                                         CStorageVariant const & var,
                                         BOOL & fCanStore )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterStoreValueLayout & data = _pLayout->GetFilterStoreValueLayout();
        SCODE sc = data.Init( _pLayout->GetMaxVarDataSize(), widFake, ps, var );
        if ( S_OK != sc )
        {
            fCanStore = TRUE; // We are not sure if this property can be stored
                              // or not in the cache - err on the assumption that
                              // it can be stored.
            return sc;
        }

        _LokGiveWork( CFilterSharedMemLayout::eFilterStoreValue );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterStoreValueLayout & data = _pLayout->GetFilterStoreValueLayout();
        Win4Assert( data.IsValid() );
        fCanStore = data.GetStatus();
        status = _pLayout->GetStatus();
    }

    return status;

}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FilterStoreSecurity
//
//  History:    06 Feb 96    AlanW    Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FilterStoreSecurity( WORKID widFake,
                                            PSECURITY_DESCRIPTOR pSD,
                                            ULONG cbSD,
                                            BOOL & fCanStore )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterStoreSecurityLayout & data =
              _pLayout->GetFilterStoreSecurityLayout();
        data.Init( _pLayout->GetMaxVarDataSize(), widFake, pSD, cbSD );
        _LokGiveWork( CFilterSharedMemLayout::eFilterStoreSecurity );
    }

    _WaitForResponse();

    SCODE status;

    {
        CIPLock  lock(_mutex);
        CFilterStoreSecurityLayout & data = _pLayout->GetFilterStoreSecurityLayout();
        Win4Assert( data.IsValid() );
        fCanStore = data.GetStatus();
        status = _pLayout->GetStatus();
    }

    return status;
} //FilterStoreSecurity



//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC representing property
//              [pid] -- PROPID written here on success
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997    KyleP    Created
//
//----------------------------------------------------------------------------

SCODE CGenericCiProxy::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFPSToPROPIDLayout & data = _pLayout->GetFPSToPROPID();
        data.Init( _pLayout->GetMaxVarDataSize(), fps );
        _LokGiveWork( CFilterSharedMemLayout::eFPSToPROPID );
    }

    _WaitForResponse();

    SCODE status = S_OK;

    {
        CIPLock  lock(_mutex);
        CFPSToPROPIDLayout & data = _pLayout->GetFPSToPROPID();
        status = _pLayout->GetStatus();

        if ( SUCCEEDED(status) )
        {
            ULONG cb =   data.GetCount();

            Win4Assert( data.IsValid() );

            pid = data.GetPROPID();
        }
        else
        {
            Win4Assert( STATUS_BUFFER_TOO_SMALL != status );
            THROW( CException(status) );
        }
    }

    return status;
} //PidMapToPidRemap


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::GetStartupData
//
//  Synopsis:   Retrieves the startup data from the main process. This will
//              be handed over to the client.
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

BYTE const * CGenericCiProxy::GetStartupData( GUID & clsidClientMgr,
                                              ULONG & cbData )
{
    ProbeForParentProcess();

    Win4Assert( _pLayout );

    {
        CIPLock  lock(_mutex);
        CFilterStartupDataLayout & data = _pLayout->GetStartupData();
        data.Init();
        _LokGiveWork( CFilterSharedMemLayout::eFilterStartupData );
    }

    _WaitForResponse();

    SCODE status;

    BYTE const * pbData = 0;

    {
        CIPLock  lock(_mutex);
        CFilterStartupDataLayout & data = _pLayout->GetStartupData();
        Win4Assert( data.IsValid() );
        status = _pLayout->GetStatus();

        if ( S_OK == status )
        {
            pbData = data.GetData( cbData );
            clsidClientMgr = data.GetClientMgrCLSID();
        }
    }

    return pbData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::SetPriority
//
//  Synopsis:   Sets the priority class of the process and this thread's priority
//              based upon the values passed in.
//
//  History:    12-19-96   srikants   Created
//
//----------------------------------------------------------------------------

void CGenericCiProxy::SetPriority( ULONG priClass, ULONG priThread )
{
    SetPriorityClass( GetCurrentProcess(), priClass );
    SetThreadPriority( GetCurrentThread(), priThread );
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::GetEntryBuffer
//
//  Synopsis:   Returns the shared memory buffer that will be used by
//              the daemon to pass the "FilterDataReady".
//              This is an optimization to avoid data copying (128K) for
//              every call to "FilterDataReady".
//
//  Arguments:  [cb] - On output, will have the size of the buffer.
//
//  History:    2-21-96   srikants   Created
//
//----------------------------------------------------------------------------

BYTE * CGenericCiProxy::GetEntryBuffer( ULONG & cbMax )
{
    CIPLock  lock(_mutex);
    CFilterDataLayout & data = _pLayout->GetFilterDataReady();

    cbMax = data.GetMaxSize();
    return data.GetBuffer();
} //GetEntryBuffer


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCiProxy::ProbeForParentProcess
//
//  Synopsis:   Checks if the parent process (cisvc.exe) is still alive
//
//  History:    12-Aug-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CGenericCiProxy::ProbeForParentProcess()
{
    DWORD status = WaitForSingleObject( _aWait[iParent], 0 );

    if ( WAIT_FAILED == status )
    {
        DWORD dwError = GetLastError();
        ciDebugOut(( DEB_ERROR, "DLDaemon - WaitFailed. Error 0x%X\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    if ( WAIT_TIMEOUT == status )
        return;
    else
    {
        ciDebugOut(( DEB_ERROR, "DLDaemon - Parent process died abruptly\n" ));
        THROW( CException(FDAEMON_E_FATALERROR ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\identran.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        identran.cxx
//
// Contents:    Identity workid <--> doc name translator
//
// Classes:     CIdentityNameTranslator
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "identran.hxx"
#include "docname.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIdentityNameTranslator::CIdentityNameTranslator
//
//  Synopsis:   Constructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CIdentityNameTranslator::CIdentityNameTranslator()
  : _cRefs( 1 )
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CIdentityNameTranslator::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIdentityNameTranslator::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CIdentityNameTranslator::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIdentityNameTranslator::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CIdentityNameTranslator::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIdentityNameTranslator::QueryInterface( REFIID riid,
                                                                 void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_ICiCDocNameToWorkidTranslator )
        *ppvObject = (void *)(ICiCDocNameToWorkidTranslator *) this;
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CIdentityNameTranslator::QueryDocName
//
//  Synopsis:   Returns a new doc name object
//
//  Arguments:  [ppICiCDocName] - Pointer to ICiCDocName object returned here
//
//  History:    24-Feb-97     SitaramR    Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIdentityNameTranslator::QueryDocName( ICiCDocName ** ppICiCDocName )
{
    Win4Assert( 0 != ppICiCDocName );

    SCODE sc = S_OK;

    TRY
    {
        *ppICiCDocName = new CCiCDocName;
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIdentityNameTranslator::WorkIdToDocName
//
//  Synopsis:   Translates a WorkId to a document name
//
//  Arguments:  [workid]       - WorkId to translate
//              [pICiCDocName] - Doc Name filled in here
//
//  History:    24-Feb-1997     SitaramR   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIdentityNameTranslator::WorkIdToDocName( WORKID workid,
                                                                  ICiCDocName * pICiCDocName )
{
    //
    // The name is a serialized form of wid, i.e. 4 bytes long
    //

    Win4Assert( sizeof(WORKID) == 2 * sizeof(WCHAR) );

    CCiCDocName *pDocName = (CCiCDocName *) pICiCDocName;
    pDocName->SetPath( (WCHAR *)&workid, sizeof(WORKID)/sizeof(WCHAR) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIdentityNameTranslator::DocNameToWorkId
//
//  Synopsis:   Converts a document name to a WorkId.
//
//  Arguments:  [pICiCDocName] - Document Name
//              [pWorkid]      - Workid returned here
//
//  History:    24-Feb-1997     SitaramR   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIdentityNameTranslator::DocNameToWorkId( ICiCDocName const * pICiCDocName,
                                                                  WORKID * pWorkid )
{
    Win4Assert( 0 != pICiCDocName );
    Win4Assert( 0 != pWorkid );

    CCiCDocName const * pDocName = (CCiCDocName const *) pICiCDocName;
    WCHAR const *pwszPath = pDocName->GetPath();
    RtlCopyMemory( pWorkid, pwszPath, sizeof(WORKID) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\idxentry.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        idxentry.cxx
//
// Contents:    Document filter interface
//
// Classes:     CIndexNotificationEntry
//
// History:     24-Feb-97       SitaramR     Created
//
// Notes:       The implementation uses the regular memory allocator,
//              and it makes a copy of every text string and property
//              that is added. A better approach may be to define a
//              custom memory allocator that allocates portions as
//              needed from say a 4K block of memory.
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cifrmcom.hxx>

#include "idxentry.hxx"
#include "cimanger.hxx"


//+---------------------------------------------------------------------------
//
//  Member:     CChunkEntry::CChunkEntry
//
//  Synopsis:   Constructor
//
//  Arguments:  [pStatChunk]   -- Pointer to stat chunk
//              [pwszText]     -- Text
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CChunkEntry::CChunkEntry( STAT_CHUNK const * pStatChunk, WCHAR const *pwszText )
    : _pChunkEntryNext( 0 )
{
    _statChunk = *pStatChunk;

    XPtrST<WCHAR> xPropString;
    if ( _statChunk.attribute.psProperty.ulKind == PRSPEC_LPWSTR )
    {
        //
        // Make own copy of property string
        //
        ULONG cwcLen = wcslen( pStatChunk->attribute.psProperty.lpwstr ) + 1;
        _statChunk.attribute.psProperty.lpwstr = new WCHAR[cwcLen];
        RtlCopyMemory( _statChunk.attribute.psProperty.lpwstr,
                       pStatChunk->attribute.psProperty.lpwstr,
                       cwcLen * sizeof( WCHAR ) );

        xPropString.Set( _statChunk.attribute.psProperty.lpwstr );
    }

    ULONG cwcLen = wcslen( pwszText ) + 1;
    _pwszText = new WCHAR[cwcLen];
    RtlCopyMemory( _pwszText, pwszText, cwcLen * sizeof(WCHAR) );

    xPropString.Acquire();  // Pass ownership to CChunkEntry
}


//+---------------------------------------------------------------------------
//
//  Member:     CChunkEntry::CChunkEntry
//
//  Synopsis:   Constructor
//
//  Arguments:  [pStatChunk]   -- Pointer to stat chunk
//              [pPropVar]     -- Property
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CChunkEntry::CChunkEntry( STAT_CHUNK const * pStatChunk, PROPVARIANT const * pPropVar )
    : _pChunkEntryNext( 0 )
{
    _statChunk = *pStatChunk;

    XPtrST<WCHAR> xPropString;
    if ( _statChunk.attribute.psProperty.ulKind == PRSPEC_LPWSTR )
    {
        //
        // Make own copy of property string
        //
        ULONG cwcLen = wcslen( pStatChunk->attribute.psProperty.lpwstr ) + 1;
        _statChunk.attribute.psProperty.lpwstr = new WCHAR[cwcLen];
        RtlCopyMemory( _statChunk.attribute.psProperty.lpwstr,
                       pStatChunk->attribute.psProperty.lpwstr,
                       cwcLen * sizeof( WCHAR ) );

         xPropString.Set( _statChunk.attribute.psProperty.lpwstr );
    }

    _pStgVariant = new CStorageVariant( *(PROPVARIANT *)pPropVar );
    if ( _pStgVariant == 0 )
        THROW( CException( E_OUTOFMEMORY ) );

    xPropString.Acquire();  // Pass ownership to CChunkEntry
}


//+---------------------------------------------------------------------------
//
//  Member:     CChunkEntry::~CChunkEntry
//
//  Synopsis:   Destructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CChunkEntry::~CChunkEntry()
{
    if ( _statChunk.attribute.psProperty.ulKind == PRSPEC_LPWSTR )
        delete _statChunk.attribute.psProperty.lpwstr;

    if ( _statChunk.flags == CHUNK_TEXT )
        delete _pwszText;
    else
        delete _pStgVariant;
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationEntry::CIndexNotificationEntry
//
//  Synopsis:   Constructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CIndexNotificationEntry::CIndexNotificationEntry(
                             WORKID wid,
                             CI_UPDATE_TYPE eUpdateType,
                             XInterface<CIndexNotificationTable> & xNotifTable,
                             XInterface<ICiCIndexNotificationStatus> & xNotifStatus,
                             CCiManager * pCiManager,
                             USN usn )
        : _xNotifTable( xNotifTable.Acquire() ),
          _xNotifStatus( xNotifStatus.Acquire() ),
          _pCiManager( pCiManager ),
          _wid( wid ),
          _eUpdateType( eUpdateType ),
          _fAddCompleted( FALSE ),
          _fShutdown( FALSE ),
          _fFilterDataPurged( FALSE ),
          _usn( usn ),
          _pChunkEntryHead( 0 ),
          _pChunkEntryTail( 0 ),
          _pChunkEntryIter( 0 ),
          _cRefs( 1 )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationEntry::~CIndexNotificationEntry
//
//  Synopsis:   Destructor
//
//  History:    24-Feb-97      SitaramR       Created
//
//----------------------------------------------------------------------------

CIndexNotificationEntry::~CIndexNotificationEntry()
{
    PurgeFilterData();
}


//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIndexNotificationEntry::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIndexNotificationEntry::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationEntry::QueryInterface( REFIID riid,
                                                                 void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_ICiIndexNotificationEntry )
        *ppvObject = (void *)(ICiIndexNotificationEntry *) this;
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::AddText
//
//  Synopsis:   Adds a text chunk
//
//  Arguments:  [pStatChunk] -- Pointer to stat chunk
//              [pwszText]   -- Text
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationEntry::AddText( STAT_CHUNK const * pStatChunk,
                                                          WCHAR const * pwszText )
{
    if ( _fShutdown )
        return CI_E_SHUTDOWN;

    if ( _fAddCompleted )
    {
        Win4Assert( !"Adding text after AddCompleted was signalled" );

        return E_FAIL;
    }

    Win4Assert( pStatChunk->flags == CHUNK_TEXT );

    SCODE sc = S_OK;

    TRY
    {
        CChunkEntry *pEntry = new CChunkEntry( pStatChunk, pwszText );
        if ( _pChunkEntryTail )
        {
            _pChunkEntryTail->SetNextChunkEntry( pEntry ); // does not fail
            _pChunkEntryTail = pEntry;
        }

        else
        {
            _pChunkEntryTail = pEntry;
            _pChunkEntryHead = pEntry;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationEntry::AddText - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::AddProperty
//
//  Synopsis:   Adds a property chunk
//
//  Arguments:  [pStatChunk] -- Pointer to stat chunk
//              [pPropVar]   -- Property
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationEntry::AddProperty( STAT_CHUNK const * pStatChunk,
                                                              PROPVARIANT const *pPropVar )
{
    if ( _fShutdown )
        return CI_E_SHUTDOWN;

    if ( _fAddCompleted )
    {
        Win4Assert( !"Adding property after AddCompleted was signalled" );

        return E_FAIL;
    }

    Win4Assert( pStatChunk->flags == CHUNK_VALUE );

    SCODE sc = S_OK;

    TRY
    {
        CChunkEntry *pEntry = new CChunkEntry( pStatChunk, pPropVar );
        if ( _pChunkEntryTail )
        {
            _pChunkEntryTail->SetNextChunkEntry( pEntry ); // does not fail
            _pChunkEntryTail = pEntry;
        }
        else
        {
            _pChunkEntryTail = pEntry;
            _pChunkEntryHead = pEntry;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationEntry::AddProperty - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::AddCompleted
//
//  Synopsis:   Signifies end of chunks. At this time the notification is
//              propagated to CCiManager.
//
//  Arguments:  [fAbort] -- If true, then the notification should not be
//                          propagted to ICiManager. Also, all resources
//                          need to be released
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationEntry::AddCompleted( ULONG fAbort )
{
    if ( _fAddCompleted )
    {
        Win4Assert( !"AddCompleted being called for the second time" );

        return E_FAIL;
    }

    SCODE sc = S_OK;

    TRY
    {
        CIndexNotificationEntry *pNotifEntry;
        _fAddCompleted = TRUE;

        if ( fAbort || _fShutdown )
        {
            SCODE scode = _xNotifStatus->Abort();

            //
            // We don't have retry logic on failures
            //
            Win4Assert( SUCCEEDED( scode ) );

            //
            // Free entry from hash table, which should be ourself
            //
            XInterface<CIndexNotificationEntry> xIndexNotifEntry;
            _xNotifTable->Remove( _wid, xIndexNotifEntry );

            Win4Assert( this == xIndexNotifEntry.GetPointer() );

            //
            // xIndexNotifEntry is released when it goes out of scope
            //
        }
        else
        {
            CDocumentUpdateInfo info( _wid, CI_VOLID_USN_NOT_ENABLED, _usn, FALSE );
            sc = _pCiManager->UpdDocumentNoThrow( &info );

            if ( FAILED( sc ) )
            {
                SCODE scode = _xNotifStatus->Abort();

                //
                // We don't have retry logic on failures
                //
                Win4Assert( SUCCEEDED( scode ) );

                //
                // Free entry from hash table, which should be ourself
                //
                XInterface<CIndexNotificationEntry> xIndexNotifEntry;
                _xNotifTable->Remove( _wid, xIndexNotifEntry );

                Win4Assert( this == xIndexNotifEntry.GetPointer() );

                //
                // xIndexNotifEntry is released when it goes out of scope
                //
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationEntry::AddCompleted - Exception caught 0x%x\n",
                     sc ));
        //
        // Not clear why AddCompleted can ever fail
        //
        Win4Assert( !"AddCompleted failed" );
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::GetFirstChunk
//
//  Synopsis:   Returns first entry in list of chunks
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

CChunkEntry *CIndexNotificationEntry::GetFirstChunk()
{
    if ( _fFilterDataPurged )
    {
        Win4Assert( !"Re-filtering is not allowed in push filtering" );

        return 0;
    }
    _pChunkEntryIter = _pChunkEntryHead;
    return _pChunkEntryIter;
}


//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::GetNextChunk
//
//  Synopsis:   Returns next entry in list of chunks. The state of iterator
//              is maintained in _pChunkEntryIter, which can be reset by
//              GetFirstChunk.
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

CChunkEntry *CIndexNotificationEntry::GetNextChunk()
{
    if ( _fFilterDataPurged )
    {
        Win4Assert( !"Re-filtering is not allowed in push filtering" );

        return 0;
    }
    
    if ( _pChunkEntryIter == 0 )
        return 0;
    else
    {
        _pChunkEntryIter = _pChunkEntryIter->GetNextChunkEntry();
        return _pChunkEntryIter;
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationEntry::PurgeFilterData
//
//  Synopsis:   Deletes filter data, because wids are filtered only once
//              in push filtering.
//
//  History:    17-Jun-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

void CIndexNotificationEntry::PurgeFilterData()
{
    _fFilterDataPurged = TRUE;
    
    //
    // Clean up all chunks
    //
    if ( _pChunkEntryHead != 0 )
    {
        CChunkEntry *pEntryPrev = _pChunkEntryHead;
        CChunkEntry *pEntryNext = pEntryPrev->GetNextChunkEntry();

        while ( pEntryNext != 0 )
        {
            delete pEntryPrev;
            pEntryPrev = pEntryNext;
            pEntryNext = pEntryNext->GetNextChunkEntry();
        }

        delete pEntryPrev;

        _pChunkEntryHead = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\idxnotif.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        idxnotif.cxx
//
// Contents:    Document notification interfaces
//
// Classes:     CIndexNotificationTable
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "idxnotif.hxx"
#include "idxentry.hxx"
#include "notifdoc.hxx"
#include "cimanger.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::CIndexNotificationTable
//
//  Synopsis:   Constructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CIndexNotificationTable::CIndexNotificationTable( CCiManager * pCiManager,
                                                  XInterface<ICiCDocStore> & xDocStore )
        : _pCiManager( pCiManager ),
          _xDocStore( xDocStore.Acquire() ),
          _fInitialized( FALSE ),
          _fShutdown( FALSE ),
          _usnCtr( 1 ),
          _cRefs( 1 )
{
    for ( ULONG i=0; i<NOTIF_HASH_TABLE_SIZE; i++)
        _aHashTable[i] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::~CIndexNotificationTable
//
//  Synopsis:   Destructor
//
//  History:    24-Feb-97      SitaramR       Created
//
//----------------------------------------------------------------------------

CIndexNotificationTable::~CIndexNotificationTable()
{
    Shutdown();
}


//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIndexNotificationTable::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CIndexNotificationTable::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::QueryInterface( REFIID riid,
                                                                 void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_ICiIndexNotification )
        *ppvObject = (void *)(ICiIndexNotification *) this;
    else if ( riid == IID_ICiCFilterClient )
        *ppvObject = (void *)(ICiCFilterClient *) this;
    else if ( riid == IID_ICiCAdviseStatus )
        return _xDocStore->QueryInterface( riid, ppvObject );
    else if ( riid == IID_ICiCLangRes )
        return _xDocStore->QueryInterface( riid, ppvObject );
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *)(ICiIndexNotification *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::AddNotification
//
//  Synopsis:   New document notification
//
//  Arguments:  [wid]                -- Workid of document
//              [pIndexNotifStatus]  -- Status of notifcation returned here
//              [ppIndexNotifEntry]  -- Buffer to document properties
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::AddNotification(
                                                     WORKID wid,
                                                     ICiCIndexNotificationStatus *pIndexNotifStatus,
                                                     ICiIndexNotificationEntry **ppIndexNotifEntry )
{
    Win4Assert( wid != widInvalid );
    Win4Assert( pIndexNotifStatus != 0 );

    if ( _fShutdown )
        return CI_E_SHUTDOWN;

    SCODE sc = S_OK;

    TRY
    {
        pIndexNotifStatus->AddRef();
        XInterface<ICiCIndexNotificationStatus> xNotifStatus( pIndexNotifStatus );
        CIndexNotificationEntry *pIndexNotifEntry;

        BOOL fFound;
        {
            CLock lock(_mutex);

            fFound = LokLookup( wid, pIndexNotifEntry );
            if ( fFound )
                sc = CI_E_DUPLICATE_NOTIFICATION;
        }

        if ( !fFound )
        {
            AddRef();
            XInterface<CIndexNotificationTable> xNotifTable(this);

            CheckForUsnOverflow();
            USN usn = InterlockedIncrement( &_usnCtr );

            pIndexNotifEntry = new CIndexNotificationEntry( wid,
                                                            CI_UPDATE_ADD,
                                                            xNotifTable,
                                                            xNotifStatus,
                                                            _pCiManager,
                                                            usn );
            XInterface<CIndexNotificationEntry> xIndexNotifEntry( pIndexNotifEntry );

            CHashTableEntry *pHashEntry = new CHashTableEntry( wid, pIndexNotifEntry );

            {
                CLock lock(_mutex);
                LokNoFailAdd( pHashEntry );
                if ( _fShutdown )
                    pIndexNotifEntry->Shutdown();
            }

            xIndexNotifEntry.Acquire();    // Passed ownership to hash table

            sc = pIndexNotifEntry->QueryInterface( IID_ICiIndexNotificationEntry,
                                                   (void **)ppIndexNotifEntry );
            //
            // No release on pIndexNotifEntry because both the hash table the client
            // own pIndexNotifEntry
            //

            Win4Assert( SUCCEEDED( sc ) );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationTable::AddNotification - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}





//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::ModifyNotification
//
//  Synopsis:   Change document notification
//
//  Arguments:  [wid]                -- Workid of document
//              [pIndexNotifStatus]  -- Status of notifcation returned here
//              [ppIndexNotifEntry]  -- Buffer to document properties
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::ModifyNotification(
                                                     WORKID wid,
                                                     ICiCIndexNotificationStatus *pIndexNotifStatus,
                                                     ICiIndexNotificationEntry **ppIndexNotifEntry )
{
   //
   // There is no difference between an add and a modify in the CI engine
   //
   SCODE sc = AddNotification( wid, pIndexNotifStatus, ppIndexNotifEntry );
   return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::DeleteNotification
//
//  Synopsis:   Delete document notification
//
//  Arguments:  [wid]                -- Workid of document
//              [pIndexNotifStatus]  -- Status of notifcation returned here
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::DeleteNotification(
                                                     WORKID wid,
                                                     ICiCIndexNotificationStatus *pIndexNotifStatus )
{
    Win4Assert( wid != widInvalid );
    Win4Assert( pIndexNotifStatus != 0 );

    if ( _fShutdown )
        return CI_E_SHUTDOWN;

    SCODE sc = S_OK;

    TRY
    {
        pIndexNotifStatus->AddRef();
        XInterface<ICiCIndexNotificationStatus> xNotifStatus( pIndexNotifStatus );
        CIndexNotificationEntry *pIndexNotifEntry;

        BOOL fFound;
        {
            CLock lock(_mutex);

            fFound = LokLookup( wid, pIndexNotifEntry );
            if ( fFound )
                sc = CI_E_DUPLICATE_NOTIFICATION;
        }

        if ( !fFound )
        {
            CheckForUsnOverflow();
            USN usn = InterlockedIncrement( &_usnCtr );

            AddRef();
            XInterface<CIndexNotificationTable> xNotifTable(this);

            pIndexNotifEntry = new CIndexNotificationEntry( wid,
                                                            CI_UPDATE_DELETE,
                                                            xNotifTable,
                                                            xNotifStatus,
                                                            _pCiManager,
                                                            usn );

            XInterface<CIndexNotificationEntry> xIndexNotifEntry( pIndexNotifEntry );

            CHashTableEntry *pHashEntry = new CHashTableEntry( wid, pIndexNotifEntry );

            XPtr<CHashTableEntry> xHashEntry( pHashEntry );

            CDocumentUpdateInfo info( wid, CI_VOLID_USN_NOT_ENABLED, usn, TRUE );
            sc  = _pCiManager->UpdDocumentNoThrow( &info );
            if ( FAILED( sc ) )
            {
                SCODE scode = pIndexNotifStatus->Abort();

                //
                // We don't have retry logic coded in case of failure,
                // hence check that it succeeded
                //
                Win4Assert( SUCCEEDED( scode ) );
            }
            else
            {
                CLock lock(_mutex);
                LokNoFailAdd( pHashEntry );
                if ( _fShutdown )
                    pIndexNotifEntry->Shutdown();

                xIndexNotifEntry.Acquire();        // Passed ownership to hash table
                xHashEntry.Acquire();
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationTable::DeleteNotification - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CIndexNotificationTable::GetConfigInfo
//
//  Synopsis:   Return configuration info
//
//  Arguments:  [pConfigInfo] - output data structure
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::GetConfigInfo(
                                       CI_CLIENT_FILTER_CONFIG_INFO *pConfigInfo )
{
    //
    // Security generation must be specified as part of configuration
    // information to the push model.
    //

    pConfigInfo->fSupportsOpLocks = FALSE;
    pConfigInfo->fSupportsSecurity = FALSE;

    return S_OK;

}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::Init
//
//  Synopsis:   Initialize storage filtering
//
//  Arguments:  [pbData]            - input data, ignored
//              [cbData]            - length of data, ignored
//              [pICiAdminParams]   - interface for retrieving configuration
//
//  History:    24-Feb-1997     SitaramR   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::Init( const BYTE * pbData,
                                                       ULONG cbData,
                                                       ICiAdminParams *pICiAdminParams )
{
    _fInitialized = TRUE;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::GetOpenedDoc
//
//  Synopsis:   Return a new OpenedDoc instance
//
//  Arguments:  [ppICiCOpenedDoc] - Interface pointer returned here
//
//  History:    24-Feb-1997     SitaramR   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CIndexNotificationTable::GetOpenedDoc( ICiCOpenedDoc ** ppICiCOpenedDoc )
{
    if ( !_fInitialized )
    {
        ppICiCOpenedDoc = 0;
        return CI_E_NOT_INITIALIZED;
    }

    SCODE sc = S_OK;

    TRY
    {
        AddRef();
        XInterface<CIndexNotificationTable> xNotifTable( this );

        CINOpenedDoc *pOpenedDoc = new CINOpenedDoc( xNotifTable );
        sc = pOpenedDoc->QueryInterface( IID_ICiCOpenedDoc, (void **)ppICiCOpenedDoc );

        pOpenedDoc->Release();   // QI does an AddRef
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CIndexNotificationTable::GetOpenedDoc - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::Hash
//
//  Synopsis:   Implements the hash function
//
//  Arguments:  [wid] - Workid to hash
//
//  History:    24-Feb-1997     SitaramR      Created
//
//  Returns:    Position of chained list in hash table
//
//----------------------------------------------------------------------------

ULONG CIndexNotificationTable::Hash( WORKID wid )
{
    return wid % NOTIF_HASH_TABLE_SIZE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::LokLookup
//
//  Synopsis:   Return the mapping corresponding to given wid
//
//  Arguments:  [wid]              -- Workid to hash
//              [pIndexNotifEntry] -- Index entry returned here
//
//  History:    24-Feb-1997     SitaramR      Created
//
//  Returns:    True if a mapping was found in the hash table
//
//----------------------------------------------------------------------------

BOOL CIndexNotificationTable::LokLookup( WORKID wid,
                                         CIndexNotificationEntry * &pIndexNotifEntry )
{
    unsigned uHashValue = Hash( wid );

    Win4Assert( uHashValue < NOTIF_HASH_TABLE_SIZE );

    for ( CHashTableEntry *pHashEntry = _aHashTable[uHashValue];
          pHashEntry != 0;
          pHashEntry = pHashEntry->GetNextHashEntry() )
    {
        if ( pHashEntry->GetWorkId() == wid )
        {
            pIndexNotifEntry  = pHashEntry->GetNotifEntry();
            return TRUE;
        }
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::LokNoFailAdd
//
//  Synopsis:   Add a wid->pIndexEntry mapping
//
//  Arguments:  [pHashEntry]    -- Hash entry
//
//  History:    24-Feb-1997     SitaramR      Created
//
//  Notes:      LokNoFailAdd should not fail due to memory allocations
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::LokNoFailAdd( CHashTableEntry *pHashEntry )
{
#if DBG == 1
    //
    // Check for duplicate entries
    //
    CIndexNotificationEntry *pExistingData;

    BOOL fFound = LokLookup( pHashEntry->GetWorkId(), pExistingData );
    Win4Assert( !fFound );
#endif

    unsigned uHashValue = Hash( pHashEntry->GetWorkId() );
    pHashEntry->SetNextHashEntry( _aHashTable[uHashValue] );
    _aHashTable[uHashValue] = pHashEntry;

    ciDebugOut(( DEB_ITRACE, "Adding Workid %d at %d hash entry\n",
                    pHashEntry->GetWorkId(),
                    uHashValue ));
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::LokRemove
//
//  Synopsis:   Return the mapping corresponding to given wid
//
//  Arguments:  [wid]              -- Workid to hash
//              [xIndexNotifEntry] -- Index entry returned here
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::LokRemove( WORKID wid,
                                         XInterface<CIndexNotificationEntry>  & xIndexNotifEntry )
{
    unsigned uHashValue = Hash( wid );

    Win4Assert( uHashValue < NOTIF_HASH_TABLE_SIZE );

    CHashTableEntry *pHashEntry = _aHashTable[uHashValue];

    if ( pHashEntry == 0 )
    {
        Win4Assert( !"Wid not found in hash table" );
        return;
    }

    if ( pHashEntry->GetWorkId() == wid )
    {
        //
        // Wid is the first entry in chain
        //
        _aHashTable[uHashValue] = pHashEntry->GetNextHashEntry();
        xIndexNotifEntry.Set( pHashEntry->GetNotifEntry() );

        ciDebugOut(( DEB_ITRACE, "Removing Workid %d:%d at %d hash entry\n",
                        pHashEntry->GetWorkId(), wid,
                        uHashValue ));

        delete pHashEntry;
        return;
    }

    CHashTableEntry *pHashEntryPrev = pHashEntry;
    pHashEntry = pHashEntry->GetNextHashEntry();
    while ( pHashEntry != 0 )
    {
        if ( pHashEntry->GetWorkId() == wid )
        {
            pHashEntryPrev->SetNextHashEntry( pHashEntry->GetNextHashEntry() );
            xIndexNotifEntry.Set( pHashEntry->GetNotifEntry() );

            ciDebugOut(( DEB_ITRACE, "Removing Workid %d:%d at %d hash entry\n",
                            pHashEntry->GetWorkId(), wid,
                            uHashValue ));

            delete pHashEntry;
            return;
        }
        pHashEntryPrev = pHashEntry;
        pHashEntry = pHashEntry->GetNextHashEntry();
    }

    Win4Assert( !"Wid not found in hash table" );
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::Remove
//
//  Synopsis:   Return the mapping corresponding to given wid
//
//  Arguments:  [wid]              -- Workid to hash
//              [xIndexNotifEntry] -- Index entry returned here
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::Remove( WORKID wid,
                                      XInterface<CIndexNotificationEntry>  & xIndexNotifEntry )
{
    CLock lock(_mutex);

    LokRemove( wid, xIndexNotifEntry );
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::Lookup
//
//  Synopsis:   Lookup the mapping corresponding to given wid
//
//  Arguments:  [wid]              -- Workid to hash
//              [pIndexNotifEntry] -- Index entry returned here
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

BOOL CIndexNotificationTable::Lookup( WORKID wid,
                                      CIndexNotificationEntry * &pIndexNotifEntry )
{
    CLock lock(_mutex);

    return LokLookup( wid, pIndexNotifEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::CommitWids
//
//  Synopsis:   Commits the notification status transactions on the given list
//              of wids
//
//  Arguments:  [aWidsInPersIndex]   -- Array of wids to be committed
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::CommitWids( CDynArrayInPlace<WORKID> & aWidsInPersIndex )
{

    for ( ULONG i=0; i<aWidsInPersIndex.Count(); i++)
    {
        WORKID wid = aWidsInPersIndex.Get( i );
        XInterface<CIndexNotificationEntry> xIndexNotifEntry;

        {
            CLock lock(_mutex);
            LokRemove( wid, xIndexNotifEntry );
        }

        Win4Assert( !xIndexNotifEntry.IsNull() );

        xIndexNotifEntry->Commit();       // Commit client transaction

        //
        // xIndexNotifEntry is released when it goes out of scope
        //
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::AbortWid
//
//  Synopsis:   Commits the notification status transactions on the given list
//              of wids
//
//  Arguments:  [cWidsInPersIndex]   -- Count of wids in array
//              [aWidsInPersIndex]   -- Array of wids to be committed
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::AbortWid( WORKID wid, USN usn )
{
    XInterface<CIndexNotificationEntry> xIndexNotifEntry;

    {
        CLock lock(_mutex);
        LokRemove( wid, xIndexNotifEntry );
    }

    Win4Assert( !xIndexNotifEntry.IsNull() );
    Win4Assert( xIndexNotifEntry->Usn() == usn );

    xIndexNotifEntry->Abort();         // Abort client transaction

    //
    // xIndexNotifEntry is released when it goes out of scope
    //
}




//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::CheckForUsnOverflow
//
//  Synopsis:   Handles overflows of usn by resetting the counter to 1
//
//  History:    24-Feb-1997     SitaramR      Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::CheckForUsnOverflow()
{
    if ( _usnCtr == LONG_MAX )
    {
        //
        // Overflow should be rare, if ever
        //
        Win4Assert( !"Usn counter overflow, resetting" );

        InterlockedExchange( &_usnCtr, 1 );
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexNotificationTable::Shutdown
//
//  Synopsis:   Shutdown processing
//
//  History:    24-Feb-97      SitaramR       Created
//
//----------------------------------------------------------------------------

void CIndexNotificationTable::Shutdown()
{
    //
    // Shutdown all entries in hash table
    //
    CLock lock( _mutex );

    _fShutdown = TRUE;

    for ( ULONG i=0; i<NOTIF_HASH_TABLE_SIZE; i++ )
    {
        CHashTableEntry *pEntry = _aHashTable[i];
        _aHashTable[i] = 0;

        while ( pEntry != 0 )
        {
            CHashTableEntry *pEntryPrev = pEntry;
            pEntry = pEntry->GetNextHashEntry();

            CIndexNotificationEntry *pIndexNotifEntry = pEntryPrev->GetNotifEntry();
            pIndexNotifEntry->Shutdown();
            pIndexNotifEntry->Release();

            delete pEntryPrev;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\olympus\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF


$(_OBJ_DIR)\$(TARGET_DIRECTORY)\ocifrmwk.def: ocifrmwk.def ..\cifrmwrk.org
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\notprop.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        notprop.cxx
//
// Contents:    Notification stat property enumeration interfaces
//
// Classes:     CINStatPropertyEnum, CINStatPropertyStorage
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "notprop.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyEnum::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINStatPropertyEnum::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}


//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyEnum::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINStatPropertyEnum::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyEnum::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINStatPropertyEnum::QueryInterface( REFIID riid,
                                                             void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_IEnumSTATPROPSTG )
        *ppvObject = (void *)(IEnumSTATPROPSTG *) this;
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

CINStatPropertyStorage::CINStatPropertyStorage()
    : _cRefs(1)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINStatPropertyStorage::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINStatPropertyStorage::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}



//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINStatPropertyStorage::QueryInterface( REFIID riid,
                                                             void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_IUnknown )
    {
        AddRef();
        *ppvObject = (void *)(IUnknown *) this;
        return S_OK;
    }
    else if ( riid == IID_IPropertyStorage )
    {
        AddRef();
        *ppvObject = (void *)(IPropertyStorage *) this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::ReadMultiple
//
//  Synopsis:   Generates a file size property
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINStatPropertyStorage::ReadMultiple(
                 ULONG cpspec,
                 const PROPSPEC rgpspec[],
                 PROPVARIANT rgpropvar[] )
{
    for (ULONG i = 0; i < cpspec; i++)
    {
        //
        //  String named properties are not found, and we only return
        //  the size property. The size is chosen to be a large number
        //  because the size is used to enforce space limits on
        //  filtering.
        //

        PROPID PropertyId;

        if (rgpspec[i].ulKind == PRSPEC_LPWSTR)
            PropertyId = 0xFFFFFFFF;
        else
            PropertyId = rgpspec[i].propid;

        if ( PropertyId == PID_STG_SIZE )
        {
            rgpropvar[i].vt = VT_I8;

            LARGE_INTEGER largeInt;
            largeInt.QuadPart = 0xFFFFFFF;
            rgpropvar[i].hVal = largeInt;
        }
        else
        {
            //
            //  No other properties exist, they are not found
            //
            rgpropvar[i].vt = VT_EMPTY;
            return E_FAIL;
        }
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CINStatPropertyStorage::Enum
//
//  Synopsis:   Returns an IEnumSTATPROPSTG interface
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINStatPropertyStorage::Enum( IEnumSTATPROPSTG **ppenum )
{
    SCODE sc = S_OK;

    TRY
    {
        *ppenum = new CINStatPropertyEnum;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINStatPropertyEnum::Enum - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\notifdoc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        notifdoc.cxx
//
// Contents:    Notification opened document interface
//
// Classes:     CINOpenedDoc
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "notifdoc.hxx"
#include "notprop.hxx"
#include "infilter.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::CINOpenedDoc
//
//  Synopsis:   Constructor
//
//  Arguments:  [xNotifTable]  -- Notification table
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CINOpenedDoc::CINOpenedDoc( XInterface<CIndexNotificationTable> & xNotifTable )
  : _widOpened( widInvalid ),
    _xNotifTable( xNotifTable.Acquire() ),
    _cRefs( 1 )
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CINOpenedDoc::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINOpenedDoc::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CINOpenedDoc::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINOpenedDoc::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}



//+-------------------------------------------------------------------------
//
//  Method:     CINOpenedDoc::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::QueryInterface( REFIID riid,
                                                      void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_ICiCOpenedDoc )
        *ppvObject = (void *)(ICiCOpenedDoc *) this;
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}




//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::Open
//
//  Synopsis:   Opens the specified file
//
//  Arguments:  [pbDocName] - Pointer to the name
//              [cbDocName] - Length in BYTES of the name
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE CINOpenedDoc::Open ( BYTE const * pbDocName, ULONG cbDocName )
{
    if ( _widOpened != widInvalid )
        return FILTER_E_ALREADY_OPEN;

    if ( cbDocName != sizeof( WORKID ) + sizeof( WCHAR ) )
    {
        //
        // Size should be serialized form of wid + null terminator
        //
        return E_INVALIDARG;
    }

    SCODE sc = S_OK;

    TRY
    {
        RtlCopyMemory( &_widOpened, pbDocName, sizeof(WORKID) );

        Win4Assert( _widOpened != widInvalid );

        if ( _widOpened == widInvalid )
            sc = E_INVALIDARG;
        else
        {
            CIndexNotificationEntry *pNotifEntry;
            BOOL fFound = _xNotifTable->Lookup( _widOpened, pNotifEntry );
            if ( fFound )
                _xName.Set( new CCiCDocName( (WCHAR *)pbDocName, sizeof(WORKID)/sizeof(WCHAR) ) );
            else
            {
                //
                // In push filtering model, wids are never refiled, and so the case of
                // a delete being refiled as a add cannot occur. Hence we shouldn't be
                // asked to open an unkwown wid. Hence the assert.
                //
                Win4Assert( !"Open: object not found" );

                sc = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINOpenedDoc::Open - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::Close
//
//  Synopsis:   Closes the opened file
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::Close()
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    SCODE sc = S_OK;

    TRY
    {
        _widOpened = widInvalid;
        _xName.Free();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINOpenedDoc::Close - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetDocumentName
//
//  Synopsis:   Returns the interface to the document name
//
//  Arguments:  [ppIDocName] - Pointer to the returned document name
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetDocumentName( ICiCDocName ** ppIDocName )
{
     if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    *ppIDocName = _xName.GetPointer();
    (*ppIDocName)->AddRef();

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetStatPropertyEnum
//
//  Synopsis:   Return property storage for the "stat" property set.  This
//              property set is not really stored but is faked.
//
//  Arguments:  [ppIStatPropEnum] - Pointer to the returned IPropertyStorage
//                                  interface
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetStatPropertyEnum( IPropertyStorage ** ppIStatPropEnum )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    SCODE sc = S_OK;

    TRY
    {
        CINStatPropertyStorage *pStorage = new CINStatPropertyStorage;
        sc = pStorage->QueryInterface( IID_IPropertyStorage,
                                       (void **) ppIStatPropEnum );

        pStorage->Release();   // QI does an AddRef
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINOpenedDoc::GetStatPropertyEnum - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetPropertySetEnum
//
//  Synopsis:   Returns the docfile property set storage interface on the
//              current doc.
//
//  Arguments:  [ppIPropSetEnum] - Returned pointer to the Docfile property
//                                 set storage
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetPropertySetEnum( IPropertySetStorage ** ppIPropSetEnum )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    //
    // No docfiles in push filtering model
    //
    *ppIPropSetEnum = 0;
    return FILTER_S_NO_PROPSETS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetPropertyEnum
//
//  Synopsis:   Return the property storage for a particular property set
//
//  Arguments:  [GuidPropSet] - GUID of the property set whose property
//                              storage is being requested
//              [ppIPropEnum] - Returned pointer to property storage
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetPropertyEnum( REFFMTID refGuidPropSet,
                                                       IPropertyStorage **ppIPropEnum )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    //
    // No property sets in push filtering
    //
    *ppIPropEnum = 0;
    return FILTER_E_NO_SUCH_PROPERTY;
}

//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetIFilter
//
//  Synopsis:   Return the appropriate filter bound to the document
//
//  Arguments:  [ppIFilter] - Returned IFilter
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetIFilter( IFilter ** ppIFilter )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    SCODE sc = S_OK;

    TRY
    {
        CIndexNotificationEntry *pIndexEntry;
        BOOL fFound = _xNotifTable->Lookup( _widOpened, pIndexEntry );

        //
        // We checked this in the Open method
        //
        Win4Assert( fFound );

        pIndexEntry->AddRef();
        XInterface<CIndexNotificationEntry> xNotifEntry( pIndexEntry );

        CINFilter *pFilter = new CINFilter( xNotifEntry );
        sc = pFilter->QueryInterface( IID_IFilter, (void **)ppIFilter );

        pFilter->Release();     // QI does an AddRef
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINOpenedDoc::GetIFilter - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::GetSecurity
//
//  Synopsis:   Retrieves security
//
//  Arguments:  [pbData]  - Pointer to returned buffer containing security descriptor
//              [pcbData] - Input:  size of buffer
//                          Output: amount of buffer used, if successful, size needed
//                                  otherwise
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::GetSecurity( BYTE * pbData, ULONG *pcbData )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    //
    // Allow security access always
    //
    *pbData = 0;
    *pcbData = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CINOpenedDoc::IsInUseByAnotherProcess
//
//  Synopsis:   Tests to see if the document is wanted by another process
//
//  Arguments:  [pfInUse] - Returned flag, TRUE => someone wants this document
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINOpenedDoc::IsInUseByAnotherProcess( BOOL *pfInUse )
{
    if ( _widOpened == widInvalid )
        return FILTER_E_NOT_OPEN;

    //
    // No oplocks in push filtering model
    //
    *pfInUse = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\cicur.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       cicur.cxx
//
//  Contents:   Content index based enumerator
//
//  History:    12-Dec-96     SitaramR     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "cicur.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CCiCursor::CCiCursor, public
//
//  Synopsis:   Create content index iterator
//
//  Arguments:  [pQuerySession]   -- Query session
//              [xXpr]            -- Expression (for CGenericCursor).
//              [accessMask]      -- ACCESS_MASK for security checks
//              [fAbort]          -- Set to true if we should abort
//              [cur]             -- CI cursor.
//
//  History:    19-Aug-93  KyleP    Created
//
//--------------------------------------------------------------------------

CCiCursor::CCiCursor( ICiCQuerySession *pQuerySession,
                      XXpr & xXpr,
                      ACCESS_MASK accessMask,
                      BOOL & fAbort,
                      XCursor & cur )
        : CGenericCursor( xXpr, accessMask, fAbort ),
          _pcur( cur )
{
    SetupPropRetriever( pQuerySession );

    //
    // Find the first matching object.
    //

    WORKID wid = _pcur->WorkId();

    while( wid != widInvalid )
    {
        if ( fAbort )
        {
            //
            // Query has been aborted
            //
            SetWorkId( widInvalid );
            return;
        }

        if ( InScope( wid ) )
            break;

        wid = _pcur->NextWorkId();
    }

    SetFirstWorkId( wid );
}

//+-------------------------------------------------------------------------
//
//  Member:     CCiCursor::CCiCursor, public
//
//  Synopsis:   Constructor called by derived CSortedByRankCursor
//
//  Arguments:  [pQuerySession]   -- Query session
//              [xxpr]            -- Expression (for CGenericCursor).
//              [accessMask]      -- ACCESS_MASK for security checks
//              [fAbort]          -- Set to true if we should abort
//
//  History:    5-Mar-96   SitaramR   Created
//
//--------------------------------------------------------------------------

CCiCursor::CCiCursor( ICiCQuerySession *pQuerySession,
                    XXpr & xXpr,
                    ACCESS_MASK accessMask,
                    BOOL & fAbort )
        : CGenericCursor( xXpr, accessMask, fAbort )
{
      SetupPropRetriever( pQuerySession );
}


//+-------------------------------------------------------------------------
//
//  Member:     CCiCursor::~CCiCursor, public
//
//  Synopsis:   Clean up context index cursor
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

CCiCursor::~CCiCursor()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CCiCursor::NextObject, public
//
//  Synopsis:   Move to next object
//
//  Returns:    Work id of next valid object, or widInvalid if end of
//              iteration.
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

WORKID CCiCursor::NextObject()
{
    WORKID wid = _pcur->NextWorkId();

    while( wid != widInvalid )
    {
        if ( InScope( wid ) )
            break;

        wid = _pcur->NextWorkId();
    }

    return( wid );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCiCursor::RatioFinished, public
//
//  Synopsis:   Returns query progress estimate
//
//  History:    21-Mar-95   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CCiCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    _pcur->RatioFinished (denom, num);
}



//+---------------------------------------------------------------------------
//
//  Member:     CCiCursor::SetupPropRetriever
//
//  Synopsis:   Sets up the property retriever
//
//  Arguments:  [pQuerySession]   --  Query session object
//
//  History:    12-Dec-96     SitaramR      Created
//
//----------------------------------------------------------------------------

void CCiCursor::SetupPropRetriever( ICiCQuerySession *pQuerySession )
{
    ICiCPropRetriever *pPropRetriever;

    SCODE sc = pQuerySession->CreatePropRetriever( &pPropRetriever );
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR, "SetupPropRetriever failed: 0x%x", sc ));

        THROW ( CException( sc ) );
    }

    _xPropRetriever.Set( pPropRetriever );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\indexing\infilter.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        infilter.cxx
//
// Contents:    IFilter interface to buffered notification
//
// Classes:     CINFilter
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "infilter.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::CINFilter
//
//  Synopsis:   Constructor
//
//  Arguments:  [xNotifEntry] -- Notification entry
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

CINFilter::CINFilter( XInterface<CIndexNotificationEntry> & xNotifEntry)
    : _pChunkEntry( 0 ),
      _xNotifEntry( xNotifEntry.Acquire() ),
      _fFirstChunk( TRUE ),
      _pStatChunk( 0 ),
      _cCharsInBuffer( 0 ),
      _cCharsRead( 0 ),
      _pwcCharBuf( 0 ),
      _cRefs( 1 )
{
}



//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::~CINFilter
//
//  Synopsis:   Destructor
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

CINFilter::~CINFilter()
{
    //
    // In push filtering, once filtering is done, then the wid is either
    // committed or aborted; it is never refiled. Hence the filter data
    // can be deleted, which is a space optimization.
    //

    _xNotifEntry->PurgeFilterData();
}



//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINFilter::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}


//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CINFilter::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    24-Feb-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINFilter::QueryInterface( REFIID riid,
                                                   void  ** ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( riid == IID_IFilter )
        *ppvObject = (void *)(IFilter *) this;
    else if ( riid == IID_IUnknown )
        *ppvObject = (void *)(IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::Init
//
//  Synopsis:   Initializes instance of filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array pAttributes
//              [pAttributes] -- array of attributes
//              [pFlags]      -- Set to 0 version 1
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINFilter::Init( ULONG grfFlags,
                                         ULONG cAttributes,
                                         FULLPROPSPEC const * pAttributes,
                                         ULONG * pFlags )
{
    _fFirstChunk = TRUE;
    *pFlags = 0;            // No OLE flags in push filtering
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINFilter::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = S_OK;

    TRY
    {
        if ( _fFirstChunk )
        {
            _pChunkEntry = _xNotifEntry->GetFirstChunk();
            _fFirstChunk = FALSE;
        }
        else
        {
            _pChunkEntry = _xNotifEntry->GetNextChunk();
        }

        if ( _pChunkEntry == 0 )
            sc = FILTER_E_END_OF_CHUNKS;
        else
        {
            _pStatChunk = _pChunkEntry->GetStatChunk();
            *pStat = *_pStatChunk;

            if ( _pStatChunk->flags == CHUNK_TEXT )
            {
                _pwcCharBuf = _pChunkEntry->GetTextBuffer();

                //
                // The assumption here is that the trailing null
                // is not part of the text
                //
                _cCharsInBuffer = wcslen( _pwcCharBuf );
                _cCharsRead = 0;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINFilter::GetChunk - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Method:     CINFilter::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    24-Feb-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput )
{
    if ( _pStatChunk->flags == CHUNK_VALUE )
        return FILTER_E_NO_TEXT;

    Win4Assert( _cCharsInBuffer >= _cCharsRead );

    ULONG cCharsRemaining = _cCharsInBuffer - _cCharsRead;
    if ( cCharsRemaining == 0 )
        return FILTER_E_NO_MORE_TEXT;

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcOutput,
                       _pwcCharBuf + _cCharsRead,
                       *pcwcOutput * sizeof(WCHAR) );
        _cCharsRead += *pcwcOutput;

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcOutput,
                       _pwcCharBuf + _cCharsRead,
                       cCharsRemaining * sizeof(WCHAR) );
        _cCharsRead += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

        return FILTER_S_LAST_TEXT;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CINFilter::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//  Arguments:  [ppPropValue] -- Value returned here
//
//  History:    24-Feb-1997     SitaramR        Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CINFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    if ( _pStatChunk->flags == CHUNK_TEXT )
        return FILTER_E_NO_VALUES;


    SCODE sc = S_OK;

    TRY
    {
       *ppPropValue = new CStorageVariant( *_pChunkEntry->GetVariant() );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR,
                     "CINFilter::GetChunk - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\olympus\dllreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       dllreg.cxx
//
//  Contents:   Null and Plain Text filter registration
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>

extern HANDLE ghDllInstance;
WCHAR wszDllFullPath[MAX_PATH+1];

SClassEntry const aTheNullClasses[] =
{
    { L".aif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".aps",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".asf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".avi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bin",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".bsc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cab",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".cgm",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".com",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dbg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dct",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".dll",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".eps",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".exe",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".exp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".eyb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".fnt",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".fon",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ghi",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".gif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".hqx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ico",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ilk",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".inv",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jbf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".jpg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".lib",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".m14",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mdb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mmf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mov",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".movie", L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".msg",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".mv",    L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ncb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".obj",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ocx",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pch",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pdb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pdf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pds",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pic",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pma",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pmc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pml",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".pmr",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".psd",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".res",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rpc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".rsp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sbr",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sc2",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sym",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".sys",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tar",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tif",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tiff",  L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tlb",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".tsp",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ttc",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".ttf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wav",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wll",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wlt",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".wmf",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".xix",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".z",     L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".z96",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
    { L".zip",   L"BinaryFile", L"Binary file", L"{08c524e0-89b0-11cf-88a1-00aa004b9986}", L"Binary file" },
};

SHandlerEntry const TheNullHandler =
{
    L"{098f2470-bae0-11cd-b579-08002b30bfeb}",
    L"Null persistent handler",
    L"{c3278e90-bea7-11cd-b579-08002b30bfeb}"
};

SFilterEntry const TheNullFilter =
{
    L"{c3278e90-bea7-11cd-b579-08002b30bfeb}",
    L"Null filter",
    wszDllFullPath,
    L"Both"
};

DEFINE_REGISTERFILTER( TheNull,
                       TheNullHandler,
                       TheNullFilter,
                       aTheNullClasses )

SClassEntry const aPlainTextClasses[] =
{
    // .dic files are marked as txtfiles by Office install

    { L".dic", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".txt", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".wtx", L"PlainText", L"Plain ASCII/UniCode text file",  L"{89bcb7a4-6119-101a-bcb7-00dd010655af}", L"Plain ASCII/UniCode text file" },
    { L".bat", L"batfile",   L"MS-DOS Batch File",              L"{89bcb7a5-6119-101a-bcb7-00dd010655af}", L"MS-DOS Batch File" },
    { L".cmd", L"cmdfile",   L"Windows Command Script",         L"{89bcb7a6-6119-101a-bcb7-00dd010655af}", L"Windows Command Script" },
    { L".idq", L"idqfile",   L"Microsoft Query parameter file", L"{961c1130-89ad-11cf-88a1-00aa004b9986}", L"Microsoft Query parameter file" },
    { L".ini", L"inifile",   L"Configuration Settings",         L"{8c9e8e1c-90f0-11d1-ba0f-00a0c906b239}", L"Configuration Settings" },
    { L".inx", L"inxfile",   L"Setup Settings",                 L"{95876eb0-90f0-11d1-ba0f-00a0c906b239}", L"Setup Settings" },
    { L".reg", L"regfile",   L"Registration Entries",           L"{9e704f44-90f0-11d1-ba0f-00a0c906b239}", L"Registration Entries" },
    { L".inf", L"inffile",   L"Setup Information",              L"{9ed4692c-90f0-11d1-ba0f-00a0c906b239}", L"Setup Information" },
};

SHandlerEntry const PlainTextHandler =
{
    L"{5e941d80-bf96-11cd-b579-08002b30bfeb}",
    L"Plain Text persistent handler",
    L"{c1243ca0-bf96-11cd-b579-08002b30bfeb}"
};

SFilterEntry const PlainTextFilter =
{
    L"{c1243ca0-bf96-11cd-b579-08002b30bfeb}",
    L"Plain Text filter",
    wszDllFullPath,
    L"Both"
};

DEFINE_REGISTERFILTER( PlainText,
                       PlainTextHandler,
                       PlainTextFilter,
                       aPlainTextClasses )

//
// Extra entries for CI Framework.  They happen to have the same form as the filter
// entries.
//

SFilterEntry const FrameworkControl =
{
    L"{47C67B50-70B5-11D0-A808-00A0C906241A}",
    L"Content Index Framework Control Object",
    wszDllFullPath,
    L"Both"
};

SFilterEntry const ISearchCreator =
{
    L"{1F247DC0-902E-11D0-A80C-00A0C906241A}",
    L"Content Index ISearch Creator Object",
    wszDllFullPath,
    L"Both"
};

extern "C" STDAPI DllRegisterServer(void)
{
    if (0 == GetModuleFileName((HMODULE)ghDllInstance, wszDllFullPath, MAX_PATH))
    {
        Win4Assert(!"Now, why did we fail to get module filename?");
        // we failed to get the full path name. default to just the filename
        wcscpy(wszDllFullPath, L"ocifrmwk.dll");
    }

    SCODE sc = TheNullRegisterServer();

    if ( S_OK == sc )
        sc = PlainTextRegisterServer();

    if ( S_OK == sc )
        sc = RegisterAFilter( FrameworkControl );

    if ( S_OK == sc )
        sc = RegisterAFilter( ISearchCreator );

    return sc;
} //DllRegisterServer

extern "C" STDAPI DllUnregisterServer(void)
{
    SCODE sc = TheNullUnregisterServer();
    SCODE sc2 = PlainTextUnregisterServer();
    SCODE sc3 = UnRegisterAFilter( FrameworkControl );
    SCODE sc4 = UnRegisterAFilter( ISearchCreator );

    if ( FAILED( sc ) )
        return sc;

    if ( FAILED( sc2 ) )
        return sc2;

    if ( FAILED( sc3 ) )
        return sc3;

    return sc4;
} //DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\enumcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       enumcur.cxx
//
//  Contents:   Enumeration cursor
//
//  Classes:    CEnumCursor
//
//  History:    12-Dec-96       SitaramR        Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "enumcur.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CEnumCursor::CEnumCursor
//
//  Synopsis:   Constructor
//
//  Arguments:  [xXpr]             -- Expression
//              [am]               -- Access mask
//              [fAbort]           -- Flag to abort
//              [xScopeEnum]       -- Scope enumerator
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

CEnumCursor::CEnumCursor( XXpr& xXpr,
                          ACCESS_MASK am,
                          BOOL &fAbort,
                          XInterface<ICiCScopeEnumerator>& xScopeEnum )
       : CGenericCursor( xXpr, am, fAbort ),
         _xScopeEnum( xScopeEnum.Acquire() )
{
    ICiCPropRetriever *pPropRetriever;

    SCODE sc = _xScopeEnum->QueryInterface( IID_ICiCPropRetriever, (void **)&pPropRetriever );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"CEnumCursor: Need to support a prop retriever interface" );

        THROW ( CException( sc ) );
    }

    _xPropRetriever.Set( pPropRetriever );

    sc = _xScopeEnum->Begin();
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR, "CEnumCursor, Begin failed: 0x%x", sc ));

        THROW ( CException( sc ) );
    }

    WORKID wid;
    sc = _xScopeEnum->CurrentDocument( &wid );

    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR, "CEnumCursor, CurrentDocument failed: 0x%x", sc ));

        _xScopeEnum->End();

        THROW ( CException( sc ) );
    }

    if ( sc == CI_S_END_OF_ENUMERATION )
        wid = widInvalid;

    SetFirstWorkId( wid );
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumCursor::~CEnumCursor
//
//  Synopsis:   Destructor
//
//  History:    01-Dec-97      KyleP           Created
//
//--------------------------------------------------------------------------

CEnumCursor::~CEnumCursor()
{
    _xScopeEnum->End();
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumCursor::NextObject
//
//  Synopsis:   Move to next object
//
//  Returns:    Work id of next valid object, or widInvalid if end of iteration.
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

WORKID CEnumCursor::NextObject()
{
    WORKID wid;
    SCODE sc = _xScopeEnum->NextDocument( &wid );
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR,
                     "CEnumCursor, CurrentDocument failed: 0x%x",
                     sc ));

        THROW ( CException( sc ) );
    }

    if ( sc == CI_S_END_OF_ENUMERATION )
        wid = widInvalid;

    return wid;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEnumCursor::RatioFinished
//
//  Synopsis:   Returns query progress estimate
//
//  Arguments:  [denom]   -- Denominator returned here
//              [num]     -- Numerator returned here
//
//  Returns:    Work id of next valid object, or widInvalid if end of iteration.
//
//  History:    12-Dec-96      SitaramR        Created
//
//--------------------------------------------------------------------------

void CEnumCursor::RatioFinished( ULONG& denom, ULONG& num )
{
    SCODE sc = _xScopeEnum->RatioFinished( &denom, &num );
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR,
                     "CEnumCursor, CurrentDocument failed: 0x%x",
                     sc ));

        THROW ( CException( sc ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\cqueue.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       CQueue.cxx
//
//  Contents:   Change queue for downlevel notification changes.
//
//  History:    30-Sep-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cqueue.hxx>
#include <ffenum.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CChangeQueue::CChangeQueue, public
//
//  Synopsis:   Constructor
//
//  History:    30-Sep-94   KyleP       Created.
//
//----------------------------------------------------------------------------

CChangeQueue::CChangeQueue()
        : _pCurrent( 0 ),
          _pCurrentBlock( 0 ),
          _pCurrentPath( 0 ),
          _fCurrentVirtual( 0 )
{
}

CChangeQueue::~CChangeQueue()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CChangeQueue::Add, public
//
//  Synopsis:   Add a block of change notifications
//
//  Arguments:  [pNotify] -- Block of filesystem notifications
//
//  History:    30-Sep-94   KyleP       Created.
//
//  Notes:      This version is used in kernel mode.  The major difference
//              from the user-mode version is that the block of memory is
//              just transferred instead of copied.
//
//----------------------------------------------------------------------------

void CChangeQueue::Add(
    CDirNotifyEntry * pNotify,
    WCHAR const *     pwcPath,
    BOOL              fVirtual )
{
    _stkChanges.Push( (BYTE *)pNotify );
    _aPathChanges.Add( pwcPath, _aPathChanges.Count() );
    _aVirtual.Add( fVirtual, _aVirtual.Count() );
}

CDirNotifyEntry const * CChangeQueue::First()
{
    Win4Assert( _pCurrent == 0 );
    Win4Assert( _pCurrentBlock == 0 );

    if ( _stkChanges.Count() > 0 )
    {
        _iCurrent = 0;
        _pCurrentBlock = _stkChanges.Get( _iCurrent );
        _pCurrent = (CDirNotifyEntry *)_pCurrentBlock;
        _pCurrentPath = _aPathChanges.Get( _iCurrent );
        _cwcCurrentPath = wcslen( _pCurrentPath );
        _fCurrentVirtual = _aVirtual.Get( _iCurrent );
    }

    return( _pCurrent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChangeQueue::Next, public
//
//  Synopsis:   Fetches next notification record
//
//  History:    30-Sep-94   KyleP       Created.
//
//----------------------------------------------------------------------------

CDirNotifyEntry const * CChangeQueue::Next()
{
    //
    // Get next entry from current block.
    //

    Win4Assert( 0 != _pCurrent );

    _pCurrent = _pCurrent->Next();

    //
    // Did we exhaust a block?
    //

    if ( 0 == _pCurrent )
    {
        //
        // Find a new block.
        //

        _iCurrent++;

        if ( _iCurrent < _stkChanges.Count() )
        {
            _pCurrentBlock = _stkChanges.Get( _iCurrent );
            _pCurrentPath = _aPathChanges.Get( _iCurrent );
            _cwcCurrentPath = wcslen( _pCurrentPath );
            _fCurrentVirtual = _aVirtual.Get( _iCurrent );
        }
        else
            _pCurrentBlock = 0;

        _pCurrent = (CDirNotifyEntry *)_pCurrentBlock;
    }

    return( _pCurrent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\normal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       Normal.cxx
//
//  Contents:   Restriction normalization.
//
//  History:    21-Feb-93  KyleP     Created
//              ?          SitaramR  Improved
//              12-Jul-96  dlee      Added check for explosion
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "normal.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::CRestrictionNormalizer
//
//  Synopsis:   Constructor
//
//  Arguments:  [fNoTimeout] -- Timeout ?
//              [cMaxNodes]  -- Cap on # restriction nodes
//
//  History:    30-May-95   SitaramR   Created
//
//----------------------------------------------------------------------------

CRestrictionNormalizer::CRestrictionNormalizer( BOOL fNoTimeout,
                                                ULONG cMaxNodes )
    : _fNoTimeout( fNoTimeout ),
      _cNodes( 0 ),
      _cMax( cMaxNodes )
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::Normalize
//
//  Synopsis:   Normalizes a restriction by
//              leaves and returns the resulting restriction
//
//  Arguments:  [pRst] -- input restriction
//
//  History:    30-May-95   SitaramR   Created
//
//----------------------------------------------------------------------------

CRestriction * CRestrictionNormalizer::Normalize(
    CRestriction * pRstIn )
{
    XPtr<CRestriction> xRst( ApplyDeMorgansLaw( pRstIn ) );

    #if CIDBG == 1
        vqDebugOut(( DEB_NORMALIZE,
                     "CQueryRstIterator: Query after applying DeMorgans law:\n" ));
        if ( xRst.GetPointer() )
            Display( xRst.GetPointer(), 0, DEB_NORMALIZE );
    #endif // CIDBG == 1

    xRst.Set( NormalizeRst( xRst.Acquire() ) );

    #if CIDBG == 1
        vqDebugOut(( DEB_NORMALIZE,
                     "CQueryRstIterator: Query after normalization:\n" ));
        if ( xRst.GetPointer() )
            Display( xRst.GetPointer(), 0, DEB_NORMALIZE );
    #endif // CIDBG == 1

    xRst.Set( AggregateRst( xRst.Acquire() ) );

    #if CIDBG == 1
        vqDebugOut(( DEB_ITRACE,
                     "CQueryRstIterator: Processed Query:\n" ));
        if ( xRst.GetPointer() )
            Display( xRst.GetPointer(), 0, DEB_ITRACE );
    #endif // CIDBG == 1

    return xRst.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::ApplyDeMorgansLaw
//
//  Synopsis:   Applies DeMorgan's law to move NOT restrictions closer to
//              leaves and returns the resulting restriction
//
//  Arguments:  [pRst] -- input restriction
//
//  History:    30-May-95   SitaramR   Created
//
//----------------------------------------------------------------------------

CRestriction * CRestrictionNormalizer::ApplyDeMorgansLaw(
    CRestriction *pRst )
{
    XRestriction xRst( pRst );

    //
    // Iterate over nodes in pRst as long as DeMorgans law can be applied
    //

    BOOL fChanged;

    do
    {
        fChanged = FALSE;

        switch ( xRst->Type() )
        {
        case RTOr:
        case RTAnd:
        {
            //
            // apply DeMorgans law to all children of the and/or node
            //

            CNodeRestriction *pNodeRst = (CNodeRestriction *) xRst.GetPointer();

            ULONG cChild = pNodeRst->Count();
            for ( ULONG i=0; i<cChild; i++ )
            {
                XRestriction xChildRst( ApplyDeMorgansLaw( pNodeRst->RemoveChild( 0 ) ) );

                pNodeRst->AddChild( xChildRst.GetPointer() );

                xChildRst.Acquire();
            }

            break;
        }

        case RTNot:
        {
            CNotRestriction *pNotRst = (CNotRestriction *) xRst.GetPointer();

            switch ( pNotRst->GetChild()->Type() )
            {
            case RTOr:
            case RTAnd:
                {
                    //
                    //  We can handle NOT expressions, but we cannot handle NOT content cursors. Hence,
                    //  we apply DeMorgan's Law only if pNotRst has content nodes
                    //
                    //  For e.g., we will apply the law to !(@size > 100 | !(@contents day | night)),
                    //  but we won't apply the law to !(@size > 100 | !(#filename *.txt | *.cxx))
                    //

                    BOOL fContentQuery = FALSE, fNonContentQuery = FALSE, fNotQuery = FALSE;

                    FindQueryType( pNotRst->GetChild(), fContentQuery, fNonContentQuery, fNotQuery );

                    if ( fContentQuery )
                    {
                        fChanged = TRUE;

                        CNodeRestriction *pChildRst = (CNodeRestriction *) pNotRst->GetChild();
                        CNodeRestriction *pResultNodeRst;

                        //
                        // Actual application of DeMorgan's law:
                        //     !( a + b + .. ) is changed to !a * !b * ..
                        //     !( a * b * .. ) is changed to !a + !b + ..
                        //

                        if ( pChildRst->Type() == RTOr )
                            pResultNodeRst = new CNodeRestriction( RTAnd );
                        else
                            pResultNodeRst = new CNodeRestriction( RTOr );

                        if ( !_fNoTimeout )
                            AddNodes( 1 );

                        XNodeRestriction xResultNodeRst( pResultNodeRst );

                        ULONG cChild = pChildRst->Count();
                        for ( ULONG i=0; i<cChild; i++ )
                        {
                            XNotRestriction xNotRst( new CNotRestriction( pChildRst->GetChild( 0 ) ) );
                            pChildRst->RemoveChild( 0 );     // acquired by NOT restriction above

                            if ( !_fNoTimeout )
                                AddNodes( 1 );

                            xResultNodeRst->AddChild( xNotRst.GetPointer() );

                            xNotRst.Acquire();
                        }

                        delete xRst.Acquire();

                        xRst.Set( xResultNodeRst.Acquire() );
                    }

                    break;
                }

            case RTNot:
                {
                    //
                    // Two successive NOT nodes is a case of two negatives making a positive, hence optimize
                    //

                    CRestriction *pGrandChild = ((CNotRestriction *) pNotRst->GetChild())->RemoveChild();

                    delete xRst.Acquire();   // delete the two successive NOT nodes

                    xRst.Set( pGrandChild );
                    break;
                }

            default:
                break;
            }

            break;
        }

        default:
            break;
        }
    } while ( fChanged );

    return xRst.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::NormalizeRst
//
//  Synopsis:   Normalizes a restriction
//
//  Effects:    Returned restrictions are of the form (A * ... * B) + ... + (D * ... * E),
//              or of the form (A ~ ... ~ B) + .... + (D ~ ... ~ E), where ~ is the proximity
//              operator
//
//  Arguments:  [pRst] -- input restriction
//
//  Returns:    A new, normalized restriction.  May or may not be different
//              from input.
//
//  History:    10-Dec-91   KyleP       Created.
//              02-Feb-93   KyleP       Use restrictions
//              30-May-95   SitaramR    Made sum-of-products the normalized form
//
//----------------------------------------------------------------------------

CRestriction * CRestrictionNormalizer::NormalizeRst(
    CRestriction * pRst )
{
    //
    // If the restriction is neither an AND node nor an OR node, nor a PROXIMITTY node,
    // then there's nothing to normalize
    //

    if ( pRst->Type() != RTOr && pRst->Type() != RTAnd && pRst->Type() != RTProximity)
    {
        vqDebugOut(( DEB_NORMALIZE,
                     "NormalizeRst: node is neither an AND nor an OR, nor a PROXIMITY node. No action taken.\n" ));
        return( pRst );
    }

    //
    // First normalize all the children of the node.
    //

    XNodeRestriction xNodeRst( (CNodeRestriction *) pRst );

    ULONG cChild = xNodeRst->Count();
    for ( ULONG i=0; i<cChild; i++ )
    {
        vqDebugOut(( DEB_NORMALIZE, "Normalizing child %d\n", i ));

        XRestriction xChildRst( NormalizeRst( xNodeRst->RemoveChild( 0 ) ) );

        xNodeRst->AddChild( xChildRst.GetPointer() );

        xChildRst.Acquire();
    }

    //
    // If this is an AND or PROXIMITY node, then apply appropriate transformations
    // to normalize it.
    //

    if ( xNodeRst->Type() == RTAnd || xNodeRst->Type() == RTProximity )
    {
        vqDebugOut(( DEB_NORMALIZE, "Beginning AND/PROXIMITY normalization.\n" ));

        //
        // Find any OR clauses below the AND/PROXIMITY clause. If there are any,
        // then we need to shift the OR clause up.
        //
        XNodeRestriction xHoldRst( new CNodeRestriction( RTOr ) );

        if ( !_fNoTimeout )
            AddNodes( 1 );

        //
        // When RemoveChild() is called, the array of child restrictions is
        // compacted. iChild keeps track of the next child restriction to be
        // processed, after taking compaction into account.
        //

        ULONG iChild = 0;
        ULONG cChild = xNodeRst->Count();

        for ( i=0; i<cChild; i++ )
        {
            if ( xNodeRst->GetChild( iChild )->Type() == RTOr )
            {
                BOOL fContinueNormalization;

                if (  xNodeRst->Type() == RTProximity )
                    fContinueNormalization = TRUE;
                else
                {
                    //
                    // If this is an AND node, we optimize by extracting an OR clause
                    // only if it has both content and non-content nodes.
                    //
                    // For e.g., we'll extract (@size > 100 | @contents night), but we won't extract
                    // (@contents day | night), and we won't extract (#filename *.cxx | *.hxx)
                    //
                    // Also, continue expansion if there is a NOT clause.
                    //
                    // Example: cat & (!dog | !horse)
                    //
                    // If we stopped expansion there, we have a content query we cannot resolve,
                    // but if we go one step further:
                    //
                    //   (cat & !dog) | (cat & !horse)
                    //
                    // then we can resolve the query.
                    //

                    BOOL fContentQuery = FALSE, fNonContentQuery = FALSE, fNotQuery = FALSE;

                    FindQueryType( xNodeRst->GetChild( iChild ), fContentQuery, fNonContentQuery, fNotQuery );
                    fContinueNormalization = (fContentQuery && fNonContentQuery) || fNotQuery;
                }

                if ( fContinueNormalization )
                {
                    XRestriction xRst( xNodeRst->RemoveChild( iChild ) );
                    xHoldRst->AddChild( xRst.GetPointer() );

                    xRst.Acquire();
                }
                else
                    iChild++;
            }
            else
                iChild++;
        }

        //
        // We need a separate AND/PROXIMITY clause containing one member of
        // each OR clause for every combination of nodes in
        // the OR clauses.  For example:
        //    ( A * B * C * (D + E + F) * (G + H))
        // is transformed to:
        //    ( A * B * C * D * G ) +
        //    ( A * B * C * D * H ) +
        //    ( A * B * C * E * G ) +
        //    ( A * B * C * E * H ) +
        //    ( A * B * C * F * G ) +
        //    ( A * B * C * F * H )
        //

        //
        // Clone the remaining AND/PROXIMITY clause and add elements, once for
        // each needed combination.  If there are no OR clauses, then
        // nothing needs to be done.
        //

        ULONG iOr = xHoldRst->Count();

        if ( iOr > 0 )
        {
            ULONG cClause = 1;

            for ( i=0; i<iOr; i++ )
            {
                CNodeRestriction * pnrOr = xHoldRst->GetChild( i )->CastToNode();
                cClause *= pnrOr->Count();
            }

            vqDebugOut(( DEB_NORMALIZE,
                         "Normalized OR node will have %d AND/PROXIMITY clauses.\n",
                         cClause ));

            XNodeRestriction xResultRst( new CNodeRestriction( RTOr, cClause ) );

            if ( !_fNoTimeout )
                AddNodes( 1 );

            //
            // Add common AND/PROXIMITY clauses to each branch of toplevel OR
            //

            for ( i=0; i<cClause; i++ )
            {
                XRestriction xAndRst( xNodeRst->Clone() );

                if ( !_fNoTimeout )
                    AddNodes( xAndRst->TreeCount() );

                xResultRst->AddChild( xAndRst.GetPointer() );

                xAndRst.Acquire();
            }

            //
            // Append the nodes from the OR clauses, in all possible
            // combinations.
            //

            ULONG cRepeat = cClause;

            for ( iOr=0; iOr<xHoldRst->Count(); iOr++ )
            {
                CNodeRestriction * pOrRst = xHoldRst->GetChild( iOr )->CastToNode();

                cRepeat /= pOrRst->Count();
                ULONG cCurrent = 0;

                while ( cCurrent < cClause )
                {
                    for ( ULONG iNode=0; iNode<pOrRst->Count(); iNode++ )
                    {
                        for ( i=0; i<cRepeat; i++ )
                        {
                            XRestriction xRst( pOrRst->GetChild( iNode )->Clone() );

                            if ( !_fNoTimeout )
                                AddNodes( xRst->TreeCount() );

                            CNodeRestriction * pnrCurr = xResultRst->GetChild(cCurrent++)->CastToNode();
                            pnrCurr->AddChild( xRst.GetPointer() );

                            xRst.Acquire();
                        }
                    }
                }
            }

            delete xNodeRst.Acquire();

            xNodeRst.Set( xResultRst.Acquire() );
        }

        vqDebugOut(( DEB_NORMALIZE, "Ending AND/PROXIMITY normalization.\n" ));
    }

    //
    // Now flatten the resulting expression.  This means constructs
    // like ( A + ( B + C ) ) become ( A + B + C ).
    //

    return FlattenRst( xNodeRst.Acquire() );
}

//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::FlattenRst
//
//  Synopsis:   Flattens a node restriction and returns it
//
//  Effects:    Converts structures like (A + (B + C)) to (A + B + C).
//
//  Arguments:  [pRst] -- Node to flatten.
//
//  Requires:   [pRst] is an AND or OR node.
//
//  History:    11-Dec-91   KyleP       Created.
//              02-Feb-93   KyleP       Converted to restrictions
//
//----------------------------------------------------------------------------

CRestriction * CRestrictionNormalizer::FlattenRst(
    CNodeRestriction * pNodeRst )
{
    Win4Assert( pNodeRst->Type() == RTOr || pNodeRst->Type() == RTAnd || pNodeRst->Type() == RTProximity );

    vqDebugOut(( DEB_NORMALIZE,
                 "FlattenRst: Pre-flattend node has %d clauses.\n",
                 pNodeRst->Count() ));

    //
    // Iterate over the nodes in pNodeRst until no more flattening occurs.
    //

    BOOL fChanged;
    XNodeRestriction xNodeRst( pNodeRst );
    ULONG nt = xNodeRst->Type();

    do
    {
        fChanged = FALSE;

        ULONG iChild = 0;
        ULONG cChildOuter = xNodeRst->Count();
        for ( ULONG i=0; i<cChildOuter; i++ )
        {
            CRestriction * pRst = xNodeRst->GetChild( iChild );

            if ( pRst->Type() == nt )
            {
                CNodeRestriction *pNodeRst = pRst->CastToNode();

                ULONG cChildInner = pNodeRst->Count();
                for ( ULONG j=0; j<cChildInner; j++ )
                {
                    XRestriction xRst( pNodeRst->RemoveChild( 0 ) );
                    xNodeRst->AddChild( xRst.GetPointer() );

                    xRst.Acquire();
                }

                delete xNodeRst->RemoveChild( iChild );
                fChanged = TRUE;
            }
            else
                iChild++;
        }

    } while ( fChanged );

    vqDebugOut(( DEB_NORMALIZE,
                 "Post-flattend node has %d clauses.\n",
                 xNodeRst->Count() ));

    //
    // Now Flatten any sub-nodes that are left.
    //

    ULONG iChild = 0;
    ULONG cChild = xNodeRst->Count();
    for ( ULONG i=0; i<cChild; i++ )
    {
        CRestriction * pRst = xNodeRst->GetChild( iChild );

        if ( pRst->Type() == RTOr || pRst->Type() == RTAnd || pRst->Type() == RTProximity )
        {
            Win4Assert( pRst->Type() != xNodeRst->Type() );

            XRestriction xRst( FlattenRst( (CNodeRestriction *) xNodeRst->RemoveChild( iChild ) ) );
            xNodeRst->AddChild( xRst.GetPointer() );

            xRst.Acquire();
        }
        else
            iChild++;
    }

    return xNodeRst.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Method:     CRestrictionNormalizer::AggregateRst
//
//  Synopsis:   Aggregates a restriction by combining all pure non-content restrictions
//              into one non-content restriction and all pure content restrictions into
//              one content restriction.
//
//              For e.g., @contents day | #filename *.cxx | @contents night | #filename *.txt
//                           is aggregated to
//                        (#filename *.cxx | #filename *.txt) | (@contents day | @contents night)
//
//  Arguments:  [pRst] -- input restriction
//
//  Returns:    A new, aggregated restriction.  May or may not be different
//              from input.
//
//  History:    19-Jul-95    SitaramR
//
//----------------------------------------------------------------------------

CRestriction * CRestrictionNormalizer::AggregateRst(
    CRestriction *pRst )
{
    //
    // If the restriction is not an OR node, then there is nothing to aggregate
    //

    if ( pRst->Type() != RTOr )
    {
        vqDebugOut(( DEB_NORMALIZE, "Node is not an OR node, no aggregation action taken\n" ));

        return pRst;
    }

    XNodeRestriction xNodeRst( (CNodeRestriction *) pRst );

    XNodeRestriction xContentRst( new CNodeRestriction( RTOr ) );

    XNodeRestriction xNonContentRst( new CNodeRestriction( RTOr ) );

    //
    // Extract all pure content restrictions and pure non-content restrictions
    //

    ULONG iChild = 0;
    ULONG cChild = xNodeRst->Count();
    BOOL fContentQuery, fNonContentQuery, fNotQuery;

    for ( ULONG i=0; i<cChild; i++)
    {
        fContentQuery = fNonContentQuery = fNotQuery = FALSE;

        FindQueryType( xNodeRst->GetChild( iChild ), fContentQuery, fNonContentQuery, fNotQuery );
        if ( fContentQuery && !fNonContentQuery )
        {
            xContentRst->AddChild( xNodeRst->GetChild( iChild ) );

            xNodeRst->RemoveChild( iChild );
        }
        else if ( !fContentQuery && fNonContentQuery )
        {
            xNonContentRst->AddChild( xNodeRst->GetChild( iChild ) );

            xNodeRst->RemoveChild( iChild );
        }
        else
            iChild++;
    }

    //
    // Optimize the case where xContentRst or xNonContentRst have just a single child,
    // obviating the need for an OR restriction
    //

    CNodeRestriction *pNodeRst;
    if ( xContentRst->Count() == 1 )
    {
        xNodeRst->AddChild( xContentRst->GetChild( 0 ) );

        xContentRst->RemoveChild( 0 );
    }

    if ( xNonContentRst->Count() == 1 )
    {
        xNodeRst->AddChild( xNonContentRst->GetChild( 0 ) );

        xNonContentRst->RemoveChild( 0 );
    }


    if ( xNodeRst->Count() == 0 )
    {
        if ( xContentRst->Count() == 0 )
            return xNonContentRst.Acquire();
        else
        {
            if ( xNonContentRst->Count() == 0 )
                return xContentRst.Acquire();

            //
            //  Add back the aggregated restrictions
            //

            xNodeRst->AddChild( xContentRst.GetPointer() );

            xContentRst.Acquire();

            xNodeRst->AddChild( xNonContentRst.GetPointer() );

            xNonContentRst.Acquire();

            return xNodeRst.Acquire();
        }
    }
    else
    {
        //
        //  Add back the aggregated restrictions, if any
        //

        if ( xContentRst->Count() != 0 )
        {
            xNodeRst->AddChild( xContentRst.GetPointer() );

            xContentRst.Acquire();
        }

        if ( xNonContentRst->Count() != 0 )
        {
            xNodeRst->AddChild( xNonContentRst.GetPointer() );

            xNonContentRst.Acquire();
        }

        return xNodeRst.Acquire();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     FindQueryType
//
//  Synopsis:   Determine whether the query is a content query, a non-content query
//              or a not query.
//
//  Arguments:  [pRst]             -- input restriction
//              [fContentQuery]    -- set to TRUE if this is a content query
//              [fNonContentQuery] -- set to TRUE if this is a non-content query
//              [fNotQuery]        -- set to TRUE if contains NOT node
//
//  History:    30-May-95   SitaramR    Created
//              14-May-97   KyleP       Added OR NOT detection
//
//----------------------------------------------------------------------------

void FindQueryType( CRestriction * pRst,
                    BOOL &         fContentQuery,
                    BOOL &         fNonContentQuery,
                    BOOL &         fNotQuery )
{
    switch ( pRst->Type() )
    {
    case RTContent:
    case RTWord:
    case RTSynonym:
    case RTPhrase:
    case RTRange:
        fContentQuery = TRUE;
        break;

    case RTOr:
    case RTAnd:
    case RTProximity:
    case RTVector:
    {
        CNodeRestriction *pNodeRst = (CNodeRestriction *) pRst;
        for ( unsigned i=0; i<pNodeRst->Count(); i++ )
        {
            FindQueryType( pNodeRst->GetChild( i ),
                           fContentQuery,
                           fNonContentQuery,
                           fNotQuery );
        }
        break;
    }

    case RTInternalProp:
        fNonContentQuery = TRUE;
        break;

    case RTNot:
    {
        CNotRestriction *pNotRst = (CNotRestriction *) pRst;
        FindQueryType( pNotRst->GetChild(), fContentQuery, fNonContentQuery, fNotQuery );
        fNotQuery = TRUE;
        break;
    }

    case RTNone:
    {
        // null node from a noise word in a vector query
        fContentQuery = TRUE;
        break;
    }

    default:
        Win4Assert( !"FindQueryType: Unknown restriction type" );
        vqDebugOut(( DEB_ERROR, "FindQueryType: Unknown restriction type - %d\n", pRst->Type() ));

        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );

        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\qiterate.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       qiterate.cxx
//
//  Contents:   Iterator for OR query restriction
//
//  History:    30-May-95 SitaramR     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <split.hxx>
#include <parse.hxx>
#include <qiterate.hxx>
#include <ciintf.h>
#include <frmutils.hxx>

#include "normal.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::CQueryRstIterator
//
//  Synopsis:   CQueryRstIterator constructor
//
//  Arguments:  [pDocStore]       --  Doc Store over which this query will run
//              [xRst]            --  Query restriction
//              [timeLimt]        --  Execution time limit
//              [fCIRequiredGlobal]  --  True if a content index is required
//                                       for resolving this query
//              [fNoTimeout]         --  TRUE if the query shouldn't timeout
//                                       if the query expands into a lot of
//                                       nodes or the expansion takes too
//                                       long.
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

CQueryRstIterator::CQueryRstIterator(
    ICiCDocStore *pDocStore,
    XRestriction& xRst,
    CTimeLimit& timeLimit,
    BOOL& fCIRequiredGlobal ,
    BOOL fNoTimeout,
    BOOL fValidateCat )
        : _timeLimit( timeLimit ),
          _fResolvingFirstComponent( TRUE ),
          _fValidateCat( fValidateCat )
{
    //
    // Display query
    //

#if CIDBG == 1
    vqDebugOut(( DEB_ITRACE, "CQueryRstIterator: New query:\n" ));
    if ( !xRst.IsNull() )
        Display( xRst.GetPointer(), 0, DEB_ITRACE );
#endif // CIDBG == 1

    if ( !xRst.IsNull() )
    {
        if ( _fValidateCat )
        {
            //
            // Get content index
            //
            ICiManager *pCiManager = 0;
            SCODE sc = pDocStore->GetContentIndex( &pCiManager );
            if ( FAILED( sc ) )
            {
                Win4Assert( !"Need to support GetContentIndex interface" );

                THROW( CException( sc ) );
            }
            _xCiManager.Set( pCiManager );
        }

        ULONG cMaxRstNodes = 0;
        if ( !fNoTimeout )
        {
            //
            // Get max restriction nodes from registry when timeout is specified.
            // Otherwise 0 is used, because CRestrictionNormalizer ignores max
            // restriction nodes when there is no timeout.
            //
            ICiAdminParams *pAdminParams = 0;
            SCODE sc = _xCiManager->GetAdminParams( &pAdminParams );
            if ( FAILED( sc ) )
            {
                Win4Assert( !"Need to support admin params interface" );

                THROW( CException( sc ) );
            }

            XInterface<ICiAdminParams> xAdminParams( pAdminParams );     // GetAdminParams has done an AddRef
            CCiFrameworkParams frameworkParams( pAdminParams );          // CCiFrameworkParams also does an AddRef

            cMaxRstNodes = frameworkParams.GetMaxRestrictionNodes();
        }

        //
        // Normalize and parse the query
        //

        CRestrictionNormalizer norm( fNoTimeout, cMaxRstNodes );

        _xRst.Set( norm.Normalize( xRst.Acquire() ) );

        BOOL fContentQuery = FALSE, fNonContentQuery = FALSE, fContentOrNot = FALSE;
        FindQueryType( _xRst.GetPointer(), fContentQuery, fNonContentQuery, fContentOrNot );

        vqDebugOut(( DEB_ITRACE,
                     "Query type -- content: %s, non-content: %s\n",
                     fContentQuery ? "TRUE" : "FALSE",
                     fNonContentQuery ? "TRUE" : "FALSE" ));

                     Win4Assert( fContentQuery || fNonContentQuery );

        if ( _xRst->Type() == RTOr )
        {
            //
            // The OR restriction may need to be processed as a single component if:
            //    a) the entire restriction is made up of content nodes
            //    b) the entire restriction is made up of non-content nodes
            //

            if ( fContentQuery && fNonContentQuery )
                _fSingleComponent = FALSE;
            else
                _fSingleComponent = TRUE;
        }
        else
        {
            //
            // There is just one component, eg an AND node
            //

            _fSingleComponent = TRUE;
        }

        fCIRequiredGlobal = fContentQuery;
    }
    else
    {
        //
        // Null query case
        //

        _fSingleComponent = TRUE;
        fCIRequiredGlobal = FALSE;
    }

    _iQueryComp = 1;
    if ( _fSingleComponent )
        _cQueryComp = 1;
    else
    {
        CNodeRestriction *pNodeRst = (CNodeRestriction *) _xRst.GetPointer();
        _cQueryComp = pNodeRst->Count();
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::GetFirstComponent
//
//  Synopsis:   Get the first component of the query
//
//  Arguments:  [xFullyIndexableRst]  --  part that is resolvable by content index
//              [xXpr]  --  part that is an expression
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

void  CQueryRstIterator::GetFirstComponent( XRestriction& xFullyIndexableRst,
                                            XXpr& xXpr )
{
    Win4Assert( xFullyIndexableRst.IsNull() );
    Win4Assert( xXpr.IsNull() );

    XRestriction xRst;
    if ( _fSingleComponent )
        xRst.Set( _xRst.Acquire() );
    else
    {
        Win4Assert( _xRst->Type() == RTOr );

        CNodeRestriction *pNodeRst = (CNodeRestriction *) _xRst.GetPointer();

        Win4Assert( pNodeRst->Count() > 0 );

        xRst.Set( pNodeRst->RemoveChild( 0 ) );
    }

    if ( !xRst.IsNull() )
        SeparateRst( xRst, xFullyIndexableRst, xXpr );
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::GetNextComponent
//
//  Synopsis:   Get the next component of the query
//
//  Arguments:  [xFullyIndexableRst]  --  part that is resolvable by content index
//              [xXpr]  --  part that is an expression
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

void  CQueryRstIterator::GetNextComponent( XRestriction& xFullyIndexableRst,
                                           XXpr& xXpr )
{
    Win4Assert( xFullyIndexableRst.IsNull() );
    Win4Assert( xXpr.IsNull() );

    Win4Assert( !_fSingleComponent );

    CNodeRestriction *pNodeRst = (CNodeRestriction *) _xRst.GetPointer();

    Win4Assert( pNodeRst->Count() > 0 );

    //
    // Remove next component of OR query for resolving
    //

    XRestriction xRst( pNodeRst->RemoveChild( 0 ) );
    SeparateRst( xRst, xFullyIndexableRst, xXpr );

    _iQueryComp++;

    _fResolvingFirstComponent = FALSE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::SeparateRst
//
//  Synopsis:   Separate restriction into indexable and non-indexable portions
//
//  Arguments:  [xRst]  --  restriction to separate
//              [xFullyIndexableRst]  --  part that is resolvable by content index
//              [xXpr]  --  part that is an expression
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

void CQueryRstIterator::SeparateRst( XRestriction& xRst,
                                     XRestriction& xFullyIndexableRst,
                                     XXpr& xXpr )
{
    //
    // Split the query into fully indexable and not-fully-indexable portions
    //

    Split( xRst, xFullyIndexableRst );

    if ( !xRst.IsNull() )
        xXpr.Set( Parse( xRst.GetPointer(), _timeLimit ) );

    //
    // Validate query. (ex: Content query requires content index)
    //
    if ( !Validate( xFullyIndexableRst.GetPointer() ) )
    {
        vqDebugOut(( DEB_ERROR, "Invalid query restriction\n" ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::AtEnd
//
//  Returns:    Are we at the end of OR query components ?
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

BOOL CQueryRstIterator::AtEnd()
{
    if ( _fSingleComponent )
        return TRUE;
    else
    {
        //
        // Are there any more components of OR query ?
        //

        CNodeRestriction *pNodeRst = (CNodeRestriction *) _xRst.GetPointer();

        return ( pNodeRst->Count() == 0 );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryRstIterator::Validate, private
//
//  Synopsis:   Fully validate query.
//
//  Arguments:  [pFullyIndexableRst]  --  indexable restriction to validate
//
//  History:    07-Nov-94   KyleP       Created.
//              20-Jan-95   DwightKr    Split from CQExecute
//              30-May-95   SitaramR    Moved to CQueryRstIterator
//
//----------------------------------------------------------------------------

inline BOOL CQueryRstIterator::Validate( CRestriction *pFullyIndexableRst )  const
{
    //
    // If no content index exists and there is a fully resolvable
    // component then this query is an error.
    //

    if ( pFullyIndexableRst && _fValidateCat )
    {
        Win4Assert ( !_xCiManager.IsNull() );

        void *pVoid;

        ICiFrameworkQuery * pIFwQuery = 0;
        ICiManager * pICiManager = _xCiManager.GetPointer();

        SCODE sc = pICiManager->QueryInterface( IID_ICiFrameworkQuery,
                                                (void **) &pIFwQuery );

        Win4Assert( S_OK == sc );
        sc = pIFwQuery->GetCCI( &pVoid );
        pIFwQuery->Release();

        if ( FAILED( sc ) )
        {
            Win4Assert( !"Need to support GetCCI method" );

            THROW( CException( sc ) );
        }

        if ( pVoid == 0 )
        {
            vqDebugOut(( DEB_ERROR, "Content restriction on drive w/o content index.\n" ));
            return( FALSE );
        }
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\gencur.cxx ===
//+------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991-1998.
//
// File:        gencur.cxx
//
// Contents:    Base cursor
//
// Classes:     CGenericCursor
//
// History:     19-Aug-91       KyleP   Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//DECLARE_INFOLEVEL(vq);

#include <gencur.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::CGenericCursor, public
//
//  Synopsis:   Extracts property and object tables from the catalog.
//
//  Arguments:  [xxpr]   -- Expression.
//              [am]     -- ACCESS_MASK for security checks
//              [fAbort] -- Set to true if we should abort
//
//  History:    21-Aug-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CGenericCursor::CGenericCursor( XXpr & xxpr,
                                ACCESS_MASK accessMask,
                                BOOL & fAbort )
        : _xxpr( xxpr ),
          _am( accessMask ),
          _widCurrent( widInvalid ),
          _fAbort( fAbort ),
          _widPrimedForPropRetrieval( widInvalid )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::~CGenericCursor, public
//
//  Synopsis:   Closes catalog tables associated with this instance.
//
//  History:    21-Aug-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CGenericCursor::~CGenericCursor()
{
    Quiesce();
}

//+-------------------------------------------------------------------------
//
//  Method:     CGenericCursor::Quiesce, public
//
//  Synopsis:   Close any open resources.
//
//  History:    3-May-1994  KyleP      Created
//
//--------------------------------------------------------------------------

void CGenericCursor::Quiesce()
{
    if ( _widPrimedForPropRetrieval != widInvalid )
    {
        SCODE sc = _xPropRetriever->EndPropertyRetrieval();
        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR, "Quiesce, EndPropertyRetrieval failed: 0x%x", sc ));

            THROW ( CException( sc ) );
        }

        _widPrimedForPropRetrieval = widInvalid;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::SetFirstWorkId, protected
//
//  Effects:    Positions on object matching query (if one is available).
//              Generally used as callback during construction of derived
//              classes
//
//  Arguments:  [wid] -- Workid on which derived class is positioned.
//
//  History:    21-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CGenericCursor::SetFirstWorkId( WORKID wid )
{
    _widCurrent = wid;

    Quiesce();

    if ( _widCurrent != widInvalid &&
         ( ( !_xxpr.IsNull() &&
             !_xxpr->IsMatch( *this ) ) ||
           !IsAccessPermitted( _widCurrent ) ) )
    {
        NextWorkId();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::SetWorkId, public
//
//  Arguments:  [wid] - WorkID of the current object is set.
//
//  Returns:    The WorkID of the object under the cursor. widInvalid if
//              no object is under the cursor.
//
//  Notes:      This is used by the large table to assign a unique workid for
//              down-level stores based upon a hash of the file path name.
//
//  History:    20 Jun 94   AlanW       Created
//
//----------------------------------------------------------------------------

WORKID CGenericCursor::SetWorkId(WORKID wid)
{
    _widCurrent = wid;
    return( _widCurrent );
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::NextWorkId, public
//
//  Synopsis:   Advances the cursor to the next workid matching current
//              selection criteria.
//
//  Returns:    The Work ID under the cursor after the advance.
//
//  History:    31-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CGenericCursor::NextWorkId()
{
    //
    // If we have the _pPropRec for the current wid, it is important to
    // release that before calling PathToWorkId(). O/W, there can be a
    // a deadlock between this thread waiting for the CiCat lock and another
    // thread waiting for the write lock on this record.
    //
    Quiesce();

    for( _widCurrent = NextObject();
         _widCurrent != widInvalid;
         _widCurrent = NextObject() )
    {
        if ( _fAbort )
        {
            _widCurrent = widInvalid;
            break;
        }

        if ( ( _xxpr.IsNull() || _xxpr->IsMatch( *this ) ) &&
             ( IsAccessPermitted( _widCurrent ) ) )
        {
            break;
        }

        Quiesce();
    }

    return( _widCurrent );
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::RatioFinished, public
//
//  Synopsis:   Returns query progress estimate
//
//  History:    21-Mar-95   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CGenericCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    if ( _widCurrent == widInvalid )
    {
        num = 100;
        denom = 100;
    }
    else
    {
        num = 50;
        denom = 100;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::GetPropertyValue, public
//
//  Synopsis:   Retrieves the value of a property for the current object.
//
//  Arguments:  [pid]      -- Property to fetch.
//              [pbData]   -- Place to return the value
//              [pcb]      -- On input, the maximum number of bytes to
//                            write at pbData.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  Returns:    GVRSuccess if successful, else a variety of error codes.
//
//  History:    25-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

inline BYTE * PastHeader( PROPVARIANT * ppv )
{
    return( (BYTE *)ppv + sizeof( PROPVARIANT ) );
}

GetValueResult CGenericCursor::GetPropertyValue( PROPID pid,
                                                 PROPVARIANT * pbData,
                                                 ULONG * pcb )
{
    //
    // We may be looking for an object that no longer exists.
    //

    if ( widInvalid == WorkId() )
    {
        return( GVRNotAvailable );
    }

    unsigned cb = sizeof( PROPVARIANT );

    // pidSecurity and pidSecondaryStorage are used internally only 
    // and aren't queryable or retrievable.

    Win4Assert( pidSecurity != pid && pidSecondaryStorage != pid);

    switch ( pid )
    {
    case pidWorkId:
        pbData->vt = VT_I4;
        pbData->lVal = WorkId();
        break;

    case pidRank:
        pbData->vt = VT_I4;
        pbData->lVal = Rank();

        if ( !_xxpr.IsNull() )
        {
            pbData->lVal = min( pbData->lVal, (long)_xxpr->Rank( *this ) );
        }

        Win4Assert( pbData->lVal >= 0 );
        Win4Assert( pbData->lVal <= MAX_QUERY_RANK );
        break;

    case pidRankVector:
    {
        CCursor * pcur = GetCursor();

        if ( pcur )
        {
            pbData->vt = VT_I4 | VT_VECTOR;

            if ( cb <= *pcb )
            {
                Win4Assert( sizeof(LONG) == sizeof(pbData->cal.pElems[0] ) );
                LONG * pTemp = (LONG *)PastHeader(pbData);

                pbData->cal.pElems = pTemp;
                pbData->cal.cElems =
                    pcur->GetRankVector( pTemp, (*pcb - cb) / sizeof( ULONG ) );
                cb += pbData->cal.cElems * sizeof( ULONG );
            }
        }
        else
        {
            vqDebugOut(( DEB_WARN,
                         "Non-content vector not yet implemented.\n" ));
            pbData->vt = VT_EMPTY;
        }
        break;
    }

    case pidHitCount:
    {
        //
        // Hit count will only be non-zero if both _xxpr and _pcur
        // support hit count.
        //

        pbData->vt = VT_I4;
        pbData->lVal = 0;
        if ( !_xxpr.IsNull() )
        {
            pbData->lVal += _xxpr->HitCount( *this );
        }

        pbData->lVal =
            ( pbData->lVal == 0 ) ? HitCount() :
            min( pbData->lVal, (long)HitCount() );
        break;
    }

    case pidSelf:
        return GVRNotAvailable;
        break;

    default:
    {
        PrimeWidForPropRetrieval( _widCurrent );

        SCODE sc = _xPropRetriever->RetrieveValueByPid( pid, pbData, pcb );
        if ( SUCCEEDED( sc ) )
        {
#if CIDBG == 1
        CStorageVariant var( *pbData );

        vqDebugOut(( DEB_PROPTIME, "Fetched value (pid = 0x%x): ", pid ));
        var.DisplayVariant( DEB_PROPTIME | DEB_NOCOMPNAME, 0 );
        vqDebugOut(( DEB_PROPTIME | DEB_NOCOMPNAME, "\n" ));
#endif

            return GVRSuccess;
        }

        if ( sc == CI_E_BUFFERTOOSMALL )
        {
            vqDebugOut(( DEB_PROPTIME, "Not enough space to fetch value (pid = 0x%x)\n", pid ));
            return GVRNotEnoughSpace;
        }
        else if ( CI_E_SHARING_VIOLATION == sc )
        {
            vqDebugOut(( DEB_PROPTIME, "Sharing violation fetching value (pid = 0x%x)\n", pid ));
            return GVRSharingViolation;
        }
        else
        {
            vqDebugOut(( DEB_PROPTIME, "Failed to fetch value (pid = 0x%x)\n", pid ));
            return GVRNotAvailable;
        }
     }

     }  // case

     if ( cb <= *pcb )
     {
        *pcb = cb;
#if CIDBG == 1
        CStorageVariant var( *pbData );

        vqDebugOut(( DEB_PROPTIME, "Fetched value (pid = 0x%x): ", pid ));
        var.DisplayVariant( DEB_PROPTIME | DEB_NOCOMPNAME, 0 );
        vqDebugOut(( DEB_PROPTIME | DEB_NOCOMPNAME, "\n" ));
#endif // CIDBG == 1
        return( GVRSuccess );
    }
    else
    {
        *pcb = cb;
        vqDebugOut(( DEB_PROPTIME, "Failed to fetch value (pid = 0x%x)\n", pid ));
        return( GVRNotEnoughSpace );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::IsAccessPermitted, public
//
//  Synopsis:   Perform access check.  Return TRUE if access is allowed.
//
//  Arguments:  [wid]  -- work ID of file whose access is to be checked.
//
//  History:    14 Feb 96    AlanW    Created
//
//----------------------------------------------------------------------------

BOOL CGenericCursor::IsAccessPermitted( WORKID wid )
{
    PrimeWidForPropRetrieval( wid );

    BOOL fGranted;
    SCODE sc = _xPropRetriever->CheckSecurity( _am, &fGranted );
    if ( FAILED( sc ) )
    {
         vqDebugOut(( DEB_ERROR, "CGenericCursor::IsAccessPermitted - CheckSecurity failed: 0x%x", sc ));
         THROW( CException( sc ) );
    }

    return fGranted;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::IsMatch, protected
//
//  Effects:    Performs full match check on specified wid.  Used by
//              derived classes that pre-process the result set.
//
//  Arguments:  [wid] -- Workid on which derived class is positioned.
//
//  Returns:    TRUE if object matches all tests.
//
//  History:    29-Mar-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CGenericCursor::IsMatch( WORKID wid )
{
    Quiesce();

    _widCurrent = wid;

    return ( _widCurrent != widInvalid &&
             ( _xxpr.IsNull() || _xxpr->IsMatch( *this ) ) &&
             IsAccessPermitted( _widCurrent ) );
}



//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::InScope
//
//  Effects:    Performs scope check on specified wid.
//
//  Arguments:  [wid] -- Workid on which derived class is positioned.
//
//  Returns:    TRUE if object is within scope
//
//  History:    12-Dec-96   SitaramR       Created
//
//----------------------------------------------------------------------------

BOOL CGenericCursor::InScope( WORKID wid )
{
    PrimeWidForPropRetrieval( wid );

    BOOL fInScope;
    SCODE sc = _xPropRetriever->IsInScope( &fInScope );
    if ( FAILED( sc ) )
    {
         vqDebugOut(( DEB_ERROR, "CGenericCursor::IsInScope failed: 0x%x", sc ));
         THROW( CException( sc ) );
    }

    return fInScope;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::PrimeWidForPropRetrieval
//
//  Effects:    Sets up current wid for retrieving properties
//
//  Arguments:  [wid] -- Workid to prime
//
//  History:    12-Dec-96   SitaramR       Created
//
//----------------------------------------------------------------------------

void CGenericCursor::PrimeWidForPropRetrieval( WORKID wid )
{
    Win4Assert( wid != widInvalid );

    //
    // Inlined fast path
    //
    if ( _widPrimedForPropRetrieval == wid )
    {
        //
        // Already primed for this wid
        //

        return;
    }

    //
    // Out of lined slow path
    //
    SetupWidForPropRetrieval( wid );
}



//+---------------------------------------------------------------------------
//
//  Member:     CGenericCursor::SetupWidForPropRetrieval
//
//  Effects:    Sets up current wid for retrieving properties
//
//  Arguments:  [wid] -- Workid to prime
//
//  History:    12-Dec-96   SitaramR       Created
//
//----------------------------------------------------------------------------

void CGenericCursor::SetupWidForPropRetrieval( WORKID wid )
{
    Win4Assert( wid != widInvalid );

    // I'm not aware of a normal case where this hits, but it's not too
    // expensive to check for this.

    if ( wid == _widPrimedForPropRetrieval )
        return;

    SCODE sc;
    if ( _widPrimedForPropRetrieval != widInvalid )
    {
        sc = _xPropRetriever->EndPropertyRetrieval();
        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR,
                         "CGenericCursor::PrimeWidForPropRetrieval - EndPropRetrieval failed: 0x%x",
                         sc ));
            THROW( CException( sc ) );
        }

        _widPrimedForPropRetrieval = widInvalid;
    }

    sc = _xPropRetriever->BeginPropertyRetrieval( wid );
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR,
                     "CGenericCursor::PrimeWidForPropRetrieval - BeginPropRetrieval failed: 0x%x",
                     sc ));
        THROW( CException( sc ) );
    }

    _widPrimedForPropRetrieval = wid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\execute.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        Execute.cxx
//
// Contents:    Query execution class
//
// Classes:     CQAsyncExecute
//
// History:     09-Sep-91       KyleP       Created
//              20-Jan-95       DwightKr    Split CQueryBase from CQExecute
//              11 Mar 95       AlanW       Renamed CQExecute to CQAsyncExecute
//                                          and CQueryBase to CQueryExecute
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tblsink.hxx>
#include <ffenum.hxx>
#include <split.hxx>
#include <strategy.hxx>
#include <sizeser.hxx>
#include <widiter.hxx>
#include <qiterate.hxx>
#include <execute.hxx>
#include <parse.hxx>
#include <normal.hxx>
#include <cci.hxx>
#include <qoptimiz.hxx>
#include <gencur.hxx>
#include <imprsnat.hxx>
#include <frmutils.hxx>

#include "singlcur.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::CQAsyncExecute, public
//
//  Synopsis:   Start a query
//
//  Arguments:  [xqopt] -- Query optimizer
//              [obt]   -- Output table
//
//  History:    20-Apr-92   KyleP       Initialize _pxpFullyResolvable.
//              09-Sep-91   KyleP       Created.
//              07-Nov-94   KyleP       General cleanup
//
//----------------------------------------------------------------------------

CQAsyncExecute::CQAsyncExecute( XQueryOptimizer & xqopt,
                                BOOL fEnableNotification,
                                CTableSink & obt,
                                ICiCDocStore *pDocStore )
        :
          PWorkItem(eSigCQAsyncExecute),
          _fAbort( FALSE ),
          _fFirstPass( TRUE ),
          _fPendingEnum( TRUE ),
          _fOnWorkQueue( TRUE ),
          _fRunning( FALSE ),
          _fMidEnum( FALSE ),
          _fEnableNotification( fEnableNotification ),
          _pChangeQueue( 0 ),
          _xqopt( xqopt ),
          _pcurResolve( 0 ),
          _pcurNotify( 0 ),
          _obt( obt ),
          _pTimeLimit( &(_xqopt->GetTimeLimit()) ),
          _pNotifyThread( 0 )
{
    //
    // Get ci manager interface
    //

    SCODE sc = pDocStore->GetContentIndex( _xCiManager.GetPPointer() );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );
        THROW( CException( sc ) );
    }

    // If the content index is corrupt, fail the query now

    XInterface<ICiFrameworkQuery> xFwQuery;
    sc = _xCiManager->QueryInterface( IID_ICiFrameworkQuery,
                                      xFwQuery.GetQIPointer() );
    Win4Assert( S_OK == sc );

    CCI * pcci;
    sc = xFwQuery->GetCCI( (void **) &pcci );
    Win4Assert( S_OK == sc );
    if ( 0 != pcci )
    {
        if ( pcci->IsCiCorrupt() )
            THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    //
    // Update Query in-progress
    //

    _obt.SetStatus( STAT_BUSY | QUERY_RELIABILITY_STATUS( _obt.Status() ) );

    //
    // Set MaxRow limit in TableSink
    //

    vqDebugOut(( DEB_ITRACE, "CQAsyncExecute::CQAsynExecute: MaxResults is %d\n", _xqopt->MaxResults() ));
    _obt.SetMaxRows( _xqopt->MaxResults() );


    //
    // Set FirstRow in TableSink
    //

    vqDebugOut(( DEB_ITRACE, "CQAsyncExecute::CQAsynExecute: FirstRows is %d\n", _xqopt->FirstRows() ));
    _obt.SetFirstRows( _xqopt->FirstRows() );

    //
    // Queue request to worker
    //

    TheWorkQueue.Add( this );
} //CQAsyncExecute

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::DoIt, private
//
//  Synopsis:   Main driver loop for CQAsyncExecute.
//
//  Arguments:  [pThread] -- Thread managing user-mode APC
//
//  History:    10-Sep-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CQAsyncExecute::DoIt( CWorkThread * pThread )
{
    XChangeQueue Changes;

    _pTimeLimit->SetBaselineTime( );

    {
        CLock lock( _mtx );

        //
        // We may have been woken up to die.
        //

        if ( _fAbort || QUERY_FILL_STATUS(_obt.Status()) == STAT_ERROR )
        {
            return;
        }

        if ( _fFirstPass && !_fMidEnum )
        {
            //
            // Notification must be enabled in the thread that will process
            // the APC requests.  Thus it must be in a worker thread, at
            // least for downlevel.
            //
            if ( _fEnableNotification )
            {
                EnableNotification();
                TheWorkQueue.AddRef( pThread );
                _pNotifyThread = pThread;
            }
        }

        Win4Assert( !_fRunning );
        Win4Assert( _fOnWorkQueue );

        _fRunning = TRUE;
        _fOnWorkQueue = FALSE;

        if ( !_fMidEnum )
        {
            //
            // Get current change queue.
            //

            Changes.Set( _pChangeQueue );
            _pChangeQueue = 0;

            //
            // If we're rescanning the directory, then begin rescan
            // and clear the query queue.
            //

            if ( _fPendingEnum )
            {
                _fPendingEnum = FALSE;
                CChangeQueue * pChanges = Changes.Acquire();
                delete pChanges;
            }
        }
    }

    _obt.SetStatus( STAT_BUSY |
                    QUERY_RELIABILITY_STATUS( _obt.Status() ) );


    //
    // Process request
    //

    SCODE status = STATUS_SUCCESS;

    TRY
    {
        //
        // Full iteration (go figure)
        //

        if ( Changes.IsNull() )
        {
            vqDebugOut(( DEB_ITRACE, "CQAsyncExecute: Resolving...\n" ));

            //
            // Resolve the query!
            //

            Resolve( );
        }
        else
        {
            vqDebugOut(( DEB_ITRACE, "CQAsyncExecute: Processing change queue...\n" ));
            Win4Assert( _fFirstPass == FALSE );
            Win4Assert( _fMidEnum == FALSE );

            Update( Changes.GetPointer() );
        }

        vqDebugOut(( DEB_ITRACE, "CQAsyncExecute: Done.\n" ));

        if ( _fFirstPass && !_fMidEnum )
        {
            _obt.SetStatus( STAT_DONE |
                            QUERY_RELIABILITY_STATUS( _obt.Status() ) );
            _obt.Quiesce ();
        }

    }
    CATCH(CException, e)
    {
        vqDebugOut(( DEB_ERROR,
                     "Catastrophic error during query execution: %lx\n",
                     e.GetErrorCode() ));

        ICiFrameworkQuery * pIFwQuery = 0;

        SCODE sc = _xCiManager->QueryInterface( IID_ICiFrameworkQuery,
                                                (void **) &pIFwQuery );

        Win4Assert( S_OK == sc );
        if ( pIFwQuery )
        {
            pIFwQuery->ProcessError( e.GetErrorCode() );
            pIFwQuery->Release();
        }

        _obt.SetStatus( STAT_ERROR |
                          QUERY_RELIABILITY_STATUS( _obt.Status() ),
                        e.GetErrorCode() );
        _obt.Quiesce ();

        status = e.GetErrorCode();
    }
    END_CATCH;

    {
        CLock lock( _mtx );

        if ( !_fMidEnum )
            _fFirstPass = FALSE;

        _fRunning = FALSE;

        if ( !_fAbort && !_pTimeLimit->IsTimedOut() && (_fPendingEnum || _fMidEnum || 0 != _pChangeQueue ) )
        {
            _fOnWorkQueue = TRUE;
            TheWorkQueue.Add( this );
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::~CQAsyncExecute(), public
//
//  Effects:    Destroys Objects and Folder tables
//
//  History:    09-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CQAsyncExecute::~CQAsyncExecute()
{
    //
    // After this call completes, no new callbacks should come in from table.
    //

    _obt.QueryAbort();

    {
        CLock lock( _mtx );

        //
        // Once the abort flag is set, no *new* activity will be started for
        // this query.  Current activity will stop ASAP. The abort flag has been
        // passed to the child/inherited cursor by reference.
        //

        Win4Assert( _fAbort == FALSE );
        _fAbort = TRUE;

        vqDebugOut(( DEB_ITRACE, "QUERY ABORT: GO\n" ));

        if ( _fOnWorkQueue )
        {
            TheWorkQueue.Remove( this );
            _fOnWorkQueue = FALSE;
        }

        //
        // Downlevel notification is *always* done under lock.  Ofs *cannot*
        // be done under lock.
        //
        if ( _fEnableNotification )
            DisableNotification();
    }

    //
    // Wait for all threads touching query to release...
    //

    _refcount.Wait();

    _obt.SetStatus( STAT_DONE |
                    QUERY_RELIABILITY_STATUS( _obt.Status() ) );

    // Make sure the client knows we quiesced.  It may not in some error
    // paths.

    _obt.Quiesce();

    //
    // Clean up.
    //

    delete _pcurResolve;
    delete _pcurNotify;
    delete _pChangeQueue;

    if ( 0 != _pNotifyThread )
        TheWorkQueue.Release( _pNotifyThread );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::Resolve, private
//
//  Synopsis:   Resolve a query.
//
//  Effects:    Retrieves matching objects from the catalog and stores them
//              in the CTableSink for the query.
//
//  Arguments:  -none-
//
//  Requires:   [_xXpr] and [_xFullyResolvableRst] have been set correctly.
//
//  History:    13-Sep-91   KyleP       Created.
//
//  Notes:      Query resolution is output driven :- As long as there is
//              additional information to retrieve, the resolver will
//              continue putting it into the CTableSink.
//
//----------------------------------------------------------------------------

void CQAsyncExecute::Resolve( )
{
    vqDebugOut((DEB_ITRACE, "CQAsyncExecute::Resolve\n"));

    ICiAdminParams *pAdminParams = 0;
    SCODE sc = _xCiManager->GetAdminParams( &pAdminParams );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support admin params interface" );

        THROW( CException( E_FAIL ) );
    }

    XInterface<ICiAdminParams> xAdminParams( pAdminParams );     // GetAdminParams has done an AddRef
    CCiFrameworkParams frameworkParams( pAdminParams );          // CCiFrameworkParams also does an AddRef

    ULONGLONG ullTimesSliceInit = frameworkParams.GetMaxQueryTimeslice() * 10000;

    ULONGLONG ullTimeslice = ullTimesSliceInit;

#   if CIDBG == 1
        BOOL fProgressDone = FALSE;
#   endif // CIDBG
    TRY
    {
        ULONG cMatched = 0;

        for ( WORKID wid = _fMidEnum ? GetNextWorkId() : GetFirstWorkId();
              wid != widInvalid;
              wid = GetNextWorkId() )
        {
            vqDebugOut(( DEB_ITRACE, "CLargeTable::Resolve: wid is 0x%x\n", wid ));

            if ( _obt.FirstRows() > 0 && _obt.RowCount() >= _obt.FirstRows()  )
            {
                wid = widInvalid;
                break;
            }

            Win4Assert( !fProgressDone && "sent ulNum == ulDenom to table, but not done!" );

            //
            // Keep going?
            //

            if ( _fAbort )
                break;

            //
            //  Translate path to a unique ID for downlevel stores
            //

            if ( !_xqopt->IsWorkidUnique() )
            {

                WORKID widNew = _obt.PathToWorkID( *_pcurResolve, CTableSink::eNewRow  );
                Win4Assert( widNew != 0 && widNew != widInvalid);
                _pcurResolve->SetWorkId( widNew );

                vqDebugOut(( DEB_RESULTS, "Convert wid %d to \"table wid\" %d\n", wid, widNew ));
            }

            //
            // Retrieve the data
            //

            vqDebugOut(( DEB_RESULTS, "Matched %d\n", wid ));

            CTableSink::ERowType eRowType;
            if ( _fFirstPass )
            {
                if ( _fFirstComponent )
                    eRowType = CTableSink::eNewRow;
                else
                    eRowType = CTableSink::eMaybeSeenRow;
            }
            else
                eRowType = CTableSink::eNotificationRow;

            BOOL fProgressNeeded = _obt.PutRow( *_pcurResolve, eRowType );

            if (fProgressNeeded)
            {
                //
                // In an OR query with content index and enumeration components,
                // the quota for RatioFinished is divided equally among all components
                // of the OR query
                //

                unsigned iQueryComp, cQueryComp;
                _xqopt->GetCurrentComponentIndex( iQueryComp, cQueryComp );
                Win4Assert( iQueryComp >= 1 && iQueryComp <= cQueryComp );

                ULONG denom, num;
                _pcurResolve->RatioFinished ( denom, num );

                //
                // New ratio = (iQueryComp-1)/cQueryComp + 1/cQueryComp * (num/denom)
                //
                Win4Assert( num <= denom );
                Win4Assert( denom <= ULONG_MAX / cQueryComp );     // check for overflow

                num += ( iQueryComp - 1 ) * denom;
                denom *= cQueryComp;

                Win4Assert( num <= denom );

                _obt.ProgressDone ( denom, num );
#if CIDBG == 1
                fProgressDone = (denom == num);
#endif // CIDBG
            }

            if ( _obt.NoMoreData() )
            {
                vqDebugOut(( DEB_IWARN,
                             "Query row limit exceeded for %08x\n",
                             this ));

                wid = widInvalid;
                StopNotifications();
                break;
            }

            //
            // Break out for time-slicing?
            //
            BOOL fBreakForTimeSlice = CheckExecutionTime( &ullTimeslice );

            if ( fBreakForTimeSlice )
            {
                if ( _pTimeLimit->IsTimedOut() )
                {
                    wid = widInvalid;
                    StopNotifications();
                    break;
                }
                else if ( 0 == TheWorkQueue.Count() )
                    ullTimeslice = ullTimesSliceInit;
                else
                    break;
            }
        }
            
        CheckExecutionTime();

        if ( wid == widInvalid || _fAbort )
        {
            _fMidEnum = FALSE;
            FreeCursor();
        }
        else
        {
            _fMidEnum = TRUE;
            _pcurResolve->Quiesce();

            _pcurResolve->SwapOutWorker();

        }
    }
    CATCH(CException, e)
    {
        _fMidEnum = FALSE;
        FreeCursor();

        if ( e.GetErrorCode() == QUERY_E_TIMEDOUT )
        {
            //
            // Execution time limit has been exceeded, not a catastrophic error
            //
            _obt.SetStatus( STAT_DONE |
                            QUERY_RELIABILITY_STATUS( _obt.Status() ) |
                            STAT_TIME_LIMIT_EXCEEDED );
            StopNotifications();

            //
            // Update local copy of execution time
            //
            _pTimeLimit->SetExecutionTime( 0 );
        }
        else
            RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::Update
//
//  Effects:    Updates wids specified by caller.
//
//  Arguments:  [widiter]    -- workid iterator for modified files
//
//  History:    07-Mar-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CQAsyncExecute::Update( PWorkIdIter & widiter )
{
    AddRef();
    XInterface<CQAsyncExecute> xAsyncExecute( this );

    TRY
    {
        CSingletonCursor * pcurBucket = _xqopt->QuerySingletonCursor( _fAbort );
        XPtr<CSingletonCursor> xCurBucket( pcurBucket );

        //
        // Iterate through changes
        //

        for ( WORKID wid = widiter.WorkId();
              wid != widInvalid && !_fAbort;
              wid = widiter.NextWorkId() )
        {
            //
            // We don't need to hold the lock while examining this variable
            // because if we miss in one loop, we will see it the next time.
            // Once the _fAbort flag is set, it will not be reset.
            //
            if ( _fAbort )
                break;

            Win4Assert( _xqopt->IsWorkidUnique() );

            pcurBucket->SetCurrentWorkId( wid );

            if ( pcurBucket->WorkId() != widInvalid )
            {
                vqDebugOut(( DEB_RESULTS,
                             "QUERY REFRESH (BUCKET): Adding/Modifying wid 0x%x\n",
                             wid ));

                pcurBucket->SetRank( widiter.Rank() );
                pcurBucket->SetHitCount( widiter.HitCount() );

                _obt.PutRow( *pcurBucket, CTableSink::eBucketRow );
            }
        }
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR,
                     "Exception 0x%x caught in Update.\n",
                     e.GetErrorCode() ));
        _obt.SetStatus( STAT_ERROR |
                          QUERY_RELIABILITY_STATUS( _obt.Status() ),
                        e.GetErrorCode() );
    }
    END_CATCH
} //Update

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::Update
//
//  Effects:
//
//  History:    09-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------
void CQAsyncExecute::Update( CChangeQueue * pChanges )
{
#if 0
    Win4Assert( _fEnableNotification );
    Win4Assert( !_fMidEnum );

    if ( 0 == _pcurNotify && !_xqopt->RequiresCI() )
        _pcurNotify = _xqopt->QuerySingletonCursor( _fAbort );

    TRY
    {
        //
        // Iterate through changes
        //

        for ( CDirNotifyEntry const * pNotify = pChanges->First();
              0 != pNotify;
              pNotify = pChanges->Next() )
        {
            vqDebugOut(( DEB_RESULTS, "UPDATE: 0x%x\n", pNotify ));

            if (CheckExecutionTime( ))
            {
                StopNotifications();
                break;
            }

            switch ( pNotify->Change() )
            {
            case FILE_ACTION_MODIFIED:
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
            case FILE_ACTION_ADDED_STREAM:
            case FILE_ACTION_REMOVED_STREAM:
            case FILE_ACTION_MODIFIED_STREAM:

                if ( _xqopt->RequiresCI() )
                {
                    vqDebugOut(( DEB_RESULTS, "QUERY REFRESH: Content query out-of-date.\n" ));
                    _obt.SetStatus( _obt.Status() | STAT_REFRESH_INCOMPLETE );
                }
                else
                {
                    Win4Assert( 0 != _pcurNotify );
                //    #if 1
                        _pcurNotify->SetFullPath( pChanges->CurrentPath(),
                                                  pChanges->CurrentPathLength(),
                                                  pNotify->Path(),
                                                  pNotify->PathSize() / sizeof(WCHAR) );
                //    #else
                        if ( pChanges->CurrentVirtual() )
                            _pcurNotify->SetFullPath( pChanges->CurrentPath(),
                                                      pChanges->CurrentPathLength(),
                                                      pNotify->Path(),
                                                      pNotify->PathSize() / sizeof(WCHAR) );
                        else
                            _pcurNotify->SetRelativePath( pNotify->Path(), pNotify->PathSize() / sizeof(WCHAR) );
                //    #endif

                    if ( _pcurNotify->WorkId() != widInvalid )
                    {
                        if ( !_xqopt->IsWorkidUnique() )
                        {
                            //
                            //  Translate path to a unique ID for downlevel stores
                            //

                            WORKID widNew = _obt.PathToWorkID( *_pcurNotify, CTableSink::eNotificationRow );
                            Win4Assert( widNew != 0 && widNew != widInvalid);
                            _pcurNotify->SetWorkId( widNew );

                        }
                        vqDebugOut(( DEB_RESULTS,
                                     "QUERY REFRESH: Adding/Modifying %.*ws\n",
                                     pNotify->PathSize()/sizeof(WCHAR), pNotify->Path() ));
                        _obt.PutRow( *_pcurNotify, CTableSink::eNotificationRow );
                        break;
                    }
                    else 
                    {
                        RemoveRow( pNotify, pChanges );
                    }
                }
                break;

            case FILE_ACTION_REMOVED:
            case FILE_ACTION_RENAMED_OLD_NAME:
                RemoveRow( pNotify, pChanges );
                break;

            default:
                Win4Assert( !"Unknown modification type" );
                break;
            }
        }
    }
    CATCH( CException, e )
    {
        if ( 0 != _pcurNotify )
        {
            _pcurNotify->Quiesce();

            _pcurNotify->SwapOutWorker();
        }
        RETHROW();
    }
    END_CATCH

    if ( 0 != _pcurNotify )
    {
        _pcurNotify->Quiesce();

        _pcurNotify->SwapOutWorker();
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::EnableNotification, public
//
//  Synopsis:   Enable notification for query
//
//  History:    06-Oct-94   KyleP       Created.
//
//  Notes:      This method must be called in the context of the thread that
//              will process APC requests (will sleep regularly in an
//              alertable state).
//
//----------------------------------------------------------------------------

void CQAsyncExecute::EnableNotification()
{
} //EnableNotification

void CQAsyncExecute::_SetupNotify(
    CScopeRestriction const & scope )
{
} //_SetupNotify

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::DisableNotification, private
//
//  Synopsis:   Tells notifications objects to shut down
//
//  History:    26-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CQAsyncExecute::DisableNotification()
{
} //DisableNotification

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncNotify::CQAsyncNotify, public
//
//  Synopsis:   Starts notification
//
//  History:    26-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

CQAsyncNotify::CQAsyncNotify( CQAsyncExecute & Execute,
                              WCHAR const * pwcScope,
                              unsigned cwcScope,
                              BOOL fDeep,
                              BOOL fVirtual )
        : CDummyNotify(),
          _Execute( Execute ),
          _fVirtual( fVirtual )
{
    _Execute.AddRef();

    EnableNotification();
}

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncNotify::~CQAsyncNotify, public
//
//  Synopsis:   For management of refcount
//
//  History:    26-Feb-96 KyleP     Created
//
//--------------------------------------------------------------------------

CQAsyncNotify::~CQAsyncNotify()
{
    _Execute.Release();
}

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncNotify::DoIt, private
//
//  Synopsis:   Called from notification APC
//
//  History:    26-Feb-96 KyleP     Moved from CQAsyncExecute
//
//--------------------------------------------------------------------------

void CQAsyncNotify::DoIt()
{
    TRY
    {
        CLock lock( _Execute._mtx );

        if ( _Execute._fAbort )
        {
            vqDebugOut(( DEB_ITRACE, "QUERY REFRESH: ABORT (IGNORE) 0x%x\n", this ));
        }
        else
        {
            if ( BufferOverflow() )
            {
                vqDebugOut(( DEB_ITRACE, "QUERY REFRESH: REQUERY 0x%x\n", this ));

                _Execute._fPendingEnum = TRUE;
            }
            else
            {
                vqDebugOut(( DEB_ITRACE, "QUERY REFRESH: CHANGES 0x%x\n", this ));

                if ( _Execute._pChangeQueue == 0 )
                    _Execute._pChangeQueue = new CChangeQueue;

                CDirNotifyEntry * pTemp =
                    (CDirNotifyEntry *)new BYTE [ BufLength() ];
                RtlCopyMemory( pTemp, GetBuf(), BufLength() );

                _Execute._pChangeQueue->Add( pTemp, GetScope(), _fVirtual );
            }

            if ( !_Execute._fOnWorkQueue && !_Execute._fRunning )
            {
                _Execute._fOnWorkQueue = TRUE;
                TheWorkQueue.Add( &_Execute );
            }

            StartNotification();
        }
    }
    CATCH(CException, e)
    {
        _Execute._obt.SetStatus( STAT_ERROR |
                                 QUERY_RELIABILITY_STATUS( _Execute._obt.Status() ),
                                 e.GetErrorCode() );
    }
    END_CATCH;
} //DoIt

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::StopNotifications, private
//
//  Synopsis:   Conditionally turns off notifications
//
//  History:    16 Apr 96   AlanW     Created
//
//--------------------------------------------------------------------------

inline void CQAsyncExecute::StopNotifications()
{
    if ( _fEnableNotification )
    {
        CLock lock( _mtx );

        //
        // Downlevel notification is *always* done under lock.  Ofs *cannot*
        // be done under lock.
        //
        DisableNotification();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::GetFirstWorkId
//
//  Synopsis:   Returns the first workid that matches the query
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

inline WORKID CQAsyncExecute::GetFirstWorkId()
{
    _fFirstComponent = TRUE;

    ULONG Status = 0;

    Win4Assert( 0 == _pcurResolve );

    _pcurResolve = _xqopt->QueryNextCursor( Status, _fAbort );

    Win4Assert( QUERY_FILL_STATUS( Status ) == 0);
    _obt.SetStatus( _obt.Status() | Status );

    WORKID wid;

    if ( 0 == _pcurResolve )
        wid = widInvalid;
    else
    {
        wid = _pcurResolve->WorkId();

        if ( wid == widInvalid )
            wid = GetWidFromNextComponent();
    }

    return wid;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::GetNextWorkId
//
//  Synopsis:   Returns the next workid that matches the query
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

inline WORKID CQAsyncExecute::GetNextWorkId()
{
    WORKID wid = _pcurResolve->NextWorkId();

    if ( wid == widInvalid )
        wid = GetWidFromNextComponent();

    return wid;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::GetWidFromNextComponent
//
//  Synopsis:   Returns matching wid from next component of OR query
//
//  History:    30-May-95    SitaramR     Created
//
//--------------------------------------------------------------------------

WORKID CQAsyncExecute::GetWidFromNextComponent()
{
    _fFirstComponent = FALSE;
    ULONG Status = 0;

    //
    // Clean up previous cursor
    //

    FreeCursor();

    _pcurResolve = _xqopt->QueryNextCursor( Status, _fAbort );

    WORKID wid;

    if ( 0 != _pcurResolve )
    {
        wid = _pcurResolve->WorkId();
    }
    else
        wid = widInvalid;

    Win4Assert( QUERY_FILL_STATUS( Status ) == 0);
    _obt.SetStatus( _obt.Status() | Status );

    return wid;
}

//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::FreeCursor, private
//
//  Synopsis:   Deletes current cursor.
//
//  History:    26-Jun-95    KyleP        Created
//
//  Notes:      Delete cannot be done under lock, because the act of
//              deleting a cursor may cause acquires of FCB(s), and
//              those same FCB(s) may be owned by a thread trying to
//              notify via CQAsyncExecute::Notify...
//
//--------------------------------------------------------------------------

void CQAsyncExecute::FreeCursor()
{
    CGenericCursor * pCur;

    {
        CLock lock( _mtx );

        pCur = _pcurResolve;
        _pcurResolve = 0;
    }

    delete pCur;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::CheckExecutionTime, private
//
//  Synopsis:   Check for CPU time limit exceeded
//
//  Arguments:  [pullTimeSlice] - pointer to time slice remaining (optional)
//
//  Returns:    TRUE if execution time limit exceeded, or if the query's
//              time for a time slice is exceeded.
//
//  Notes:      The CPU time spent executing a query since the last
//              check is computed and compared with the remaining time
//              in the CPU time limit.  If the time limit is exceeded,
//              the query is aborted and a status bit is set indicating
//              that.  Otherwise, the remaining time and the time
//              snapshot are updated.
//
//  History:    08 Apr 96    AlanW        Created
//
//--------------------------------------------------------------------------

BOOL CQAsyncExecute::CheckExecutionTime(
    ULONGLONG * pullTimeSlice )
{
    BOOL fTimeOut = _pTimeLimit->CheckExecutionTime( pullTimeSlice );
    if (fTimeOut && _pTimeLimit->IsTimedOut())
    {
        vqDebugOut(( DEB_IWARN,
                     "Execution time limit exceeded for %08x\n",
                     this ));

        _obt.SetStatus( STAT_DONE |
                        QUERY_RELIABILITY_STATUS( _obt.Status() ) |
                        STAT_TIME_LIMIT_EXCEEDED );
    }

    return fTimeOut;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQAsyncExecute::FetchDeferredValue
//
//  Synopsis:   Checks if read access is permitted
//
//  Arguments:  [wid] - Workid
//              [ps]  -- Property to be fetched
//              [var] -- Property returned here
//
//  History:    12-Jan-97    SitaramR        Created
//
//--------------------------------------------------------------------------

BOOL CQAsyncExecute::FetchDeferredValue( WORKID wid,
                                         CFullPropSpec const & ps,
                                         PROPVARIANT & var )
{
    return _xqopt->FetchDeferredValue( wid, ps, var );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\sortrank.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       sortrank.cxx
//
//  Contents:   Sort-by-rank optimization cursor
//
//  History:    21-Feb-96      SitaramR     Created
//
//  Notes:      The sort-by-rank cursor first fills up cMaxResults or less
//              entries in the _aSortedRank array and sorts them using
//              quicksort. Additional results are stored in a heap, whose
//              root is at the end of the array, i.e. at cMaxResults - 1.
//              The heap grows at the expense of the quicksorted array, so that
//              at any time, the entire can be partitioned exactly into the
//              quicksorted array part, and the heap part. After all results
//              have been processed, the heap portion is sorted using quicksort
//              because we need to retrieve wids from the heap in  descending
//              rank order and the heap stores wids in ascending rank order.
//              At this point we have two sorted arrays and the two arrays
//              are logically merged while iterating through NextObject().
//
//              ----------------------         ----------------------
//              |Max Rank            |         |Max Rank 1          |
//              |                    |         |                    |
//              |Quicksorted array   |         |Quicksorted array 1 |
//              |                    |         |                    |
//              |                    |         |                    |
//              |Min Rank            |         |Min Rank 1          |
//              |--------------------|   ==>   |--------------------|
//      ^       |                    |         |Max Rank 2          |
//      |       |                    |         |                    |
//      |       |Heap array          |         |Quicksorted array 2 |
//  Heap grows  |                    |         |                    |
//  this way    |                    |         |                    |
//              |Min Rank            |         |Min Rank 2          |
//              ----------------------         ----------------------
//
//
//              In addition to the quicksort and heapsort, insertion sort
//              is used as a subroutine in the impelementation of quicksort.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qoptimiz.hxx>

#include "sortrank.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::CSortedByRankCursor
//
//  Synopsis:   Constructor
//
//  Arguments:  [pQuerySession]   -- Query session
//              [xxpr]   -- Expression (for CGenericCursor).
//              [am]     -- ACCESS_MASK for security checks
//              [fAbort] -- Set to true if we should abort
//              [xCursor]  -- CI cursor.
//              [cMaxResults]  -- Limit on # query results,
//              [cFirstRows]  -- Process only up to cFirstRows of wids, implies no heap
//              [fDeferTrimming] -- TRUE if query trimming force-deferred
//                                  til ::NextObject
//
//  History:    21-Feb-1996      SitaramR     Created
//              28-Jun-2000      KitmanH      Added cFirstRows
//
//--------------------------------------------------------------------------

CSortedByRankCursor::CSortedByRankCursor( ICiCQuerySession *pQuerySession,
                                          XXpr & xxpr,
                                          ACCESS_MASK accessMask,
                                          BOOL & fAbort,
                                          XCursor & xCursor,
                                          ULONG cMaxResults,
                                          ULONG cFirstRows,
                                          BOOL fDeferTrimming,
                                          CTimeLimit & timeLimit )
      : CCiCursor( pQuerySession,
                   xxpr,
                   accessMask,
                   fAbort ),
        _cMaxResults(cMaxResults),
        _cFirstRows(cFirstRows),
        _fDeferTrimming(fDeferTrimming),
        _cActualResults(0),
        _iCurEntry(0),
        _iStartHeap(cFirstRows > 0 ? cFirstRows : cMaxResults),
        _aSortedRank(0),
        _timeLimit( timeLimit )
{
    Win4Assert( ( cMaxResults > 0 && cMaxResults <= MAX_HITS_FOR_FAST_SORT_BY_RANK_OPT )|| 
                ( cFirstRows > 0 && cFirstRows <= MAX_HITS_FOR_FAST_SORT_BY_RANK_OPT ) );

    vqDebugOut(( DEB_ITRACE, "Using sorted-by-rank optimization\n" ));
    
    if ( cFirstRows > 0 )
    {
        _cMaxResults = cMaxResults = cFirstRows;
    }

    _aSortedRank = new CSortedRankEntry[cMaxResults+1];
    _xSortedRank.Set( cMaxResults+1, _aSortedRank );

    unsigned iCurEntry = 0;

    for ( WORKID wid = xCursor->WorkId();
          wid != widInvalid;
          wid = xCursor->NextWorkId() )
    {
        if ( fAbort )
        {
            //
            // Query has been aborted
            //
            SetWorkId( widInvalid );
            return;
        }

        _aSortedRank[iCurEntry]._wid = wid;
        Win4Assert( xCursor->Rank() >= 0 && xCursor->Rank() <= MAX_QUERY_RANK );
        _aSortedRank[iCurEntry]._rank = xCursor->Rank();
        _aSortedRank[iCurEntry]._hitCount = xCursor->HitCount();

        if ( !_fDeferTrimming )
        {
            if ( InScope( _aSortedRank[_iCurEntry]._wid ) &&
                 IsMatch( _aSortedRank[_iCurEntry]._wid ) )
            {
                iCurEntry++;
            }
        }
        else
            iCurEntry++;
        
        if ( iCurEntry == _cMaxResults )
        {
            //
            // We'll be overflowing _aSortedRank, so switch to mode where
            // we keep the top _cMaxResults ranks only
            //
            break;
                
        }

        // Check every now and then if the timelimit is exceeded

        if ( ( 0 == ( iCurEntry % 50 ) ) &&
             ( _timeLimit.CheckExecutionTime() ) )
        {
            ciDebugOut(( DEB_WARN, "exceeded sbr timelimit 1\n" ));
            _timeLimit.DisableCheck();
            wid = widInvalid;
            break;
        }
    }

    _cActualResults = iCurEntry;

    _iCurEntry = iCurEntry;

    if ( iCurEntry > 1 )
        QuickSort( 0, iCurEntry - 1 );

    if ( ( wid != widInvalid ) && ( 0 == cFirstRows ) )
    {
        //
        // We have to do some extra work up-front.  Full set of results didn't fit
        // in buffer, so we have to go back through and throw out mismatches.
        // The mismatches are thrown out by marking them with a rank that is
        // guaranteed to be lower than any legitimate rank.  This will push them
        // to the bottom of the sort, where they will get naturally pushed out.
        //

        Win4Assert( iCurEntry == _cMaxResults );

        //
        // Go thru remaining wids
        //

        for ( ULONG iLoop = 1, wid = xCursor->NextWorkId();
              wid != widInvalid;
              wid = xCursor->NextWorkId(), iLoop++ )
        {
            if ( fAbort )
            {
                //
                // Query has been aborted
                //
                SetWorkId( widInvalid );
                return;
            }

            // Check every now and then if the timelimit is exceeded

            if ( ( 0 == ( iLoop % 50 ) ) &&
                 ( _timeLimit.CheckExecutionTime() ) )
            {
                ciDebugOut(( DEB_WARN, "exceeded sbr timelimit 2\n" ));
                _timeLimit.DisableCheck();
                break;
            }

            //
            // Get the minimum rank from the quick sorted rank array and the heap
            //
            ULONG iMinEntry = GetMinRankEntry();

            Win4Assert( iMinEntry < _cActualResults );

            LONG lRank = xCursor->Rank();

            Win4Assert( lRank >= 0 && lRank <= MAX_QUERY_RANK );

            if ( _aSortedRank[iMinEntry]._rank < lRank )
            {
                //
                // Use scratch entry so Rank() and HitCount() will work
                // from IsMatch().
                //

                _iCurEntry = _cMaxResults;
                _aSortedRank[_cMaxResults]._wid = wid;
                _aSortedRank[_cMaxResults]._rank = lRank;
                _aSortedRank[_cMaxResults]._hitCount = xCursor->HitCount();

                if ( _fDeferTrimming || ( InScope( wid ) && IsMatch( wid ) ) )
                {
                    //
                    // Overwrite new rank, wid and hitcount over old entry
                    //
                    _aSortedRank[iMinEntry]._wid = _aSortedRank[_cMaxResults]._wid;
                    _aSortedRank[iMinEntry]._rank = _aSortedRank[_cMaxResults]._rank;
                    _aSortedRank[iMinEntry]._hitCount = _aSortedRank[_cMaxResults]._hitCount;

                    //
                    // Insert the entry into the appropriate place in the heap
                    //
                    InsertEntry( iMinEntry );
                }
            }
        }
    }


    //
    // Is there a non-null heap ?
    //
    if ( _iStartHeap < _cActualResults )
    {
        //
        // The heap has the minimum rank entry at the root of heap. We need to
        // remove entries from heap in max rank order. Hence sort the heap
        // in descending rank order
        //
        QuickSort( _iStartHeap, _cMaxResults - 1 );
    }

    //
    // Set up the start and end positions of the two sorted lists
    //
    SetSortedListsBoundaries();

    vqDebugOut(( DEB_ITRACE,
                 "Sorted-by-rank list boundaries %d->%d and %d->%d\n",
                 _iStartList1,
                 _iEndList1,
                 _iStartList2,
                 _iEndList2 ));

    //
    // Position ourselves on the first entry
    //
    _iCurEntry = GetMaxRankEntry();
    if ( _iCurEntry < _cActualResults )
    {
        if ( InScope( _aSortedRank[_iCurEntry]._wid ) )
            SetFirstWorkId( _aSortedRank[_iCurEntry]._wid );
        else
            SetFirstWorkId( NextObject() );
    }
    else
        SetFirstWorkId( widInvalid );

    //
    // Don't need the content index cursor anymore
    //
    delete xCursor.Acquire();

    END_CONSTRUCTION( CSortedByRankCursor );
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::~CSortedByRankCursor
//
//  Synopsis:   Destructor
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

CSortedByRankCursor::~CSortedByRankCursor()
{
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::RatioFinished
//
//  Synopsis:   Returns query progress estimate
//
//  Arguments:  [denom] -- Denominator returned here.
//              [num]   -- Numerator returned here.
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

void  CSortedByRankCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    if ( _iCurEntry < _cActualResults )
    {
        num = _iCurEntry;
        denom = _cActualResults;
    }
    else
    {
        //
        // We are done
        //
        num = denom = 1;
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::NextObject
//
//  Synopsis:   Return next work id
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

WORKID CSortedByRankCursor::NextObject()
{
    _iCurEntry = GetNextMaxRankEntry();

    WORKID wid;

    if ( _iCurEntry < _cActualResults )
    {
        if ( _fDeferTrimming || _iStartHeap == _cMaxResults )
        {
            //
            // If we never needed a heap, then we need to skip out-of-scope
            // entries here.
            //

            for( ; _iCurEntry < _cActualResults; _iCurEntry = GetNextMaxRankEntry() )
            {
                if ( InScope( _aSortedRank[_iCurEntry]._wid ) )
                    break;
            }

            if ( _iCurEntry < _cActualResults )
                wid= _aSortedRank[_iCurEntry]._wid;
            else
                wid = widInvalid;
        }
        else
        {
            //
            // Scope testing was already done to weed entries
            // out of the first quick-and-dirty filling of
            // the buffer.
            //

            if ( -1 == _aSortedRank[_iCurEntry]._rank )
                wid = widInvalid;
            else
                wid = _aSortedRank[_iCurEntry]._wid;
        }
    }
    else
        wid = widInvalid;

    if ( _timeLimit.CheckDisabled() &&
         ( ( _iCurEntry >= ( _cActualResults - 1 ) ) ||
           ( _iCurEntry >= ( _cActualResults - 2 ) ) ) )
        _timeLimit.EnableCheck();

    return wid;
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::HitCount
//
//  Synopsis:   Return hitcount of current work id
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

ULONG CSortedByRankCursor::HitCount()
{
    //
    // Unfortunately, we can't assert this because it is legitimately
    // untrue when ::Rank is called from the constructor.
    //

    // Win4Assert( _iCurEntry < _cActualResults );

    return _aSortedRank[_iCurEntry]._hitCount;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::Rank
//
//  Synopsis:   Return rank of current work id
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

LONG CSortedByRankCursor::Rank()
{
    //
    // Unfortunately, we can't assert this because it is legitimately
    // untrue when ::Rank is called from the constructor.
    //

    // Win4Assert( _iCurEntry < _cActualResults );

    return _aSortedRank[_iCurEntry]._rank;
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::GetMinRankEntry
//
//  Synopsis:   Return the index of the entry with the minimum rank
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

ULONG CSortedByRankCursor::GetMinRankEntry()
{
    if ( _iStartHeap == 0 )
    {
        //
        // The heap spans the entire array and so return the mininum entry in
        // heap, i.e. the root
        //
        return _cMaxResults - 1;
    }

    //
    // Min rank entry in quicksorted array is just before the start of heap
    //
    ULONG iMinQuickSortEntry = _iStartHeap - 1;
    long minQuickSortRank = _aSortedRank[iMinQuickSortEntry]._rank;

    if ( _iStartHeap < _cMaxResults )
    {
        long minHeapRank = _aSortedRank[_cMaxResults-1]._rank;

        if ( minHeapRank <= minQuickSortRank)
            return _cMaxResults - 1;
        else
            return iMinQuickSortEntry;
    }
    else
    {
        //
        // Null heap
        //
        return iMinQuickSortEntry;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::GetMaxRankEntry
//
//  Synopsis:   Return the index of the entry with the maximum rank
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

ULONG CSortedByRankCursor::GetMaxRankEntry()
{
    if ( _iStartList1 <= _iEndList1 )
    {
        long rankList1 = _aSortedRank[_iStartList1]._rank;
        if ( _iStartList2 <= _iEndList2 )
        {
            long rankList2 = _aSortedRank[_iStartList2]._rank;
            if ( rankList1 > rankList2 )
                return _iStartList1;
            else
                return _iStartList2;
        }
        else
            return _iStartList1;
    }
    else
    {
        if ( _iStartList2 <= _iEndList2 )
            return _iStartList2;
        else
        {
            //
            // No more entries
            //
            return _cActualResults;
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::GetNextMaxRankEntry
//
//  Synopsis:   Return the index of the entry with the next maximum rank
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

ULONG CSortedByRankCursor::GetNextMaxRankEntry()
{
    if ( _iStartList1 > _iEndList1 && _iStartList2 > _iEndList2 )
    {
        //
        // No more entries
        //
        return _cActualResults;
    }

    Win4Assert( _iCurEntry == _iStartList1 || _iCurEntry == _iStartList2 );

    if ( _iStartList1 == _iCurEntry && _iStartList1 <= _iEndList1 )
    {
        _iStartList1++;
    }
    else
    {
        Win4Assert( _iCurEntry == _iStartList2 );
        Win4Assert( _iStartList2 <= _iEndList2 );
        _iStartList2++;
    }

    return GetMaxRankEntry();
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::SetSortedListsBoundaries
//
//  Synopsis:   Set up the start and end points of the two sorted lists
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::SetSortedListsBoundaries()
{
    if ( _iCurEntry == 0 )
    {
        //
        // No wids in scope
        //
        _iStartList1 = _cMaxResults + 1; // _iEndList1 + 1
        _iEndList1 = _cMaxResults;
        _iStartList2 = _cMaxResults + 1;
        _iEndList2 = _cMaxResults;
    }
    else if ( _iStartHeap == _cMaxResults )
    {
        //
        // No heap partition
        //
        _iStartList1 = 0;
        _iEndList1 = _cActualResults - 1;
        _iStartList2 = _cMaxResults + 1; // _iEndList2 + 1
        _iEndList2 = _cMaxResults;
    }
    else if ( _iStartHeap == 0 )
    {
        //
        // Heap is the entire partition
        //
        _iStartList1 = _cMaxResults + 1;
        _iEndList1 = _cMaxResults;
        _iStartList2 = 0;
        _iEndList2 = _cMaxResults - 1;
    }
    else
    {
        //
        // Two sorted partitions
        //
        _iStartList1 = 0;
        _iEndList1 = _iStartHeap - 1;
        _iStartList2 = _iStartHeap;
        _iEndList2 = _cMaxResults - 1;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::InsertEntry
//
//  Synopsis:   Inserts an entry that is either part of the quicksorted array
//              or of the heap into the heap
//
//  Arguments:  [iEntry]  --  Index of entry to insert
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::InsertEntry( ULONG iEntry )
{
    //
    // Ensure that the entry to be inserted is either the root of heap, or the
    // last entry of the quicksorted array
    //
    Win4Assert( iEntry == _cMaxResults - 1 || iEntry == _iStartHeap - 1 );

    if ( iEntry == _cMaxResults - 1 && _iStartHeap < _cMaxResults )
    {
        //
        // New entry at root of heap
        //
        Heapify( iEntry );
    }
    else
    {
        //
        // Transfer entry from quicksorted array to heap
        //
        HeapInsert( iEntry );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::HeapSize
//
//  Synopsis:   Returns size of heap
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::HeapSize()
{
    return _cMaxResults - _iStartHeap;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::LeftChild
//
//  Synopsis:   Returns left child of entry
//
//  Arguments:  [iEntry]  --  Entry specified
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::LeftChild( ULONG iEntry )
{
    Win4Assert( iEntry < _cMaxResults );

    ULONG iHeapEntry = GetHeapIndex( iEntry );
    return GetArrayIndex( iHeapEntry * 2 );
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::RightChild
//
//  Synopsis:   Returns right child of entry
//
//  Arguments:  [iEntry]  --  Entry specified
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::RightChild( ULONG iEntry )
{
    Win4Assert( iEntry < _cMaxResults );

    ULONG iHeapEntry = GetHeapIndex( iEntry );
    return GetArrayIndex( iHeapEntry * 2 + 1 );
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::Parent
//
//  Synopsis:   Returns parent of entry
//
//  Arguments:  [iEntry]  --  Entry specified
//
//  History:    21-Feb-96      SitaramR     Created
//
//+-------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::Parent( ULONG iEntry )
{
    Win4Assert( iEntry < _cMaxResults );

    if ( iEntry == _cMaxResults - 1 )
        return iEntry;

    ULONG iHeapEntry = GetHeapIndex( iEntry );
    return GetArrayIndex( iHeapEntry / 2 );
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::GetHeapIndex
//
//  Synopsis:   Returns 1-based position in heap, i.e, the root which is at
//              _cMaxResults-1 is mapped to 1
//
//  Arguments:  [iEntry]  --  Entry specified
//
//  History:    21-Feb-96      SitaramR     Created
//
//+-------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::GetHeapIndex( ULONG iEntry )
{
    Win4Assert( iEntry < _cMaxResults );

    return _cMaxResults - iEntry;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::GetArrayIndex
//
//  Synopsis:   Returns position in array, so the root's array position
//              is _cMaxResults-1
//
//  Arguments:  [iEntry]  --  Entry specified
//
//  History:    21-Feb-96      SitaramR     Created
//
//+-------------------------------------------------------------------------

inline ULONG CSortedByRankCursor::GetArrayIndex( ULONG iEntry )
{
    Win4Assert( iEntry >= 1 );

    if  ( iEntry <= _cMaxResults )
        return _cMaxResults - iEntry;
    else return _cMaxResults;             // Index is outside the heap range
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::Heapify
//
//  Synopsis:   Moves entry to proper place in heap
//
//  Arguments:  [iEntry]  --  Index of entry to insert
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::Heapify( ULONG iEntry )
{
    ULONG iLeft = LeftChild( iEntry );
    ULONG iRight = RightChild( iEntry );

    //
    // Compare entry with left child
    //
    ULONG iMinEntry;
    if ( iLeft >= _iStartHeap              // low range check
         && iLeft < _cMaxResults           // high range check
         && _aSortedRank[iLeft]._rank < _aSortedRank[iEntry]._rank )
    {
        iMinEntry = iLeft;
    }
    else
        iMinEntry = iEntry;

    //
    // Compare min entry with right child
    //
    if ( iRight >= _iStartHeap
         && iRight < _cMaxResults
         && _aSortedRank[iRight]._rank < _aSortedRank[iMinEntry]._rank )
    {
        iMinEntry = iRight;
    }

    if ( iMinEntry != iEntry )
    {
        //
        // Exchange iMinEntry and iEntry
        //
        CSortedRankEntry entryTemp = _aSortedRank[iMinEntry];
        _aSortedRank[iMinEntry] = _aSortedRank[iEntry];
        _aSortedRank[iEntry] = entryTemp;

        Heapify( iMinEntry );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::HeapInsert
//
//  Synopsis:   Adds entry to heap
//
//  Arguments:  [iEntry]  --  Index of entry to insert
//
//  History:    21-Feb-96      SitaramR     Created
//              16-Nov-00      EugeneSa     Fixed bug with entryTemp._rank (was _aSortedRank[iEntry]._rank )
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::HeapInsert( ULONG iEntry )
{
    //
    // Ensure that last entry of quicksorted array is being added
    //
    Win4Assert( _iStartHeap > 0 && iEntry == _iStartHeap - 1 );

    //
    // Grow heap
    //
    _iStartHeap--;

    CSortedRankEntry entryTemp = _aSortedRank[iEntry];

    ULONG iParent = Parent( iEntry );

    while ( iEntry < _cMaxResults-1 && entryTemp._rank < _aSortedRank[iParent]._rank )
    {
        _aSortedRank[iEntry] = _aSortedRank[iParent];
        iEntry = iParent;
        iParent = Parent( iEntry );
    }

    //
    // This is the position in heap where the entry should be inserted
    //
    _aSortedRank[iEntry] = entryTemp;
}

#pragma optimize( "t", on )

//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::QuickSort
//
//  Synopsis:   Sort entries in descending rank order
//
//  Arguments:  [iLeft]  --  Start entry
//              [iRight] --  End entry
//
//  History:    21-Feb-96      SitaramR     Created
//
//  Notes:      Algorithm copied from CEntryBuffer::Sort and then modified
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::QuickSort( ULONG iLeft, ULONG iRight )
{
    Win4Assert( iLeft <= iRight );

    if ( iLeft == iRight )
        return;

    //
    // Use quicksort above threshold size
    //
    if ( iRight-iLeft+1 > MIN_PARTITION_SIZE )
    {
        CDynStack<CSortPartition> _stkPartition;  // Store for unsorted partitions

        ULONG iLeftPart = iLeft;                  // Left endpoint of current partition
        ULONG iRightPart = iRight;                // Right endpoint of current partition

        //
        // Outer loop for sorting partitions
        //
        while ( TRUE )
        {
            Win4Assert( iRightPart >= iLeftPart + MIN_PARTITION_SIZE );

            //
            // Compute the median of left, right and (left+right)/2
            //
            ULONG iMedian = Median( iLeftPart, iRightPart, (iLeftPart + iRightPart) / 2 );
            Win4Assert( iMedian >= iLeftPart && iMedian <= iRightPart );

            //
            // Exchange median with left
            //
            CSortedRankEntry entryPivot = _aSortedRank[iMedian];

            if ( iMedian != iLeftPart )
            {
                _aSortedRank[iMedian] = _aSortedRank[iLeftPart];
                _aSortedRank[iLeftPart] = entryPivot;
            }

            //
            // Point i at pivot, j beyond the end of partition and sort in-between
            //
            ULONG i = iLeftPart;
            ULONG j = iRightPart + 1;

            //
            // Partition chosen, now burn the candle from both ends
            //
            while ( TRUE )
            {
                //
                // Increment i until key <= pivot
                //
                do
                    i++;
                while ( _aSortedRank[i].Compare(entryPivot) < 0 );

                //
                // Decrement j until key >= pivot
                //
                do
                    j--;
                while ( _aSortedRank[j].Compare(entryPivot) > 0 );

                if ( j<= i )
                    break;

                //
                // Swap the elements that are out of order
                //
                CSortedRankEntry entryTemp = _aSortedRank[i];
                _aSortedRank[i] = _aSortedRank[j];
                _aSortedRank[j] = entryTemp;

            }   // Continue burning

            //
            // Finally, exchange the pivot
            //
            _aSortedRank[iLeftPart] = _aSortedRank[j];
            _aSortedRank[j] = entryPivot;

            //
            // Entries to the left of j are larger than the entries to
            // the right of j
            //

            ULONG rSize = iRightPart - j;
            ULONG lSize = j - iLeftPart;

            //
            // Push the larger one on the stack for later sorting.
            // If any of the partitions are smaller than the minimum,
            // skip it and proceed directly with the other one. If
            // both are too small, pop the stack.
            //

            if ( rSize > MIN_PARTITION_SIZE )     // Right partition big enough
            {
                if ( lSize >= rSize )             // Left partition is even bigger
                {
                    //
                    // Sort left later
                    //
                    CSortPartition *pSortPart = new CSortPartition( iLeftPart, j-1 );
                    _stkPartition.Push( pSortPart );

                    //
                    // Sort right now
                    //
                    iLeftPart = j + 1;
                }
                else if ( lSize > MIN_PARTITION_SIZE )
                {
                    //
                    // Sort right later
                    //
                    CSortPartition *pSortPart = new CSortPartition( j+1, iRightPart );
                    _stkPartition.Push( pSortPart );

                    //
                    // Sort left now
                    //
                    iRightPart = j - 1;
                }
                else // Left too small
                {
                    //
                    // Sort the right partition now
                    //
                    iLeftPart = j + 1;
                }
            }
            else if ( lSize > MIN_PARTITION_SIZE )
            {
                //
                // Right partition is too small, but left is big enough. So,
                // sort left partition now.
                //
                iRightPart = j - 1;
            }
            else
            {
                //
                // Both partitions are too small
                //
                if ( _stkPartition.Count() == 0 )
                    break;   // we are done
                else
                {
                    //
                    // Sort the next partition
                    //
                    CSortPartition *pSortPart = _stkPartition.Pop();

                    iLeftPart = pSortPart->GetLeft();
                    iRightPart = pSortPart->GetRight();

                    delete pSortPart;
                }
            }
        }
    }

    //
    // Sort all small partitions that were not sorted
    //
    InsertionSort( iLeft, iRight );

    //
    // Check that the array has been sorted
    //
#if DBG==1
    for ( ULONG i=iLeft; i<iRight; i++ )
        Win4Assert( _aSortedRank[i]._rank >= _aSortedRank[i+1]._rank );
#endif
}



//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::Median
//
//  Synopsis:   Find the median rank of three entries
//
//  Arguments:  [i1]  --  Entry 1
//              [i2]  --  Entry 2
//              [i3]  --  Entry 3
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

ULONG CSortedByRankCursor::Median( ULONG i1, ULONG i2, ULONG i3 )
{
    if ( _aSortedRank[i1].Compare(_aSortedRank[i2]) < 0 )
    {
        if ( _aSortedRank[i2].Compare(_aSortedRank[i3]) < 0 )
            return i2;
        else
        {
            if ( _aSortedRank[i1].Compare(_aSortedRank[i3]) < 0 )
                return i3;
            else
                return i1;
        }
    }
    else
    {
        if ( _aSortedRank[i1].Compare(_aSortedRank[i3]) < 0 )
            return i1;
        else
        {
            if ( _aSortedRank[i2].Compare(_aSortedRank[i3]) < 0 )
                return i3;
            else
                return i2;
        }
    }

    // unreachable code
    return 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSortedByRankCursor::InsertionSort
//
//  Synopsis:   Sort entries in descending rank order
//
//  Arguments:  [iLeft]  --  Start entry
//              [iRight] --  End entry
//
//  History:    21-Feb-96      SitaramR     Created
//
//--------------------------------------------------------------------------

void CSortedByRankCursor::InsertionSort( ULONG iLeft, ULONG iRight )
{
    Win4Assert( iLeft <= iRight );

    if ( iLeft == iRight )
        return;

    for ( ULONG j=iLeft+1; j<=iRight; j++ )
    {
        CSortedRankEntry entryKey = _aSortedRank[j];

        //
        // Go backwards from j-1 shifting up entries with rank less than entryKey
        //
        Win4Assert( iRight <= INT_MAX );      // Check conversion from ULONG -> INT

        for ( INT i=j-1;
              i >= (INT) iLeft && (_aSortedRank[i].Compare(entryKey) > 0 );
              i-- )
        {
            _aSortedRank[i+1] = _aSortedRank[i];
        }

        //
        // Found entry greater then entryKey or hit the beginning (i == iLeft-1).
        // Insert key in hole.
        //
        if ( i+1 != (INT) j )
            _aSortedRank[i+1] = entryKey;
    }
}

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\qoptimiz.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000.
//
// File:        QOptimiz.cxx
//
// Contents:    Query optimizer.  Chooses indexes and table implementations.
//
// Classes:     CQueryOptimizer
//
// History:     21-Jun-95       KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qoptimiz.hxx>
#include <cci.hxx>
#include <pidremap.hxx>
#include <gencur.hxx>

#include "cicur.hxx"
#include "enumcur.hxx"
#include "singlcur.hxx"
#include "sortrank.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::CQueryOptimizer, public
//
//  Synopsis:   Analyze query.
//
//  Arguments:  [xQuerySession]  -- Query session object
//              [pDocStore]      -- Catalog.
//              [rst]            -- Restriction.
//              [cols]           -- Output columns
//              [psort]          -- Sort order.  May be null.
//              [pidmap]         -- PID remapper
//              [rProps]         -- rowset properties, giving params of query
//
//  History:    21-Jun-95    KyleP        Created
//              19-Oct-98    sundara      Used IS_ENUM_ALLOWED for _fUseCI
//
//--------------------------------------------------------------------------

CQueryOptimizer::CQueryOptimizer( XInterface<ICiCQuerySession>& xQuerySession,
                                  ICiCDocStore *pDocStore,
                                  XRestriction & rst,
                                  CColumnSet const & cols,
                                  CSortSet const * psort,
                                  CPidRemapper const & pidmap,
                                  CRowsetProperties const & rProps,
                                  DWORD dwQueryStatus )
        :
          _fNullCatalog( FALSE ),
          //
          // A most useful piece of debugging...
          //

#         if CIDBG == 1
              _xrstOriginal( rst.IsNull() ? 0 : rst->Clone() ),
#         endif
          _xQuerySession( xQuerySession.Acquire() ),
          _fDeferTrimming( (rProps.GetPropertyFlags() & eDeferTrimming) != 0 ),
          _cMaxResults( rProps.GetMaxResults() ),
          _cFirstRows( rProps.GetFirstRows() ),
          // Note: max override time is set below in the constructor
          _TimeLimit( rProps.GetCommandTimeout(), 0 ),
          _qRstIterator( pDocStore, rst, _TimeLimit, _fCIRequiredGlobal,
                         rProps.GetCommandTimeout() == ULONG_MAX ),
          _fAtEnd( FALSE ),
          _fNeedSingleton( FALSE ),
          _pidmap( pidmap ),
          _fSortedByRankOpt( FALSE ),
          _fRankVectorProp( pidmap.ContainsRankVectorProp() ),
          _dwQueryStatus( dwQueryStatus )
{
    _am = (_pidmap.AnyStatProps() ? FILE_READ_ATTRIBUTES : 0) |
          (_pidmap.ContainsContentProp() ? FILE_READ_DATA : 0);
    Win4Assert( _am != 0 );

    //
    // Get content index and admin params
    //
    SCODE sc = pDocStore->GetContentIndex( _xCiManager.GetPPointer() );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );
        THROW( CException( sc ) );
    }

    XInterface<ICiCAdviseStatus> xAdviseStatus;
    sc = pDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                    xAdviseStatus.GetQIPointer() );
    if ( S_OK != sc )
        THROW( CException(sc) );

    xAdviseStatus->IncrementPerfCounterValue( CI_PERF_TOTAL_QUERIES );

    // Do we have a null catalog?
    _xCiManager->IsNullCatalog(&_fNullCatalog);

    XInterface<ICiAdminParams> xAdminParams;
    sc = _xCiManager->GetAdminParams( xAdminParams.GetPPointer() );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support admin params interface" );
        THROW( CException( sc ) );
    }

    _frameworkParams.Set( xAdminParams.GetPointer() );    // Set does an AddRef

    _fUseCI= !(_frameworkParams.IsEnumAllowed());

    vqDebugOut(( DEB_ITRACE, "_fUseCI from frameworkparams: %x\n", _fUseCI ));

    if ( !_fUseCI )
        _fUseCI = ( 0 != (rProps.GetPropertyFlags() & eUseCI) );

    vqDebugOut(( DEB_ITRACE, "_fUseCI final: %x\n", _fUseCI ));

    _TimeLimit.SetMaxOverrideTime( _frameworkParams.GetMaxQueryExecutionTime() );

    //
    // Choose an indexing strategy for the first component.  If there are
    // additional components, then we know this is a multi-part cursor.
    //

    _qRstIterator.GetFirstComponent( _xFullyResolvableRst, _xXpr );

    ChooseIndexStrategy( psort, cols );

    if ( _qRstIterator.AtEnd() )
        _fMulti = FALSE;
    else
    {
        _fMulti = TRUE;
        _xcols.Set( new CColumnSet( cols ) );

        if ( 0 != psort)
            _xsort.Set( new  CSortSet( *psort ) );
    }

    _TimeLimit.CheckExecutionTime();    // account for execution time in ctor
} //CQueryOptimizer

//+-------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::~CQueryOptimizer, public
//
//  Synopsis:   Destructor
//
//  History:    21-Jun-95    KyleP        Created
//
//--------------------------------------------------------------------------

CQueryOptimizer::~CQueryOptimizer()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::QueryNextCursor, public
//
//  Returns:    Cursor for next component of query.
//
//  Arguments:  [status]  -- Status filled in here
//              [fAbort]  -- Set to true if we should abort
//
//  History:    21-Jun-95    KyleP        Created
//
//--------------------------------------------------------------------------

CGenericCursor * CQueryOptimizer::QueryNextCursor( ULONG & status, BOOL & fAbort )
{
    XPtr<CGenericCursor> xTemp;

    do
    {
        if ( _fAtEnd )
        {
            Win4Assert( xTemp.IsNull() );
            break;
        }
        else
        {
            xTemp.Set( ApplyIndexStrategy( status, fAbort ) );

            if ( _qRstIterator.AtEnd() )
                _fAtEnd = TRUE;
            else
            {
                //
                // Delete previous components of OR query
                //

                delete _xFullyResolvableRst.Acquire();
                Win4Assert( _xXpr.IsNull() );

                _qRstIterator.GetNextComponent( _xFullyResolvableRst, _xXpr );

                ChooseIndexStrategy( _xsort.GetPointer(), _xcols.GetReference() );
            }
        }
    }
    while ( xTemp.IsNull() );

    return xTemp.Acquire();
} //QueryNextCursor

//+-------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::QuerySingletonCursor, public
//
//  Returns:    "Singleton" cursor.
//
//  Arguments:  [fAbort] -- Set to true if we should abort
//
//  History:    21-Jun-95    KyleP        Created
//
//  Notes:      A singleton cursor is manually positionable.
//
//--------------------------------------------------------------------------

CSingletonCursor * CQueryOptimizer::QuerySingletonCursor( BOOL & fAbort )
{
    XXpr xxprTemp;

    if ( !_xxprSingleton.IsNull() )
        xxprTemp.Set( _xxprSingleton->Clone() );

    return new CSingletonCursor( _xQuerySession.GetPointer(),
                                 xxprTemp,
                                 _AccessMask(),
                                 fAbort );
} //QuerySingletonCursor

//+---------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::ChooseIndexStrategy, private
//
//  Effects:    Selects indexing strategy for query.
//
//  Arguments:  [pSort] -- Sort order.  May be null.
//              [cols]  -- Output columns.
//
//  History:    04-Nov-94   KyleP       Split from CQExecute::Resolve
//              20-Jan-95   DwightKr    Split from CQExecute
//
//----------------------------------------------------------------------------

void CQueryOptimizer::ChooseIndexStrategy( CSortSet const * pSort,
                                           CColumnSet const & cols )
{
    _fCIRequired = FALSE;

    CIndexStrategy strategy;

    // Poll non-content nodes for strategy

    if ( !_xXpr.IsNull() )
        _xXpr->SelectIndexing( strategy );

    vqDebugOut(( DEB_ITRACE, "IsFullyResolvableRst: %s\n",
                 _xFullyResolvableRst.IsNull() ? "no" : "yes" ));

    if ( !_xFullyResolvableRst.IsNull() )
    {
#if (CIDBG == 1)
        vqDebugOut(( DEB_ITRACE, "Content indexable portion:\n" ));
        Display( _xFullyResolvableRst.GetPointer(), 0, DEB_ITRACE );
#endif

        //
        // When processing a query component by component, we need to check
        // if the current component of query requires a content index.
        // Here we set the content-index-required-local flag to TRUE.
        //

        _fCIRequired = TRUE;

        //
        // If we have any property indexing to add, do it here on the first pass.
        //

        XRestriction rst( strategy.QueryContentRestriction() );

        if ( !rst.IsNull() )
        {
#           if (CIDBG == 1)
                vqDebugOut(( DEB_ITRACE, "Value indexable portion:\n" ));
                Display( rst.GetPointer(), 0, DEB_ITRACE );
#           endif
            XNodeRestriction rstTemp( new CNodeRestriction( RTAnd, 2 ) );

            if ( rstTemp.IsNull() )
                THROW( CException( STATUS_NO_MEMORY ) );

            rstTemp->AddChild( rst.Acquire() );
            rstTemp->AddChild( _xFullyResolvableRst.Acquire() );

            _xFullyResolvableRst.Set( rstTemp.Acquire() );
        }
    }
    else
    {
        //
        // We have a non-content query.  At least we can add some value-
        // indexing for enumeration queries that are big. Only do value-
        // indexing if there is a content index.
        //

        CI_ENUM_OPTIONS enumOption;
        SCODE sc = _xQuerySession->GetEnumOption( &enumOption );
        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR, "ChooseIndexStrategy - GetEnumOption returned %#x\n", sc ));
            THROW ( CException( sc ) );
        }

        Win4Assert( enumOption == CI_ENUM_SMALL ||
                    enumOption == CI_ENUM_BIG ||
                    enumOption == CI_ENUM_NEVER ||
                    enumOption == CI_ENUM_MUST ||
                    enumOption == CI_ENUM_MUST_NEVER_DEFER );

        if ( enumOption != CI_ENUM_MUST && enumOption != CI_ENUM_MUST_NEVER_DEFER )
            _xFullyResolvableRst.Set( strategy.QueryContentRestriction( TRUE ) );

        if ( ( !_xFullyResolvableRst.IsNull() ) &&
             ( enumOption == CI_ENUM_BIG || _fUseCI ) )
        {
#           if (CIDBG == 1)
                vqDebugOut(( DEB_ITRACE, "Value indexable portion:\n" ));
                Display( _xFullyResolvableRst.GetPointer(), 0, DEB_ITRACE );
#           endif
        }
        else
        {
            //
            // This is a shallow query where no view matches the sort,
            // restriction, or any output columns.
            //

            delete _xFullyResolvableRst.Acquire();
        }
    }


    _fFullySorted = FALSE;
    _fSortedByRankOpt = FALSE;
    if ( 0 == pSort || pSort->Count() == 0 )
    {
        _fFullySorted = TRUE;
    }
    else if ( !_xFullyResolvableRst.IsNull()
              && pSort->Count() == 1
              && pSort->Get(0).pidColumn == pidWorkId
              && pSort->Get(0).dwOrder == QUERY_SORTASCEND )
    {
        _fFullySorted = TRUE;
    }
    else if ( pSort->Count() == 1           // No need to check for 
                                            // !_xFullyResolvableRst.IsNull(), because 
                                            // in this case all ranks will be 1000
              && pSort->Get(0).pidColumn == pidRank
              && pSort->Get(0).dwOrder == QUERY_SORTDESCEND
              && !_fRankVectorProp          // CSortedByRankCursor cannot provide rank vector info
              &&  (     ( _cMaxResults > 0           // Limit on # results has been specified
                          && _cMaxResults <= MAX_HITS_FOR_FAST_SORT_BY_RANK_OPT )  // Limit is less than internal cutoff
                    ||  ( _cFirstRows > 0  
                          && _cFirstRows <= MAX_HITS_FOR_FAST_SORT_BY_RANK_OPT )))
    {                       
        _fSortedByRankOpt = TRUE;
    }
} //ChooseIndexStrategy

//+---------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::ApplyIndexStrategy, private
//
//  Synopsis:   Apply indexing to cursor.
//
//  Arguments:  [status] -  Content index status
//              [fAbort] -  Set to true if we should abort
//
//  History:    07-Nov-94   KyleP       Created.
//              20-Jan-95   DwightKr    Split from CQExecute
//
//  Notes:      This call can take a long time!!!  Query cursors position
//              themselves on the first matching record, when index selection
//              is made.
//
//----------------------------------------------------------------------------

CGenericCursor * CQueryOptimizer::ApplyIndexStrategy(
    ULONG & status,
    BOOL &  fAbort )
{
    status = _dwQueryStatus;

    if ( _fNeedSingleton && !_xXpr.IsNull() )
    {
        delete _xxprSingleton.Acquire();
        _xxprSingleton.Set( _xXpr->Clone() );
    }

    XPtr<CGenericCursor> cursor;

    //
    // If we have a content restriction, then we use CI.
    // If we have nothing, then we enumerate.
    //
    // If we have a null catalog, we can only enumerate
    //

    if ( !_xFullyResolvableRst.IsNull())
    {
        CI_ENUM_OPTIONS enumOption;
        SCODE sc = _xQuerySession->GetEnumOption( &enumOption );
        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR, "ApplyIndexStrategy - GetEnumOption returned 0x%x\n", sc ));
            THROW ( CException( sc ) );
        }

        if ( enumOption != CI_ENUM_MUST &&
             enumOption != CI_ENUM_MUST_NEVER_DEFER &&   // CI is allowed.
             !_fNullCatalog &&                                           // We have a catalog.
             (enumOption != CI_ENUM_SMALL || _fCIRequired || _fUseCI) )  // We're not using CI for a small scope when we don't have to.
        {
            void *pVoid = 0;

            ICiFrameworkQuery * pIFwQuery = 0;
            SCODE sc = _xCiManager->QueryInterface( IID_ICiFrameworkQuery,
                                                     (void **) &pIFwQuery );

            Win4Assert( S_OK == sc );
            sc = pIFwQuery->GetCCI( &pVoid );
            pIFwQuery->Release();

            if ( FAILED( sc ) )
            {
                Win4Assert( !"Need to support GetCCI method" );

                THROW( CException( sc ) );
            }

            Win4Assert( pVoid != 0 );

            CCI * pcci = (CCI *) pVoid;
            PARTITIONID pid = 1;
            ULONG flags = 0;

            Win4Assert( pcci != 0 );

            ULONG cPendingChanges = (_fCIRequired || _fUseCI) ?
                                        0 :
                                        _frameworkParams.GetMaxPendingDocuments();

            XCursor cur( pcci->Query( _xFullyResolvableRst.GetPointer(),   // Restriction
                                      &flags,                              // Flags
                                      1,                                   // cPartition
                                      &pid,                                // Partition
                                      cPendingChanges,
                                      _frameworkParams.GetMaxRestrictionNodes() ) ); // Maximum # nodes in query


            if ( flags & CI_NOISE_PHRASE )
                status |= STAT_NOISE_WORDS;

            #if CIDBG == 1
            if ( flags & CI_TOO_MANY_NODES )
            {
                Win4Assert( cur.IsNull() );
            }
            #endif // CIDBG

            //
            // If we didn't get any results, it may be because one or more of
            // the properties we tried to use a value-index for were unindexed.
            // In that case, we can fall back on enumeration.
            //

            if ( cur.IsNull() || cur->IsUnfilteredOnly() )
            {
                cur.Free();
                if ( _fCIRequired || _fUseCI )
                {
                    if ( flags & CI_TOO_MANY_NODES )
                    {
                        vqDebugOut(( DEB_ITRACE, "CI query too expensive!\n" ));
                        status |= STAT_CONTENT_QUERY_INCOMPLETE;
                    }

                    if ( flags & CI_NOT_UP_TO_DATE )
                        status |= STAT_CONTENT_OUT_OF_DATE;

                    vqDebugOut(( DEB_ITRACE, "Null cursor from content index.\n" ));

                    delete _xXpr.Acquire();
                    return 0;
                }
                else
                {
                    vqDebugOut(( DEB_ITRACE, "Fallback: Optional CI returned no hits.\n" ));
                }
            }
            else
            {
                if ( (flags & CI_NOT_UP_TO_DATE) && !_fCIRequired && !_fUseCI )
                {
                    vqDebugOut(( DEB_ITRACE, "Fallback: Optional CI not up-to-date.\n" ));

                    delete cur.Acquire();
                }
                else
                {
                    if ( flags & CI_NOT_UP_TO_DATE )
                        status |= STAT_CONTENT_OUT_OF_DATE;

                    vqDebugOut(( DEB_ITRACE, "Iterating via content index.\n" ));

                    if ( _fSortedByRankOpt )
                    {
                        cursor.Set( new CSortedByRankCursor( _xQuerySession.GetPointer(),
                                                             _xXpr,
                                                             _AccessMask(),
                                                             fAbort,
                                                             cur,
                                                             _cMaxResults,
                                                             _cFirstRows,
                                                             _fDeferTrimming,
                                                             _TimeLimit ) );
                    }
                    else
                    {
                        cursor.Set( new CCiCursor( _xQuerySession.GetPointer(),
                                                   _xXpr,
                                                   _AccessMask(),
                                                   fAbort,
                                                   cur ) );
                    }
                }
            }
        }
        else
        {
            if ( _fCIRequired )
            {
                vqDebugOut(( DEB_ITRACE,
                             "(A) Cannot use ci for require-ci query, _fCIRequired %d, enumoption 0x%x\n",
                             _fCIRequired, enumOption ));
                status |= STAT_CONTENT_QUERY_INCOMPLETE;
                return 0;
            }
        }
    }

    if ( cursor.IsNull() )
    {
        CI_ENUM_OPTIONS enumOption;
        SCODE sc = _xQuerySession->GetEnumOption( &enumOption );
        if ( FAILED( sc ) )
        {
            vqDebugOut(( DEB_ERROR, "ApplyIndexStrategy - GetEnumOption returned 0x%x\n", sc ));
            THROW ( CException( sc ) );
        }

        switch ( enumOption )
        {
        case CI_ENUM_SMALL:
        case CI_ENUM_BIG:
            if ( _fUseCI )
            {
                vqDebugOut(( DEB_ITRACE,
                             "(B) Cannot use ci for require-ci query, _fCIRequired %d, enumoption: 0x%x\n",
                             _fCIRequired, enumOption ));
                status |= STAT_CONTENT_QUERY_INCOMPLETE;
                return 0;
            }               // No break, deliberate fall thru

        case CI_ENUM_MUST:
        case CI_ENUM_MUST_NEVER_DEFER:
        {
            vqDebugOut(( DEB_ITRACE, "Iterating via enumeration\n" ));

            XInterface<ICiCScopeEnumerator> xScopeEnumerator;
            sc = _xQuerySession->CreateEnumerator( xScopeEnumerator.GetPPointer() );
            if ( FAILED( sc ) )
            {
                vqDebugOut(( DEB_ERROR, "ApplyIndexStrategy - CreateEnumerator returned 0x%x\n", sc ));
                THROW ( CException( sc ) );
            }

            cursor.Set( new CEnumCursor( _xXpr,
                                         _AccessMask(),
                                         fAbort,
                                         xScopeEnumerator ) );
            break;
        }

        case CI_ENUM_NEVER:
            vqDebugOut(( DEB_ITRACE, "Cannot iterate via enumeration, because the scope doesn't support enumeration\n" ));
            status |= STAT_CONTENT_QUERY_INCOMPLETE;

            return 0;

        default:

            Win4Assert( !"ApplyIndexStrategy - unknown case selector" );
            vqDebugOut(( DEB_ERROR, "ApplyIndexStrategy - unknown value of case selector: %d\n", enumOption ));

            THROW ( CException( E_FAIL ) );
        }
    }

    //
    // Don't bother returning a null cursor.
    //

    if ( cursor->WorkId() == widInvalid )
        cursor.Free();

    return cursor.Acquire();
} //ApplyIndexStrategy

//+-------------------------------------------------------------------------
//
//  Member:     CQueryOptimizer::FetchDeferredValue
//
//  Synopsis:   Fetches deferred property value
//
//  Arguments:  [wid] -- Workid
//              [ps]  -- Property to be fetched
//              [var] -- Property returned here
//
//  History:    12-Jan-97    SitaramR        Created
//
//--------------------------------------------------------------------------

BOOL CQueryOptimizer::FetchDeferredValue( WORKID wid,
                                          CFullPropSpec const & ps,
                                          PROPVARIANT & var )
{
    SCODE sc;

    {
        //
        // If the client is using a pipe to communicate with the server then
        // the pipe will serialize calls to fetch deferred values. If the
        // client is not using a pipe, then two threads can potentially call
        // FetchDeferredValue concurrently. Hence the lock.
        //
    
        CLock lock( _mtxSem );

        if ( _xDefPropRetriever.IsNull() )
        {
    
            sc = _xQuerySession->CreateDeferredPropRetriever( _xDefPropRetriever.GetPPointer() );
            if ( FAILED( sc ) )
            {
                vqDebugOut(( DEB_ERROR,
                             "CQueryOptimizer::FetchDeferredValue failed, 0x%x\n",
                             sc ));
                THROW ( CException( sc ) );
            }
        }   
    }

    sc = _xDefPropRetriever->RetrieveDeferredValueByPropSpec( wid,
                                                              ps.CastToStruct(),
                                                              &var );
    return SUCCEEDED( sc );
} //FetchDeferredValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\split.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Split.cxx
//
//  Contents:   Split expressions and restrictions into indexable/non-indexable
//
//  History:    22-Dec-92 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <split.hxx>
#include <xpr.hxx>
#include <parse.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     Split
//
//  Synopsis:   Splits a restriction into an indexable/non-indexable restrictions
//
//  Arguments:  [xRst] -- input safe pointer to restriction
//              [xRstFullyResolvable] -- output safe pointer to indexable
//                                       restriction
//
//  Notes:      By the time Split is called, xRst has been normalized --
//              it is of the form (A or .. or C) and ... and (B or ... or D).
//              All of the fully indexable subexpressions (the or clauses)
//              can be replaced by a single call to the content index.
//
//              Other partially indexable clauses are not dealt with at
//              this point.
//
//
//  History:    11-Sep-91   KyleP       Created.
//              26-Sep-94   SitaramR    Moved here from execute.cxx and
//                                        converted to a standalone function.
//
//----------------------------------------------------------------------------

void Split( XRestriction& xRst, XRestriction& xRstFullyResolvable )
{
    vqDebugOut((DEB_ITRACE, "Split...\n"));

    //
    // There are two cases for split -- If the top level expression is
    // an AND then we need to iterate through the subexpressions of the
    // AND to find those that are fully indexable.  If the top level
    // is not a boolean combination then we have only one expression to
    // look at.
    //

    if( xRst->Type() == RTAnd )
    {
        CNodeRestriction * pNodeRst = xRst->CastToNode();

        //
        // Split off all nodes *fully* resolvable by content index
        // (e.g. content nodes)
        //

        XNodeRestriction rstFullyResolvable( new CNodeRestriction( RTAnd ) );

        MoveFullyIndexable( *pNodeRst, rstFullyResolvable.GetReference() );

        //
        // Get rid of any null or nearly null boolean expressions.
        //

        switch ( rstFullyResolvable->Count() )
        {
        case 0:
            break;

        case 1:
            xRstFullyResolvable.Set( rstFullyResolvable->RemoveChild( 0 ) );
            break;

        default:
            xRstFullyResolvable.Set( rstFullyResolvable.Acquire() );
            break;
        }

        switch ( pNodeRst->Count() )
        {
        case 0:
            // delete the solitary And node

            pNodeRst = xRst.Acquire()->CastToNode();
            delete pNodeRst;
            break;

        case 1:
            pNodeRst = xRst.Acquire()->CastToNode();
            xRst.Set( pNodeRst->RemoveChild( 0 ));

            Win4Assert( pNodeRst->Count() == 0 );

            delete pNodeRst;
            break;

        default:
            break;
        }
    }

    //
    // Non-boolean top node.
    //

    else
    {
        if ( IsFullyIndexable( xRst.GetPointer() ) )
            xRstFullyResolvable.Set( xRst.Acquire() );
    }
}


#if 0
//+---------------------------------------------------------------------------
//
//  Function:   SplitXpr, public
//
//  Synopsis:   Splits a boolean expression into its indexable and non-
//              indexable portions.
//
//  Effects:    On (non exception) exit, [nxp] contains the portion
//              of the input expression which is not fully indexable.
//              [nxpFullyIndexable] contains clauses which are fully
//              indexable.  If an exception occurs output state is
//              identical to input state.
//
//  Arguments:  [nxp]               -- Original input expression.
//              [nxpFullyIndexable] -- Fully indexable subexpressions are
//                                     moved here.
//
//  Modifies:   Subexpressions are moved from [nxp] to [nxpFullyIndexable]
//
//  History:    21-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void SplitXpr( CNodeXpr &nxp, CNodeXpr &nxpFullyIndexable)
{
    TRY
    {
        for (int i = nxp.Count() - 1; i >= 0; i--)
        {
            if ( nxp.GetChild( i )->IsFullyIndexable() )
            {
                nxpFullyIndexable.AddChild( nxp.RemoveChild( i ) );
            }
        }
    }
    CATCH( CException, e )
    {
        for (int i = nxpFullyIndexable.Count() - 1; i >= 0; i--)
        {
            nxp.AddChild( nxpFullyIndexable.RemoveChild( i ) );
        }

        RETHROW();
    }
    END_CATCH
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\singlcur.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       singlcur.cxx
//
//  Contents:   Single object 'iterator'
//
//  History:    03-May-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciintf.h>

#include "singlcur.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CSingletonCursor::CSingletonCursor, public
//
//  Synopsis:   Initialize single object `enumerator'
//
//  Arguments:  [pQuerySession]  -- Query session object
//              [xxpr]           -- Expression (for base class)
//              [accessMask]     -- Access mask
//              [fAbort]         -- Set to true if we should abort
//
//  History:    03-May-94 KyleP     Created
//
//--------------------------------------------------------------------------

CSingletonCursor::CSingletonCursor( ICiCQuerySession *pQuerySession,
                                    XXpr & xxpr,
                                    ACCESS_MASK accessMask,
                                    BOOL & fAbort )
        : CGenericCursor( xxpr, accessMask, fAbort ),
          _lRank( MAX_QUERY_RANK ),
          _ulHitCount( 0 )
{
    ICiCPropRetriever *pPropRetriever;

    SCODE sc = pQuerySession->CreatePropRetriever( &pPropRetriever );
    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_ERROR, "SetupPropRetriever failed: 0x%x", sc ));

        THROW ( CException( sc ) );
    }

    _xPropRetriever.Set( pPropRetriever );

    END_CONSTRUCTION( CSingletonCursor );
}


//+---------------------------------------------------------------------------
//
//  Method:     CSingletonCursor::RatioFinished, private
//
//  Synopsis:   Computes ratio finished.
//
//  Arguments:  [denom] -- Denominator returned here
//              [num]   -- Numerator returned here
//
//  History:    17-Jul-95   KyleP      Added header
//
//----------------------------------------------------------------------------

void CSingletonCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = 1;
    num   = 1;
}



//+-------------------------------------------------------------------------
//
//  Member:     CSingletonCursor::SetCurrentWorkId, public
//
//  Synopsis:   Position cursor on said workid
//
//  Arguments:  [wid] -- WorkId.
//
//  History:    19-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CSingletonCursor::SetCurrentWorkId( WORKID wid )
{
    Quiesce();

    SetWorkId( wid );
}

//+-------------------------------------------------------------------------
//
//  Member:     CSingletonCursor::NextObject, public
//
//  Synopsis:   Move to next object which is widInvalid
//
//  History:    17-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

WORKID CSingletonCursor::NextObject()
{
    return( widInvalid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\strategy.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1994 - 2000.
//
// File:       Strategy.cxx
//
// Contents:   Encapsulates strategy for choosing indexes
//
// History:    03-Nov-94   KyleP       Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <strategy.hxx>
#include <compare.hxx>
#include <norm.hxx>
#include <vkrep.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::CIndexStrategy, public
//
//  Synopsis:   Constructor
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

CIndexStrategy::CIndexStrategy()
        : _BooleanMode( NoMode ),
          _cNodes( 0 ),
          _cBounds( 0 ),
          _depth( 0 ),
          _iRangeUsn( InvalidUsnRange )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::~CIndexStrategy, public
//
//  Synopsis:   Destructor
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

CIndexStrategy::~CIndexStrategy()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::SetBounds, public
//
//  Synopsis:   Set both upper and lower bounds of property
//
//  Arguments:  [pid]      -- Property id
//              [varLower] -- Lower bound
//              [varUpper] -- Upper bound
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

void CIndexStrategy::SetBounds( PROPID pid,
                                CStorageVariant const & varLower,
                                CStorageVariant const & varUpper )
{
    SetLowerBound( pid, varLower );
    SetUpperBound( pid, varUpper );

    _cNodes--;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::SetLowerBound, public
//
//  Synopsis:   Set lower bound of property
//
//  Arguments:  [pid]      -- Property id
//              [varLower] -- Lower bound
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

void CIndexStrategy::SetLowerBound( PROPID pid, CStorageVariant const & varLower )
{
    _cNodes++;

    if ( _depth > 1 )
        return;

    unsigned i = FindPid( pid );

    if ( pid == pidLastChangeUsn )
        _iRangeUsn = i;

    CRange * pRange = _aBounds.Get(i);

    if ( !pRange->IsValid() )
        return;

    if ( pRange->LowerBound().Type() == VT_EMPTY )
        pRange->SetLowerBound( varLower );
    else
    {
#if CIDBG == 1
        if ( pRange->LowerBound().Type() != varLower.Type() )
        {
            vqDebugOut(( DEB_WARN, "Type mismatch (%d vs. %d) setting indexing strategy.\n",
                         pRange->LowerBound().Type(), varLower.Type() ));
        }
#endif
        FRel rel = VariantCompare.GetRelop( varLower.Type(), (_BooleanMode == OrMode) ? PRLT : PRGT );

        if ( 0 == rel )
            pRange->MarkInvalid();
        else if ( rel( (PROPVARIANT const &)varLower,
                       (PROPVARIANT const &)pRange->LowerBound() ) )
            pRange->SetLowerBound( varLower );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::SetUpperBound, public
//
//  Synopsis:   Set upper bound of property
//
//  Arguments:  [pid]      -- Property id
//              [varUpper] -- Upper bound
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

void CIndexStrategy::SetUpperBound( PROPID pid, CStorageVariant const & varUpper )
{
    _cNodes++;

    if ( _depth > 1 )
        return;

    unsigned i = FindPid( pid );

    if ( pid == pidLastChangeUsn )
        _iRangeUsn = i;

    CRange * pRange = _aBounds.Get(i);

    if ( !pRange->IsValid() )
        return;

    if ( pRange->UpperBound().Type() == VT_EMPTY )
        pRange->SetUpperBound( varUpper );
    else
    {
#if CIDBG == 1
        if ( pRange->UpperBound().Type() != varUpper.Type() )
        {
            vqDebugOut(( DEB_WARN, "Type mismatch (%d vs. %d) setting indexing strategy.\n",
                         pRange->UpperBound().Type(), varUpper.Type() ));
        }
#endif
        FRel rel = VariantCompare.GetRelop( varUpper.Type(), (_BooleanMode == OrMode) ? PRGT : PRLT );

        if ( 0 == rel )
            pRange->MarkInvalid();
        else if ( rel( (PROPVARIANT const &)varUpper,
                       (PROPVARIANT const &)pRange->UpperBound() ) )
            pRange->SetUpperBound( varUpper );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::SetUnknownBounds, public
//
//  Synopsis:   Placeholder method.  Indicates a node has been found with
//              no bounds.  Used to maintain accurate count of nodes.
//
//  Arguments:  [pid] -- Property id
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

void CIndexStrategy::SetUnknownBounds( PROPID pid )
{
    _cNodes++;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::LowerBound, public
//
//  Arguments:  [pid] -- Property id
//
//  Returns:    Lower bound
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

CStorageVariant const & CIndexStrategy::LowerBound( PROPID pid ) const
{
    for ( unsigned i = 0; i < _cBounds; i++ )
    {
        if ( _aBounds.Get(i)->Pid() == pid )
        {
            Win4Assert( _aBounds.Get(i)->IsValid() );
            return( _aBounds.Get(i)->LowerBound() );
        }
    }

    Win4Assert( !"Couldn't find pid (lower bound" );
    return( *((CStorageVariant *)0) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::UpperBound, public
//
//  Arguments:  [pid] -- Property id
//
//  Returns:    Upper bound
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

CStorageVariant const & CIndexStrategy::UpperBound( PROPID pid ) const
{
    for ( unsigned i = 0; i < _cBounds; i++ )
    {
        if ( _aBounds.Get(i)->Pid() == pid )
        {
            Win4Assert( _aBounds.Get(i)->IsValid() );
            return( _aBounds.Get(i)->UpperBound() );
        }
    }

    Win4Assert( !"Couldn't find pid (upper bound" );
    return( *((CStorageVariant *)0) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::GetUsnRange, public
//
//  Synopsis:   Returns bounds for USN property.
//
//  Arguments:  [usnMin] -- Lower bound returned here
//              [usnMax] -- Upper bound returned here
//
//  Returns:    TRUE if bounds existed for USN
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

BOOL CIndexStrategy::GetUsnRange( USN & usnMin, USN & usnMax ) const
{
    if ( _iRangeUsn == InvalidUsnRange || _BooleanMode == OrMode || _BooleanMode == InvalidMode )
        return FALSE;

    CStorageVariant const & varLower = _aBounds.Get(_iRangeUsn)->LowerBound();

    if ( varLower.Type() != VT_I8 )
        usnMin = 0;
    else
        usnMin = varLower.GetI8().QuadPart;

    CStorageVariant const & varUpper = _aBounds.Get(_iRangeUsn)->UpperBound();

    if ( varUpper.Type() != VT_I8 )
        usnMax = _UI64_MAX;
    else
        usnMax = varUpper.GetI8().QuadPart;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::SetContentHelper, public
//
//  Synopsis:   Transfer content helper node to strategy object.
//
//  Arguments:  [pcrst] -- Content node
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

void CIndexStrategy::SetContentHelper( CRestriction * pcrst )
{
    Win4Assert( 0 != pcrst );

    if ( _depth > 1 )
        delete pcrst;
    else
        _stkContentHelpers.Push( pcrst );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::QueryContentRestriction, public
//
//  Synopsis:   Compute content restriction, including use of value indices.
//
//  Arguments:  [fPropertyOnly] -- TRUE if query is property only and must
//                                 match unfiltered objects.
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

CRestriction * CIndexStrategy::QueryContentRestriction( BOOL fPropertyOnly )
{
    vqDebugOut(( DEB_ITRACE, "QueryContentRestriction _BooleanMode: %s\n",
                 _BooleanMode == NoMode ? "NoMode" :
                 _BooleanMode == AndMode ? "AndMode" :
                 _BooleanMode == OrMode ? "OrMode" : "InvalidMode" ));

    vqDebugOut(( DEB_ITRACE, "_cNodes %d, _cBounds: %d\n", _cNodes, _cBounds ));

    Win4Assert( _BooleanMode != NoMode || _cNodes <= 1 );

    if ( _BooleanMode == InvalidMode )
        return 0;

    XNodeRestriction pnrst( new CNodeRestriction( (_BooleanMode == OrMode) ? RTOr : RTAnd ) );

    // operator new throws.

    Win4Assert( !pnrst.IsNull() );

    if ( _BooleanMode != OrMode )
    {
        //
        // Construct range (property value) restrictions
        //

        for ( unsigned i = 0; i < _cBounds; i++ )
        {
            CRange * pRange = _aBounds.Get(i);

            vqDebugOut(( DEB_ITRACE,
                         "    pRange->IsValid: %d\n", pRange->IsValid() ));

            if ( !pRange->IsValid() )
                continue;

            if ( ( VT_EMPTY == pRange->LowerBound().Type() ) &&
                 ( VT_EMPTY == pRange->UpperBound().Type() ) )
                continue;

            //
            // Path is (currently) unique in that it is not value-indexed.
            //

            if ( pidPath == pRange->Pid() ||
                 pidDirectory == pRange->Pid() ||
                 pidVirtualPath == pRange->Pid() )
                continue;

            CRangeKeyRepository krep;
            CValueNormalizer norm( krep );
            OCCURRENCE occ = 1;

            vqDebugOut(( DEB_ITRACE, "    lower type %d, upper type %d\n",
                         pRange->LowerBound().Type(),
                         pRange->UpperBound().Type() ));

            if ( pRange->LowerBound().Type() == VT_EMPTY)
                norm.PutMinValue( pRange->Pid(), occ, pRange->UpperBound().Type() );
            else
                norm.PutValue( pRange->Pid(), occ, pRange->LowerBound() );

            if ( pRange->UpperBound().Type() == VT_EMPTY )
                norm.PutMaxValue( pRange->Pid(), occ, pRange->LowerBound().Type() );
            else
                norm.PutValue( pRange->Pid(), occ, pRange->UpperBound() );

            CRestriction * prst = krep.AcqRst();

            if ( 0 != prst )
            {
                pnrst->AddChild( prst );

#               if 0 && CIDBG == 1
                    vqDebugOut(( DEB_ITRACE, "   PID 0x%x: LOWER = ", _aBounds.Get(i)->Pid() ));
                    _aBounds.Get(i)->LowerBound().DisplayVariant( DEB_ITRACE | DEB_NOCOMPNAME, 0 );
                    vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, ",  UPPER = " ));
                    _aBounds.Get(i)->UpperBound().DisplayVariant( DEB_ITRACE | DEB_NOCOMPNAME, 0 );
                    vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));
#               endif
            }
            else
            {
                vqDebugOut(( DEB_ITRACE, "    range key repository gave no restriction\n" ));
            }
        }
    }

    //
    // Add any content helpers
    //

    vqDebugOut(( DEB_ITRACE, "count of content helpers: %d\n",
                 _stkContentHelpers.Count() ));

    //
    // Note: This code is problematic and was rewritten in the new engine.
    //       It works well enough for now.
    // 
    // Why was this if statement written like this?  When would an OR
    // node be acceptable if _cNodes == _stkContentHelpers.Count?
    // I commented out the latter check because it was mis-handling
    // @size < 20 or #filename *.htm since the counts are equal in OR mode.
    //

    if ( _BooleanMode != OrMode ) // || _cNodes == _stkContentHelpers.Count() )
    {
        vqDebugOut(( DEB_ITRACE, "Adding content helpers\n" ));

        while ( _stkContentHelpers.Count() > 0 )
        {
            CRestriction * prst = _stkContentHelpers.Pop();

            pnrst->AddChild( prst );
        }
    }

    //
    // Optimize return restriction
    //

    if ( pnrst->Count() == 0 )
    {
        vqDebugOut(( DEB_ITRACE, "No restriction to return\n" ));
        return 0;
    }

    //
    // If this is a property-only query then add an OR clause to match unfiltered files.
    //

    if ( fPropertyOnly )
    {
        XNodeRestriction rstOr( new CNodeRestriction( RTOr, 2 ) );

        CRangeKeyRepository krep;
        CValueNormalizer norm( krep );
        OCCURRENCE occ = 1;
        CStorageVariant var;
        var.SetBOOL( VARIANT_TRUE );

        norm.PutValue( pidUnfiltered, occ, var );
        norm.PutValue( pidUnfiltered, occ, var );

        rstOr->AddChild( krep.AcqRst() );

        if ( pnrst->Count() == 1 )
            rstOr->AddChild( pnrst->RemoveChild(0) );
        else
            rstOr->AddChild( pnrst.Acquire() );

        return rstOr.Acquire();
    }
    else
    {
        if ( pnrst->Count() == 1 )
            return pnrst->RemoveChild( 0 );
        else
            return pnrst.Acquire();
    }
} //QueryContentRestriction

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::CanUse, public
//
//  Arguments:  [pid]        -- Property id
//              [fAscending] -- Use for ascending/descending sort
//
//  Returns:    TRUE if property can be used with specified index.
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

BOOL CIndexStrategy::CanUse( PROPID pid, BOOL fAscending ) const
{
    vqDebugOut(( DEB_ITRACE, "strategy::CanUse pid %#x, fAscending %d, _BooleanMode %s\n",
                 _BooleanMode == NoMode ? "NoMode" :
                 _BooleanMode == AndMode ? "AndMode" :
                 _BooleanMode == OrMode ? "OrMode" : "InvalidMode" ));

    if ( _BooleanMode == OrMode || _BooleanMode == InvalidMode )
        return FALSE;

    for ( unsigned i = 0; i < _cBounds; i++ )
    {
        CRange * pRange = _aBounds.Get(i);

        if ( pRange->Pid() == pid )
        {
            if ( !pRange->IsValid() )
                return FALSE;

            if ( fAscending )
            {
                if ( pRange->LowerBound().Type() == VT_EMPTY )
                    return( FALSE );
                else
                    return( TRUE );
            }
            else
            {
                if ( pRange->UpperBound().Type() == VT_EMPTY )
                    return( FALSE );
                else
                    return( TRUE );
            }
        }
    }

    return( FALSE );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIndexStrategy::FindPid, private
//
//  Arguments:  [pid] -- Property id
//
//  Returns:    Index of [pid] in bounds array.
//
//  History:    26-Oct-95    KyleP        Added header
//
//--------------------------------------------------------------------------

unsigned CIndexStrategy::FindPid( PROPID pid )
{
    for ( unsigned i = 0; i < _cBounds; i++ )
    {
        if ( _aBounds.Get(i)->Pid() == pid )
            break;
    }

    if ( i == _cBounds )
    {
        _aBounds.Add( new CRange( pid ), i );
        _cBounds++;
    }

    return( i );
} //FindPid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cifrmwrk\query\timlimit.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       timlimit.cxx
//
//  Contents:   Class to monitor execution time of a query
//
//  Classes:    CTimeLimit
//
//  History:    09 Jul 1996    AlanW    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <timlimit.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CTimeLimit::CTimeLimit, public
//
//  Synopsis:   Initialize a time limit
//
//  Arguments:  [ulExecutionTimeLimit] - Time limit in seconds
//              [ulMaxTimeOverride] - upper bound on ulExecutionTimeLimit (in msec)
//
//  History:    09 Jul 1996    AlanW    Created
//
//----------------------------------------------------------------------------

CTimeLimit::CTimeLimit( ULONG ulExecutionTimeLimit, ULONG ulMaxTimeOverride )
        : _ullExecutionTimeLimit( ulExecutionTimeLimit ),
          _fDisableCheck( FALSE )
{
    if (ULONG_MAX == ulExecutionTimeLimit || 0 == ulExecutionTimeLimit)
        _ullExecutionTimeLimit = _UI64_MAX;
    else
        _ullExecutionTimeLimit *= 10000000; // convert to 100 nsec intervals

    #if DBG || CIDBG
    if ( ciInfoLevel > 7 || vqInfoLevel > 7 )
    {
        if (_UI64_MAX != _ullExecutionTimeLimit)
            _ullExecutionTimeLimit *= 50;   // debugouts take a long... time
    }
    #endif // DBG || CIDBG

    SetMaxOverrideTime( ulMaxTimeOverride );
    SetBaselineTime();
}

//+-------------------------------------------------------------------------
//
//  Member:     CTimeLimit::SetBaselineTime, private
//
//  Synopsis:   Set CPU time for time limit computation
//
//  Arguments:  -none-
//
//  History:    08 Apr 96    AlanW        Created
//
//--------------------------------------------------------------------------

void CTimeLimit::SetBaselineTime( )
{
    FILETIME ftDummy1, ftDummy2;
    ULARGE_INTEGER ftUser, ftKernel;

    BOOL fSucceeded = GetThreadTimes( GetCurrentThread(),
                                      &ftDummy1,
                                      &ftDummy2,
                                      (PFILETIME) &ftUser,
                                      (PFILETIME) &ftKernel );

    if (! fSucceeded )
    {
        vqDebugOut(( DEB_ERROR,
                     "Error %d occurred during GetThreadTimes\n",
                     GetLastError() ));
        _ullBaselineTime = 0;
    }
    else
    {
        _ullBaselineTime = ftUser.QuadPart + ftKernel.QuadPart;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CTimeLimit::CheckExecutionTime, private
//
//  Synopsis:   Check for CPU time limit exceeded
//
//  Arguments:  [pullTimeslice] - pointer to time slice remaining (optional)
//
//  Returns:    TRUE if execution time limit exceeded, or if the query's
//              time for a time slice is exceeded.  Use the method IsTimedOut()
//              to determine if it was the time limit that was exceeded when
//              there is a TRUE return.
//
//  Notes:      The CPU time spent executing a query since the last
//              check is computed and compared with the remaining time
//              in the CPU time limit.
//              The remaining time, the time snapshot and the remaining
//              time slice are all updated.
//
//  History:    08 Apr 96    AlanW        Created
//
//--------------------------------------------------------------------------

BOOL CTimeLimit::CheckExecutionTime(
    ULONGLONG * pullTimeslice )
{
    if ( IsNoTimeOut() && 0 == pullTimeslice )
        return FALSE;

    ULONGLONG ullElapsed = _ullBaselineTime;

    SetBaselineTime( );

    Win4Assert( _ullBaselineTime >= ullElapsed );
    ullElapsed = _ullBaselineTime - ullElapsed;

    if (ullElapsed >= _ullExecutionTimeLimit)
    {
        _ullExecutionTimeLimit = 0;
        if (pullTimeslice)
            *pullTimeslice = 0;

        return TRUE;
    }

    _ullExecutionTimeLimit -= ullElapsed;

    if ( pullTimeslice )
    {
        if ( ullElapsed >= *pullTimeslice)
        {
            *pullTimeslice = 0;
            return TRUE;
        }
        else
        {
            *pullTimeslice -= ullElapsed;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\abortwid.cxx ===
//+------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 1998.
//
// File:        abortwid.cxx
//
// Contents:    Tracks aborted wids that are not refiled
//
// Classes:     CAbortedWids
//
// History:     24-Feb-97       SitaramR     Created
//
// Notes:       The data structure is a sequential array of aborted
//              wids. In push filtering, the number of aborted wids
//              should be small and hence the choice of sequential
//              array.
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "abortwid.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CAbortedWids::CAbortedWids
//
//  Synopsis:   Constructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//----------------------------------------------------------------------------

CAbortedWids::CAbortedWids()
  : _aAbortedWids( 0 )
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAbortedWids::NoFailLokAddWid
//
//  Synopsis:   Adds wid to the aborted list
//
//  Arguments:  [wid]  -- Workid to be added
//              [usn]  -- USN of the notification
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

void CAbortedWids::NoFailLokAddWid( WORKID wid, USN usn )
{
    Win4Assert( wid != widInvalid );
    Win4Assert( usn > 0 );

    // Space for the wid was pre-allocated in Reserve(), since we can't
    // afford to take an exception here.

    Win4Assert( _aAbortedWids.Count() < _aAbortedWids.Size() );

    CAbortedWidEntry widEntry( wid, usn );

    _aAbortedWids.Add( widEntry, _aAbortedWids.Count() );
} //NoFailLokAddWid

//+-------------------------------------------------------------------------
//
//  Method:     CAbortedWids::LokRemoveWid
//
//  Synopsis:   Adds wid to the aborted list
//
//  Arguments:  [wid]  -- Workid to be added
//              [usn]  -- USN of the notification
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

void CAbortedWids::LokRemoveWid( WORKID wid, USN usn )
{
    Win4Assert( wid != widInvalid );
    Win4Assert( usn > 0 );

    unsigned count = _aAbortedWids.Count();

    for ( unsigned i=0; i<_aAbortedWids.Count(); i++ )
    {
        if ( _aAbortedWids.Get(i)._wid == wid &&
             _aAbortedWids.Get(i)._usn == usn )
        {
            _aAbortedWids.Remove(i);
            break;
        }
    }

    //
    // Check that the wid was found in the array. We
    // are using count, instead of _aAbortedWids.Count()
    // because the latter will decrease after the Remove().
    //
    Win4Assert( i < count );
} //LokRemoveWid

//+-------------------------------------------------------------------------
//
//  Method:     CAbortedWids::LokIsWidAborted
//
//  Synopsis:   Adds wid to the aborted list
//
//  Arguments:  [wid]  -- Workid to be added
//              [usn]  -- USN of the notification
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

BOOL CAbortedWids::LokIsWidAborted( WORKID wid, USN usn )
{
    Win4Assert( wid != widInvalid );

    //
    // Can be called in pull filtering where usn's can be zero, hence
    // no assertion on value of usn
    //

    CAbortedWidEntry widEntry( wid, usn );

    for ( unsigned i=0; i<_aAbortedWids.Count(); i++ )
    {
        if ( _aAbortedWids.Get(i)._wid == wid &&
             _aAbortedWids.Get(i)._usn == usn )
        {
            return TRUE;
        }
    }

    return FALSE;
} //LokIsWidAborted

//+-------------------------------------------------------------------------
//
//  Method:     CAbortedWids::LokReserve
//
//  Synopsis:   Reserve space for potentially aborted wids.
//
//  Arguments:  [cWids]  -- # of slots to reserve now for failure later
//
//  History:    27-April-1998      dlee      Created
//
//--------------------------------------------------------------------------

void CAbortedWids::LokReserve( unsigned cWids )
{
    unsigned cPossible = _aAbortedWids.Count() + cWids;

    if ( _aAbortedWids.Size() < cPossible )
        _aAbortedWids.SetSize( cPossible );
} //LokReserve
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\bitstm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       BITSTM.cxx
//
//  Contents:   'Bit Stream'
//
//  Classes:    CBitBuffer
//
//  Classes:    CBitStream, CWBitStream, CRBitStream
//
//  History:    03-Jul-91       KyleP           Created
//              24-Aug-92       BartoszM        Rewrote it
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#pragma optimize( "t", on )

#include "bitstm.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::CSmartBuffer, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [phStorage] -- Physical index -- source of pages
//              [mode]      -- Access mode for the index
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CSmartBuffer::CSmartBuffer ( CPhysStorage& phStorage, EAccessMode mode )
        : _phStorage(phStorage),
          _pBuffer(0),
          _fWritable( mode == eWriteExisting )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::CSmartBuffer, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [phStorage] -- Physical index -- source of pages
//              [fCreate]   -- Indicates if new buffer is needed
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CSmartBuffer::CSmartBuffer ( CPhysStorage& phStorage, BOOL fCreate )
        : _phStorage(phStorage),
          _numPage(0),
          _fWritable(fCreate)
{
    if (fCreate)
    {
        _pBuffer  = _phStorage.BorrowNewBuffer(0);

        IncrementSig();

        #if CIDBG == 1
        CheckCorruption();
        #endif
    }
    else
    {
        _pBuffer  = _phStorage.BorrowBuffer( 0, _fWritable, _fWritable );

        CheckCorruption();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::CSmartBuffer, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [phStorage] -- Physical index -- source of pages
//              [numPage]   -- Page to encapsulate
//              [mode]      -- Access mode for the index
//              [fIncrSig]  -- Indicates if page should be signed
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CSmartBuffer::CSmartBuffer ( CPhysStorage& phStorage,
                             ULONG numPage,
                             EAccessMode mode,
                             BOOL fIncrSig )
        : _phStorage(phStorage),
          _numPage(numPage),
          _fWritable(mode == eWriteExisting)
{
    _pBuffer = _phStorage.BorrowBuffer( _numPage, _fWritable, _fWritable );

    if ( _fWritable && fIncrSig )
        IncrementSig();

    if (fIncrSig)
        CheckCorruption();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::CSmartBuffer, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [buf] -- Source CSmartBuffer
//              [numPage]      -- Page to acquire
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CSmartBuffer::CSmartBuffer ( CSmartBuffer& buf, ULONG numPage )
        : _phStorage(buf._phStorage),
          _numPage(numPage),
          _fWritable(buf._fWritable)
{
    _pBuffer = _phStorage.BorrowBuffer( _numPage, _fWritable, _fWritable );

    if ( _fWritable )
        IncrementSig();

    CheckCorruption();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::~CSmartBuffer, public
//
//  Synopsis:   Destructor.
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CSmartBuffer::~CSmartBuffer ()
{
    if ( 0 != _pBuffer )
    {
        // If a writable buffer still exists in this destructor we're in a
        // failure path that must not THROW.  Anything that really needs to
        // be on disk should already be there by now, so this code path
        // won't throw if it can't flush.
        //
        // If you see this debugout and you're not unwinding an exception,
        // your code is broken.
        // If a merge fails and you get this debugout, it's not a problem
        //

        if ( _fWritable && _phStorage.RequiresFlush( _numPage ) )
        {
            IncrementSig();
            ciDebugOut(( DEB_WARN, "deleting writable buffer in potential "
                         "unwind path -- it may not get flushed\n" ));
        }

        _phStorage.ReturnBuffer( _numPage, _fWritable, FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::CheckCorruption, private
//
//  Synopsis:   Attempts to determine if the entire page wasn't written
//              to disk.
//
//  History:    ?       KyleP        Created
//
//----------------------------------------------------------------------------

void CSmartBuffer::CheckCorruption()
{
    if ( 0 == _pBuffer[0] ||
         _pBuffer[0] != _pBuffer[SMARTBUF_PAGE_SIZE_IN_DWORDS + 1] )
    {
        ciDebugOut(( DEB_ERROR, "Buffer at 0x%x corrupt (StartDword = 0x%x, EndDword = 0x%x)\n",
                     _pBuffer, _pBuffer[0], _pBuffer[SMARTBUF_PAGE_SIZE_IN_DWORDS + 1] ));

        Win4Assert( !"Index corruption." );

        _phStorage.GetStorage().ReportCorruptComponent( ( 0 == _pBuffer[0] ) ?
                                                        L"SmartBuffer1" :
                                                        L"SmartBuffer2");
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::IncrementSig, private
//
//  Synopsis:   Increments the signature at the start and end of the page.
//
//  History:    ?       KyleP        Created
//
//----------------------------------------------------------------------------

void CSmartBuffer::IncrementSig()
{
    Win4Assert( _pBuffer[0] == _pBuffer[SMARTBUF_PAGE_SIZE_IN_DWORDS + 1] );

    _pBuffer[0]++;
    _pBuffer[SMARTBUF_PAGE_SIZE_IN_DWORDS + 1]++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::InitSignature, public
//
//  Synopsis:   Initializes the signature at the start and end of the page.
//
//  History:    ?       KyleP        Created
//
//----------------------------------------------------------------------------

void CSmartBuffer::InitSignature()
{
    _pBuffer[0] = _pBuffer[SMARTBUF_PAGE_SIZE_IN_DWORDS + 1] = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::Refill, public
//
//  Synopsis:   Makes sure the given page is borrowed and ready to go
//
//  Arguments:  [numPage]  -- The page requested
//
//  History:    11/6/98   dlee      Added Header
//
//----------------------------------------------------------------------------

void CSmartBuffer::Refill( ULONG numPage )
{
    if ( 0 != _pBuffer &&
         _fWritable &&
         _phStorage.RequiresFlush( _numPage ) )
    {
        IncrementSig();
    }

    // first borrow next, then return previous to avoid reloading

    ULONG * pOld = _pBuffer;
    unsigned numOldPage = _numPage;
    _pBuffer = _phStorage.BorrowBuffer( numPage, _fWritable, _fWritable );
    _numPage = numPage;

    if ( 0 != pOld )
        _phStorage.ReturnBuffer( numOldPage, _fWritable );

    Win4Assert( 0 != _pBuffer );

    // increment signature

    if ( _fWritable )
        IncrementSig();

    CheckCorruption();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::Next, public
//
//  Synopsis:   Makes sure the next page is borrowed and ready to go
//
//  History:    11/6/98   dlee      Added Header
//
//----------------------------------------------------------------------------

ULONG* CSmartBuffer::Next()
{
    Win4Assert( 0 != _pBuffer );

    if ( 0 != _pBuffer &&
         _fWritable &&
         _phStorage.RequiresFlush( _numPage ) )
        IncrementSig();

    ULONG * pOld = _pBuffer;

    // first borrow next, then return previous to avoid reloading

    _pBuffer = _phStorage.BorrowBuffer( _numPage+1, _fWritable, _fWritable );
    _numPage++;

    if ( 0 != pOld )
        _phStorage.ReturnBuffer( _numPage-1, _fWritable );

    Win4Assert( 0 != _pBuffer );

    if ( _fWritable )
        IncrementSig();

    CheckCorruption();

    return _pBuffer + 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::NextNew, public
//
//  Synopsis:   Makes sure the next page is borrowed and ready to go
//
//  History:    11/6/98   dlee      Added Header
//
//----------------------------------------------------------------------------

ULONG* CSmartBuffer::NextNew()
{
    Win4Assert( 0 != _pBuffer );

    if ( _fWritable && _phStorage.RequiresFlush( _numPage ) )
        IncrementSig();

    // first borrow next, then return previous to avoid reloading

    _pBuffer = _phStorage.BorrowNewBuffer(_numPage+1);
    _numPage++;
    Win4Assert ( _pBuffer != 0 );
    _phStorage.ReturnBuffer( _numPage-1, _fWritable );

    if ( _fWritable )
        IncrementSig();

    #if CIDBG == 1
    CheckCorruption();
    #endif

    return _pBuffer + 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartBuffer::Free, public
//
//  Synopsis:   Frees the current page if and only if the underlying storage
//              is writable.  Useful for master merges where we want to
//              unmap the old master index so it can be made sparse.
//
//  History:    11/6/98   dlee      Added Header
//
//----------------------------------------------------------------------------

void CSmartBuffer::Free()
{
    //
    // Only free the buffer if the stream (not necessarily the buffer)
    // is writable, so the stream can be shrunk from the front during a
    // master merge.
    //

    Win4Assert( _phStorage.IsWritable() );

    if ( 0 != _pBuffer )
    {
        if ( _fWritable && _phStorage.RequiresFlush( _numPage ) )
            IncrementSig();

        _phStorage.ReturnBuffer( _numPage, _fWritable );
        _pBuffer = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::CBitStream, public
//
//  Synopsis:   Constructor. Does not load pages.
//
//  Arguments:  [physIndex] -- Physical index -- source of pages
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------
CBitStream::CBitStream(CPhysStorage& phStorage, CSmartBuffer::EAccessMode mode )
        : _buffer(phStorage, mode),
          _oBuffer( 0 )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CPBitStream::CPBitStream, public
//
//  Synopsis:   Constructor. Does not load any pages.
//
//  Arguments:  [physIndex] -- Physical index -- source of pages
//
//  History:    02-Sep-92       BartoszM        Created
//
//----------------------------------------------------------------------------

CPBitStream::CPBitStream(CPhysStorage& phStorage)
: CBitStream ( phStorage, CSmartBuffer::eWriteExisting )

{
    _bitOff.SetPage(0);
    _bitOff.SetOff(0);
    ciDebugOut (( DEB_BITSTM, "CPBitStream::CPBitStream\n" ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::CBitStream, public
//
//  Synopsis:   Constructor. Starts at the beginning of index
//
//  Arguments:  [physIndex] -- Physical index -- source of pages
//
//  History:    08-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CBitStream::CBitStream(CPhysStorage& phStorage, BOOL fCreate)
        : _buffer(phStorage, fCreate),
          _oBuffer( 0 )

{
    ciDebugOut (( DEB_BITSTM, "CBitStream::CBitStream\n" ));

    _pCurPos = _buffer.Get();
    _pEndBuf = _pCurPos + SMARTBUF_PAGE_SIZE_IN_DWORDS;
    _cbitLeftDW = ULONG_BITS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::CBitStream, public
//
//  Synopsis:   Constructor.  Seek to a specified position.
//
//  Arguments:  [physIndex] -- Physical index -- source of pages
//              [off]  -- starting bit offset
//              [mode] -- Check access mode
//              [fIncrSig] -- Indicates if signature has to be incremented.
//
//  History:    08-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CBitStream::CBitStream(CPhysStorage& phStorage,
                       const BitOffset& off,
                       CSmartBuffer::EAccessMode mode,
                       BOOL fIncrSig )
        : _buffer(phStorage, off.Page(), mode, fIncrSig),
          _oBuffer( 0 )

{
    ciDebugOut(( DEB_BITSTM, "CBitStream::CBitStream %d:%d\n",
                 off.Page(), off.Offset() ));
    SetPosition(off.Offset());
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::LoadNextPage, private
//
//  Synopsis:   Loads next page, positions stream at its beginning
//
//  Requires:   Page must already exits
//
//  History:    28-Aug-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CBitStream::LoadNextPage()
{
    _pCurPos = _buffer.Next();
    _pEndBuf = _pCurPos + SMARTBUF_PAGE_SIZE_IN_DWORDS;
    _cbitLeftDW = ULONG_BITS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::LoadNewPage, private
//
//  Synopsis:   Creates and loads new page following the current one
//              Positions stream at its beginning
//
//  History:    28-Aug-92   BartoszM    Created.
//
//  Notice:     Page should be zero filled
//
//----------------------------------------------------------------------------

void CBitStream::LoadNewPage()
{
    _pCurPos = _buffer.NextNew();
    _pEndBuf = _pCurPos + SMARTBUF_PAGE_SIZE_IN_DWORDS;
    _cbitLeftDW = ULONG_BITS;

#if CIDBG == 1
    ULONG* p = _buffer.Get();
    for (int i=0; i < SMARTBUF_PAGE_SIZE_IN_DWORDS; i++)
        if (p[i] != 0)
            break;
    Win4Assert(i == SMARTBUF_PAGE_SIZE_IN_DWORDS);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   Refill
//
//  Synopsis:   Invalidates the currently cached copy and gets a new
//              copy of the buffer. This is needed during master merge
//              because we unmap the buffer before flushing and it is
//              possible that the re-mapped buffer may be in a physically
//              different location.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CBitStream::Refill()
{
    BitOffset bitOff;
    GetOffset(bitOff);

    _buffer.Refill(bitOff.Page());
    SetPosition( bitOff.Offset() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::SetPosition, private
//
//  Synopsis:   Set bit position within a freshly loaded page
//
//  Arguments:  [off] -- number of bits to skip
//
//  History:    28-Aug-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CBitStream::SetPosition(ULONG off)
{
    Win4Assert( off < SMARTBUF_PAGE_SIZE_IN_BITS );

    Win4Assert( !_buffer.isEmpty() );

    //ciDebugOut (( DEB_BITSTM, "SetPosition %d\n", off ));
    _pCurPos = _buffer.Get() + off / ULONG_BITS;
    _pEndBuf = _buffer.Get() + SMARTBUF_PAGE_SIZE_IN_DWORDS;
    _cbitLeftDW = ULONG_BITS - ( off - ULONG_BITS * ( off / ULONG_BITS ) );

    Win4Assert ( Position() == off );
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::CBitStream, public
//
//  Synopsis:   Copy Constructor (with pb as a clone of _pBuffer).
//
//  Arguments:  [pb] -- Pointer to memory for buffer.
//
//              [orig] -- Original CBitStream to be copied.
//
//  History:    13-Jan-92   AmyA        Created.
//
//----------------------------------------------------------------------------

CBitStream::CBitStream(CBitStream & orig)
      : _buffer(orig._buffer, orig._buffer.PageNum()),
        _cbitLeftDW(orig._cbitLeftDW),
        _oBuffer( 0 )

{
    _pCurPos = _buffer.Get() + ( orig._pCurPos - orig._buffer.Get() );
    _pEndBuf = _buffer.Get() + SMARTBUF_PAGE_SIZE_IN_DWORDS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPBitStream::OverwriteBits, public
//
//  Synopsis:   Store bits in the buffer. This call doesn't affect
//              surrounding bits.
//
//  Effects:    OR the [cb] low bits in [ul] beginning at the 'bit-cursor'
//
//  Arguments:  [ul] -- A DWord containing data to store.
//
//              [cb] -- The number of bits to store.
//
//  History:    18-Jul-91   KyleP       Created.
//              02-Sep-92   BartoszM    Rewrote for lazy paging
//
//  Notes:      Bits are stored 'big-endian'.
//
//----------------------------------------------------------------------------

void CPBitStream::OverwriteBits(ULONG ul, unsigned cb)
{
    ciDebugOut (( DEB_BITSTM , "OverwriteBits %d\n", cb ));
    Win4Assert(cb != 0 && cb <= ULONG_BITS);

    // Fault in the page if necessary
    if ( _buffer.isEmpty() || _buffer.PageNum() != _bitOff.Page())
    {
        _buffer.Refill(_bitOff.Page());
    }

    SetPosition(_bitOff.Offset());

    //
    // The easy case is the one where all the data fits in the current dword
    //

    if (cb <= _cbitLeftDW)
    {
        // this much will be left after current write
        _cbitLeftDW -= cb;

        // zero out a segment within current dword
        // first create a mask of cb bits by (ULONG_BITS - cb) shift right
        // then shift this mask left by the number of bits to be left

        *_pCurPos &= ~((0xFFFFFFFF >> (ULONG_BITS - cb)) << _cbitLeftDW);

        // shift ul left by the number of bits to be left
        *_pCurPos |= (ul << _cbitLeftDW);

        // prepare for the next write
        _bitOff += cb;

        Win4Assert( _bitOff.Offset() < SMARTBUF_PAGE_SIZE_IN_BITS );
    }
    else
    {
        IOverwriteBits( ul, cb );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWBitStream::IPutBits, private
//
//  Synopsis:   Store bits in the buffer. Internal version for multi-dword
//              case.
//
//  Effects:    Store the [cb] low bits in [ul] beginning at the 'bit-cursor'
//
//  Arguments:  [ul] -- A DWord containing data to store.
//
//              [cb] -- The number of bits to store.
//
//  History:    08-Jul-91   KyleP       Created.
//
//  Notes:      Bits are stored 'big-endian'.
//
//----------------------------------------------------------------------------

void CWBitStream::IPutBits(ULONG ul, unsigned cb)
{
    Win4Assert ( cb > _cbitLeftDW );

//    ciDebugOut (( DEB_BITSTM, "IPutBits %d\n", cb ));
    if ( _cbitLeftDW != 0 )
    {
        Win4Assert ( _pCurPos < EndBuf() );
        //
        // Save the high portion in the current dword and save the
        // number of unwritten bits in cb
        //

        cb -= _cbitLeftDW;
        *_pCurPos |= (ul >> cb);
    }

    //
    // Increment to the next dword
    //

    NextDword();

    //
    // Store the remainder
    //

    _cbitLeftDW -= cb;
    *_pCurPos = ul << _cbitLeftDW;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWBitStream::ZeroToEndOfPage, public
//
//  Synopsis:   Writes zeros from the current bit offset to ther end of the
//              page.
//
//  History:    22-Apr-94   DwightKr    Created.
//
//  Notes:      Bits are stored 'big-endian'.
//
//----------------------------------------------------------------------------
void CWBitStream::ZeroToEndOfPage()
{
    ULONG * pCurPos = _pCurPos;

    if ( (_cbitLeftDW != 0) && (_cbitLeftDW != 32) )
    {
        *pCurPos &= (0xFFFFFFFF << _cbitLeftDW);
         pCurPos++;
    }

    RtlZeroMemory( pCurPos, (EndBuf() - pCurPos) * sizeof(ULONG));
}

void CWBitStream::InitSignature()
{
    _buffer.InitSignature();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPBitStream::IOverwriteBits, private
//
//  Synopsis:   Store bits in the buffer. This call doesn't affect
//              surrounding bits.
//
//  Effects:    OR the [cb] low bits in [ul] beginning at the 'bit-cursor'
//
//  Arguments:  [ul] -- A DWord containing data to store.
//
//              [cb] -- The number of bits to store.
//
//  History:    18-Jul-91   KyleP       Created.
//
//  Notes:      Bits are stored 'big-endian'.
//
//----------------------------------------------------------------------------

void CPBitStream::IOverwriteBits(ULONG ul, unsigned cb)
{
    Win4Assert ( cb > _cbitLeftDW );

    // prepare for next write
    _bitOff += cb;

    Win4Assert( _bitOff.Offset() < SMARTBUF_PAGE_SIZE_IN_BITS );

    if ( _cbitLeftDW > 0 )
    {
        Win4Assert ( _pCurPos < EndBuf() );
        // zero the remaining bits in the current dword
        *_pCurPos &= 0xFFFFFFFF << _cbitLeftDW;
        // this much will go to the next dword
        cb -= _cbitLeftDW;
        // shift away the part that goes to the next dword
        // and or in the rest
        *_pCurPos |= (ul >> cb);
    }

    //
    // Increment to the next dword
    //

    NextDword();
    //
    // Store the remainder
    //

    Win4Assert( cb <= ULONG_BITS );

    if ( cb == ULONG_BITS )
    {
        *_pCurPos = ul;
    }
    else
    {
        // zero the cb upper bits of the current dword
        *_pCurPos &= (0xFFFFFFFF >> cb);
        // fill them with cb bits from the bottom of ul
        *_pCurPos |= ul << (ULONG_BITS - cb);
    }
}

const ULONG g_aMasks[33] =
{
    0,
    0x1,
    0x3,
    0x7,
    0xf,
    0x1f,
    0x3f,
    0x7f,
    0xff,
    0x1ff,
    0x3ff,
    0x7ff,
    0xfff,
    0x1fff,
    0x3fff,
    0x7fff,
    0xffff,
    0x1ffff,
    0x3ffff,
    0x7ffff,
    0xfffff,
    0x1fffff,
    0x3fffff,
    0x7fffff,
    0xffffff,
    0x1ffffff,
    0x3ffffff,
    0x7ffffff,
    0xfffffff,
    0x1fffffff,
    0x3fffffff,
    0x7fffffff,
    0xffffffff,
};

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::IGetBits, public
//
//  Synopsis:   Retrieve bits from the buffer. Internal version for multi-
//              dword case.
//
//  Arguments:  [cb] -- Count of bits to retrieve.
//
//  History:    12-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CBitStream::IGetBits(unsigned cb)
{
    Win4Assert ( cb > _cbitLeftDW );

    //ciDebugOut (( DEB_BITSTM, "IGetBits %d\n", cb ));

    //
    // Get the portion from the current DWord
    //

    ULONG ul;

    if ( 0 != _cbitLeftDW )
    {
        const ULONG mask = g_aMasks[ cb ];
        cb -= _cbitLeftDW;
        ul = (*_pCurPos << cb) & mask;
    }
    else
        ul = 0L;

    //
    // And the portion from the next.
    //

    NextDword();

    _cbitLeftDW -= cb;
    return ul | (*_pCurPos >> (ULONG_BITS - cb));
} //IGetBits

//+---------------------------------------------------------------------------
//
//  Member:     CWBitStream::PutBytes, public
//
//  Synopsis:   Store a number of bytes in the buffer.
//
//  Arguments:  [pb] -- Pointer to data to store.
//
//              [cb] -- Number of bytes to store.
//
//  History:    08-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CWBitStream::PutBytes(const BYTE * pb, unsigned cb)
{
//    ciDebugOut (( DEB_BITSTM, "IPutBytes %d\n", cb ));

    while (cb > 0)
    {
        PutBits(*pb, 8);
        pb += 1;
        cb--;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::GetBytes, public
//
//  Synopsis:   Retrieve bytes from the buffer.
//
//  Arguments:  [pb] -- Pointer to area where data is returned.
//
//              [cb] -- Count of bytes to retrieve.
//
//  History:    12-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CBitStream::GetBytes(BYTE * pb, unsigned cb)
{
    ciDebugOut (( DEB_BITSTM, "GetBytes %d\n", cb ));

    while (cb > 0)
    {
        *pb = BYTE ( GetBits(8) );
        pb++;
        cb--;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CBitStream::Seek, public
//
//  Synopsis:   Seeks to the specified bit offset
//
//  Arguments:  [off] -- bit offset
//
//  History:    28-Aug-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CBitStream::Seek ( const BitOffset& off )
{
    ciDebugOut (( DEB_BITSTM , "CBitStream::Seek %d:%d\n",
        off.Page(), off.Offset()  ));

    if (_buffer.PageNum() != off.Page())
    {
        _buffer.Refill(off.Page());
    }

    SetPosition(off.Offset());
}

#if CIDBG == 1

unsigned CBitStream::PeekBit()
{
    if (_cbitLeftDW > 0)
    {
        ULONG ul = *_pCurPos;
        return( ul >> (_cbitLeftDW - 1)) & 1;
    }
    else
    {
        ULONG* pNewPos = _pCurPos + 1;
        if (pNewPos < EndBuf())
        {
            return(*pNewPos >> (ULONG_BITS-1));
        }
        else
        {
            Win4Assert ( 0 && "Untested" );
            CSmartBuffer bufTmp( _buffer, _buffer.PageNum() + 1 );

            ULONG* p = bufTmp.Get();
            unsigned bit = *p >> (ULONG_BITS-1);
            return(bit);
        }
    }
}

unsigned CPBitStream::PeekBit()
{
    // Fault in the page if necessary

    if (_buffer.isEmpty() || _buffer.PageNum() != _bitOff.Page())
        _buffer.Refill(_bitOff.Page());

    SetPosition(_bitOff.Offset());

    return CBitStream::PeekBit();
}

void DumpDword ( ULONG* pul )
{
    ULONG ul = *pul;

    for (int i = ULONG_BITS-1; i >= 0; i--)
    {
        ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME,"%0d", (ul >> i) & 1 ));
        if (i %4 == 0)
            ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME," " ));
    }
    ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME,"\n" ));
}

void CBitStream::Dump()
{
    ciDebugOut (( DEB_ITRACE, "CBitStream:\n"
    "\tpage %d\n"
    "\t_pCurPos 0x%x dwords from beginning\n"
    "\t_cbitLeftDW %d\n",
        _buffer.PageNum(), _pCurPos - _buffer.Get(), _cbitLeftDW ));

    if (_pCurPos > _buffer.Get())
        DumpDword ( _pCurPos - 1 );
    if (_pCurPos < EndBuf())
    {
        DumpDword ( _pCurPos );
        for (unsigned i = 1; i <= ULONG_BITS - _cbitLeftDW; i++ )
        {
            ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME," " ));
            if (i %4 == 0)
                ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME," " ));
        }
        ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME,"^\n" ));
    }
    if (_pCurPos + 1 < EndBuf())
        DumpDword(_pCurPos + 1);
}

void CPBitStream::Dump()
{
    // Fault in the page if necessary
    if (_buffer.isEmpty() || _buffer.PageNum() != _bitOff.Page())
    {
        _buffer.Refill(_bitOff.Page());
    }

    SetPosition(_bitOff.Offset());

    CBitStream::Dump();
}

#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\afwwork.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       afwwork.cxx
//
//  Contents:   A generic asynchronous work item for use in CI framework.
//
//  Classes:    CFwAsyncWorkItem
//
//  History:    2-26-96   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include "afwwork.hxx"
#include "resman.hxx"

#if 0

//
// We have this as a model to write code for the async work item.
//
//+---------------------------------------------------------------------------
//
//  Member:     CFwEnableUpdates::DoIt
//
//  Synopsis:   The main processing routine for enabling updates.
//
//  Arguments:  [pThread] - 
//
//  History:    12-10-96   srikants   Created
//
//----------------------------------------------------------------------------

void CFwEnableUpdates::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    ciDebugOut(( DEB_ITRACE,
       "CFwEnableUpdates::DoIt(). Enabling Updates in DocStore\n" ));

    _pIDocStore->EnableUpdates();
    _pIDocStore->Release();
    _pIDocStore = 0;

    Done();
    Release();
    // --------------------------------------------------------
}

#endif   // 0

//+---------------------------------------------------------------------------
//
//  Member:     CFwFlushNotify::DoIt
//
//  Synopsis:   Calls the ProcessFlushNotifies() method on the CCiManager
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CFwFlushNotify::DoIt( CWorkThread * pThread )
{
    // ====================================
    {
        CLock   lock(_mutex);
        _fOnWorkQueue = FALSE;
    }
    // ====================================

    // --------------------------------------------------------
    AddRef();

    ciDebugOut(( DEB_ITRACE,
       "CFwFlushNotify::DoIt(). Giving Flush Notification \n" ));

    _resMan.ProcessFlushNotifies();

    Done();
    Release();
    // --------------------------------------------------------
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\cibackup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cibackup.cxx
//
//  Contents:   Content Index index migration
//
//  Classes:    
//
//  History:    3-17-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>
#include <pidxtbl.hxx>

#include "cibackup.hxx"
#include "resman.hxx"
#include "indsnap.hxx"
#include "partn.hxx"
#include "fresh.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiWorkItem::CBackupCiWorkItem
//
//  Synopsis:   Constructor of the backup save work item.
//
//  Arguments:  [storage]         - Destination storage object.
//              [fFullSave]       - Indicating if a full save is needed.
//              [progressTracker] - Progress tracking object.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

CBackupCiWorkItem::CBackupCiWorkItem( PStorage & storage,
                                      BOOL fFullSave,
                                      PSaveProgressTracker & progressTracker )
: _status(STATUS_UNSUCCESSFUL),
  _storage(storage),
  _fFull(fFullSave),
  _progressTracker(progressTracker),
  _fDoingFull(FALSE),
  _backupState(eNotStarted)
{
    _evtDone.Reset();
}

//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiPersData::CBackupCiPersData
//
//  Synopsis:   An object that backups the relevant CI persistent data.
//
//  Arguments:  [workItem] - The workitem having details of the save operation.
//              [resman]   - Resman reference.
//              [partn]    - The partition that must be saved.
//
//  History:    3-18-97   srikants   Created
//
//  Notes:      We are assuming that changelog need not be saved. This is
//              certainly true for the Incremental Index Shipping feature of
//              Normandy.
//
//              We are also assuming that for an incremental save, the
//              destination has the same master index id as this. This
//              assumption allows us to save the index table and the
//              persistent freshlog without any transformation. If the
//              destination misses even one "full" save in a sequence,
//              a full save MUST be done.
//
//              These limitations can be removed when KyleP does the complete
//              implementation of incremental indexing.
//
//----------------------------------------------------------------------------


CBackupCiPersData::CBackupCiPersData(
                                CBackupCiWorkItem & workItem,
                                CResManager & resman,
                                CPartition & partn )
 : _workItem( workItem ),
   _pIndSnap( 0 ),
   _resman( resman ),
   _partn(partn),
   _indexTable( resman.GetIndexTable() ),
   _fresh( resman.GetFresh() )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiPersData::~CBackupCiPersData
//
//  Synopsis:   Destroys the saved index snap shot.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

CBackupCiPersData::~CBackupCiPersData()
{
    delete _pIndSnap;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiPersData::LokGrabResources
//
//  Synopsis:   Grabs the persistent indexes that must be backed up.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CBackupCiPersData::LokGrabResources()
{
    //
    // First Create a new Index SnapShot depending upon the
    // type of backup.
    //
    Win4Assert( 0 == _pIndSnap );
    _pIndSnap = new CIndexSnapshot( _resman );
    _pIndSnap->LokInitForBackup( _partn, _workItem.IsFullSave() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiPersData::BackupIndexes
//
//  Synopsis:   Backs up the relevant persistent indexes.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CBackupCiPersData::BackupIndexes()
{
    //
    // For each index in the snapshot, create a backup copy.
    //
    unsigned cInd;
    CIndex ** apIndexes = _pIndSnap->LokGetIndexes( cInd );

    Win4Assert( cInd <= 1 );

    for ( unsigned i = 0; i < cInd; i++ )
    {

        Win4Assert( apIndexes[i]->IsPersistent() );

        PStorage::EDefaultStrmType strmType = PStorage::eNonSparseIndex;
        WORKID wid = _workItem.GetStorage().CreateObjectId( apIndexes[i]->GetId(),
                                                            strmType );
        apIndexes[i]->MakeBackupCopy( _workItem.GetStorage(),
                                      wid,
                                      _workItem.GetSaveProgressTracker() );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBackupCiPersData::LokBackupMetaInfo
//
//  Synopsis:   Backs up the persistent fresh log and the index table.
//              Also collects the workids in the fresh log to indicate the
//              changed workid.
//
//  Arguments:  [aWids] - On output, will have the modified list of workids.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CBackupCiPersData::LokBackupMetaInfo()
{

    _fresh.LokMakeFreshLogBackup( _workItem.GetStorage(),
                                  _workItem.GetSaveProgressTracker(),
                                  _workItem.GetWorkidsIf() );

    //
    // Create a backup of the Index Table.
    //
    _indexTable.LokMakeBackupCopy( _workItem.GetStorage(),
                                   _workItem.IsFullSave(),
                                   _workItem.GetSaveProgressTracker() );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\ci.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CI.CXX
//
//  Contents:   Main Content Index class methods
//
//  Classes:    CContentIndex - Main content index class
//              CCI           - Exports content index
//
//  History:    21-Aug-91   KyleP       Added CCI
//              26-Feb-91   KyleP       Created stubs
//              25-Mar-91   BartoszM    Implemented
//              03-Nov-93   w-PatG      Added KeyList methods
//              03-Jan-95   BartoszM    Separated Filter Manager
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cci.hxx>
#include <curstk.hxx>
#include <convert.hxx>
#include <qparse.hxx>
#include <heap.hxx>
#include <pidmap.hxx>
#include <pidxtbl.hxx>
#include <eventlog.hxx>
#include <cievtmsg.h>

#include "ci.hxx"
#include "partn.hxx"
#include "fretest.hxx"
#include "freshcur.hxx"
#include "unioncur.hxx"
#include "widarr.hxx"
#include "index.hxx"

#if CIDBG == 1
void SetGlobalInfoLevel ( ULONG level )
{
    _SetWin4InfoLevel(level);
}
#endif // CIDBG == 1

#define AssertOnNotFound(status) Win4Assert((status) != STATUS_NOT_FOUND)

ULONG ciDebugGlobalFlags = 0;

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::CContentIndex, public
//
//  Synopsis:   Content index constructor.
//
//  Effects:    Creates a content index object.
//
//  Arguments:  [storage] -- Storage object
//              [xact]    -- startup transaction
//              [xIndexNotifTable] -- Table of notifications in push filtering
//
//  History:    21-Aug-91   KyleP       Removed unused path member
//              26-Feb-91   KyleP       Created.
//              01-Apr-91   BartoszM    Implemented
//
//----------------------------------------------------------------------------

CContentIndex::CContentIndex( PStorage &storage,
                              CCiFrameworkParams & params,
                              ICiCDocStore * pICiCDocStore,
                              CI_STARTUP_INFO const & startupInfo,
                              IPropertyMapper * pIPropertyMapper,
                              CTransaction& xact,
                              XInterface<CIndexNotificationTable> & xIndexNotifTable )
    :   _storage (storage),
        _resman ( storage,
                  params,
                  pICiCDocStore,
                  startupInfo,
                  pIPropertyMapper,
                  xact,
                  xIndexNotifTable ),
        _filterMan ( _resman )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::ReserveUpdate, public
//
//  Synopsis:   Reserves slot for pending update.
//
//  Arguments:  [wid] -- work id.  Used for confirmation of hint.
//
//  Returns:    Hint.  Used in CConentIndex::Update to speed processing.
//
//  History:    30-Aug-95   KyleP       Created
//
//----------------------------------------------------------------------------

unsigned CContentIndex::ReserveUpdate( WORKID wid )
{
    return _resman.ReserveUpdate( wid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::Update, public
//
//  Synopsis:   Notifies the content index of document update/deletion.
//
//  Effects:    Schedules document for
//              indexing. This method is also called to add new documents
//              (a special case of update).
//
//  Arguments:  [iHint]    -- Cookie representing unique position in queue.
//              [wid]      -- work id
//              [partid]   -- Partition id
//              [usn]      -- unique sequence number
//              [volumeId] -- Volume id
//              [action]   -- update/delete
//
//  History:    08-Oct-93   BartoszM    Created
//
//----------------------------------------------------------------------------
SCODE CContentIndex::Update( unsigned iHint,
                             WORKID wid,
                             PARTITIONID partid,
                             USN usn,
                             VOLUMEID volumeId,
                             ULONG action )
{
    return _resman.UpdateDocument ( iHint, wid, partid, usn, volumeId, action );
}


//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::Query, public
//
//  Synopsis:   Resolves a free-text query.
//
//  Effects:    Parses a free text query and creates a tree of cursors to
//              resolve the query.
//
//  Arguments:  [pRst]   -- Pointer to tree of query restriction(s)
//
//              [pFlags] -- Holds information about the status of the query
//
//              [cPartitions] -- The number of partitions in aPartID.
//
//              [aPartID] -- Array of partitionIDs specifying partitions
//                          to be searched.
//
//              [cPendingUpdates] -- A non-zero value here will return pending
//                  updates in addition to whatever values match the query.
//                  If more than cPendingUpdates exist in any single partition,
//                  then the CI_NOT_UP_TO_DATE flag will be set.
//
//              [cMaxNodes] -- Maximum expansion for query.  Roughly counted
//                  in terms of leaf query nodes.
//
//  Requires:   All partitions in aPartID are valid.
//
//  Returns:    A cursor to iterate over the results
//
//  Modifies:   pFlags will be modified to reflect the status of the query
//
//  History:    19-Sep-91   BartoszM    Created.
//              08-Sep-92   AmyA        Added pFlags functionality
//
//----------------------------------------------------------------------------

CCursor* CContentIndex::Query( CRestriction const * pRst,
                               ULONG* pFlags,
                               UINT cPartitions,
                               PARTITIONID aPartId[],
                               ULONG cPendingUpdates,
                               ULONG cMaxNodes )
{
    CCursor* pCurResult = 0;

    ciDebugOut (( DEB_ITRACE, "CContentIndex::Query\n" ));

    *pFlags = 0;  // any incoming information should have been obtained already

    if ( pRst == 0 )
    {
        *pFlags |= CI_NOISE_PHRASE;
    }

    //
    // Acquire resources from resman
    //

    CIndexSnapshot indSnap ( _resman );

    indSnap.Init ( cPartitions, aPartId, cPendingUpdates, pFlags );

    unsigned cInd = indSnap.Count();

    CCurStack curStack(cInd);

    //
    // If all the cursors against all persistent indexes only have unfiltered files,
    // mark the resulting cursor as only containing unfiltered files.
    //
    BOOL fUnfilteredOnly = TRUE;

    for ( unsigned i = 0; i < cInd; i++ )
    {
        CConverter convert ( indSnap.Get(i), cMaxNodes );
        XCursor xCur( convert.QueryCursor ( pRst ) );

        if ( !xCur.IsNull() )
        {
            if( !xCur->IsUnfilteredOnly() )
            {
                fUnfilteredOnly = FALSE;
            }
            curStack.Push( xCur.GetPointer() );
            xCur.Acquire();
        }
        else if ( convert.TooManyNodes() )
        {
            *pFlags |= CI_TOO_MANY_NODES;
            return 0;
        }

    }

    XCursor curResult;

    unsigned cCur = curStack.Count();

    ciDebugOut((DEB_FILTERWIDS,
               "cCur == %d, indSnap.Count() == %d\n",
               cCur, indSnap.Count() ));
    if ( cCur > 1 )
    {
        curResult.Set( new CUnionCursor ( cCur, curStack ) );
    }
    else if ( cCur == 1 )
    {
        curResult.Set( curStack.Pop() );
    }

    // Acquires resources from index snapshot

    if ( !curResult.IsNull() )
    {
        curResult.Set( new CFreshCursor ( curResult, indSnap ) );

        //
        // OR in cursors for pending updates, but only if we have some real updates
        // to augment.  Performing this action in the absence of real updates will
        // make a query over an unindexed property appear to be indexed.
        //

        if ( cPendingUpdates > 0 )
        {
            indSnap.AppendPendingUpdates( curResult );

            Win4Assert( curStack.Count() == 0 );
        }

        curResult->SetUnfilteredOnly( fUnfilteredOnly );
    }

    return( curResult.Acquire() );
}

NTSTATUS CContentIndex::Dismount()
{
    _resman.Dismount();
    return  _filterMan.Dismount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::FilterReady, public
//
//  Synopsis:   Retrieves list of documents to be filtered.  Blocks thread if
//              resources are not available or if there are no documents to
//              be filtered.
//
//  Arguments:  [docBuffer] -- (in, out) buffer for paths and properties of
//                             documents to be filtered.
//              [cwc] -- (in) count of WCHAR's in docBuffer
//              [cMaxDocs] -- (in) the maximum number of docs that can be
//                            filtered at once by the filter daemon.
//
//  History:    18-Apr-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CContentIndex::FilterReady ( BYTE * docBuffer,
                                   ULONG & cb,
                                   ULONG cMaxDocs )
{
    return _filterMan.FilterReady( docBuffer, cb, cMaxDocs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::FilterDataReady, public
//
//  Synopsis:   Adds the contents of entry buffer to the current word list.
//
//  Returns:    Whether Word List is full
//
//  Arguments:  [pEntryBuf] -- pointer to data to be added to word list
//              [cb] -- count of bytes in buffer
//
//  History:    22-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CContentIndex::FilterDataReady( const BYTE * pEntryBuf, ULONG cb )
{
    return _filterMan.FilterDataReady( pEntryBuf, cb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::FilterMore, public
//
//  Synopsis:   Commits the current word list and initializes a new one.
//
//  Arguments:  [aStatus] -- array of STATUS for the resource manager
//              [count] -- count for array
//
//  History:    03-May-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CContentIndex::FilterMore( const STATUS * aStatus, ULONG count )
{
    return( _filterMan.FilterMore( aStatus, count ) );
}

SCODE CContentIndex::FilterStoreValue(
    WORKID widFake,
    CFullPropSpec const & ps,
    CStorageVariant const & var,
    BOOL & fStored )
{
    return _filterMan.FilterStoreValue( widFake, ps, var, fStored );
}

SCODE CContentIndex::FilterStoreSecurity(
    WORKID widFake,
    PSECURITY_DESCRIPTOR pSD,
    ULONG cbSD,
    BOOL & fStored )
{
    return _filterMan.FilterStoreSecurity( widFake, pSD, cbSD, fStored );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::FilterDone, public
//
//  Synopsis:   Commits the current word list.
//
//  Arguments:  [aStatus] -- array of STATUS for the resource manager
//              [count] -- count for array
//
//  History:    26-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CContentIndex::FilterDone( const STATUS * aStatus, ULONG count )
{
    return( _filterMan.FilterDone( aStatus, count ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC property to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC representation of property
//              [pid] -- PROPID written here on success
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997  KyleP      Created.
//
//----------------------------------------------------------------------------

SCODE CContentIndex::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    return _filterMan.FPSToPROPID( fps, pid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::CreatePartition, public
//
//  Synopsis:   Create a new partition in the content index.
//
//  Effects:    Stores persistent information about the new partition and
//              creates a new partition object.
//
//  Arguments:  [partID] -- ID of new partition. Further references to the new
//                            partition must use [partID].
//
//  Requires:   [partID] is not the ID of any existing partition.
//
//  Signals:    CPartitionException
//
//  History:    26-Feb-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CContentIndex::CreatePartition( PARTITIONID partID )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::DestroyPartition, public
//
//  Synopsis:   Destroys a content index partition and all data within it.
//
//  Effects:    This is a very powerful call. All document data stored in
//              the destroyed partition is permanently lost. The MergePartitions
//              method is a more common method of getting rid of a partition.
//
//  Arguments:  [partID] -- ID of partition to be destroyed.
//
//  Signals:    CPartitionException
//
//  History:    26-Feb-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CContentIndex::DestroyPartition(PARTITIONID partID)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::MergePartitions, public
//
//  Synopsis:   Merges one partition into another.
//
//  Effects:    Merges all documents in [partSrc] into [partDest] and then
//      deletes [partSrc]. Note that although the merge may be
//              carried out asyncronously the effects of the merge are
//              immediately visible (references to [partDest] will map to
//              [partDest] and [partSrc]).
//
//  Arguments:  [partDest] -- Partition into which [partSrc] is merged.
//
//      [partSrc] -- Partition which is merged into [partDest].
//
//  Requires:   [partDest] and [partSrc] exist.
//
//  Signals:    CPartitionException
//
//  Modifies:   [partSrc] is no longer a valid reference in the content index.
//
//  Notes:  From the point of view of the content index, a partition is just
//              a collection of documents. The translation of partitions to
//      filesystem scope is performed at a higher level. Thus any
//      partition manipulation more complicated than a merge (such as
//              changing the scope of a partition) must be performed at a
//              higher level.
//
//      The content index must be notified about documents which move
//      from one partition to another as the result of rescoping but the
//      scope change must be translated at a higher level into
//      DeleteDocument and UpdateDocument calls.
//
//  History:    26-Feb-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CContentIndex::MergePartitions(
    PARTITIONID partDest,
    PARTITIONID partSrc)
{
}

#if CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::DebugStats, public
//
//  Synopsis:   Returns statistics on the use and composition of the CI.
//
//  Arguments:  [pciDebStats] -- Pointer to debug statistics structure.
//
//  Modifies:   The structure pointed at by pciDebStats is filled in with
//              the statistical information.
//
//  History:    26-Feb-91   KyleP       Created.
//
//  Notes:      This function is only avaliable in the debug version of the
//      content index.
//
//----------------------------------------------------------------------------

void CContentIndex::DebugStats(/* CIDEBSTATS *pciDebStats */)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::DebugDump, public
//
//  Synopsis:   Dumps a plain text representation of the content index.
//
//  Arguments:  [sOut] -- Output stream. A formatted representation of the
//                        content index is sent here.
//
//  Modifies:   Text is written to [sOut].
//
//  History:    26-Feb-91   KyleP       Created.
//
//  Notes:      This function is only avaliable in the debug version of the
//      content index.
//
//----------------------------------------------------------------------------

void CContentIndex::DumpIndexes( FILE * pf, INDEXID iid, ULONG fSummaryOnly )
{
        PARTITIONID partid = 1;
        CFreshTest * pfresh;
        unsigned cind;
        ULONG pFlags = 0;

        CIndex ** ppIndex =
            _resman.QueryIndexes( 1,            // One partition
                                  &partid,      // The partition
                                  &pfresh,      // Fresh test (unused)
                                  cind,         // # indexes.
                                  0,            // # pending updates
                                  0,            // curPending
                                  &pFlags );    // Still changes to do?

    for (int i = cind-1; i >= 0; i-- )
    {
        if ( 0 == iid || ppIndex[i]->GetId() == iid )
        {
        fprintf( pf, "\n\nIndex %lx:\n", ppIndex[i]->GetId() );

        ppIndex[i]->DebugDump( pf, fSummaryOnly );
        }
    }

    _resman.ReleaseIndexes( cind, ppIndex, pfresh );
    delete ppIndex;
}

//+---------------------------------------------------------------------------
//
//  Member:     CContentIndex::DumpWorkId, public
//
//  Synopsis:   Dumps a plain text representation of the content index for
//              a single wid.
//
//  Arguments:  [pb]  -- Buffer has bookmark on input, text on output.
//              [cb]  -- Size of [pb]
//
//  History:    30-Mar-95   KyleP       Created.
//
//  Notes:      Calling this API is a little convoluted.  Because it is
//              called via FSCTL for the kernel implementation, just
//              passing one huge buffer is difficult.  Instead, each
//              buffer of text is terminated with either a null dword
//              indicating completion or a bookmark of size sizeof(ULONG) +
//              sizeof(WORKID) + sizeof(CKeyBuf).  The initial ulong is
//              the control code to CContentIndex::Backdoor, followed
//              by the workid we're searching for, followed by the
//              key we should start up on.
//
//----------------------------------------------------------------------------

void CContentIndex::DumpWorkId( BYTE * pb, ULONG cb )
{
    //
    // Set up for iteration.
    //

    BYTE * pbTemp = pb;
    pbTemp += sizeof(ULONG);      // Skip command

    WORKID widLocate = *(WORKID UNALIGNED *)pbTemp;
    pbTemp += sizeof(WORKID);     // Skip workid

    ULONG  iidRequested = *(WORKID UNALIGNED *) pbTemp;
    pbTemp += sizeof(ULONG);

    //
    // This copy is "safe" because I know CKeyBuf doesn't contain
    // any data members that are pointers.
    //

    CKeyBuf keyStart;
    memcpy( &keyStart, pbTemp, sizeof(keyStart) );

    CKey * pkeyStart = 0;

    if ( keyStart.Count() != 0 )  // On initial call, count is zero
        pkeyStart = new CKey( keyStart );

    //
    // Compute space to write text.  Save enough to write bookmark (and "...\n")
    //

    char const szContinued[] = "... \n";
    char * psz = (char *)pb;
    int cc = cb - sizeof(ULONG) - sizeof(WORKID) - sizeof(CKeyBuf) - sizeof(szContinued);

    if ( cc <= 0 )
    {
        ciDebugOut(( DEB_ERROR,
                     "Buffer passed to CContentIndex::DumpWorkId too small for bookmark!\n" ));
        return;
    }

    //
    // Snapshot indices
    //

    PARTITIONID partid = 1;
    CFreshTest * pfresh;
    unsigned cind;
    ULONG pFlags = 0;

    CIndex ** ppIndex = _resman.QueryIndexes( 1,            // One partition
                                              &partid,      // The partition
                                              &pfresh,      // Fresh test (unused)
                                              cind,         // # indexes.
                                              0,            // # pending updates
                                              0,            // curPending
                                              &pFlags );    // Still changes to do?

    //
    // Loop through indices, looking for freshest.
    //

    int cbWritten = 0;

    for ( int i = cind-1; i >= 0; i-- )
    {
        if ( ( (0 == iidRequested) && pfresh->IsCorrectIndex( ppIndex[i]->GetId(), widLocate ) ) ||
             ( ppIndex[i]->GetId() == iidRequested )
           )
        {
            //
            // Header
            //

            if ( pkeyStart == 0 )
            {
                cbWritten = _snprintf( psz,
                                       cc,
                                       "Dump of wid %d (0x%x)\n"
                                       "Using index 0x%x\n\n",
                                       widLocate,
                                       widLocate,
                                       ppIndex[i]->GetId() );
                if ( cbWritten != -1 )
                {
                    psz += cbWritten;
                    cc -= cbWritten;
                }
            }

            //
            // pszStart is where we started writing the last key.  A key must
            // be written completely or we will try again in the next pass.
            //

            char * pszStart = psz;

            //
            // Get cursor, either from beginning or from bookmark.
            //

            CKeyCursor * pcur;
            CKeyBuf const * pkey = 0;

            if ( pkeyStart == 0 )
            {
                pcur = ppIndex[i]->QueryCursor();
                pkeyStart = new CKey( *pcur->GetKey() );
            }
            else
                pcur = ppIndex[i]->QueryKeyCursor( pkeyStart );

            //
            // I think pcur can be null, if indexes / keys shifted beneath us.
            //

            if ( pcur != 0 )
            {
                ciDebugOut(( DEB_ITRACE, "Scan on letter: " ));
                WCHAR FirstLetter = '@';

                for ( pkey = pcur->GetKey();
                      cbWritten != -1 && pkey != 0;
                      pkey = pcur->GetNextKey() )
                {
                    if ( *(pkey->GetStr()) != FirstLetter )
                    {
                        FirstLetter = *(pkey->GetStr());
                        ciDebugOut (( DEB_NOCOMPNAME | DEB_ITRACE, "%c", FirstLetter ));
                    }

                    //
                    // Search for specified wid.
                    //

                    for ( WORKID wid = pcur->WorkId(); wid < widLocate; wid = pcur->NextWorkId() )
                        continue;

                    //
                    // Print data for the key.
                    //

                    if ( wid == widLocate )
                    {
                        cbWritten = _snprintf( psz, cc, "Key: %.*ws  --   (PID = %lx)\n",
                                               pkey->StrLen(), pkey->GetStr(), pkey->Pid() );
                        if ( cbWritten != -1 )
                        {
                            psz += cbWritten;
                            cc -= cbWritten;
                        }

                        int i = 1;

                        for ( OCCURRENCE occ = pcur->Occurrence();
                              cbWritten != 0xFFFFFFFF && occ != OCC_INVALID;
                              occ = pcur->NextOccurrence(), i++ )
                        {
                            cbWritten = _snprintf( psz, cc, " %6ld", occ );
                            if ( cbWritten != -1 )
                            {
                                psz += cbWritten;
                                cc -= cbWritten;
                            }

                            if ( i % 10 == 0 )
                            {
                                cbWritten = _snprintf( psz, cc, "\n" );
                                if ( cbWritten != -1 )
                                {
                                    psz += cbWritten;
                                    cc -= cbWritten;
                                }
                            }
                        }

                        if ( cbWritten != -1 )
                            cbWritten = _snprintf( psz, cc, "\n" );

                        if ( cbWritten != -1 )
                        {
                            psz += cbWritten;
                            cc -= cbWritten;
                            pszStart = psz;
                        }
                        else
                            break;
                    }
                } // for

                delete pcur;
            } // pcur != 0

            //
            // What if we didn't write any key?
            //

            if ( pkey && pkey->Compare( *pkeyStart ) == 0 )
            {
                cbWritten = _snprintf( psz, sizeof(szContinued), szContinued);
                psz += cbWritten;

                pkey = pcur->GetNextKey();
            }
            else
            {
                psz = pszStart;
            }

            *psz = 0;
            psz++;  // For final null

            //
            // Either buffer is full, or we ran out of keys.
            //

            if ( pkey != 0 )
            {
                //
                // Write bookmark
                //

                *((ULONG UNALIGNED *)psz) = CiDumpWorkId;
                psz += sizeof(ULONG);
                *((WORKID UNALIGNED *)psz) = widLocate;
                psz += sizeof(WORKID);

                *((ULONG UNALIGNED *)psz) = iidRequested;
                psz += sizeof(ULONG);

                keyStart = *pkey;
                memcpy( psz, &keyStart, sizeof(keyStart) );
            }
            else
            {
                //
                // Write end-of-iteration signature
                //

                *((ULONG UNALIGNED *)psz) = 0;
            }

            break;
        }
    }

    //
    // We may not have found any data.
    //

    if ( i < 0 )
    {
        unsigned cbWritten = _snprintf( psz, cc, "No index contains data for wid %d (0x%x)\n", widLocate, widLocate );
        psz += cbWritten;
        cc -= cbWritten;

        psz++;  // For final null
        *((ULONG UNALIGNED *)psz) = 0;
    }

    //
    // Cleanup
    //

    delete pkeyStart;
    _resman.ReleaseIndexes( cind, ppIndex, pfresh );
    delete ppIndex;
}

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:      CContentIndex::KeyToId, public
//
//  Synopsis:    Maps from a key to an id.
//
//  Arguments:   [pkey] -- pointer to the key to be mapped to ULONG
//
//  Returns:     key id - a ULONG
//
//  History:     03-Nov-93   w-Patg      Created.
//
//----------------------------------------------------------------------------
ULONG CContentIndex::KeyToId( CKey const * pkey )
{
    return _resman.KeyToId( pkey );
}

//+---------------------------------------------------------------------------
//
//  Member:      CContentIndex::IdToKey, public
//
//  Synopsis:    Maps from an id to a key.
//
//  Arguments:   [ulKid] -- key id to be mapped to a key
//               [rkey] -- reference to the returned key
//
//  Returns:     void
//
//  History:     03-Nov-93   w-Patg      Created.
//
//----------------------------------------------------------------------------
void CContentIndex::IdToKey( ULONG ulKid, CKey & rkey )
{
    _resman.IdToKey( ulKid, rkey );
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::CCI, public
//
//  Synopsis:   Creates a content index object.
//
//  Arguments:  [storage]          -- Storage
//              [xIndexNotifTable] -- Table of notifications in push filtering
//
//  History:    21-Aug-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CCI::CCI( PStorage & storage,
          CCiFrameworkParams & params,
          ICiCDocStore * pICiCDocStore,
          CI_STARTUP_INFO const & startupInfo,
          IPropertyMapper * pIPropertyMapper,
          XInterface<CIndexNotificationTable> & xIndexNotifTable )
          : _storage(storage),
            _pci(0),
            _createStatus(STATUS_INTERNAL_ERROR)
{

    Win4Assert( 0 != pIPropertyMapper );

    if ( startupInfo.startupFlags & CI_CONFIG_EMPTY_DATA )
    {
        ciDebugOut(( DEB_WARN,
        "**** CI_CONFIG_EMPTY_DATA is true. Emptying contents of contentIndex.\n" ));
        Empty();
    }

    _xPropMapper.Set( pIPropertyMapper );
    pIPropertyMapper->AddRef();

    _createStatus = Create( pICiCDocStore, startupInfo, params, xIndexNotifTable );

    if ( STATUS_SUCCESS != _createStatus )
        THROW( CException( _createStatus ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCI::~CCI, public
//
//  Synopsis:   Destroys the content index.
//
//  Signals:    ???
//
//  History:    21-Aug-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CCI::~CCI()
{
    delete _pci;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::IsCiCorrupt, public
//
//  Synopsis:   Returns TRUE if the index is corrupt or FALSE otherwise
//
//  History:    5-Oct-98   dlee      Created.
//
//----------------------------------------------------------------------------

BOOL CCI::IsCiCorrupt()
{
    if ( 0 == _pci )
        return FALSE;

    return _pci->IsCiCorrupt();
} //IsCiCorrupt

SCODE CCI::FilterStoreValue(
    WORKID widFake,
    CFullPropSpec const & ps,
    CStorageVariant const & var,
    BOOL & fStored )
{
    fStored = FALSE;
    if ( 0 != _pci )
        return _pci->FilterStoreValue( widFake, ps, var, fStored );

    return S_OK;
}

SCODE CCI::FilterStoreSecurity(
    WORKID widFake,
    PSECURITY_DESCRIPTOR pSD,
    ULONG cbSD,
    BOOL & fStored )
{
    fStored = FALSE;
    if ( 0 != _pci )
        return _pci->FilterStoreSecurity( widFake, pSD, cbSD, fStored );

    return S_OK;
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CRWStore * CCI::ComputeRelevantWords(ULONG cRows,ULONG cRW,
                                     WORKID *pwid,PARTITIONID partid)
{
    if ( 0 != _pci )
        return _pci->ComputeRelevantWords(cRows,cRW,pwid,partid);

    return 0;
} //ComputeRelevantWords


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CRWStore * CCI::RetrieveRelevantWords(BOOL fAcquire,PARTITIONID partid)
{
    if ( 0 != _pci )
        return _pci->RetrieveRelevantWords(fAcquire,partid);

    return 0;
} //RetrieveRelevantWords


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
unsigned CCI::ReserveUpdate ( WORKID wid )
{
    if ( 0 != _pci )
        return _pci->ReserveUpdate ( wid );
    else
        return 0;
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

SCODE CCI::Update ( unsigned iHint,
                    WORKID wid,
                    PARTITIONID partid,
                    USN usn,
                    VOLUMEID volumeId,
                    ULONG action )
{
    if ( 0 == _pci )
        return CI_E_NOT_INITIALIZED;

    return _pci->Update ( iHint, wid, partid, usn, volumeId, action );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

void CCI::FlushUpdates()
{
    if ( 0 != _pci )
        _pci->FlushUpdates();
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

void CCI::MarkOutOfDate()
{
    if ( 0 != _