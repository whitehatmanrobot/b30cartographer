wError;
}

DWORD
ProcessDAVGetSpace(
    DWORD   argc,
    LPSTR   *argv
    )
{
    DWORD   dwError = ERROR_SUCCESS;
    ULARGE_INTEGER MaxSpace, UsedSpace;
    WCHAR   tzLocation[MAX_PATH];
    DWORD   dwSize;

    dwSize = sizeof(tzLocation);    
    if ((dwError = DavGetDiskSpaceUsage(tzLocation, &dwSize, &MaxSpace, &UsedSpace)) == ERROR_SUCCESS)
    {
        printf("Location=%ls MaxSpace=%I64d UsedSpace=%I64d\n", tzLocation, MaxSpace, UsedSpace);
    }
    
    return dwError;
}


DWORD
ProcessDAVFreeSpace(
    DWORD   argc,
    LPSTR   *argv
    )
{
    DWORD   dwError = ERROR_SUCCESS, dwPercent;
    
    if (argc < 1)
    {
        printf("FreeSpace Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    if(sscanf(argv[0], "%d", &dwPercent) == 1)
    {
        dwError = DavFreeUsedDiskSpace(dwPercent);
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\dllmain.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

Revision History:

--*/

#include "pch.h"
#pragma hdrstop
#include <debug.h>

CRITICAL_SECTION g_csLock;

HINSTANCE g_hinst;

#if DBG
ULONG DavClientDebugFlag = 0;
#define DAVNP_PARAMETERS_KEY L"System\\CurrentControlSet\\Services\\WebClient\\Parameters"
#define DAVNP_DEBUG_KEY L"ClientDebug"
#endif

extern LONG g_cRefCount;

#define DAV_NETWORK_PROVIDER L"SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider"
#define DAV_NETWORK_PROVIDER_NAME L"Name"

WCHAR DavClientDisplayName[MAX_PATH];

BOOL
WINAPI
DllMain (
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    The DllMain routine for the davclnt.dll. DllMain should do as little work 
    as possible.

Arguments:

    hinst - Instance handle of the DLL.
    
    dwReason - The reason for this function to be called by the system.
    
    pvReserved - Indicated whether the DLL was implicitly or explicitly loaded.

Return Value:

    TRUE.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG ValueType = 0, ValueSize = 0;

    if (DLL_PROCESS_ATTACH == dwReason) {

        //
        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

        //
        // Syncrhonization support --
        // Unless you have *measured* lock contention, you should only need
        // one lock for the entire DLL.  (and maybe you don't even need one.)
        //
        try {
            InitializeCriticalSection ( &(g_csLock) );
        } except(EXCEPTION_EXECUTE_HANDLER) {
              ULONG WStatus = GetExceptionCode();
        }

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;
        g_cRefCount = 0;

        //
        // Read the DAV Network Provider Name out of the registry.
        //
        DavClientDisplayName[0] = L'\0';
        
        WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                DAV_NETWORK_PROVIDER,
                                0,
                                KEY_QUERY_VALUE,
                                &(KeyHandle));
        
        if (WStatus == ERROR_SUCCESS) {

            ValueSize = sizeof(DavClientDisplayName);

            WStatus = RegQueryValueExW(KeyHandle,
                                       DAV_NETWORK_PROVIDER_NAME,
                                       0,
                                       &(ValueType),
                                       (LPBYTE)&(DavClientDisplayName),
                                       &(ValueSize));
            RegCloseKey(KeyHandle);
        
        } else {

            DavClientDisplayName[0] = L'\0';

        }

#if DBG

        //
        // Read DebugFlags value from the registry. If the entry exists, the global
        // filter "DavClientDebugFlag" is set to this value. This value is used in
        // filtering the debug messages.
        //
        WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                DAVNP_PARAMETERS_KEY,
                                0,
                                KEY_QUERY_VALUE,
                                &(KeyHandle));
        
        if (WStatus == ERROR_SUCCESS) {

            ValueSize = sizeof(DavClientDebugFlag);

            WStatus = RegQueryValueExW(KeyHandle,
                                       DAVNP_DEBUG_KEY,
                                       0,
                                       &(ValueType),
                                       (LPBYTE)&(DavClientDebugFlag),
                                       &(ValueSize));
            RegCloseKey(KeyHandle);
        
        }

#endif
        
    } else if (DLL_PROCESS_DETACH == dwReason) {
        DeleteCriticalSection (&g_csLock);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\dllmain2.cpp ===
#include <windows.h>
#include <olectl.h>
#include <advpub.h>     // REGINSTALL

#include "volclean.h"

/*
**------------------------------------------------------------------------------
** Global variables
**------------------------------------------------------------------------------
*/
extern "C" {
LONG g_cRefCount = 0;
}

typedef HRESULT (WINAPI *PFNCREATEINSTANCE)(REFIID, void **);

/*
**------------------------------------------------------------------------------
** DllCanUnloadNow
**
** Purpose:       Answers if the DLL can be free, that is, if there are no
**                references to anything this DLL provides.
** Return:        TRUE, if OK to unload (i.e. nobody is using us or has us locked)
**                FALSE, otherwise
** Notes;
**------------------------------------------------------------------------------
*/
STDAPI DllCanUnloadNow(void) 
{
    //  
    // Are there any outstanding references?
    //
    return (g_cRefCount == 0 ? S_OK : S_FALSE);
}


STDAPI_(void) DllAddRef(void) 
{
    InterlockedIncrement(&g_cRefCount);
}


STDAPI_(void) DllRelease(void) 
{
    InterlockedDecrement(&g_cRefCount);
}


class CWebDavCleanerClassFactory : IClassFactory
{
    LONG m_cRef;
    PFNCREATEINSTANCE m_pfnCreateInstance;

public:
    CWebDavCleanerClassFactory(PFNCREATEINSTANCE pfnCreate) 
        : m_cRef(1), 
          m_pfnCreateInstance(pfnCreate) 
    {
        Trace(L"CWebDavCleanerClassFactory::CWebDavCleanerClassFactory");
        DllAddRef();
    }

    ~CWebDavCleanerClassFactory() 
    {
        Trace(L"CWebDavCleanerClassFactory::~CWebDavCleanerClassFactory");
        DllRelease();
    }

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


/*
**------------------------------------------------------------------------------
** DllGetClassObject
**
** Purpose:    Provides an IClassFactory for a given CLSID that this DLL is
**             registered to support.  This DLL is placed under the CLSID
**             in the registration database as the InProcServer.
** Parameters:
**  clsID   -  REFCLSID that identifies the class factory desired.
**             Since this parameter is passed this DLL can handle
**             any number of objects simply by returning different
**             different class factories here for different CLSIDs.
**  riid    -  REFIID specifying the interface the caller wants
**             on the class object, usually IID_ClassFactory.
**  ppvOut  -  pointer in which to return the interface pointer.
** Return:     NOERROR on success, otherwise an error code
** Notes;
**------------------------------------------------------------------------------
*/
STDAPI DllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    OUT void **ppv
    )
{
    HRESULT hr = E_FAIL;
    PFNCREATEINSTANCE pfnCreateInstance = NULL;
    Trace(L"DllGetClassObject");

    *ppv = NULL;

    //
    // Is the request for our cleaner object?
    //
    if (IsEqualCLSID(rclsid, CLSID_WebDavVolumeCleaner)) {
        pfnCreateInstance = CWebDavCleaner::CreateInstance;
    }
    else {
        //
        // Error - we don't know about this object
        //
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // 
    // Get our IClassFactory for making CWebDavCleaner objects
    //
    CWebDavCleanerClassFactory *pClassFactory = new CWebDavCleanerClassFactory(pfnCreateInstance);
    if (pClassFactory) {
        //
        // Make sure the new class factory likes the requested interface
        //
        hr = pClassFactory->QueryInterface(riid, ppv);
        if (FAILED(hr)) {
            // 
            // Error - interface rejected
            //
            delete pClassFactory;
        }
        else {
            //
            // Release initial ref
            //
            pClassFactory->Release();
        }
    }
    else {
          //
          // Error - couldn't make factory object
          //
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    Trace(L"CWebDavCleanerClassFactory::QueryInterface");
    if (!ppv) {
        return E_POINTER;
    }

    if (riid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    }
    else  {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;

}


STDMETHODIMP_(ULONG) 
CWebDavCleanerClassFactory::AddRef()
{
    Trace(L"CWebDavCleanerClassFactory::AddRef");
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) 
CWebDavCleanerClassFactory::Release()
{
    Trace(L"CWebDavCleanerClassFactory::Release");
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_UNEXPECTED;
    Trace(L"CWebDavCleanerClassFactory::CreateInstance");

    *ppv = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if (m_pfnCreateInstance)
        hr = m_pfnCreateInstance(riid, ppv);

    return hr;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::LockServer(BOOL fLock)
{
    Trace(L"CWebDavCleanerClassFactory::LockServer");
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\workitem.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    workitem.c

Abstract:

    This code handles allocating and freeing work items for the user mode
    reflector library.  This implements UMReflectorAllocateWorkItem and
    UMReflectorCompleteWorkItem.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


PUMRX_USERMODE_WORKITEM_HEADER
UMReflectorAllocateWorkItem (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    ULONG AdditionalBytes
    )
/*++

Routine Description:

    Allocate a new work item or pull one out of the Available list and return.

Arguments:

    Handle - The reflector's handle.

    AdditionalBytes - Number of extra bytes.

Return Value:

    The return status for the operation

--*/
{
    PUMRX_USERMODE_REFLECT_BLOCK reflector;
    ULONG rc;
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG entrySize;
    PUMRX_USERMODE_WORKITEM_HEADER workItemHeader = NULL;

    if (WorkerHandle == NULL) {
        return NULL;
    }

    reflector = WorkerHandle->ReflectorInstance;

    EnterCriticalSection(&reflector->Lock);

    if (reflector->Closing) {
        LeaveCriticalSection(&reflector->Lock);
        return NULL;
    }

    entrySize = sizeof(UMRX_USERMODE_WORKITEM_ADDON) + AdditionalBytes;

    //
    // Check the AvailableList for one thats big enough and free.
    //
    if (reflector->NumberAvailable) {
        listEntry = reflector->AvailableList.Flink;
        while ((listEntry != &reflector->AvailableList) &&
               (workItem == NULL)) {
            workItem = CONTAINING_RECORD(listEntry,
                                         UMRX_USERMODE_WORKITEM_ADDON,
                                         ListEntry);
            if (workItem->EntrySize < entrySize) {
                workItem = NULL;
            }
            listEntry = listEntry->Flink;
        }
        if (workItem != NULL) {
            //
            // Reuse it by taking it off the free list.
            //
            reflector->NumberAvailable--;
            RemoveEntryList( &workItem->ListEntry );
            entrySize = workItem->EntrySize;
        }
    }

    if (workItem == NULL) {
        workItem = LocalAlloc(LMEM_FIXED, entrySize);
        if (workItem == NULL) {
            LeaveCriticalSection(&reflector->Lock);
            return NULL;
        }
    }

    //
    // Reset everything back to known.
    //
    RtlZeroMemory(workItem, entrySize);
    workItem->EntrySize = entrySize;
    workItem->ReflectorInstance = reflector;
    workItem->WorkItemState = WorkItemStateNotYetSentToKernel;
    InsertHeadList(&reflector->WorkItemList, &workItem->ListEntry);

    workItemHeader = &workItem->Header;
    workItemHeader->WorkItemLength = sizeof(UMRX_USERMODE_WORKITEM_HEADER) +
                                     AdditionalBytes;

    LeaveCriticalSection(&reflector->Lock);

    return workItemHeader;
}


ULONG
UMReflectorCompleteWorkItem (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    )
/*++

Routine Description:

    Complete a WorkItem that has come back from the kernel.

Arguments:

    WorkerHandle - The worker thread's handle.

    IncomingWorkItem - The workitem to be completed.

Return Value:

    The return status for the operation

--*/
{
    PUMRX_USERMODE_REFLECT_BLOCK reflector;
    ULONG rc;
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG entrySize;

    if (WorkerHandle == NULL || IncomingWorkItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    reflector = WorkerHandle->ReflectorInstance;

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR)IncomingWorkItem -
                           FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState != WorkItemStateFree);
    ASSERT(workItem->WorkItemState != WorkItemStateAvailable);

    EnterCriticalSection(&reflector->Lock);

    RemoveEntryList(&workItem->ListEntry);

    if (!reflector->Closing && (reflector->CacheLimit > 0)) {

        workItem->WorkItemState = WorkItemStateAvailable;
        InsertHeadList(&reflector->AvailableList, &workItem->ListEntry);
        reflector->NumberAvailable++;

        //
        // If we already have too many cached, then we free up an old one and 
        // put this one on the free list. We do this so that if the app changes
        // the size of the blocks then it will not get stuck with a cache full
        // of ones that are too small.
        //
        if (reflector->NumberAvailable >= reflector->CacheLimit) {

            reflector->NumberAvailable--;

            //
            // We remove from the tail because we just put the new one onto
            // the head. No use freeing the same one we're trying to put on.
            //
            listEntry = RemoveTailList(&reflector->AvailableList);

            workItem = CONTAINING_RECORD(listEntry,
                                         UMRX_USERMODE_WORKITEM_ADDON,
                                         ListEntry);
        } else {
            workItem = NULL;
        }
    }

    if (workItem != NULL) {
        workItem->WorkItemState = WorkItemStateFree;
        LocalFree( workItem );
    }

    LeaveCriticalSection( &reflector->Lock );
    
    return STATUS_SUCCESS;
}

// workitem.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

extern WCHAR DavClientDisplayName[MAX_PATH];

#if DBG

extern ULONG DavClientDebugFlag;

//
// The Debug flags.
//
#define DEBUG_DEBUG             0x00000001  // General debugging.
#define DEBUG_ERRORS            0x00000002  // Hard error.
#define DEBUG_MISC              0x00000004  // Misc info.
#define DEBUG_ENTRY             0x00000008  // Function entry.
#define DEBUG_EXIT              0x00000010  // Function exit.

#define IF_DEBUG(flag) if (DavClientDebugFlag & (DEBUG_ ## flag))

#define IF_DEBUG_PRINT(flag, args) {     \
        if (DavClientDebugFlag & flag) { \
            DbgPrint args;               \
        }                                \
}

#else

#define IF_DEBUG(flag) if (0)

#define IF_DEBUG_PRINT(flag, args)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This file contains globals and prototypes for user mode webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DAVGLOBAL_H
#define _DAVGLOBAL_H

#pragma once

#include <debug.h>
#include <davrpc.h>
#include <winsock2.h>
#include <align.h>
#include <winbasep.h>
#include <icanon.h>

#define DAV_PATH_SEPARATOR L'\\'

#define DAV_DUMMY_SHARE L"DavWWWRoot"

#define RESOURCE_SHAREABLE      0x00000006

typedef enum _DAV_REMOTENAME_TYPE {
    DAV_REMOTENAME_TYPE_INVALID = 0,
    DAV_REMOTENAME_TYPE_WORKGROUP,
    DAV_REMOTENAME_TYPE_DFS,
    DAV_REMOTENAME_TYPE_SERVER,
    DAV_REMOTENAME_TYPE_SHARE,
    DAV_REMOTENAME_TYPE_PATH
} DAV_REMOTENAME_TYPE, *PDAV_REMOTENAME_TYPE;

typedef enum _DAV_ENUMNODE_TYPE {
    DAV_ENUMNODE_TYPE_USE = 0,
    DAV_ENUMNODE_TYPE_CONTEXT,
    DAV_ENUMNODE_TYPE_SHARE,
    DAV_ENUMNODE_TYPE_SERVER,
    DAV_ENUMNODE_TYPE_DOMAIN,
    DAV_ENUMNODE_TYPE_EMPTY
} DAV_ENUMNODE_TYPE;

typedef struct _DAV_ENUMNODE {
    
    DAV_ENUMNODE_TYPE DavEnumNodeType;
    
    DWORD dwScope;
    
    DWORD dwType;
    
    DWORD dwUsage;
    
    //
    // Are we done returning all the requested entries. If we are this is set
    // to TRUE, so that on the next call, we can return WN_NO_MORE_ENTRIES.
    //
    BOOL Done;

    //
    // Start with the entry at this index. This means that the entries of 
    // lower indices have already been sent to the caller previously.
    //
    DWORD Index;
    
    LPNETRESOURCE lpNetResource;

} DAV_ENUMNODE, *PDAV_ENUMNODE;

#endif // DAVGLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\version.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    version.h

Abstract:

Revision History:

--*/

#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Web DAV Client DLL"
#define VER_INTERNALNAME_STR            "davclnt.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\midluser.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    
    25-Apr-1991    JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    
    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.
    
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

    10-Feb-1993     RitaW
        Copied to the NetWare tree so that the LPC transport can used for
        the local case.

--*/

#include <nt.h>
#include <ntrtl.h>              // needed for nturtl.h
#include <nturtl.h>             // needed for windows.h
#include <windows.h>            // win32 typedefs
#include <rpc.h>                // rpc prototypes

#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <winbase.h>            // LocalAlloc

#include <debug.h>

PVOID
MIDL_user_allocate (
    IN unsigned int NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    LPVOID NewPointer;

    NewPointer = (LPVOID) LocalAlloc(
                              LMEM_ZEROINIT,
                              NumBytes
                              );

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree((HLOCAL) MemPointer);

} // MIDL_user_free

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN unsigned long NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.


    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = (LPVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  NewByteCount
                                  );

    } else if (NewByteCount == 0) {

        (void) LocalFree((HLOCAL) OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = (PVOID) LocalReAlloc(
                              hOldMem,               // old handle
                              NewByteCount,          // new size in bytes
                              LMEM_ZEROINIT |        // flags
                                  LMEM_MOVEABLE      //  (motion okay)
                              );

        if (hNewMem == NULL) {
            return (NULL);
        }

        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


ULONG_PTR
MIDL_user_size(
    IN void * Pointer
    )
{
    ULONG_PTR ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\pch.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

#ifndef __cplusplus

#pragma once

#define UNICODE 1
#define _UNICODE 1

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Public windows headers.
//
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <rpc.h>
#include <rpcutil.h>
#include <lmcons.h>
#include <lmerr.h>
#include <netlib.h>
#include <netlibnt.h>
#include <wininet.h>
#include <winineti.h>
#include <mpr.h>
#include <npapi.h>
#include "davname.h"

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by volclean.rc
//
#define IDS_DISKCLEAN_DISPLAY           1
#define IDS_DISKCLEAN_DESCRIPTION       2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\provider.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    provider.c

Abstract:

    This module contains WebDav's Network Provider code.  It is the client-side 
    wrapper for APIs supported by the Dav Client service.

Author:

    Rohan Kumar   01-Dec-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <global.h>

#define SECURITY_WIN32
#include <security.h>
#include <wincred.h>
#include <wincred.h>
#include <npapi.h>
//
// Local Function Prototypes.
//

BOOL
DavWorkstationStarted(
    VOID
    );

DWORD
DavMapRpcErrorToProviderError(
    IN DWORD RpcError
    );

DWORD
DavBindTheRpcHandle(
    handle_t *dav_binding_h
    );

DAV_REMOTENAME_TYPE 
DavParseRemoteName (
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    );

BOOL
DavServerExists(
    IN PWCHAR PathName,
    OUT PWCHAR Server
    );

BOOL
DavShareExists(
    PWCHAR PathName
    );

BOOL
DavConnectionExists(
    PWCHAR ConnName
    );

DWORD 
DavDisplayTypeToUsage(
    DWORD dwDisplayType
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_PROMPTFORCREDENTIALS)(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
void
(WINAPI
*PFN_CREDUI_CONFIRMCREDENTIALS)(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    );

HMODULE
DavInitCredUI(
    PWCHAR RemoteName,
    WCHAR ServerName[CRED_MAX_STRING_LENGTH + 1],
    PFN_CREDUI_CONFIRMCREDENTIALS *pfnCredUIConfirmCredentials,
    PFN_CREDUI_PROMPTFORCREDENTIALS *pfnCredUIPromptForCredentials,
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS *pfnCredUICmdlinePromptForCredentials
    );

ULONG
DavCheckAndConvertHttpUrlToUncName(
    IN PWCHAR RemoteName,
    OUT PWCHAR *UncRemoteName,
    OUT PBOOLEAN MemoryAllocated,
    IN BOOLEAN AddDummyShare,
    OUT PDAV_REMOTENAME_TYPE pRemoteType,
    OUT PULONG pPathStart,
    IN BOOLEAN bCanonicalize
    );

ULONG
DavCheckResourceType(
   IN DWORD dwType
   );

ULONG
DavCheckLocalName(
    IN PWCHAR LocalName
    );

VOID 
DavDisplayNetResource(
    LPNETRESOURCE netRes, 
    LPWSTR dispMesg
    );

VOID 
DavDisplayEnumNode(
    PDAV_ENUMNODE enumNode, 
    LPWSTR dispMesg
    );

VOID
DavDebugBreakPoint(
    VOID
    );

DWORD
APIENTRY
NPGetCaps(
    IN DWORD QueryVal
    )
/*++

Routine Description:

    This function returns the functionality supported by the DAV network
    provider.

Arguments:

    QueryVal - Supplies a value which determines the type of information
               queried regarding the network provider's support in this area.

Return Value:

    Returns a value which indicates the level of support given by this
    provider.

--*/
{

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetCaps: QueryVal = %d\n", QueryVal));

    //
    // Some of the flags are commented out, since they are not supported.
    //

    switch (QueryVal) {

    case WNNC_SPEC_VERSION:
        return WNNC_SPEC_VERSION51;

    case WNNC_NET_TYPE:
        return WNNC_NET_DAV;

    case WNNC_DRIVER_VERSION:
        return 0x00010000;      // driver version 1.0

    case WNNC_USER:
        return WNNC_USR_GETUSER;

    case WNNC_CONNECTION:
        return ( WNNC_CON_ADDCONNECTION  |
                 WNNC_CON_ADDCONNECTION3 |
                 //
                 // Not supported for now.
                 //
                 //WNNC_CON_GETPERFORMANCE |
                 //
                 // DEFERRED connections are not supported for now.
                 //
                 //WNNC_CON_DEFER          |
                 WNNC_CON_GETCONNECTIONS |
                 WNNC_CON_CANCELCONNECTION );

    case WNNC_ENUMERATION:
        return ( WNNC_ENUM_GLOBAL  |
                 WNNC_ENUM_LOCAL   |
                 // 
                 // We are not supporting this option since we have no concept
                 // of DOMAIN in DAV. Hence cannot show any thing in  
                 // "network neighbourhood" view.
                 // 
                 // WNNC_ENUM_CONTEXT |
                 WNNC_ENUM_SHAREABLE );
    
    case WNNC_START:
        if ( DavWorkstationStarted() ) {
            return 1;
        }
        else {
            return 0xffffffff;   // don't know
        }

    case WNNC_DIALOG:
        return ( WNNC_DLG_GETRESOURCEPARENT      | 
                 //
                 //This flag is Obselete and is not supported.
                 //
                 //WNNC_DLG_DEVICEMODE             |
                 //
                 // Both of these Dialog options are not supported for now.
                 //
                 //WNNC_DLG_PROPERTYDIALOG         |
                 //WNNC_DLG_SEARCHDIALOG           |
                 WNNC_DLG_FORMATNETWORKNAME      |
                 WNNC_DLG_GETRESOURCEINFORMATION );

    case WNNC_ADMIN:
        return  0; 
                // 
                // None of functions given below are supported.
                //
                //( WNNC_ADM_GETDIRECTORYTYPE  |
                //WNNC_ADM_DIRECTORYNOTIFY );

    case WNNC_CONNECTION_FLAGS:
        return  ( WNNC_CF_DEFAULT |
                 //
                 // DEFERRED Connections are not supported for now.
                 //
                 //CONNECT_DEFERRED | 
                  CONNECT_COMMANDLINE |
                  CONNECT_CMD_SAVECRED );

        //
        // The rest are not supported by the DAV provider.
        //
        default:
            return 0;
    
    }

}


DWORD 
NPGetUser(
    IN LPTSTR lpName,
    OUT LPTSTR lpUserName,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function determines the user name that created the connection.

Arguments:

    lpName - Name of the local drive or the remote name that the user has made
             a connection to. If NULL, return currently logged on user.
    
    lpUserName - The buffer to be filled in with the requested user name.
    
    lpBufferSize - Contains the length (in chars not bytes )of the lpUserName 
                   buffer. If the length is insufficient, this place is used to 
                   inform the user the actual length needed. 

Return Value:

    WN_SUCCESS - Successful. OR

    The appropriate network error code.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    handle_t dav_binding_h;
    BOOL getUser = FALSE, bindRpcHandle = FALSE;
    DWORD NumOfChars = 0;
    BOOLEAN didAllocate = FALSE, getLogonUserName = FALSE, doRpcCall = FALSE;
    PWCHAR ConnectionName = NULL;
    DWORD npStatus = ERROR_SUCCESS;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetUser Entered.\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Checking for invalid parameters. 
    //
    if (lpBufferSize  == NULL || (lpUserName == NULL && *lpBufferSize != 0) ) {
        NPStatus = ERROR_INVALID_PARAMETER;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser. Invalid parameters. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if the given connectin name (lpName) is L"" or NULL, in which case we
    // returns user-id of the logon user.
    //
    if (lpName != NULL && lpName[0] != L'\0') {
        if (DavCheckLocalName(lpName) != WN_SUCCESS) {
            // 
            // Check if it is a valid format remote connection: it can be a
            // URL form string or can be a UNC format string.
            //
            NPStatus = DavCheckAndConvertHttpUrlToUncName(lpName,
                                                          &(ConnectionName),
                                                          &(didAllocate),
                                                          FALSE /*TRUE*/,
                                                          &remNameType,
                                                          NULL,
                                                          TRUE);
            if (NPStatus != ERROR_SUCCESS) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUser/DavCheckAndConvertHttpUrlToUncName."
                                " NPStatus = %08lx\n", NPStatus));
                if (NPStatus == WN_BAD_NETNAME) {
                     NPStatus = WN_NOT_CONNECTED;
                }
                goto EXIT_THE_FUNCTION;
            }
            // 
            // Connection names are allowed only to shares or sub-directories
            // inside them. So RemoteName should have atleast \\server\share
            // part in it.
            //
            if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
                remNameType != DAV_REMOTENAME_TYPE_PATH) {
               IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/DavCheckAndConvertHttpUrlToUncName."
                        " remNameType = %d\n", remNameType));
               NPStatus = WN_NOT_CONNECTED;
               goto EXIT_THE_FUNCTION;
            }

            //
            // Given connection is a valid format remote connection name: and
            // this connection name is converted to a UNC name.
            // 
            doRpcCall = TRUE;
        } else {
            //
            // Given connection is a valid format local DOS-device name.
            // 
            ConnectionName = lpName;
            doRpcCall = TRUE;
        }
    } else {
        // 
        // Connection name (lpName) passed to this function is L"" or NULL in which
        // case we returns user-id of the logon-user.
        //
        getLogonUserName = TRUE;
    }

    if (doRpcCall == TRUE) {
        
        ASSERT(ConnectionName != NULL);
        
        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetUser/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }
        bindRpcHandle = TRUE;

        RpcTryExcept {
            NPStatus = DavrGetUser(dav_binding_h, lpBufferSize, ConnectionName, lpUserName);
            if (NPStatus != WN_SUCCESS) {
               IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUser/DavrGetConnection(1). NPStatus = %08lx\n",
                                NPStatus));
               if (NPStatus == ERROR_NOT_FOUND || NPStatus == NERR_UseNotFound) {
                    NPStatus = WN_NOT_CONNECTED;
               }
               if (NPStatus == ERROR_INSUFFICIENT_BUFFER) {
                    NPStatus = WN_MORE_DATA;
               }
               goto EXIT_THE_FUNCTION;
           } else {
               // 
               // NPStatus == WN_SUCCESS. We are done. Exit.
               //
               goto EXIT_THE_FUNCTION;
           }
        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
              RPC_STATUS RpcStatus;
              RpcStatus = RpcExceptionCode();
              IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUser/DavrConnectionExist."
                                            " RpcExceptionCode = %d\n", RpcStatus));
              NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
              goto EXIT_THE_FUNCTION;
        }
        RpcEndExcept
    
    }

    // 
    // We should come here only in case when logged-on user name is to be
    // returned.
    //
    if (getLogonUserName == FALSE) {
        //
        // Neither the connection exist, nor this function call is called with
        // null connection parameter in which case it should return logon-userid
        // So we quit here with error WN_NOT_CONNECTED.
        //
        NPStatus = WN_NOT_CONNECTED;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(getLogonUserName == TRUE);

    //
    // Get the required length for storing the name of the currently logged on
    // user.
    //

    NumOfChars = 0;
    getUser = GetUserName( NULL, &NumOfChars );
    npStatus = GetLastError();
    if (getUser != FALSE || npStatus != ERROR_INSUFFICIENT_BUFFER) {
        NPStatus = npStatus;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/GetUserName. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see if the buffer passed-in is of the required length. (It also
    // includes the null terminator).
    //
    if ( *lpBufferSize < NumOfChars  || lpUserName == NULL ) {
        NPStatus = WN_MORE_DATA;
        *lpBufferSize = NumOfChars;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUser: WStatus = WN_MORE_DATA\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Now, get the user name.
    //
    getUser = GetUserName( lpUserName, lpBufferSize);
    if (!getUser) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/GetUserName. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    NPStatus = WN_SUCCESS;

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetUser: NPStatus = %d\n", NPStatus));

    if(didAllocate == TRUE && ConnectionName != NULL) {
        LocalFree((HLOCAL)ConnectionName);
        didAllocate = FALSE;
        ConnectionName = NULL;
    }

    return NPStatus;
}


DWORD
NPGetConnection(
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function determines the remote name associated with the local name
    passed in.

Arguments:

    lpLocalName - Name of the local drive redirected to the remote name.
    
    lpRemoteName - The remote name to find.
    
    lpBufferSize - Contains the length (in chars not bytes ) of the lpRemoteName 
                   buffer. If the length is insufficient, this place is used to 
                   inform the user the actual length needed. 

Return Value:

    WN_SUCCESS - Successful. OR

    WN_NOT_CONNECTED - The device specified by lpLocalName is not redirected by 
                       this provider.

    WN_MORE_DATA - The buffer is too small.
    
    WN_NO_NETWORK - Network is not present.

--*/
{
    DWORD NPStatus = WN_SUCCESS, WStatus = ERROR_SUCCESS;
    PWCHAR DeviceName = NULL;
    DWORD DeviceNameLen = 0, LengthWritten = 0, LocalBufLen = 0, ReqLen = 0;
    PWCHAR ServerStart = NULL, SymLink = NULL, LocalAllocBuf = NULL;
    WCHAR LocalBuf[MAX_PATH + 1] = L"";
    DWORD LocalBufMaxLen = sizeof(LocalBuf)/sizeof(WCHAR);

    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetConnection: LocalName = %ws\n", lpLocalName));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    if ( lpLocalName == NULL || lpBufferSize == NULL || (lpRemoteName == NULL && *lpBufferSize != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. Invalid parameters. NPStatus = %d\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Initialize some local variables.
    //
    DeviceName = DD_DAV_DEVICE_NAME_U;
    DeviceNameLen = DeviceName == NULL ? 0: wcslen(DD_DAV_DEVICE_NAME_U);
    LocalBufLen = 0;
    SymLink = NULL;
    LengthWritten = 0;
    ServerStart = NULL;
    ReqLen = 0;
    
    // 
    // Make sure that WebDAV redirector has valid device name set = 
    // DD_DAV_DEVICE_NAME_U != L""
    //
    if (DeviceNameLen == 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. DeviceName=NULL. NPStatus=%d\n", NPStatus));
        // 
        // This should never happen. Break here and investigate.
        //
        ASSERT(FALSE);
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Find out from QueryDosDevice, the information about symlink associated
    // to it. This call will fail for bad lpLocalName, or for non-existent
    // lpLocalName devices. When successful, it will tell the length of buffer
    // required to contain symbolic link of the given local device (lpLocalName).
    //

    //
    // We are going to use a local buffer to get the symbolic link. It that
    // buffer falls short, then we will try allocating buffer and use them.
    // 
    SymLink = LocalBuf;
    LocalBufLen = LocalBufMaxLen;

    do {
        
        LengthWritten = QueryDosDeviceW(lpLocalName, SymLink, LocalBufLen);
        
        if ( LengthWritten == 0 ) {

            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                NPStatus = WN_NOT_CONNECTED;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/QueryDosDevice. GLE=%d, NPStatus=%d\n",
                            WStatus, NPStatus));
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Allocate the buffer to hold the symlink to be returned from 
            // QueryDosDevice call.
            //
        
            // 
            // We are going to allocate more buffer to contain the symbolic link.
            // We don't want to allocate more and more and more - so putting a cap
            // on max-size that can be allocated or else some error in API QueryDosDevice
            // can take this API in trouble.
            //
            if ( LocalBufLen > MAX_PATH * 10) {
                NPStatus = WN_OUT_OF_MEMORY;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/LocalAlloc. NPStatus=%d\n",
                            NPStatus));
                ASSERT(FALSE);
                goto EXIT_THE_FUNCTION;
            }
            
            if (LocalAllocBuf != NULL) {
                LocalFree((HLOCAL)LocalAllocBuf);
                LocalAllocBuf = NULL;
            }

            // 
            // Add MAX_PATH to length of buffer used in last call of QueryDosDevice.
            // Allocate buffer of new length and use it in next call of 
            // QueryDosDevice.
            //
            LocalBufLen += MAX_PATH; 
        
            LocalAllocBuf = LocalAlloc ( (LMEM_FIXED | LMEM_ZEROINIT), 
                                         (LocalBufLen * sizeof(WCHAR)) );
            if (LocalAllocBuf == NULL) {
                NPStatus = WN_OUT_OF_MEMORY;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/LocalAlloc. NPStatus=%d\n",
                            NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            SymLink = LocalAllocBuf;
        
        }
    
    } while (LengthWritten == 0);

    //
    // Check if the given local-name belongs to our device DD_DAV_DEVICE_NAME_U.
    // SymLink should be of form (an example):
    // \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    // And DeviceName is of form (an example): \Device\WebDavRedirector.
    //

    if (_wcsnicmp(SymLink, DeviceName, DeviceNameLen) != 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. Non-DAV device. SymLink=%ws, "
                        "NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Check if local-drive letter in symbolic mapping is same as the 
    // lpLocalName given to this function.
    //
    // \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    // And
    // lpLocalNname is (in example): Z:
    //
    if (_wcsnicmp((PWCHAR)(SymLink + DeviceNameLen + 2), lpLocalName, 2) != 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. SymLink has different drive name. "
                        "SymLink=%ws, NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // The control comes here when symbolic-link returned by QueryDosDevice
    // belongs to our device and is associated to the local device given in 
    // this function (lpLocalName).
    //
    IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPGetConnection. WebDAV symlink FOUND. SymLink=%ws\n",
                        SymLink));

    //
    // Now get remote-name stored in symbolic link.
    // Example SymLink: \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    //                                                               ^
    //                                                               |
    //                                                               ServerStart
    // This example has remote name = \\webdav-server\dav-share.
    //
    // Note: an extra L'\' is added in front of "ServerStart" to make it
    // valid UNC remote-name.
    //
    ServerStart = wcschr((PWCHAR)(SymLink + DeviceNameLen + 2), L'\\');
    if (ServerStart == NULL) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. SymLink do not has remote name. "
                        "SymLink=%ws, NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Symbolic string returned by QueryDosDevice function is a double-null
    // terminated string. So subtract 1 from LengthWritten to get length of Symbolic
    // string with only 1 null termination character.
    //
    ReqLen = (LengthWritten-1) - (DWORD)(ServerStart - SymLink) + 1; // +1 for extra L'\'

    if (*lpBufferSize < ReqLen) {
        // 
        // Passed length is shorter than required to store remote name.
        //
        NPStatus = WN_MORE_DATA;
        *lpBufferSize = ReqLen;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. RequiredLen=%d, NPStatus=%d\n",
                        ReqLen, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Given buffer is enough to contain buffer.
    //

    wsprintf(lpRemoteName, L"\\%s",ServerStart);
    NPStatus = WN_SUCCESS;
    IF_DEBUG_PRINT(DEBUG_MISC , ("NPGetConnection: lpRemoteName = %ws\n", lpRemoteName));

EXIT_THE_FUNCTION:

    if (LocalAllocBuf != NULL ) {
        LocalFree((HLOCAL)LocalAllocBuf);
        LocalAllocBuf = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetConnection: NPStatus = %d\n", NPStatus));
    
    return NPStatus;
}


DWORD
APIENTRY
NPAddConnection3(
    HWND  hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword, 
    LPTSTR lpUserName,
    DWORD  dwFlags
    )
/*++

Routine Description:

    This function is used to redirect (connect) a local device to a network 
    resource.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any messages 
                or dialogs. This is only valid if  CONNECT_INTERACTIVE is set in 
                dwFlags, and should only be used to produce dialogs needed for 
                authentication.

    lpNetResource - Specifies the network resource to connect to. This structure 
                    is defined the section describing Enumeration APIs. The 
                    following fields must be set when making a connection, the 
                    others are ignored.
        
                    lpRemoteName - Specifies the network resource to connect to.
                    
                    lpLocalName - This specifies the name of a local device to 
                                  be redirected, such as "F:" or "LPT1". The 
                                  string is treated in a case insensitive manner, 
                                  and may be the empty string (or NULL pointer) 
                                  in which case a connection to the network 
                                  resource is made without making a redirection.
                                  
                    dwType - Specifies the type of resource to connect to. It 
                             can be RESOURCETYPE_DISK, RESOURCETYPE_PRINT, or 
                             RESOURCETYPE_ANY. The value RESOURCETYPE_ANY is 
                             used if the caller does not care or does not know.
                             
    lpPassword - Specifies the password to be used in making the connection, 
                 normally the password associated with lpUserName. The NULL 
                 value may be passed in to indicate to the function to use the 
                 default password. An empty string may be used to indicate no 
                 password.
                  
    lpUserName - This specifies the username used to make the connection. If 
                 NULL, the default username (currently logged on user) will be 
                 applied. This is used when the user wishes to connect to a 
                 resource, but has a different user name or account assigned to 
                 him for that resource.
                 
    dwFlags - Any combination of the following values:

              CONNECT_TEMPORARY - The connection is being established for 
                                  browsing purposes and will probably be 
                                  released quickly.

              CONNECT_INTERACTIVE - May have interaction with the user for 
                                    authentication purposes.

              CONNECT_PROMPT - Do no use any defaults for usernames or passwords 
                               without offering user the chance to supply an 
                               alternative. This flag is only valid if  
                               CONNECT_INTERACTIVE is set.

              CONNECT_DEFERRED - Do not perform any remote network operations to 
                                 make the network connection; instead, restore 
                                 the connection in a "disconnected state".  
                                 Attempt the actual connection only when some 
                                 process attempts to use it. If this bit is set, 
                                 the caller must supply lpLocalName. This feature 
                                 is used to speed the restoring of network 
                                 connections at logon. A provider that supports 
                                 it should return the WNNC_CON_DEFERRED bit in 
                                 NPGetCaps.

              The provider should ignore any other bits of dwFlags that may be 
              set.

    Return Value:
    
    WN_SUCCESS - The call is successful. Otherwise, the an error code is 
                 returned, which may include:
    
    WN_BAD_NETNAME - lpRemoteName in the lpNetResource structure is not 
                     acceptable to this provider.
    
    WN_BAD_LOCALNAME - lpLocalName in lpNetResource is invalid.
    
    WN_BAD_PASSWORD - Invalid password.
    
    WN_ALREADY_CONNECTED - lpLocalName already connected.
    
    WN_ACCESS_DENIED - Access denied.
    
    WN_NO_NETWORK - Network is not present.
    
    WN_CANCEL - The attempt to make the connection was cancelled by the user via 
                a dialog box displayed by the provider.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    handle_t dav_binding_h;
    BOOL bindRpcHandle = FALSE;
    WCHAR UIServerName[CRED_MAX_STRING_LENGTH + 1] = L"";
    PFN_CREDUI_CONFIRMCREDENTIALS pfnCredUIConfirmCredentials = NULL;
    PFN_CREDUI_PROMPTFORCREDENTIALS pfnCredUIPromptForCredentials = NULL;
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS pfnCredUICmdlinePromptForCredentials = NULL;
    HMODULE hCredUI = NULL;
    CREDUI_INFOW uiInfo = { sizeof(uiInfo), hwndOwner, NULL };
    DWORD dwCreduiFlags = 0;
    PWCHAR szCaption = NULL, szMessage = NULL, Password = NULL, UserName = NULL;
    SIZE_T szCaptionLength = 0, szMessageLength =0;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    if ( lpNetResource == NULL ) {
        NPStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("Entering NPAddConnection3. LocalName = %ws, RemoteName = %ws,"
                    " dwFlags = %08lx\n",
                    lpNetResource->lpLocalName, lpNetResource->lpRemoteName, dwFlags));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3. NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if (lpNetResource->lpLocalName != NULL &&
        lpNetResource->lpLocalName[0] != L'\0' && 
        lpNetResource->dwType != RESOURCETYPE_DISK) {
        NPStatus = WN_BAD_DEV_TYPE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE /*TRUE*/,
                                                  &remNameType,
                                                  NULL,
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
        remNameType != DAV_REMOTENAME_TYPE_PATH) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavCheckAndConvertHttpUrlToUncName."
                        " remNameType = %d\n", remNameType));
        NPStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPAddConnection3: RemoteName = %ws\n", RemoteName));

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPAddConnection3/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    bindRpcHandle = TRUE;

    RpcTryExcept {
        NPStatus = DavrCreateConnection(dav_binding_h,
                                        lpNetResource->lpLocalName,
                                        RemoteName,
                                        lpNetResource->dwType,
                                        lpPassword,
                                        lpUserName);
        if (NPStatus == NO_ERROR) {
            //
            // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
            // to let the MPR know we used the default credentials to connect.
            //
            if (lpUserName == NULL && lpPassword == NULL) {
                NPStatus = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            } else {
                NPStatus = WN_SUCCESS;
            }
            goto EXIT_THE_FUNCTION;
        } else {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPAddConnection3/DavrCreateConnection. "
                            "NPStatus = %08lx\n", NPStatus));
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPAddConnection3/DavrCreateConnection."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    //
    // If the error returned was not one of the following, we return the error 
    // and don't query for the users credentials.
    //
    if ( NPStatus != ERROR_ACCESS_DENIED && 
         NPStatus != ERROR_LOGON_FAILURE &&
         NPStatus != ERROR_INVALID_PASSWORD ) {
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // If the CONNECT_INTERACTIVE flag was not specified, then we don't pop up 
    // the UI.
    //
    if ( !(dwFlags & CONNECT_INTERACTIVE) ) {
        goto EXIT_THE_FUNCTION;
    } 

    if (lpUserName != NULL && (wcslen(lpUserName) > CREDUI_MAX_USERNAME_LENGTH) ) {
        NPStatus = WN_BAD_USER;
        goto EXIT_THE_FUNCTION;
    }

    ZeroMemory( UIServerName, ((CRED_MAX_STRING_LENGTH + 1) * sizeof(WCHAR)) );

    hCredUI = DavInitCredUI(RemoteName, 
                            UIServerName, 
                            &(pfnCredUIConfirmCredentials),
                            &(pfnCredUIPromptForCredentials),
                            &(pfnCredUICmdlinePromptForCredentials));
    if (hCredUI == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavInitCredUI = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to allocate memory for a few things.
    //

    Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                          (CREDUI_MAX_PASSWORD_LENGTH + 1) * sizeof(WCHAR));
    if (Password == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    UserName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                          (CREDUI_MAX_USERNAME_LENGTH + 1) * sizeof(WCHAR));
    if (UserName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The extra bytes are for the WCHARS "Connect to " and the L'\0' at 
    // the end. See the wcsncpy (szCaption) below for understanding this.
    //
    szCaptionLength = ( ( wcslen(UIServerName) + 
                          wcslen(L"Connect to ") + 
                          1 ) * sizeof(WCHAR) );
    szCaption = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), szCaptionLength);
    if (szCaption == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The extra 30 bytes is for the 14 WCHARS "Connecting to " and the L'\0' at 
    // the end. See the wcsncpy (szMessage) below for understanding this.
    //
    szMessageLength = ( ( wcslen(UIServerName) + 
                          wcslen(L"Connecting to ") + 
                          1) * sizeof(WCHAR) );
    szMessage = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), szMessageLength);
    if (szMessage == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the caption.
    //
    wcscpy( szCaption, L"Connect to ");
    wcscat( szCaption, UIServerName);
    
    //
    // Copy the message.
    //
    wcscpy( szMessage, L"Connecting to ");
    wcscat( szMessage, UIServerName);
    
    //
    // Set the message and caption copied above in the uiInfo field.
    //
    uiInfo.pszMessageText = szMessage;
    uiInfo.pszCaptionText = szCaption;
    
    if (lpUserName != NULL) {
        wcsncpy( UserName, lpUserName, wcslen(lpUserName) );
    }
    
    //
    // We loop till the user hits the cancel button or the credentials are
    // valid and the connection gets created.
    //
    for ( ; ; ) {
        
        BOOL fCredWritten = FALSE;
        DWORD dwAuthErr = NPStatus;
        LPWSTR lpNewPassword = NULL;

        Password[0] = L'\0';

        //
        // Require confirmation of the stored credentials.
        //
        dwCreduiFlags = CREDUI_FLAGS_EXPECT_CONFIRMATION;

        if (dwFlags & CONNECT_COMMANDLINE) {
            
            //
            // Set the appropriate flags to set the behavior of the common UI.
            //

            //
            // CredMgr does not (yet) know how to handle certificates.
            //
            dwCreduiFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            //
            // Ensure that the username syntax is correct.
            //
            dwCreduiFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            //
            // If the caller wants to save both username and password,
            // create an enterprise peristed cred.
            //
            if ( dwFlags & CONNECT_CMD_SAVECRED ) {
                dwCreduiFlags |= CREDUI_FLAGS_PERSIST;
            } else {
                dwCreduiFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;
            }

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPAddConnection3: pfnCredUICmdlinePromptForCredentials."
                            " RemoteName = %ws\n", RemoteName));

            NPStatus = pfnCredUICmdlinePromptForCredentials(UIServerName,
                                                            NULL,
                                                            0,
                                                            UserName,
                                                            CREDUI_MAX_USERNAME_LENGTH,
                                                            Password,
                                                            CREDUI_MAX_PASSWORD_LENGTH,
                                                            &fCredWritten,
                                                            dwCreduiFlags);
        } else {

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPAddConnection3: pfnCredUIPromptForCredentials."
                            " RemoteName = %ws\n", RemoteName));

            NPStatus = pfnCredUIPromptForCredentials(&(uiInfo),
                                                     UIServerName,
                                                     NULL,
                                                     0,
                                                     UserName,
                                                     CREDUI_MAX_USERNAME_LENGTH,
                                                     Password,
                                                     CREDUI_MAX_PASSWORD_LENGTH,
                                                     &fCredWritten,
                                                     dwCreduiFlags);
        }

        if (NPStatus != ERROR_SUCCESS) {
            SetLastError(NPStatus);
            goto EXIT_THE_FUNCTION;
        } else {
            lpUserName = (L'\0' == UserName[0]) ? NULL : UserName;
            lpNewPassword = (L'\0' == Password[0]) ? NULL : Password;
        }
        
        //
        // Try to connect to the server again with the new credentials the user 
        // entered.
        //
        RpcTryExcept {
            NPStatus = DavrCreateConnection(dav_binding_h,
                                            lpNetResource->lpLocalName,
                                            RemoteName,
                                            lpNetResource->dwType,
                                            lpNewPassword,
                                            lpUserName);
            if (NPStatus != NO_ERROR) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPAddConnection3/DavrCreateConnection(2). "
                                "NPStatus = %08lx\n", NPStatus));
                //
                // Report cred as not working.
                //
                pfnCredUIConfirmCredentials(UIServerName, FALSE);
                SetLastError(NPStatus);
            } else {
                //
                // Since we succeeded, we can/should confirm these credentials.
                //
                NPStatus = WN_SUCCESS;
                pfnCredUIConfirmCredentials(UIServerName, TRUE);
                //
                // If the credentials were not stored in credman, tell MPR so it
                // can prompt the user when restoring peristent connections. If
                // the credentials were stored in credman, tell MPR that the
                // default credential was used.
                //
                if (fCredWritten) {
                    NPStatus = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
                } else if ( (lpPassword == NULL) || (wcscmp(lpPassword, lpNewPassword) != 0) ) {
                    NPStatus = WN_CONNECTED_OTHER_PASSWORD;
                }
                goto EXIT_THE_FUNCTION;
            }
        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
              RPC_STATUS RpcStatus;
              RpcStatus = RpcExceptionCode();
              IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPAddConnection3/DavrCreateConnection."
                                            " RpcExceptionCode = %d\n", RpcStatus));
              NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
              //
              // Report cred as not working.
              //
              pfnCredUIConfirmCredentials(UIServerName, FALSE);
              goto EXIT_THE_FUNCTION;
        }
        RpcEndExcept

        //
        // For command line prompting, only prompt once.
        //
        if ( dwFlags & CONNECT_COMMANDLINE ) {
            break;
        }
    
    } // end of for loop.

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName && didAllocate) {
        LocalFree(RemoteName);
        RemoteName = NULL;
    }

    if (hCredUI) {
        FreeLibrary(hCredUI);
        hCredUI = NULL;
    }
    
    //
    // Clear the password from memory before freeing it.
    //
    if (Password != NULL) {
        ZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH) ;
        LocalFree(Password);
        Password = NULL;
    }

    if (UserName != NULL) {
        LocalFree(UserName);
        UserName = NULL;
    }

    if (szCaption != NULL) {
        LocalFree(szCaption);
        szCaption = NULL;
    }
    
    if (szMessage != NULL) {
        LocalFree(szMessage);
        szMessage = NULL;
    }
    
    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPAddConnection3: NPStatus = %d\n", NPStatus));
    
    return NPStatus;
}


DWORD
APIENTRY
NPAddConnection(
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    lpNetResource - Supplies the NETRESOURCE structure which specifies the local
                    DOS device to map, the remote resource to connect to and 
                    other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

Return Value:

    WN_SUCCESS - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.
    
    WN_ACCESS_DENIED - Unable to connect with the given credentials.

--*/
{
    DWORD NPStatus = WN_SUCCESS;

    NPStatus = NPAddConnection3(NULL,
                                lpNetResource,
                                lpPassword,
                                lpUserName,
                                0);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection/NPAddConnection3. "
                        "NPStatus = %08lx\n", NPStatus));
    }

    return NPStatus;
}

DWORD
APIENTRY
NPCancelConnection(
    LPWSTR lpName,
    BOOL fForce
    )
/*++

Routine Description:

    This function deletes a remote connection.

Arguments:

    lpName - Supplies the local DOS device, or the remote resource name
             if it is a UNC connection to delete.

    fForce - Supplies the force level to break the connection.  TRUE means to
             forcefully delete the connection, FALSE means end the connection
             only if there are no opened files.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_OPEN_FILES - fForce is FALSE and there are opened files on the
                    connection.

    Other network errors.

--*/
{
    DWORD NPStatus;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ( "NPCancelConnection: Name = %ws, Force = %s\n",
                     lpName, (fForce == 0 ? "FALSE" : "TRUE") ));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPCancelConnection/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    if ( lpName == NULL || lpName[0] == L'\0' ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPCancelConnection. lpName is not valid"));
        NPStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the name supplied is a local name then the second char will be a L':'.
    // If its not a local name, then we should check to see if the remote name
    // is of the form http:. If it is, we convert it to the UNC format and send
    // it to the RPC server.
    //
    if (DavCheckLocalName(lpName) != WN_SUCCESS ) {

        NPStatus = DavCheckAndConvertHttpUrlToUncName(lpName,
                                                      &(RemoteName),
                                                      &(didAllocate),
                                                      FALSE /*TRUE*/,
                                                      &remNameType,
                                                      NULL,
                                                      TRUE);
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavCheckAndConvertHttpUrlToUncName."
                            " NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
            remNameType != DAV_REMOTENAME_TYPE_PATH) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavCheckAndConvertHttpUrlToUncName."
                            " remNameType=%d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    
    } else {

        //
        // If we are removing a local name, set the RemoteName value to be the
        // local name.
        //
        RemoteName = lpName;

    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPCancelConnection: RemoteName = %ws\n", RemoteName));

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        NPStatus = DavrDeleteConnection(dav_binding_h, RemoteName, fForce);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavDeleteConnection. "
                            "NPStatus = %08lx\n", NPStatus));
            if (NPStatus == ERROR_NOT_FOUND || NPStatus == NERR_UseNotFound) {
                NPStatus = WN_NOT_CONNECTED;
            }
            goto EXIT_THE_FUNCTION;
        } else {
            NPStatus = WN_SUCCESS;
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCancelConnection/DavrDeleteConnection."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName && didAllocate) {
        LocalFree(RemoteName);
        RemoteName = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPCancelConnection: NPStatus = %d\n", NPStatus));
    
    return NPStatus;
}


DWORD
NPOpenEnum(
    IN DWORD dwScope,
    IN DWORD dwType,
    IN DWORD dwUsage,
    IN LPNETRESOURCE lpNetResource,
    OUT LPHANDLE lphEnum
    )
/*++

Routine Description:

    This API is used to Open an enumeration of network resources or existing
    connections.

Arguments:

    dwScope - Determines the scope of the enumeration. This can be one of:
              RESOURCE_CONNECTED - All currently connected resources.
              RESOURCE_GLOBALNET - All resources on the network.
              RESOURCE_CONTEXT - The resources associated with the user's 
                                 current and default network context. Used for
                                 a "Network Neighbourhood" view.
    
    dwType - Used to specify the type of resources of interest. This is a 
             bitmask which may be any combination of:
             RESOURCETYPE_DISK  - All disk resources.
             RESOURCETYPE_PRINT - All print resources.
             RESOURCEUSAGE_ATTACHED - Specifies that the function should fail if
                                      the caller is not authenticated (even if 
                                      the network permits enumeration without 
                                      authentication).
             If dwType is 0, or is just RESOURCEUSAGE_ATTACHED, all types of 
             resources are returned. If a provider does not have the capability
             to distinguish between print and disk resources at a level, 
             it may return all resources.                                       
    
    dwUsage - Used to specify the usage of resources of interested. This is a 
              bitmask which may be any combination of:
              RESOURCEUSAGE_CONNECTABLE - All connectable resources.
              RESOURCEUSAGE_CONTAINER - All container resources.
              The bitmask may be 0 to match all. This parameter may be ignored 
              if dwScope is not RESOURCE_GLOBALNET.

    lpNetResource - This specifies the container to perform the enumeration. The
                    NETRESOURCE could have been obtained via a previous 
                    NPEnumResource, or constructed by the caller or NULL. If it 
                    is NULL, or if the lpRemoteName field of the NETRESOURCE is 
                    NULL, the provider should enumerate the top level of its 
                    network. (Note: This means that a provider cannot use an 
                    lpRemoteName of NULL to represent any network resource.) A 
                    caller would normally start off by calling NPOpenEnum with 
                    this parameter set to NULL, and then use the returned 
                    results for further enumeration. If the calling program 
                    knows exactly the provider and remote path to enumerate from,
                    it may build its own NETRESOURCE structure to pass in, 
                    filling in the lpProvider and lpRemoteName fields. Note that
                    if dwScope is RESOURCE_CONNECTED or RESOURCE_CONTEXT this 
                    parameter will be NULL.
    
    lphEnum - If function call is successful, a handle will be returned here 
              that can then be used for enumeration.

Return Value:

    WN_SUCCESS- If the call is successful. Otherwise, an error code is returned, 
                which may include:

    WN_NOT_SUPPORTED - The provider does not support the type of enumeration 
                       being requested, or the specific network resource cannot 
                       be browsed.
    
    WN_NOT_CONTAINER - lpNetResource does not point to a container.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination of 
                   parameters is specified.

    WN_NO_NETWORK - Network is not present.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode = NULL;
    BOOL isThisDavServer = FALSE, bRetEnumNode = FALSE;
    LPNETRESOURCEW lpNROut = NULL;
    ULONG RemoteNameSizeInBytes = 0;
    PWCHAR RemoteName = NULL, pRemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("NPOpenEnum: Entered. dwScope=0x%x, dwType=0x%x "
                    "dwUsage=0x%x, lpNetResource=0x%x\n",
                    dwScope, dwType, dwUsage, lpNetResource));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPOpenEnum");

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPOpenEnum/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to perform some basic checks before moving ahead.
    //

    if (lphEnum == NULL) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPOpenEnum: lphEnum == NULL. NPStatus = %d\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Validate dwType parameter - it can have RESOURCEUSAGE_ATTACHED in addition
    // to its standard set of values - but currently RESOURCEUSAGE_ATTACHED is
    // a NO-OP for us.
    //
    if (dwType == 0 || dwType == RESOURCEUSAGE_ATTACHED ) {
         dwType = RESOURCETYPE_DISK;
    }

    if ( dwType & ~RESOURCETYPE_DISK ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: Invalid dwType."
                                "NPStatus=%d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavEnumNode = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(DAV_ENUMNODE));
    if (DavEnumNode == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                     " = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    bRetEnumNode = FALSE;

    switch (dwScope) {
        
    case RESOURCE_CONNECTED: {
            
        //
        // We are looking for current uses.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_CONNECTED\n"));

        // 
        // lpNetResource should be == NULL for this dwScope.
        //
        if (lpNetResource != NULL) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_CONNECTED. lpNetRes != NULL."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        bRetEnumNode = TRUE;
        DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_USE;
        pRemoteName = NULL;
        
        break;
    
    }

    case RESOURCE_CONTEXT: {

        //
        // We are looking for servers in the domain. We don't support this 
        // search in the DAV NP since there is no way of enumerating the DAV
        // servers in the domain. DAV doesn't even support the domain concept.
        //

        NPStatus = WN_NOT_SUPPORTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                      ("ERROR: NPOpenEnum: RESOURCE_CONTEXT not supported."
                       " NPStatus = %d\n",
                       NPStatus));
        goto EXIT_THE_FUNCTION;

        break;
        
    }

    case RESOURCE_SHAREABLE: {

        //
        // We are looking for shareable resources. lpNetResource should contain
        // lpRemoteName for a server in UNC/URL form. In this case, enumerate
        // shares under this server.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_SHAREABLE\n"));

        if ( lpNetResource == NULL || lpNetResource->lpRemoteName == NULL ) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. Bad parameter "
                            "lpNetResource or lpRemoteName == NULL. NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // Need to convert lpRemoteName to UNC form if possible. This
        // can be a URL name originally.
        //
        NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                      &(RemoteName),
                                                      &(didAllocate),
                                                      FALSE,
                                                      &remNameType,
                                                      NULL,
                                                      TRUE);
        if (NPStatus != ERROR_SUCCESS || remNameType != DAV_REMOTENAME_TYPE_SERVER) {
            NPStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                            ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. lpRemoteName != SERVER."
                             " NPStatus = %d\n",NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // We need to check if the given server is a DAV server.
        //
        if (DavServerExists(RemoteName, NULL) != TRUE) {
            NPStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. Server does not exist."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // RemoteName is a valid server name in UNC form (\\server)
        //
        pRemoteName = RemoteName;
        bRetEnumNode = TRUE;
        DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SHARE;

        break;

    }

    case RESOURCE_GLOBALNET: {
            
        //
        // Only - RemoteName == UNC/URL-server or RemoteName == UNC/URL-share or 
        // RemoteName == UNC/URL-path are supported in this scope. In this cases,
        // shares under this RemoteName are enumerated. Top level (when RemoteName
        // == NULL or non-UNC-URL entity) is not supported.
        //

        //
        // Look for the combination of all bits and substitute "All" for them.
        // Ignore bits we don't know about.
        // Note: RESOURCEUSAGE_ATTACHED is a no-op for us.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_GLOBALNET\n"));
           
        // 
        // Check for presence of valid flags. If dwUsage is 0 we set it to
        // RESOURCEUSAGE_ALL since thats what is implied by the caller.
        //
        if (dwUsage == 0) {
            dwUsage = RESOURCEUSAGE_ALL;
        }

        //
        // We return WN_BAD_VALUE if the caller gave us a dwUsage value which
        // we do not support.
        //
        if ( !( dwUsage & (RESOURCEUSAGE_ALL | RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) ) ) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET - dwUsage invalid value."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Only RESOURCEUSAGE_CONNECTABLE & RESOURCEUSAGE_CONTAINER are
        // supported, hence filter out flags which are not related to these.
        //
#if 0
        if (dwUsage & RESOURCEUSAGE_ALL) {
            dwUsage |= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);
        }
#endif
        dwUsage &= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);

        //
        // We are looking for global resources out on the net. Since we do NOT
        // have a concept of domains in the DAV NP, the top level resources in
        // the network are servers. Our hierarchy is
        // 1. Entire Network ===> 2. Web Client Network ===> 3. Servers ===>
        // 4. Shares.
        //
        if ( lpNetResource == NULL || lpNetResource->lpRemoteName == NULL ) {
                
            //
            // We have been asked to enumerate the top level containers in the
            // network. In the DAV NP, these are the DAV servers we know about.
            // The caller should have set the dwUsage to RESOURCEUSAGE_CONTAINER
            // since its asking us to enumerate the container types.
            //
            if ( (dwUsage & RESOURCEUSAGE_CONTAINER) == 0 ) {
                NPStatus = WN_BAD_VALUE;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. "
                                "(dwUsage & RESOURCEUSAGE_CONTAINER)."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            //
            // At top level, therefore enumerating domains. If the user asked 
            // for connectable, well, there aint none. We don't support the 
            // concept of enumerating domains in the DAV NP. Rather we will return
            // the list of servers that are access from this client.
            // 
            pRemoteName = NULL;
            bRetEnumNode = TRUE;
            DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SERVER;

        } else {

            //
            // If we come here, it implies that we have a name. At this point we
            // assume that we have been given a server and have been asked to
            // enumerate the shares exposed by the server.
            //

            //
            // Since we have been asked to enumerate the shares, the dwUsage
            // value should have the RESOURCEUSAGE_CONNECTABLE flag set.
            //
            if ( (dwUsage & RESOURCEUSAGE_CONNECTABLE) == 0 ) {
                NPStatus = WN_BAD_VALUE;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. "
                                "(dwUsage & RESOURCEUSAGE_CONNECTABLE)."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            // 
            // We are assured of lpRemoteName != NULL. Check that the given
            // lpNetResource is a CONTAINER. It has to be a container since we
            // assume that its a server. Remember that below we are checking the
            // dwUsage values of the lpNetResource.
            //
            if ( (lpNetResource->dwUsage != 0) && 
                 ((lpNetResource->dwUsage & RESOURCEUSAGE_CONTAINER) != RESOURCEUSAGE_CONTAINER) ) {
                NPStatus = WN_NOT_CONTAINER;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. lpNetRes != CONTAINER."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }

            NPStatus = WN_SUCCESS;
            
            NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                          &(RemoteName),
                                                          &(didAllocate),
                                                          FALSE,
                                                          &remNameType,
                                                          NULL,
                                                          TRUE);
            if ( NPStatus != ERROR_SUCCESS || remNameType != DAV_REMOTENAME_TYPE_SERVER ) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum/DavCheckAndConvertHttpUrlToUncName "
                                "RESOURCE_GLOBALNET. NPStatus = %u\n", NPStatus));
                NPStatus = WN_BAD_NETNAME;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // RemoteName is UNC here - it is of form UNC-server.
            // We support both CONTAINERS (sub-directories) and CONNECTABLES (sub-dir)
            // on all these remote forms.
            //
            
            ASSERT(RemoteName != NULL);

            //
            // Check if the server given in RemoteName is a valid DAV server.
            //
            if (DavServerExists(RemoteName, NULL) != TRUE ) {
                NPStatus = WN_BAD_NETNAME;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                                ("ERROR: NPOpenEnum/DavServerExists. RESOURCE_GLOBALNET."
                                 "NPStatus = %u\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }

            bRetEnumNode = TRUE;
            DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SHARE;
            pRemoteName = RemoteName;

        }
            
        break;
        
    }
        
    default: {
        
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: default: InvPar dwScope\n"));
            goto EXIT_THE_FUNCTION;

        }
    
    };

    //
    // If the EnumNodeType is not one of DAV_ENUMNODE_TYPE_SHARE OR
    // DAV_ENUMNODE_TYPE_USE, then we return WN_NOT_SUPPORTED. The only kind
    // of enumeration we support in the DAV NP is USE and SHAREs on a server.
    //
    if ( (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_SHARE) &&
         (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_SERVER) && 
         (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_USE) && 
         (bRetEnumNode == TRUE) ) {
        bRetEnumNode = FALSE;
        NPStatus = WN_NOT_SUPPORTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: WN_NOT_SUPPORTED!!!\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // We are returning valid handle to object DAV_ENUMNODE.
    //
    ASSERT(bRetEnumNode == TRUE);

    DavEnumNode->dwScope = dwScope;
    DavEnumNode->dwType = dwType;
    DavEnumNode->dwUsage = dwUsage;
    DavEnumNode->Done = FALSE;
    DavEnumNode->Index = 0;

    //
    // If the lpNetResource is not NULL, then we create a copy of it and store
    // it in the DavEnumNode
    //
    if (lpNetResource != NULL) {

        //
        // Allocate memory for the lpNetResource for this DavEnumNode.
        //
        lpNROut = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(NETRESOURCEW));
        if (lpNROut == NULL) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                         " = %08lx\n", NPStatus));
            bRetEnumNode = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        lpNROut->dwScope = lpNetResource->dwScope;
        lpNROut->dwType = lpNetResource->dwType;
        lpNROut->dwDisplayType = lpNetResource->dwDisplayType;
        lpNROut->dwUsage = lpNetResource->dwUsage;

        //
        // If the lpRemoteName field is not NULL, then we copy the name into the
        // structure that we are creating. lpRemoteName field in lpNROut will
        // always point to a valid UNC form or a valid non-UNC form. For this,
        // we are creating this name from the remotename we got from function
        // DavCheckAndConvertHttpUrlToUncName.
        //
        if (pRemoteName != NULL && didAllocate == FALSE) {

            //
            // We need to copy the remote name since thats all what we are 
            // interested in.
            //
            RemoteNameSizeInBytes = ( ( wcslen(pRemoteName) + 1 ) * sizeof(WCHAR) );
            
            lpNROut->lpRemoteName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT),
                                               RemoteNameSizeInBytes);
            if (lpNROut->lpRemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                             " = %08lx\n", NPStatus));
                bRetEnumNode = FALSE;
                goto EXIT_THE_FUNCTION;
            }

            //
            // Finally copy the remote name from the lpNetResource.
            //
            wcscpy(lpNROut->lpRemoteName, pRemoteName);

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPOpenEnum: lpNROut->lpRemoteName = %ws\n",
                            lpNROut->lpRemoteName));

        } else if (pRemoteName != NULL && didAllocate == TRUE) {
            
            lpNROut->lpRemoteName = pRemoteName;
            
            didAllocate = FALSE;
            
            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPOpenEnum: lpNROut->lpRemoteName(2) = %ws\n",
                            lpNROut->lpRemoteName));
        
        }

        DavEnumNode->lpNetResource = lpNROut;

    }

    //
    // Set DavEnumNode to be the handle. We will get called back in 
    // NpEnumResource with this value.
    //
    *lphEnum = (HANDLE)DavEnumNode;
    NPStatus = WN_SUCCESS;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPOpenEnum");

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: DavEnumNode = %08lx\n", DavEnumNode));

EXIT_THE_FUNCTION:

    //
    // If we did not succeed, then we should be freeing the memory if we 
    // allocated any. Also, set *lphEnum to NULL just to be on the safe side.
    //
    if (NPStatus != WN_SUCCESS || bRetEnumNode == FALSE) {
        if (lpNROut) {
            if (lpNROut->lpRemoteName) {
                LocalFree(lpNROut->lpRemoteName);
                lpNROut->lpRemoteName = NULL;
            }
            LocalFree(lpNROut);
            lpNROut = NULL;
        }
        if (DavEnumNode) {
            LocalFree(DavEnumNode);
            DavEnumNode = NULL;
        }

        if (lphEnum) {
            *lphEnum = NULL;
        }
    }
    
    if (didAllocate == TRUE && RemoteName != NULL) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPOpenEnum: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();

    return NPStatus;
}


DWORD
NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    Perform an enumeration based on handle returned by NPOpenEnum.

Arguments:

    hEnum - This must be a handle obtained from NPOpenEnum call.
    
    lpcCount - Specifies the number of entries requested. It may be 0xFFFFFFFF 
               to request as many as possible. On successful call, this location 
               will receive the number of entries actually read.
    
    lpBuffer - A pointer to the buffer to receive the enumeration result, which 
               are returned as an array of NETRESOURCE entries. The buffer is 
               valid until the next call using hEnum.
    
    lpBufferSize - This specifies the size in bytes of the buffer passed to the 
                   function call on entry. On exit, if the buffer is too small 
                   for even one entry, this will contain the number of bytes 
                   needed to read one entry. The value is only set if the 
                   return code is WN_MORE_DATA.

Return Value:

    WN_SUCCESS - If the call is successful, the caller may continue to call 
                NPEnumResource to continue the enumeration.
    
    WN_NO_MORE_ENTRIES - No more entries found, the enumeration completed 
                         successfully (the contents of the return buffer is 
                         undefined).
    
    WN_MORE_DATA - The buffer is too small even for one entry.
    
    WN_BAD_HANDLE - hEnum is not a valid handle.
    
    WN_NO_NETWORK - Network is not present. This condition is checked for before 
                    hEnum is tested for validity.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode = NULL;
    BOOL SrvExists = FALSE, RpcBindSucceeded = FALSE;
    handle_t dav_binding_h = NULL;
    DWORD cRequested = 0, Index = 0, EntryLengthNeededInBytes = 0, BufferSizeRemaining = 0;
    LPNETRESOURCEW lpNROut = NULL;
    PWCHAR lpszNext = NULL;
    BOOLEAN AreWeDone = FALSE;
    PWCHAR FromEnd = NULL;
    DWORD LocalNameLength = 0, RemoteNameLength = 0, DisplayNameLength = 0;
    WCHAR LocalName[3]=L""; 
    PWCHAR RemoteName = NULL, ServerName = NULL;
    DWORD ServerNameMaxLen = 0, RemoteNameMaxLen = 0;
    BOOLEAN RemoteNameAllocated = FALSE, ServerNameAllocated = FALSE;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPEnumResource: Entered.\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPEnumResource/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    if ( lpcCount == NULL || lpBufferSize == NULL || (lpBuffer == NULL && *lpBufferSize != 0)) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource: Invalid Parameter\n"));
        NPStatus = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    if ( hEnum == NULL ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource: Invalid Handle\n"));
        NPStatus = WN_BAD_HANDLE;
        goto EXIT_THE_FUNCTION;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: hEnum = %08lx\n", hEnum));
    IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: Count = %u\n", *lpcCount));

    DavEnumNode = (PDAV_ENUMNODE)hEnum;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPEnumResources");
    
    if ( DavEnumNode->Done == TRUE ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: Done == TRUE\n"));
        NPStatus = WN_NO_MORE_ENTRIES;
        goto EXIT_THE_FUNCTION;
    }

    BufferSizeRemaining = *lpBufferSize;
    
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = (LPWSTR)(lpNROut + 1);
    FromEnd = (PWCHAR) ( ( (PBYTE)lpNROut ) +  BufferSizeRemaining );

    cRequested = *lpcCount;
    *lpcCount = 0;

    if ( (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_SERVER) &&
         (DavEnumNode->lpNetResource == NULL ||
          DavEnumNode->lpNetResource->lpRemoteName == NULL) ) {
        
        // 
        // Return the list of servers that are accessed from this machine.
        // Make sure that only servers accessed from a user's view
        // should be shown.

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        // 
        // Allocate Memory for RemoteName
        //
        RemoteNameMaxLen = (MAX_PATH + 1);
        RemoteName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT),
                                 (RemoteNameMaxLen * sizeof(WCHAR)));
        if (RemoteName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        RemoteNameAllocated = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1 )&& *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            Index = DavEnumNode->Index;

            //
            // Enumerate all the servers exposed to this user's view.
            //
            RemoteNameLength = RemoteNameMaxLen;
            
            RpcTryExcept {
                NPStatus = DavrEnumServers(dav_binding_h,
                                           &(Index),
                                           &(RemoteNameLength),
                                           &(RemoteName[0]),
                                           &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumServers. NPStatus = "
                                    "%08lx\n", NPStatus));
                    if ( NPStatus == ERROR_INSUFFICIENT_BUFFER ) {
                        // 
                        // Comming here => UNC-servername length is greater than
                        // length of buffer passed to this function which is
                        // = (MAX_PATH + 1). Break here and investigate.
                        //
                        IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumServers. ServerNameLength"
                                    " is %d!!!\n", RemoteNameLength));
                        ASSERT(FALSE);
                    }
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumServers."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            // 
            // To be on safe side - end this buffer with null character else
            // if DavrEnumShare has returned a share name >= buffer len, then 
            // it is trouble here.
            //
            RemoteName[RemoteNameMaxLen-1]=L'\0';

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }
        
            IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: ServerName = %ws\n", RemoteName));
        
            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA."
                                    "Supplied=%d, Required=%d\n", 
                                    BufferSizeRemaining, EntryLengthNeededInBytes));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_GLOBALNET;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // When we are enumerating servers, we don't have a LocalNames.
            //
            lpNROut->lpLocalName = NULL;
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Note: Do not change Index, it is updated inside the rpc 
            // function (DavrEnumServers).
            //
            DavEnumNode->Index = Index;


            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;

            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(0)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);
        
        } while (TRUE);

    } else if (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_SHARE &&
               DavEnumNode->lpNetResource != NULL &&
               DavEnumNode->lpNetResource->lpRemoteName != NULL) {

        //
        // Return list of shares for given UNC server name.
        //

        // 
        // Allocate Memory for RemoteName
        //
        RemoteNameMaxLen = (MAX_PATH + 1);
        RemoteName = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, RemoteNameMaxLen*sizeof(WCHAR));
        if (RemoteName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        RemoteNameAllocated = TRUE;

        // 
        // Allocate Memory for ServerName
        //
        ServerNameMaxLen = MAX_PATH+1;
        ServerName = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, ServerNameMaxLen*sizeof(WCHAR));
        if (ServerName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerNameAllocated = TRUE;

        //
        // Note: The remotename here is already converted to valid UNC
        // form in NPOpenEnum function.
        //
        SrvExists = DavServerExists(DavEnumNode->lpNetResource->lpRemoteName,
                                    ServerName);
        if ( !SrvExists ) {
            NPStatus = WN_BAD_HANDLE;
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavServerExists."
                                    "NPStatus=%d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerName[ServerNameMaxLen-1] = L'\0';

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1 )&& *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            Index = DavEnumNode->Index;

            //
            // BUGBUG: We can support enumeration of resources on server. Beside this
            // , we can also support the enumeration of the shares - but we are not doing that
            // for now.
            //
            RpcTryExcept {
                NPStatus = DavrEnumShares(dav_binding_h, &(Index), ServerName, RemoteName, &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumShares. NPStatus = "
                                    "%08lx\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumShares."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            // 
            // To be on safe side - end thi buffer with null character else
            // if DavrEnumShare has returned a share name >= buffer len, then 
            // it is trouble here.
            //
            RemoteName[RemoteNameMaxLen-1]=L'\0';

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }
        
            IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: ShareName = %ws\n", RemoteName));
        
            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA."
                                    "Supplied=%d, Required=%d\n", 
                                    BufferSizeRemaining, EntryLengthNeededInBytes));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_SHAREABLE;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // When we are enumerating shares, we don't have a LocalNames.
            //
            lpNROut->lpLocalName = NULL;
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Increment the index to point to the next entry to be returned.
            //
            (DavEnumNode->Index)++;

            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;

            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(1)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);
        
        } while (TRUE);
    
    } else if (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_USE) {

        // 
        // Allocate Memory for RemoteName
        //
        RemoteNameMaxLen = MAX_PATH+1;
        RemoteName = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, RemoteNameMaxLen*sizeof(WCHAR));
        if (RemoteName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        RemoteNameAllocated = TRUE;

        // 
        // Allocate Memory for ServerName
        //
        ServerNameMaxLen = (MAX_PATH + 1);
        ServerName = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, ServerNameMaxLen*sizeof(WCHAR));
        if (ServerName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerNameAllocated = TRUE;

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1) && *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            ZeroMemory( LocalName, ( 3 * sizeof(WCHAR) ) );
            ZeroMemory( RemoteName, RemoteNameMaxLen * sizeof(WCHAR) );

            Index = DavEnumNode->Index;

            RpcTryExcept {
                NPStatus = DavrEnumNetUses(dav_binding_h, &(Index), LocalName, RemoteName, &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumNetUses. NPStatus = "
                                    "%08lx\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumNetUses."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            // 
            // Set NULL character in the end of remotename buffer to rule out
            // any possibility of use name running out of buffer length.
            //
            RemoteName[RemoteNameMaxLen-1]=L'\0';
            LocalName[2]=L'\0';

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPEnumResource: LocalName = %ws, RemoteName = %ws\n",
                            LocalName, RemoteName));
            
            //
            // The LocalName may or may not exist. If the user does 
            // net use \\server\share, there is no local name.
            //
            LocalNameLength = wcslen(LocalName) + 1;
            if (LocalNameLength == 1) {
                LocalNameLength = 0;
            }

            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( LocalNameLength * sizeof(WCHAR) )  +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA\n"));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_CONNECTED;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // Fill in the LocalName if one exists.
            //
            if ( LocalNameLength != 0 ) {
                FromEnd -= LocalNameLength;
                wcscpy(FromEnd, LocalName);
                lpNROut->lpLocalName = FromEnd;
            }
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Increment the index to point to the next entry to be returned.
            //
            (DavEnumNode->Index)++;

            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;
            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(1)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);
        
        } while ( TRUE );

    } else {
        
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource: DavEnumNodeType = %d\n",
                                     DavEnumNode->DavEnumNodeType));
        NPStatus = WN_BAD_HANDLE;
        goto EXIT_THE_FUNCTION;
    
    }

EXIT_THE_FUNCTION:

    //
    // If RPC binding was successfully done, we need to free it now.
    //
    if (RpcBindSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindSucceeded = FALSE;
    }
    if (ServerNameAllocated == TRUE && ServerName != NULL) {
        LocalFree((HLOCAL)ServerName);
        ServerName = NULL;
        ServerNameAllocated = FALSE;
    }
    if (RemoteNameAllocated == TRUE && RemoteName != NULL) {
        LocalFree((HLOCAL)RemoteName);
        RemoteName = NULL;
        RemoteNameAllocated = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPEnumResource: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    
    return NPStatus;
}

    
DWORD
NPCloseEnum (
    HANDLE hEnum
    )
/*++

Routine Description:

    This routine closes an enumeration and frees up the resources.

Arguments:

    hEnum - This must be a handle obtained from NPOpenEnum call.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is returned, 
                 which may include:
    
    WN_NO_NETWORK - Network is not present. This condition is checked for before 
                    hEnum is tested for validity.
    
    WN_BAD_HANDLE - hEnum is not a valid handle.
    
--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode;
    HLOCAL Handle;
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPCloseEnum: hEnum = %08lx\n", hEnum));
    
    DavEnumNode = (PDAV_ENUMNODE)hEnum;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPCloseEnum");
    //
    // If the hEnum sent in was NULL, we return right away.
    //
    if (DavEnumNode == NULL) {
        return NPStatus;
    }

    if (DavEnumNode->lpNetResource) {

        if (DavEnumNode->lpNetResource->lpRemoteName) {
            //
            // Free the memory we allocated for the RemoteName in NPOpenEnum.
            //
            Handle = LocalFree(DavEnumNode->lpNetResource->lpRemoteName);
            if (Handle != NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                             " %08lx\n", NPStatus));
            }
            DavEnumNode->lpNetResource->lpRemoteName = NULL;
        }

        //
        // Free the memory we allocated for the NetResource in NPOpenEnum.
        //
        Handle = LocalFree(DavEnumNode->lpNetResource);
        if (Handle != NULL) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                     " %08lx\n", NPStatus));
        }
        DavEnumNode->lpNetResource = NULL;

    }
    
    //
    // Finally, free the DavEnumNode.
    //
    Handle = LocalFree(DavEnumNode);
    if (Handle != NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                     " %08lx\n", NPStatus));
    }
    DavEnumNode = NULL;
    
    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPCloseEnum: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    return NPStatus;
}


DWORD
NPGetResourceInformation(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPTSTR *lplpSystem
    )
/*++

Routine Description:

    NPGetResourceInformation determines whether this provider is the right 
    provider to respond to a request for a specified network resource, and 
    returns information about the resource's type. This routine closes an 
    enumeration and frees up the resources.

Arguments:

    lpNetResource - Specifies the network resource for which information is 
                    required. The lpRemoteName field specifies the remote name 
                    of the resource. The calling program should fill in the 
                    values for the lpProvider and dwType fields if it knows 
                    them; otherwise, it should set them to NULL. All other 
                    fields in the NETRESOURCE are ignored and are not initialized.
                    If the lpRemoteName string contains a portion that is 
                    accessed through WNet APIs and a portion that is accessed 
                    through other system APIs specific to the resource type, 
                    the function should only return information about the 
                    network portion of the resource (except for lplpSystem as 
                    described below). For example, if the resource is 
                    "\\server\share\dir1\dir2" where "\\server\share" is 
                    accessed through WNet APIs and "\dir1\dir2" is accessed 
                    through file system APIs, the provider should verify that it 
                    is the right provider for "\\server\share", but need not 
                    check whether "\dir1\dir2" actually exists.
                    
    lpBuffer - A pointer to the buffer to receive the result. The first field in 
               the result is a single NETRESOURCE structure (and associated 
               strings) representing that portion of the input resource that is 
               accessed through WNet APIs, rather than system APIs specific to 
               the resource type. (For example, if the input remote resource 
               name was "\\server\share\dir1\dir2", then the output NETRESOURCE 
               contains information about the resource "\\server\share"). The 
               lpRemoteName, lpProvider, dwType, dwDisplayType and dwUsage 
               fields are returned, all other fields being set to NULL. 
               lpRemoteName should be returned in the same syntax as that 
               returned from an enumeration by the NPEnumResource function, so 
               that the caller can perform a case sensitive string comparison to 
               determine whether the output network resource is the same as one 
               returned by NPEnumResource. The provider should not do purely 
               syntactic checking to determine whether it owns the resource, as 
               this could produce incorrect results when two networks are running 
               on the client and the provider doing syntactic checking is called 
               first.
                
    lpcbBuffer - Points to a location that specifies the size, in bytes, of the 
                 buffer pointed to by lpBuffer. If the buffer is too small for 
                 the result, the function places the required buffer size at 
                 this location and returns the error WN_MORE_DATA.                    

    lplpSystem - On a successful return, points to a string in the output buffer 
                 that specifies the part of the resource that is accessed through 
                 system APIs specific to the resource type rather than WNet APIs. 
                 If there is no such part, lplpSystem is set to NULL. For example, 
                 if the input remote resource name was "\\server\share\dir", then 
                 lpRemoteName is returned pointing to "\\server\share" and 
                 lplpSystem points to "\dir", both strings being stored in the 
                 buffer pointed to by lpBuffer.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is returned, 
                 which may include:
    
    WN_MORE_DATA - Input buffer is too small.
    
    WN_BAD_NETNAME - The resource is not recognized by this provider.
    
    WN_BAD_VALUE - Invalid dwUsage or dwType.
    
    WN_BAD_DEV_TYPE - The caller passed in a non-zero dwType that does not match 
                      the actual type of the network resource.
    
    WN_NOT_AUTHENTICATED - The caller has not been authenticated to the network.
    
    WN_ACCESS_DENIED - The caller has been authenticated to the network, but 
                       does not have sufficient permissions (access rights).
    
--*/
{
    ULONG NPStatus = WN_SUCCESS;
    BOOL fExists = FALSE;
    DWORD iBackslash = 0;
    LPNETRESOURCEW lpNROut = NULL;
    LPWSTR lpszNext = NULL;
    DWORD cbNeeded = 0, dwDisplayType = 0, cbProvider = 0, cbRemote = 0;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;
    PWCHAR PathPtr = NULL;
    DWORD cbPath = 0;
    
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetResourceInformation.\n"));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPGetResourceInformation");
    
    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Validate the parameters passed to the function.
    //
    if ( lpNetResource == NULL               || 
         lpNetResource->lpRemoteName == NULL ||
         lpcbBuffer == NULL                  || 
         lplpSystem == NULL                  || 
         (lpBuffer == NULL && *lpcbBuffer != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation(1). NPStatus = %d.\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Initialize local variables.
    //
    cbNeeded = sizeof(NETRESOURCEW);
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = lpBuffer == NULL? NULL : (LPWSTR)(lpNROut + 1);

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceInformation: lpRemoteName = %ws.\n",
                    lpNetResource->lpRemoteName));

    
    // 
    // Check remote name passed to this function - and convert it to UNC name
    // if it is in URL form. After converting to UNC name - canonicalize it
    // which checks for validity of UNC name more strictly.
    // 
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE,
                                                  &remNameType,
                                                  &(iBackslash),
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = WN_SUCCESS;
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceInformation: RemoteName = %ws, NameType=%d\n", 
                    RemoteName, remNameType));

    // 
    // Remote name is successfully converted to a valid UNC form. It is either a 
    // UNC-server name (this is added with DUMMY share), or UNC-share name or UNC-path name.
    //
    
    //
    // Set a few default values.
    //
    if ( *lpcbBuffer >= cbNeeded ) {
        ZeroMemory(lpNROut, sizeof(NETRESOURCEW));
    }
    *lplpSystem = NULL;


    switch (remNameType) {

        case DAV_REMOTENAME_TYPE_SERVER: {

            // 
            // RemoteName = \\server
            // 
            fExists = DavServerExists(RemoteName, NULL);
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            break;
        }
    
        case DAV_REMOTENAME_TYPE_PATH: {

            // 
            // RemoteName = \\server\share\path
            //

            //
            // Set the lplpSystem pointer.
            //
            
            PathPtr = (RemoteName + iBackslash);
            cbPath = ( ( 1 + wcslen(PathPtr) ) * sizeof(WCHAR) );
            cbNeeded += cbPath;
            if (*lpcbBuffer >= cbNeeded ) {
                *lplpSystem = lpszNext;
                wcscpy(*lplpSystem, PathPtr);
                lpszNext += ( cbPath / sizeof(WCHAR));
            }
            
            //
            // Fall through.
            //
        }

        case DAV_REMOTENAME_TYPE_SHARE: {

            // 
            // RemoteName = \\server\share
            //
            
            // 
            // Control comes here for both cases - when remote name is of type
            // UNC-share or UNC-path    AND 
            // when remote name is or type UNC-server. DUMMYShare is added to it
            // above - making it of UNC-share form (\\server\DUMMYShare).
            //
            fExists = DavShareExists(RemoteName);
            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            break;
        }
        
        default:{
        
            // 
            // Control should not come here. DavCheckAndConvertHttpUrlToUncName
            // returns successful only for valid cases considered above.
            //

            ASSERT(FALSE);
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Invalid "
                                         "DavRemoteNameType = %d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    }
    
    // 
    // UNC - server/share do not exists - quit with error.
    //
    if (fExists == FALSE) {
        if (remNameType == DAV_REMOTENAME_TYPE_SERVER) {
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Server in"
                                         " path %ws does not do DAV\n", RemoteName));
        } else {
            // 
            // remNameType = DAV_REMOTENAME_TYPE_SHARE
            //
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Share in"
                                         " path %ws does not exist\n", RemoteName));
        }
        NPStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Server/Share given in lpRemoteName exists.
    //

    //
    // Set the lpProvider pointer.
    //
    cbProvider = ( (1 + wcslen(DavClientDisplayName) ) * sizeof(WCHAR) );
    cbNeeded += cbProvider;
    if (*lpcbBuffer >= cbNeeded ) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpNROut->lpProvider, DavClientDisplayName);
        lpszNext += ( cbProvider / sizeof(WCHAR) );
    }

    //
    // Set the lpRemoteName pointer. If iBackslash (=offset of \dir portion in
    // \\server\share\dir...) is > 0, then the lpRemoteName that was sent has 
    // the form \\server\share\dir... . 
    // If it is = 0, then the RemoteName form is \\server\share or \\server.
    //
    if (iBackslash > 0) {
        //
        // RemoteName = \\server\share\dir
        //                            ^
        //                            |
        //                            iBackslash
        cbRemote = ( (1 + iBackslash) * sizeof(WCHAR) );
        cbNeeded += cbRemote;
        if ( *lpcbBuffer >= cbNeeded ) {
            lpNROut->lpRemoteName = lpszNext;
            RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, (iBackslash * sizeof(WCHAR)) );
            lpNROut->lpRemoteName[iBackslash] = L'\0';
            lpszNext += ( cbRemote / sizeof(WCHAR) );
        }
    } else {
        //
        // RemoteName = \\server\share or  \\server
        //
        cbRemote = ( ( 1 + wcslen(RemoteName) ) * sizeof(WCHAR) );
        cbNeeded += cbRemote;
        if (*lpcbBuffer >= cbNeeded ) {
            lpNROut->lpRemoteName = lpszNext;
            wcscpy(lpNROut->lpRemoteName, RemoteName);
            lpszNext += ( cbRemote / sizeof(WCHAR) );
        }
    }
    
    if ( *lpcbBuffer >= cbNeeded ) {
        //
        // All data is filled and supplied buffer is long enough to contain it.
        //
        lpNROut->dwType = RESOURCETYPE_DISK;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
        NPStatus = WN_SUCCESS;
        DavDisplayNetResource(lpNROut, L"lpNROut in NPGetResourceInformation");
        goto EXIT_THE_FUNCTION;
    } else {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation: Need more "
                        "buffer space. Supplied = %d, Required = %d\n",
                        *lpcbBuffer, cbNeeded));
        *lpcbBuffer = cbNeeded;
        NPStatus = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetResourceInformation: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    
    return NPStatus;
}


DWORD
NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    )
/*++

Routine Description:

    NPGetResourceParent returns the parent of a specified network resource in 
    the browse hierarchy.  This function is typically called for resources that 
    were returned by the same provider from prior calls to NPEnumResource or 
    NPGetResourceInformation.

Arguments:

    lpNetResource - This specifies the network resource whose parent name is 
                    required. The NETRESOURCE could have been obtained via a 
                    previous call to NPEnumResource or NPGetResourceInformation, 
                    or constructed by the caller. The lpRemoteName field 
                    specifies the remote name of the network resource whose 
                    parent is required. The lpProvider field specifies the 
                    provider to call. This must be supplied. The dwType field is 
                    filled in if the calling program knows its value, otherwise 
                    it is set to NULL. All other fields in the NETRESOURCE are 
                    ignored and are not initialized.
                    
    lpBuffer - Points to a buffer to receive the result, which is a single 
               NETRESOURCE structure representing the parent resource. The 
               lpRemoteName, lpProvider, dwType, dwDisplayType and dwUsage 
               fields are returned; all other fields are set to NULL. The output 
               lpRemoteName should be in the same syntax as that returned from 
               an enumeration by NPEnumResource, so that the caller can perform 
               a case sensitive string comparison to determine whether the 
               parent resource is the same as one returned by NPEnumResource. 
               If the input resource syntactically has a parent, the provider 
               can return it, without determining whether the input resource or 
               its parent actually exist. If a resource has no browse parent on 
               the network, then lpRemoteName is returned as NULL. The 
               RESOURCEUSAGE_CONNECTABLE bit in the returned dwUsage field does 
               not necessarily indicate that the resource can currently be 
               connected to, only that the resource is connectable when it is 
               available on the network.
                    
    lpcbBuffer - Points to a location that specifies the size, in bytes, of the 
                 buffer pointed to by lpBuffer. If the buffer is too small for 
                 the result, the function places the required buffer size at 
                 this location and returns the error WN_MORE_DATA.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.
    
    WN_BAD_NETNAME - This provider does not own the resource specified by 
                     lpNetResource (or the resource is syntactically invalid).

    WN_BAD_VALUE - Invalid dwUsage or dwType, or bad combination of parameters 
                   is specified (e.g. lpRemoteName is syntactically invalid for 
                   dwType).

    WN_NOT_AUTHENTICATED - The caller has not been authenticated to the network.

    WN_ACCESS_DENIED - The caller has been authenticated to the network, but 
                       does not have sufficient permissions (access rights).

--*/
{
    ULONG NPStatus = WN_SUCCESS;
    ULONG iBackslash = 0;
    LPNETRESOURCEW lpNROut = NULL;
    LPWSTR lpszNext = NULL;
    DWORD cbNeeded = 0, dwDisplayType = 0, cbProvider = 0;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetResourceParent\n"));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPGetResourceParent");

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Check for validity of the parameters passed to this function.
    //
    if (lpNetResource == NULL               || 
        lpNetResource->lpRemoteName == NULL ||
        lpcbBuffer == NULL                  || 
        (lpBuffer == NULL && *lpcbBuffer != 0)) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent(1). NPStatus = %08lx\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Initialize local variables.
    //
    cbNeeded = sizeof(NETRESOURCEW);
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = lpNROut == NULL ? NULL : (LPWSTR)(lpNROut + 1);
    
    // 
    // Check remote name passed to this function - and convert it to UNC name
    // if it is in URL form. After converting to UNC name - canonicalize it
    // which checks for validity of UNC name more strictly.
    //
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE,
                                                  &remNameType,
                                                  &(iBackslash),
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = WN_SUCCESS;
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceParent : RemoteName = %ws.\n", RemoteName));

    // 
    // Remote name is successfully converted to a valid UNC form. It is either a 
    // UNC-server name, or UNC-share name or UNC-path name.
    //
    
    //
    // Set a few default values.
    //
    if ( *lpcbBuffer >= cbNeeded ) {
        ZeroMemory(lpNROut, sizeof(NETRESOURCEW));
    }

    switch (remNameType) {

        case DAV_REMOTENAME_TYPE_SERVER: {

            //
            // There is no domain concept for DAV servers. So return NULL for lpRemoteName
            // to indicate that server is the top level resource of this provider.
            //
            lpNROut->lpRemoteName = NULL;
            dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
            
            break;
        }

        case DAV_REMOTENAME_TYPE_SHARE: {
            
            // 
            // RemoteName = \\server\share(\)
            //
        
            DWORD Count = 0, cbRemote = 0;
            PWCHAR Ptr1 = NULL;
        
            Ptr1 = wcschr (&(RemoteName[2]), L'\\');

            // 
            // A trick: Share name here can be DAV_DUMMY_SHARE. If that is the case,
            // then \\server\DAV_DUMMY_SHARE is actually <==> \\server in which 
            // case, it has no parent.
            //
            if (_wcsnicmp( (Ptr1 + 1),
                           DAV_DUMMY_SHARE,
                           wcslen(DAV_DUMMY_SHARE) ) == 0) {
                IF_DEBUG_PRINT(DEBUG_MISC,
                               ("NPGetResourceParent. RemoteName has DUMMYShare = %ws\n",
                                RemoteName));
                lpNROut->lpRemoteName = NULL;
                dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
                break;
            }
        
            //  
            // Copy the lpRemoteName.
            //  
            Count = (DWORD) ( Ptr1 - RemoteName );
            cbRemote = (Count + 1) * sizeof(WCHAR);
            cbNeeded += cbRemote;
            if (*lpcbBuffer >= cbNeeded ) {
                lpNROut->lpRemoteName = lpszNext;
                RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, Count * sizeof(WCHAR) );
                lpNROut->lpRemoteName[Count] = L'\0';
                lpszNext += ( cbRemote / sizeof(WCHAR) );
            }
            
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            
            break;
        
        }

        case DAV_REMOTENAME_TYPE_PATH: {
            
            // 
            // RemoteName = \\server\share\path\...
            // OR
            // RemoteName = \\server\share\path\...\
            //
            
            DWORD Count = 0, cbRemote = 0;
            PWCHAR Ptr1 = NULL, Ptr2 = NULL, Ptr3 = NULL;
            BOOLEAN LastCharIsWack = FALSE;
            PWCHAR ResourceStart = NULL;

            Ptr3 = &(RemoteName[0]);
            while (Ptr3[0] != L'\0') {
                if (Ptr3[0] == L'\\') {
                        Ptr1 = Ptr2;
                        Ptr2 = Ptr3;
                        Count++;
                }
                Ptr3++;
            }
            
            if (Ptr2[1] == L'\0') {
                LastCharIsWack = TRUE;
                ResourceStart = Ptr1;
            } else {
                ResourceStart = Ptr2;
            }
            
            //
            // After this while loop:
            // \\server\share\pathname\
            //               ^        ^
            //               |        | 
            //               Ptr1     Ptr2
            //  Ptr2 points to last L'\', while Ptr1 points to second last L'\'.
            //  And Count = Number of L'\' in the RemoteName.
            //

            if ((Count < 5) || (Count == 5 && LastCharIsWack == TRUE)) {
                dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            } else {
                dwDisplayType = RESOURCEDISPLAYTYPE_DIRECTORY;
            }

            //  
            // Copy the lpRemoteName.
            //  
            Count = (DWORD) ( ResourceStart - RemoteName);
            cbRemote = (Count + 1) * sizeof(WCHAR);
            cbNeeded += cbRemote;
            if ( *lpcbBuffer >= cbNeeded ) {
                lpNROut->lpRemoteName = lpszNext;
                RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, Count * sizeof(WCHAR) );
                lpNROut->lpRemoteName[Count] = L'\0';
                lpszNext += ( cbRemote / sizeof(WCHAR) );
            }

            break;
        }
        
        default:{
            
            // 
            // Control should not come here - DavCheckAnd... API returns successfully
            // only for valid cases considered above.
            //

            ASSERT(FALSE);
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                            ("ERROR: NPGetResourceParent: Invalid "
                             "DavRemoteNameType = %d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            
            goto EXIT_THE_FUNCTION;
        
        }

    }

    //
    // Set the lpProvider pointer.
    //
    cbProvider = ( (1 + wcslen(DavClientDisplayName) ) * sizeof(WCHAR) );
    cbNeeded += cbProvider;
    if ( *lpcbBuffer >= cbNeeded ) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpNROut->lpProvider, DavClientDisplayName);
        lpszNext += ( cbProvider / sizeof(WCHAR) );
    }

    // 
    // If supplied buffer is long enough to contain whole data then return success.
    // 
    if ( *lpcbBuffer >= cbNeeded ) {
        lpNROut->dwType = RESOURCETYPE_DISK;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
        NPStatus = WN_SUCCESS;
        DavDisplayNetResource(lpNetResource, L"lpNROut in NPGetResourceParent");
        goto EXIT_THE_FUNCTION;
    } else {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent: Need more "
                        "buffer space. Supplied = %d, Required = %d\n",
                        *lpcbBuffer, cbNeeded));
        *lpcbBuffer = cbNeeded;
        NPStatus = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetResourceParent: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    return NPStatus;
}


DWORD
NPGetUniversalName(
    IN LPCWSTR lpLocalPath,
    IN DWORD dwInfoLevel,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns the UNC name of the network resource associated with
    a redirected local device.

Arguments:

    lpLocalPath - Specifies the name of the redirected local drive, like
                  W:\bar\foo1.txt
                  
    dwInfoLevel - UniversalName or RemoteName (See the def of WNetGetUniversalName).

    lpBuffer - The NameInfo is filled in if the call is successful.
    
    lpBufferSize - Contains the size of the buffer lpBuffer. If the call fails
                   with WN_MORE_DATA, this contains the size of buffer needed.

Return Value:

    WN_SUCCESS - Success.
    
    WN_NOT_CONNECTED - lpLocalPath is not a redirected local path.
    
    WN_BAD_VALUE - 
    
    WN_MORE_DATA - Buffer was too small.
    
    WN_OUT_OF_MEMORY - Cannot allocate buffer due memory shortage.
    
    WN_NET_ERROR - Other network error.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    DWORD cbNeeded = 0, LocalPathLen = 0, UncNameLen = 0, RemoteNameLen = 0;
    WCHAR localDrive[3]=L"";
    WCHAR CanonName[MAX_PATH+1]=L"";
    ULONG CanonNameSize = sizeof(CanonName);
    ULONG CanonNameLen = 0;
    ULONG CanonNameMaxLen = sizeof(CanonName)/sizeof(WCHAR);
    NET_API_STATUS NetApiStatus = NERR_Success;
    LPUNIVERSAL_NAME_INFO lpUNOut = NULL;
    LPREMOTE_NAME_INFO lpRNOut = NULL;
    PWCHAR lpszNext = NULL, RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DWORD PathType = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, 
                   ("NPGetUniversalName: lpLocalPath = %ws, dwInfoLevel = %d"
                    "lpBuffer=0x%x, lpBufferSize=0x%x, *lpBufferSize=%d\n",
                    lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize,
                    lpBufferSize == NULL?-1:*lpBufferSize));
    
    //
    // Initialize local variables
    //
    didAllocate = FALSE;
    lpRNOut = NULL;
    lpUNOut = NULL;
    lpszNext = NULL;
    RemoteName = NULL;
    
    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUniversalName/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check for bad info level.
    //
    if ( (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) && (dwInfoLevel != REMOTE_NAME_INFO_LEVEL) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad InfoLevel\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check for validity of the parameters passed to this function.
    //
    if ( lpLocalPath == NULL || lpBufferSize == NULL || (lpBuffer == NULL && *lpBufferSize != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad Pointers\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Local path must at least have "X:".
    //
    LocalPathLen = wcslen(lpLocalPath) + 1;
    if ( (LocalPathLen < 3)       ||
         (lpLocalPath[1] != L':') ||
         ((LocalPathLen > 3) && (lpLocalPath[2] != L'\\')) ) {
        NPStatus = WN_BAD_LOCALNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad LocalPath\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Canonicalize the local path to take care of invalid forms + 
    // macros expansion like '.' and '..'
    //
    PathType = 0;
    NetApiStatus = I_NetPathCanonicalize(NULL,
                                         (PWCHAR)lpLocalPath,
                                         CanonName,
                                         CanonNameSize,
                                         NULL,
                                         &PathType,
                                         0);
    if ( (NetApiStatus != NERR_Success) || 
         ( (PathType != ITYPE_DEVICE_DISK) && // lpLocalPath=C:
           ( !(PathType & ITYPE_PATH) ||      // lpLocalPath=C:\abc\..\asds
             !(PathType & ITYPE_DPATH) )
           ) ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUniversalName/I_NetPathCanonicalize: "
                        "NetApiStatus = %08lx\n", NetApiStatus));
        NPStatus = WN_BAD_LOCALNAME;
        goto EXIT_THE_FUNCTION;
    }

    CanonName[CanonNameMaxLen-1] = L'\0';
    CanonNameLen = wcslen(CanonName) + 1;
    
    //
    // Now onwards, use Canonicalized name instead of lpLocalPath to return more meaningful
    // values.
    //

    localDrive[0]=CanonName[0];
    localDrive[1]=CanonName[1];
    localDrive[2]=L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName/I_NetPathCanonicalize: "
                                "CanonName= %ws, LocalDrive=%ws\n", CanonName, localDrive));

    //
    // Use the available buffer for storing remote name for now. We will allocate 
    // local copy of remote name later if required.
    //
    RemoteNameLen = (*lpBufferSize)/sizeof(WCHAR);
    NPStatus = NPGetConnection(localDrive, lpBuffer, &RemoteNameLen);
    
    if (NPStatus != WN_MORE_DATA && NPStatus != WN_SUCCESS) {
        //
        // The local drive is not valid for our provider - or some other error occured.
        // Return error.
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName/NPGetConnection: "
                                      "NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if ( NPStatus == WN_SUCCESS ) {
        RemoteNameLen = wcslen(lpBuffer) + 1;
        IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPGetUniversalName/NPGetConnection: "
                        "RemoteUncName = %ws, RemoteNameLen = %d\n",
                        lpBuffer, RemoteNameLen));
    }

    // 
    // NPStatus = WN_SUCCESS OR NPStatus = WN_MORE_DATA. In either case cbRemote will
    // have the sizeof(RemoteName-for-local-drive) for given local drive.
    //

    // 
    // UNC path = "RemoteName-for-local-drive" + "RemainingPath-in-local-path"
    // Where RemainingPath-in-local-path is path remaining after removing local-drive
    // portion (ex. "C:") from the local-path.
    // So len(UNC Path) = len(RemoteName) + (CanonNameLen-2).
    // Where subtract=2 denote removing local-drive portion (ex "C:" from localpath).
    // Subtract 1 from RemoteNameLen to remove NULL character from RemoteName,
    // a NULL character is already accounted in CanonName
    //
    UncNameLen = (RemoteNameLen - 1) + (CanonNameLen - 2);
    
    switch (dwInfoLevel) {
    
        case UNIVERSAL_NAME_INFO_LEVEL: {
            
            cbNeeded = sizeof(UNIVERSAL_NAME_INFO);
            lpUNOut = (LPUNIVERSAL_NAME_INFO)lpBuffer;
            lpszNext = lpBuffer == NULL ? NULL:(LPWSTR)(lpUNOut + 1);
            
            //
            // Calculate the bytes we really need = sizeof(STRUCTURE) + sizeof(UNC Path).
            //
            cbNeeded += ((UncNameLen)*sizeof(WCHAR));
            IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName: BufReq=%d\n", cbNeeded));

            //
            // If the number of bytes that were passed in is not sufficient, we 
            // return WN_MORE_DATA.
            //
            if (*lpBufferSize < cbNeeded) {
                *lpBufferSize = cbNeeded;
                NPStatus = WN_MORE_DATA;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Create local copy of remote name. Deallocate it in the end.
            //
            ASSERT (RemoteName == NULL);
            RemoteName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                              (RemoteNameLen * sizeof(WCHAR)) ) ;
            if (RemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUniversalName/LocalAlloc. NPStatus = %08lx\n", 
                                NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            didAllocate = TRUE;
            wcscpy(RemoteName, lpBuffer);

            ZeroMemory(lpUNOut,sizeof(UNIVERSAL_NAME_INFO));
            //
            // Now, we have enough buffer, copy the information into the buffer.
            //

            lpUNOut->lpUniversalName = lpszNext;
            wcscpy(lpUNOut->lpUniversalName, RemoteName);

            //
            // We concatenate the name afterthe drive letter to the RemoteBuffer
            // we copied above.
            //
            wcscat( lpUNOut->lpUniversalName, (CanonName + 2) );
            NPStatus = WN_SUCCESS;
        
            break;
        }

        case REMOTE_NAME_INFO_LEVEL: {
       
            cbNeeded = sizeof(REMOTE_NAME_INFO);
            lpRNOut = (LPREMOTE_NAME_INFO)lpBuffer;
            lpszNext = lpBuffer == NULL ? NULL:(LPWSTR)(lpRNOut + 1);
        
            //
            // Calculate the bytes we really need = sizeof(STRUCTURE) + sizeof(UNC Path) +
            // sizeof(ConnectionPath) + sizeof(RemainingPath).
            //
            cbNeeded += ( ( UncNameLen    +                           // UNC Path
                            RemoteNameLen +                           // ConnectionPath
                            (CanonNameLen - 2) ) * sizeof(WCHAR) );   // RemainingPath

            IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName: BufReq=%d\n", cbNeeded));
            //
            // If the number of bytes that were passed in is not sufficient, we 
            // return WN_MORE_DATA.
            //
            if (*lpBufferSize < cbNeeded) {
                *lpBufferSize = cbNeeded;
                NPStatus = WN_MORE_DATA;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Create local copy of remote name. Deallocate it in the end.
            //
            ASSERT (RemoteName == NULL);
            RemoteName = (PWCHAR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, 
                                                    RemoteNameLen*sizeof(WCHAR)) ;
            if (RemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUniversalName/LocalAlloc. NPStatus = %08lx\n", 
                                NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            didAllocate = TRUE;
            
            wcscpy(RemoteName, lpBuffer);

            ZeroMemory(lpRNOut,sizeof(REMOTE_NAME_INFO));
            
            //
            // Now, we have enough buffer, copy the information into the buffer.
            //

            lpRNOut->lpUniversalName = lpszNext;
            lpszNext += UncNameLen;
            wcscpy(lpRNOut->lpUniversalName, RemoteName);

            //
            // We concatenate the name afterthe drive letter to the RemoteBuffer
            // we copied above.
            //
            wcscat( lpRNOut->lpUniversalName, (CanonName + 2) );
            
            //
            // Copy the connection name.
            //
            lpRNOut->lpConnectionName = lpszNext;
            lpszNext += RemoteNameLen;
            wcscpy(lpRNOut->lpConnectionName, RemoteName);

            //
            // Copy the remaining path.
            //
            lpRNOut->lpRemainingPath = lpszNext;
            wcscpy( lpRNOut->lpRemainingPath, (CanonName+ 2) );
            
            NPStatus = WN_SUCCESS;

            break;
        }

        default: {

            //
            // We should never come here since we make this check above.
            //
            NPStatus = WN_BAD_VALUE ;
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad InfoLevel\n"));
            ASSERT(FALSE);
            goto EXIT_THE_FUNCTION;
        }
    }

EXIT_THE_FUNCTION:

    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        didAllocate = FALSE;
        RemoteName = NULL;
    }

    return NPStatus;
}


DWORD
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
/*++

Routine Description:

    This API allows the provider to trim or modify network names before they are 
    presented to the user.

Arguments:

    lpRemoteName - Network name to be formatted.
    
    lpFormattedName - Pointer to string buffer that will receive the formatted 
                      name.
                      
    lpnLength - Pointer to DWORD that specifies the size of the buffer (in 
                characters) passed in.  If the result is WN_MORE_DATA, this will 
                contain the buffer size required (in characters).
                
    dwFlags - Bitfield indicating the type of format being requested. Can be one 
              of:
        
              WNFMT_MULTILINE (0x01) - The provider should place the '\n' 
                                       character where line breaks should appear 
                                       in the name.  The full name should be 
                                       expressed.
 
              WNFMT_ABBREVIATED (0x02) - The provider should ellipsize or 
                                         otherwise shorten the network name such 
                                         that the most useful information will be 
                                         available to the user in the space 
                                         provided.
                                         
              In addition, the following flags may be 'or'ed in and act as 
              modifiers to the above flags:
              
              WNFMT_INENUM (0x10) - The network name is being presented in the 
                                    context of an enumeration where the 
                                    "container" of this object is presented 
                                    immediately prior to this object. This may 
                                    allow network providers to remove redundant 
                                    information from the formatted name, 
                                    providing a less cluttered display for the 
                                    user.

    dwAveCharPerLine - This is the average number of characters that will fit on 
                       a single line where the network name is being presented. 
                       Specifically, this value is defined as the width of the 
                       control divided by the tmAveCharWidth of the TEXTMETRIC 
                       structure from the font used for display in the control.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.
    
    All other errors will be ignored by the caller and the unformatted network 
    name will be used.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    ULONG NameLength = 0;
    LPWSTR pszCopyFrom = NULL, pszThird = NULL;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("NPFormatNetworkName: RemoteName = %ws\n",
                    lpRemoteName));

    //
    // We do some checks before proceeding further.
    //

    if ( (dwFlags & WNFMT_MULTILINE) && (dwFlags & WNFMT_ABBREVIATED) ) {
        NPStatus  = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    if ( lpRemoteName == NULL || lpnLength == NULL || (lpFormattedName == NULL && (*lpnLength != 0)) ) {
        NPStatus  = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    pszCopyFrom = lpRemoteName;
    
    if ( (dwFlags & WNFMT_ABBREVIATED) && (dwFlags & WNFMT_INENUM) ) {

        if (lpRemoteName[0] == L'\\' && lpRemoteName[1] == L'\\') {

            pszThird = wcschr( (lpRemoteName + 2), L'\\' );

            if (pszThird != NULL) {

                //
                // In the form "\\server\share" => get the share name.
                //
                pszCopyFrom = (pszThird + 1);

            } else {

                //
                // In the form "\\server" => get rid of "\\".
                //
                pszCopyFrom = (lpRemoteName + 2);

            }

        }

    }

    //
    // Check to see if the supplied buffer is of the required size. If not
    // return WN_MORE_DATA and fill lpnLength with the needed size in the number
    // of chars.
    //
    NameLength = ( wcslen(pszCopyFrom) + 1 );
    if (NameLength > *lpnLength) {
        *lpnLength = NameLength;
        NPStatus  = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we've come, we're ready to copy the name.
    //
    wcsncpy(lpFormattedName, pszCopyFrom, NameLength);

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPFormatNetworkName: lpFormattedName = %ws\n",
                    lpFormattedName));

    NPStatus = WN_SUCCESS;

EXIT_THE_FUNCTION:

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPFormatNetworkName: NPStatus = %d\n", NPStatus));

    return NPStatus;
}


DWORD
DavMapRpcErrorToProviderError(
    IN DWORD RpcError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{
    switch (RpcError) {

    case RPC_S_UNKNOWN_IF:
    case RPC_S_SERVER_UNAVAILABLE:
    case ERROR_UNEXP_NET_ERR:
    case EPT_S_NOT_REGISTERED:
        return WN_NO_NETWORK;

    case RPC_S_INVALID_BINDING:
    case RPC_X_SS_IN_NULL_CONTEXT:
    case RPC_X_SS_CONTEXT_DAMAGED:
    case RPC_X_SS_HANDLES_MISMATCH:
    case ERROR_INVALID_HANDLE:
        return ERROR_INVALID_HANDLE;

    case RPC_X_NULL_REF_POINTER:
    case ERROR_INVALID_PARAMETER:
        return WN_BAD_VALUE;

    case ERROR_NOACCESS:
    case EXCEPTION_ACCESS_VIOLATION:
        return ERROR_INVALID_ADDRESS;

    case ERROR_OPEN_FILES:
        return WN_OPEN_FILES;

    case ERROR_ALREADY_ASSIGNED:
        return WN_ALREADY_CONNECTED;

    case ERROR_REM_NOT_LIST:
        return WN_BAD_NETNAME;

    case ERROR_BAD_DEVICE:
        return WN_BAD_LOCALNAME;

    case ERROR_INVALID_PASSWORD:
        return WN_BAD_PASSWORD;

    case ERROR_NOT_FOUND:
        return WN_NOT_CONNECTED;

    default:
        return RpcError;
    }
}


DWORD
DavBindTheRpcHandle(
    handle_t *dav_binding_h
    )
/*++

Routine Description:

    This routine binds the RPC handle to the local server.

Arguments:

    dav_binding_h - The pointer to the handle that will be bound to the server
                    in this routine.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    handle_t Handle;

    //
    // Binds the RPC handle to the DAV RPC server.
    //
    WStatus = NetpBindRpc(NULL,
                          L"DAV RPC SERVICE",
                          NULL,
                          &(Handle));
    if (WStatus != RPC_S_OK) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavBindTheRpcHandle/NetpBindRpc. "
                        "WStatus = %08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the handle that was passed into the function.
    //
    *dav_binding_h = Handle;

EXIT_THE_FUNCTION:

    return WStatus;
}


BOOL
DavWorkstationStarted(
    VOID
    )
/*++

Routine Description:

    This function queries the service controller to see if the Dav client
    service has started.  If in doubt, it returns FALSE.

Arguments:

    None.

Return Value:

    Returns TRUE if the DAV client service has started, FALSE otherwise.

--*/
{
    DWORD WStatus;
    SC_HANDLE ScManager;
    SC_HANDLE Service;
    SERVICE_STATUS ServiceStatus;
    BOOL IsStarted = FALSE;

    ScManager = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);
    if (ScManager == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/OpenSCManagerW. "
                        "WStatus = %08lx\n", WStatus));
        return FALSE;
    }

    Service = OpenServiceW(ScManager, SERVICE_DAVCLIENT, SERVICE_QUERY_STATUS);
    if (Service == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/OpenServiceW. "
                        "WStatus = %08lx\n", WStatus));
        CloseServiceHandle(ScManager);
        return FALSE;
    }

    if ( !QueryServiceStatus(Service, &ServiceStatus) ) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/QueryServiceStatus. "
                        "WStatus = %08lx\n", WStatus));
        CloseServiceHandle(ScManager);
        CloseServiceHandle(Service);
        return FALSE;
    }


    if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING)          ||
         (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING)    ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavWorkstationStarted. WebClient Running!!!\n"));
        IsStarted = TRUE;
    } else {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavWorkstationStarted. WebClient Stopped!!!\n"));
    }

    CloseServiceHandle(ScManager);
    CloseServiceHandle(Service);

    return IsStarted;
}


DAV_REMOTENAME_TYPE 
DavParseRemoteName (
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    )
/*++

Routine Description:

    This function canonicalizes a remote resource name and determines its type.

Arguments:

    RemoteName - Remote resource name to be parsed: Expects UNC name here.
        
    CanonName - Buffer for canonicalized name, assumed to be MAX_PATH characters 
                long.
        
    CanonNameSize - Size, in bytes, of output buffer.
    
    PathStart - Set to the offset, in characters, of the start
                of the "\path" portion (in the DAV_REMOTENAME_TYPE_PATH case)
                within CanonName.  Not set in other cases. Otherwise set to 0.

Return Value:

    If RemoteName is like    Then return
    ---------------------    ------------
    workgroup                DAV_REMOTENAME_TYPE_WORKGROUP
    \\server                 DAV_REMOTENAME_TYPE_SERVER
    \\server\share           DAV_REMOTENAME_TYPE_SHARE
    \\server\share\path      DAV_REMOTENAME_TYPE_PATH
    (other)                  DAV_REMOTENAME_TYPE_INVALID

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    DWORD PathType = 0;
    PWCHAR wszDummy = NULL;
    ULONG  ReqLen = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavParseRemoteName: RemoteName = %ws\n", RemoteName));
    
    NetApiStatus = I_NetPathType(NULL, RemoteName, &PathType, 0);
    if (NetApiStatus != NERR_Success) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathType: "
                                     "NetApiStatus = %08lx\n", NetApiStatus));
        return DAV_REMOTENAME_TYPE_INVALID;
    }

    if ( PathStart != NULL) {
        *PathStart = 0;
    }
    //
    // I_NetPathType doesn't give us quite as fine a classification of path 
    // types as we need, so we still need to do a little more parsing.
    //
    switch (PathType) {
        
        case ITYPE_PATH_RELND:
            
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_PATH_RELND\n"));
            
            //
            // A driveless relative path. A valid workgroup or domain name would be 
            // classified as such, but it still needs to be validated as a workgroup 
            // name.
            //
            NetApiStatus = I_NetNameCanonicalize(NULL,
                                                 RemoteName,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NAMETYPE_WORKGROUP,
                                                 0);
            if (NetApiStatus == NERR_Success) {
                return DAV_REMOTENAME_TYPE_WORKGROUP;
            } else {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetNameCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }

            break;

        case ITYPE_UNC_COMPNAME:
            
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_UNC_COMPNAME\n"));
            
            //
            // A UNC computername, "\\server".
            //
                
            //
            // HACK: I_NetPathCanonicalize likes "\\server\share" but not
            // "\\server", so append a dummy share name to canonicalize.
            // We assume that the CanonName buffer will still be big
            // enough (which it will, in the calls made from this file).
            //
            ReqLen = wcslen(RemoteName) + 2 + 1;
            wszDummy = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                          (ReqLen * sizeof(WCHAR)) );
            if (wszDummy == NULL) {
                ULONG WStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavParseRemoteName/LocalAlloc. WStatus = %08lx\n", 
                            WStatus));
                return DAV_REMOTENAME_TYPE_INVALID; 
            }
            
            wcscpy(wszDummy, RemoteName);
            wcscat(wszDummy, L"\\a");
            
            PathType = ITYPE_UNC;
            NetApiStatus = I_NetPathCanonicalize(NULL,
                                                 wszDummy,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NULL,
                                                 &PathType,
                                                 0);
            if(wszDummy) {
                LocalFree((HLOCAL)wszDummy);
                wszDummy = NULL;
            }
            if (NetApiStatus != NERR_Success) {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }
            CanonName[(CanonNameSize/sizeof(WCHAR))-1]=L'\0';

            // 
            // Remove the dummy portion added to remote name = L"\a".
            //
            CanonName[ wcslen(CanonName) - 2 ] = L'\0';
            return DAV_REMOTENAME_TYPE_SERVER;

            break;

        case ITYPE_UNC: {
            
            PWCHAR pShareStart = NULL;
            PWCHAR pPathStart = NULL;
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_UNC\n"));
            
            //
            // A UNC path, either "\\server\share" or "\\server\share\path".
            // Canonicalize and determine which one.
            //
            PathType = ITYPE_UNC;
            NetApiStatus = I_NetPathCanonicalize(NULL,
                                                 RemoteName,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NULL,
                                                 &PathType,
                                                 0);
            if (NetApiStatus != NERR_Success) {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }
            CanonName[(CanonNameSize/sizeof(WCHAR))-1]=L'\0';
                
            pShareStart = wcschr( (CanonName + 2), DAV_PATH_SEPARATOR );
            //
            // Look for a fourth slash. Also, if the form is \\server\share\,
            // we will have 4 slashes but no extra path. Hence the extra check
            // is made.
            //
            pPathStart = wcschr( (pShareStart + 1), DAV_PATH_SEPARATOR );

            if ( pPathStart != NULL &&  *(pPathStart + 1) != L'\0') {
                if(PathStart) {
                    *PathStart = (ULONG)(pPathStart - CanonName);
                }
                return DAV_REMOTENAME_TYPE_PATH;

            } else {
                if(PathStart) {
                    *PathStart = 0;
                }
                return DAV_REMOTENAME_TYPE_SHARE;
            }
            break;
        }
        default: {
            
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName: Invalid PathType\n"));
            return DAV_REMOTENAME_TYPE_INVALID;
            break;
        }
    } // end switch(PathType);

}


BOOL
DavServerExists(
    IN PWCHAR PathName,
    OUT PWCHAR Server
    )
/*++

Routine Description:

    This function figures out if the Server in the PathName is a valid DAV 
    server.

Arguments:

    PathName - A UNC path (\\server\share\dir....). Assuming that it is a valid string.
               It can be of form \\server OR \\server\share  OR \\server\share\dir...
    
    Server - If non NULL, the server in the PathName is filled in on return.

Return Value:

    TRUE - Valid DAV server and 
    
    FALSE - Its not.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    handle_t dav_binding_h;
    BOOLEAN serverExists = FALSE, RpcBindingSucceeded = FALSE;
    ULONG iBackslash = 0;
    ULONG_PTR ServerLength = 0;
    PWCHAR ServerName = NULL;
    PWCHAR Ptr1 = NULL, Ptr2 = NULL;


    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavServerExists: PathName = %ws\n", PathName));
    
    serverExists = FALSE;

    //
    // The PathName is of the form \\server or \\server\share or \\server\share\path.
    //
    
    ASSERT(PathName[0] == L'\\' && PathName[1] == L'\\');

    Ptr1 = Ptr2 = &(PathName[2]);
    while(Ptr2[0] != L'\\' && Ptr2[0] != L'\0') {
        Ptr2++;
    }

    ServerLength = (ULONG_PTR) ( (Ptr2 - Ptr1) + 1 );
    ServerName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                      (ServerLength * sizeof(WCHAR)) );
    if (ServerName == NULL) {
        ULONG WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavServerExists/LocalAlloc. WStatus = %08lx\n", 
                        WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the chars that make the ServerName.
    //
    RtlCopyMemory(ServerName, Ptr1, (ServerLength-1) * sizeof(WCHAR));
    ServerName[ServerLength-1] = L'\0';

    //
    // We now need to RPC the server name into the DAV service process which
    // figures out if this server is a valid DAV server.
    //

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavServerExists/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    RpcBindingSucceeded = TRUE;

    RpcTryExcept {
        NPStatus = DavrDoesServerDoDav(dav_binding_h, ServerName, &serverExists);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavServerExists/DavrDoesServerDoDav. "
                            "NPStatus = %08lx\n", NPStatus));
            SetLastError(NPStatus);
            serverExists = FALSE;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;

          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavServerExists/DavrDoesServerDoDav."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          serverExists = FALSE;
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    IF_DEBUG_PRINT(DEBUG_MISC, ("DavServerExists: serverExists = %d\n", serverExists));
    
EXIT_THE_FUNCTION:

    if (ServerName != NULL) {
        //
        // If the Server is not NULL, then we need to copy the ServerName.
        //
        if (Server != NULL) {
            wcscpy(Server, ServerName);
        }
        LocalFree(ServerName);
        ServerName = NULL;
    }

    if (RpcBindingSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindingSucceeded = FALSE;
    }

    return serverExists;
}


BOOL
DavShareExists(
    PWCHAR PathName
    )
/*++

Routine Description:

    This function figures out if the Share in the PathName is a valid DAV 
    share.

Arguments:

    PathName - A UNC path (\\server\share\dir....) : Assuming that this is valid.

Return Value:

    TRUE - Valid DAV share and 
    
    FALSE - Its not.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    BOOLEAN shareExists = FALSE, RpcBindingSucceeded = FALSE;
    handle_t dav_binding_h;
    PWCHAR ServerName = NULL, ShareName = NULL;
    PWCHAR serverStart = NULL, shareStart = NULL, shareEnd = NULL;
    DWORD count = 0;
    ULONG_PTR ServerLength = 0, ShareLength = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavShareExists: PathName = %ws\n", PathName));

    ASSERT(PathName[0]==L'\\' && PathName[1]==L'\\');
    serverStart = &(PathName[2]);
    shareExists = FALSE;

    //
    // The PathName could be of the following forms.
    // 1. \\server\share OR
    // 2. \\server\share\path
    // We need to extract the share name from the path and find out if its a
    // valid share.
    //
    shareStart = wcschr(serverStart ,L'\\');

    ASSERT(shareStart != NULL);

    //
    // Copy the ServerName to local copy. Last char is for L'\0' char.
    //
    ServerLength = (ULONG_PTR)(shareStart - serverStart) + 1;
    ServerName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                      (ServerLength * sizeof(WCHAR)) );
    if (ServerName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/LocalAlloc. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the chars that make the ServerName.
    //
    RtlCopyMemory(ServerName, serverStart, (ServerLength-1) * sizeof(WCHAR));
    ServerName[ServerLength-1] = L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: ServerName = %ws\n", ServerName));
    
    //
    // \\server\share\path
    //          ^
    //          |
    //          shareStart
    shareStart++;

    //
    // We need to find out if the PathName is of the form
    // 1. \\server\share OR
    // 2. \\server\share\path
    // If it is of form 1, then wcschr(shareStart, L'\\'); should return NULL
    // and if it is of form 2 wcschr(shareStart, L'\\'); points to the 4th L'\\'.
    //
    shareEnd = shareStart+1;
    while(shareEnd[0] != L'\\' && shareEnd[0] != L'\0') {
        shareEnd++;
    }

    ShareLength = (ULONG_PTR)(shareEnd - shareStart) + 1;
    ShareName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                          (ShareLength * sizeof(WCHAR)) );
    if (ShareName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/LocalAlloc. NPStatus = %08lx\n", 
                         NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    //
    // Copy the chars that make the ShareName.
    //
    RtlCopyMemory(ShareName, shareStart, (ShareLength-1) * sizeof(WCHAR));
    ShareName[ShareLength-1]=L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: ShareName = %ws\n", ShareName));

    //
    // If the share is DAV_DUMMY_SHARE, then we just need to check if server is a 
    // valid DAV server. If it is a DAV server, then return SUCCESS as 
    // DAV_DUMMY_SHARE is only name given to root level of DAV server.
    //
    if ( _wcsicmp(ShareName, DAV_DUMMY_SHARE) == 0 ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: DUMMY_SHARE. ShareName=%ws\n", 
                                ShareName));
        if (DavServerExists(PathName, NULL) == TRUE) {
            shareExists = TRUE;
            NPStatus = WN_SUCCESS;
            goto EXIT_THE_FUNCTION;
        } else {
            shareExists = FALSE;
            NPStatus = WN_SUCCESS;
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists/DavServerExists: DUMMY_SHARE."
                                    "Server do not exist=%ws\n", PathName));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // We now need to RPC the server name and the share name into the DAV 
    // service process which figures out if this share is valid share of the 
    // server.
    //

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    RpcBindingSucceeded = TRUE;

    RpcTryExcept {
        NPStatus = DavrIsValidShare(dav_binding_h, ServerName, ShareName, &shareExists);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavShareExists/DavrIsValidShare. "
                            "NPStatus = %08lx\n", NPStatus));
            SetLastError(NPStatus);
            shareExists = FALSE;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavShareExists/DavrIsValidShare."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          shareExists = FALSE;
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: shareExists = %d\n", shareExists));
    
EXIT_THE_FUNCTION:

    if (ServerName) {
        LocalFree(ServerName);
        ServerName = NULL;
    }

    if (ShareName) {
        LocalFree(ShareName);
        ShareName = NULL;
    }

    if (RpcBindingSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindingSucceeded = FALSE;
    }
    
    return shareExists;
}


HMODULE
DavInitCredUI(
    PWCHAR RemoteName,
    WCHAR ServerName[CRED_MAX_STRING_LENGTH + 1],
    PFN_CREDUI_CONFIRMCREDENTIALS *pfnCredUIConfirmCredentials,
    PFN_CREDUI_PROMPTFORCREDENTIALS *pfnCredUIPromptForCredentials,
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS *pfnCredUICmdlinePromptForCredentials
    )
/*++

Routine Description:

    This function initializes the credential management stuff.

Arguments:

    RemoteName - RemoteName to be mapped.
    
    ServerName - On return, contains the ServerName which is a part of the 
                 RemoteName.
                 
    pfnCredUIGetPassword - On return contains a pointer to the 
                           "CredUIGetPasswordW" function of credui.dll.

Return Value:

    Handle returned by LoadLibrary or NULL.

--*/
{
    PWCHAR StartName = NULL, EndName = NULL;
    DWORD NameLength = 0;
    HMODULE hCredUI = NULL;

    //
    // Assume the first 2 characters are path separators (L'\\').
    //

    StartName = RemoteName + 2;

    EndName = wcschr(StartName, L'\\');

    //
    // If EndName is NULL, it implies that the RemoteName is of the form
    // \\server.
    //
    if (EndName == NULL) {
        EndName = StartName + wcslen(StartName);
    }

    NameLength = (DWORD)(EndName - StartName);

    if ( (NameLength == 0) || (NameLength > CRED_MAX_STRING_LENGTH) ) {
        //
        // The server is either an empty string or has more than the maximum
        // number of characters we support:
        //
        SetLastError(WN_BAD_NETNAME);
        return NULL;
    }

    wcsncpy(ServerName, StartName, NameLength);
    ServerName[NameLength] = L'\0';

    //
    // Load the DLL here and find the function we need.
    //
    hCredUI = LoadLibraryW(L"credui.dll");
    if (hCredUI != NULL) {
        *pfnCredUIConfirmCredentials = (PFN_CREDUI_CONFIRMCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUIConfirmCredentialsW");

        *pfnCredUIPromptForCredentials = (PFN_CREDUI_PROMPTFORCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUIPromptForCredentialsW");

        *pfnCredUICmdlinePromptForCredentials = (PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUICmdLinePromptForCredentialsW");

        if (*pfnCredUIConfirmCredentials == NULL ||
            *pfnCredUIPromptForCredentials == NULL ||
            *pfnCredUICmdlinePromptForCredentials == NULL ) {
            FreeLibrary(hCredUI);
            hCredUI = NULL;
        }
    }

    return hCredUI;
}


DWORD 
DavDisplayTypeToUsage(
    DWORD dwDisplayType
    )
/*++

Routine Description:

    This routine maps the display type to usage type.

Arguments:

    dwDisplayType - The display type to be mapped.

Return Value:

    The Usage Type or 0 if none matches.

--*/
{
    switch (dwDisplayType) {
    
    case RESOURCEDISPLAYTYPE_NETWORK:
    case RESOURCEDISPLAYTYPE_DOMAIN:
    case RESOURCEDISPLAYTYPE_SERVER:
        return RESOURCEUSAGE_CONTAINER;

    case RESOURCEDISPLAYTYPE_SHARE:
        return RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_NOLOCALDEVICE;

    case RESOURCEDISPLAYTYPE_SHAREADMIN:
        return RESOURCEUSAGE_NOLOCALDEVICE;

    default:
        break;
    
    }
    
    return 0L;
}


ULONG
DavCheckResourceType(
   IN DWORD dwType
   )
/*++

Routine Description:

    This routine checks for valid resource types allowed for our provider.
    Currently only RESOURCETYPE_DISK is valid for our resources.

Arguments:

    dwType - Supplies the resource type to be checked for the validity.

Return Value:

    WN_SUCCESS or the appropriate Win32/WNet error code.

--*/
{
    // 
    // Check if dwType is set and is set to some valid value. It can be only of
    // type RESOURCETYPE_DISK for our provider.
    //
    if ( (dwType != RESOURCETYPE_ANY) &&
         (dwType & ~(RESOURCETYPE_PRINT | RESOURCETYPE_DISK)) ){
        return WN_BAD_VALUE;
    }

    if (dwType == RESOURCETYPE_ANY || (dwType & RESOURCETYPE_DISK) ) {
        return WN_SUCCESS;
    } else {
        return WN_BAD_DEV_TYPE;
    }
}


ULONG
DavCheckLocalName(
    IN PWCHAR LocalName
    )
/*++

Routine Description:

    This only handles NULL, empty string, and L"X:" formats.

Arguments:

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

Return Value:

    WN_SUCCESS or the appropriate Win32/WNet error code.

--*/
{
    DWORD LocalNameLength;

    LocalNameLength = ( LocalName == NULL ) ? 0 : wcslen( LocalName );

    if (LocalNameLength != 2 || !iswalpha(*LocalName) || LocalName[1] != L':') {
        return WN_BAD_LOCALNAME;
    }

    return WN_SUCCESS;
}


ULONG
DavCheckAndConvertHttpUrlToUncName(
    IN PWCHAR RemoteName,
    OUT PWCHAR *UncRemoteName,
    OUT PBOOLEAN MemoryAllocated,
    IN BOOLEAN AddDummyShare,
    OUT PDAV_REMOTENAME_TYPE premNameType,
    OUT LPDWORD pathOffset,
    IN BOOLEAN bCanonicalize
    )
/*++

Routine Description:

    This routine checks to see if the name is valid (atleast 3 chars long). It
    then converts a Http URL (if the remote name was one) into a UNC name. Its 
    possible that the NP APIs get called with the URLs as RemoteNames. We need 
    to convert them to UNC before proceeding further. It also adds a dummy share
    DavWWWRoot if one was not supplied with the request. This is because its 
    possible to map a drive to the root of the DAV server.

Arguments:

    RemoteName - The Http URL that came in. An important thing to note is that 
                 this need not be a HTTP URL. If its not, then we don't do any 
                 conversion.
    
    UncRemoteName - The UNC name that is returned to the caller. The returned 
                    name will have the format \\server\share.
                    
    MemoryAllocated - TRUE if memory was allocated for the returned UNC name.                    

    AddDummyShare - If TRUE, and the RemoteName is \\server or http://server,
                    a dummy share DavWWWRoot is added to the UNC name.

    premNameType - Pointer to location to receive the type of UNC path returned by 
                   I_NetPathType/Canonicalization. If NULL, no value is set.
                   This has meaning only when Canonicalization is done.

    pathOffset - Offset of "\path" in remotename when remotename is of type 
                 \\server\share\path... . Otherwise it is zero. If NULL, no value
                 is set. This has meaning only when Canonicalization is done.
                 
    bCanonicalize - IF TRUE, the remote name returned from URL to UNC will be 
                    canonicalized before return.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

Notes: 

       This function returns WN_BAD_NETNAME also for remotes names which are 
       correct in syntax but have length > MAX_PATH.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR ReturnedUncName = NULL, TempName = NULL, SrvName = NULL;
    PWCHAR CanonicalName = NULL, ColonPtr = NULL;
    BOOLEAN didAllocate = FALSE;
    ULONG ReturnedUncNameLen = 0, index = 0, DummyShareNameLen = 0, CanonicalNameMaxLen = 0;

    if (MemoryAllocated == NULL || UncRemoteName == NULL) {
        WStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: (MemoryAllocated"
                        " == NULL || UncRemoteName == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    *UncRemoteName = NULL;
    *MemoryAllocated = FALSE;
    if(pathOffset != NULL) {
        *pathOffset = 0;
    }

    // 
    // 1. First we will check if this is a URL form remotename. If this is, then
    //    we will convert it to UNC name. 
    // 2. After converting to UNC name, we will add DummyShare name depending on
    //    parameter value passed to this function.
    // 3. After this, we will canonicalize the converted UNC name depending on
    //    the parameter value passed to this function.
    //

    //
    // If RemoteName is NULL, we have nothing to do.
    //
    if (RemoteName == NULL) {
        WStatus = WN_BAD_NETNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: RemoteName == NULL\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The remote name must be atleast 3 chars long. It cannot be \\.
    //
    if ( wcslen(RemoteName) < 3 ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: wcslen(RemoteName) < 3\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see if the remote name being suppiled is http:.
    //
    //
    // We could get the names in the following formats.
    // 1. http://servername/sharename OR
    // 2. \\http://servername/sharename OR
    // 3. http://servername OR
    // 4. \\http://servername
    // 5. \\servername.....
    //
    
    SrvName = NULL;
    ColonPtr = wcschr(RemoteName, L':');
    
    if( (ColonPtr != NULL) && 
        ( (ColonPtr - RemoteName == 4) || (ColonPtr - RemoteName == 6)) ) {
        if( (RemoteName[0] == L'\\') && (RemoteName[1] == L'\\') && 
            (_wcsnicmp((RemoteName + 2), L"http:", 5) == 0) )  {
            //
            // RemoteName is \\HTTP name. \\http://server....
            //
            SrvName = (RemoteName + 7);
        } else if (_wcsnicmp(RemoteName, L"http:", 5) == 0) {
            //
            // RemoteName is HTTP name. http://server....
            //
            SrvName = (RemoteName + 5);
        } else {
            IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(1): Invalid URL string\n"));
            WStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    } else if (RemoteName[0] == L'\\' && RemoteName[1] == L'\\') {
        //
        // RemoteName is UNC name
        //
        SrvName = RemoteName;
    } else {
        // 
        // RemoteName is neither "http://..." name NOR UNC name.
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(1): Invalid remote string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT (SrvName != NULL);

    // 
    // SrvName is pointing to start of servername portion. Servername portion 
    // can be of type L"\\..." or L"//...".
    //
    
    //
    // Our parsing code below that converts the supplied http name into
    // a UNC name looks at the first charactter to decide the format.
    // We need to add the additional \\ in front of http to fool shell
    // into sending the http name to us.
    //

    ReturnedUncNameLen = wcslen( SrvName ) ;
    if ( ( ReturnedUncNameLen < 3 )                    || 
         ( SrvName[0] != L'\\' && SrvName[0] != L'/' ) || 
         ( SrvName[1] != L'\\' && SrvName[1] != L'/' ) ) {
        //
        // The following cases will be eliminated here.
        // 1. http:// 2. http:/aaa 3. \aaa 4. aaaa
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName(2): Invalid URL string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // We will allocate space for DAV_DUMMY_SHARE in this name so that
    // if we are to add the Dummy name later, we don't have to reallocate memory
    // for new name with Dummy share. String that will be added = L"\dummyshare"
    // 
    if (AddDummyShare == TRUE) {
        DummyShareNameLen = 1 + wcslen (DAV_DUMMY_SHARE);
    }

    ReturnedUncName = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                  ( (ReturnedUncNameLen +
                                     DummyShareNameLen + 
                                     1) * sizeof(WCHAR) ) );
    if (ReturnedUncName == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/LocalAlloc. "
                        "WStatus = %08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to keep track of the fact that we allocated memory in this
    // routine.
    //
    didAllocate = TRUE;

    //
    // Copy the name in the UNC format. Replace '/' by '\'.
    //
    for (index = 0; index < ReturnedUncNameLen; index++) {
        if (SrvName[index] == L'/') {
            ReturnedUncName[index] = L'\\';
        } else {
            ReturnedUncName[index] = SrvName[index];
        }
    }
    ReturnedUncName[ReturnedUncNameLen] = L'\0';

    //
    // If the final char of the RemoteName is a '\' or a '/' remove it. For 
    // some reason, the DAV servers do not like a / at the end.
    //
    if ( ReturnedUncName[ReturnedUncNameLen - 1] == L'/' ||
         ReturnedUncName[ReturnedUncNameLen - 1] == L'\\' ) {
        ReturnedUncName[ReturnedUncNameLen - 1] = L'\0';
        ReturnedUncNameLen--;
    }
    
    if ( ReturnedUncNameLen < 3) {
        //
        // The following cases will be eliminated here.
        // 1. http:/// 2. \\\
        // 
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(3): Invalid remote string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // At this point, any URL remotename is already converted to UNC name.
    //

    //
    // Add the dummy share only if we were asked to.
    //
    if (AddDummyShare == TRUE) {

        //
        // If the format is \\server, we need to add a dummy share just to get 
        // through the file system since it does not understand a CreateFile on a 
        // server name. This is valid in case of a DAV server since \\server maps
        // to the root http://www.foo.com/.
        //
        TempName = wcschr( &(ReturnedUncName[2]), L'\\' );
        if (TempName == NULL) {

            //
            // We need to add a dummy share. We are assuming that space for
            // storing DAV_DUMMY_SHARE name is already allocated above.
            //
            ReturnedUncName[ReturnedUncNameLen] = L'\\';
            ReturnedUncName[ReturnedUncNameLen+1] = L'\0';
            wcscpy( &(ReturnedUncName[ReturnedUncNameLen+1]), DAV_DUMMY_SHARE );
            ReturnedUncNameLen += DummyShareNameLen;
            ReturnedUncName[ReturnedUncNameLen] = L'\0';
        }
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC, 
                   ("DavCheckAndConvertSrvNameUrlToUncName: RemoteName = %ws\n",
                    ReturnedUncName));

    // 
    // At this point, any URL remotename is already converted to UNC name + 
    // DAV_DUMMY_SHARE is added to the remote name (if asked so).
    //

    if (bCanonicalize == TRUE) {
        
        DAV_REMOTENAME_TYPE nameType = DAV_REMOTENAME_TYPE_INVALID;
        
        // 
        // Allocate another buffer to contain canonicalize name
        //
        CanonicalName = NULL;
        CanonicalNameMaxLen = MAX_PATH + 1;
        CanonicalName = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                  ( CanonicalNameMaxLen * sizeof(WCHAR) ) );
        if (CanonicalName == NULL) {
            WStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/LocalAlloc. "
                        "WStatus = %08lx\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        nameType = DavParseRemoteName (ReturnedUncName,
                                       CanonicalName,
                                       (CanonicalNameMaxLen * sizeof(WCHAR)),
                                       pathOffset);
        
        CanonicalName[(CanonicalNameMaxLen - 1)] = L'\0';

        // 
        // We will allow only UNC names of type UNC-server, UNC-share or 
        // UNC-path to pass from this function. All other type of names returned
        // from canonicalization will rejected (function will return failure
        // status) as INVALID_NAMES.
        //
        if (nameType != DAV_REMOTENAME_TYPE_SERVER && 
            nameType != DAV_REMOTENAME_TYPE_SHARE &&
            nameType != DAV_REMOTENAME_TYPE_PATH) {
            WStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/DavParseRemoteName. "
                            "nameType = %d\n", nameType));
            goto EXIT_THE_FUNCTION;
        }
        
        // 
        // Free the previous buffer allocate in ReturnedUncName and point
        // this variable to new canonical name just allocated here.
        //
        LocalFree((HLOCAL)ReturnedUncName);
        ReturnedUncName = NULL;
        ReturnedUncNameLen = 0;
        didAllocate = FALSE;
        
        ReturnedUncName = CanonicalName;
        ReturnedUncNameLen = wcslen(CanonicalName);
        didAllocate = TRUE;
        CanonicalName = NULL;
            
        if (premNameType != NULL) {
            *premNameType = nameType;
        }
    
    }

    if ( ReturnedUncNameLen > MAX_PATH ) {
        WStatus = WN_BAD_NETNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName. ReturnedUncNameLen=%d ",
                        ReturnedUncNameLen));
        goto EXIT_THE_FUNCTION;
    }

    *UncRemoteName = ReturnedUncName;
    *MemoryAllocated = didAllocate;
    WStatus = ERROR_SUCCESS;

EXIT_THE_FUNCTION:

    if (WStatus != ERROR_SUCCESS) {
        if (ReturnedUncName && didAllocate) {
            LocalFree(ReturnedUncName);
            ReturnedUncName = NULL;
            didAllocate = FALSE;
        }
        if (CanonicalName != NULL) {
            LocalFree(CanonicalName);
            CanonicalName = NULL;
        }
    }

    return WStatus;
}


DWORD
WINAPI
DavWinlogonLogonUserEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    lpParam - This is of no interest to us.

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavWinlogonLogonUserEvent: Entered\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogonUserEvent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    WStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (WStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogonUserEvent/DavBindTheRpcHandle. "
                        "WStatus = %08lx\n", WStatus));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        WStatus = DavrWinlogonLogonEvent(dav_binding_h);
        if (WStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavWinlogonLogonUserEvent/DavrWinlogonLogonEvent. "
                            "WStatus = %08lx\n", WStatus));
            SetLastError(WStatus);
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS,
                         ("ERROR: DavWinlogonLogonUserEvent/DavrWinlogonLogonEvent. "
                          " RpcExceptionCode = %d\n", RpcStatus));
          WStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
    }

    return WStatus;
}


DWORD
WINAPI
DavWinlogonLogoffUserEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs off the system.

Arguments:

    lpParam - This is of no interest to us.

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavWinlogonLogoffUserEvent: Entered\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogoffUserEvent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    WStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (WStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogoffUserEvent/DavBindTheRpcHandle. "
                        "WStatus = %08lx\n", WStatus));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        WStatus = DavrWinlogonLogoffEvent(dav_binding_h);
        if (WStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavWinlogonLogoffUserEvent/DavrWinlogonLogoffEvent. "
                            "WStatus = %08lx\n", WStatus));
            SetLastError(WStatus);
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS,
                         ("ERROR: DavWinlogonLogoffUserEvent/DavrWinlogonLogoffEvent. "
                          " RpcExceptionCode = %d\n", RpcStatus));
          WStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
    }

    return WStatus;
}


VOID 
DavDisplayNetResource(
    LPNETRESOURCE netRes, 
    LPWSTR dispMesg
    )
/*++

Routine Description:

    The routine prints out the contents of an NetResource and a display message.

Arguments:

    netRes - The NetResource whose contents will be printed out.
    
    dispMesg - The caller can use this to identify itself.

Returns:

    None.

--*/
{

    if(dispMesg != NULL ) {
        IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDisplayNetResource: Entered: %ws\n", dispMesg));
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("netRes = 0x%x\n", netRes));

    if (netRes == NULL) {
        return;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("netRes->[dwScope = 0x%x , dwType = 0x%x ,"
                    " dwUsage = 0x%x , dwDisplayType = 0x%x]\n", 
                    netRes->dwScope, netRes->dwType, netRes->dwUsage,
                    netRes->dwDisplayType));

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("netRes->[dwLocalName = %ws , dwRemoteName = %ws  ,"
                    " dwComment = %ws , dwProvider = %ws]\n",
                    netRes->lpLocalName, netRes->lpRemoteName, netRes->lpComment,
                    netRes->lpProvider));

    return;
}


VOID 
DavDisplayEnumNode(
    PDAV_ENUMNODE enumNode, 
    LPWSTR dispMesg
    )
/*++

Routine Description:

    The routine prints out the contents of an enumNode and a display message.

Arguments:

    enumNode - The enumNode whose contents will be printed out.
    
    dispMesg - The caller can use this to identify itself.

Returns:

    None.

--*/
{

    if(dispMesg != NULL ) {
        IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDisplayEnumNode: Entered: %ws\n", dispMesg));
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("enumNode = 0x%x\n", enumNode));
    
    if (enumNode == NULL) {
        return;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("enumNode->[dwScope = 0x%x , dwType = 0x%x ,"
                    " dwUsage = 0x%x , DavEnumNodeType = %d ,"
                    " Done = %d , Index = %d]\n", 
                    enumNode->dwScope, enumNode->dwType, enumNode->dwUsage,
                    enumNode->DavEnumNodeType, enumNode->Done,
                    enumNode->Index));

    DavDisplayNetResource(enumNode->lpNetResource, L"lpNetResource in enumNode");

    return;
}


VOID DavDebugBreakPoint(
    VOID
    )
/*++

Routine Description:

    The routine is used for debugging purposes to add breakpoints where needed.

Arguments:

    None.

Returns:

    None.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDebugBreakPoint.\n"));
    return;
}




DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR      lptzLocation,
    DWORD       *lpdwSize,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    )
/*++

Routine Description:

    Finds out the amount of disk being consumed by wininet urlcache due to Webdav

Arguments:

    lptzLocation  - Buffer to return Cache location string. As much of the location string as can fit
                    in the buffer is returned
    
    lpdwSize     -  Size of the cache location buffer. On return this will contain the actual size of the 
                    location string. 
                    
    lpMaxSpace   -  Size of disk Quota set for webdav

    lpUsedSpace -   Size of disk consumed by the urlcache used by webdav
    
Return Value:

    Win32 error code

--*/
{
    DWORD   dwError;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    WCHAR   Buffer[MAX_PATH];
    DWORD   dwSize;
        
    dwError = DavBindTheRpcHandle( &(dav_binding_h) );
    if (dwError != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavrDiskSpaceUsage/DavBindTheRpcHandle. "
                        "dwError = %08lx\n", dwError));
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;
    RpcTryExcept {
        dwError = DavrGetDiskSpaceUsage(dav_binding_h, Buffer, MAX_PATH, &dwSize, lpMaxSpace, lpUsedSpace);
        if (dwError == ERROR_SUCCESS)
        {
            memset(lptzLocation, 0, *lpdwSize);
            memcpy(lptzLocation, Buffer, min(*lpdwSize, dwSize));
            *lpdwSize = dwSize;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        RPC_STATUS RpcStatus;
        RpcStatus = RpcExceptionCode();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavrGetDiskSpaceUsage/DavrConnectionExist."
                                            " RpcExceptionCode = %d\n", RpcStatus));
        dwError = DavMapRpcErrorToProviderError(RpcStatus);
        goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept
EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    return dwError;    
}

DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD   dwPercent
    )
/*++

Routine Description:

    Frees up dwPercent of cache

Arguments:

    dwPercent - number between 0 and 100

Returns:

    ERROR_SUCCESS if successful, else returns the win32 errorcode

--*/
{
    DWORD   dwError;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    
    dwError = DavBindTheRpcHandle( &(dav_binding_h) );
    if (dwError != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavFreeUsedDiskSpace/DavBindTheRpcHandle. "
                        "dwError = %08lx\n", dwError));
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;
    RpcTryExcept {
        DavrFreeUsedDiskSpace(dav_binding_h, dwPercent);
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        RPC_STATUS RpcStatus;
        RpcStatus = RpcExceptionCode();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavFreeUsedDiskSpace/DavrConnectionExist."
                                            " RpcExceptionCode = %d\n", RpcStatus));
        dwError = DavMapRpcErrorToProviderError(RpcStatus);
        goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept
EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    return dwError;    
}




//
// The functions below are a part of the NP spec but have NOT been implemented
// by the DAV NP. We do not claim to support these in the NPGetCaps function.
//

#if 0

DWORD
NPGetPropertyText(
    DWORD iButtonDlg,
    DWORD nPropSel,
    LPTSTR lpFileName,
    LPTSTR lpButtonName,
    DWORD cchButtonName,
    DWORD nType
    )
/*++

Routine Description:

    This function is used to determine the names of buttons added to a property 
    dialog for some particular resources. It is called every time such a dialog 
    is brought up, and prior to displaying the dialog. If the user clicks a 
    button added through this API by the Winnet provider, NPPropertyDialog will 
    be called with the appropriate parameters.

Arguments:

    iButtonDlg - Indicates the index (starting at 0) of the button. The File 
                 Manager will support at most 6 buttons. The parameter is 
                 numbered 1-6 for each of the possible buttons if only one file 
                 is selected, or 11-16 if multiple files are selected.

    nPropSel - Specifies what items the property dialog focuses on. It can be 
               one of the following values:
    
               WNPS_FILE (0) - Single file.
               
               WNPS_DIR (1) - Single directory.
               
               WNPS_MULT (2) - Multiple selection of files and/or directories.

    lpFileName - Specifies the names of the item or items to be viewed or edited 
                 by the dialog. Currently, the items are files (and directories), 
                 so the item names are file names. These will be unambiguous, 
                 contain no wildcard characters and will be fully qualified 
                 (e.g., C:\LOCAL\FOO.BAR).  Multiple filenames will be separated 
                 with spaces. Any filename may be quoted (e.g., "C:\My File") in 
                 which case it will be treated as a single name. The caret 
                 character '^' may also be used as the quotation mechanism for 
                 single characters (e.g., C:\My^"File, "C:\My^"File" both refer 
                 to the file C:\My"File).

    lpButtonName - Points to a buffer where the Winnet provider should copy the 
                   name of the property button. On success, the buffer pointed 
                   to by lpButtonName will contain the name of the property 
                   button. If this buffer, on exit, contains the empty string, 
                   then the corresponding button and all succeeding buttons will 
                   be removed from the dialog box. The network provider cannot 
                   "skip" a button.

    cchButtonName - Specifies the size of the lpButtonName buffer in characters.

    nType - Specifies the item type. Currently, only WNTYPE_FILE will be used.

Return Value:

    WN_SUCCESS - If the call is successful and lpButtonName can be used.
    
    WN_OUT_OF_MEMORY - Couldn't load string from resources.

    WN_MORE_DATA - The given buffer is too small to fit the text of the button.

    WN_BAD_VALUE - The lpFileName parameter takes an unexpected form.

    WN_NOT_SUPPORTED - Property dialogs are not supported for the given object 
                       type (nType).

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetPropertyText Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPPropertyDialog(
    HWND hwndParent,
    DWORD iButtonDlg,
    DWORD nPropSel,
    LPTSTR lpFileName,
    DWORD nType
)
/*++

Routine Description:

    This function is called out to when the user clicks a button added through 
    the NPGetPropertyText API. Currently, this will only be called for file and 
    directory network properties.

Arguments:

    hwndParent - Specifies the parent window which should own the file property 
                 dialog.

    iButtonDlg - Indicates the index (starting at 0) of the button that was 
                 pressed.
    
    nPropSel - Specifies what items the property dialog should act on. It can be 
               one of the following values:
               
               WNPS_FILE (0) - Single file.
               
               WNPS_DIR (1) - Single directory.
               
               WNPS_MULT (2) - Multiple selection of files and/or directories.

    lpFileName - Points to the names of the items that the property dialog 
                 should act on. See the NPGetPropertyText API for a description 
                 of the format of what lpFileName points to.

    nType - Specifies the item type. Currently, only WNTYPE_FILE will be used.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, the an error code is 
                 returned which can be one of the following:

    WN_BAD_VALUE - Some parameter takes an unexpected form or value.

    WN_OUT_OF_MEMORY - Not enough memory to display the dialog.

    WN_NET_ERROR - Some other network error occurred.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPPropertyDialog Entered.\n"));
    return WN_NET_ERROR;
}


DWORD
NPSearchDialog(
    HWND hParent,
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpnFlags
    )
/*++

Routine Description:

    This dialog allows network provider to supply its own form of browsing and 
    search beyond the hierarchical view presented in the Connection Dialog.

Arguments:

    hwnd - Specifies the handle of the window that will be used as the dialog 
           box's parent.
    
    lpNetResource - Specifies the currently selected item in the Network 
                    connections dialog. A provider may choose to ignore this 
                    field.

    lpBuffer - Pointer to buffer that will receive the result of the search.
    
    cbBuffer - DWORD that will specify size of buffer passed in.
    
    lpnFlags - Pointer to a DWORD of flags which the provider can set to force 
               certain actions after the dialog is dismissed.  It can be one of:

               WNSRCH_REFRESH_FIRST_LEVEL - Forces MPR to collapse then expand 
                                            (and refresh) the first level below 
                                            this provider after the dialog is 
                                            dismissed.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_CANCEL - If user cancelled the operation.
    
    WN_MORE_DATA - If input buffer is too small.
    
--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPSearchDialog Entered.\n"));
    return WN_CANCEL;
}


DWORD
NPGetDirectoryType (
    LPTSTR lpName,
    LPINT lpType,
    BOOL bFlushCache
    )
/*++

Routine Description:

    This function is used by the file manager to determine the type of a 
    network directory.

Arguments:

    lpName - This parameter points to the fully qualified name of the directory. 
             The network provider returns the type to the word pointed to by 
             lpType. If the value returned in lpType is 0 or if the network 
             provider returns an error, the File Manager displays the directory 
             as a "normal" directory.
             
    lpType - This is defined by the network provider and is used to modify the 
             display of the drive tree in the File Manager.  In this way, the 
             network provider can show special directories to the user.
             
    bFlushCache - This is set to TRUE when the File Manager call MPR to get the 
                  directory type for the first time while repainting a window on 
                  Refresh. Subsequently, it will be FALSE. This gives a provider 
                  the opportunity to optimize performance if it wishes to just 
                  read the data for a drive once and cache it until the next 
                  Refresh.             

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_NOT_SUPPORTED - This function is not supported.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetDirectoryType Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPDirectoryNotify(
    HWND hwnd,
    LPTSTR lpDir,
    DWORD dwOper
    )
/*++

Routine Description:

    This function is used by the File Manager to notify the network provider of 
    certain directory operations. This function can be used to perform special 
    behaviour for certain directories.
    
Arguments:

    hwnd - Specifies an owner window handle in the event the network provider 
           needs to interact with the user.

    lpDir - This points to the fully qualified name of the directory.
    
    dwOper - Indicates the operation. If dwOper is WNDN_MKDIR (1), then the File 
             Manager is about to create a directory with the given name. If 
             dwOper WNDN_RMDIR (2), the File Manager is about the remove the 
             directory. dwOper may also be WNDN_MVDIR (3) to indicate that the 
             directory is about to be renamed.

Return Value:

    WN_SUCCESS - If the call is successful. This indicates to the caller that it 
                 should continue and perform the operation. Otherwise, the 
                 appropriate code is returned, which may include:

    WN_CANCELLED - The provider would have handled the operation, but the user 
                   cancelled it. The caller should NOT perform the operation.

    WN_CONTINUE - The network provider handled the operation, the caller should 
                  proceed normally but do not perform the operation.

    WN_NOT_SUPPORTED - The network does not have special directory handling, 
                       this is treated as WN_SUCCESS.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPDirectoryNotify Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPGetConnectionPerformance(
    LPCWSTR lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
/*++

Routine Description:

    This function returns information about the expected performance of a 
    connection used to access a network resource. The request can only be for a 
    network resource to which there is currently a connection. The information 
    returned may be an estimate. Note that if the network cannot obtain 
    information about the resource on the network, then it can return 
    information about the network adaptor and its associated performance, 
    setting dwFlags accordingly.

Arguments:

    lpRemoteName - Contains the local name or remote name for a resource for 
                   which a connection exists. 
                   
    lpNetConnectInfo - This is is a pointer to a NETCONNECTINFOSTRUCT structure 
                       which is filled in by the net provider if the provider 
                       has a connection to the network resource. With the 
                       exception of the cbStructure field, all other fields are 
                       zero filled before MPR.DLL passes the request on to the 
                       net providers, and the provider only has to write to 
                       fields for which it has information available. Also, for 
                       rate values, a value of 1 means that the performance is 
                       better than can be represented in the unit.                    

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, the an error code is 
                 returned, which may include:
    
    WN_NOT_CONNECTED - lpRemoteName is not a connected network resource.
    
    WN_NO_NETWORK - Network is not present.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetConnectionPerformance Entered.\n"));
    // 
    // BUGBUG: why is this function supported at all ?? It can result in error
    // if a connection is created and checked for its existence.
    // 
    // LOOK HERE: Not supported for now: return WN_NOT_CONNECTED;
    return WN_NOT_SUPPORTED;
}

#endif // #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\volclean.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.cpp
//
//  Authors;
//    Guhan Suriyanarayanan (guhans)
//
//  Notes;
//    WebDav disk cleanup interface (IEmptyVolumeCache, IEmptyVolumeCache2)
//--------------------------------------------------------------------------

#include <windows.h>
#include "volclean.h"
#include "resource.h"

extern "C" {
extern HINSTANCE g_hinst;


DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD   dwPercent
    );


DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR      lptzLocation,
    DWORD       *lpdwSize,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    );

}

HRESULT
CoTaskLoadString(
    HINSTANCE hInstance, 
    UINT idString, 
    LPWSTR *ppwsz
    )
{
    int cchString = 100;      // start with a reasonable default
    BOOL done = TRUE;

    *ppwsz = NULL;

    do {
        done = TRUE;

        *ppwsz = (LPWSTR)CoTaskMemAlloc(cchString * sizeof(WCHAR));
        if (*ppwsz) {

            //
            // Try loading the string into the current buffer
            //
            int nResult = LoadStringW(hInstance, idString, *ppwsz, cchString);
            if (!nResult || (nResult >= (cchString-1))) {
                //
                // We couldn't load the string.  If this is because the 
                // buffer isn't big enough, we'll try again.
                //
                DWORD dwStatus = GetLastError();
                
                //
                // Free the current buffer first
                //
                CoTaskMemFree(*ppwsz);
                *ppwsz = NULL;

                if (nResult >= (cchString-1)) {
                    //
                    // Try again with a bigger buffer
                    //
                    cchString *=2;
                    done = FALSE;
                }
                else {
                    return HRESULT_FROM_WIN32(dwStatus);
                }
            }
        }
        else {
            return E_OUTOFMEMORY;
        }

    } while (!done);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IClassFactory::CreateInstance support                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CWebDavCleaner::CreateInstance(REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    Trace(L"CWebDavCleaner::CreateInstance");

    CWebDavCleaner *pThis = new CWebDavCleaner();
    if (pThis)
    {
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IUnknown implementation                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CWebDavCleaner::QueryInterface(REFIID riid, void **ppv)
{

    Trace(L"CWebDavCleaner::QueryInterface");
    if (!ppv) {
        return E_POINTER;
    }

    if (riid == IID_IEmptyVolumeCache) {
        *ppv = static_cast<IEmptyVolumeCache*>(this);
    }
    else if (riid == IID_IEmptyVolumeCache2) {
        *ppv = static_cast<IEmptyVolumeCache2*>(this);
    }
    else  {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) 
CWebDavCleaner::AddRef()
{
    Trace(L"CWebDavCleaner::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) 
CWebDavCleaner::Release()
{
    Trace(L"CWebDavCleaner::Release");
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IEmptyVolumeCache implementation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CWebDavCleaner::Initialize(
    IN  HKEY    hkRegKey,
    IN  LPCWSTR pcwszVolume,
    OUT LPWSTR *ppwszDisplayName,
    OUT LPWSTR *ppwszDescription,
    IN OUT LPDWORD pdwFlags
    )
{

    Trace(L"CWebDavCleaner::Initialize");
    HRESULT hr = E_FAIL;

    if (!pcwszVolume || 
        !ppwszDisplayName || 
        !ppwszDescription || 
        !pdwFlags
        ) {
        return E_POINTER;
    }

    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;

    //
    // Check the IN flags first
    //
    if ((*pdwFlags) & EVCF_OUTOFDISKSPACE) {
        //
        // The user is out of disk space on the drive, and we should be 
        // aggressive about freeing disk space, even if it results in a 
        // performance loss. 
        //
        m_dwPercent = 100;
    }

    if ((*pdwFlags) & EVCF_SETTINGSMODE) {
        //
        // The disk cleanup manager is being run on a schedule. We must 
        // assign values to the ppwszDisplayName and ppwszDescription 
        // parameters. If this flag is set, the disk cleanup manager will not 
        // call GetSpaceUsed, Purge, or ShowProperties. Because Purge will not 
        // be called, cleanup must be handled by Initialize. The handler should 
        // ignore the pcwszVolume parameter and clean up any unneeded files 
        // regardless of what drive they are on. 
        //
        // Let's just call purge ourselves!
        //
        m_fScheduled = TRUE;
        m_fFilesToDelete = TRUE;
    }

    //
    // And set the OUT flags
    //
    *pdwFlags = EVCF_DONTSHOWIFZERO;

    // 
    // Load the display name and description strings
    //
    hr = CoTaskLoadString(g_hinst, IDS_DISKCLEAN_DISPLAY, ppwszDisplayName);
    if (FAILED(hr)) {
        return hr;
    }
    hr = CoTaskLoadString(g_hinst, IDS_DISKCLEAN_DESCRIPTION, ppwszDescription);
    if (FAILED(hr)) {
        return hr;
    }

    if (m_fScheduled) {
        //
        // Scheduled run:  Purge now.
        //
        Purge(-1, NULL);
    }
    else {
        //
        // Copy the volume path locally
        //
        if (m_szVolume) {
            delete [] m_szVolume;
            m_szVolume = NULL;
        }
        
        m_szVolume = new WCHAR[(wcslen(pcwszVolume) + 1)];
        
        if (!m_szVolume) {
            return E_OUTOFMEMORY;
        }

        wcscpy(m_szVolume, pcwszVolume);
    }

    return S_OK;
}


STDMETHODIMP
CWebDavCleaner::GetSpaceUsed(
    OUT DWORDLONG *pdwlSpaceUsed,
    IN  LPEMPTYVOLUMECACHECALLBACK picb
    )
{
    WCHAR szLocation[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH + 1, 
        dwStatus = ERROR_SUCCESS;
    ULARGE_INTEGER dwMaxSpace,
        dwUsedSpace;

    Trace(L"CWebDavCleaner::GetSpaceUsed");

    ZeroMemory(szLocation, (MAX_PATH+1)*sizeof(WCHAR));

    if (!pdwlSpaceUsed) {
        return E_POINTER;
    }
    if (!m_szVolume) {
        //
        // Initialize should have been called first
        //
        return E_UNEXPECTED;
    }

    *pdwlSpaceUsed = 0;

    //
    // Check if the webdav cache is using this volume, and set the flags 
    // accordingly.
    //
    dwStatus = DavGetDiskSpaceUsage(szLocation, &dwSize, &dwMaxSpace, &dwUsedSpace);

    pToUpperCase(szLocation);
    pToUpperCase(m_szVolume);

    //
    // Check if the volume being cleaned matches the volume holding the
    // Webdav cache
    //
    if ((ERROR_SUCCESS == dwStatus) && (!wcsncmp(szLocation, m_szVolume, wcslen(m_szVolume)))) {
        m_fFilesToDelete = TRUE;
        m_dwlUsedSpace =  (DWORDLONG)(dwUsedSpace.QuadPart);

    }
    else {
        m_fFilesToDelete = FALSE;
        m_dwlUsedSpace = 0;
    }

    //
    // We're done with this, purge doesn't need to know
    // the volume being cleaned.
    //
    delete [] m_szVolume;
    m_szVolume = NULL;

    *pdwlSpaceUsed = m_dwlUsedSpace;

    return HRESULT_FROM_WIN32(dwStatus);

    UNREFERENCED_PARAMETER(picb);
}


STDMETHODIMP
CWebDavCleaner::Purge(
    IN DWORDLONG dwlSpaceToFree,
    IN LPEMPTYVOLUMECACHECALLBACK picb
    )
{
    Trace(L"CWebDavCleaner::Purge");
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Does this volume have stuff of interest?
    //
    if (m_fFilesToDelete) {
        //
        // Figure out m_dwPercent:  dwlSpaceToFree is set to -1 if
        // we need to free as much as possible
        //
        if (dwlSpaceToFree == (DWORDLONG) -1) {
            m_dwPercent = 100;
        }
        else {
            m_dwPercent = (DWORD)  (dwlSpaceToFree * 100 / m_dwlUsedSpace);
        }

        dwStatus = DavFreeUsedDiskSpace(m_dwPercent);
    }

    return HRESULT_FROM_WIN32(dwStatus);
    UNREFERENCED_PARAMETER(picb);
}


STDMETHODIMP
CWebDavCleaner::ShowProperties(
    IN HWND hwnd 
    )
{
    //
    // No UI to display.  S_FALSE indicates to the caller
    // that no settings were changed by the user.
    //
    return S_FALSE;

    UNREFERENCED_PARAMETER(hwnd);
}

STDMETHODIMP
CWebDavCleaner::Deactivate(
    IN LPDWORD pdwFlags
    )
{
    // 
    // Nothing to do here
    //
    return S_OK;

    UNREFERENCED_PARAMETER(pdwFlags);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IEmptyVolumeCache2 implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CWebDavCleaner::InitializeEx(
    IN  HKEY hkRegKey,
    IN  LPCWSTR pcwszVolume,
    IN  LPCWSTR pcwszKeyName,
    OUT LPWSTR *ppwszDisplayName,
    OUT LPWSTR *ppwszDescription,
    OUT LPWSTR *ppwszBtnText,
    IN OUT LPDWORD pdwFlags
    )
{
    Trace(L"CWebDavCleaner::InitializeEx");

    *ppwszBtnText = NULL;
    return Initialize(hkRegKey,
        pcwszVolume,
        ppwszDisplayName,
        ppwszDescription,
        pdwFlags
        );

    UNREFERENCED_PARAMETER(pcwszKeyName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\volclean.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.h
//
//--------------------------------------------------------------------------

#ifndef _VOLFREE_H_
#define _VOLFREE_H_

#include <windows.h>
#include <emptyvc.h>
#include <initguid.h>
#include <stdio.h>

#define Trace(x) 

// {E3BF1126-BA29-4850-AF33-5BDB654F4774}
DEFINE_GUID(CLSID_WebDavVolumeCleaner, 
    0xE3BF1126, 0xBA29, 0x4850, 
    0xAF, 0x33, 0x5B, 0xDB, 
    0x65, 0x4F, 0x47, 0x74
    );


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

class CWebDavCleaner : public IEmptyVolumeCache2
{
    LONG m_cRef;
    DWORDLONG m_dwlUsedSpace;
    DWORD m_dwPercent;
    BOOL m_fScheduled;
    BOOL m_fFilesToDelete;
    PWSTR m_szVolume;

public:
    CWebDavCleaner() 
      : m_cRef(1), 
        m_dwlUsedSpace(0), 
        m_fScheduled(FALSE),
        m_fFilesToDelete(FALSE),
        m_dwPercent(90),
        m_szVolume(NULL)

    {
        Trace(L"CWebDavCleaner::CWebDavCleaner");
        ::DllAddRef();
    }

    ~CWebDavCleaner()
    {
        Trace(L"CWebDavCleaner::~CWebDavCleaner");
        if (m_szVolume) {
            delete [] m_szVolume;
            m_szVolume = NULL;
        }

        ::DllRelease();
    }

    static HRESULT WINAPI CreateInstance(REFIID riid, LPVOID *ppv);

    // 
    // IUnknown methods
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // 
    // IEmptyVolumeCache methods
    //
    STDMETHODIMP Initialize(HKEY hkRegKey,
        LPCWSTR pcwszVolume,
        LPWSTR *ppwszDisplayName,
        LPWSTR *ppwszDescription,
        LPDWORD pdwFlags
        );

    STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwlSpaceUsed,
        LPEMPTYVOLUMECACHECALLBACK picb
        );

    STDMETHODIMP Purge(DWORDLONG dwlSpaceToFree,
        LPEMPTYVOLUMECACHECALLBACK picb
        );

    STDMETHODIMP ShowProperties(HWND hwnd);
    STDMETHODIMP Deactivate(LPDWORD pdwFlags);

    // 
    // IEmptyVolumeCache2 methods
    //
    STDMETHODIMP InitializeEx(HKEY hkRegKey,
        LPCWSTR pcwszVolume,
        LPCWSTR pcwszKeyName,
        LPWSTR *ppwszDisplayName,
        LPWSTR *ppwszDescription,
        LPWSTR *ppwszBtnText,
        LPDWORD pdwFlags
        );

private:
    VOID pToUpperCase(IN PWSTR sz) 
    {
        for (UINT i = 0; i < wcslen(sz); i++) {
            if ((sz[i] >= L'a') && (sz[i] <= L'z')) {
                sz[i] += L'A' - L'a';
            }
        }
    }


};

#endif  // _VOLFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\davname.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davname.h

Abstract:

    This file contains service name strings for the dav redir. it should
    be folded into lmsname.h at some point

Environment:

    User Mode -Win32

--*/

#ifndef _DAVNAME_
#define _DAVNAME_

#if _MSC_VER > 1000
#pragma once
#endif

//
//  Standard LAN Manager service names.
//

#define SERVICE_DAVCLIENT       L"WebClient"

#define DAVCLIENT_DRIVER        L"MRxDAV"

#define DAV_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\WebClient\\Parameters"
#define DAV_DEBUG_KEY            L"ServiceDebug"
#define DAV_MAXTHREADS_KEY       L"MaxThreads"
#define DAV_THREADS_KEY          L"Threads"

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_DAV_DEVICE_NAME    "\\Device\\WebDavRedirector"
#define DD_DAV_DEVICE_NAME_U L"\\Device\\WebDavRedirector"

#define DAV_ENCODE_SEED     0x9C

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//
#define DD_DAV_FILESYS_NAME "FAT"
#define DD_DAV_FILESYS_NAME_U L"FAT"
// #define DD_DAV_FILESYS_NAME "WebDavRedirector"
// #define DD_DAV_FILESYS_NAME_U L"WebDavRedirector"

#endif


//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_DAV_BASE                  0x400

#define _DAV_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_DAV_BASE, request, method, access)


#define FSCTL_DAV_START                  _DAV_CONTROL_CODE(1, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_STOP                   _DAV_CONTROL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_SET_CONFIG_INFO        _DAV_CONTROL_CODE(3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_CONFIG_INFO        _DAV_CONTROL_CODE(4, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_CONNECTION_INFO    _DAV_CONTROL_CODE(5, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DAV_ENUMERATE_CONNECTIONS  _DAV_CONTROL_CODE(6, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_VERSIONS           _DAV_CONTROL_CODE(7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_DELETE_CONNECTION      _DAV_CONTROL_CODE(8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_STATISTICS         _DAV_CONTROL_CODE(9, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v

$(O)\netdav.inf: $(_INX)\netdav.inx $(_LNG)\netdav.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\cancel.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cancel.c

Abstract:

    This module implements the routines relating to the cancel logic in the 
    DAV MiniRedir.

Author:

    Rohan Kumar     [RohanK]    10-April-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "netevent.h"
#include "nvisible.h"
#include "webdav.h"
#include "ntddmup.h"
#include "rxdata.h"
#include "fsctlbuf.h"

//
// The timeout value used by the MiniRedir. If an operation is not completed
// within the timeout then it is cancelled. The user can set this to 0xffffffff
// to disable the timeout/cancel logic. In other words, if the timeout value
// is 0xffffffff, the requests will never timeout.
//
ULONG RequestTimeoutValueInSec;
LARGE_INTEGER RequestTimeoutValueInTickCount;

//
// The timer object used by the timer thread that cancels the requests which
// have not completed in a specified time.
//
KTIMER DavTimerObject;

//
// This is used to indicate the timer thread to shutdown. When the system is
// being shutdown this is set to TRUE. MRxDAVTimerThreadLock is the resource
// used to gain access to this variable.
//
BOOL TimerThreadShutDown;
ERESOURCE MRxDAVTimerThreadLock;

//
// The handle of the timer thread that is created using PsCreateSystemThread
// is stored this global.
//
HANDLE TimerThreadHandle;

//
// This event is signalled by the timer thread right before its going to
// terminate itself.
//
KEVENT TimerThreadEvent;

NTSTATUS
MRxDAVCancelTheContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVCompleteTheCancelledRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleGeneralCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleQueryDirCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCloseSrvOpenCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleSetFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateSrvCallCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleSrvCallFinalizeCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleFinalizeVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCleanupFobxCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleRenameCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleQueryFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVCancelRoutine(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine initiates the cancellation of an I/O request.

Arguments:

    RxContext - The RX_CONTEXT instance which needs to be cancelled.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY listEntry = NULL;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    BOOL lockAcquired = FALSE, contextFound = FALSE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelRoutine. RxContext = %08lx\n",
                 PsGetCurrentThreadId(), RxContext));

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    listEntry = UMRxAsyncEngineContextList.Flink;

    while ( listEntry != &(UMRxAsyncEngineContextList) ) {

        //
        // Get the pointer to the UMRX_ASYNCENGINE_CONTEXT structure.
        //
        AsyncEngineContext = CONTAINING_RECORD(listEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               ActiveContextsListEntry);

        listEntry = listEntry->Flink;

        //
        // Check to see if this entry is for the RxContext in question.
        //
        if (AsyncEngineContext->RxContext == RxContext) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCancelRoutine: RxContext: %08lx FOUND\n",
                         PsGetCurrentThreadId(), RxContext));
            contextFound = TRUE;
            break;
        }

    }

    if (!contextFound) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCancelTheContext: RxContext: %08lx NOT FOUND\n",
                     PsGetCurrentThreadId(), RxContext));
        goto EXIT_THE_FUNCTION;
    }

    NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, TRUE);

EXIT_THE_FUNCTION:

    //
    // If we acquired the UMRxAsyncEngineContextListLock, then we need to
    // release it now.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelTheContext: Returning NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


VOID
MRxDAVContextTimerThread(
    PVOID DummyContext
    )
/*++

Routine Description:

   This timer thread is created with this routine. The thread waits on a timer
   object which gets signalled RequestTimeoutValueInSec after it has been
   inserted into the timer queue.

Arguments:

    DummyContext - A dummy context that is supplied.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LONGLONG DueTimeInterval;
    LONG CopyTheRequestTimeValue;
    BOOLEAN setTimer = FALSE, lockAcquired = FALSE;

    CopyTheRequestTimeValue = RequestTimeoutValueInSec;

    do {

        //
        // If TimerThreadShutDown is set to TRUE, it means that the system is
        // being shutdown. The job of this thread is done. We check here after
        // we have gone through the context list and before we restart the wait.
        // We also check this below as soon as the DavTimerObject is signalled.
        //
        ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);
        lockAcquired = TRUE;
        if (TimerThreadShutDown) {
            break;
        }
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;

        //
        // We set the DueTimeInterval to be -ve RequestTimeoutValueInSec in 100
        // nano seconds. This is because this tells KeSetTimerEx that the 
        // expiration time is relative to the current system time.
        //
        DueTimeInterval = ( -CopyTheRequestTimeValue * 1000 * 1000 * 10 );

        //
        // Call KeSetTimerEx to insert the TimerObject in the system's timer
        // queue. Also, the return value should be FALSE since this timer
        // should not exist in the system queue.
        //
        setTimer = KeSetTimerEx(&(DavTimerObject), *(PLARGE_INTEGER)&(DueTimeInterval), 0, NULL);
        ASSERT(setTimer == FALSE);

        //
        // Wait for the timer object to be signalled. This call should only 
        // return if the wait has been satisfied, which implies that the return
        // value is STATUS_SUCCESS.
        //
        NtStatus = KeWaitForSingleObject(&(DavTimerObject),
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);
        ASSERT(NtStatus == STATUS_SUCCESS);

        //
        // If TimerThreadShutDown is set to TRUE, it means that the system is
        // being shutdown. The job of this thread is done. We check as soon as 
        // the DavTimerObject is signalled. We also check this above as soon
        // as we complete cycling through the context list.
        //
        ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);
        lockAcquired = TRUE;
        if (TimerThreadShutDown) {
            break;
        }
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;

        //
        // Now call MRxDAVTimeOutTheContexts which cycles through all the
        // currently active contexts and cancels the ones that have been hanging
        // around for more than RequestTimeoutValueInSec.
        //
        MRxDAVTimeOutTheContexts(FALSE);

    } while (TRUE);

    //
    // If the lock is still acquired, we need to release it.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;
    }

    //
    // Set the timer thread event signalling that the timer thread is done
    // with the MRxDAVTimerThreadLock and that it can be deleted.
    //
    KeSetEvent(&(TimerThreadEvent), 0, FALSE);

    //
    // Close the thread handle to remove the reference on the object. We need 
    // to do this before we call PsTerminateSystemThread.
    //
    ZwClose(TimerThreadHandle);

    //
    // Terminate this thread since we are going to shutdown now.
    //
    PsTerminateSystemThread(STATUS_SUCCESS);

    return;
}


VOID
MRxDAVTimeOutTheContexts(
    BOOL WindDownAllContexts
    )
/*++

Routine Description:

   This routine is called by the thread that wakes up every "X" minutes to see
   if some AsyncEngineContext has been hanging around in the active contexts
   list for more than "X" minutes. If it finds some such context, it just cancels
   the operation. The value "X" is read from the registry and is stored in the
   global variable MRxDAVRequestTimeoutValueInSec at driver init time. This value
   defaults to 10 min. In other words, if an operation has not completed in "X"
   minutes, it is cancelled. The user can set this value to 0xffffffff to turn
   off the timeout. 
   
   It can also be called by the thread that is trying to complete all the 
   requests and stop the MiniRedir. This happens when the WebClient service 
   is being stopped.

Arguments:

    WindDownAllContexts - If this is set to TRUE, then all the contexts are
                          cancelled no matter when they were added to the list.
                          This is set to FALSE by the timer thread and to TRUE
                          by the thread that is stopping the MiniRedir.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY listEntry = NULL;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    BOOL lockAcquired = FALSE;
    LARGE_INTEGER CurrentSystemTickCount, TickCountDifference;

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    listEntry = UMRxAsyncEngineContextList.Flink;

    while ( listEntry != &(UMRxAsyncEngineContextList) ) {

        //
        // Get the pointer to the UMRX_ASYNCENGINE_CONTEXT structure.
        //
        AsyncEngineContext = CONTAINING_RECORD(listEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               ActiveContextsListEntry);

        listEntry = listEntry->Flink;

        if (!WindDownAllContexts) {

            KeQueryTickCount( &(CurrentSystemTickCount) );

            //
            // Get the time elapsed (in system tick counts) since the time this
            // AsyncEngineContext was created.
            //
            TickCountDifference.QuadPart = (CurrentSystemTickCount.QuadPart - AsyncEngineContext->CreationTimeInTickCount.QuadPart);

            //
            // If the amount of time that has elapsed since this context was added
            // to the list is greater than the timeout value, then cancel the
            // request.
            //
            if (TickCountDifference.QuadPart > RequestTimeoutValueInTickCount.QuadPart) {
                NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, FALSE);
            }

        } else {

            //
            // If we were asked to wind down all the contexts then we cancel
            // every request no matter when it was inserted into the active
            // context list.
            //
            NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, FALSE);

        }

    }

    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    return;
}


NTSTATUS
MRxDAVCancelTheContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles the cancellation of an I/O request. The caller of this
   routine needs to acquire the global UMRxAsyncEngineContextListLock before
   the call is made.

Arguments:

    AsyncEngineContext - The UMRX_ASYNCENGINE_CONTEXT instance which needs to be
                         cancelled.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelTheContext. AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    //
    // We do not cancel read and wrtie operations.
    //
    switch (DavContext->EntryPoint) {
    case DAV_MINIRDR_ENTRY_FROM_READ:
    case DAV_MINIRDR_ENTRY_FROM_WRITE:
        goto EXIT_THE_FUNCTION;
    }

    //
    // We shouldn't be getting cancel I/O calls for which the MiniRedir callouts
    // which cannot be cancelled by the user. These can however be cancelled
    // by the timeout thread.
    //
    if (UserInitiatedCancel) {
        switch (DavContext->EntryPoint) {
        case DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL:
        case DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL:
        case DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX:
        case DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT:
        case DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT:
        case DAV_MINIRDR_ENTRY_FROM_CREATE:
            DbgPrint("MRxDAVCancelTheContext: Invalid EntryPoint = %d\n", DavContext->EntryPoint);
            ASSERT(FALSE);
            goto EXIT_THE_FUNCTION;
        }
    }

    switch (AsyncEngineContext->AsyncEngineContextState) {

    case UMRxAsyncEngineContextAllocated:
    case UMRxAsyncEngineContextInUserMode:
        AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextCancelled;
        break;

    default:
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCancelTheContext: NOT Being Cancelled. AsyncEngineContextState: %d\n",
                     PsGetCurrentThreadId(), AsyncEngineContext->AsyncEngineContextState));
        goto EXIT_THE_FUNCTION;

    }

    NtStatus = MRxDAVCompleteTheCancelledRequest(AsyncEngineContext, UserInitiatedCancel);

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVCompleteTheCancelledRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion if the request that has been cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context of the operation that is being
                         cancelled.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCompleteTheCancelledRequest. AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    switch (DavContext->EntryPoint) {
    
    case DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL:
        NtStatus = MRxDAVHandleCreateSrvCallCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT:
        NtStatus = MRxDAVHandleCreateVNetRootCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL:
        NtStatus = MRxDAVHandleSrvCallFinalizeCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT:
        NtStatus = MRxDAVHandleFinalizeVNetRootCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CREATE:
        NtStatus = MRxDAVHandleCreateCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_QUERYDIR:
        NtStatus = MRxDAVHandleQueryDirCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN:
        NtStatus = MRxDAVHandleCloseSrvOpenCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION:
        NtStatus = MRxDAVHandleSetFileInfoCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX:
        NtStatus = MRxDAVHandleCleanupFobxCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_RENAME:
        NtStatus = MRxDAVHandleRenameCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION:
        NtStatus = MRxDAVHandleQueryFileInfoCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    default:
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCancelTheContext: EntryPoint: %d\n",
                     PsGetCurrentThreadId(), DavContext->EntryPoint));
        goto EXIT_THE_FUNCTION;

    }

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVHandleGeneralCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the some requests which has been cancelled.
   Its called by those rotuines whose completion is straight forward and does
   not require any special handling.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;

    //
    // Only an AsyncOperation which would have returned STATUS_IO_PENDING
    // can be cancelled by a user.
    //
    if (UserInitiatedCancel) {
        ASSERT(AsyncEngineContext->AsyncOperation == TRUE);
    }

    RxContext = AsyncEngineContext->RxContext;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVHandleGeneralCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // If this cancel operation was initiated by the user, we return
    // STATUS_CANCELLED. If it was initiated by the timeout thread, we return
    // STATUS_IO_TIMEOUT.
    //
    if (UserInitiatedCancel) {
        AsyncEngineContext->Status = STATUS_CANCELLED;
    } else {
        AsyncEngineContext->Status = STATUS_IO_TIMEOUT;
    }

    AsyncEngineContext->Information = 0;

    //
    // We take different course of action depending upon whether this request
    // was a synchronous or an asynchronous request.
    //
    if (AsyncEngineContext->AsyncOperation) {
        //
        // Complete the request by calling RxCompleteRequest.
        //
        RxContext->CurrentIrp->IoStatus.Status = AsyncEngineContext->Status;
        RxContext->CurrentIrp->IoStatus.Information = AsyncEngineContext->Information;
        RxCompleteRequest(RxContext, AsyncEngineContext->Status);
    } else {
        //
        // This was a synchronous request. There is a thread waiting for this
        // request to finish and be signalled. Signal the thread that is waiting
        // after queuing the workitem on the KQueue.
        //
        RxSignalSynchronousWaiter(RxContext);
    }

    return NtStatus;
}


NTSTATUS
MRxDAVHandleQueryDirCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the QueryDirectory request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleQueryDirCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCloseSrvOpenCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CloseSrvOpen request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCloseSrvOpenCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleSetFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the SetFileInfo request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleSetFileInfoCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the Create request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateSrvCallCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CreateSrvCall request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;

    RxContext = AsyncEngineContext->RxContext;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateSrvCallCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    //
    // A CreateSrvCall operation is always Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == TRUE);

    SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
    ASSERT(SCCBC != NULL);
    SrvCalldownStructure = SCCBC->SrvCalldownStructure;
    ASSERT(SrvCalldownStructure != NULL);
    SrvCall = SrvCalldownStructure->SrvCall;
    ASSERT(SrvCall != NULL);

    //
    // We allocated memory for it, so it better not be NULL.
    //
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    if (DavSrvCall->SCAlreadyInitialized) {
        ASSERT(RxContext->MRxContext[2] != NULL);
        SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
        RxFreePool(RxContext->MRxContext[2]);
        RxContext->MRxContext[2] = NULL;
        DavSrvCall->SCAlreadyInitialized = FALSE;
    }

    //
    // Set the status in the callback structure. If a CreateSrvCall is being
    // cancelled, this implies that it is being done by the timeout thread
    // since a user can never cancel a create request. Hence the status we set
    // is STATUS_IO_TIMEOUT.
    //
    ASSERT(UserInitiatedCancel == FALSE);
    SCCBC->Status = STATUS_IO_TIMEOUT;
    
    //
    // Call the callback function supplied by RDBSS.
    //
    SrvCalldownStructure->CallBack(SCCBC);
    
    return NtStatus;
}


NTSTATUS
MRxDAVHandleSrvCallFinalizeCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the SrvCallFinalize request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleSrvCallFinalizeCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CreateVNetRoot request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;

    RxContext = AsyncEngineContext->RxContext;
    
    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateVNetRootCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
    // RxContext structure. This is done in the MRxDAVCreateVNetRoot
    // function.
    //
    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    DavVNetRoot->createVNetRootUnSuccessful = TRUE;

    //
    // Set the status in the AsyncEngineContext. If a CreateSrvCall is being
    // cancelled, this implies that it is being done by the timeout thread
    // since a user can never cancel a create request. Hence the status we set
    // is STATUS_IO_TIMEOUT.
    //
    ASSERT(UserInitiatedCancel == FALSE);
    AsyncEngineContext->Status = STATUS_IO_TIMEOUT;

    //
    // This was a synchronous request. There is a thread waiting for this
    // request to finish and be signalled. Signal the thread that is waiting
    // after queuing the workitem on the KQueue.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);
    RxSignalSynchronousWaiter(RxContext);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleFinalizeVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the FinalizeVNetRoot request which has
   been cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleFinalizeVNetRootCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCleanupFobxCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CleanupFobx request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCleanupFobxCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleRenameCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the Rename request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleRenameCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleQueryFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the QueryFileInfo request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleQueryFileInfoCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\usrmddav.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usrmddav.h

Abstract:

    This module defines the data structures which are shared by the user mode
    and the kernel mode components of the WebDav miniredirector.

Author:

    Rohan Kumar      [RohanK]      30-March-1999

Revision History:

--*/

#ifndef _USRMDDAV_H
#define _USRMDDAV_H

//
// The subset of DAV file attributes (common with NTFS attributes) which get 
// returned on a PROPFIND call. 
//
typedef struct _DAV_FILE_ATTRIBUTES {
    BOOL InvalidNode;
    ULONG FileIndex;
    DWORD dwFileAttributes;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastModifiedTime;
    LARGE_INTEGER DavCreationTime;
    LARGE_INTEGER DavLastModifiedTime;
    LARGE_INTEGER FileSize;
    LIST_ENTRY NextEntry;
    BOOL isHidden;
    BOOLEAN isCollection;
    ULONG FileNameLength;
    PWCHAR FileName;
    PWCHAR Status;
    BOOL    fReportsAvailableSpace;
    LARGE_INTEGER    TotalSpace;
    LARGE_INTEGER    AvailableSpace;
} DAV_FILE_ATTRIBUTES, *PDAV_FILE_ATTRIBUTES;

#ifndef __cplusplus

//
// The fileinfo that gets filled in by the user mode process and returned to the
// kernel mode miniredir.
//
typedef struct _DAV_USERMODE_CREATE_RETURNED_FILEINFO {

    //
    // File's Basic Info.
    //
    union {
        ULONG ForceAlignment1;
        FILE_BASIC_INFORMATION BasicInformation;
    };

    //
    // File's Standard Info.
    //
    union {
        ULONG ForceAlignment2;
        FILE_STANDARD_INFORMATION StandardInformation;
    };

} DAV_USERMODE_CREATE_RETURNED_FILEINFO,*PDAV_USERMODE_CREATE_RETURNED_FILEINFO;

//
// Structure used in create/close requests.
//
typedef struct _DAV_HANDLE_AND_USERMODE_KEY {

    //
    // The handle of the file being opened.
    //
    HANDLE Handle;

    //
    // This is set to the handle value and is used for debugging purposes.
    //
    PVOID UserModeKey;

} DAV_HANDLE_AND_USERMODE_KEY, *PDAV_HANDLE_AND_USERMODE_KEY;

//
// The Dav create request flags and buffer.
//
#define DAV_SECURITY_DYNAMIC_TRACKING   0x01
#define DAV_SECURITY_EFFECTIVE_ONLY     0x02

typedef struct _DAV_USERMODE_CREATE_REQUEST {

    //
    // The complete path name of the create request. The user mode process
    // parses this path name and creates a URL to be sent to the server.
    //
    PWCHAR CompletePathName;

    //
    // The server's unique id which was got during the CreateSrvCall.
    //
    ULONG ServerID;

    //
    // The user/session's LogonID.
    //
    LUID LogonID;

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    ULONG SdLength;

    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;

    ULONG SecurityFlags;

    ACCESS_MASK DesiredAccess;

    LARGE_INTEGER AllocationSize;

    ULONG FileAttributes;

    ULONG ShareAccess;

    ULONG CreateDisposition;

    ULONG CreateOptions;

    PVOID EaBuffer;

    ULONG EaLength;

    BOOLEAN FileInformationCached;
    BOOLEAN FileNotExists;
    BOOLEAN ParentDirInfomationCached;
    BOOLEAN ParentDirIsEncrypted;

} DAV_USERMODE_CREATE_REQUEST, *PDAV_USERMODE_CREATE_REQUEST;

//
// The create response returned by the user mode.
//
typedef struct _DAV_USERMODE_CREATE_RESPONSE {

    //
    // The filename of the local file that represents the file on the DAV server
    // which got created/opened. Locally, the files are cached in the IE cache.
    //
    WCHAR FileName[MAX_PATH];

    WCHAR Url[MAX_PATH * 2];

    //
    // If this was a new file created on the server, do we need to set the 
    // attributes on Close ?
    //
    BOOL NewFileCreatedAndSetAttributes;

    //
    // If a new file or directory is created, we need to PROPPATCH the time
    // values on close. This is because we use the time values from the client
    // when the name cache entry is created for this new file. The same time
    // value needs to be on the server.
    //
    BOOL PropPatchTheTimeValues;

    //
    // If this is TRUE, it means that the file exists on the server, but 
    // "FILE_OVERWRITE_IF" was specified as the CreateDisposition. So, the file
    // was created locally and the new file needs to be PUT (overwrite) over the
    // old file on the server on close.
    //
    BOOL ExistsAndOverWriteIf;

    //
    // Was "FILE_DELETE_ON_CLOSE" specified as one of the CreateOptions ?
    //
    BOOL DeleteOnClose;

    //
    // We haven't really opened the file as the caller is either deleting or 
    // reading/setting attributes.
    //
    BOOL fPsuedoOpen;

    BOOL LocalFileIsEncrypted;

    union {
        DAV_HANDLE_AND_USERMODE_KEY;
        DAV_HANDLE_AND_USERMODE_KEY HandleAndUserModeKey;
    };

    union {
        DAV_USERMODE_CREATE_RETURNED_FILEINFO;
        DAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo;
    };

} DAV_USERMODE_CREATE_RESPONSE, *PDAV_USERMODE_CREATE_RESPONSE;

//
// Create SrvCall request buffer.
//
typedef struct _DAV_USERMODE_CREATE_SRVCALL_REQUEST {

    //
    // The name of the server for which a SrvCall is being created. The user
    // mode process verifies whether this server exists and whether it speaks
    // DAV.
    //
    PWCHAR ServerName;

    //
    // The user/session's LogonID.
    //
    LUID LogonID;

    //
    // Am I the thread that is creating and initializing this ServerHashEntry?
    //
    BOOL didICreateThisSrvCall;

    //
    // Am I a thread that did a wait and took a reference while some other
    // thread was creating and initializing this ServerHashEntry?
    //
    BOOL didIWaitAndTakeReference;

} DAV_USERMODE_CREATE_SRVCALL_REQUEST, *PDAV_USERMODE_CREATE_SRVCALL_REQUEST;

//
// The Create SrvCall response.
//
typedef struct _DAV_USERMODE_CREATE_SRVCALL_RESPONSE {

    //
    // The Server ID is generated in the user mode when a create srvcall
    // request comes up. This is stored in the mini-redir's portion of the
    // srvcall structure and is sent up along with future reflections against
    // this server.
    //
    ULONG ServerID;

} DAV_USERMODE_CREATE_SRVCALL_RESPONSE, *PDAV_USERMODE_CREATE_SRVCALL_RESPONSE;

//
// Finalize SrvCall request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_SRVCALL_REQUEST {

    //
    // The server whose entry is being finalized.
    //
    PWCHAR ServerName;

    //
    // The ServerID for the server.
    //
    ULONG ServerID;

} DAV_USERMODE_FINALIZE_SRVCALL_REQUEST, *PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST;

//
// The QueryDirectory request buffer.
//
typedef struct _DAV_USERMODE_QUERYDIR_REQUEST {

    //
    // Is the DavFileAttributes list for this directory created ? This is set 
    // to TRUE after the fisrt call to QueryDirectory gets satisfied.
    //
    BOOL AlreadyDone;

    //
    // The template that came with the QueryDirectory request does not contain
    // wild cards.
    //
    BOOL NoWildCards;
    
    //
    // LogonID of this session.
    //
    LUID LogonID;

    //
    // The server being queried.
    //
    PWCHAR ServerName;

    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The path of the direcotry being queried on the server.
    //
    PWCHAR PathName;

} DAV_USERMODE_QUERYDIR_REQUEST, *PDAV_USERMODE_QUERYDIR_REQUEST;

//
// The QueryDirectory response buffer.
//
typedef struct _DAV_USERMODE_QUERYDIR_RESPONSE {

    //
    // The list of DavFileAttributes for the files under the directory being
    // queried.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

    //
    // Number of entries in the DavFileAttributes list.
    //
    ULONG NumOfFileEntries;

} DAV_USERMODE_QUERYDIR_RESPONSE, *PDAV_USERMODE_QUERYDIR_RESPONSE;

//
// The Close request buffer.
//
typedef struct _DAV_USERMODE_CLOSE_REQUEST {

    union {
        DAV_HANDLE_AND_USERMODE_KEY;
        DAV_HANDLE_AND_USERMODE_KEY HandleAndUserModeKey;
    };

    //
    // LogonID of this session.
    //
    LUID LogonID;

    //
    // The server being queried.
    //
    PWCHAR ServerName;

    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The path of the direcotry being queried on the server.
    //
    PWCHAR PathName;

    //
    // Should this file be deleted on Close ?
    //
    BOOL DeleteOnClose;

    //
    // Was the file modified ? If it was, then we need to PUT the modified
    // file back to the server.
    //
    BOOL FileWasModified;

    //
    // Was the handle to this file created in the kernel.
    //
    BOOL createdInKernel;

    //
    // Is this a Directory ?
    //
    BOOL isDirectory;
    
    //
    // Basic Information change
    //
    BOOLEAN fCreationTimeChanged;
    
    BOOLEAN fLastAccessTimeChanged;
    
    BOOLEAN fLastModifiedTimeChanged;    
    
    BOOLEAN fFileAttributesChanged;

    LARGE_INTEGER CreationTime;
    
    LARGE_INTEGER LastAccessTime;
    
    LARGE_INTEGER LastModifiedTime;
    
    LARGE_INTEGER  AvailableSpace;
    
    DWORD dwFileAttributes;
    ULONG FileSize;

    //
    // The local file name of the file created/opened on the DAV server.
    //
    WCHAR FileName[MAX_PATH];
    WCHAR Url[MAX_PATH * 2];

} DAV_USERMODE_CLOSE_REQUEST, *PDAV_USERMODE_CLOSE_REQUEST;

//
// The Finalize Fobx request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_FOBX_REQUEST {

    //
    // The list of DavFileAttributes for the files under the directory being
    // queried.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

} DAV_USERMODE_FINALIZE_FOBX_REQUEST, *PDAV_USERMODE_FINALIZE_FOBX_REQUEST;

//
// The  request buffer.
//
typedef struct _DAV_USERMODE_SETFILEINFORMATION_REQUEST {

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The server name on which the file/dir resides
    //
    PWCHAR ServerName;

    //
    // The path name of the file or directory
    //
    PWCHAR PathName;

    //
    // Basic Information change
    //
    BOOLEAN fCreationTimeChanged;
    
    BOOLEAN fLastAccessTimeChanged;
    
    BOOLEAN fLastModifiedTimeChanged;    
    
    BOOLEAN fFileAttributesChanged;


    //
    // for now we will set only the basic info. In future we may want to expand this filed to FILE_ALL_INFORMATION
    //
    FILE_BASIC_INFORMATION          FileBasicInformation;

} DAV_USERMODE_SETFILEINFORMATION_REQUEST, *PDAV_USERMODE_SETFILEINFORMATION_REQUEST;


typedef struct _DAV_USERMODE_RENAME_REQUEST {

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;

    //
    // If the destination file exists, replace it if this is TRUE. If its FALSE,
    // fail.
    //
    BOOLEAN ReplaceIfExists;
    
    //
    // The server name on which the file being renamed resides.
    //
    PWCHAR ServerName;

    //
    // The old path name of the file.
    //
    PWCHAR OldPathName;

    //
    // The new path name of the file.
    //
    PWCHAR NewPathName;
    WCHAR Url[MAX_PATH * 2];

} DAV_USERMODE_RENAME_REQUEST, *PDAV_USERMODE_RENAME_REQUEST;


//
// The Create V_NET_ROOT request buffer.
//
typedef struct _DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // ShareName. We need to find out if this share exists or not.
    //
    PWCHAR ShareName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
} DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST, *PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST;

//
// The CreateVNetRoot response buffer.
//
typedef struct _DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE {

    //
    // Is this an Office Web Server share?
    //
    BOOL isOfficeShare;

    //
    // Is this a Tahoe share?
    //
    BOOL isTahoeShare;

    //
    // OK to do PROPPATCH?
    //
    BOOL fAllowsProppatch;    

    //
    // Does it report available space?
    //    
    BOOL fReportsAvailableSpace;

} DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE, *PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE;

//
// The finalize VNetRoot request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;

} DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST, *PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST;


//
// The Create QUERYVOLUMEINFORMATION request buffer.
//
typedef struct _DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // ShareName. We need to find out if this share exists or not.
    //
    PWCHAR ShareName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
} DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST, *PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST;

//
// The CreateVNetRoot response buffer.
//
typedef struct _DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE {

    //
    // If someone reports available space, keep it
    //    
    LARGE_INTEGER   TotalSpace;
    LARGE_INTEGER   AvailableSpace;

} DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE, *PDAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE;






//
// The various types of usermode work requests handled by the reflector. These
// requests are filled in by the kernel.
//
typedef union _DAV_USERMODE_WORK_REQUEST {
    DAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest;
    DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest;
    DAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinalizeSrvCallRequest;
    DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST FinalizeVNetRootRequest;
    DAV_USERMODE_CREATE_REQUEST CreateRequest;
    DAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest;
    DAV_USERMODE_CLOSE_REQUEST CloseRequest;
    DAV_USERMODE_FINALIZE_FOBX_REQUEST FinalizeFobxRequest;
    DAV_USERMODE_RENAME_REQUEST ReNameRequest;
    DAV_USERMODE_SETFILEINFORMATION_REQUEST    SetFileInformationRequest;
    DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST     QueryVolumeInformationRequest;
} DAV_USERMODE_WORK_REQUEST, *PDAV_USERMODE_WORK_REQUEST;

//
// The various types of usermode work responses send down to the kernel by the
// reflector.
//
typedef union _DAV_USERMODE_WORK_RESPONSE {
    DAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse;
    DAV_USERMODE_CREATE_RESPONSE CreateResponse;
    DAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse;
    DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse;
    DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE  QueryVolumeInformationResponse;
} DAV_USERMODE_WORK_RESPONSE, *PDAV_USERMODE_WORK_RESPONSE;

//
// The DAV operations which need callbacks. These are the operations which are
// performed asynchronously. NOTE!!!! The order of these is important. Do not
// change them. If you need to add an operation, add it at the end.
//
typedef enum _DAV_OPERATION {
    DAV_CALLBACK_INTERNET_CONNECT = 0,
    DAV_CALLBACK_HTTP_OPEN,
    DAV_CALLBACK_HTTP_SEND,
    DAV_CALLBACK_HTTP_END,
    DAV_CALLBACK_HTTP_READ,
    DAV_CALLBACK_MAX
} DAV_OPERATION;

typedef enum _DAV_WORKITEM_TYPES {
    UserModeCreate = 0,
    UserModeCreateVNetRoot,
    UserModeQueryDirectory,
    UserModeClose,
    UserModeCreateSrvCall,
    UserModeFinalizeSrvCall,
    UserModeFinalizeFobx,
    UserModeFinalizeVNetRoot,
    UserModeReName,
    UserModeSetFileInformation,
    UserModeQueryVolumeInformation,
    UserModeMaximum
} DAV_WORKITEM_TYPES;

//
// We expose the signatures of the HASH_SERVER_ENTRY and PER_USER_ENTRY structs
// in this file. This is done so that we can use these names (for type checking
// by the compiler) in the DavWorkItem structure instead of using PVOID.
//
typedef struct _HASH_SERVER_ENTRY *PHASH_SERVER_ENTRY;
typedef struct _PER_USER_ENTRY *PPER_USER_ENTRY;

//
// A Create call is mapped to two DAV calls. A PROPFIND, followed by the GET of
// the file. This is a list of calls that could be sent to the server during
// create.
//
typedef enum _DAV_ASYNC_CREATE_STATES {
    AsyncCreatePropFind = 0,
    AsyncCreateQueryParentDirectory,
    AsyncCreateGet,
    AsyncCreateMkCol,
    AsyncCreatePut
} DAV_ASYNC_CREATE_STATES;

typedef enum _DAV_MINOR_OPERATION {
    DavMinorQueryInfo = 0,
    DavMinorReadData,
    DavMinorPushData,
    DavMinorWriteData,
    DavMinorDeleteFile,
    DavMinorPutFile,
    DavMinorProppatchFile
} DAV_MINOR_OPERATION;

//
// The Dav usermode workitem that gets passed between user and kernel mode.
// This structure also gets used as a callback context in async DAV operations.
//
typedef struct _DAV_USERMODE_WORKITEM {

    //
    // WorkItem Header. This header is used by the reflector library and is
    // shared across miniredirs.
    //
    union {
        UMRX_USERMODE_WORKITEM_HEADER;
        UMRX_USERMODE_WORKITEM_HEADER Header;
    };

    //
    // The kernel mode operation that got reflected upto the user mode.
    //
    DAV_WORKITEM_TYPES WorkItemType;

    //
    // The DAV operation for which this callback is being returned.
    //
    DAV_OPERATION DavOperation;

    //
    // The Minor operation. Used for handling Async reads.
    //
    DAV_MINOR_OPERATION DavMinorOperation;

    //
    // This restart routine is called after we've finished doing an async
    // operation on a worker thread. Type: LPTHREAD_START_ROUTINE.
    //
    LPVOID RestartRoutine;

    //
    // The Handle used to impersonate the user thread which initiated the
    // request.
    //
    HANDLE ImpersonationHandle;

    //
    // This keeps the list of InternetStatus the callback function was called
    // with for this workitem. This is just for debugging purposes.
    //
    USHORT InternetStatusList[200];

    //
    // This is the index of the above array.
    //
    ULONG InternetStatusIndex;

    //
    // The thread that is handling this request. This is helpful in debugging
    // the threads that get stuck in WinInet.
    //
    ULONG ThisThreadId;

    //
    // Pointer to the structure that contains the handles created by the
    // asynchronous calls.
    //
#ifdef WEBDAV_KERNEL
    LPVOID AsyncResult;
#else
    LPINTERNET_ASYNC_RESULT AsyncResult;
#endif

    //
    // Union of structs used in Async operations.
    //
    union {

        //
        // Async Create SrvCall.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The InternetConnect handle.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavConnHandle;
#else
            HINTERNET DavConnHandle;
#endif

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncCreateSrvCall;

        //
        // Async Create CreateVNetRoot.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // If a reference was taken on the PerUserEntry while creating the
            // VNetRoot, this is set to TRUE. If we fail and this is TRUE, we
            // decrement the reference.
            //
            BOOL didITakeReference;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncCreateVNetRoot;

        //
        // AsyncQueryDirectoryCall.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Does the template that came with the QueryDirectory request
            // contain wildcards ?
            //
            BOOL NoWildCards;

            //
            // Data Buffer for reads.
            //
            PCHAR DataBuff;

            //
            // DWORD for storing the number of bytes read.
            //
            LPDWORD didRead;

            //
            // The context pointers used for parsing the XML data.
            //
            PVOID Context1;
            PVOID Context2;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncQueryDirectoryCall;
        //
        // Async AsyncQueryVolumeInformation
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncQueryVolumeInformation;


        //
        // Async Close.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The modified file is copied into this buffer and is "PUT" on the
            // server
            //
            PBYTE DataBuff;

            //
            // LocalAlloc takes the ULONG allocation size, no reason to declare ULONGLONG
            //
            ULONG DataBuffSizeInBytes;
            ULONG DataBuffAllocationSize;

#ifdef WEBDAV_KERNEL
            LPVOID InternetBuffers;
#else
            LPINTERNET_BUFFERS InternetBuffers;
#endif

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncClose;

        //
        // Async ReName.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The header which is added to the "MOVE" request to be sent to
            // the server and contains the destination URI.
            //
            PWCHAR HeaderBuff;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
        
        } AsyncReName;

        //
        // Async Create.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Is this a PROPFIND or a GET call.
            //
            DAV_ASYNC_CREATE_STATES AsyncCreateState;

            //
            // Data Buffer for reads.
            //
            PCHAR DataBuff;

            //
            // DWORD for storing the number of bytes read.
            //
            LPDWORD didRead;

            //
            // The FileHandle used in writing the file locally.
            //
            HANDLE FileHandle;

            //
            // Does the file being created exist on the server ?
            //
            BOOL doesTheFileExist;

            //
            // The context pointers used for parsing the XML data.
            //
            PVOID Context1;
            PVOID Context2;

            //
            // The remaining path name. For example in \\server\share\dir\f.txt
            // this would correspond to dir\f.txt.
            //
            PWCHAR RemPathName;

            //
            // The file name being created. From the above example, this would
            // correspond to f.txt.
            //
            PWCHAR FileName;

            //
            // The URL used to create an entry in the WinInet cache.
            //
            PWCHAR UrlBuffer;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
            LPVOID  lpCEI;  // cache entry info

        } AsyncCreate;
        
        struct {
            
            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;
            
            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;
        
        } ServerUserEntry;
        //
        // Async SetFileInformation
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The header which is added to the "MOVE" request to be sent to
            // the server and contains the destination URI.
            //
            PWCHAR HeaderBuff;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
        
        } AsyncSetFileInformation;

    };

    //
    // The request and response types.
    //
    struct {
        union {
            DAV_USERMODE_WORK_REQUEST;
            DAV_USERMODE_WORK_REQUEST WorkRequest;
        };
        union {
            DAV_USERMODE_WORK_RESPONSE;
            DAV_USERMODE_WORK_RESPONSE WorkResponse;
        };
    };

    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];

} DAV_USERMODE_WORKITEM, *PDAV_USERMODE_WORKITEM;

//
// The default HTTP/DAV port.
//
#define DEFAULT_HTTP_PORT 80

//
// The number of bytes to read in a single InternetReadFile call.
//
#define NUM_OF_BYTES_TO_READ 4096

#define EA_NAME_USERNAME            "UserName"
#define EA_NAME_PASSWORD            "Password"
#define EA_NAME_TYPE                "Type"
#define EA_NAME_WEBDAV_SIGNATURE    "mrxdav"

#endif // no __cplusplus

#endif // _USRMDDAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\davwmik.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DavWmiK.h

Abstract:

    This module contains the global definitions and macros needed for the WMI 
    Logging feature in the kernel for the DAV MiniRedir.

Author:

    Rohan Kumar     [RohanK]    06-June-2000

Revision History:

--*/

#ifndef _DAVWMIK_H_
#define _DAVWMIK_H_

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[32];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[32];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

#ifndef _WMIKM_
#define _WMIKM_
#endif

//
// Include the header files which exist in the rdr2\wmi directory.
//
#include "..\..\..\..\wmi\wmlkm.h"
#include "..\..\..\..\wmi\wmlmacro.h"

//
// DAV Streams.
//
#define _DAV_TRACE_STREAM               0x00
#define _DAV_PERF_STREAM                0x01
#define _DAV_INSTR_STREAM               0x02

#define _DAV_ENABLE_ERROR               0x0001
#define _DAV_ENABLE_LOG                 0x0002
#define _DAV_ENABLE_TRACE               0x0004
#define _DAV_ENABLE_SERVER              0x0008
#define _DAV_ENABLE_NETROOT             0x0010
#define _DAV_ENABLE_VNETROOT            0x0020
#define _DAV_ENABLE_FCB                 0x0040
#define _DAV_ENABLE_SRVOPEN             0x0080
#define _DAV_ENABLE_FOBX                0x0100
#define _DAV_ENABLE_TRANSPORT           0x0200
#define _DAV_ENABLE_RXCONTEXT           0x0400
#define _DAV_ENABLE_SESSION             0x0800
#define _DAV_ENABLE_SECURITY            0x1000
#define _DAV_ENABLE_EXCHANGE            0x2000
#define _DAV_ENABLE_UNUSED2             0x4000
#define _DAV_ENABLE_UNUSED1             0x8000

#define _DAV_LEVEL_DETAIL               0x1
#define _DAV_LEVEL_NORM                 0x2
#define _DAV_LEVEL_BRIEF                0x4

#define DAV_LOG_STREAM(_stream)   _DAV_ ## _stream ## _STREAM
#define DAV_LOG_FLAGS(_flag)      _DAV_ENABLE_ ## _flag
#define DAV_LOG_LEVEL(_level)     _DAV_LEVEL_ ## _level

#define DAV_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(MRxDav_, DAV_LOG_STREAM(_why), DAV_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,

#define DavTrace(_flag, _type, _arg)              \
            DAV_LOG(TRACE, DETAIL, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DavLog(_flag, _type, _arg)              \
            DAV_LOG(TRACE, BRIEF, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DavTraceError(_status, _flag, _type, _arg)    \
            DAV_LOG(TRACE, DETAIL, (DAV_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DAV_LOG_FLAGS(ERROR))), _type, _arg)

#define DavLogError(_status, _flag, _type, _arg)    \
            DAV_LOG(TRACE, BRIEF, (DAV_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DAV_LOG_FLAGS(ERROR))), _type, _arg)

#if 0
#define DAV_PERF(_flag, _type, _arg)                    \
            DAV_LOG (PERF, HIGH, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DAV_INSTR(_flag, _type, _arg)                   \
            DAV_LOG (INSTR, HIGH, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DAV_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, DAV_LOG_STREAM(_why), DAV_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define DAV_DBG_PRINT(_flag, _fmtstr, _arg)             \
            DAV_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define DAV_ERR_PRINT(_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                DAV_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }
#endif


enum DAV_WMI_ENUM {
  MSG_ID_DavDefault = 1,
  MSG_ID_MRxDavFsdDispatch_1 = 2
}; 

#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)

extern WML_CONTROL_GUID_REG MRxDav_ControlGuids[];

extern BOOLEAN DavEnableWmiLog;

#endif // _DAVWMIK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\devfcb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all ioctls and fsctls that can be applied to
    a device fcb.

Author:

    Joe Linn
    
    Rohan Kumar    [RohanK]   13-March-1999
    
--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVOuterStart(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVOuterStop(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVDeleteConnection(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS      
MRxDavDeleteConnection(
    IN OUT PRX_CONTEXT RxContext
    );      



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVDevFcbXXXControlFile)
#pragma alloc_text(PAGE, MRxDAVOuterStart)
#pragma alloc_text(PAGE, MRxDAVStart)
#pragma alloc_text(PAGE, MRxDAVOuterStop)
#pragma alloc_text(PAGE, MRxDAVStop)
#pragma alloc_text(PAGE, MRxDAVDeleteConnection)
#pragma alloc_text(PAGE, MRxDAVFastIoDeviceControl)
#pragma alloc_text(PAGE, MRxDAVFormatTheDAVContext)
#pragma alloc_text(PAGE, MRxDavDeleteConnection)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVDevFcbXXXControlFile(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS - The Startup sequence was successfully completed. Any other 
                     value indicates the appropriate error in the startup 
                     sequence.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    UCHAR MinorFunctionCode = LowIoContext->ParamsFor.FsCtl.MinorFunction;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;
    LUID LocalServiceLogonID = LOCALSERVICE_LUID, ClientLogonID;
    LUID SystemLogonID = SYSTEM_LUID;
    BOOLEAN IsInLocalServiceProcess = FALSE, IsInSystemProcess = FALSE;
    SECURITY_SUBJECT_CONTEXT ClientContext;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDevFcbXXXControlFile!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDevFcbXXXControlFile: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: MajorFunctionCode = %d.\n",
                 PsGetCurrentThreadId(), MajorFunctionCode));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: MinorFunctionCode = %d.\n",
                 PsGetCurrentThreadId(), MinorFunctionCode));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: ControlCode = %d.\n",
                 PsGetCurrentThreadId(), ControlCode));
    
    SeCaptureSubjectContext( &(ClientContext) );
    SeLockSubjectContext( &(ClientContext) );
    
    NtStatus = SeQueryAuthenticationIdToken(SeQuerySubjectContextToken(&(ClientContext)),
                                            &(ClientLogonID));
    if (NtStatus == STATUS_SUCCESS) {
        IsInLocalServiceProcess = RtlEqualLuid( &(ClientLogonID), &(LocalServiceLogonID) );
        IsInSystemProcess = RtlEqualLuid( &(ClientLogonID), &(SystemLogonID) );
    } else {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDevFcbXXXControlFile/SeQueryAuthenticationIdToken: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
    }

    SeUnlockSubjectContext( &(ClientContext) );
    SeReleaseSubjectContext( &(ClientContext) );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: IsInLocalServiceProcess = %d, IsInSystemProcess = %d\n",
                 PsGetCurrentThreadId(), IsInLocalServiceProcess, IsInSystemProcess));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: ClientLogonID.HighPart = %x, ClientLogonID.LowPart = %x\n",
                 PsGetCurrentThreadId(), ClientLogonID.HighPart, ClientLogonID.LowPart));

    switch (MajorFunctionCode) {
    
    case IRP_MJ_FILE_SYSTEM_CONTROL: {
        
        switch (MinorFunctionCode) {
        
        case IRP_MN_USER_FS_REQUEST: {
            
            switch (ControlCode) {
            
            case FSCTL_UMRX_START:
                if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                                 PsGetCurrentThreadId()));
                    NtStatus = STATUS_ACCESS_DENIED;
                    goto EXIT_THE_FUNCTION;
                }
                ASSERT (!capFobx);
                NtStatus = MRxDAVOuterStart(RxContext);
                break;
            
            case FSCTL_UMRX_STOP:
                if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(2)\n",
                                 PsGetCurrentThreadId()));
                    NtStatus = STATUS_ACCESS_DENIED;
                    goto EXIT_THE_FUNCTION;
                }
                ASSERT (!capFobx);
                if (RxContext->RxDeviceObject->NumberOfActiveFcbs > 0) {
                    return STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
                } else {
                    NtStatus = MRxDAVOuterStop(RxContext);
                }
                break;

            case FSCTL_DAV_DELETE_CONNECTION:
                NtStatus = MRxDavDeleteConnection(RxContext);
                break;
            
            default:
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                             "ControlCode = %d\n",
                             PsGetCurrentThreadId(), ControlCode));
                NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;
            
            }

        }
        break;
        
        default :
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                         "MinorFunction = %d\n",
                         PsGetCurrentThreadId(), MinorFunctionCode));
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        
        }
    
    }
    break;
    
    default:
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                     "MajorFunction = %d\n",
                     PsGetCurrentThreadId(), MajorFunctionCode));
        NtStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDevFcbXXXControlFile with NtStatus = "
                 "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    //
    // This suppresses the second call to my lowio Fsctl routine.
    //
    RxContext->pFobx = NULL;
    
    return(NtStatus);
}


NTSTATUS
MRxDAVOuterStart(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine starts the Mini-Redir if it hasn't been started already.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS or the appropriate error code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    PDAV_USERMODE_DATA DavUserModeData = NULL;
    ULONG DavUserModeDataLength = 0;
    
    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVOuterStart!!!!\n", 
                 PsGetCurrentThreadId()));
    
    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVOuterStart: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVOuterStart: Try to Start the Mini-Redir\n",
                 PsGetCurrentThreadId()));

    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);

    LowIoContext= &(RxContext->LowIoContext);

    //
    // The WinInet cache path and the process id are stored in the input buffer 
    // of the FSCTL.
    //
    DavUserModeData = (PDAV_USERMODE_DATA)LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ASSERT(DavUserModeData != NULL);
    DavUserModeDataLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;
    ASSERT(DavUserModeDataLength == sizeof(DAV_USERMODE_DATA));

    //
    // Set the DeviceFcb, now that we have an RxContext.
    //
    DavDeviceObject->CachedRxDeviceFcb = RxContext->pFcb;
    
    //
    // We call ExAcquireFastMutexUnsafe instead of ExAcquireFastMutex because the
    // APCs have already been disabled by the FsrtlEnterFileSystem() call in the
    // RxFsdCommonDispatch function. This is done because a ExAcquireFastMutex
    // raises the IRQL level to APC_LEVEL (1) which is wrong since we are calling
    // into RxStartMiniRedir which calls FsrtlRegisterUncProvider which lands 
    // up calling into the Dav MiniRedir again. If the IRQL level is raised here,
    // the MiniRedir will get called at a raised IRQL which is wrong.
    //
    ExAcquireFastMutexUnsafe( &(MRxDAVSerializationMutex) );
    
    try {

        if (DavDeviceObject->IsStarted) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: Mini-Redir already started.\n",
                         PsGetCurrentThreadId()));
            try_return(NtStatus = STATUS_REDIRECTOR_STARTED);
        }
        
        NtStatus = RxStartMinirdr(RxContext, &RxContext->PostRequest);
        
        if (NtStatus == STATUS_SUCCESS) {
            
            DavDeviceObject->IsStarted = TRUE;
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: Mini-Redir started.\n",
                         PsGetCurrentThreadId()));
            
            //
            // Copy the DavWinInetCachePath value into the global variable. This
            // value is used to satisy the volume relalted queries.
            //
            wcscpy(DavWinInetCachePath, DavUserModeData->WinInetCachePath);
            
            //
            // Copy the ProcessId of the svchost.exe process that loads the
            // webclnt.dll.
            //
            DavSvcHostProcessId = DavUserModeData->ProcessId;
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: DavWinInetCachePath = %ws, DavSvcHostProcessId = %x\n",
                         PsGetCurrentThreadId(), DavWinInetCachePath, DavSvcHostProcessId));

            //
            // Start the timer thread. This thread wakes up every few minutes
            // (RequestTimeoutValueInSec) and cancels all the requests that 
            // have not completed for more than RequestTimeoutValueInSec.
            //
            NtStatus = PsCreateSystemThread(&(TimerThreadHandle),
                                            PROCESS_ALL_ACCESS,
                                            NULL,
                                            NULL,
                                            NULL,
                                            MRxDAVContextTimerThread,
                                            NULL);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVOuterStart/PsCreateSystemThread: NtStatus"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            }

        } else {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStart/RxStartMinirdr: NtStatus"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            
            try_return(NtStatus);
        
        }
        
        try_exit: NOTHING;

    } finally {

        //
        // Since we called ExAcquireFastMutexUnsafe to acquire this mutex, we 
        // call ExReleaseFastMutexUnsafe to release it.
        //
        ExReleaseFastMutexUnsafe( &(MRxDAVSerializationMutex) );

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVOuterStart with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    return NtStatus;
}


NTSTATUS
MRxDAVOuterStop(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine stops the Mini-Redir if it has been started.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS or the appropriate error code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;
    PVOID HeapHandle = NULL;
    PLIST_ENTRY pFirstListEntry = NULL;
    PUMRX_SHARED_HEAP sharedHeap = NULL;
    BOOLEAN TimerState = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVOuterStop!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVOuterStop: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVOuterStop: Try to Stop the Mini-Redir.\n",
                 PsGetCurrentThreadId()));

    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    
    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);

    //
    // Tell the timer thread that its time to shutdown to its job is done.
    //
    ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);

    if (!TimerThreadShutDown) {

        TimerThreadShutDown = TRUE;

        //
        // Read the state of the timer. If its NOT signalled, call KeSetTimerEx
        // with 0 DueTime (2nd argument) to signal it.
        //
        TimerState = KeReadStateTimer( &(DavTimerObject) );
        if (!TimerState) {
            LARGE_INTEGER TimeOutNow;
            TimeOutNow.QuadPart = 0;
            KeSetTimerEx(&(DavTimerObject), TimeOutNow, 0, NULL);
        }

        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));

        //
        // Complete all the currently active contexts.
        //
        MRxDAVTimeOutTheContexts(TRUE);

    } else {

        //
        // If we have already shutdown the timer thread, then we don't need to
        // do it again. Just release the resource and move on.
        //
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));

    }

    //
    // Free the list of shared memory heaps. This has to happen in the context
    // of the DAV's usermode process. It cannot happen at Unload time since
    // unload happens in the context of a system thread.
    //
    while (!IsListEmpty(&UMRefDeviceObject->SharedHeapList)) {

        pFirstListEntry = RemoveHeadList(&UMRefDeviceObject->SharedHeapList);

        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(pFirstListEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVOuterStop: sharedHeap: %08lx.\n",
                     PsGetCurrentThreadId(), sharedHeap));

        // ASSERT(sharedHeap->HeapAllocationCount == 0);

        HeapHandle = RtlDestroyHeap(sharedHeap->Heap);
        if (HeapHandle != NULL) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStop/RtlDestroyHeap.\n",
                         PsGetCurrentThreadId()));
        }

        ZwFreeVirtualMemory(NtCurrentProcess(),
                            &sharedHeap->VirtualMemoryBuffer,
                            &sharedHeap->VirtualMemoryLength,
                            MEM_RELEASE);

        RxFreePool(sharedHeap);
    
    }

    //
    // We call ExAcquireFastMutexUnsafe instead of ExAcquireFastMutex because the
    // APCs have already been disabled by the FsrtlEnterFileSystem() call in the
    // RxFsdCommonDispatch function. This is done because a ExAcquireFastMutex
    // raises the IRQL level to APC_LEVEL (1) which is wrong since we are calling
    // into RxStartMiniRedir which calls FsrtlRegisterUncProvider which lands 
    // up calling into the Dav MiniRedir again. If the IRQL level is raised here,
    // the MiniRedir will get called at a raised IRQL which is wrong.
    //
    ExAcquireFastMutexUnsafe(&MRxDAVSerializationMutex);
    try {
        if (!DavDeviceObject->IsStarted) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStop: Mini-Redir not started.\n",
                         PsGetCurrentThreadId()));
            try_return(NtStatus = STATUS_REDIRECTOR_NOT_STARTED);
        }
        NtStatus = RxStopMinirdr(RxContext, &RxContext->PostRequest);
        if (NtStatus == STATUS_SUCCESS) {
            DavDeviceObject->IsStarted = FALSE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStop: Mini-Redir stopped.\n",
                         PsGetCurrentThreadId()));
        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStop/RxStopMinirdr: NtStatus"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }
    try_exit: NOTHING;
    } finally {
        //
        // Since we called ExAcquireFastMutexUnsafe to acquire this mutex, we 
        // call ExReleaseFastMutexUnsafe to release it.
        //
        ExReleaseFastMutexUnsafe(&MRxDAVSerializationMutex);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVOuterStop with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    return NtStatus;
}


NTSTATUS
MRxDAVDeleteConnection(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    RxCaptureFobx;
    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PNET_ROOT NetRoot;
    PV_NET_ROOT VNetRoot;

    PAGED_CODE();

    if (!Wait) {
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    try {
        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
            NetRoot = (PNET_ROOT)capFobx;
            VNetRoot = NULL;
        }

        Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);

        try_return(Status);

try_exit:NOTHING;
    } finally {
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}


BOOLEAN
MRxDAVFastIoDeviceControl(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine handles the Fast I/O path of the WebDav miniredir.

Arguments:

    FileObject - The file object of the file involved in the I/O request.

    Wait -

    InputBuffer - Buffer which holds the inputs for the I/O request.

    InputBufferLength - Length of the InputBuffer.

    OutputBuffer - Where the results of the I/O request are placed.

    OutputBufferLength - Length of the OutputBuffer.

    IoControlCode - The controlcode describing the I/O to be done.

    IoStatus - The results of the assignment.

    DeviceObject - The device object which handles the I/O request.

Return Value:

    TRUE - The I/O operation was handled and FALSE otherwise.

--*/
{
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)DeviceObject;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)DeviceObject;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFastIoDeviceControl.\n",
                 PsGetCurrentThreadId()));

    if (FileObject->FsContext != DavDeviceObject->CachedRxDeviceFcb) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFastIoDeviceControl: Wrong DeviceFcb!!\n",
                     PsGetCurrentThreadId()));
        return FALSE;
    }

    //
    // It's the right kind of fileobject. Go for it.
    //
    switch (IoControlCode) {
    case IOCTL_UMRX_RELEASE_THREADS:
            UMRxReleaseCapturedThreads(UMRefDeviceObject);
            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = 0;
            return (TRUE);

    case IOCTL_UMRX_GET_REQUEST:
    case IOCTL_UMRX_RESPONSE_AND_REQUEST:
    case IOCTL_UMRX_RESPONSE:
            UMRxAssignWork(UMRefDeviceObject,
                           InputBuffer,
                           InputBufferLength,
                           OutputBuffer,
                           OutputBufferLength,
                           IoStatus);
            return(TRUE);

    default:
            break;
    }

    //
    // The I/O operation could not be handled.
    //
    return(FALSE);
}


NTSTATUS
MRxDAVFormatTheDAVContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT EntryPoint
    )
/*++

Routine Description:

    This routine formats the DAV Mini-Redir portion of the context.

Arguments:

    AsyncEngineContext  - The Reflector's context.
    
    EntryPoint - The operation being performed.
    
Return Value:

    none.
    
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PNT_CREATE_PARAMETERS NtCP = &(RxContext->Create.NtCreateParameters);
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecClnCtx = NULL;
    BOOL AlreadyInitialized = FALSE, SecurityClientContextCreated = FALSE;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSECURITY_SUBJECT_CONTEXT SecSubCtx = NULL;
    PSECURITY_QUALITY_OF_SERVICE SecQOS = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatTheDAVContext!!!!\n",
                PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatTheDAVContext: AsyncEngineContext: %08lx, "
                 "EntryPoint: %d.\n", PsGetCurrentThreadId(), 
                 AsyncEngineContext, EntryPoint));


    ASSERT(DavContext != NULL);
    ASSERT(RxContext != NULL);

    //
    // Set the EntryPoint field. If this is not a Create operation, we can 
    // return.
    //
    DavContext->EntryPoint = EntryPoint;
    if (EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL &&
        EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT) {
        return NtStatus;
    }

    //
    // Since this is a create call, get the client's security context. This is 
    // used to impersonate the client before sending the requests to the server.
    //
    
    if ( NtCP->SecurityContext != NULL && 
         NtCP->SecurityContext->AccessState != NULL ) {
        
        //
        // Check whether its a CreateSrvCall call or a CreateVNetRoot call.
        //
        if ( EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL ) {
            
            //
            // This is s CreateVNetRoot call.
            //
            ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT);
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. CreateVNetRoot.\n",
                         PsGetCurrentThreadId()));

            //
            // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
            // RxContext structure. This is done in the MRxDAVCreateVNetRoot function.
            //
            VNetRoot = RxContext->MRxContext[1];
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. VNetRoot = %08lx\n",
                         PsGetCurrentThreadId(), VNetRoot));
            
            //
            // The context pointer of the V_NET_ROOT already points to a blob of
            // memory, the size of which is sizeof(WEBDAV_V_NET_ROOT). This 
            // should never be NULL.
            //
            DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
            if(DavVNetRoot == NULL) {
                ASSERT(FALSE);
                goto EXIT_THE_FUNCTION;
            }

            SecClnCtx = &(DavVNetRoot->SecurityClientContext);

            //
            // Only need to initialize on the first create call by the user.
            //
            if (DavVNetRoot->SCAlreadyInitialized) {
                AlreadyInitialized = TRUE;
            }
        
        } else {
            
            //
            // This is a CreateSrvCall call.
            //
            ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL);

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. CreateSrvCall.\n",
                         PsGetCurrentThreadId()));

            //
            // The SrvCall pointer is stored in the SCCBC structure which is
            // stored in the MRxContext[1] pointer of the RxContext structure.
            // This is done in the MRxDAVCreateSrvCall function.
            //
            ASSERT(RxContext->MRxContext[1] != NULL);
            SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
            
            SrvCall = SCCBC->SrvCalldownStructure->SrvCall;
            ASSERT(SrvCall != NULL);

            DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
            ASSERT(DavSrvCall != NULL);
            
            //
            // At this time, we don't have a V_NET_ROOT and hence cannot store 
            // the SecurityClientContext. We just use MRxContext[2] of RxContext
            // to pass the SecurityClientContext.
            //
            SecClnCtx = RxAllocatePoolWithTag(NonPagedPool,
                                              sizeof(SECURITY_CLIENT_CONTEXT),
                                              DAV_SRVCALL_POOLTAG);
            if (SecClnCtx == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVFormatTheDAVContext/RxAllocatePoolWithTag.\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            ASSERT(RxContext->MRxContext[2] == NULL);
            RxContext->MRxContext[2] = (PVOID)SecClnCtx;
        
        }
        
        if (!AlreadyInitialized) {

            SecSubCtx = &(NtCP->SecurityContext->AccessState->SubjectSecurityContext);
            
            SecQOS = ( (NtCP->SecurityContext->SecurityQos) ? 
                       (NtCP->SecurityContext->SecurityQos) : &(SecurityQos) );

            //
            // If the user did not specify the security QOS structure, create 
            // one. We set the value of SecurityQos.EffectiveOnly to FALSE
            // to keep the privilege so that we can do certain operations
            // later on. This is specifically needed for the EFS operations.
            // If set to TRUE, any privilege not enabled at this time will be
            // lost. In the EFS case, the "restore" privilege is lost.
            //
            if (NtCP->SecurityContext->SecurityQos == NULL) {
                SecurityQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
                SecurityQos.ImpersonationLevel = DEFAULT_IMPERSONATION_LEVEL;
                SecurityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQos.EffectiveOnly = FALSE;
            }

            //
            // This call sets the SecurityClientContext of the user. This is 
            // stored in the V_NET_ROOT since its a per user thing. This 
            // strucutre is used later on in impersonating the client that 
            // issued the I/O request.
            //
            NtStatus = SeCreateClientSecurityFromSubjectContext(SecSubCtx,
                                                                SecQOS,
                                                                // Srv Remote ?
                                                                FALSE, 
                                                                SecClnCtx);
            //
            // If unsuccessful, return NULL.
            //
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVFormatTheDAVContext/"
                             "SeCreateClientSecurityFromSubjectContext. Error "
                             "Val = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            SecurityClientContextCreated = TRUE;

            //
            // If this was a create call, set the bool in the DavVNetRoot to 
            // indicate that the SecurityClientContext has been initialized.
            //
            if (EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT) {
                DavVNetRoot->SCAlreadyInitialized = TRUE;
            } else{
                ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL);
                DavSrvCall->SCAlreadyInitialized = TRUE;
            }
        
        }
    
    } else {
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatTheDAVContext. Could not get SecClnCtx."
                     "EntryPoint = %d.\n", PsGetCurrentThreadId(), EntryPoint));
    
    }

EXIT_THE_FUNCTION:

    if (NtStatus != STATUS_SUCCESS) {
        if (EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL && SecClnCtx != NULL) {
            if (SecurityClientContextCreated) {
                SeDeleteClientSecurity(SecClnCtx);
                DavSrvCall->SCAlreadyInitialized = FALSE;
            }
            RxFreePool(SecClnCtx);
            RxContext->MRxContext[2] = NULL;
        }
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Leaving MRxDAVFormatTheDAVContext with NtStatus = %08lx.\n",
                PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDavDeleteConnection(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine deletes a VNetroot. The result depends on the forcelevel. If called
   with maximum force, this will delete all connections and orphan the fileobjects
   working on files for this VNetRoot.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;
    
    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG Level;

    PMRX_V_NET_ROOT VNetRoot;
    PMRX_NET_ROOT NetRoot;

    PAGED_CODE();

#if 0
    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }
#endif

    try {

        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PMRX_V_NET_ROOT)capFobx;
            NetRoot = (PMRX_NET_ROOT)VNetRoot->pNetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
        }

        if (InputBufferLength < sizeof(DWORD)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        Level = *((DWORD *)InputBuffer);
        
        if (Level <= USE_LOTS_OF_FORCE) {
            if (VNetRoot != NULL && Level == USE_LOTS_OF_FORCE) {
            }
            
            Status = RxFinalizeConnection(
                         (PNET_ROOT)NetRoot,
                         (PV_NET_ROOT)VNetRoot,
                         (BOOLEAN)(Level == USE_LOTS_OF_FORCE));
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {

#if 0
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fcbfobx.c ===
/*++ 

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fcbfobx.c

Abstract:

    This code manages the finalizing of the FCB and FOBX strucutres of the 
    DAV Mini-Redir.

Author:

    Rohan Kumar        [RohanK]       26-Sept-1999

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVDeallocateForFobxContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeFobxFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeFobxFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

VOID
DavLogDelayedWriteError(
    PUNICODE_STRING PathName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVDeallocateForFobx)
#pragma alloc_text(PAGE, MRxDAVDeallocateForFobxContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeFobxFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeFobxFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVCleanupFobx)
#pragma alloc_text(PAGE, MRxDAVDeallocateForFcb)
#pragma alloc_text(PAGE, DavLogDelayedWriteError)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVDeallocateForFobx(
    IN OUT PMRX_FOBX pFobx
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FOBX.

Arguments:

    pFobx - the Fobx being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_FOBX DavFobx = NULL;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRV_CALL SrvCall;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PUNICODE_STRING RemainingName = NULL;

    PAGED_CODE();

    SrvCall = (PMRX_SRV_CALL)pFobx->pSrvOpen->pFcb->pNetRoot->pSrvCall;
    ASSERT(SrvCall);
    RxDeviceObject = SrvCall->RxDeviceObject;

    DavFobx = MRxDAVGetFobxExtension(pFobx);
    ASSERT(DavFobx != NULL);

    RemainingName = pFobx->pSrvOpen->pAlreadyPrefixedName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFobx. RemainingName = %wZ.\n",
                  PsGetCurrentThreadId(), RemainingName));

    //
    // If this FOBX does not have a list of DavFileAttributes, we are done.
    //
    if (DavFobx->DavFileAttributes == NULL) {
        return NtStatus;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDeallocateForFobx. DavFileAttributes = %08lx.\n", 
                 PsGetCurrentThreadId(), DavFobx->DavFileAttributes));
    
    //
    // We need to finalize the list of DavFileAttributes.
    //

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVDeallocateForFobx/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to send the Fobx to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pFobx;
    
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX,
                                        MRxDAVDeallocateForFobxContinuation,
                                        "MRxDAVDeallocateForFobx");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVDeallocateForFobx/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDeallocateForFobx with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


NTSTATUS
MRxDAVDeallocateForFobxContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which finalizes an Fobx.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFobxContinuation.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDeallocateForFobxContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeFobxFinalizeRequest,
                              MRxDAVPrecompleteUserModeFobxFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCallContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeFobxFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the Fobx finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_FOBX_REQUEST FinFobxReq = NULL;
    PMRX_FOBX Fobx = NULL;
    PWEBDAV_FOBX DavFobx = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeFobxFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // We dont impersonate the user before going up to the user mode since
    // all we do in the user mode is free memory and the users credentials are 
    // not needed to do this.
    //

    //
    // Fobx was set to MRxContext[1] in MRxDAVDeallocateForFobx. We need it to
    // get the pointer to the DavFileAttributes list.
    //
    Fobx = (PMRX_FOBX)RxContext->MRxContext[1];
    DavFobx = MRxDAVGetFobxExtension(Fobx);
    ASSERT(DavFobx != NULL);
    ASSERT(DavFobx->DavFileAttributes != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeFobxFinalizeRequest. DavFileAttributes = %08lx.\n", 
                 PsGetCurrentThreadId(), DavFobx->DavFileAttributes));
    
    DavWorkItem->WorkItemType = UserModeFinalizeFobx;

    FinFobxReq = &(DavWorkItem->FinalizeFobxRequest);

    FinFobxReq->DavFileAttributes = DavFobx->DavFileAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL,
            ("%ld: Leaving MRxDAVFormatUserModeFobxFinalizeRequest "
             "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeFobxFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize Fobx request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A FinalizeFobx request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the CloseSrvOpen case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    NtStatus = AsyncEngineContext->Status;

    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: "
                     "Finalize Fobx failed in user mode.\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}


NTSTATUS
MRxDAVCleanupFobx(
      IN PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine cleansup a file system object. Normally a no op.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb);
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCleanupFobx: RemainingName: %wZ\n", 
                 PsGetCurrentThreadId(), RemainingName));
    
    IF_DEBUG {
        RxCaptureFobx;
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  
    }
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );
    ASSERT (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT));
    

    //
    // Because we only have one handle on the file, we do nothing for each
    // individual handle being closed. In this way we avoid doing paging ios.
    // We close the handle when the final close for the fcb comes down.
    //
    
    return(Status);
}

NTSTATUS
MRxDAVDeallocateForFcb(
    IN OUT PMRX_FCB pFcb
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FCB.

Arguments:

    pFcb - the Fcb being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_FCB DavFcb = (PWEBDAV_FCB)(pFcb->Context);
    PWCHAR NtFileName = NULL;
    
    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFcb: FileName: %ws\n",
                 PsGetCurrentThreadId(), DavFcb->FileName));

    //
    // If we allocated the FCB resource to synchronize the "read-modify-write"
    // sequence, we need to uninitialize and deallocate it now.
    //
    if (DavFcb->DavReadModifyWriteLock) {
        ExDeleteResourceLite(DavFcb->DavReadModifyWriteLock);
        RxFreePool(DavFcb->DavReadModifyWriteLock);
        DavFcb->DavReadModifyWriteLock = NULL;
    }

    //
    // If the value of DavFcb->FileWasModified is TRUE, it means that some write
    // never made it to the server. This is a delayed write failure in WebDav.
    // We need to notify this to the user. Hence we log an entry in the EventLog
    // and call IoRaiseInformationalHardError to inform the user.
    //
    if (DavFcb->FileWasModified) {

        BOOLEAN RaiseHardError = FALSE;

        ASSERT(DavFcb->FileNameInfo.Buffer != NULL);

        //
        // Log that the write failed in the event log.
        //
        DavLogDelayedWriteError( &(DavFcb->FileNameInfo) );

        RaiseHardError = IoRaiseInformationalHardError(STATUS_LOST_WRITEBEHIND_DATA,
                                                       &(DavFcb->FileNameInfo),
                                                       NULL);
        if (!RaiseHardError) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDeallocateForFcb/IoRaiseInformationalHardError",
                         PsGetCurrentThreadId()));
        }

    }

    //
    // If we allocated any memory for the FileNameInfo, we need to free it now.
    //
    if (DavFcb->FileNameInfo.Buffer) {
        ASSERT(DavFcb->FileNameInfoAllocated == TRUE);
        RxFreePool(DavFcb->FileNameInfo.Buffer);
        DavFcb->FileNameInfo.Buffer = NULL;
        DavFcb->FileNameInfo.Length = 0;
        DavFcb->FileNameInfo.MaximumLength = 0;
        DavFcb->FileNameInfoAllocated = FALSE;
    }

    //
    // Delete the EFS file cache at the end of the Fcb lifetime. If the file is
    // opened again, the EFS file cache will be restored from the WinInet cache
    // in backup formate. This way, WinInet does not involved in delete the EFS
    // file cache which will be denied in the context of LocalService.
    //
    if (DavFcb->LocalFileIsEncrypted) {
        NTSTATUS LocalNtStatus = STATUS_SUCCESS;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeFileName;
        ULONG SizeInBytes = 0;
        
        SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
        
        NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
        
        if (NtFileName == NULL) {
            //
            // cannot do much, bailout
            //
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVDeallocateForFcb/RxAllocatePoolWithTag failed", PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(NtFileName, SizeInBytes);

        wcscpy( NtFileName, L"\\??\\" );
        wcscpy( &(NtFileName[4]), DavFcb->FileName );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVDeallocateForFcb: NtFileName = %ws\n",
                     PsGetCurrentThreadId(), NtFileName));

        RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

        InitializeObjectAttributes( &ObjectAttributes,
                            &UnicodeFileName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

        LocalNtStatus = ZwDeleteFile( &(ObjectAttributes) );
        
        if (!NT_SUCCESS(LocalNtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDeallocateForFcb/ZwDeleteFile"
                         ". NtStatus = %08lx %ws \n", PsGetCurrentThreadId(), LocalNtStatus,DavFcb->FileName));
        }
    }

EXIT_THE_FUNCTION:
    
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

    RtlZeroMemory(DavFcb, sizeof(WEBDAV_FCB));
    
    return(NtStatus);
}


VOID
DavLogDelayedWriteError(
    PUNICODE_STRING PathName
    )
/*++

Routine Description:

   This routine logs a delayed write error to the event log.

Arguments:

    PathName - The PathName for which the delayed write failed.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT RemainingLength = 0;
    UNICODE_STRING ErrorLog[1];
    
    PAGED_CODE();

    RemainingLength = ERROR_LOG_MAXIMUM_SIZE;
    RemainingLength -= sizeof(IO_ERROR_LOG_PACKET);
    RemainingLength -=  sizeof(UNICODE_NULL);

    //
    // If the length of the PathName is less than the RemainingLength, then we
    // print the entire path, otherwise we print the max amount allowed. This is
    // because the length of the error log message is limited by the
    // ERROR_LOG_MAXIMUM_SIZE.
    //
    if (PathName->Length > RemainingLength) {
        ErrorLog[0].Length = RemainingLength;
    } else {
        ErrorLog[0].Length = PathName->Length;
    }

    ErrorLog[0].MaximumLength = ErrorLog[0].Length;
    ErrorLog[0].Buffer = PathName->Buffer;

    RxLogEventWithAnnotation((PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject,
                             EVENT_DAV_REDIR_DELAYED_WRITE_FAILED,
                             STATUS_LOST_WRITEBEHIND_DATA,
                             NULL,
                             0,
                             ErrorLog,
                             1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\chngnote.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    chngnote.c

Abstract:

    This module will someday implement change notify. currently it just returns
    not_implemented. when we have async upcalls, we will revisit this.

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
//  The local debug trace level
//


//BUGBUG we need to implement change directory........
typedef struct _UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT_ {
   PRX_CONTEXT                         pRxContext;
   //REQ_NOTIFY_CHANGE                   NotifyRequest;
} UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT, *PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT;

VOID
UMRxNotifyChangeDirectoryCompletion(
   PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is completed

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine will always be called. This is true even if the change directory
    notification is cancelled. In such cases the memory allocated is freed without
    any inteaction with the wrapped. In cases os successful directory change
    notification completion the appropriate completion routine is invoked and the
    RxContext modified to prevent any cancellation from proceeding further.

--*/
{
    NTSTATUS           Status;
    PRX_CONTEXT        pRxContext;
    PUMRX_RX_CONTEXT pUMRxContext;

    MRxDAVAcquireGlobalSpinLock();

    pRxContext     = pNotificationContext->pRxContext;

    if (pRxContext != NULL) {
        // This is a case of successful completion of the change directory
        // notification, i.e., the request was not cancelled. In such cases
        // prevent all race conditions by modifying the RxContext under lock
        // to turn back cancellation request.

        pUMRxContext = UMRxGetMinirdrContext(pRxContext);

        pUMRxContext->pCancelContext   = NULL;
        pNotificationContext->pRxContext = NULL;
    }

    MRxDAVReleaseGlobalSpinLock();

    // Complete the Context if it was not previously cancelled
    if (pRxContext != NULL) {
        //pResumptionContext  = &(pNotificationContext->ResumptionContext);
        //pRxContext->StoredStatus = pResumptionContext->FinalStatusFromServer;

        Status = RxSetMinirdrCancelRoutine(pRxContext,NULL);
        if (Status == STATUS_SUCCESS) {
            RxLowIoCompletion(pRxContext);
        }
    }

#if 0
    // Free the associated exchange.
    if (pExchange != NULL) {
        UMRxCeDereferenceAndDiscardExchange(pExchange);
    }
#endif //0

    // Free the notification context.
    RxFreePool(pNotificationContext);
}

NTSTATUS
UMRxNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is cancelled.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    //NTSTATUS Status;

    BOOLEAN ChangeDirectoryNotificationCompleted;

    PUMRX_RX_CONTEXT pUMRxContext = UMRxGetMinirdrContext(RxContext);

    PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

    MRxDAVAcquireGlobalSpinLock();

    pNotificationContext = (PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT)pUMRxContext->pCancelContext;
    ChangeDirectoryNotificationCompleted = (pNotificationContext == NULL);

    if (!ChangeDirectoryNotificationCompleted) {
        // This is a case of successful cancellation of the change directory
        // notification. In such cases prevent all race conditions by modifying
        // the RxContext under lock to prevent successful completion

        pNotificationContext->pRxContext = NULL;
        pUMRxContext->pCancelContext   = NULL;
    }

    MRxDAVReleaseGlobalSpinLock();

    if (ChangeDirectoryNotificationCompleted) {
        // The cancellation is trivial since the request has already been completed
        return STATUS_SUCCESS;
    }

    // Complete the request.
    RxContext->StoredStatus = STATUS_CANCELLED;

    RxLowIoCompletion(RxContext);

    return STATUS_SUCCESS;
}

NTSTATUS
UMRxNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

BUGBUG THIS STUFF IS WRONG!!!!! It refers to the smbmini implementation.
i am leaving most stuff in to guide the implementation for the reflector.


    A directory change notification opertaion is an asychronous operation. It
    consists of sending a change notification whose response is
    obtained when the desired change is affected on the server.

    Some important points to remember are as follows .....

      1) The response is not obtained till the desired change is affected on
      the server. Therefore an additional MID needs to be reserved on those
      connections which permit multiple MID's so that a cancel can be sent to
      the server when a change notification is active.

      2) The Change notification is typical of a long term ( response time
      dictated by factors beyond the servers control). Another example is
      the query FSCTL operation in CAIRO. For all these operations we initiate
      an asychronous transact exchange.

      3) The corresponding LowIo completion routine is invoked asynchronously.

      4) This is an example of an operation for which the MINI RDR has to
      register a context for handling cancellations initiated locally.

--*/
{
   NTSTATUS Status;
   RxCaptureFcb;
   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

   //PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

#if 0
   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;
#endif //0

   // RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

#if 0
   pNotificationContext =
         (PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT)
         RxAllocatePoolWithTag(
            NonPagedPool,
            sizeof(UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT),
            DAV_FSCTL_POOLTAG);

   if (pNotificationContext != NULL) {
      PREQ_NOTIFY_CHANGE                  pNotifyRequest;
      PUMRX_SRV_OPEN                   pUMRxSrvOpen;

      IF_DEBUG {
          RxCaptureFobx;
          ASSERT (capFobx != NULL);
          ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  //ok
      }

      Status = UMRxDeferredCreate(RxContext);

      if (Status==STATUS_SUCCESS) {

          pUMRxSrvOpen = UMRxGetSrvOpenExtension(RxContext->pRelevantSrvOpen);

          pNotificationContext->pRxContext = RxContext;

          pNotifyRequest      = &(pNotificationContext->NotifyRequest);
          pTransactionOptions = &(pNotificationContext->Options);
          pResumptionContext  = &(pNotificationContext->ResumptionContext);

          pNotifyRequest->CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
          pNotifyRequest->Fid              = pUMRxSrvOpen->Fid;
          pNotifyRequest->WatchTree        = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;
          pNotifyRequest->Reserved         = 0;

          OutputDataBufferLength  = pLowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength;
          pOutputDataBuffer       = pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer;

          *pTransactionOptions = RxDefaultTransactionOptions;
          pTransactionOptions->NtTransactFunction = NT_TRANSACT_NOTIFY_CHANGE;
          pTransactionOptions->TimeoutIntervalInMilliSeconds = SMBCE_TRANSACTION_TIMEOUT_NOT_USED;
          pTransactionOptions->Flags = SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE;

          UMRxCeInitializeAsynchronousTransactionResumptionContext(
                pResumptionContext,UMRxNotifyChangeDirectoryCompletion,pNotificationContext);

          Status = UMRxCeAsynchronousTransact(
                         RxContext,                    // the RXContext for the transaction
                         pTransactionOptions,          // transaction options
                         pNotifyRequest,               // the setup buffer
                         sizeof(REQ_NOTIFY_CHANGE),    // setup buffer length
                         pInputParamBuffer,            // Input Param Buffer
                         InputParamBufferLength,       // Input param buffer length
                         pOutputParamBuffer,           // Output param buffer
                         OutputParamBufferLength,      // output param buffer length
                         pInputDataBuffer,             // Input data buffer
                         InputDataBufferLength,        // Input data buffer length
                         pOutputDataBuffer,            // output data buffer
                         OutputDataBufferLength,       // output data buffer length
                         pResumptionContext            // the resumption context
                         );

          if (Status == STATUS_PENDING) {
             PUMRX_RX_CONTEXT pUMRxContext;

             pUMRxContext = UMRxGetMinirdrContext(RxContext);
             pUMRxContext->pCancelContext = pNotificationContext;

             // Ensure that the appropriate cancel routine is set because this is a long term
             // operation and the cancelling mechanism needs to be in place.

             Status = RxSetMinirdrCancelRoutine(RxContext,UMRxNotifyChangeDirectoryCancellation);
             if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
             } else if (Status == STATUS_CANCELLED) {
                UMRxNotifyChangeDirectoryCancellation(RxContext);
                Status = STATUS_PENDING;
             }
          } else {
             // On exit from this routine the request would have been completed in all
             // the cases. The asynchronous case and synchronous case are folded into
             // one async response by returning STATUS_PENDING.

             Status = STATUS_PENDING;
          }
      }  else {
          NOTHING; //just return the status from the deferred open call
      }
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }
#endif //0

   Status = STATUS_NOT_SUPPORTED;

   // RxDbgTrace(-1, Dbg, ("UMRxNotifyChangeDirectory -> %08lx\n", Status ));
   return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\ea.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the DAV Mini-Redir call down routines pertaining to
    query/set ea/security.

Author:

    Shishir Pardikar [ShishirP] 04/24/2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryEaInformation)
#pragma alloc_text(PAGE, MRxDAVSetEaInformation)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryEaInformation(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles Query EA Info requests for the DAV Mini-Redir. For now,
   we just return STATUS_EAS_NOT_SUPPORTED.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    PAGED_CODE();

    NtStatus = STATUS_EAS_NOT_SUPPORTED;

    return NtStatus;
}


NTSTATUS
MRxDAVSetEaInformation(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles Set EA Info requests for the DAV Mini-Redir. For now,
   we just return STATUS_EAS_NOT_SUPPORTED.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NtStatus = STATUS_EAS_NOT_SUPPORTED;

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fileinfo.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the DAV mini redirector call down routines pertaining
    to query/set file/volume information.

Author:

    Rohan Kumar [RohanK] 27-Sept-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"


#define DEFAULT_BYTES_PER_SECTOR    512
#define DEFAULT_SECTORS_PER_ALLOCATION_UNIT 1

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVReNameContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVSetFileInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );
    
NTSTATUS
MRxDAVFormatUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );
    
BOOL
MRxDAVPrecompleteUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVQueryVolumeInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );
    
NTSTATUS
MRxDAVFormatUserModeQueryVolumeInformationRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );
    
BOOL
MRxDAVPrecompleteUserModeQueryVolumeInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

BOOL
DavIsValidDate(
    PLARGE_INTEGER pFileTime
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryVolumeInformation)
#pragma alloc_text(PAGE, MRxDAVQueryFileInformation)
#pragma alloc_text(PAGE, MRxDAVSetFileInformation)
#pragma alloc_text(PAGE, MRxDAVReNameContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeReNameRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeReNameRequest)
#pragma alloc_text(PAGE, MRxDAVSetFileInformationContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSetFileInformationRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSetFileInformationRequest)
#pragma alloc_text(PAGE, MRxDAVQueryVolumeInformationContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeQueryVolumeInformationRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeQueryVolumeInformationRequest)
#pragma alloc_text(PAGE, DavIsValidDate)
#pragma alloc_text(PAGE, MRxDAVIsValidDirectory)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryVolumeInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query volume info requests for the DAV MiniRedir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    FS_INFORMATION_CLASS FsInfoClass;
    PVOID Buffer;
    ULONG BufferLength = 0, BufferLengthUsed = 0;
    PFILE_FS_SIZE_INFORMATION FileFsSizeInfo = NULL;
    PFILE_FS_FULL_SIZE_INFORMATION FileFsFullSizeInfo = NULL;
    PFILE_FS_VOLUME_INFORMATION FileFsVolInfo = NULL;
    PFILE_FS_DEVICE_INFORMATION FileFsDeviceInfo = NULL;
    PFILE_FS_ATTRIBUTE_INFORMATION FileFsAttributeInfo = NULL;
    RxCaptureFcb;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    BOOLEAN SynchronousIo = FALSE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeFileName;
    PWCHAR NtFileName = NULL;
    FILE_FS_FULL_SIZE_INFORMATION SizeInfo;
    ULONG SizeInBytes = 0;
    PWEBDAV_V_NET_ROOT DavVNetRoot = (PWEBDAV_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot->Context;

    PAGED_CODE();

    FsInfoClass = RxContext->Info.FsInformationClass;
    BufferLength = RxContext->Info.LengthRemaining;
    Buffer = RxContext->Info.Buffer;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVQueryVolumeInformation. FsInfoClass = %d.\n", 
                 PsGetCurrentThreadId(), FsInfoClass));

    if ( FsInfoClass == FileFsSizeInformation || 
         FsInfoClass == FileFsFullSizeInformation ) {

        //
        // If the Driver initialization went smoothly then DavWinInetCachePath 
        // should be containing the WinInetCachePath value.
        //
        ASSERT(DavWinInetCachePath[0] != L'\0');

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation: DavWinInetCachePath: %ws\n",
                     PsGetCurrentThreadId(), DavWinInetCachePath));

        //
        // Create an NT path name for the cached file. This is used in the 
        // NtCreateFile call below. If c:\foo\bar is the DOA path name,
        // the NT path name is \??\c:\foo\bar. 
        //

        SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
        NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
        if (NtFileName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryVolumeInformation/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(NtFileName, SizeInBytes);

        wcscpy( NtFileName, L"\\??\\" );
        wcscpy( &(NtFileName[4]), DavWinInetCachePath );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation: NtFileName = %ws\n",
                     PsGetCurrentThreadId(), NtFileName));

        RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

        InitializeObjectAttributes(&(ObjectAttributes),
                                   &(UnicodeFileName),
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = ZwOpenFile(&(FileHandle),
                              (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                              &(ObjectAttributes),
                              &(IoStatusBlock),
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY);
        if ( !NT_SUCCESS(NtStatus) ) {
            FileHandle = NULL;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation/NtOpenFile: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        NtStatus = ZwQueryVolumeInformationFile(FileHandle,
                                                &(IoStatusBlock),
                                                &(SizeInfo),
                                                sizeof(SizeInfo),
                                                FileFsFullSizeInformation);
        if ( !NT_SUCCESS(NtStatus) ) {
            NtStatus = IoStatusBlock.Status;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation/NtQueryVolumeInformationFile: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    switch (FsInfoClass) {
    
    case FileFsVolumeInformation:
    
        if ( BufferLength < sizeof(FILE_FS_VOLUME_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsVolInfo = (PFILE_FS_VOLUME_INFORMATION)Buffer;

        FileFsVolInfo->VolumeCreationTime.LowPart = 0;
        FileFsVolInfo->VolumeCreationTime.HighPart = 0;

        FileFsVolInfo->VolumeSerialNumber = 0;

        FileFsVolInfo->SupportsObjects = FALSE;

        FileFsVolInfo->VolumeLabelLength = 0;

        FileFsVolInfo->VolumeLabel[0] = 0;

        BufferLengthUsed += sizeof(FILE_FS_VOLUME_INFORMATION);
        
        break;
    
    case FileFsSizeInformation:

        if ( BufferLength < sizeof(FILE_FS_SIZE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        if (!DavVNetRoot->fReportsAvailableSpace)
        {
            FileFsSizeInfo = (PFILE_FS_SIZE_INFORMATION)Buffer;

            FileFsSizeInfo->AvailableAllocationUnits.LowPart = SizeInfo.ActualAvailableAllocationUnits.LowPart;
            FileFsSizeInfo->AvailableAllocationUnits.HighPart = SizeInfo.ActualAvailableAllocationUnits.HighPart;

            FileFsSizeInfo->BytesPerSector = SizeInfo.BytesPerSector;

            FileFsSizeInfo->SectorsPerAllocationUnit = SizeInfo.SectorsPerAllocationUnit;

            FileFsSizeInfo->TotalAllocationUnits.LowPart = SizeInfo.TotalAllocationUnits.LowPart;
            FileFsSizeInfo->TotalAllocationUnits.HighPart = SizeInfo.TotalAllocationUnits.HighPart;

            BufferLengthUsed += sizeof(FILE_FS_SIZE_INFORMATION);
        }
        else
        {
            NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                                SIZEOF_DAV_SPECIFIC_CONTEXT,
                                                MRxDAVFormatTheDAVContext,
                                                (USHORT)DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION,
                                                MRxDAVQueryVolumeInformationContinuation,
                                                "MRxDAVQueryVolumeInformation");
            if (NtStatus == STATUS_SUCCESS)
            {
                BufferLengthUsed += sizeof(FILE_FS_SIZE_INFORMATION);
            }
        }
        break;

    case FileFsFullSizeInformation:

        if ( BufferLength < sizeof(FILE_FS_FULL_SIZE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }
        if (!DavVNetRoot->fReportsAvailableSpace)
        {
            FileFsFullSizeInfo = (PFILE_FS_FULL_SIZE_INFORMATION)Buffer;

            FileFsFullSizeInfo->ActualAvailableAllocationUnits.LowPart = SizeInfo.ActualAvailableAllocationUnits.LowPart;
            FileFsFullSizeInfo->ActualAvailableAllocationUnits.HighPart = SizeInfo.ActualAvailableAllocationUnits.HighPart;

            FileFsFullSizeInfo->BytesPerSector = SizeInfo.BytesPerSector;

            FileFsFullSizeInfo->CallerAvailableAllocationUnits.LowPart = SizeInfo.CallerAvailableAllocationUnits.LowPart;
            FileFsFullSizeInfo->CallerAvailableAllocationUnits.HighPart = SizeInfo.CallerAvailableAllocationUnits.HighPart;

            FileFsFullSizeInfo->SectorsPerAllocationUnit = SizeInfo.SectorsPerAllocationUnit;

            FileFsFullSizeInfo->TotalAllocationUnits.LowPart = SizeInfo.TotalAllocationUnits.LowPart;
            FileFsFullSizeInfo->TotalAllocationUnits.HighPart = SizeInfo.TotalAllocationUnits.HighPart;

            BufferLengthUsed += sizeof(FILE_FS_FULL_SIZE_INFORMATION);
        }
        else
        {
            NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                                SIZEOF_DAV_SPECIFIC_CONTEXT,
                                                MRxDAVFormatTheDAVContext,
                                                (USHORT)DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION,
                                                MRxDAVQueryVolumeInformationContinuation,
                                                "MRxDAVQueryVolumeInformation");
        
            if (NtStatus == STATUS_SUCCESS)
            {
                BufferLengthUsed += sizeof(FILE_FS_FULL_SIZE_INFORMATION);
            }
        }

        break;

    case FileFsDeviceInformation:

        if ( BufferLength < sizeof(FILE_FS_DEVICE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsDeviceInfo = (PFILE_FS_DEVICE_INFORMATION)Buffer;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation. DeviceType = %d.\n", 
                     PsGetCurrentThreadId(), NetRoot->DeviceType));
        
        FileFsDeviceInfo->DeviceType = NetRoot->DeviceType;

        FileFsDeviceInfo->Characteristics = FILE_REMOTE_DEVICE;

        BufferLengthUsed += sizeof(FILE_FS_DEVICE_INFORMATION);
        
        break;
    
    case FileFsAttributeInformation: {

        ULONG LengthNeeded, FileSystemNameLength;
         
        LengthNeeded = sizeof(FILE_FS_ATTRIBUTE_INFORMATION);
        LengthNeeded += ( wcslen(DD_DAV_FILESYS_NAME_U) * sizeof(WCHAR) );

        if ( BufferLength < LengthNeeded ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;

        FileFsAttributeInfo->FileSystemAttributes = (FILE_CASE_PRESERVED_NAMES | FILE_SUPPORTS_ENCRYPTION);

        FileFsAttributeInfo->MaximumComponentNameLength = 255;
        
        FileSystemNameLength = ( 1 + wcslen(DD_DAV_FILESYS_NAME_U) ) * sizeof(WCHAR);

        FileFsAttributeInfo->FileSystemNameLength = FileSystemNameLength;

        wcscpy(&(FileFsAttributeInfo->FileSystemName[0]), DD_DAV_FILESYS_NAME_U);

        BufferLengthUsed += LengthNeeded;

    }
        
        break;

    default:
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVQueryVolumeInformation. FsInfoClass = %d.\n", 
                     PsGetCurrentThreadId(), FsInfoClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;
    
    }

EXIT_THE_FUNCTION:

    RxContext->Info.LengthRemaining -= BufferLengthUsed;

    //
    // Close the handle if we opened the handle to the WinInetCachePath.
    //
    if (FileHandle) {
        NtClose(FileHandle);
    }

    //
    // Free the NtFileName buffer if we allocated one.
    //
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

    return NtStatus;
}


NTSTATUS
MRxDAVQueryFileInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query file info requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    FS_INFORMATION_CLASS FsInfoClass;
    PFCB thisFcb = NULL;
    PVOID Buffer = NULL;
    ULONG BufferLength = 0, BufferLengthUsed = 0, fileAttributes = 0;
    PFILE_BASIC_INFORMATION FileBasicInfo = NULL;
    PFILE_STANDARD_INFORMATION FileStandardInfo = NULL;
    PFILE_INTERNAL_INFORMATION FileInternalInfo = NULL;
    PFILE_EA_INFORMATION FileEaInfo = NULL;
    PFILE_ATTRIBUTE_TAG_INFORMATION FileAttTagInfo = NULL;
    PFILE_NAME_INFORMATION FileAltNameInfo = NULL;
    PFILE_STREAM_INFORMATION FileStreamInfo = NULL;

    PAGED_CODE();

    FsInfoClass = RxContext->Info.FsInformationClass;
    BufferLength = RxContext->Info.LengthRemaining;
    Buffer = RxContext->Info.Buffer;
    thisFcb = (PFCB)RxContext->pFcb;

    //
    // If the file attributes is 0, then we set return FILE_ATTRIBUTE_ARCHIVE.
    // We fake this since the apps expect this.
    //
    fileAttributes = thisFcb->Attributes;
    if (fileAttributes == 0) {
        fileAttributes = FILE_ATTRIBUTE_ARCHIVE;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVQueryFileInformation. FsInfoClass = %d.\n", 
                 PsGetCurrentThreadId(), FsInfoClass));

    switch (FsInfoClass) {
    
    case FileBasicInformation:

        FileBasicInfo = (PFILE_BASIC_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_BASIC_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileBasicInfo->ChangeTime.LowPart = thisFcb->LastChangeTime.LowPart;
        FileBasicInfo->ChangeTime.HighPart = thisFcb->LastChangeTime.HighPart;

        FileBasicInfo->CreationTime.LowPart = thisFcb->CreationTime.LowPart;
        FileBasicInfo->CreationTime.HighPart = thisFcb->CreationTime.HighPart;

        FileBasicInfo->LastAccessTime.LowPart = thisFcb->LastAccessTime.LowPart;
        FileBasicInfo->LastAccessTime.HighPart = thisFcb->LastAccessTime.HighPart;

        FileBasicInfo->LastWriteTime.LowPart = thisFcb->LastWriteTime.LowPart;
        FileBasicInfo->LastWriteTime.HighPart = thisFcb->LastWriteTime.HighPart;

        FileBasicInfo->FileAttributes = fileAttributes;

        BufferLengthUsed += sizeof(FILE_BASIC_INFORMATION);

        break;

    case FileStandardInformation:

        FileStandardInfo = (PFILE_STANDARD_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_STANDARD_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileStandardInfo->AllocationSize.LowPart = thisFcb->Header.AllocationSize.LowPart;
        FileStandardInfo->AllocationSize.HighPart = thisFcb->Header.AllocationSize.HighPart;

        FileStandardInfo->EndOfFile.LowPart = thisFcb->Header.FileSize.LowPart;
        FileStandardInfo->EndOfFile.HighPart = thisFcb->Header.FileSize.HighPart;

        FileStandardInfo->DeletePending = 0;

        FileStandardInfo->Directory = (BOOLEAN)(fileAttributes & FILE_ATTRIBUTE_DIRECTORY);

        FileStandardInfo->NumberOfLinks = thisFcb->NumberOfLinks;

        BufferLengthUsed += sizeof(FILE_STANDARD_INFORMATION);
        
        break;

    case FileInternalInformation:

        FileInternalInfo = (PFILE_INTERNAL_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_INTERNAL_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileInternalInfo->IndexNumber.LowPart = 0;
        FileInternalInfo->IndexNumber.HighPart = 0;
        
        BufferLengthUsed += sizeof(FILE_INTERNAL_INFORMATION);
        
        break;

    case FileEaInformation:

        FileEaInfo = (PFILE_EA_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_EA_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileEaInfo->EaSize = 0;

        BufferLengthUsed += sizeof(FILE_EA_INFORMATION);
        
        break;

    case FileAttributeTagInformation:

        FileAttTagInfo = (PFILE_ATTRIBUTE_TAG_INFORMATION)Buffer;
    
        if ( BufferLength < sizeof(FILE_ATTRIBUTE_TAG_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileAttTagInfo->FileAttributes = fileAttributes;

        FileAttTagInfo->ReparseTag = 0;

        BufferLengthUsed += sizeof(FILE_ATTRIBUTE_TAG_INFORMATION);
        
        break;

    case FileAlternateNameInformation:

        FileAltNameInfo = (PFILE_NAME_INFORMATION)Buffer;
    
        if ( BufferLength < sizeof(FILE_NAME_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        //
        // We don't return any alternate names.
        //

        FileAltNameInfo->FileNameLength = 0;

        FileAltNameInfo->FileName[0] = L'\0';

        BufferLengthUsed += sizeof(FILE_NAME_INFORMATION);
        
        break;

    case FileStreamInformation: {
        
        FileStreamInfo = (PFILE_STREAM_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_STREAM_INFORMATION) + 6 * sizeof(WCHAR) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        // Return the default stream information of the dav file

        FileStreamInfo->NextEntryOffset = 0;
        FileStreamInfo->StreamNameLength = 7 * sizeof(WCHAR);
        FileStreamInfo->StreamSize.QuadPart = thisFcb->Header.FileSize.QuadPart;
        FileStreamInfo->StreamAllocationSize.QuadPart = thisFcb->Header.AllocationSize.QuadPart;
        RtlCopyMemory(&FileStreamInfo->StreamName[0], L"::$DATA", 7 * sizeof(WCHAR));

        BufferLengthUsed += sizeof(FILE_STREAM_INFORMATION) + 6 * sizeof(WCHAR);
        /*
        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
        PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

        NtStatus = DavXxxInformation(IRP_MJ_QUERY_INFORMATION,
                                     davSrvOpen->UnderlyingFileObject,
                                     FileStreamInformation,
                                     RxContext->Info.Length,
                                     RxContext->Info.Buffer,
                                     NULL);*/
        } 

        break;

    default:
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVQueryFileInformation. FsInfoClass = %d.\n",
                     PsGetCurrentThreadId(), FsInfoClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;

    }

    RxContext->Info.LengthRemaining -= BufferLengthUsed;

    return NtStatus;
}


NTSTATUS
MRxDAVSetFileInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query file info requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PFCB thisFcb = NULL;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer = NULL;
    PFILE_DISPOSITION_INFORMATION FileDispInfo = NULL;
    PFILE_RENAME_INFORMATION FileRenInfo = NULL;
    PFILE_END_OF_FILE_INFORMATION FileEOFInfo = NULL;
    PFILE_BASIC_INFORMATION FileBasicInfo = NULL;
    PFILE_ALLOCATION_INFORMATION FileAllocInfo = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    BOOLEAN FileAttributesChanged = FALSE;

    PAGED_CODE();

    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    thisFcb = (PFCB)RxContext->pFcb;
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAvSetFileInformation: FileInformationClass = %d\n",
                 PsGetCurrentThreadId(), FileInformationClass));

    switch (FileInformationClass) {
    
    case FileDispositionInformation:

        FileDispInfo = (PFILE_DISPOSITION_INFORMATION)Buffer;

        //
        // If we have been asked to delete this file or directory and its read
        // only, then we return STATUS_CANNOT_DELETE.
        //
        if ( FileDispInfo->DeleteFile && (thisFcb->Attributes & (FILE_ATTRIBUTE_READONLY)) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAvSetFileInformation: STATUS_CANNOT_DELETE %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
            NtStatus = STATUS_CANNOT_DELETE;
            goto EXIT_THE_FUNCTION;
        }

        if (FileDispInfo->DeleteFile) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAvSetFileInformation: DELETE %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
        }

        //
        // This file needs to be deleted on close OR a previous delete of this
        // file is being nullified.
        //
        DavFcb->DeleteOnClose = ( (FileDispInfo->DeleteFile == TRUE) ? TRUE : FALSE );

        break;

    case FileRenameInformation:

        FileRenInfo = (PFILE_RENAME_INFORMATION)Buffer;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAvSetFileInformation: NewFileName = %ws\n",
                     PsGetCurrentThreadId(), FileRenInfo->FileName));

        //
        // If the FileNameLength is greater than (MAX_PATH * sizeof(WCHAR)),
        // we return STATUS_NAME_TOO_LONG since the NewFileName in the FCB
        // cannot hold names greater than this size.
        //
        if ( FileRenInfo->FileNameLength > (MAX_PATH * sizeof(WCHAR)) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAvSetFileInformation: STATUS_NAME_TOO_LONG %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
            NtStatus = STATUS_NAME_TOO_LONG;
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the new file name.
        //
        RtlCopyMemory(DavFcb->NewFileName, FileRenInfo->FileName, FileRenInfo->FileNameLength);

        DavFcb->NewFileNameLength = FileRenInfo->FileNameLength;

        NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                            SIZEOF_DAV_SPECIFIC_CONTEXT,
                                            MRxDAVFormatTheDAVContext,
                                            DAV_MINIRDR_ENTRY_FROM_RENAME,
                                            MRxDAVReNameContinuation,
                                            "MRxDAVSetFileInformation");
        if (NtStatus != ERROR_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVSetFileInformation/UMRxAsyncEngOuterWrapper: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        } else {
            //
            // We need to set this value in the DAV Fcb. We look at this value on 
            // Close to figure out the new file name to do the PUT on.
            //
            DavFcb->FileWasRenamed = TRUE;
            //
            // Create the name based file not found cache.
            //
            MRxDAVCacheFileNotFound(RxContext);
            //
            // Invalidate the file not found cache for the new name if it exists.
            //
            MRxDAVInvalidateFileNotFoundCacheForRename(RxContext);
            MRxDAVInvalidateFileInfoCache(RxContext);

            if ((thisFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (thisFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                UNICODE_STRING DirName;
                UNICODE_STRING RenameName;
                PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;

                //
                // Remove the old directory name from the registry
                //
                MRxDAVRemoveEncryptedDirectoryKey(&DavFcb->FileNameInfo);

                RenameName.Buffer = &RenameInformation->FileName[0];
                RenameName.Length = (USHORT)RenameInformation->FileNameLength;

                NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&RenameName,&DirName);

                if (NtStatus != STATUS_SUCCESS) {
                    goto EXIT_THE_FUNCTION;
                }

                if (DirName.Buffer != NULL) {
                    //
                    // Create the new directory in the registry
                    //
                    NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);

                    // The buffer was allocated in MRxDAVGetFullDirectoryPath
                    RxFreePool(DirName.Buffer);
                }
            }
        }

        break;

    case FileEndOfFileInformation: {
        
            PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

            //
            // If the FileEndOfFileInformation is being done on a directory,
            // return STATUS_INVALID_PARAMETER since it doesn't make sense to
            // do this.
            //
            if (DavFcb->isDirectory) {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }
        
            NtStatus = DavXxxInformation(IRP_MJ_SET_INFORMATION,
                                         davSrvOpen->UnderlyingFileObject,
                                         FileEndOfFileInformation,
                                         RxContext->Info.Length,
                                         RxContext->Info.Buffer,
                                         NULL);
           if (NtStatus == STATUS_SUCCESS) {
               thisFcb->Header.FileSize = ((PFILE_END_OF_FILE_INFORMATION)(RxContext->Info.Buffer))->EndOfFile;
               DavFcb->FileWasModified = TRUE;
               DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
               MRxDAVUpdateFileInfoCacheFileSize(RxContext,&thisFcb->Header.FileSize);
           } else {
               DavDbgTrace(DAV_TRACE_ERROR,
                           ("%ld: ERROR: MRxDAvSetFileInformation/DavXxxInformation"
                            ". FileInfoClass = %d\n", PsGetCurrentThreadId(), FileInformationClass));
           }

    }
        break;

    case FileBasicInformation:

        if (!DavVNetRoot->fAllowsProppatch)
        {
            NtStatus = STATUS_ACCESS_DENIED;
            break;
        }

        FileBasicInfo = (PFILE_BASIC_INFORMATION)Buffer;

        //
        // If the user specified -1 for a field, it means that we should leave
        // the field unchanged. We set the field to 0 then so we know not to
        // actually set the field to the user-specified (in this case, illegal)
        // value.
        //

        if (FileBasicInfo->LastWriteTime.QuadPart == -1) {
            FileBasicInfo->LastWriteTime.QuadPart = 0;
        }

        if (FileBasicInfo->LastAccessTime.QuadPart == -1) {
            FileBasicInfo->LastAccessTime.QuadPart = 0;
        }

        if (FileBasicInfo->CreationTime.QuadPart == -1) {
            FileBasicInfo->CreationTime.QuadPart = 0;
        }

        //
        // Let us first find what changed, we will try to change it on the server
        // if that succeeds, we will set it on the FCB.
        //

        if (FileBasicInfo->ChangeTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->ChangeTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastChangeTime.LowPart != FileBasicInfo->ChangeTime.LowPart)||
                (thisFcb->LastChangeTime.HighPart != FileBasicInfo->ChangeTime.HighPart)) {
                thisFcb->LastChangeTime.LowPart = FileBasicInfo->ChangeTime.LowPart;
                thisFcb->LastChangeTime.HighPart = FileBasicInfo->ChangeTime.HighPart;
            }
        }

        if (FileBasicInfo->CreationTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->CreationTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->CreationTime.LowPart != FileBasicInfo->CreationTime.LowPart)||
                (thisFcb->CreationTime.HighPart != FileBasicInfo->CreationTime.HighPart)) {
                DavFcb->fCreationTimeChanged = TRUE;
            }
        }
        
        if (FileBasicInfo->LastAccessTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->LastAccessTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastAccessTime.LowPart != FileBasicInfo->LastAccessTime.LowPart)||
                (thisFcb->LastAccessTime.HighPart != FileBasicInfo->LastAccessTime.HighPart)) {
                DavFcb->fLastAccessTimeChanged = TRUE;
            }
        }
        
        if (FileBasicInfo->LastWriteTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->LastWriteTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastWriteTime.LowPart != FileBasicInfo->LastWriteTime.LowPart)||
                (thisFcb->LastWriteTime.HighPart != FileBasicInfo->LastWriteTime.HighPart)) {
                DavFcb->fLastModifiedTimeChanged = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            }
        }

        if ((FileBasicInfo->FileAttributes != 0) && (thisFcb->Attributes != FileBasicInfo->FileAttributes)) {

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVSetFileInformation: thisFcb->Attributes = %x, "
                         "FileBasicInfo->FileAttributes = %x\n", PsGetCurrentThreadId(),
                         thisFcb->Attributes, FileBasicInfo->FileAttributes));

            //
            // If this is a directory then when we OR the attributes with
            // FILE_ATTRIBUTE_DIRECTORY. This is because this gets filtered
            // by the time it comes to us and we have code in the usermode
            // which makes some validity checks when a user tries to set
            // attributes on a directory.
            //
            if ( (thisFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                FileBasicInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                
            }

            DavFcb->fFileAttributesChanged = TRUE;
            FileAttributesChanged = TRUE;

        }

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVSetFileInformation: fCreationTimeChanged = %d, "
                     "fLastAccessTimeChanged = %d, fLastModifiedTimeChanged = %d, "
                     "fFileAttributesChanged = %d\n", PsGetCurrentThreadId(),
                     DavFcb->fCreationTimeChanged, DavFcb->fLastAccessTimeChanged,
                     DavFcb->fLastModifiedTimeChanged, DavFcb->fFileAttributesChanged));

        NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                            SIZEOF_DAV_SPECIFIC_CONTEXT,
                                            MRxDAVFormatTheDAVContext,
                                            DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION,
                                            MRxDAVSetFileInformationContinuation,
                                            "MRxDAVSetFileInformation");
        if (NtStatus != ERROR_SUCCESS) {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVSetFileInformation/UMRxAsyncEngOuterWrapper: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        
        } else {
            //
            // Succeeded, modify on the FCB.
            //
            if(DavFcb->fCreationTimeChanged) {
                thisFcb->CreationTime.LowPart = FileBasicInfo->CreationTime.LowPart;
                thisFcb->CreationTime.HighPart = FileBasicInfo->CreationTime.HighPart;
            }

            if(DavFcb->fLastAccessTimeChanged) {
                thisFcb->LastAccessTime.LowPart = FileBasicInfo->LastAccessTime.LowPart;
                thisFcb->LastAccessTime.HighPart = FileBasicInfo->LastAccessTime.HighPart;
            }

            if(DavFcb->fLastModifiedTimeChanged) {
                thisFcb->LastWriteTime.LowPart = FileBasicInfo->LastWriteTime.LowPart;
                thisFcb->LastWriteTime.HighPart = FileBasicInfo->LastWriteTime.HighPart;
            }

            //
            // DavFcb->fFileAttributesChanged could be set on create, and the 
            // FileBasicInfo->FileAttributes could be 0 here. So we should not check 
            // DavFcb->fFileAttributesChanged.
            //
                
            if (FileAttributesChanged) {
                ULONG SavedAttributes = thisFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED;

                thisFcb->Attributes = FileBasicInfo->FileAttributes;
                
                //
                // SetFileInformation should not affect any extended NT file attributes
                //
                thisFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                thisFcb->Attributes |= SavedAttributes;
            }

            MRxDAVUpdateBasicFileInfoCache(RxContext,thisFcb->Attributes,&thisFcb->LastWriteTime);
        }

        //
        // Cleanup the FCB bits.
        //
        DavFcb->fCreationTimeChanged = DavFcb->fFileAttributesChanged = 
        DavFcb->fLastAccessTimeChanged = DavFcb->fLastModifiedTimeChanged = 0;

        break;

    case FileAllocationInformation: {

        PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

        //
        // If the FileAllocationInformation is being done on a directory,
        // return STATUS_INVALID_PARAMETER since it doesn't make sense to
        // do this.
        //
        if (DavFcb->isDirectory) {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

        NtStatus = DavXxxInformation(IRP_MJ_SET_INFORMATION,
                                     davSrvOpen->UnderlyingFileObject,
                                     FileAllocationInformation,
                                     RxContext->Info.Length,
                                     RxContext->Info.Buffer,
                                     NULL);
        if (NtStatus == STATUS_SUCCESS) {
            DavFcb->FileWasModified = TRUE;
            DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAvSetFileInformation/DavXxxInformation"
                         ". FileInfoClass = %d\n", PsGetCurrentThreadId(), FileInformationClass));
        }

    }
        break;

    default:

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAvSetFileInformation: FileInformationClass"
                     " = %d\n", PsGetCurrentThreadId(), FileInformationClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;
    
    }

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVReNameContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which renames a file.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVReNameContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVReNameContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeReNameRequest,
                              MRxDAVPrecompleteUserModeReNameRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVReNameContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeReNameRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the ReName request being sent to the user mode for 
    processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL, OldPathName = NULL, NewPathName = NULL;
    ULONG ServerNameLengthInBytes, OldPathNameLengthInBytes, NewPathNameLengthInBytes;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes, NetRootNameLengthInWChars;
    PFILE_RENAME_INFORMATION FileRenInfo = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeReNameRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeReNameRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    FileRenInfo = (PFILE_RENAME_INFORMATION)RxContext->Info.Buffer;
    
    DavWorkItem->WorkItemType = UserModeReName;

    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //
    // If the destination file already exists, then we need to need to replace
    // the file only if ReplaceIfExists is set to TRUE.
    //
    DavReNameRequest->ReplaceIfExists = FileRenInfo->ReplaceIfExists;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: ReplaceIfExists: %d\n",
                 PsGetCurrentThreadId(), DavReNameRequest->ReplaceIfExists));
    
    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: ServerName: %ws\n",
                 PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    DavReNameRequest->ServerID = DavSrvCall->ServerID;

    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the OldPathName of the Directory.
    //
    OldPathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                 SrvOpen->pAlreadyPrefixedName->Length + 
                                 sizeof(WCHAR) );

    OldPathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       OldPathNameLengthInBytes);
    if (OldPathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlZeroMemory(OldPathName, OldPathNameLengthInBytes);
    
    RtlCopyBytes(OldPathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    RtlCopyBytes( (OldPathName + NetRootNameLengthInWChars), 
                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                  SrvOpen->pAlreadyPrefixedName->Length );
    
    OldPathName[( ( (OldPathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->OldPathName = OldPathName;
    wcscpy(DavReNameRequest->Url, DavFcb->Url);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: OldPathName: %ws\n",
                 PsGetCurrentThreadId(), OldPathName));

    //
    // Copy the NewPathName of the Directory.
    //
    NewPathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                 DavFcb->NewFileNameLength + 
                                 sizeof(WCHAR) );
    
    NewPathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       NewPathNameLengthInBytes);
    if (NewPathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlZeroMemory(NewPathName, NewPathNameLengthInBytes);
    
    RtlCopyBytes(NewPathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    RtlCopyBytes( (NewPathName + NetRootNameLengthInWChars), 
                  DavFcb->NewFileName, 
                  DavFcb->NewFileNameLength );

    NewPathName[( ( (NewPathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->NewPathName = NewPathName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: NewPathName: %ws\n",
                 PsGetCurrentThreadId(), NewPathName));
    
    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    DavReNameRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    DavReNameRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 

    if(!DavVNetRoot->SCAlreadyInitialized)
    {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeReNameRequest \n");
        DbgBreakPoint();
    }
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                     ("%ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                      "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                      PsGetCurrentThreadId(), NtStatus));
    }   

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeReNameRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the ReName request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the Rename case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeReNameRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (DavReNameRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavReNameRequest->OldPathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->OldPathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavReNameRequest->NewPathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->NewPathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    NtStatus = AsyncEngineContext->Status;
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest:"
                     "Rename failed with NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    return(TRUE);
}



NTSTATUS
MRxDAVSetFileInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    The precompletion routine for the SetFileInformation request.

Arguments:


Return Value:

    TRUE or FALSE.

--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVSetFileInformationContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVSetFileInformationContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeSetFileInformationRequest,
                              MRxDAVPrecompleteUserModeSetFileInformationRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVSetFileInformationContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;

}


NTSTATUS
MRxDAVFormatUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SetFileInformation request being sent to the user mode for 
    processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflector's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PFCB thisFcb = (PFCB)RxContext->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL, PathName = NULL;
    ULONG ServerNameLengthInBytes, PathNameLengthInBytes;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST DavSetFileInformationRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes, NetRootNameLengthInWChars;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSetFileInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    DavWorkItem->WorkItemType = UserModeSetFileInformation;

    DavSetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavSetFileInformationRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: ServerName: %ws\n",
                 PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    DavSetFileInformationRequest->ServerID = DavSrvCall->ServerID;

    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the PathName of the Directory.
    //
    PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                              SrvOpen->pAlreadyPrefixedName->Length + 
                              sizeof(WCHAR) );

    PathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       PathNameLengthInBytes);
    if (PathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlZeroMemory(PathName, PathNameLengthInBytes);
    
    RtlCopyBytes(PathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    RtlCopyBytes( (PathName + NetRootNameLengthInWChars), 
                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                  SrvOpen->pAlreadyPrefixedName->Length );
    
    PathName[( ( (PathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavSetFileInformationRequest->PathName = PathName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: PathName: %ws\n",
                 PsGetCurrentThreadId(), PathName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    DavSetFileInformationRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    DavSetFileInformationRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 

    if(!DavVNetRoot->SCAlreadyInitialized)
    {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeSetFileInformationRequest \n");
        DbgBreakPoint();
    }
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }   
    
    ASSERT(RxContext->Info.FileInformationClass == FileBasicInformation);
    
    //
    // Set the change bits, we will clear them from the FCB in 
    // MRxDavSetFileInformation routine this is OK because the FCB is exclusive 
    // at this point.
    //
    DavSetFileInformationRequest->FileBasicInformation = *(PFILE_BASIC_INFORMATION)(RxContext->Info.Buffer);

    if (RxContext->pFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
        //
        // Preserve the FILE_ATTRIBUTE_ENCRYPTED flag on the PROPPATCH request 
        // sent to DAV server. In fact, no extended file attributes should be 
        // changed with a SetFileInformation request.
        //
        DavSetFileInformationRequest->FileBasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
    }

    //
    // If we are setting a particular time value, we need to make sure that it
    // it not zero. If the user is trying to set a subset of the basic information
    // and the other values (which are not being set by the user but need to be)
    // need to be updated as well, we do them now. The time values to be updated
    // are in the FCB. This situation happens in the copy command.
    //

    DavSetFileInformationRequest->fCreationTimeChanged = DavFcb->fCreationTimeChanged;
    if (DavSetFileInformationRequest->fCreationTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart = thisFcb->CreationTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fLastAccessTimeChanged = DavFcb->fLastAccessTimeChanged;
    if (DavSetFileInformationRequest->fLastAccessTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.LastAccessTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.LastAccessTime.QuadPart = thisFcb->LastAccessTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fLastModifiedTimeChanged = DavFcb->fLastModifiedTimeChanged;
    if (DavSetFileInformationRequest->fLastModifiedTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart = thisFcb->LastWriteTime.QuadPart;
        }
    }

    //
    // If we are setting both the Creation and LastWrite time values, we need to
    // make sure that the CreationTime <= LastWriteTime.
    //

    if (DavSetFileInformationRequest->fCreationTimeChanged && DavSetFileInformationRequest->fLastModifiedTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart > 
            DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart) {
            DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart = 
                DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fFileAttributesChanged = DavFcb->fFileAttributesChanged;

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeSetFileInformationRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the SetFileInformation request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST DavSetFileInformationRequest = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();

    DavSetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the SetFileInformation case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSetFileInformationRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (DavSetFileInformationRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavSetFileInformationRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavSetFileInformationRequest->PathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavSetFileInformationRequest->PathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    NtStatus = AsyncEngineContext->Status;
    
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest:"
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
    }
    
EXIT_THE_FUNCTION:

    return(TRUE);
}


NTSTATUS
MRxDAVQueryVolumeInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for query volume information operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryVolumeInformationContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT, 
                ("%ld: MRxDAVQueryVolumeInformationContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));


    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeQueryVolumeInformationRequest,
                              MRxDAVPrecompleteUserModeQueryVolumeInformationRequest
                              );

    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryVolumeInformationContinuation with NtStatus "
                 "= %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeQueryVolumeInformationRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the QueryVolumeInformation request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWCHAR ServerName = NULL, ShareName = NULL, JustTheShareName = NULL;
    ULONG ServerNameLengthInBytes, ShareNameLengthInBytes;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeQueryVolumeInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

    DavWorkItem->WorkItemType = UserModeQueryVolumeInformation;
    
    QueryVolumeInformationRequest = &(DavWorkItem->QueryVolumeInformationRequest);

    DavFobx = MRxDAVGetFobxExtension(capFobx);
    ASSERT(DavFobx != NULL);

    NetRoot = SrvOpen->pFcb->pNetRoot;

    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: SrvCallName = %wZ, "
                 "SrvCallNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pSrvCall->pSrvCallName, NetRoot->pSrvCall->pSrvCallName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: ShareName = %wZ, "
                 "ShareNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pNetRootName, NetRoot->pNetRootName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: PathName = %wZ, "
                 "PathNameLength = %d\n", PsGetCurrentThreadId(), 
                 SrvOpen->pAlreadyPrefixedName, SrvOpen->pAlreadyPrefixedName->Length));

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryVolumeInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    QueryVolumeInformationRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    QueryVolumeInformationRequest->ServerID = DavSrvCall->ServerID;

    //
    // The ShareName (pShareName) includes the ServerName. Hence to get the
    // ShareNameLengthInBytes, we do the following.
    //
    ShareNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);

    ShareName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheShareName = wcschr(ShareName, L'\\');

    // allocate for NULL
    ShareName = (PWCHAR)UMRxAllocateSecondaryBuffer(AsyncEngineContext, ShareNameLengthInBytes+sizeof(WCHAR));
    
    if (ShareName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryVolumeInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    QueryVolumeInformationRequest->ShareName = (PWCHAR)ShareName;
    
    RtlZeroMemory(QueryVolumeInformationRequest->ShareName, ShareNameLengthInBytes+sizeof(WCHAR));
    
    //
    // Copy the ShareName.
    //
    RtlCopyMemory(ShareName, JustTheShareName, ShareNameLengthInBytes);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. PathName ="
                 " %ws\n", PsGetCurrentThreadId(), ShareName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    QueryVolumeInformationRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    QueryVolumeInformationRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. DavVNetRoot"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. LogonID.LowPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. LogonID.HighPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 
    
    if(!DavVNetRoot->SCAlreadyInitialized)
    {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeQueryVolumeInformationRequest \n");
        DbgBreakPoint();
    }
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                     "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }   


EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeQueryVolumeInformationRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeQueryVolumeInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the Query Volume Information request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE QueryVolumeInformationResponse;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVPrecompleteUserModeQueryVolumeInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    QueryVolumeInformationRequest  = &(DavWorkItem->QueryVolumeInformationRequest);
    QueryVolumeInformationResponse = &(DavWorkItem->QueryVolumeInformationResponse);

    //
    // If the operation was cancelled then we don't need to do the following.
    //
    if (!OperationCancelled) {

        //
        // Get the response items only if we succeeded in the user mode and if
        // we got the properties of all the files in the directory.
        //
        if (AsyncEngineContext->Status == STATUS_SUCCESS) {

            if (RxContext->Info.FsInformationClass == FileFsSizeInformation) {
                
                PFILE_FS_SIZE_INFORMATION FileFsSizeInfo = (PFILE_FS_SIZE_INFORMATION)RxContext->Info.Buffer;

                FileFsSizeInfo->BytesPerSector = DEFAULT_BYTES_PER_SECTOR;

                FileFsSizeInfo->SectorsPerAllocationUnit = DEFAULT_SECTORS_PER_ALLOCATION_UNIT;

                *(LONGLONG *)&FileFsSizeInfo->TotalAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->TotalSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                *(LONGLONG *)&FileFsSizeInfo->AvailableAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->AvailableSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            


            } else {
                
                PFILE_FS_FULL_SIZE_INFORMATION FileFsFullSizeInfo = (PFILE_FS_FULL_SIZE_INFORMATION)RxContext->Info.Buffer;
                
                ASSERT(RxContext->Info.FsInformationClass == FileFsFullSizeInformation);

                FileFsFullSizeInfo->BytesPerSector = DEFAULT_BYTES_PER_SECTOR;

                FileFsFullSizeInfo->SectorsPerAllocationUnit = DEFAULT_SECTORS_PER_ALLOCATION_UNIT;

                *(LONGLONG *)&FileFsFullSizeInfo->TotalAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->TotalSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                *(LONGLONG *)&FileFsFullSizeInfo->ActualAvailableAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->AvailableSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                FileFsFullSizeInfo->CallerAvailableAllocationUnits.LowPart = FileFsFullSizeInfo->ActualAvailableAllocationUnits.LowPart;
                FileFsFullSizeInfo->CallerAvailableAllocationUnits.HighPart = FileFsFullSizeInfo->ActualAvailableAllocationUnits.HighPart;

            }

        }

    } else {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //
    
    if (QueryVolumeInformationRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)QueryVolumeInformationRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (QueryVolumeInformationRequest->ShareName != NULL) {
    
        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)QueryVolumeInformationRequest->ShareName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }
    
EXIT_THE_FUNCTION:

    AsyncEngineContext->Status = NtStatus;

    return(TRUE);
}


BOOL
DavIsValidDate(
    PLARGE_INTEGER pFileTime
    )
/*++

Routine Description:

    This routine checks whether the date corresponding to the filetime is valid

Arguments:

    pFileTime - Time to be validated

Return Value:

    TRUE or FALSE.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER NtTime;

    PAGED_CODE();

    NtTime = *pFileTime;        
    
    ExSystemTimeToLocalTime( &NtTime, &NtTime );
    RtlTimeToTimeFields( &NtTime, &TimeFields );

    //
    //  Check the range of the date found in the time field record
    //
    if ((TimeFields.Year < 1980) || (TimeFields.Year > (1980 + 127))) {

        return FALSE;
    }
    
    return TRUE;
}


NTSTATUS
MRxDAVIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

   This routine checks a remote directory. Actually in webdav all we do is make sure this is coming from 
   our service which is indicated by the webdav signature string in the EAs. This gurantees
   us that our service has checked the path before we came here.

Arguments:

    RxContext - the RDBSS context
    DirectoryName - the directory needs to be checked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS    ntStatus = STATUS_UNSUCCESSFUL;
    PFILE_FULL_EA_INFORMATION Ea = NULL;

    if (RxContext->Create.EaLength) {
        
        Ea = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        for (;;)
        {
            if (!strcmp(Ea->EaName, EA_NAME_WEBDAV_SIGNATURE))
            {
                ntStatus = STATUS_SUCCESS;
                break;
            }
            else
            {
                if (!Ea->NextEntryOffset)
                {
                    break;
                }
                
                (ULONG_PTR) Ea += Ea->NextEntryOffset;
            }
        }
    }
    
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fsctl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file
    system objects.

Author:

    Yun Lin      [YunLin]      27-Oct-2000

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#include "webdav.h"

NTSTATUS
MrxDAVEfsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MrxDAVEfsControl(
      IN OUT PRX_CONTEXT RxContext
      );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVFsCtl)
#pragma alloc_text(PAGE, MrxDAVEfsControl)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVFsCtl(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;
    RxCaptureFcb;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVFsCtl: FsControlCode = %08lx\n", FsControlCode));

    switch (pLowIoContext->ParamsFor.FsCtl.MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_KERNEL_CALL    :
        switch (FsControlCode) {
        case FSCTL_ENCRYPTION_FSCTL_IO :
        case FSCTL_SET_ENCRYPTION      :
        case FSCTL_READ_RAW_ENCRYPTED  :
        case FSCTL_WRITE_RAW_ENCRYPTED :
        case FSCTL_SET_COMPRESSION     :
        case FSCTL_SET_SPARSE          :
        case FSCTL_QUERY_ALLOCATED_RANGES :
            Status = MrxDAVEfsControl(RxContext);
            break;

        default:
            Status =  STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
}


NTSTATUS
MrxDAVEfsControl(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine redirects an EFS FSCTL operation on a remote file to its local cache

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:
    
    IMPORTANT!!!
    We acquire the FCB exclusively in this routine. Its very critical that this
    routine has a single exit point. Need to remember this while modifying the
    file.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT pLowIoContext = NULL;
    ULONG FsControlCode = 0, EncryptionOperation = 0;
    PIRP TopIrp = NULL, irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    PDEVICE_OBJECT DeviceObject = NULL;
    PENCRYPTION_BUFFER EncryptionBuffer = NULL;
    BOOLEAN ShouldUpdateNameCache = FALSE, ExclusiveFcbAcquired = FALSE;
    KEVENT Event;
    RxCaptureFobx;
    RxCaptureFcb;

    PAGED_CODE();

    pLowIoContext = &RxContext->LowIoContext;
    FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;
    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
    DeviceObject = davSrvOpen->UnderlyingDeviceObject; 

    //
    // When we come here we do not acquire the FCB. The asserts below confirm
    // this.
    //
    ASSERT(RxIsFcbAcquiredExclusive(RxContext->pRelevantSrvOpen->pFcb) == FALSE);
    ASSERT(RxIsFcbAcquiredShared(RxContext->pRelevantSrvOpen->pFcb) == FALSE);

    //
    // Since we might be changing the attributes of the FCB, we acquire it
    // exclusive.
    //
    RxAcquireExclusiveFcbResourceInMRx(RxContext->pRelevantSrvOpen->pFcb);
    ExclusiveFcbAcquired = TRUE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("MrxDAVEfsControl: IRP = %x, capFcb = %x, capFobx = %x\n",
                 RxContext->CurrentIrp, capFcb, capFobx));

    //
    // We cannot encrypt a SYSTEM file.
    //
    if ((capFcb->Attributes & FILE_ATTRIBUTE_SYSTEM) &&
        !(capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControlrol: FILE_ATTRIBUTE_SYSTEM\n"));
        Status = STATUS_ACCESS_DENIED;
        goto EXIT_THE_FUNCTION;
    }

    if (FsControlCode == FSCTL_SET_ENCRYPTION || FsControlCode == FSCTL_ENCRYPTION_FSCTL_IO) {

        ULONG InputBufferLength = 0;

        EncryptionBuffer = (PENCRYPTION_BUFFER)RxContext->CurrentIrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        InputBufferLength = RxContext->CurrentIrpSp->Parameters.FileSystemControl.InputBufferLength;
        
        if (EncryptionBuffer == NULL) {
            DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControlrol: EncryptionBuffer == NULL\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

        //
        // The InputBufferLength should be atleast sizeof(ENCRYPTION_BUFFER).
        //
        if (InputBufferLength < sizeof(ENCRYPTION_BUFFER)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto EXIT_THE_FUNCTION;
        }

        try {
            if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
                ProbeForRead(EncryptionBuffer, InputBufferLength, sizeof(UCHAR));
            }
            EncryptionOperation = EncryptionBuffer->EncryptionOperation;
        } except(EXCEPTION_EXECUTE_HANDLER) {
              Status = STATUS_INVALID_USER_BUFFER;
              goto EXIT_THE_FUNCTION;
        }
    
    }

    if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        UNICODE_STRING FileName;

        if (FsControlCode == FSCTL_SET_ENCRYPTION) {
            switch (EncryptionOperation) {
            case FILE_SET_ENCRYPTION:
            case STREAM_SET_ENCRYPTION: 
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                ShouldUpdateNameCache = TRUE;

                MRxDAVGetFullDirectoryPath(RxContext,NULL,&FileName);

                if (FileName.Buffer != NULL) {
                    Status = MRxDAVCreateEncryptedDirectoryKey(&FileName);
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("MrxDAVEfsControl: Encrypt Directory. capFcb = %x\n",
                             capFcb));
                break;

            case FILE_CLEAR_ENCRYPTION:
            case STREAM_CLEAR_ENCRYPTION:
                capFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                ShouldUpdateNameCache = TRUE;
                
                MRxDAVGetFullDirectoryPath(RxContext,NULL,&FileName);

                if (FileName.Buffer != NULL) {
                    Status = MRxDAVRemoveEncryptedDirectoryKey(&FileName);
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("MrxDAVEfsControl: Decrypt Directory. capFcb = %x\n",
                             capFcb));
                break;

            default:
                Status = STATUS_NOT_SUPPORTED;
            }

            goto EXIT_THE_FUNCTION;

        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ERROR: MrxDAVEfsControl: FSCTL NOT supported. capFcb = %x, "
                         "FsControlCode = %x\n", capFcb, FsControlCode));
            Status = STATUS_NOT_SUPPORTED;
            goto EXIT_THE_FUNCTION;
        }
    }

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {
        Status = STATUS_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    KeInitializeEvent(&(Event), NotificationEvent, FALSE);

    irp = RxCeAllocateIrpWithMDL(DeviceObject->StackSize, FALSE, NULL);
    if (!irp) {
        DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControl/RxCeAllocateIrpWithMDL\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    
    irp->RequestorMode = KernelMode;
    irp->UserBuffer = RxContext->CurrentIrp->UserBuffer;
    irp->AssociatedIrp.SystemBuffer = RxContext->CurrentIrp->AssociatedIrp.SystemBuffer;

    if (RxContext->CurrentIrp->MdlAddress &&
        RxContext->CurrentIrp->MdlAddress->ByteCount != 0) {
        irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,
                                        RxContext->CurrentIrp->MdlAddress->ByteCount,
                                        FALSE,
                                        FALSE,
                                        NULL);
        if (!irp->MdlAddress) {
            DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControl/IoAllocateMdl\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked. This is where the function codes and the parameters are set.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = (UCHAR)RxContext->MajorFunction;
    irpSp->MinorFunction = (UCHAR)RxContext->MinorFunction;
    irpSp->FileObject = davSrvOpen->UnderlyingFileObject;
    irpSp->Flags = RxContext->CurrentIrpSp->Flags;
    irpSp->Parameters.FileSystemControl.OutputBufferLength = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.OutputBufferLength;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.InputBufferLength;
    irpSp->Parameters.FileSystemControl.FsControlCode = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.FsControlCode;
    irpSp->Parameters.FileSystemControl.Type3InputBuffer = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    IoSetCompletionRoutine(irp,
                           MrxDAVEfsControlCompletion, 
                           &Event,
                           TRUE,TRUE,TRUE);

    try {

        //
        // Save the TopLevel Irp.
        //
        TopIrp = IoGetTopLevelIrp();

        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);

        Status = IoCallDriver(DeviceObject,irp);

    } finally {

        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp);

    }

    if ((Status == STATUS_PENDING) || (Status == STATUS_SUCCESS)) {

        Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ERROR: MrxDAVEfsControl/KeWaitForSingleObject. Status = %08lx\n",
                         Status));
            goto EXIT_THE_FUNCTION;
        }

        Status = irp->IoStatus.Status;

        if ((Status == STATUS_SUCCESS) && (FsControlCode == FSCTL_SET_ENCRYPTION)) {
            
            DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FSCTL_SET_ENCRYPTION\n"));
            
            switch (EncryptionOperation) {

            case FILE_SET_ENCRYPTION:
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FILE_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                DavFcb->FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;

            case FILE_CLEAR_ENCRYPTION:
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FILE_CLEAR_ENCRYPTION\n"));
                capFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                DavFcb->FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;

            case STREAM_SET_ENCRYPTION: 
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: STREAM_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                DavFcb->FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;
            
            }
        
        }

        if ( (Status == STATUS_SUCCESS) && (FsControlCode == FSCTL_ENCRYPTION_FSCTL_IO) ) {
            
            PWEBDAV_FCB DavFcb = NULL;
            DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
            
            DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FSCTL_ENCRYPTION_FSCTL_IO\n"));
            
            switch (EncryptionOperation) {
            case STREAM_SET_ENCRYPTION: 
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: STREAM_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                DavFcb->FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;
            }
        
        }
    
    }

EXIT_THE_FUNCTION:

    //
    // If we modified the attributes, we need to update the name cache to
    // reflect this change.
    //
    if (Status == STATUS_SUCCESS && ShouldUpdateNameCache) {
        MRxDAVUpdateBasicFileInfoCache(RxContext, capFcb->Attributes, NULL);
    }

    if (ExclusiveFcbAcquired) {
        RxReleaseFcbResourceInMRx(RxContext->pRelevantSrvOpen->pFcb);
    }

    if (irp) {
        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }

        RxCeFreeIrp(irp);
    }

    return Status;
}


NTSTATUS
MrxDAVEfsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    //
    // Since this is an IRP Completion routine, this cannot be paged code.
    //
    
    if (Context != NULL) {
        KeSetEvent((PKEVENT )Context, 0, FALSE);
    }
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\infocach.h ===
typedef REDIR_STATISTICS   MRX_DAV_STATISTICS;
typedef PREDIR_STATISTICS  PMRX_DAV_STATISTICS;

extern MRX_DAV_STATISTICS MRxDAVStatistics;

VOID
MRxDAVCreateFileInfoCache(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               Status
    );

VOID
MRxDAVCreateFileInfoCacheWithName(
    PUNICODE_STRING            FileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_BASIC_INFORMATION    Basic,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    );

VOID
MRxDAVCreateBasicFileInfoCacheWithName(
    PUNICODE_STRING         OriginalFileName,
    PMRX_NET_ROOT           NetRoot,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    );

VOID
MRxDAVCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVCreateStandardFileInfoCacheWithName(
    PUNICODE_STRING            OriginalFileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateBasicFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateStandardFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize
    );

VOID
MRxDAVUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime
    );

VOID
MRxDAVUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic
    );

VOID
MRxDAVUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory
    );

BOOLEAN
MRxDAVIsFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    );
/*
// these file attributes may be different between streams on a file
ULONG StreamAttributes = FILE_ATTRIBUTE_COMPRESSED |
                         FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_SPARSE_FILE;
*/
BOOLEAN
MRxDAVIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    );

BOOLEAN
MRxDAVIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    );

NTSTATUS
MRxDAVGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext
    );

BOOLEAN
MRxDAVIsFileNotFoundCached(
    PRX_CONTEXT RxContext
    );

BOOLEAN
MRxDAVIsFileNotFoundCachedWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVCacheFileNotFound(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVCacheFileNotFoundWithName(
    PUNICODE_STRING  OriginalFileName,
    PMRX_NET_ROOT    NetRoot
    );

VOID
MRxDAVCacheFileNotFoundFromQueryDirectory(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\nvisible.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NVisible.h

Abstract:

    This module declares a number of flag variables that are essentially private
    to various modules but which are exposed so that they can be initialized from
    the registry and/or modified by fsctls. This should not be in precomp.h.

Revision History:

--*/

#ifndef _INVISIBLE_INCLUDED_
#define _INVISIBLE_INCLUDED_

extern ULONG MRxSmbNegotiateMask;  //controls which protocols are not negotiated

extern BOOLEAN MRxSmbDeferredOpensEnabled;
extern BOOLEAN MRxSmbOplocksDisabled;

#endif // _INVISIBLE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\infocach.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    infocach.c

Abstract:

    This module implements the name cache for file basic and standard information.

Author:

    Yun Lin      [YunLin]      13-Feburary-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVCacheFileNotFound)
#pragma alloc_text(PAGE, MRxDAVCacheFileNotFoundWithName)
#pragma alloc_text(PAGE, MRxDAVIsFileNotFoundCached)
#pragma alloc_text(PAGE, MRxDAVIsFileNotFoundCachedWithName)
#pragma alloc_text(PAGE, MRxDAVCreateFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVIsFileInfoCacheFound)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateBasicFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxDAVCreateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateStandardFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateFileInfoCacheFileSize)
#pragma alloc_text(PAGE, MRxDAVUpdateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileNotFoundCache)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCacheAll)
#pragma alloc_text(PAGE, MRxDAVInvalidateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateBasicFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxDAVInvalidateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateStandardFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateStandardFileInfoCacheStatus)
#endif

extern FAST_MUTEX MRxDAVFileInfoCacheLock;
MRX_DAV_STATISTICS MRxDAVStatistics;

VOID
MRxDAVCreateFileInfoCache(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               Status
    )
/*++

Routine Description:

   This routine creates name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the file information package including basic and standard information
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVCreateBasicFileInfoCache(RxContext,&FileInfo->BasicInformation,Status);
    MRxDAVCreateStandardFileInfoCache(RxContext,&FileInfo->StandardInformation,Status);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCreateFileInfoCache %wZ\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));
}

VOID
MRxDAVCreateFileInfoCacheWithName(
    PUNICODE_STRING            FileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_BASIC_INFORMATION    Basic,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the file information package including basic and standard information
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVCreateBasicFileInfoCacheWithName(FileName,NetRoot,Basic,Status);
    MRxDAVCreateStandardFileInfoCacheWithName(FileName,NetRoot,Standard,Status);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCreateFileInfoCacheWithName %wZ\n",FileName));
}


VOID
MRxDAVCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - the file basic information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot;

    PAGED_CODE();

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    MRxDAVCreateBasicFileInfoCacheWithName(OriginalFileName,NetRoot,Basic,Status);
}

VOID
MRxDAVCreateBasicFileInfoCacheWithName(
    PUNICODE_STRING         OriginalFileName,
    PMRX_NET_ROOT           NetRoot,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file basic information.

Arguments:

    OriginalFileName - the name of the file to cache the basic information
    NetRoot   - the Net Root that the file belongs to
    Basic     - the file basic information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    PFILE_BASIC_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Basic;
        NameCache->PriorStatus = Status;

        if (FileInfoCache->FileAttributes & ~FILE_ATTRIBUTE_NORMAL) {
            FileInfoCache->FileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        }

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileInformationCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create File Attrib cache : %x %wZ\n",Basic->FileAttributes,OriginalFileName));
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create File Attrib cache : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();
    
    MRxDAVCreateStandardFileInfoCacheWithName(OriginalFileName,NetRoot,Standard,Status);
}

VOID
MRxDAVCreateStandardFileInfoCacheWithName(
    PUNICODE_STRING            OriginalFileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Standard;

        NameCache->PriorStatus = Status;

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileInformationCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create Standard cache : %I64x %I64x %I64x %wZ\n",
                     ((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,
                     Standard->AllocationSize,
                     Standard->EndOfFile,
                     OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry as STATUS_OBJECT_NAME_NOT_FOUND
   for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    MRxDAVUpdateBasicFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
    MRxDAVUpdateStandardFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
}

VOID
MRxDAVUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    MRxDAVUpdateBasicFileInfoCacheStatus(RxContext,Status);
    MRxDAVUpdateStandardFileInfoCacheStatus(RxContext,Status);
}

VOID
MRxDAVUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update status basic    : %x %wZ\n",Status,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCache(RxContext);
    MRxDAVInvalidateStandardFileInfoCache(RxContext);
}

VOID
MRxDAVInvalidateFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCacheWithName(OriginalFileName,NetRoot);
    MRxDAVInvalidateStandardFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file basic information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateBasicFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file basic information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Invalid Baisc    cache : %wZ\n",OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    MRxDAVInvalidateStandardFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateStandardFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Invalid Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize
    )
/*++

Routine Description:

   This routine updates file size on the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        FileInfoCache->AllocationSize.QuadPart = FileSize->QuadPart;
        FileInfoCache->EndOfFile.QuadPart = FileSize->QuadPart;

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File size cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime
    )
/*++

Routine Description:

   This routine updates file attributs and last write time on the name cache entry
   for the file basic information.

Arguments:

    RxContext - the RDBSS context
    FileAttributes - new file attributes
    pLastWriteTime - address of file last write time

Return Value:

    none

--*/
{
    FILE_BASIC_INFORMATION Basic;

    Basic.ChangeTime.QuadPart = 0;
    Basic.CreationTime.QuadPart = 0;
    Basic.LastWriteTime.QuadPart = 0;
    Basic.LastAccessTime.QuadPart = 0;

    if (pLastWriteTime != NULL && pLastWriteTime->QuadPart != 0) {
        Basic.LastWriteTime = *pLastWriteTime;
    }

    Basic.FileAttributes = FileAttributes;

    MRxDAVUpdateBasicFileInfoCacheAll(RxContext,&Basic);
}

VOID
MRxDAVUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic - file basic information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;
    PFILE_BASIC_INFORMATION BasicFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        BasicFileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        if (Basic->CreationTime.QuadPart != 0) {
            BasicFileInfoCache->CreationTime = Basic->CreationTime;
        }

        if (Basic->LastAccessTime.QuadPart != 0) {
            BasicFileInfoCache->LastAccessTime = Basic->LastAccessTime;
        }

        if (Basic->LastWriteTime.QuadPart != 0) {
            BasicFileInfoCache->LastWriteTime = Basic->LastWriteTime;
        }

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                   ("Update File Attrib cache 2: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName));

        BasicFileInfoCache->FileAttributes = Basic->FileAttributes;

        if (BasicFileInfoCache->FileAttributes & ~FILE_ATTRIBUTE_NORMAL) {
            BasicFileInfoCache->FileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File Attrib cache 3: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName));
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File Attrib cache  : %I64X %I64X %wZ\n",BasicFileInfoCache->CreationTime,BasicFileInfoCache->LastAccessTime,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file standard information.

Arguments:

    RxContext   - the RDBSS context
    Standard    - file standard information
    IsDirectory - file is a directory

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION StandardFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        StandardFileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        if (Standard != NULL) {
            *StandardFileInfoCache = *Standard;
        } else {
            StandardFileInfoCache->Directory = IsDirectory;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Update Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

BOOLEAN
MRxDAVIsFileInfoCacheFound(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               *Status,
    PUNICODE_STRING                        OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - buffer to return file basic and standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    BOOLEAN CacheFound = FALSE;

    if (MRxDAVIsBasicFileInfoCacheFound(RxContext,&FileInfo->BasicInformation,Status,OriginalFileName)) {
        if (*Status == STATUS_SUCCESS) {
            if (MRxDAVIsStandardFileInfoCacheFound(RxContext,&FileInfo->StandardInformation,Status,OriginalFileName)) {
                CacheFound = TRUE;
            }
        } else {

            // if an error stored on the file basic information cache, return cache found
            CacheFound = TRUE;
        }
    }
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVIsFileInfoCacheFound %x %x %wZ\n",*Status,CacheFound,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    return CacheFound;
}

BOOLEAN
MRxDAVIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - buffer to return file basic information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    ULONG                   RootAttributes = 0;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound || *Status == RootStatus)) {

            // The name cache matches if it is not expired and the attributes matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Basic = *((PFILE_BASIC_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("   Found Basic     cache  : %x %wZ\n",Basic->FileAttributes,OriginalFileName));
            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("   Get File Attrib cache  : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    } else {
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("   No    Basic     cache  : %wZ\n",OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

BOOLEAN
MRxDAVIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - buffer to return file standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound || *Status == RootStatus)) {

            // The name cache matches if it is not expired and the status matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Standard = *((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("    Get Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

NTSTATUS
MRxDAVGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine looks for the status of the name cache entry of either file basic or standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - statu of the name cache if found, otherwise, STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtlBasic = &DavNetRoot->NameCacheCtlGFABasic;
    PNAME_CACHE_CONTROL     NameCacheCtlStandard = &DavNetRoot->NameCacheCtlGFAStandard;
    NTSTATUS                Status = STATUS_MORE_PROCESSING_REQUIRED;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtlBasic,OriginalFileName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired
        //
        NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS) {
            //
            // If the cache has not expired, return the previous status.
            //
            Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtlBasic);

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtlBasic, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("    Get Basic Status   : %x %wZ\n",Status,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtlBasic, NameCache);
        }
    } else {
        NameCache = RxNameCacheFetchEntry(NameCacheCtlStandard,OriginalFileName);

        if (NameCache != NULL) {
            RX_NC_CHECK_STATUS NameCacheStatus;
            //
            // Found it.  Now check entry for not expired
            //
            NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

            if (NameCacheStatus == RX_NC_SUCCESS) {
                //
                // If the cache has not expired, return the previous status.
                //
                Status = NameCache->PriorStatus;
                RxNameCacheOpSaved(NameCacheCtlStandard);

                // put the entry back to the active list without changing the expire time
                RxNameCacheActivateEntry(NameCacheCtlStandard, NameCache, 0, 0);
            } else {
                // put the entry back to the expire list
                RxNameCacheExpireEntry(NameCacheCtlStandard, NameCache);
            }
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return Status;
}

BOOLEAN
MRxDAVIsFileNotFoundCached(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine checks if the name cache entry exists as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    return MRxDAVIsFileNotFoundCachedWithName(OriginalFileName,NetRoot);
}

BOOLEAN
MRxDAVIsFileNotFoundCachedWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine checks if the name cache entry exists as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    BOOLEAN                 CacheFound = FALSE;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              //MRxDAVStatistics.SmbsReceived.LowPart
                              NameCache->Context);

        if ((NameCacheStatus == RX_NC_SUCCESS) &&
            (NameCache->PriorStatus == STATUS_OBJECT_NAME_NOT_FOUND)) {
            //
            // This is a match.  Return the old status, file info and
            // reactivate the entry but leave expiration time unchanged.
            //

            CacheFound = TRUE;
            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("MRxDAVIsFileNotFoundCached %wZ\n",OriginalFileName));

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

VOID
MRxDAVCacheFileNotFound(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    
    PAGED_CODE();

    MRxDAVCacheFileNotFoundWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVCacheFileNotFoundWithName(
    PUNICODE_STRING  OriginalFileName,
    PMRX_NET_ROOT    NetRoot
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileNotFoundCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);
    } else {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match

        if (NameCache != NULL) {
            NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            RxNameCacheActivateEntry(
                NameCacheCtl,
                NameCache,
                FileNotFoundCacheLifeTimeInSec,
                MRxDAVStatistics.SmbsReceived.LowPart);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCacheFileNotFound %wZ\n",OriginalFileName));
}

VOID
MRxDAVCacheFileNotFoundFromQueryDirectory(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PUNICODE_STRING         Template = &capFobx->UnicodeQueryTemplate;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

    if (NameCache != NULL) {
        if ((NameCache == NULL) &&
            (OriginalFileName->Length > sizeof(WCHAR))) {
            //
            // Do lookup now since we may have skipped it at entry.
            //
            NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);
            if (NameCache == NULL) {
                NameCache = RxNameCacheCreateEntry (
                                NameCacheCtl,
                                OriginalFileName,
                                TRUE);   // case insensitive match
            }
        }
        if (NameCache != NULL) {
            NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            RxNameCacheActivateEntry(
                NameCacheCtl,
                NameCache,
                FileNotFoundCacheLifeTimeInSec,
                MRxDAVStatistics.SmbsReceived.LowPart);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVInvalidateFileNotFoundCache %wZ\n",OriginalFileName));
}

VOID
MRxDAVInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    UNICODE_STRING          RenameName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("Invalidate FNF cache from rename %wZ\n", &RenameName));

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&RenameName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\innerio.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    InnerIo.c

Abstract:

    This module implements the read, write, and lockctrl routines for the 
    reflector.

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

typedef struct _DAV_IRPCOMPLETION_CONTEXT {
    KEVENT Event;
} DAV_IRPCOMPLETION_CONTEXT, *PDAV_IRPCOMPLETION_CONTEXT;


NTSTATUS
DavIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVBuildAsynchronousRequest)
#pragma alloc_text(PAGE, DavXxxInformation)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
DavIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    DeviceObject - The DAV Device Object.
    
    CalldownIrp - The IRP that was sent down.
    
    Context - The callback context.

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PDAV_IRPCOMPLETION_CONTEXT IrpCompletionContext = NULL;

    //
    // This is not Pageable code.
    //

    IrpCompletionContext = (PDAV_IRPCOMPLETION_CONTEXT)Context;

    if (CalldownIrp->PendingReturned){
        KeSetEvent( &IrpCompletionContext->Event, 0, FALSE );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
MRxDAVBuildAsynchronousRequest(
    IN PRX_CONTEXT RxContext,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    )
/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request (RxContext->MajorFunction) must be one of the following request 
    codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_DIRECTORY_CONTROL
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN (not yet implemented)


Arguments:

    RxContext - The RDBSS context.
    
    CompletionRoutine - The Irp CompletionRoutine.

Return Value:

    The return status of the operation.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG MajorFunction = RxContext->MajorFunction;
    RxCaptureFcb;
    PLOWIO_CONTEXT LowIoContext = &(RxContext->LowIoContext);
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PDEVICE_OBJECT DeviceObject =  davSrvOpen->UnderlyingDeviceObject; 
    PFILE_OBJECT FileObject = davSrvOpen->UnderlyingFileObject;
    LARGE_INTEGER ZeroAsLI;
    ULONG MdlLength = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVBuildAsynchronousRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVBuildAsynchronousRequest: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    AsyncEngineContext = (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0];
    
    IF_DEBUG {
        RxCaptureFobx;
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  
    }
    ASSERT (davSrvOpen->UnderlyingFileObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //
        // I cannot handled buffered_I/O devices. Sigh.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVBuildAsynchronousRequest: Buffered IO.\n",
                     PsGetCurrentThreadId()));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVBuildAsynchronousRequest: Length = %08lx, Offset "
                 "= %08lx.\n", PsGetCurrentThreadId(), 
                 LowIoContext->ParamsFor.ReadWrite.ByteCount,
                 (ULONG)LowIoContext->ParamsFor.ReadWrite.ByteOffset));
    
    ZeroAsLI.QuadPart = 0;

    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE); 
    if (!irp) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVBuildAsynchronousRequest/IoAllocateIrp.\n",
                     PsGetCurrentThreadId()));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked. This is where the function codes and the parameters are set.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = (UCHAR) MajorFunction;
    irpSp->FileObject = FileObject;
    
    {   
        BOOLEAN EnableCalls = CompletionRoutine != NULL;
        IoSetCompletionRoutine(irp,
                               CompletionRoutine, 
                               RxContext,
                               EnableCalls,
                               EnableCalls,
                               EnableCalls);
    }

    if ( (MajorFunction == IRP_MJ_READ) || (MajorFunction == IRP_MJ_WRITE) ) {
        
        BOOLEAN PagingIo;

        PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                                 LOWIO_READWRITEFLAG_PAGING_IO);

        if (PagingIo) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVBuildAsynchronousRequest: Paging IO.\n",
                         PsGetCurrentThreadId()));
        }

        //
        // For now, never paging I/O.
        //
        PagingIo = FALSE;
        
        // irp->Flags |= IRP_NOCACHE;

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //
        ASSERT (&irpSp->Parameters.Write.Key == &irpSp->Parameters.Read.Key);
        ASSERT (&irpSp->Parameters.Write.Length == &irpSp->Parameters.Read.Length);
        ASSERT (&irpSp->Parameters.Write.ByteOffset == &irpSp->Parameters.Read.ByteOffset);
        
        irpSp->Parameters.Read.Key = LowIoContext->ParamsFor.ReadWrite.Key;
        
        irpSp->Parameters.Read.ByteOffset.QuadPart = 
                                  LowIoContext->ParamsFor.ReadWrite.ByteOffset;
        
        irp->RequestorMode = KernelMode;
        
        irp->UserBuffer = RxLowIoGetBufferAddress(RxContext);

        MdlLength = RxContext->CurrentIrp->MdlAddress->ByteCount;
        
        if (PagingIo) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVBuildAsynchronousRequest: MdlLength = %08lx.\n",
                         PsGetCurrentThreadId(), MdlLength));
            irpSp->Parameters.Read.Length = MdlLength;
        } else {
            irpSp->Parameters.Read.Length = LowIoContext->ParamsFor.ReadWrite.ByteCount;
        }
    
    } else if (MajorFunction == IRP_MJ_FLUSH_BUFFERS) {

        //
        // Nothing else to do!!!
        //
        MdlLength = 0;
    
    } else {

        FILE_INFORMATION_CLASS FileInformationClass = 
                                        RxContext->Info.FileInformationClass;
        PVOID   Buffer = RxContext->Info.Buffer;
        PULONG  pLengthRemaining = &RxContext->Info.LengthRemaining;
        BOOLEAN Wait = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
        ASSERT( MajorFunction == IRP_MJ_DIRECTORY_CONTROL );
        irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
        irpSp->Parameters.QueryDirectory = 
                        RxContext->CurrentIrpSp->Parameters.QueryDirectory;
        ASSERT (
               (irpSp->Parameters.QueryDirectory.FileInformationClass == 
                FileInformationClass)
            && (irpSp->Parameters.QueryDirectory.Length == *pLengthRemaining)
        );
        irpSp->Flags = RxContext->CurrentIrpSp->Flags;
        irp->UserBuffer = Buffer;
        MdlLength = *pLengthRemaining;
        if (Wait) {
            irp->Flags |= IRP_SYNCHRONOUS_API;
        }
    
    }

    //
    // Build an MDL if necessary.
    //
    if (MdlLength != 0) {

        irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,
                                        MdlLength,
                                        FALSE,
                                        FALSE,
                                        NULL);
        if (!irp->MdlAddress) {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVBuildAsynchronousRequest/IoAllocateMdl.\n",
                         PsGetCurrentThreadId()));
            
            IoFreeIrp(irp);
            
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        
        MmBuildMdlForNonPagedPool(irp->MdlAddress);
    
    }

    //
    // Finally, return a pointer to the IRP.
    //
    AsyncEngineContext->CalldownIrp = irp;
    
    return STATUS_SUCCESS;
}


NTSTATUS
DavXxxInformation(
    IN const int xMajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    pFileObject - Supplies a pointer to the file object about which the 
                  requested information is returned.

    FsInformationClass - Specifies the type of information which should be
                         returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
                    returned about the file.  This buffer must not be pageable 
                    and must reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
                     information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
                      is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT DeviceObject;
    DAV_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG DummyReturnedLength;

    PAGED_CODE();

    if (ReturnedLength == NULL) {
        ReturnedLength = &DummyReturnedLength;
    }


    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)xMajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           DavIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    IF_DEBUG {
        ASSERT( (irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) );

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            ASSERT( (InformationClass == FileAllocationInformation)
                        || (InformationClass == FileEndOfFileInformation) );
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.QueryVolume.Length);


        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                                          == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT((PVOID)&irpSp->Parameters.QueryFile.FileInformationClass
                                          == (PVOID)&irpSp->Parameters.QueryVolume.FsInformationClass);

    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );


    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }


    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }


    if (Status == STATUS_SUCCESS) {
        *ReturnedLength = (ULONG)irp->IoStatus.Information;
    }

    IoFreeIrp(irp);
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\netroot.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating net roots for the WebDav
    miniredir.

Author:

    Rohan Kumar    [RohanK]    24-April-1999
    
Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVCreateVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVFinalizeVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeVNetRootFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeVNetRootFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVDereferenceNetRootContext(
    IN PWEBDAV_NET_ROOT DavNetRoot
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVUpdateNetRootState)
#pragma alloc_text(PAGE, MRxDAVCreateVNetRoot)
#pragma alloc_text(PAGE, MRxDAVCreateVNetRootContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeVNetRootCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeVNetRootCreateRequest)
#pragma alloc_text(PAGE, MRxDAVFinalizeNetRoot)
#pragma alloc_text(PAGE, MRxDAVExtractNetRootName)
#pragma alloc_text(PAGE, MRxDAVFinalizeVNetRoot)
#pragma alloc_text(PAGE, MRxDAVFinalizeVNetRootContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeVNetRootFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeVNetRootFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVDereferenceNetRootContext)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot
    )
/*++

Routine Description:

   This routine update the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

   if (pNetRoot->Context == NULL) {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
   } else {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
   }

   return STATUS_SUCCESS;
}


NTSTATUS
MRxDAVCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the 
   information required by the mini redirector.

Arguments:

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_V_NET_ROOT pVNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRxDeviceObject = NULL;
    PMRX_SRV_CALL pSrvCall = NULL;
    PMRX_NET_ROOT pNetRoot = NULL;
    BOOLEAN  SynchronousIo = FALSE;
    NTSTATUS ExNtStatus = STATUS_SUCCESS;
    HANDLE ExDeviceHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ExDeviceName;
    IO_STATUS_BLOCK IoStatusBlock;
    PKEY_VALUE_PARTIAL_INFORMATION DavKeyValuePartialInfo = NULL;
    PIO_STACK_LOCATION IrpSp = NULL;
    PFILE_OBJECT DavFileObject = NULL;
    PWCHAR NewFileName = NULL;
    ULONG NewFileNameLength = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateVNetRoot\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateVNetRoot: pVNetRoot = %08lx\n", 
                 PsGetCurrentThreadId(), pVNetRoot));

    RxContext = pCreateNetRootContext->RxContext;
    pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;
    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    UMRxDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;
    DavVNetRoot = MRxDAVGetVNetRootExtension(pVNetRoot);

    ASSERT(DavVNetRoot != NULL);
    ASSERT(NodeType(pNetRoot) == RDBSS_NTC_NETROOT);
    ASSERT(NodeType(pSrvCall) == RDBSS_NTC_SRVCALL);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: NetRootName = %wZ\n", 
                 PsGetCurrentThreadId(), pVNetRoot->pNetRoot->pNetRootName));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: VNetRoot = %08lx\n", 
                 PsGetCurrentThreadId(), pVNetRoot));
    
    //
    // Copy the LogonID in the MiniRedir's portion of the V_NET_ROOT.
    //
    DavVNetRoot->LogonID.LowPart = pVNetRoot->LogonId.LowPart;
    DavVNetRoot->LogonID.HighPart = pVNetRoot->LogonId.HighPart;
    DavVNetRoot->LogonIDSet = TRUE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));

    //
    // There are cases when we fail, we want the error which SMB returned to be
    // returned to the user. This is becuase SMB could have returned a more 
    // specific error like logon failure or something on the share where as we
    // return share not found. To enable this we return STATUS_BAD_NETWORK_PATH 
    // when the creation of netroot fails instead of STATUS_BAD_NETWORK_NAME 
    // because MUP will overwrite SMBs error with our error if we return 
    // STATUS_BAD_NETWORK_NAME. STATUS_BAD_NETWORK_NAME is a specif error which
    // implies that the share does not exist where as STATUS_BAD_NETWORK_PATH is
    // a more general error.
    //

    //
    // If the share name is a net root or a pipe, we reject it since SMB 
    // Mini-Redir is the only one that handles it.
    //
    if ( pNetRoot->Type == NET_ROOT_PIPE || pNetRoot->Type == NET_ROOT_MAILSLOT ) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot: Invalid NetRootType\n",
                     PsGetCurrentThreadId()));
        //
        // We set the following flag in the DavVNetRoot structure to TRUE. This 
        // is because when the finalize comes, we don't need to go to the 
        // usermode.
        //
        DavVNetRoot->createVNetRootUnSuccessful = TRUE;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_NAME;
        pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_NAME;
        goto EXIT_THE_FUNCTION;
    }

    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: SynchronousIo = %d\n",
                 PsGetCurrentThreadId(), SynchronousIo));
    
    //
    // We need to pass the server and share names to the user mode to check 
    // whether they actually exist. RxContext has 4 pointers that the mini-redirs 
    // can use. Here we use MRxContext[1]. We store a reference to the pVNetRoot
    // strucutre. MRxContext[0] is used to store a reference to the 
    // AsynEngineContext and this is done when the context gets created in the 
    // function UMRxCreateAsyncEngineContext.
    //
    RxContext->MRxContext[1] = pVNetRoot;
    
    //
    // We now need to go to the user mode and find out if this WebDav share
    // exists on the server.
    //
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT,
                                        MRxDAVCreateVNetRootContinuation,
                                        "MRxDAVCreateVNetRoot");
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));

        if (NtStatus == STATUS_ACCESS_DENIED ||
            NtStatus == STATUS_LOGON_FAILURE ||
            NtStatus == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
            pCreateNetRootContext->VirtualNetRootStatus = NtStatus;
        } else {
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        }

        //
        // Don't set the NetRootStatus here since it is a global data structure
        // shared among different VNetRoots (TS users). Failure on one VNetRoot
        // should not affects the NetRoot.
        //

        goto EXIT_THE_FUNCTION;
    }

    //
    // If we succeeded and the share is not a TAHOE share, nor an Office Web 
    // Server share, then we claim the share name. Otherwise we fail since the 
    // users intends to use the TAHOE specific features in Rosebud, or Office
    // specific features in Shell.
    //
    if ( !DavVNetRoot->isTahoeShare && !DavVNetRoot->isOfficeShare ) {
        pNetRoot->DeviceType = RxDeviceType(DISK);
        pNetRoot->Type = NET_ROOT_DISK;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
        pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
    } else {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "TAHOE or OFFICE Share\n", PsGetCurrentThreadId()));
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_NAME;
        pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_NAME;
    }

    if (pNetRoot->Context == NULL) {
        
        pNetRoot->Context = RxAllocatePoolWithTag(PagedPool,
                                                  sizeof(WEBDAV_NET_ROOT),
                                                  DAV_NETROOT_POOLTAG);

        if (pNetRoot->Context == NULL) {
            
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
            
            pCreateNetRootContext->NetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        
        } else {
            
            PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

            //
            // Refcount of 2, one is taken away at VNetRoot finalization, another one is taken
            // away at NetRoot finalization.
            //
            DavNetRoot->RefCount = 2;
            DavNetRoot->pRdbssNetRoot = pNetRoot;

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlGFABasic,
                                  sizeof(FILE_BASIC_INFORMATION),
                                  NameCacheMaxEntries);

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlGFAStandard,
                                  sizeof(FILE_STANDARD_INFORMATION),
                                  NameCacheMaxEntries);

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlFNF,
                                  0,
                                  NameCacheMaxEntries);

            pVNetRoot->Context2 = DavNetRoot;
            
            DavDbgTrace(DAV_TRACE_DAVNETROOT,
                        ("MRxDav allocates DavNetRoot %x %x %x 2\n",DavNetRoot,pNetRoot,pVNetRoot));
        
        }
    
    } else {
        
        PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

        pVNetRoot->Context2 = DavNetRoot;
        InterlockedIncrement(&DavNetRoot->RefCount);
        DavDbgTrace(DAV_TRACE_DAVNETROOT,
                    ("MRxDAVCreateVNetRoot ref DavNetRoot %x %x %x %d\n",DavNetRoot,pNetRoot,pVNetRoot,DavNetRoot->RefCount));
    
    }

    //
    // We return from here since the code below was written for accomodating the
    // exchange DAV Redir which was suppose to ship with Office 2000. Since that
    // project (LocalStore which included the Exchange Redir) has been canned,
    // (as of Dec 8th, 2000) we don't need to execute the code below any more. 
    // We will keep it around though, just in case.
    //
    goto EXIT_THE_FUNCTION;
    
    //
    // The Exchange Redir has been installed on the system. Now we need to find 
    // out if its loaded. This is an exchange share. If the exchange Redir is 
    // not installed, we claim the name.
    //

    DavKeyValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DavExchangeDeviceName;
    
    RtlInitUnicodeString( &(ExDeviceName), (PWCHAR)DavKeyValuePartialInfo->Data );

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(ExDeviceName),
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);

    ExNtStatus = NtOpenFile(&(ExDeviceHandle),
                            0,
                            &(ObjectAttributes),
                            &(IoStatusBlock),
                            0,
                            0);
    if (ExNtStatus != STATUS_SUCCESS) {
        //
        // This is an exchange share but the Exchange Redir is not installed.
        // We will handle this.
        //
        ExDeviceHandle = INVALID_HANDLE_VALUE;
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateVNetRoot. Exchange BUT No Redir\n",
                     PsGetCurrentThreadId()));
        pNetRoot->DeviceType = RxDeviceType(DISK);
        pNetRoot->Type = NET_ROOT_DISK;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
        pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    IrpSp = IoGetCurrentIrpStackLocation(RxContext->CurrentIrp);
    
    DavFileObject = IrpSp->FileObject;

    //
    // The NewFileNameLength is = ExchangeDeviceNameLength + PathName. The 
    // DavKeyValuePartialInfo->DataLength contains an extra 2 bytes for the 
    // \0 char.
    //
    NewFileNameLength = ( DavKeyValuePartialInfo->DataLength + 
                          DavFileObject->FileName.Length );

    //
    // If the first char is not a \, then we need to add another sizeof(WCHAR).
    //
    if (DavFileObject->FileName.Buffer[0] != L'\\') {
        NewFileNameLength += sizeof(WCHAR);
    }

    //
    // Allocate memory for the NewFileName.
    //
    NewFileName = ExAllocatePoolWithTag(PagedPool, NewFileNameLength, DAV_EXCHANGE_POOLTAG);
    if (NewFileName == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot/ExAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        pCreateNetRootContext->NetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(NewFileName, NewFileNameLength);

    //
    // Copy the new device name.
    //
    RtlCopyMemory(NewFileName,
                  DavKeyValuePartialInfo->Data,
                  DavKeyValuePartialInfo->DataLength);

    //
    // If the first char is not a \, then we need to copy it before we copy the
    // rest of the name.
    //
    if (DavFileObject->FileName.Buffer[0] != L'\\') {

        //
        // Copy the \ next.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength ),
                       L"\\",
                       sizeof(WCHAR) );

        //
        // Finally copy the PathName that was sent with this IRP.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength + sizeof(WCHAR) ),
                       DavFileObject->FileName.Buffer,
                       DavFileObject->FileName.Length );

    } else {
        
        //
        // Finally copy the PathName that was sent with this IRP.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength ),
                       DavFileObject->FileName.Buffer,
                       DavFileObject->FileName.Length );
    
    }

    //
    // Free the memory allocated in the FileObject's original filename buffer.
    //
    ExFreePool(DavFileObject->FileName.Buffer);

    //
    // Set the NewFileName in the FileObject.
    //
    DavFileObject->FileName.Buffer = NewFileName;
    DavFileObject->FileName.Length = (USHORT)NewFileNameLength;
    DavFileObject->FileName.MaximumLength = (USHORT)NewFileNameLength;

    //
    // Finally, set the status to STATUS_REPARSE so that the I/O manager will
    // call into the Exchange Redir.
    //
    pCreateNetRootContext->VirtualNetRootStatus = STATUS_REPARSE;
    pCreateNetRootContext->NetRootStatus = STATUS_REPARSE;

EXIT_THE_FUNCTION:

    //
    // Callback the RDBSS for resumption.
    //
    pCreateNetRootContext->Callback(pCreateNetRootContext);

    //
    // If we opened a handle to the exchange redir, we need to close it now.
    //
    if (ExDeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(ExDeviceHandle);
    }
    
    //
    // Map the error code to STATUS_PENDING since this triggers the 
    // synchronization mechanism in the RDBSS.
    //
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateVNetRoot\n", PsGetCurrentThreadId()));

    return STATUS_PENDING;
}


NTSTATUS
MRxDAVCreateVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This routine checks to see if the share for which a VNetRoot is being
    created exists or not.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation.
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateVNetRootContinuation\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateVNetRootContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                UMRX_ASYNCENGINE_ARGUMENTS,
                                MRxDAVFormatUserModeVNetRootCreateRequest,
                                MRxDAVPrecompleteUserModeVNetRootCreateRequest
                                );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateVNetRootContinuation with NtStatus ="
                 " %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeVNetRootCreateRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the VNetRoot create request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    PWCHAR ServerName = NULL, ShareName = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG ServerNameLengthInBytes = 0, NetRootNameLengthInBytes = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeVNetRootCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: AsyncEngineContext"
                 " = %08lx, RxContext = %08lx.\n", PsGetCurrentThreadId(),  
                 AsyncEngineContext, RxContext));

     CreateVNetRootRequest = &(WorkItem->CreateVNetRootRequest);

     //
     // We need to set the work item type.
     //
     WorkItem->WorkItemType = UserModeCreateVNetRoot;

    //
    // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
    // RxContext structure. This is done in the MRxDAVCreateVNetRoot function.
    //
    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    
    ASSERT(VNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: "
                 "VNetRoot = %08lx\n", PsGetCurrentThreadId(), VNetRoot));

    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    NetRoot = VNetRoot->pNetRoot;
    ASSERT(NetRoot != NULL);

    SrvCall = NetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);

    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext);

    //
    // Copy the LogonID in the CreateRequest buffer. The LogonId is in the 
    // MiniRedir's portion of the V_NET_ROOT.
    //
    CreateVNetRootRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    CreateVNetRootRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName,
                 SrvCall->pSrvCallName->Buffer,
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CreateVNetRootRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    CreateVNetRootRequest->ServerID = DavSrvCall->ServerID;
    
    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - SrvCall->pSrvCallName->Length);

    //
    // For '\0' at the end.
    //
    NetRootNameLengthInBytes += sizeof(WCHAR);
    
    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the NetRoot (Share) name.
    //
    ShareName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                     NetRootNameLengthInBytes);
    if (ShareName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ShareName,
                 JustTheNetRootName,
                 (NetRoot->pNetRootName->Length - SrvCall->pSrvCallName->Length));
    
    ShareName[( ( (NetRootNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CreateVNetRootRequest->ShareName = ShareName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: ShareName: "
                 "%ws\n", PsGetCurrentThreadId(), ShareName));
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(WorkItem->UserName[0] == L'\0' && WorkItem->Password[0] == L'\0');

    if (VNetRoot->pUserName && VNetRoot->pUserName->Length) {
        RtlCopyMemory(WorkItem->UserName,VNetRoot->pUserName->Buffer,VNetRoot->pUserName->Length);
    }

    if (VNetRoot->pPassword && VNetRoot->pPassword->Length) {
        RtlCopyMemory(WorkItem->Password,VNetRoot->pPassword->Buffer,VNetRoot->pPassword->Length);
    }

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeVNetRootCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the CreateVNetRoot request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;

    PAGED_CODE();

    CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);
    CreateVNetRootResponse = &(DavWorkItem->CreateVNetRootResponse);

    if (!OperationCancelled) {
        //
        // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
        // RxContext structure. This is done in the MRxDAVCreateVNetRoot
        // function.
        //
        VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
        DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
        ASSERT(DavVNetRoot != NULL);
    } else {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeVNetRootCreateRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }
    
    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (CreateVNetRootRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CreateVNetRootRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (CreateVNetRootRequest->ShareName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CreateVNetRootRequest->ShareName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (!OperationCancelled) {
        NtStatus = AsyncEngineContext->Status;
        if (NtStatus != STATUS_SUCCESS) {
            //
            // If the CreateVNetRoot failed in the usermode, we set the following
            // in the DavVNetRoot structure to TRUE. This is because when the 
            // finalize comes, we don't need to go to the usermode.
            //
            DavVNetRoot->createVNetRootUnSuccessful = TRUE;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest:"
                         " NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        } else {
            //
            // We would have figured out in the usermode if this share is a TAHOE
            // share or an Office Web Server share and whether this share allows 
            // PROPPATCH or not, and resporst available space or not
            //
            DavVNetRoot->isOfficeShare = CreateVNetRootResponse->isOfficeShare;
            DavVNetRoot->isTahoeShare = CreateVNetRootResponse->isTahoeShare;
            DavVNetRoot->fAllowsProppatch = CreateVNetRootResponse->fAllowsProppatch;
            DavVNetRoot->fReportsAvailableSpace = CreateVNetRootResponse->fReportsAvailableSpace;
        }
    }

EXIT_THE_FUNCTION:

    return(TRUE);
}


NTSTATUS
MRxDAVDereferenceNetRootContext(
    IN PWEBDAV_NET_ROOT DavNetRoot
    )
/*++

Routine Description:

    This routine dereferences the Webdav NetRoot instance and free it if the refcount reaches 0.
    
Arguments:

    DavNetRoot - The Webdav NetRoot.

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    if (DavNetRoot != NULL) {
        ULONG RefCount;

        RefCount = InterlockedDecrement(&DavNetRoot->RefCount);
        DavDbgTrace(DAV_TRACE_DAVNETROOT,
                    ("MRxDAVDereferenceNetRootContext %x %d\n",DavNetRoot,RefCount));

        if (RefCount == 0) {
            //
            // Free storage associated with all entries in the name caches.
            //
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlGFABasic);
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlGFAStandard);
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlFNF);
            
            //
            // Reset the Context so that no further reference can be made to this DavNetRoot
            //
            ASSERT(DavNetRoot->pRdbssNetRoot->Context == DavNetRoot);
            DavNetRoot->pRdbssNetRoot->Context = NULL;

            RxFreePool(DavNetRoot);
            DavDbgTrace(DAV_TRACE_DAVNETROOT,
                        ("MRxDav frees DavNetRoot %x\n",DavNetRoot));
        }
    }
    
    return STATUS_SUCCESS;
}

NTSTATUS
MRxDAVFinalizeNetRoot(
    IN PMRX_NET_ROOT pNetRoot,
    IN PBOOLEAN ForceDisconnect
    )
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - The Virtual NetRoot.

    ForceDisconnect - Disconnect is forced.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering UMRxFinalizeNetRoot!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: UMRxFinalizeNetRoot: pNetRoot = %08lx.\n", 
                 PsGetCurrentThreadId(), pNetRoot));
    
    DavDbgTrace(DAV_TRACE_DAVNETROOT,
                ("MRxDAVFinalizeNetRoot deref DavNetRoot %x %x\n",pNetRoot->Context,pNetRoot));
    
    MRxDAVDereferenceNetRootContext((PWEBDAV_NET_ROOT)pNetRoot->Context);

    return STATUS_SUCCESS;
}

VOID
MRxDAVExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:
    
    FilePathName - The filename that came in.
    
    SrvCall - The SrvCall strucutre created by RDBSS.
    
    NetRootName - Pointer to the netroot name.
    
    RestOfName - Pointer to the Rest of the name.

Return Value:

    none.

--*/
{
    UNICODE_STRING xRestOfName;
    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w) + length);
    PWCH wlow;

    PAGED_CODE();

    //
    // The netroot name starts after the SrvCall name.
    //
    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;

    //
    // Calculate the length of the NetRoot name.
    //
    for ( ; ; ) {
        if (w >= wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w != wlow) ){
#if ZZZ_MODE
            if (*(w - 1) == L'z') {
                w++;
                continue;
            }
#endif // if ZZZ_MODE
            break;
        }
        w++;
    }
    
    NetRootName->Length = NetRootName->MaximumLength = (USHORT)((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) {
        RestOfName = &xRestOfName;
    }
    
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVExtractNetRootName: FilePath = %wZ\n", 
                 PsGetCurrentThreadId(), FilePathName));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVExtractNetRootName: Srv = %wZ, Root = %wZ, "
                 "Rest = %wZ\n", PsGetCurrentThreadId(), 
                 SrvCall->pSrvCallName, NetRootName, RestOfName));

    return;
}


NTSTATUS
MRxDAVFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN ForceDisconnect
    )
/*++

Routine Description:

Arguments:

    pVNetRoot - The virtual net root which has to be finalized.

    ForceDisconnect - Disconnect is forced.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering UMRxFinalizeVNetRoot!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: UMRxFinalizeVNetRoot: NetRootName = %wZ\n", 
                 PsGetCurrentThreadId(), pVNetRoot->pNetRoot->pNetRootName));

    SrvCall = pVNetRoot->pNetRoot->pSrvCall;

    RxDeviceObject = SrvCall->RxDeviceObject;

    DavVNetRoot = MRxDAVGetVNetRootExtension(pVNetRoot);
    ASSERT(DavVNetRoot != NULL);

    //
    // If we created the SecurityClientContext, we need to delete it now. We 
    // don't need this when we go up to the usermode to finalize the VNetRoot
    // since we don't impersonate the client when doing this.
    //
    if (DavVNetRoot->SCAlreadyInitialized) {
        SeDeleteClientSecurity(&(DavVNetRoot->SecurityClientContext));
    }

    DavDbgTrace(DAV_TRACE_DAVNETROOT,
                ("MRxDAVFinalizeVNetRoot deref DavNetRoot %x %x %x\n",pVNetRoot->Context2,pVNetRoot->pNetRoot,pVNetRoot));
    MRxDAVDereferenceNetRootContext((PWEBDAV_NET_ROOT)pVNetRoot->Context2);
    pVNetRoot->Context2 = NULL;

    //
    // We need to make sure that the creation of this VNetRoot was successful.
    // If it was not, then we don't go to the usermode to finalize the 
    // PerUserEntry. Also, if the MiniRedir never got called during the 
    // creation of VNetRoot (possible in some failure case) then we should not
    // go to the user mode. If the MiniRedir never gets called LogonIDSet will
    // be FALSE. If the MiniRedir gets called this will be TRUE for sure.
    //
    if (DavVNetRoot->createVNetRootUnSuccessful || !DavVNetRoot->LogonIDSet) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: UMRxFinalizeVNetRoot. createVNetRootUnSuccessful\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeVNetRoot/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to send the VNetRoot to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pVNetRoot;
    
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT,
                                        MRxDAVFinalizeVNetRootContinuation,
                                        "MRxDAVFinalizeVNetRoot");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }
    
EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeVNetRoot with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDAVFinalizeVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
ORoutine Description:
                            
    This is the continuation routine which finalizes a VNetRoot.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeVNetRootContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeVNetRootContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeVNetRootFinalizeRequest,
                              MRxDAVPrecompleteUserModeVNetRootFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeVNetRootContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeVNetRootFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the VNetRoot finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL;
    ULONG ServerNameLengthInBytes = 0;
    PBYTE SecondaryBuff = NULL;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeVNetRootFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    ASSERT(VNetRoot != NULL);
    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    SrvCall = VNetRoot->pNetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);
    
    DavWorkItem->WorkItemType = UserModeFinalizeVNetRoot;

    DavFinalizeVNetRootRequest = &(DavWorkItem->FinalizeVNetRootRequest);

    //
    // Set the ServerID.
    //
    DavFinalizeVNetRootRequest->ServerID = DavSrvCall->ServerID;

    //
    // Set the LogonID.
    //
    DavFinalizeVNetRootRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    DavFinalizeVNetRootRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootFinalizeRequest: "
                 "LogonID.LowPart = %d, LogonID.HighPart = %d\n",
                 PsGetCurrentThreadId(), 
                 DavVNetRoot->LogonID.LowPart, DavVNetRoot->LogonID.HighPart));

    //
    // Set the Server name.
    //
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLengthInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeVNetRootFinalizeRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    DavFinalizeVNetRootRequest->ServerName = (PWCHAR)SecondaryBuff;
    
    wcscpy(DavFinalizeVNetRootRequest->ServerName, ServerName);

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeVNetRootFinalizeRequest "
                 "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeVNetRootFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize VNetRoot request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
     //
    // A FinalizeVNetRoot request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the FinalizeVNetRoot case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    DavFinalizeVNetRootRequest = &(WorkItem->FinalizeVNetRootRequest);
    
    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (DavFinalizeVNetRootRequest->ServerName != NULL) {
        
        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)DavFinalizeVNetRootRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootFinalizeRequestt/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest. "
                     "Finalize VNetRoot Failed!!!\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\openclos.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to 
    opening/closing of file/directories.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [rohank]      15-March-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVSyncIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

NTSTATUS
MRxDAVCreateContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVCloseSrvOpenContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

NTSTATUS
MRxDAVFormatUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

BOOL
MRxDAVPrecompleteUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVSyncXxxInformation)
#pragma alloc_text(PAGE, MRxDAVShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, MRxDAVSetLoud)
#pragma alloc_text(PAGE, MRxDAVCreate)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeCreateRequest)
#pragma alloc_text(PAGE, MRxDAVCreateContinuation)
#pragma alloc_text(PAGE, MRxDAVCollapseOpen)
#pragma alloc_text(PAGE, MRxDAVComputeNewBufferingState)
#pragma alloc_text(PAGE, MRxDAVTruncate)
#pragma alloc_text(PAGE, MRxDAVForcedClose)
#pragma alloc_text(PAGE, MRxDAVCloseSrvOpen)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeCloseRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeCloseRequest)
#pragma alloc_text(PAGE, MRxDAVCloseSrvOpenContinuation)
#endif

//
// The implementation of functions begins here.
//

#define MRXDAV_ENCRYPTED_DIRECTORY_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\EncryptedDirectories"

NTSTATUS
MRxDAVSyncIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    DeviceObject
    
    CalldownIrp
    
    Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;

    //
    // Since this is an IRP completion rotuine, this cannot be paged code.
    //

    if (CalldownIrp->PendingReturned){
        RxSignalSynchronousWaiter(RxContext);
    }
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


ULONG_PTR DummyReturnedLengthForXxxInfo;

NTSTATUS
MRxDAVSyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG_PTR ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FsInformationClass - Specifies the type of information which should be
                         returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
                    returned about the file.  This buffer must not be pageable 
                    and must reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
                     information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
                      is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE();

    if (ReturnedLength == NULL) {
        ReturnedLength = &(DummyReturnedLengthForXxxInfo);
    }

    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    ASSERT (DeviceObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp(DeviceObject->StackSize, TRUE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = MajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           MRxDAVSyncIrpCompletionRoutine,
                           RxContext,
                           TRUE,
                           TRUE,
                           TRUE);


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //
    IF_DEBUG {
        ASSERT((irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
               || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
               || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION));

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            //IF_LOUD_DOWNCALLS(MiniFileObject) {
            //    SetFileInfoInfo =  ((PFILE_END_OF_FILE_INFORMATION)Information)->EndOfFile.LowPart;
            //}
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length 
                                         == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length 
                                     == &irpSp->Parameters.QueryVolume.Length);
        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                           == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                         == &irpSp->Parameters.QueryVolume.FsInformationClass);
    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    KeInitializeEvent(&RxContext->SyncEvent,
                      NotificationEvent,
                      FALSE);

    try {
        TopIrp = IoGetTopLevelIrp();
        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp);
    }

    if (Status == (STATUS_PENDING)) {
        RxWaitSync(RxContext);
        Status = irp->IoStatus.Status;
    }

    if (Status == STATUS_SUCCESS) {
        *ReturnedLength = irp->IoStatus.Information;
    }

    IoFreeIrp(irp);
    
    return(Status);
}


NTSTATUS
MRxDAVShouldTryToCollapseThisOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PAGED_CODE();

    //
    // We do not collapse any SrvOpen. The idea is to have one SrvOpen per 
    // create. 
    //

    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVShouldTryToCollapseThisOpen!!!!\n",
                 PsGetCurrentThreadId()));
    
    return Status;
}


ULONG UMRxLoudStringTableSize = 0;
UNICODE_STRING UMRxLoudStrings[50];

VOID    
MRxDAVSetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    )
{
    ULONG i;
    UNICODE_STRING temp;

    PAGED_CODE();

    for (i=0; i < UMRxLoudStringTableSize; i++) {
        PUNICODE_STRING t = &(UMRxLoudStrings[i]);
        ((PBYTE)temp.Buffer) = ((PBYTE)s->Buffer) + s->Length - t->Length;
        temp.Length = t->Length;
        if (RtlEqualUnicodeString(&temp, t, TRUE)) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVSetLoud: %s Found %wZ from %wZ.\n", 
                         PsGetCurrentThreadId(), Msg, t, s));
            RxContext->LoudCompletionString = t;
            break;
        }
    }
}


NTSTATUS
MRxDAVCreate(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles create request for the DAV mini-redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreate!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreate: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATE,
                                        MRxDAVCreateContinuation,
                                        "MRxDAVCreate");
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreate with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


NTSTATUS
MRxDAVFormatUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the arguments of the create request which is being 
    sent to the user mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    PNT_CREATE_PARAMETERS CreateParameters;                       
    PDAV_USERMODE_CREATE_REQUEST CreateRequest = &(WorkItem->CreateRequest);
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = &(WorkItem->CreateResponse);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PBYTE SecondaryBuff = NULL;
    PWCHAR NetRootName = NULL, AlreadyPrefixedName = NULL;
    DWORD PathLen = 0, PathLenInBytes = 0, SdLength = 0;
    BOOL didIAllocateFileNameInfo = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeCreateRequest: AsyncEngineContext = "
                 "%08lx, RxContext = %08lx.\n", PsGetCurrentThreadId(),  
                 AsyncEngineContext, RxContext));

    CreateParameters = &(RxContext->Create.NtCreateParameters);

    //
    // Set the SecurityClientContext which is used in impersonating. 
    //
    MRxDAVGetSecurityClientContext();

    //
    // Copy the LogonID in the CreateRequest buffer. The LogonId is in the 
    // MiniRedir's portion of the V_NET_ROOT.
    //
    CreateRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    CreateRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    NetRootName = SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Buffer;
    
    AlreadyPrefixedName = SrvOpen->pAlreadyPrefixedName->Buffer;

    //
    // Allocate memory for the complete path name and copy it.
    // The CompletePathName = NetRootName + AlreadyPrefixedName. The extra two
    // bytes are for '\0' at the end.
    //
    PathLen = SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length;
    PathLen += SrvOpen->pAlreadyPrefixedName->Length;
    PathLen += sizeof(WCHAR);
    PathLenInBytes = PathLen;
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                PathLenInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeCreateRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    CreateRequest->CompletePathName = (PWCHAR)SecondaryBuff;

    RtlZeroMemory(CreateRequest->CompletePathName, PathLenInBytes);

    //
    // Copy the NetRootName.
    //
    RtlCopyMemory(SecondaryBuff,
                  NetRootName, 
                  SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length);

    //
    // Copy the AlreadyPrefixedName after the NetRootName to make the complete
    // path name.
    //
    RtlCopyMemory(SecondaryBuff + SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length, 
                  AlreadyPrefixedName, 
                  SrvOpen->pAlreadyPrefixedName->Length);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: CPN = %ws.\n",
                 PsGetCurrentThreadId(), CreateRequest->CompletePathName));


    //
    // If this is the first create, then we need to allocate the FileNameInfo
    // in the FCB. This is used in logging the delayed write failure.
    //
    if (DavFcb->FileNameInfoAllocated != TRUE) {
        
        DavFcb->FileNameInfo.Buffer = RxAllocatePoolWithTag(PagedPool,
                                                            PathLenInBytes,
                                                            DAV_FILEINFO_POOLTAG);
        if (DavFcb->FileNameInfo.Buffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ld: ERROR: MRxDAVFormatUserModeCreateRequest/"
                         "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DavFcb->FileNameInfo.Buffer, PathLenInBytes);
    
        RtlCopyMemory(DavFcb->FileNameInfo.Buffer,
                      CreateRequest->CompletePathName,
                      PathLenInBytes);

        DavFcb->FileNameInfo.Length = (USHORT)PathLenInBytes - sizeof(WCHAR);
        DavFcb->FileNameInfo.MaximumLength = (USHORT)PathLenInBytes;

        DavFcb->FileNameInfoAllocated = TRUE;

        didIAllocateFileNameInfo = TRUE;
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFormatUserModeCreateRequest: FileNameInfo = %wZ\n",
                     PsGetCurrentThreadId(), &(DavFcb->FileNameInfo)));

    }

    WorkItem->WorkItemType = UserModeCreate;

    //
    // Set the ServerID that was got during the CreateSrvCall operation.
    //
    ASSERT(RxContext->pRelevantSrvOpen->pVNetRoot->pNetRoot->pSrvCall->Context);
    DavSrvCall = (PWEBDAV_SRV_CALL)RxContext->pRelevantSrvOpen->pVNetRoot->
                                   pNetRoot->pSrvCall->Context;
    
    CreateRequest->ServerID = DavSrvCall->ServerID;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: ServerID = %d.\n",
                 PsGetCurrentThreadId(), CreateRequest->ServerID));

    CreateRequest->AllocationSize = CreateParameters->AllocationSize;
    
    CreateRequest->FileAttributes = CreateParameters->FileAttributes;
    
    CreateRequest->ShareAccess = CreateParameters->ShareAccess;
    
    CreateRequest->CreateDisposition = CreateParameters->Disposition;
    
    CreateRequest->EaBuffer = RxContext->Create.EaBuffer;
    
    CreateRequest->EaLength = RxContext->Create.EaLength;
    
    SdLength = CreateRequest->SdLength = RxContext->Create.SdLength;
    
    CreateRequest->ImpersonationLevel = CreateParameters->ImpersonationLevel;
    
    CreateRequest->SecurityFlags = 0;
    if (CreateParameters->SecurityContext != NULL) {
        
        if (CreateParameters->SecurityContext->SecurityQos != NULL) {
            
            if (CreateParameters->SecurityContext->
                    SecurityQos->ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {
                
                CreateRequest->SecurityFlags |= DAV_SECURITY_DYNAMIC_TRACKING;
            
            }
            
            if (CreateParameters->SecurityContext->SecurityQos->EffectiveOnly) {
                
                CreateRequest->SecurityFlags |= DAV_SECURITY_EFFECTIVE_ONLY;
            
            }
        
        }
    
    }
    
    CreateRequest->DesiredAccess = CreateParameters->DesiredAccess;
    
    CreateRequest->CreateOptions = CreateParameters->CreateOptions;

    if (AsyncEngineContext->FileInformationCached) {
        CreateRequest->FileInformationCached = TRUE;
        CreateResponse->BasicInformation = DavContext->CreateReturnedFileInfo->BasicInformation;
        CreateResponse->StandardInformation = DavContext->CreateReturnedFileInfo->StandardInformation;
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("MRxDAVFormatUserModeCreateRequest file info cached %x %x %x %x %ws\n",
                     CreateResponse->BasicInformation.FileAttributes,
                     CreateResponse->BasicInformation.CreationTime.HighPart,
                     CreateResponse->BasicInformation.CreationTime.LowPart,
                     CreateResponse->StandardInformation.EndOfFile.LowPart,
                     CreateRequest->CompletePathName));
    }

    CreateRequest->ParentDirInfomationCached = AsyncEngineContext->ParentDirInfomationCached;
    CreateRequest->ParentDirIsEncrypted = AsyncEngineContext->ParentDirIsEncrypted;

    if (AsyncEngineContext->FileNotExists) {
        CreateRequest->FileNotExists = TRUE;
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeCreateRequest with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    if (NtStatus != STATUS_SUCCESS) {

        if (CreateRequest->CompletePathName != NULL) {
            UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                    (PBYTE)CreateRequest->CompletePathName);
            CreateRequest->CompletePathName = NULL;
        }

        //
        // Free the FileNameInfo buffer only if it was allocated in this call.
        //
        if (DavFcb->FileNameInfo.Buffer != NULL && didIAllocateFileNameInfo) {
            RxFreePool(DavFcb->FileNameInfo.Buffer);
            DavFcb->FileNameInfo.Buffer = NULL;
            DavFcb->FileNameInfo.Length = 0;
            DavFcb->FileNameInfo.MaximumLength = 0;
            DavFcb->FileNameInfoAllocated = FALSE;
        }

    }
    
    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = NULL;
    PWEBDAV_CONTEXT DavContext = NULL;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PMRX_FCB Fcb = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = NULL;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest = NULL;
    HANDLE OpenHandle;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A Create operation can never be Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    CreateResponse = &(WorkItem->CreateResponse);
    CreateRequest = &(WorkItem->CreateRequest);

    //
    // If the operation is cancelled, then there is no guarantee that the FCB,
    // FOBX etc are still valid. All that we need to do is cleanup and bail.
    //
    if (!OperationCancelled) {
        SrvOpen = RxContext->pRelevantSrvOpen;
        davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
        Fcb = SrvOpen->pFcb;
        DavFcb = MRxDAVGetFcbExtension(Fcb);
    }

    NtStatus = AsyncEngineContext->Status;

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (CreateRequest->CompletePathName != NULL) {

        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest:"
                         "Open failed for file \"%ws\" with NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), CreateRequest->CompletePathName, 
                         NtStatus));
        }

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)CreateRequest->CompletePathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }

    //
    // Open didn't work. We can bail out now.
    //
    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the operation has been cancelled and we created a handle in the
    // usermode then we need to set callWorkItemCleanup to TRUE which will
    // land up closing this handle. In any case, if the operation has been 
    // cancelled, we can leave right away.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: "
                     "Operation Cancelled.\n", PsGetCurrentThreadId()));
        if (CreateResponse->Handle) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: "
                         "callWorkItemCleanup\n", PsGetCurrentThreadId()));
            WorkItem->callWorkItemCleanup = TRUE;
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to do the "handle to fileobject" association only if its a file.
    // If the create was for a directory, no handle would have been created in
    // the user mode.
    //
    if (!CreateResponse->StandardInformation.Directory) {

        OpenHandle = CreateResponse->Handle;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                     "OpenHandle = %08lx.\n", PsGetCurrentThreadId(), 
                     OpenHandle));


        DavFcb->isDirectory = FALSE;

        if ( (OpenHandle != NULL) ) {

            NtStatus = ObReferenceObjectByHandle(OpenHandle,
                                                 0L,
                                                 NULL,
                                                 KernelMode,
                                                 (PVOID *)&(davSrvOpen->UnderlyingFileObject),
                                                 NULL);

            if (NtStatus == STATUS_SUCCESS) {

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVPrecompleteUserModeCreateRequest: UFO(1) = %08lx\n",
                             PsGetCurrentThreadId(), davSrvOpen->UnderlyingFileObject));

                davSrvOpen->UnderlyingHandle = OpenHandle;

                davSrvOpen->UserModeKey = CreateResponse->UserModeKey;

                davSrvOpen->UnderlyingDeviceObject = 
                IoGetRelatedDeviceObject(davSrvOpen->UnderlyingFileObject);

                //
                // Copy the local file name into the FCB.
                //
                wcscpy(DavFcb->FileName, CreateResponse->FileName);
                wcscpy(DavFcb->Url, CreateResponse->Url);
                DavFcb->LocalFileIsEncrypted = CreateResponse->LocalFileIsEncrypted;

                MRxDAVGetSecurityClientContext();
                ASSERT(SecurityClientContext != NULL);
                RtlCopyMemory(&DavFcb->SecurityClientContext,
                              SecurityClientContext,
                              sizeof(SECURITY_CLIENT_CONTEXT));

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                             "LocalFileName = %ws.\n", PsGetCurrentThreadId(), 
                             DavFcb->FileName));

                //
                // We only get/create the file/dir on the first open. On 
                // subsequent opens, we do the create in the kernel itself since 
                // the file exists in the WinInet cache. This caching is used 
                // till the FCB for the file exists.
                //

                DavFcb->isFileCached = TRUE;

            } else {

                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "ObReferenceObjectByHandle: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));

                //
                // If we have a valid handle, then why should 
                // ObReferenceObjectByHandle fail?
                //
                DbgBreakPoint();

                ZwClose(OpenHandle);

                goto EXIT_THE_FUNCTION;

            }

            //
            // If "FILE_DELETE_ON_CLOSE" flag was specified as one of 
            // the CreateOptions, then we need to remember this and
            // delete this file on close.
            //
            if (CreateResponse->DeleteOnClose) {
                DavFcb->DeleteOnClose = TRUE;
            }

            //
            // If a new file has been created then we need to set the attributes
            // of this new file on close on the server.
            //
            if (CreateResponse->NewFileCreatedAndSetAttributes) {
                DavFcb->fFileAttributesChanged = TRUE;
            }

            //
            // This file exists on the server, but this create operation
            // has FILE_OVERWRITE_IF as its CreateDisposition. So, we 
            // can create this file locally overwrite the one on the 
            // server on close. We set DoNotTakeTheCurrentTimeAsLMT to
            // TRUE since the LMT has been just set on Create and we do
            // not need to set it to the current time on close.
            //
            if (CreateResponse->ExistsAndOverWriteIf) {
                DavFcb->FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            }

            //
            // If a new file or directory is created, we need to PROPPATCH the
            // time values on close. This is because we use the time values from
            // the client when the name cache entry is created for this new
            // file. The same time value needs to be on the server.
            //
            if (CreateResponse->PropPatchTheTimeValues) {
                DavFcb->fCreationTimeChanged = TRUE;
                DavFcb->fLastAccessTimeChanged = TRUE;
                DavFcb->fLastModifiedTimeChanged = TRUE;
            }

        } else {

            //
            // We don't have an OpenHandle for a file. This should only happen 
            // in case where the open is for read/setting sttributes of a file
            // or deleting/renaming a file. 
            //
            if (!CreateResponse->fPsuedoOpen) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: No OpenHandle\n"));
                DbgBreakPoint();
            }

            //
            // If "FILE_DELETE_ON_CLOSE" flag was specified as one of 
            // the CreateOptions, then we need to remember this and
            // delete this file on close.
            //
            if (CreateResponse->DeleteOnClose) {
                DavFcb->DeleteOnClose = TRUE;
            }
        }

    } else {

        //
        // This was a directory open.
        //
        DavFcb->isDirectory = TRUE;

        if (CreateResponse->DeleteOnClose) {
            DavFcb->DeleteOnClose = TRUE;
        }

        //
        // If a new directory has been created then we need to set the
        // attributes of this new file on close on the server.
        //
        if (CreateResponse->NewFileCreatedAndSetAttributes) {
            DavFcb->fFileAttributesChanged = TRUE;
        }

        //
        // If a new file or directory is created, we need to PROPPATCH the
        // time values on close. This is because we use the time values from
        // the client when the name cache entry is created for this new
        // file. The same time value needs to be on the server.
        //
        if (CreateResponse->PropPatchTheTimeValues) {
            DavFcb->fCreationTimeChanged = TRUE;
            DavFcb->fLastAccessTimeChanged = TRUE;
            DavFcb->fLastModifiedTimeChanged = TRUE;
        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        RxContext->Create.ReturnedCreateInformation = (ULONG)WorkItem->Information;

        *(DavContext->CreateReturnedFileInfo) = CreateResponse->CreateReturnedFileInfo;

        capFcb->Attributes = CreateResponse->CreateReturnedFileInfo.BasicInformation.FileAttributes;

        if ((capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            ((RxContext->Create.ReturnedCreateInformation == FILE_CREATED) || 
             (RxContext->Create.ReturnedCreateInformation == FILE_OVERWRITTEN))) {
            //
            // The encryption user information is added to the file. This
            // information need to be sent to the server even if the file
            // itself is created empty. We set DoNotTakeTheCurrentTimeAsLMT to
            // TRUE since the LMT has been just set on Create and we do not
            // need to set it to the current time on close.
            //
            DavFcb->FileWasModified = TRUE;
            DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            DavFcb->fFileAttributesChanged = TRUE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVPrecompleteUserModeCreateRequest: Encrypted file/dir was created %x %x %x\n",DavFcb,Fcb,((PFCB)Fcb)->Attributes));
        }

        if (capFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
                //
                // We update the registry if the directory has been encrypted
                // by someone else.
                //
                NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DavFcb->FileNameInfo);
            } else {
                //
                // Query the registry to see if the directory should be encrypted.
                //
                NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DavFcb->FileNameInfo);
                if (NtStatus == STATUS_SUCCESS) {
                    capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                    NtStatus = STATUS_SUCCESS;
                }
            }
        }

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("MRxDAVPrecompleteUserModeCreateRequest file info %x %x %x %x %x %x %ws\n",
                     capFcb->Attributes,
                     CreateResponse->BasicInformation.CreationTime.HighPart,
                     CreateResponse->BasicInformation.CreationTime.LowPart,
                     CreateResponse->StandardInformation.EndOfFile.LowPart,
                     DavFcb,
                     Fcb,
                     DavFcb->FileName));

    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return TRUE;
}


NTSTATUS
MRxDAVCreateContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for the create operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo = NULL;
    PNT_CREATE_PARAMETERS NtCreateParameters = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeFileName;
    PWCHAR NtFileName = NULL;
    BOOL isFileCached = FALSE, isVNRInitialized = FALSE, didIAllocateFcbResource = FALSE;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    ULONG Disposition = RxContext->Create.NtCreateParameters.Disposition;
    BOOLEAN CacheFound = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT, 
                ("%ld: MRxDAVCreateContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateContinuation: Attempt to open: %wZ\n",
                 PsGetCurrentThreadId(), 
                 GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

    NtCreateParameters = &(RxContext->Create.NtCreateParameters);

    if (MRxDAVIsFileNotFoundCached(RxContext)) {
        
        DavContext->AsyncEngineContext.FileNotExists = TRUE;

        if ( !( (Disposition==FILE_CREATE) || (Disposition==FILE_OPEN_IF) ||
                (Disposition==FILE_OVERWRITE_IF) || (Disposition==FILE_SUPERSEDE) ) ) {
            //
            // If file does not exist on the server and we're not going to
            // create it, no further operation is necessary.
            //
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVCreateContinuation file not found %wZ\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }
    
    }
    
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot->Context; 
    
    isFileCached = DavFcb->isFileCached;

    //
    // We need to initialize the resource that is used to synchronize the
    // "read-modify-write" sequence if its not been done already.
    //
    if (DavFcb->DavReadModifyWriteLock == NULL) {

        //
        // Allocate memory for the resource.
        //
        DavFcb->DavReadModifyWriteLock = RxAllocatePoolWithTag(NonPagedPool,
                                                               sizeof(ERESOURCE),
                                                               DAV_READWRITE_POOLTAG);
        if (DavFcb->DavReadModifyWriteLock == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxAllocatePoolWithTag\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }
    
        didIAllocateFcbResource = TRUE;

        //
        // Now that we have allocated memory, we need to initialize it.
        //
        ExInitializeResourceLite(DavFcb->DavReadModifyWriteLock);
    
    }

    //
    // If we have a V_NET_ROOT whose LogonID has not been initialized, we need
    // to go to the user mode to create an entry for the user, in case this
    // new V_NET_ROOT has different user credentials than the one that opened
    // this file. We need to do this even if the file is cached since the user
    // that opened the file could be different from the current user. Its 
    // possible for multiple V_NET_ROOTS to be associate with the same FCB since 
    // FCB is associated with a NET_ROOT.
    //
    isVNRInitialized = DavVNetRoot->LogonIDSet;
    
    //
    // Since we set the LogonId during the creation of the V_NET_ROOT, this
    // should always be TRUE.
    //
    ASSERT(isVNRInitialized == TRUE);

    //
    // We can look at the FCB and figure out if this file was already opened
    // and cached in the WinInet cache. If it was, then we already have the
    // local name of the cached file in the FCB. All we need to do is open
    // a handle to the file with the create options specified by the caller.
    //
    if ( !isFileCached || !isVNRInitialized ) {
        
        if ((NtCreateParameters->Disposition == FILE_CREATE) &&
            (NtCreateParameters->FileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
            (NtCreateParameters->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            //
            // Remove the Encryption flag if creating a SYSTEM file.
            //
            NtCreateParameters->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
        }
        
        CreateReturnedFileInfo = RxAllocatePoolWithTag(PagedPool, 
                                                       sizeof(DAV_USERMODE_CREATE_RETURNED_FILEINFO),
                                                       DAV_FILEINFO_POOLTAG);
        if (CreateReturnedFileInfo == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(CreateReturnedFileInfo, sizeof(DAV_USERMODE_CREATE_RETURNED_FILEINFO));
        DavContext->CreateReturnedFileInfo = CreateReturnedFileInfo;

        CacheFound = MRxDAVIsFileInfoCacheFound(RxContext,
                                                CreateReturnedFileInfo,
                                                &(NtStatus),
                                                NULL);

        if (CacheFound) {

            //
            // If it exists in the cache, we perform a few checks before 
            // succeeding the create.
            //

            //
            // If the FileAttributes had the READ_ONLY bit set, then these
            // cannot be TRUE.
            // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
            //    FILE_OVERWRITE or FILE_SUPERSEDE. 
            // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
            // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
            //    FILE_WRITE_DATA or FILE_APPEND_DATA.
            // This is because these intend to overwrite the existing file.
            //
            if ( (CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) &&
                 ( (NtCreateParameters->Disposition == FILE_OVERWRITE)          ||
                   (NtCreateParameters->Disposition == FILE_OVERWRITE_IF)       ||
                   (NtCreateParameters->Disposition == FILE_SUPERSEDE)          ||
                   (NtCreateParameters->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
                   (NtCreateParameters->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: ReadOnly & ObjectMismatch\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_ACCESS_DENIED;
                goto EXIT_THE_FUNCTION;
            }

            //
            // We return failure if FILE_CREATE was specified since the file
            // already exists.
            //
            if (NtCreateParameters->Disposition == FILE_CREATE) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: FILE_CREATE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_OBJECT_NAME_COLLISION;
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the file is a directory and the caller supplied 
            // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
            // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
            // then we return STATUS_ACCESS_DENIED.
            //
            
            if ( (NtCreateParameters->CreateOptions & FILE_DIRECTORY_FILE) &&
                 !(CreateReturnedFileInfo->StandardInformation.Directory) )   {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: File & FILE_DIRECTORY_FILE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_NOT_A_DIRECTORY;
                goto EXIT_THE_FUNCTION;
            }

            if ( (NtCreateParameters->CreateOptions & FILE_NON_DIRECTORY_FILE) &&
                 (CreateReturnedFileInfo->StandardInformation.Directory) )   {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: Directory & FILE_NON_DIRECTORY_FILE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_FILE_IS_A_DIRECTORY;
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the delete is for a directory and the path is of the form
            // \\server\share then we return STATUS_ACCESS_DENIED. This is
            // because we do not allow a client to delete a share on the server.
            // If the path is of the form \\server\share then the value of
            // SrvOpen->pAlreadyPrefixedName->Length is 0.
            //
            if ( (CreateReturnedFileInfo->StandardInformation.Directory) &&
                 (SrvOpen->pAlreadyPrefixedName->Length == 0) &&
                 ( (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) ||
                   (NtCreateParameters->DesiredAccess & DELETE) ) ) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: ServerShareDelete\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_ACCESS_DENIED;
                goto EXIT_THE_FUNCTION;
            }

            if ((NtCreateParameters->DesiredAccess & DELETE ||
                 NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) &&
                CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // If it is a open for directory deletion, we want to make sure
                // no files are under the directory before return success.
                //
                CacheFound = FALSE;
            } else {
                DavContext->AsyncEngineContext.FileInformationCached = TRUE;
            }
        }

        //
        // We short circuit the open in kernel under the following conditions.
        // 1. If the file is in the name cache and open is for a directory.
        // 2. The file is NOT encrypted. This is because when we short circuit
        //    the open, we do not create a local file and hence no local file
        //    handle and no underlyingdeviceobject. This is needed by some of
        //    the FSCTLs that are issued against the EFS files. Hence we skip
        //    short circuiting them.
        // 3. A file with desire access of delete or read attributes.
        //
        
        if (CacheFound &&
            ((CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
             (NtCreateParameters->Disposition == FILE_OPEN) &&
             !(NtCreateParameters->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)) &&
             !(CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED))) {

            if (CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                DavFcb->isDirectory = TRUE;
            }

            //
            // If this Create was with FILE_DELETE_ON_CLOSE, we need to set this
            // information in the FCB since we'll need to DELETE this file on 
            // Close.
            //
            if (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) {
                DavFcb->DeleteOnClose = TRUE;
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Pseudo Open: %wZ\n",
                         PsGetCurrentThreadId(), 
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

        } else {

            UNICODE_STRING ParentDirName;
            SHORT i;
            FILE_BASIC_INFORMATION BasicInformation;
            PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Usermode Open: %wZ\n",
                         PsGetCurrentThreadId(),
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

            if (FileName->Length > 0) {

                //
                // Try to get the parent directory information from cache so that we don't
                // have to query the server.
                //

                for ( i = ( (FileName->Length / sizeof(WCHAR)) - 1 ); i >= 0; i-- ) {
                    if (FileName->Buffer[i] == L'\\') {
                        break;
                    }
                }

                //
                // Only if we found a wack will i be > 0. If we did not find
                // a wack (==> i == -1), it means that the parent directory was
                // not specified in the path. Hence we do not perform the check
                // below.
                //
                if (i > 0) {

                    ParentDirName.Length = (i * sizeof(WCHAR));
                    ParentDirName.MaximumLength = (i * sizeof(WCHAR));
                    ParentDirName.Buffer = FileName->Buffer;
    
                    if (MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInformation,&NtStatus,&ParentDirName)) {
                        
                        DavContext->AsyncEngineContext.ParentDirInfomationCached = TRUE;
                        
                        DavContext->AsyncEngineContext.ParentDirIsEncrypted = BooleanFlagOn(BasicInformation.FileAttributes,FILE_ATTRIBUTE_ENCRYPTED);
    
                        DavDbgTrace(DAV_TRACE_INFOCACHE,
                                   ("MRxDAVCreateContinuation parent dir found %d %wZ\n",
                                     DavContext->AsyncEngineContext.ParentDirIsEncrypted,
                                     &ParentDirName));
    
                    } else {
                        
                        NtStatus = MRxDAVGetFullParentDirectoryPath(RxContext, &ParentDirName);
                        if (NtStatus != STATUS_SUCCESS) {
                            goto EXIT_THE_FUNCTION;
                        }
    
                        if (ParentDirName.Buffer != NULL) {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&ParentDirName);
                            if (NtStatus == STATUS_SUCCESS) {
                                DavContext->AsyncEngineContext.ParentDirInfomationCached = TRUE;
                                DavContext->AsyncEngineContext.ParentDirIsEncrypted = TRUE;
                            }
                        }

                    }

                }

            }

            //
            // If the file is not in the name cache we have to send the request to the webclient
            //
            NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                             UMRX_ASYNCENGINE_ARGUMENTS,
                                             MRxDAVFormatUserModeCreateRequest,
                                             MRxDAVPrecompleteUserModeCreateRequest
                                             );

            ASSERT(NtStatus != STATUS_PENDING); 

            switch (NtStatus) {
            case  STATUS_SUCCESS:
                MRxDAVInvalidateFileNotFoundCache(RxContext);
                MRxDAVCreateFileInfoCache(RxContext,CreateReturnedFileInfo,STATUS_SUCCESS);
                break;

            case STATUS_OBJECT_NAME_NOT_FOUND:
                MRxDAVCacheFileNotFound(RxContext);
                MRxDAVInvalidateFileInfoCache(RxContext);
                break;

            default:
                //
                // Invalid the name based file not found cache if other error
                // happens.
                //
                MRxDAVInvalidateFileInfoCache(RxContext);
                MRxDAVInvalidateFileNotFoundCache(RxContext);
            }
        
        }
    
    } else {

        ULONG SizeInBytes;
        ACCESS_MASK DesiredAccess = 0;

        //
        // If the FileAttributes had the READ_ONLY bit set, then these
        // cannot be TRUE.
        // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
        //    FILE_OVERWRITE or FILE_SUPERSEDE. 
        // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
        // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
        //    FILE_WRITE_DATA or FILE_APPEND_DATA.
        // This is because these intend to overwrite the existing file.
        //
        if ( (Fcb->Attributes & FILE_ATTRIBUTE_READONLY) &&
             ( (NtCreateParameters->Disposition == FILE_OVERWRITE)          ||
               (NtCreateParameters->Disposition == FILE_OVERWRITE_IF)       ||
               (NtCreateParameters->Disposition == FILE_SUPERSEDE)          ||
               (NtCreateParameters->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
               (NtCreateParameters->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): ReadOnly & ObjectMismatch\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_ACCESS_DENIED;
            goto EXIT_THE_FUNCTION;
        }

        //
        // We return failure if FILE_CREATE was specified since the file
        // already exists.
        //
        if (NtCreateParameters->Disposition == FILE_CREATE) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): FILE_CREATE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_OBJECT_NAME_COLLISION;
            goto EXIT_THE_FUNCTION;
        }
        
        //
        // If the file is a directory and the caller supplied 
        // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
        // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
        // then we return STATUS_ACCESS_DENIED.
        //

        if ( (NtCreateParameters->CreateOptions & FILE_DIRECTORY_FILE) &&
             !(DavFcb->isDirectory) )   {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): File & FILE_DIRECTORY_FILE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_NOT_A_DIRECTORY;
            goto EXIT_THE_FUNCTION;
        }

        if ( (NtCreateParameters->CreateOptions & FILE_NON_DIRECTORY_FILE) &&
             (DavFcb->isDirectory) )   {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): Directory & FILE_NON_DIRECTORY_FILE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_FILE_IS_A_DIRECTORY;
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the delete is for a directory and the path is of the form
        // \\server\share then we return STATUS_ACCESS_DENIED. This is
        // because we do not allow a client to delete a share on the server.
        // If the path is of the form \\server\share then the value of
        // SrvOpen->pAlreadyPrefixedName->Length is 0.
        //
        if ( (DavFcb->isDirectory) &&
             (SrvOpen->pAlreadyPrefixedName->Length == 0) &&
             ( (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) ||
               (NtCreateParameters->DesiredAccess & DELETE) ) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): ServerShareDelete\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_ACCESS_DENIED;
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to do the create only if its a file. If we are talking about 
        // a directory, then no create is needed.
        //
        if ( !DavFcb->isDirectory ) {

            //
            // We have a cached copy of the file which hasn't been closed. All we
            // need to do is call ZwCreateFile on it.
            //

            //
            // Create an NT path name for the cached file. This is used in the 
            // ZwCreateFile call below. If c:\foo\bar is the DOA path name,
            // the NT path name is \??\c:\foo\bar. 
            //

            SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
            NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
            if (NtFileName == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation/RxAllocatePool: Error Val"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(NtFileName, SizeInBytes);

            wcscpy( NtFileName, L"\\??\\" );
            wcscpy( &(NtFileName[4]), DavFcb->FileName );

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: NtFileName = %ws\n",
                         PsGetCurrentThreadId(), NtFileName));

            RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

            //
            // IMPROTANT!!!
            // We use OBJ_KERNEL_HANDLE below for the following reason. While
            // firing up a word file from explorer, I noticed that the create
            // below was happening in one process (A) and the close for the handle
            // which is stored in the SrvOpen extension came down in another 
            // process (B). This could happen if the process that is closing the 
            // handle (B) duplicated the handle created by A. By using OBJ_KERNEL_HANDLE
            // the handle can be closed by any process.
            //

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeFileName,
                                       (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                                       0,
                                       NULL);

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: DesiredAccess = %08lx,"
                         " FileAttributes = %08lx, ShareAccess = %d, Disposition"
                         " = %d, CreateOptions = %08lx\n",
                         PsGetCurrentThreadId(),
                         NtCreateParameters->DesiredAccess,
                         NtCreateParameters->FileAttributes,
                         NtCreateParameters->ShareAccess,
                         NtCreateParameters->Disposition,
                         NtCreateParameters->CreateOptions));

            //
            // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
            // checks this for us. Moreover, we delay the close after the final 
            // close happens and this could cause problems. Consider the scenario.
            // 1. Open with NO share access.
            // 2. We create a local handle with this share access.
            // 3. The app closes the handle. We delay the close and keep the local
            //    handle.
            // 4. Another open comes with any share access. This will be 
            //    conflicting share access since the first one was done with no
            //    share access. This should succeed since the previous open has 
            //    been closed from the app and the I/O systems point of view.
            // 5. It will not if we have created the local handle with the share
            //    access which came with the first open.
            // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
            // the local handle.
            //

            //
            // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
            // the user specified, becuase we don't want the underlying file
            // system to create another cache map. This way all the I/O that comes
            // to us will directly go to the disk. BUG 128843 in the Windows RAID
            // database explains some deadlock scenarios that could happen with 
            // PagingIo if we don't do this. Also since we supply the 
            // FILE_NO_INTERMEDIATE_BUFFERING option we filter out the
            // FILE_APPEND_DATA from the DesiredAccess flags since the underlying
            // filesystem expects this.
            //

            //
            // We also always create the file with DesiredAccess ORed with
            // FILE_WRITE_DATA if either FILE_READ_DATA or FILE_EXECUTE was
            // specified because there can be situations where we get write
            // IRPs on a FILE_OBJECT which was not opened with Write Access
            // and was only opened with FILE_READ_DATA or FILE_EXECUTE. This
            // is BUG 284557. To get around the problem, we do this.
            //

            DesiredAccess = (NtCreateParameters->DesiredAccess & ~(FILE_APPEND_DATA));
            if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
                DesiredAccess |= (FILE_WRITE_DATA);
            }

            NtStatus = ZwCreateFile(&(FileHandle),
                                    DesiredAccess,
                                    &(ObjectAttributes),
                                    &(IoStatusBlock),
                                    &(NtCreateParameters->AllocationSize),
                                    NtCreateParameters->FileAttributes,
                                    FILE_SHARE_VALID_FLAGS,
                                    NtCreateParameters->Disposition,
                                    (NtCreateParameters->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                                    RxContext->Create.EaBuffer,
                                    RxContext->Create.EaLength);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVCreateContinuation/ZwCreateFile: "
                             "Error Val = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: FileHandle = %08lx, "
                         "Process = %08lx, SrvOpen = %08lx, davSrvOpen = %08lx\n",
                         PsGetCurrentThreadId(), FileHandle, PsGetCurrentProcess(),
                         SrvOpen, davSrvOpen));

            //
            // On the final close we check this to figure out where the close of the
            // handle should occur.
            //
            davSrvOpen->createdInKernel = TRUE;

            NtStatus = ObReferenceObjectByHandle(
                                  FileHandle,
                                  0L,
                                  NULL,
                                  KernelMode,
                                  (PVOID *)&(davSrvOpen->UnderlyingFileObject),
                                  NULL
                                  );
            if (NtStatus == STATUS_SUCCESS) {

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVCreateContinuation: UFO(2) = %08lx\n",
                             PsGetCurrentThreadId(), davSrvOpen->UnderlyingFileObject));

                davSrvOpen->UnderlyingHandle = FileHandle;

                davSrvOpen->UserModeKey = (PVOID)FileHandle;

                davSrvOpen->UnderlyingDeviceObject = 
                    IoGetRelatedDeviceObject(davSrvOpen->UnderlyingFileObject);

            } else {

                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR:  MRxDAVCreateContinuation/"
                             "ObReferenceObjectByHandle: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));

                ZwClose(FileHandle);

            }

        }
    
    }
    
    ASSERT(RxIsFcbAcquiredExclusive(capFcb));
    
    if ( NtStatus == STATUS_SUCCESS && ( !isFileCached || !isVNRInitialized ) ) {
        
        RX_FILE_TYPE StorageType = 0;
        
        PFILE_BASIC_INFORMATION pBasicInformation = 
                                   &(CreateReturnedFileInfo->BasicInformation);
        
        PFILE_STANDARD_INFORMATION pStandardInformation = 
                                &(CreateReturnedFileInfo->StandardInformation);
        
        FCB_INIT_PACKET InitPacket;

        // StorageType = RxInferFileType(RxContext);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateContinuation: Storagetype = %08lx\n", 
                     PsGetCurrentThreadId(), StorageType));

        //
        // If we have never obtained the characteristics, we have to get them.
        //
        if ((capFcb->OpenCount == 0)
            || !FlagOn(capFcb->FcbState, FCB_STATE_TIME_AND_SIZE_ALREADY_SET)) {

            if (StorageType == 0) {
                StorageType = pStandardInformation->Directory?
                                            (FileTypeDirectory):(FileTypeFile);
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVCreateContinuation: "
                             "ChangedStoragetype %08lx\n", 
                             PsGetCurrentThreadId(), StorageType));
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Name: %wZ, FileType: %d\n",
                         PsGetCurrentThreadId(), 
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb), StorageType));
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: FileSize %08lx\n",
                         PsGetCurrentThreadId(), 
                         pStandardInformation->EndOfFile.LowPart));

            RxFinishFcbInitialization(capFcb,
                                      RDBSS_STORAGE_NTC(StorageType),
                                      RxFormInitPacket(
                                         InitPacket,
                                         &pBasicInformation->FileAttributes,
                                         &pStandardInformation->NumberOfLinks,
                                         &pBasicInformation->CreationTime,
                                         &pBasicInformation->LastAccessTime,
                                         &pBasicInformation->LastWriteTime,
                                         &pBasicInformation->ChangeTime,
                                         &pStandardInformation->AllocationSize,
                                         &pStandardInformation->EndOfFile,
                                         &pStandardInformation->EndOfFile));

        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        RxContext->pFobx = RxCreateNetFobx(RxContext, SrvOpen);
        if ( !RxContext->pFobx ) {
            
            NTSTATUS PostedCloseStatus;
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxCreateNetFobx.\n",
                         PsGetCurrentThreadId()));

            if ( !davSrvOpen->createdInKernel ) {
            
                PostedCloseStatus = UMRxSubmitAsyncEngUserModeRequest(
                                          UMRX_ASYNCENGINE_ARGUMENTS,
                                          MRxDAVFormatUserModeCloseRequest,
                                          MRxDAVPrecompleteUserModeCloseRequest
                                          );
            } else {

                ZwClose(davSrvOpen->UnderlyingHandle);

                davSrvOpen->UnderlyingHandle = davSrvOpen->UserModeKey = NULL;

            }
            
            ObDereferenceObject(davSrvOpen->UnderlyingFileObject);
            
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        
        } else {
            
            //
            // Note, collapsing is enabled on fcb but not on any srvopen.
            //
            SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED     |
                                        FCB_STATE_FILESIZECACHEING_ENABLED  |
                                        FCB_STATE_FILETIMECACHEING_ENABLED  |
                                        FCB_STATE_WRITEBUFFERING_ENABLED    |
                                        FCB_STATE_LOCK_BUFFERING_ENABLED    |
                                        FCB_STATE_READBUFFERING_ENABLED     |
                                        FCB_STATE_READCACHEING_ENABLED);
        }
    
    }


EXIT_THE_FUNCTION:

    if (CreateReturnedFileInfo != NULL) {
        RxFreePool(CreateReturnedFileInfo);
    }

    if (NtFileName != NULL) {
        RxFreePool(NtFileName);
    }

    //
    // If we allocated the FCB resource and the create failed, we need to free 
    // up the resource.
    //
    if (NtStatus != STATUS_SUCCESS && didIAllocateFcbResource) {
        ASSERT(DavFcb->DavReadModifyWriteLock != NULL);
        ExDeleteResourceLite(DavFcb->DavReadModifyWriteLock);
        RxFreePool(DavFcb->DavReadModifyWriteLock);
        DavFcb->DavReadModifyWriteLock = NULL;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateContinuation with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    if (NtStatus == STATUS_SUCCESS && (SrvOpen->pAlreadyPrefixedName->Length > 0) ) {
        DavAddEntryToGlobalList(SrvOpen->pAlreadyPrefixedName);
    }
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    return(NtStatus);
}


NTSTATUS
MRxDAVCollapseOpen(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVCollapseOpen!!!!\n",
                 PsGetCurrentThreadId()));

    //
    // We should never come here since we never collapse the Open.
    //
    ASSERT(FALSE);
    
    RxContext->pFobx = (PMRX_FOBX) RxCreateNetFobx(RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT(RxIsFcbAcquiredExclusive(capFcb));
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    } else {
       Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
MRxDAVComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pMRxSrvOpen,
    IN PVOID pMRxContext,
    OUT PULONG pNewBufferingState
    )
/*++

Routine Description:

   This routine computes the appropriate RDBSS buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    ULONG NewBufferingState;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(pMRxSrvOpen);

    PAGED_CODE();

    ASSERT(pNewBufferingState != NULL);

    NewBufferingState = 0;

    pMRxSrvOpen->BufferingFlags = NewBufferingState;
    *pNewBufferingState = pMRxSrvOpen->BufferingFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
MRxDAVTruncate(
    IN PRX_CONTEXT pRxContext
    )
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVTruncate.\n", PsGetCurrentThreadId()));

    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxDAVForcedClose(
    IN PMRX_SRV_OPEN pSrvOpen
    )
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVForcedClose.\n", PsGetCurrentThreadId()));

    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxDAVCloseSrvOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles requests to close the srvopen data structure.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCloseSrvOpen!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCloseSrvOpen: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN,
                                        MRxDAVCloseSrvOpenContinuation,
                                        "MRxDAVCloseSrvOpen");
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCloseSrvOpen with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVFormatUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the arguments of the close request which is being 
    sent to the user mode for processing.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 

Return Value:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(WorkItem->CloseRequest);
    PWCHAR ServerName = NULL, PathName = NULL;
    ULONG ServerNameLengthInBytes = 0, PathNameLengthInBytes = 0;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes = 0, NetRootNameLengthInWChars = 0;
    RxCaptureFobx;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    LARGE_INTEGER VDLServFile = {0,0}, VDLLocFile = {0,0};
    LARGE_INTEGER ServFileSize = {0,0}, LocFileSize = {0,0};
    HANDLE LocalFileHandle = INVALID_HANDLE_VALUE;
    ULONG SizeInBytes = 0;
    PWCHAR NtFileName = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeFileName;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    PSRV_OPEN rdbssSrvOpen = NULL;
    PDAV_GLOBAL_FILE_TABLE_ENTRY FileTableEntry = NULL;
    PDAV_CLOSE_FILE_ENTRY DavCloseFileEntry = NULL;
    BOOL Exists = FALSE;
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeCloseRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeCloseRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
 
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    
    if ( !DavFcb->isDirectory && DavFcb->isFileCached ) {

        VDLServFile.LowPart = Fcb->Header.ValidDataLength.LowPart;
        VDLServFile.HighPart = Fcb->Header.ValidDataLength.HighPart;
        ServFileSize.LowPart = Fcb->Header.FileSize.LowPart;
        ServFileSize.HighPart = Fcb->Header.FileSize.HighPart;

        //
        // Create an NT path name for the cached file. This is used in the 
        // ZwCreateFile call below. If c:\foo\bar is the DOA path name,
        // the NT path name is \??\c:\foo\bar. We do the Create to query the 
        // filesize of the underlying file.
        //

        SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
        NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
        if (NtFileName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVFormatUserModeCloseRequest/RxAllocatePoolWithTag: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(NtFileName, SizeInBytes);

        wcscpy( NtFileName, L"\\??\\" );
        wcscpy( &(NtFileName[4]), DavFcb->FileName );

        RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeFileName,
                                   (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                                   0,
                                   NULL);

        NtStatus = ZwCreateFile(&(LocalFileHandle),
                                FILE_READ_ATTRIBUTES,
                                &(ObjectAttributes),
                                &(IoStatusBlock),
                                NULL,
                                0,
                                FILE_SHARE_VALID_FLAGS,
                                FILE_OPEN,
                                0,
                                NULL,
                                0);
        if (NtStatus != STATUS_SUCCESS) {
            LocalFileHandle = INVALID_HANDLE_VALUE;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCloseRequest/ZwCreateFile: "
                         "Error Val = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // See what the current FileStandardInformation is. We don't use the file 
        // handle stored in the davSrvOpen structure, because this could have been
        // created in the svchost process and hence will not be valid in this 
        // process.
        //
        NtStatus = ZwQueryInformationFile(LocalFileHandle,
                                          &(IoStatusBlock),
                                          &(FileStandardInfo),
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVFormatUserModeCloseRequest/ZwQueryInformationFile. "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        LocFileSize.LowPart = FileStandardInfo.EndOfFile.LowPart;
        LocFileSize.HighPart = FileStandardInfo.EndOfFile.HighPart;

        if ( (ServFileSize.HighPart != LocFileSize.HighPart) ||
             (ServFileSize.LowPart != LocFileSize.LowPart) ) {

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR!!! MRxDAVFormatUserModeCloseRequest: FileName = %wZ, "
                         "LocalFileName = %ws\n", PsGetCurrentThreadId(),
                         SrvOpen->pAlreadyPrefixedName,
                         DavFcb->FileName));

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR!!! MRxDAVFormatUserModeCloseRequest: ServFileSize.HighPart = %x, "
                         "ServFileSize.LowPart = %x, LocFileSize.HighPart = %x, LocFileSize.LowPart = %x, "
                         "VDLServFile.HighPart = %x, VDLServFile.LowPart = %x\n",
                         PsGetCurrentThreadId(),
                         ServFileSize.HighPart, ServFileSize.LowPart,
                         LocFileSize.HighPart, LocFileSize.LowPart,
                         VDLServFile.HighPart, VDLServFile.LowPart));

            rdbssSrvOpen = (PSRV_OPEN)SrvOpen;

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR!!! MRxDAVFormatUserModeCloseRequest: davSrvOpen->LastByteOffset.HighPart = %x, "
                         "davSrvOpen->LastByteOffset.LowPart = %x, davSrvOpen->LastByteCount = %x, "
                         "rdbssSrvOpen->LastByteOffset.HighPart = %x, rdbssSrvOpen->LastByteOffset.LowPart = %x, "
                         "rdbssSrvOpen->LastByteCount = %x\n",
                         PsGetCurrentThreadId(),
                         davSrvOpen->LastByteOffset.HighPart,
                         davSrvOpen->LastByteOffset.LowPart,
                         davSrvOpen->LastByteCount,
                         rdbssSrvOpen->LastByteOffset.HighPart,
                         rdbssSrvOpen->LastByteOffset.LowPart,
                         rdbssSrvOpen->LastByteCount));

            ASSERT(!"DATA CORRUPTION");

            DbgBreakPoint();

        }

        if ( RxContext->pRelevantSrvOpen->pAlreadyPrefixedName != NULL &&
             RxContext->pRelevantSrvOpen->pAlreadyPrefixedName->Length > 0 ) {
 
            Exists = DavDoesTheFileEntryExist(SrvOpen->pAlreadyPrefixedName,
                                              &(FileTableEntry));
            if (!Exists) {
                DbgBreakPoint();
            }

            DavCloseFileEntry = RxAllocatePool(PagedPool, sizeof(DAV_CLOSE_FILE_ENTRY));
            if (DavCloseFileEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavCloseFileEntry, sizeof(DAV_CLOSE_FILE_ENTRY));

            DavCloseFileEntry->ThisThreadId = PsGetCurrentThreadId();

            DavCloseFileEntry->LocFileSize = FileStandardInfo.EndOfFile;

            DavCloseFileEntry->ServFileSize.QuadPart = Fcb->Header.FileSize.QuadPart;

            if ( DavFcb->FileWasModified && !(DavFcb->DeleteOnClose) ) {
                DavCloseFileEntry->WasPut = TRUE;
            }

            InsertHeadList( &(FileTableEntry->DavCloseFileEntry), &(DavCloseFileEntry->thisCloseEntry) );

        }

    }

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    WorkItem->WorkItemType = UserModeClose;

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);

    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    //
    // Copy the local file name.
    //
    wcscpy(CloseRequest->FileName, DavFcb->FileName);
    wcscpy(CloseRequest->Url, DavFcb->Url);

    //
    // We need to tell the user mode process about the following file 
    // information. 
    //
    CloseRequest->DeleteOnClose = DavFcb->DeleteOnClose;
    CloseRequest->FileWasModified = DavFcb->FileWasModified;
    
    //
    // If this file was modified and DeleteOnClose is not set, we need to 
    // set RaiseHardErrorIfCloseFails to TRUE. On the precomplete close call,
    // if the usermode operation failed and RaiseHardErrorIfCloseFails is TRUE,
    // we call IoRaiseInformationalHardError to notify the user (the calls pops
    // up a box) that the data could have been lost.
    //
    if ( DavFcb->FileWasModified && !(DavFcb->DeleteOnClose) ) {
        davSrvOpen->RaiseHardErrorIfCloseFails = TRUE;
    } else {
        davSrvOpen->RaiseHardErrorIfCloseFails = FALSE;
    }

    if (!CloseRequest->DeleteOnClose)
    {
        //
        // If the file is modified, just propatch again. This is to get around
        // the docfile issue where on a PUT, the properties get cleaned up.
        //
        if (DavFcb->FileWasModified)
        {
            LARGE_INTEGER CurrentTime;

            CloseRequest->fCreationTimeChanged = (((PFCB)Fcb)->CreationTime.QuadPart != 0);
            CloseRequest->fLastAccessTimeChanged = (((PFCB)Fcb)->LastAccessTime.QuadPart != 0);
            CloseRequest->fLastModifiedTimeChanged = (((PFCB)Fcb)->LastWriteTime.QuadPart != 0);

            //
            // We query the Current system time and make that the LastWrite
            // and the LastAccess time of the file. Even though RxCommonCleanup
            // modifies these time values, it only modifies them on FileObjects
            // which have FO_FILE_MODIFIED set. Consider the case where h1 and
            // h2 are two handles created. A write is issued on h2 setting
            // FO_FILE_MODIFIED in its FileObject. CloseHandle(h1) leads to the
            // file being PUT on the server since DavFcb->FileWasModified is
            // TRUE (write on h2 caused this). But since the FileObject of
            // h1 doesn't have FO_FILE_MODIFIED set, in the RxCommonCleanup
            // code the LastWrite and LastAccess time values of this FCB are
            // not modifed causing us to PROPPATCH the old values on the server.
            // To avoid this we query the current time value and set it
            // ourselves in the FCB. If "DavFcb->DoNotTakeTheCurrentTimeAsLMT"
            // is TRUE then we don't do this since the application explicitly
            // set the LastModifiedTime after all the changes were done.
            //
            if (DavFcb->DoNotTakeTheCurrentTimeAsLMT == FALSE) {
                KeQuerySystemTime( &(CurrentTime) );
                ((PFCB)Fcb)->LastAccessTime.QuadPart = CurrentTime.QuadPart;
                ((PFCB)Fcb)->LastWriteTime.QuadPart = CurrentTime.QuadPart;
            }

            //
            // If FILE_ATTRIBUTE_NORMAL was the only attribute set on the file
            // and the file was modified, then we should replace this with the
            // FILE_ATTRIBUTE_ARCHIVE attribute.
            //
            if ( ((PFCB)Fcb)->Attributes == FILE_ATTRIBUTE_NORMAL ) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("ld: ERROR: MRxDAVFormatUserModeCloseRequest: "
                             "FILE_ATTRIBUTE_NORMAL ===> FILE_ATTRIBUTE_ARCHIVE\n",
                             PsGetCurrentThreadId()));
                ((PFCB)Fcb)->Attributes = FILE_ATTRIBUTE_ARCHIVE;
                DavFcb->fFileAttributesChanged = TRUE;
            }

            if ((((PFCB)Fcb)->Attributes != 0) || DavFcb->fFileAttributesChanged) {
                CloseRequest->fFileAttributesChanged = TRUE;
            }
        }
        else
        {
            //
            // If any of the following times have changed, then we need to PROPPATCH
            // them to the server.
            //
            CloseRequest->fCreationTimeChanged = DavFcb->fCreationTimeChanged;
            CloseRequest->fLastAccessTimeChanged = DavFcb->fLastAccessTimeChanged;
            CloseRequest->fLastModifiedTimeChanged = DavFcb->fLastModifiedTimeChanged;
            CloseRequest->fFileAttributesChanged = DavFcb->fFileAttributesChanged;
        }
    }

    //
    // Copy the various time values.
    //
    CloseRequest->CreationTime = ((PFCB)Fcb)->CreationTime;
    CloseRequest->LastAccessTime = ((PFCB)Fcb)->LastAccessTime;
    CloseRequest->LastModifiedTime = ((PFCB)Fcb)->LastWriteTime;
    CloseRequest->dwFileAttributes = ((PFCB)Fcb)->Attributes;
    CloseRequest->FileSize = Fcb->Header.FileSize.LowPart;

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CloseRequest->ServerName = ServerName;
    
    //
    // Copy the ServerID.
    //
    CloseRequest->ServerID = DavSrvCall->ServerID;
    
    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the PathName of the Directory. If the file was renamed, we need to
    // copy the new path name which is stored in the DavFcb and not the 
    // AlreadyPrefixedName of the SrvOpen.
    //
    if (DavFcb->FileWasRenamed) {
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                  DavFcb->NewFileNameLength + 
                                  sizeof(WCHAR) );
    } else {
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                  SrvOpen->pAlreadyPrefixedName->Length + 
                                  sizeof(WCHAR) );
    }
    
    PathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                    PathNameLengthInBytes);
    if (PathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(PathName, PathNameLengthInBytes);

    RtlCopyBytes(PathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    if (DavFcb->FileWasRenamed) {
        RtlCopyBytes((PathName + NetRootNameLengthInWChars),
                     DavFcb->NewFileName, 
                     DavFcb->NewFileNameLength);
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("ld: MRxDAVFormatUserModeCloseRequest. ReNamed!!! NewFileName = %ws\n",
                     PsGetCurrentThreadId(), PathName));
    } else {
        RtlCopyBytes((PathName + NetRootNameLengthInWChars),
                     SrvOpen->pAlreadyPrefixedName->Buffer,
                     SrvOpen->pAlreadyPrefixedName->Length);
    }
    
    PathName[( ( (PathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CloseRequest->PathName = PathName;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("ld: MRxDAVFormatUserModeCloseRequest. PathName = %ws\n",
                 PsGetCurrentThreadId(), PathName));
    
    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    CloseRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    CloseRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    if ( !DavFcb->isDirectory ) {
        CloseRequest->isDirectory = FALSE;
        if ( !davSrvOpen->createdInKernel ) {
            CloseRequest->Handle = davSrvOpen->UnderlyingHandle;
            CloseRequest->UserModeKey = davSrvOpen->UserModeKey;
        } else {
            CloseRequest->Handle = NULL;
            CloseRequest->UserModeKey = NULL;
            CloseRequest->createdInKernel = davSrvOpen->createdInKernel; // TRUE
        }
    } else {
        CloseRequest->isDirectory = TRUE;
    }

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCloseRequest: "
                     "SecurityClientContext is NULL.\n",
                     PsGetCurrentThreadId()));
    }

EXIT_THE_FUNCTION:

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    
    //
    // If we created a LocalFileHandle, we need to close it now.
    //
    if (LocalFileHandle != INVALID_HANDLE_VALUE) {
        ZwClose(LocalFileHandle);
    }
    
    //
    // If we allocated an NtFileName to do the create, we need to free it now.
    //
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeCloseRequest with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the CloseSrvOpen request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(WorkItem->CloseRequest);
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeCloseRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeCloseRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A CloseSrvOpen request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the CloseSrvOpen case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeCloseRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeCloseRequest "
                     "Close failed for file \"%ws\"\n",
                     PsGetCurrentThreadId(), CloseRequest->PathName));
    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (CloseRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CloseRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCloseRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (CloseRequest->PathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CloseRequest->PathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCloseRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeCloseRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return TRUE;
}


NTSTATUS
MRxDAVCloseSrvOpenContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine closes a file across the network.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFcb; 
    RxCaptureFobx;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb);
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);

    PAGED_CODE();

    //
    // Assert that the FCB has been exclusively acquired.
    //
    ASSERT( RxIsFcbAcquiredExclusive(Fcb) == TRUE );

    if (RxIsFcbAcquiredExclusive(Fcb) != TRUE) {
        DbgPrint("MRxDAVCloseSrvOpenContinuation: FCB NOT Exclusive\n");
        DbgBreakPoint();
    }

    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }
    
    ASSERT(NodeTypeIsFcb(capFcb));
    ASSERT(SrvOpen->OpenCount == 0);
    ASSERT(NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCloseSrvOpenContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCloseSrvOpenContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCloseSrvOpenContinuation: Attempt to Close: %wZ\n",
                 PsGetCurrentThreadId(), RemainingName));

    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                           UMRX_ASYNCENGINE_ARGUMENTS,
                                           MRxDAVFormatUserModeCloseRequest,
                                           MRxDAVPrecompleteUserModeCloseRequest
                                           );
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVCloseSrvOpenContinuation/"
                     "UMRxSubmitAsyncEngUserModeRequest: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
    }

    if (DavFcb->isDirectory == FALSE) {
        
        //
        // If this handle got created in the kernel, we need to close it now.
        //
        if (davSrvOpen->createdInKernel) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCloseSrvOpenContinuation: FileHandle = %08lx,"
                         " Process = %08lx, SrvOpen = %08lx, davSrvOpen = %08lx\n", 
                         PsGetCurrentThreadId(), davSrvOpen->UnderlyingHandle, 
                         PsGetCurrentProcess(), SrvOpen, davSrvOpen));
            ZwClose(davSrvOpen->UnderlyingHandle);
            davSrvOpen->UnderlyingHandle = NULL;
            davSrvOpen->UserModeKey = NULL;
        }
    
        //      
        // Remove our reference which we would have taken on the FileObject
        // when the Create succeeded.
        //
        if (davSrvOpen->UnderlyingFileObject) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCloseSrvOpenContinuation: Attempt to close"
                         " %wZ.\n", PsGetCurrentThreadId(), RemainingName));
            ObDereferenceObject(davSrvOpen->UnderlyingFileObject);
            davSrvOpen->UnderlyingFileObject = NULL;
        }

    }

    if (DavFcb->DeleteOnClose) {
        
        MRxDAVInvalidateFileInfoCache(RxContext);
        
        MRxDAVCacheFileNotFound(RxContext);

        if ((capFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            //
            // Remove the directory from the registry since it has been deleted.
            //
            MRxDAVRemoveEncryptedDirectoryKey(&DavFcb->FileNameInfo);
        }
    
    }

    if (DavFcb->FileWasModified) {
        // 
        // We cannot predict the size of the file on the server.
        //
        MRxDAVInvalidateFileInfoCache(RxContext);
        // MRxDAVUpdateBasicFileInfoCache(RxContext,capFcb->Attributes,&((PFCB)capFcb)->LastWriteTime);
        // MRxDAVUpdateFileInfoCacheFileSize(RxContext,&(capFcb->Header.FileSize));
    }

    NtStatus = AsyncEngineContext->Status;

    //
    // If we succeeded and FileWasModified was set to TRUE, we need to clear the
    // flag since we have already PUT the data on the server. This reasoning
    // is based on the fact that when a SrvOpen is getting closed, the FCB is
    // acquired exclusive and no other modifications to the file can happen before
    // we return from this call.
    //
    if (NtStatus == STATUS_SUCCESS) {
        DavFcb->FileWasModified = FALSE;
        DavFcb->fCreationTimeChanged = FALSE;
        DavFcb->fFileAttributesChanged = FALSE;
        DavFcb->fLastAccessTimeChanged = FALSE;
        DavFcb->fLastModifiedTimeChanged = FALSE;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCloseSrvOpenContinuation with NtStatus = "
                 "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVGetFullParentDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING ParentDirName
    )
/*++

Routine Description:

   This routine returns the parent directory name of the file on the RxContext including 
   server and share.
    
   Here is an example of the FileName on a file object:
          \;Y:000000000000cdef\www.msnusers.com\dv1@usa.com\files\mydoc.doc
   We want to return the middle part of the FileName:
          \www.msnusers.com\dv1@usa.com\files
    

Arguments:

    RxContext - The RDBSS context.
    ParentDirName - The full path name of the parent directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    USHORT i, j;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUNICODE_STRING FileName = &RxContext->CurrentIrpSp->FileObject->FileName;

    ParentDirName->Buffer = NULL;

    for (i = 1; i < (FileName->Length / sizeof(WCHAR)); i++) {
        if (FileName->Buffer[i] == L'\\') {
            break;
        }
    }

    if ( i < (FileName->Length / sizeof(WCHAR)) ) {
        for (j = ( (FileName->Length / sizeof(WCHAR)) - 1 ); j > i; j--) {
            if (FileName->Buffer[j] == L'\\') {
                break;
            }
        }

        if (i < j) {
            ParentDirName->Buffer = &FileName->Buffer[i];
            ParentDirName->Length = ParentDirName->MaximumLength = (j - i) * sizeof(WCHAR);
        }
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVGetFullParentDirectoryPath: ParentDirName: %wZ\n", ParentDirName));

    return NtStatus;
}


NTSTATUS
MRxDAVGetFullDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING FileName,
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine returns the full directory name including the server and share.

Arguments:

    RxContext - The RDBSS context.
    FileName - If provided, it will be included in the returned path.
               If not provided, the file name on the file object will be returned.
    DirName - The full path name of the parent directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
Note:

   If FileName is provided, the caller should free up the the UNICODE buffer.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    DirName->Buffer = NULL;
    DirName->Length = DirName->MaximumLength = 0;
    
    if (FileName == NULL) {
        
        USHORT i;

        FileName = &RxContext->CurrentIrpSp->FileObject->FileName;

        for (i = 1; i < (FileName->Length / sizeof(WCHAR)); i++) {
            if (FileName->Buffer[i] == L'\\') {
                break;
            }
        }

        if ( i < (FileName->Length / sizeof(WCHAR)) ) {
            DirName->Buffer = &FileName->Buffer[i];
            DirName->Length = DirName->MaximumLength = FileName->Length - i*sizeof(WCHAR);
        }
    
    } else {
        
        RxCaptureFcb;
        
        USHORT NameLength = 0;

        if (FileName->Length == 0) {
            goto EXIT_THE_FUNCTION;
        }

        NameLength = capFcb->pNetRoot->pNetRootName->Length + FileName->Length;

        DirName->Length = DirName->MaximumLength = NameLength;

        DirName->Buffer = RxAllocatePoolWithTag(PagedPool, 
                                                NameLength + sizeof(WCHAR),
                                                DAV_FILEINFO_POOLTAG);

        if (DirName->Buffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVGetParentDirectory/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DirName->Buffer,NameLength + sizeof(WCHAR));

        RtlCopyMemory(DirName->Buffer,
                      capFcb->pNetRoot->pNetRootName->Buffer,
                      capFcb->pNetRoot->pNetRootName->Length);

        RtlCopyMemory(&DirName->Buffer[capFcb->pNetRoot->pNetRootName->Length/sizeof(WCHAR)],
                      FileName->Buffer,
                      FileName->Length);
    
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVGetFullDirectoryPath: DirName: %wZ\n", DirName));

    return NtStatus;
}


NTSTATUS
MRxDAVCreateEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine creates the registry key for the encrypted directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVCreateEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status != STATUS_SUCCESS) {
        
        Status = ZwCreateKey(&Key,
                             KEY_ALL_ACCESS,
                             &ObjectAttributes,
                             0,
                             NULL,
                             0,
                             NULL);

        if (Status == STATUS_SUCCESS) {
            
            Status = ZwSetValueKey(Key,
                                   DirName,
                                   0,
                                   REG_DWORD,
                                   &i,
                                   sizeof(ULONG));

            ZwClose(Key);

        }
    
    } else {
        
        Status = ZwQueryValueKey(Key,
                                 DirName,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &(RequiredLength));

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            
            Status = ZwSetValueKey(Key,
                                   DirName,
                                   0,
                                   REG_DWORD,
                                   &i,
                                   sizeof(ULONG));
        
        } else if (Status == STATUS_BUFFER_TOO_SMALL) {

            Status = STATUS_SUCCESS;
        
        }

        ZwClose(Key);
    
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}


NTSTATUS
MRxDAVRemoveEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine deletes the registry key for the directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVRemoveEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status == STATUS_SUCCESS) {
        Status = ZwDeleteValueKey(Key,DirName);
        ZwClose(Key);
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVRemoveEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}


NTSTATUS
MRxDAVQueryEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine queries the registry key for the directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVQueryEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status == STATUS_SUCCESS) {
        
        Status = ZwQueryValueKey(Key,
                                 DirName,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &(RequiredLength));

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            Status = STATUS_SUCCESS;
        }

        ZwClose(Key);
    
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: ERROR: MRxDAVQueryEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the Driver Initialization routine for the WebDav
    miniredir.

Author:

    Joe Linn

    Rohan Kumar     [RohanK]    10-March-1999

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "netevent.h"
#include "nvisible.h"
#include "webdav.h"
#include "ntddmup.h"
#include "rxdata.h"
#include "fsctlbuf.h"
#include "tdikrnl.h"

//
// IMPORTANT!!! If the following define is commented out, then the WMI logging 
// code in the DAV MiniRedir will not get compiled.
//
// #define DAVWMILOGGING_K 1

#ifdef DAVWMILOGGING_K

#include "davwmik.h"



NTSTATUS
MRxDAVProcessSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

WML_CONTROL_GUID_REG MRxDav_ControlGuids[] = {
   { // d0b2a457-562b-4b37-b2e2-041535fa1f78 MRxDav
     0xd0b2a457,0x562b,0x4b37,{0xb2,0xe2,0x04,0x15,0x35,0xfa,0x1f,0x78},
     { // a0c1133a-2dbd-4db4-b006-86b6f78e7278
       {0xa0c1133a,0x2dbd,0x4db4,{0xb0,0x06,0x86,0xb6,0xf7,0x8e,0x72,0x78},},
       // cac23be8-5744-4788-a3ec-3b595dc2b794
       {0xcac23be8,0x5744,0x4788,{0xa3,0xec,0x3b,0x59,0x5d,0xc2,0xb7,0x94},},
       // 9c9cfd45-f664-4b04-87ad-e8adea670e4b
       {0x9c9cfd45,0xf664,0x4b04,{0x87,0xad,0xe8,0xad,0xea,0x67,0x0e,0x4b},}
     },
   },  
};


#define MRxDav_ControlGuids_len  1

BOOLEAN DavEnableWmiLog = FALSE;

#endif

//
// Global data declarations.
//
PEPROCESS       MRxDAVSystemProcess;
FAST_MUTEX      MRxDAVSerializationMutex;
KIRQL           MRxDAVGlobalSpinLockSavedIrql;
KSPIN_LOCK      MRxDAVGlobalSpinLock;
BOOLEAN         MRxDAVGlobalSpinLockAcquired;
BOOLEAN         MRxDAVTransportReady = FALSE;
HANDLE          MRxDAVTdiNotificationHandle = NULL;

//
// The Exchange Registry key from where we read their DeviceObject name.
//
#define DavExchangeRegistryKey L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Lsifs\\Parameters"

//
// The exchange device name will be stored in this KEY_VALUE_PARTIAL_INFORMATION
// structure.
//
PBYTE DavExchangeDeviceName = NULL;

//
// The DavWinInetCachePath which is used in satisfying volume related queries.
//
WCHAR DavWinInetCachePath[MAX_PATH];

//
// The ProcessId of the svchost.exe process that loads the webclnt.dll.
//
ULONG DavSvcHostProcessId = 0;

//
// Name cache stuff. These values are read from the registry during init time.
//
ULONG FileInformationCacheLifeTimeInSec = 0;
ULONG FileNotFoundCacheLifeTimeInSec = 0;
ULONG NameCacheMaxEntries = 0;

#define MRXDAV_DEBUG_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\Parameters"
#define NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME L"FileInformationCacheLifeTimeInSec"
#define NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME L"FileNotFoundCacheLifeTimeInSec"
#define NAME_CACHE_NETROOT_MAX_ENTRIES L"NameCacheMaxEntries"
#define MRXDAV_REQUEST_TIMEOUT_IN_SEC L"RequestTimeoutInSec"

#if DBG
#define MRXDAV_DEBUG_VALUE L"DAVDebugFlag"
#endif

//
// Define the size of the shared memory area that we allocate as a heap
// between user and server.
//
#define DAV_SHARED_MEMORY_SIZE (1024 * 512)

//
// The Debug vector flags that control the amount of tracing in the debugger.
//
#if DBG
ULONG MRxDavDebugVector = 0;
#endif

//
// Mini Redirector global variables.
//
struct _MINIRDR_DISPATCH  MRxDAVDispatch;
PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject; 
FAST_IO_DISPATCH MRxDAVFastIoDispatch;

#define DAV_SVCHOST_NAME_SIZE   22

UNICODE_STRING uniSvcHost = {DAV_SVCHOST_NAME_SIZE+2,DAV_SVCHOST_NAME_SIZE+2,L"svchost.exe"};

FAST_MUTEX MRxDAVFileInfoCacheLock;

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MRxDAVInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN WEBDAV_INIT_STATES MRxDAVInitState
    );

VOID
MRxDAVUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
MRxDAVInitializeTables(
    VOID
    );

NTSTATUS
MRxDAVFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    );

VOID
MRxDAVDeregisterAndCleanupDeviceObject (
    PUMRX_DEVICE_OBJECT UMRdrDeviceObject
    );

NTSTATUS
MRxDAVRegisterForPnpNotifications(
    VOID
    );

NTSTATUS
MRxDAVDeregisterForPnpNotifications(
    VOID
    );

VOID
MRxDAVPnPBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    );

NTSTATUS
MRxDAVSkipIrps(
    IN PIRP Irp,
    IN PUNICODE_STRING pFileName,
    IN BOOL fCheckAny
    );

UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, MRxDAVInitUnwind)
#pragma alloc_text(PAGE, MRxDAVUnload)
#pragma alloc_text(PAGE, MRxDAVInitializeTables)
#pragma alloc_text(PAGE, MRxDAVFsdDispatch)
#pragma alloc_text(PAGE, MRxDAVDeregisterAndCleanupDeviceObject)
#pragma alloc_text(PAGE, MRxDAVFlush)
#pragma alloc_text(PAGE, MRxDAVPnPBindingHandler)
#pragma alloc_text(PAGE, MRxDAVRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxDAVDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxDAVProbeForReadWrite)
#pragma alloc_text(PAGE, MRxDAVSkipIrps)
#endif

#ifdef DAVWMILOGGING_K
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVProcessSystemControlIrp)
#endif
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the usermode reflector.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
               operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WEBDAV_INIT_STATES MRxDAVInitState = 0;
    UNICODE_STRING MRxDAVMiniRedirectorName;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    NTSTATUS RegNtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING UnicodeRegKeyName, UnicodeValueName;
    ULONG RequiredLength = 0;
    PKEY_VALUE_PARTIAL_INFORMATION DavKeyValuePartialInfo = NULL;

    PAGED_CODE();

    //
    // Read the name cache values from the registry. If we fail to read them,
    // we set them to some default values.
    //

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME,
                                               &(FileInformationCacheLifeTimeInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FileInformationCacheLifeTimeInSec = 60;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME,
                                               &(FileNotFoundCacheLifeTimeInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FileNotFoundCacheLifeTimeInSec = 60;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_NETROOT_MAX_ENTRIES,
                                               &(NameCacheMaxEntries));
    if (RegNtStatus != STATUS_SUCCESS) {
        NameCacheMaxEntries = 300;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               MRXDAV_REQUEST_TIMEOUT_IN_SEC,
                                               &(RequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        RequestTimeoutValueInSec = (10 * 60);
    }

    //
    // Calculate the timeout value in TickCount (100 nano seconds) using the
    // timeout value in seconds (which was read from the registry above).
    // Step1 below calculates the number of ticks that happen in one second.
    // Step2 below calculates the number of ticks in RequestTimeoutValueInSec.
    //
    RequestTimeoutValueInTickCount.QuadPart = ( (1000 * 1000 * 10) / KeQueryTimeIncrement() );
    RequestTimeoutValueInTickCount.QuadPart *= RequestTimeoutValueInSec;

    //
    // Initialize the debug tracing for the Mini-Redir.
    //
#if DBG
    UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY, MRXDAV_DEBUG_VALUE, &(MRxDavDebugVector));
#endif

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering DriverEntry!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: DriverEntry: Starting MRxDAV. DriverObject: %08lx.\n", 
                 PsGetCurrentThreadId(), DriverObject));

#ifdef MONOLITHIC_MINIRDR
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: Calling RxDriverEntry.\n",
                 PsGetCurrentThreadId()));

    NtStatus =  RxDriverEntry(DriverObject, RegistryPath);
    
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: DriverEntry: Back from RxDriverEntry. NtStatus: %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/RxDriverEntry: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
        return(NtStatus);
    }

#endif

    //
    // The Dav redirector needs to register for PNP notifications to handle the 
    // following scenario. The SMB redirector does not accept connections till 
    // the net is ready as indicated by a PNP event. If during this time DAV 
    // forwards the connection requests to WinInet it will in turn spin up RAS 
    // connections. By registering for PNP notifications we provide an easy 
    // mechanism for short circuiting the requests till transports are ready. 
    //
    MRxDAVRegisterForPnpNotifications();

    MRxDAVSystemProcess = RxGetRDBSSProcess();
    ExInitializeFastMutex(&MRxDAVSerializationMutex);
    KeInitializeSpinLock(&MRxDAVGlobalSpinLock);
    MRxDAVGlobalSpinLockAcquired = FALSE;

    //
    // 1. We need to initialize the TimerObject which will be used by the timer
    //    thread. 
    // 2. Set TimerThreadShutDown to FALSE. This will be set to TRUE
    //    when the system is being shutdown.
    // 3. Initialize the resource that is used to synchronize the timer thread
    //    when the service is stopped.
    // 4. Initialize the event that is signalled by the timer thread just
    //    before it terminates itself.
    //
    KeInitializeTimerEx( &(DavTimerObject), NotificationTimer );
    TimerThreadShutDown = FALSE;
    ExInitializeResourceLite( &(MRxDAVTimerThreadLock) );
    KeInitializeEvent( &(TimerThreadEvent), NotificationEvent, FALSE );

    //
    // Zero the WinInetCachePath global. This will be initialized to the local
    // WinInetCachePath value when the MiniRedir is started.
    //
    RtlZeroMemory ( DavWinInetCachePath, MAX_PATH * sizeof(WCHAR) );
    
    try {

        MRxDAVInitState = MRxDAVINIT_START;
        
        RtlInitUnicodeString(&MRxDAVMiniRedirectorName, DD_DAV_DEVICE_NAME_U);
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: DriverEntry: Registering the Mini-Rdr with RDBSS.\n",
                     PsGetCurrentThreadId()));
        
        NtStatus = RxRegisterMinirdr((PRDBSS_DEVICE_OBJECT *)(&MRxDAVDeviceObject),
                                     DriverObject,
                                     &MRxDAVDispatch,
                                     RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS,
                                     &MRxDAVMiniRedirectorName,
                                     WEBDAV_DEVICE_OBJECT_EXTENSION_SIZE,
                                     FILE_DEVICE_NETWORK_FILE_SYSTEM,
                                     FILE_REMOTE_DEVICE);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry/RxRegisterMinirdr: NtStatus "
                         "= %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }

        MRxDAVInitState = MRxDAVINIT_MINIRDR_REGISTERED;

        //
        // Now initialize the reflector's portion of the Device object.
        //
        UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(MRxDAVDeviceObject->UMRefDeviceObject);
        NtStatus = UMRxInitializeDeviceObject(UMRefDeviceObject, 
                                              1024, 
                                              512,
                                              DAV_SHARED_MEMORY_SIZE);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry/UMRxInitializeDeviceObject:"
                         " NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }

        //
        // Initialize the DAV Mini-Redir specific fields of the device object.
        //
        MRxDAVDeviceObject->IsStarted = FALSE;
        MRxDAVDeviceObject->CachedRxDeviceFcb = NULL;
        MRxDAVDeviceObject->RegisteringProcess = IoGetCurrentProcess();
    
    try_exit: NOTHING;
    
    } finally {
        
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry: Calling MRxDAVInitUnwind.\n",
                         PsGetCurrentThreadId()));
            MRxDAVInitUnwind(DriverObject, MRxDAVInitState);
        }
    
    }

    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry failed with NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
        return(NtStatus);
    }
    
    //
    // Initialize the dispatch vector used by RDBSS.
    //
    MRxDAVInitializeTables();

    //
    // Initialize the major function dispatch vector of the Driver object.
    //
    {
        DWORD i;
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxDAVFsdDispatch; 
        }
    }

    //
    // Setup Unload Routine for the Driver Object.
    //
    DriverObject->DriverUnload = MRxDAVUnload;

    //
    // Set the Driver Object's FastIoDispatch function.
    //
    DriverObject->FastIoDispatch = &(MRxDAVFastIoDispatch);
    MRxDAVFastIoDispatch.SizeOfFastIoDispatch = sizeof(MRxDAVFastIoDispatch);

    MRxDAVFastIoDispatch.FastIoDeviceControl = MRxDAVFastIoDeviceControl;
    MRxDAVFastIoDispatch.FastIoRead = MRxDAVFastIoRead;
    MRxDAVFastIoDispatch.FastIoWrite = MRxDAVFastIoWrite;

#ifdef DAVWMILOGGING_K

    //
    // Register with WMI. If the registration is successful, we enable WMI 
    // logging.
    //
    NtStatus = IoWMIRegistrationControl( (PDEVICE_OBJECT)MRxDAVDeviceObject, WMIREG_ACTION_REGISTER );
    if ( NtStatus != STATUS_SUCCESS ) {
        DbgPrint("DriverEntry/IoWMIRegistrationControl: NtStatus = %08lx\n", NtStatus);
    } else {
        DavEnableWmiLog = TRUE;
    }

#endif

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    InitializeListHead( &(DavGlobalFileTable) );
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    //
    // Since the Exchange Redir is not shipping with Whistler, we don't need 
    // to execute the code below. We can exit right away.
    //
    goto EXIT_THE_FUNCTION;

    //
    // Finally find out if the Exchange Redir is installed on this machine. If 
    // it is, get its Device Name.
    //

    RtlInitUnicodeString( &(UnicodeRegKeyName), DavExchangeRegistryKey );

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);
    
    //
    // Open a handle to the Exchange Key.
    //
    RegNtStatus = ZwOpenKey(&(KeyHandle), KEY_READ, &(ObjectAttributes));
    if (RegNtStatus != STATUS_SUCCESS) {
        KeyHandle = INVALID_HANDLE_VALUE;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwOpenKey: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We are looking for the DeviceName Value.
    //
    RtlInitUnicodeString( &(UnicodeValueName), L"DeviceName" );
    // RtlInitUnicodeString( &(UnicodeValueName), L"Name" );

    //
    // Find out the number of bytes needed to store this value.
    //
    RegNtStatus = ZwQueryValueKey(KeyHandle,
                                  &(UnicodeValueName),
                                  KeyValuePartialInformation,
                                  NULL,
                                  0,
                                  &(RequiredLength));
    if (RegNtStatus !=  STATUS_BUFFER_TOO_SMALL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwQueryValueKey(1): NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavExchangeDeviceName = RxAllocatePoolWithTag(PagedPool, RequiredLength, DAV_EXCHANGE_POOLTAG);
    if (DavExchangeDeviceName == NULL) {
        RegNtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: DriverEntry/RxAllocatePoolWithTag. NtStatus = %08lx\n",
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(DavExchangeDeviceName, RequiredLength);
    
    DavKeyValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DavExchangeDeviceName;
    
    RegNtStatus = ZwQueryValueKey(KeyHandle,
                                  &(UnicodeValueName),
                                  KeyValuePartialInformation,
                                  (PVOID)DavKeyValuePartialInfo,
                                  RequiredLength,
                                  &(RequiredLength));
    if (RegNtStatus != STATUS_SUCCESS || DavKeyValuePartialInfo->Type != REG_SZ) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwQueryValueKey(2): NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: ExchangeDeviceName = %ws\n", 
                 PsGetCurrentThreadId(), DavKeyValuePartialInfo->Data));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: ExchangeDeviceNameLength = %d\n", 
                 PsGetCurrentThreadId(), DavKeyValuePartialInfo->DataLength));

EXIT_THE_FUNCTION:

    //
    // We are done with the handle now, so close it.
    //
    if (KeyHandle != INVALID_HANDLE_VALUE) {
        ZwClose(KeyHandle);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving DriverEntry with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return  NtStatus;
}


VOID
MRxDAVInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN WEBDAV_INIT_STATES MRxDAVInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxDAVInitState) {
    case MRxDAVINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(&MRxDAVDeviceObject->RxDeviceObject);
        //
        // Lack of break intentional.
        //

    case MRxDAVINIT_START:
        break;
    }
}


VOID
MRxDAVUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the usermode reflector.

Arguments:

     DriverObject - pointer to the driver object for the UMRx

Return Value:

     None

--*/
{
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;

    PAGED_CODE();

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(MRxDAVDeviceObject->UMRefDeviceObject);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVUnload!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVUnload: DriverObject = %08lx.\n", 
                 PsGetCurrentThreadId(), DriverObject));

#ifdef DAVWMILOGGING_K

    //
    // If we had Registered with WMI during driver load, we need to DeRegister 
    // now.
    //
    if (DavEnableWmiLog) {
        NTSTATUS NtStatus;
        NtStatus = IoWMIRegistrationControl((PDEVICE_OBJECT)MRxDAVDeviceObject, WMIREG_ACTION_DEREGISTER);
        if (NtStatus != STATUS_SUCCESS) {
            DbgPrint("MRxDAVUnload/IoWMI(De)RegistrationControl: NtStatus = %08lx\n", NtStatus);
        }
    }

#endif

    //
    // If we allocated memory for the exchange device name, we need to free it
    // now.
    //
    if (DavExchangeDeviceName != NULL) {
        RxFreePool(DavExchangeDeviceName);
    }
    
    //
    // Deregister the device object before calling RxUnload.
    //
    MRxDAVDeregisterAndCleanupDeviceObject(UMRefDeviceObject);

    //
    // Wait for the timer thread to finish before we delete the global lock
    // MRxDAVTimerThreadLock used to synchronize TimerThreadShutDown variable.
    //
    KeWaitForSingleObject(&(TimerThreadEvent),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    ExDeleteResourceLite( &(MRxDAVTimerThreadLock) );

    //
    // The TDI registration needs to be undone.
    //
    MRxDAVDeregisterForPnpNotifications();

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVUnload.\n", PsGetCurrentThreadId()));

    return;
}


VOID
MRxDAVInitializeTables(
    VOID
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    //
    // Local minirdr dispatch table init.
    //
    ZeroAndInitializeNodeType(&MRxDAVDispatch,
                              RDBSS_NTC_MINIRDR_DISPATCH,
                              sizeof(MINIRDR_DISPATCH));

    //
    // Reflector extension sizes and allocation policies.
    // CODE.IMPROVEMENT. Currently we do not allocate the NET_ROOT and
    // SRV_CALL extensions in the wrapper. Except for V_NET_ROOT wherein it is
    // shared across multiple instances in the wrapper all the other data
    // structure management should be left to the wrappers.
    //

    MRxDAVDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION         |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION    |
                               RDBSS_MANAGE_FOBX_EXTENSION        |
                               RDBSS_MANAGE_V_NET_ROOT_EXTENSION  |
                               RDBSS_NO_DEFERRED_CACHE_READAHEAD);
    
    MRxDAVDispatch.MRxSrvCallSize  = 0;
    MRxDAVDispatch.MRxNetRootSize  = 0;
    MRxDAVDispatch.MRxVNetRootSize = sizeof(WEBDAV_V_NET_ROOT);
    MRxDAVDispatch.MRxFcbSize      = sizeof(WEBDAV_FCB);
    MRxDAVDispatch.MRxSrvOpenSize  = sizeof(WEBDAV_SRV_OPEN);
    MRxDAVDispatch.MRxFobxSize     = sizeof(WEBDAV_FOBX); 

    //
    // Mini redirector cancel routine.
    //
    MRxDAVDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop
    //
    MRxDAVDispatch.MRxStart                = MRxDAVStart;
    MRxDAVDispatch.MRxStop                 = MRxDAVStop;
    MRxDAVDispatch.MRxDevFcbXXXControlFile = MRxDAVDevFcbXXXControlFile;

    //
    // Mini redirector name resolution
    //
    MRxDAVDispatch.MRxCreateSrvCall = MRxDAVCreateSrvCall;
    MRxDAVDispatch.MRxSrvCallWinnerNotify = MRxDAVSrvCallWinnerNotify;
    MRxDAVDispatch.MRxCreateVNetRoot = MRxDAVCreateVNetRoot;
    MRxDAVDispatch.MRxUpdateNetRootState = MRxDAVUpdateNetRootState;
    MRxDAVDispatch.MRxExtractNetRootName = MRxDAVExtractNetRootName;
    MRxDAVDispatch.MRxFinalizeSrvCall = MRxDAVFinalizeSrvCall;
    MRxDAVDispatch.MRxFinalizeNetRoot = MRxDAVFinalizeNetRoot;
    MRxDAVDispatch.MRxFinalizeVNetRoot = MRxDAVFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //
    MRxDAVDispatch.MRxCreate                      = MRxDAVCreate;
    MRxDAVDispatch.MRxCollapseOpen                = MRxDAVCollapseOpen;
    MRxDAVDispatch.MRxShouldTryToCollapseThisOpen = MRxDAVShouldTryToCollapseThisOpen;
    MRxDAVDispatch.MRxExtendForCache              = MRxDAVExtendForCache;
    MRxDAVDispatch.MRxExtendForNonCache           = MRxDAVExtendForNonCache;
    MRxDAVDispatch.MRxTruncate                    = MRxDAVTruncate;
    MRxDAVDispatch.MRxCleanupFobx                 = MRxDAVCleanupFobx;
    MRxDAVDispatch.MRxCloseSrvOpen                = MRxDAVCloseSrvOpen;
    MRxDAVDispatch.MRxFlush                       = MRxDAVFlush;
    MRxDAVDispatch.MRxForceClosed                 = MRxDAVForcedClose;
    MRxDAVDispatch.MRxDeallocateForFcb            = MRxDAVDeallocateForFcb;
    MRxDAVDispatch.MRxDeallocateForFobx           = MRxDAVDeallocateForFobx;
    // MRxDAVDispatch.MRxIsLockRealizable         = UMRxIsLockRealizable;

    //
    // File System Objects query/Set.
    //
    MRxDAVDispatch.MRxQueryDirectory   = MRxDAVQueryDirectory;
    MRxDAVDispatch.MRxQueryVolumeInfo  = MRxDAVQueryVolumeInformation;
    MRxDAVDispatch.MRxQueryEaInfo     = MRxDAVQueryEaInformation;
    MRxDAVDispatch.MRxSetEaInfo       = MRxDAVSetEaInformation;
    // MRxDAVDispatch.MRxQuerySdInfo     = UMRxQuerySecurityInformation;
    // MRxDAVDispatch.MRxSetSdInfo       = UMRxSetSecurityInformation;
    MRxDAVDispatch.MRxQueryFileInfo    = MRxDAVQueryFileInformation;
    MRxDAVDispatch.MRxSetFileInfo      = MRxDAVSetFileInformation;
    // MRxDAVDispatch.MRxSetFileInfoAtCleanup = UMRxSetFileInformationAtCleanup;
    MRxDAVDispatch.MRxIsValidDirectory= MRxDAVIsValidDirectory;


    //
    // Buffering state change.
    //
    MRxDAVDispatch.MRxComputeNewBufferingState = MRxDAVComputeNewBufferingState;

    //
    // File System Object I/O.
    //
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_READ]               = MRxDAVRead;
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]              = MRxDAVWrite;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = UMRxLocks;
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]              = MRxDAVFsCtl;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = UMRxIoCtl;
    
    //
    // Shouldn't flush come through lowio?
    //
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] =
    //                                              UMRxNotifyChangeDirectory;

    //
    // Miscellanous.
    //
    // MRxDAVDispatch.MRxCompleteBufferingStateChangeRequest =
    //                                 UMRxCompleteBufferingStateChangeRequest;

    // initialize the mutex which protect the file info cache expire timer
    ExInitializeFastMutex(&MRxDAVFileInfoCacheLock);

    return;
}


NTSTATUS
MRxDAVFsdDispatch(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the DAV miniredir.
    
Arguments:

    RxDeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed.

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    UCHAR MajorFunctionCode  = IrpSp->MajorFunction;
    UCHAR MinorFunctionCode  = IrpSp->MinorFunction;
    PFILE_OBJECT FileObject  = IrpSp->FileObject;
    PWCHAR SaveInitialString = NULL;
    BOOL JustAServer = FALSE;
    ULONG IoControlCode = 0;
    PQUERY_PATH_REQUEST qpRequest = NULL;
    PWCHAR QueryPathBuffer = NULL;
    ULONG QueryPathBufferLength = 0; // Length in Bytes of QueryPathBuffer.
    KPROCESSOR_MODE ReqMode = 0;

    PAGED_CODE();

    //
    // Check if the PNP event indicating that the transports are ready has been
    // received. Till that time there is no point in forwarding requests to 
    // the user mode agent since this could put WinInet in a wierd state.
    //
    if (!MRxDAVTransportReady) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFsdDispatch. MRxDAVTransportReady == FALSE\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_REDIRECTOR_NOT_STARTED;
        goto COMPLETE_THE_REQUEST;
    }

    //
    // The first thing we need to check is whehter we got a DeviceIoControl
    // from MUP "IOCTL_REDIR_QUERY_PATH", to figure out if some UNC path is
    // owned by DAV or not. We need to check to see if the share supplied
    // in the path is one of the special SMB shares. These include PIPE, IPC$
    // and mailslot. If its one of these, then we reject the path at this stage
    // with a STATUS_BAD_NETOWRK_PATH response. This is better than rejecting
    // it at the creation of netroot becuase we save a network trip to the 
    // server while creating the SrvCall.
    //

    try {

        if (MajorFunctionCode == IRP_MJ_DEVICE_CONTROL) {

            ReqMode = Irp->RequestorMode;

            //
            // Get the IoControlCode from IrpSp.
            //
            IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

            //
            // If the IoControlCode is "IOCTL_REDIR_QUERY_PATH", we need to do the 
            // following. We basically check to see if the request came down for
            // any of the special SMB shares. If it did, then we return.
            //
            if (IoControlCode == IOCTL_REDIR_QUERY_PATH) {

                PWCHAR QPPtr1 = NULL;
                BOOL FirstWack = TRUE, SpecialShare = FALSE;
                UNICODE_STRING UnicodeShareName, uniFileName;
                ULONG ShareNameLengthInBytes = 0;

                //
                // This particular IOCTL should only come to us from the MUP and
                // hence the requestor mode of the IRP should always be 
                // KernelMode. If its not we return STATUS_INVALID_DEVICE_REQUEST.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto COMPLETE_THE_REQUEST;
                }

                qpRequest  = METHODNEITHER_OriginalInputBuffer(IrpSp);

                //
                // If the requestor mode is not Kernel, we need to probe the buffer.
                // Probe the buffer that was supplied by the caller of the IOCTL to
                // make sure that its valid. This is to prevent hacker programs from
                // using this IOCTL to pass in invalid buffers.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = MRxDAVProbeForReadWrite((PBYTE)qpRequest, sizeof(QUERY_PATH_REQUEST), TRUE, FALSE);
                    if (NtStatus != STATUS_SUCCESS) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch/MRxDAVProbeForReadWrite(1). "
                                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                        goto COMPLETE_THE_REQUEST;
                    }
                }

                QueryPathBuffer = (PWCHAR)(qpRequest->FilePathName);
                ASSERT(QueryPathBuffer != NULL);
                QueryPathBufferLength = qpRequest->PathNameLength;

                //
                // If the requestor mode is not Kernel, we need to probe the buffer.
                // Probe the file name buffer (which is a part of the structure) 
                // that was supplied by the caller of the IOCTL to make sure that 
                // its valid.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = MRxDAVProbeForReadWrite((PBYTE)QueryPathBuffer, QueryPathBufferLength, TRUE, FALSE);
                    if (NtStatus != STATUS_SUCCESS) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch/MRxDAVProbeForReadWrite(2). "
                                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                        goto COMPLETE_THE_REQUEST;
                    }
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: Type3InputBuffer = %ws\n",
                             PsGetCurrentThreadId(), QueryPathBuffer));

                //
                // The Type3InputBuffer is of the form \server\share or 
                // \server\share\ or \server\share\path. We make the 
                // QueryPathBuffer point to the char after the \ character.
                //
                QueryPathBuffer += 1;
                ASSERT(QueryPathBuffer != NULL);

                //
                // We subtract ( sizeof(WCHAR) ) from the buffer length because
                // the QueryPathBuffer points starting from the server name. It 
                // skips the first WCHAR which is \.
                //
                QueryPathBufferLength -= sizeof(WCHAR);

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: QueryPathBufferLength = %d\n",
                             PsGetCurrentThreadId(), QueryPathBufferLength));

                //
                // If we just got a \ down from the MUP, then the value of 
                // QueryPathBufferLength will now be zero since we have already 
                // taken out 2 bytes above. We return right away in such a situation.
                //
                if (QueryPathBufferLength == 0) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVFsdDispatch: QueryPathBufferLength == 0\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                //
                // The loop below is to set the start of the sharename and to 
                // calculate the length of the sharename in bytes.
                //
                while (TRUE) {

                    if ( *QueryPathBuffer == L'\\' ) {
                        if (FirstWack) {
                            QPPtr1 = QueryPathBuffer;
                            FirstWack = FALSE;
                        } else {
                            break;
                        }
                    }

                    if (!FirstWack) {
                        ShareNameLengthInBytes += sizeof(WCHAR);
                    }

                    QueryPathBufferLength -= sizeof(WCHAR);
                    if (QueryPathBufferLength == 0) {
                        break;
                    }

                    QueryPathBuffer++;

                }

                //
                // If only a server name was specified then QPPrt1 will be NULL or
                // QPPtr1 will not be NULL but ShareNameLengthInBytes == sizeof(WCHAR).
                // QPPtr1 == NULL ==> \server
                // ShareNameLengthInBytes == sizeof(WCHAR) ==> \server\
                //
                if ( QPPtr1 == NULL || ShareNameLengthInBytes == sizeof(WCHAR) ) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    if (QPPtr1 == NULL) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch: QPPtr1 == NULL\n",
                                     PsGetCurrentThreadId()));
                    } else {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch: "
                                     "ShareNameLengthInBytes == sizeof(WCHAR)\n",
                                     PsGetCurrentThreadId()));
                    }
                    goto COMPLETE_THE_REQUEST;
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: QPPtr1 = %ws\n",
                             PsGetCurrentThreadId(), QPPtr1));

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: ShareNameLengthInBytes = %d\n",
                             PsGetCurrentThreadId(), ShareNameLengthInBytes));

                //
                // Set the Unicode string. The OPPtr1 pointer points to the \ before
                // the share name. So if the path was \server\share\dir,
                // \server\share\dir
                //        ^
                //        |
                //        QPPtr1
                // Accordingly, the ShareNameLengthInBytes contains an extra 
                // sizeof(WCHAR) bytes for the \ char.
                //
                UnicodeShareName.Buffer = QPPtr1;
                UnicodeShareName.Length = (USHORT)ShareNameLengthInBytes;
                UnicodeShareName.MaximumLength = (USHORT)ShareNameLengthInBytes;

                //
                // We now take this name and see if it matches any of the special
                // SMB shares. If it does, we return STATUS_BAD_NETWORK_PATH.
                //

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_PipeShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: PIPE == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_MailSlotShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: MAILSLOT == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_IpcShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: IPC$ == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                //
                // Check whether we need to skip some files. See the explanation
                // below (in the function definition) for why IRPs are skipped.
                //
                uniFileName.Buffer=(PWCHAR)(qpRequest->FilePathName);
                uniFileName.Length = uniFileName.MaximumLength = (USHORT)(qpRequest->PathNameLength);

                if (MRxDAVSkipIrps(Irp, &uniFileName, TRUE) == STATUS_SUCCESS)
                {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: Skipped\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

            }

        }
        
        if (MajorFunctionCode == IRP_MJ_CREATE) {
            //
            // See the explanation below (in the function definition) for why
            // IRPs are skipped. Send the filename in the fileobject.
            //
            if (MRxDAVSkipIrps(Irp, &FileObject->FileName, FALSE) == STATUS_SUCCESS)
            {
                NtStatus = STATUS_BAD_NETWORK_PATH;
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: ERROR: MRxDAVFsdDispatch: Skipped\n",
                             PsGetCurrentThreadId()));
                goto COMPLETE_THE_REQUEST;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

          NtStatus = STATUS_INVALID_PARAMETER;
    
          DavDbgTrace(DAV_TRACE_ERROR,
                      ("%ld: ERROR: MRxDAVFsdDispatch: Exception!!!\n",
                       PsGetCurrentThreadId()));
          
          goto COMPLETE_THE_REQUEST;

    }

    //
    // Save the filename passed in by the I/O manager. This is freed up later.
    //
    if (FileObject) {
        SaveInitialString = FileObject->FileName.Buffer;
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFsdDispatch. MajorFunction = %d, MinorFunction = %d"
                 ", FileObject = %08lx.\n", PsGetCurrentThreadId(), 
                 MajorFunctionCode, MinorFunctionCode, FileObject));

#ifdef DAVWMILOGGING_K

    if (IrpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        NtStatus = MRxDAVProcessSystemControlIrp((PDEVICE_OBJECT)RxDeviceObject, Irp);
        goto EXIT_THE_FUNCTION;
    }

#endif
    
#ifdef DAVWMILOGGING_K
    
    DavLog(LOG, 
           MRxDavFsdDispatch_1, 
           LOGUCHAR(MajorFunctionCode) 
           LOGUCHAR(MinorFunctionCode) 
           LOGPTR(FileObject));

#endif

    if (SaveInitialString) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFsdDispatch: FileName: %wZ, FileObject: %08lx\n", 
                     PsGetCurrentThreadId(), FileObject->FileName, FileObject));

        //
        // If the first and the second chars are '\'s, then its possible that
        // the name is just a \\server. Its possible that the name is of the
        // form \;X:0\path and hence we check for the second \ as well. So,
        // only if the first two chars are \ and \ we proceed to check whether
        // the create is just for just a server.
        //
        if ( SaveInitialString[0] == L'\\' && SaveInitialString[1] == L'\\' ) {

            PWCHAR wcPtr1 = NULL;
            ULONG MaxNameLengthInWChars = 0;
            
            MaxNameLengthInWChars = ( FileObject->FileName.Length / sizeof(WCHAR) );

            //
            // We assume that this is of the form \\server. If its not, then
            // this value is changed to FALSE below.
            //
            JustAServer = TRUE;

            //
            // Is the FileName just a server? Its possible that the FileName is
            // of the form \\server.
            //
            wcPtr1 = &(SaveInitialString[2]);

            //
            // If we have a '\' after the first two chars and atleast a single 
            // char after that, it means that the name is not of the form
            // \\server or \\server\.
            //
            while ( (MaxNameLengthInWChars - 2) > 0 ) {
                if ( *wcPtr1 == L'\\' && *(wcPtr1 + 1) != L'\0' ) {
                    JustAServer = FALSE;
                    break;
                }
                MaxNameLengthInWChars--;
                wcPtr1++;
            }
        
        }    
    
    }

    //
    // If JustAServer is TRUE then the network path name is invalid.
    //
    if (JustAServer) {
        NtStatus = STATUS_BAD_NETWORK_PATH;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFsdDispatch: JustAServer == TRUE. SaveInitialString = %ws\n",
                     PsGetCurrentThreadId(), SaveInitialString));
        goto COMPLETE_THE_REQUEST;
    }

    //
    // Call RxFsdDispatch.
    //
    NtStatus = RxFsdDispatch(RxDeviceObject, Irp);
    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: Leaving MRxDAVFsdDispatch with NtStatus(2) = %08lx,"
                     " FileObject = %08lx, MjFn = %d, MiFn = %d.\n", 
                     PsGetCurrentThreadId(), NtStatus, FileObject,
                     MajorFunctionCode, MinorFunctionCode));
    }

    goto EXIT_THE_FUNCTION;

COMPLETE_THE_REQUEST:

    //
    // We come here if we did not call into RDBSS and need to complete the 
    // IRP ourselves.
    // 
    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

EXIT_THE_FUNCTION:

    return NtStatus;
}


VOID
MRxDAVDeregisterAndCleanupDeviceObject(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    Note: The mutex is already acquired and we're already off the list.

Arguments:

    UMRdrDeviceObject - The device object being deregistered and cleaned.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeregisterAndCleanupDeviceObject!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDeregisterAndCleanupDeviceObject: "
                 "UMRefDeviceObject: %08lx.\n", 
                 PsGetCurrentThreadId(), UMRefDeviceObject));

    NtStatus = UMRxCleanUpDeviceObject(UMRefDeviceObject);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDeregisterAndCleanupDeviceObject/"
                     "UMRxCleanUpDeviceObject: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }

    RxUnregisterMinirdr(&UMRefDeviceObject->RxDeviceObject);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDeregisterAndCleanupDeviceObject.\n",
                 PsGetCurrentThreadId()));
}


NTSTATUS
MRxDAVFlush(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles the "File Flush" requests.

Arguments:

    RxContext - The context created by RDBSS.

Return Value:

    NTSTATUS or the appropriate NT error code.

--*/
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}


VOID
MRxDAVPnPBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    )
/*++

Routine Description:

    The TDI callbacks routine for binding changes.

Arguments:

    PnPOpcode - The PNP op code.

    pTransportName - The transport name.

    BindingList - The binding order.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    switch (PnPOpcode) {
    
    case TDI_PNP_OP_NETREADY: {
        MRxDAVTransportReady = TRUE;
    }
    break;

    default:
        break;
    
    }

    return;
}


NTSTATUS
MRxDAVRegisterForPnpNotifications(
    VOID
    )
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications.

Arguments:

    None.

Return Value:

    The NTSTATUS code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if ( MRxDAVTdiNotificationHandle == NULL ) {
        
        UNICODE_STRING ClientName;

        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

        RtlInitUnicodeString( &(ClientName), L"WebClient");

        ClientInterfaceInfo.MajorTdiVersion = 2;
        ClientInterfaceInfo.MinorTdiVersion = 0;

        ClientInterfaceInfo.Unused = 0;
        ClientInterfaceInfo.ClientName = &ClientName;

        ClientInterfaceInfo.BindingHandler = MRxDAVPnPBindingHandler;
        ClientInterfaceInfo.AddAddressHandler = NULL;
        ClientInterfaceInfo.DelAddressHandler = NULL;
        ClientInterfaceInfo.PnPPowerHandler = NULL;

        NtStatus = TdiRegisterPnPHandlers ( &(ClientInterfaceInfo),
                                            sizeof(ClientInterfaceInfo),
                                            &(MRxDAVTdiNotificationHandle) );
    
    }

    return NtStatus;
}


NTSTATUS
MRxDAVDeregisterForPnpNotifications(
    VOID
    )
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism.
    
Arguments:

    None.

Return Value:

    The NTSTATUS code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if ( MRxDAVTdiNotificationHandle != NULL ) {
        
        NtStatus = TdiDeregisterPnPHandlers( MRxDAVTdiNotificationHandle );

        if( NT_SUCCESS( NtStatus ) ) {
            MRxDAVTdiNotificationHandle = NULL;
        }
    
    }

    return NtStatus;
}


NTSTATUS
MRxDAVProbeForReadWrite(
    IN PBYTE BufferToBeValidated,
    IN DWORD BufferSize,
    IN BOOL doProbeForRead,
    IN BOOL doProbeForWrite
    )
/*++

Routine Description:

    This function probes the buffer that is supplied by the caller for read/write
    access. This is done because the caller of an IOCTL might supply a invalid
    buffer accessing which might cause a bugcheck.

Arguments:

    BufferToBeValidated - The Buffer which has to be validated for read/write
                          access.
                          
    BufferSize - The size of the buffer being validated.
    
    doProbeForRead - If TRUE, then probe the buffer for read.

    doProbeForWrite - If TRUE, then probe the buffer for write.

Return Value:

    STATUS_SUCCESS or STATUS_INVALID_USER_BUFFER.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // We call the functions ProbeForRead and ProbeForWrite in a try/except
    // loop because these functions throw an exception if the buffer supplied
    // is invalid. We catch the exception and set the appropriate NtStatus 
    // value.
    //
    try {
        if (BufferToBeValidated != NULL) {
            if (doProbeForRead) {
                ProbeForRead(BufferToBeValidated, BufferSize, 1);
            }
            if (doProbeForWrite) {
                ProbeForWrite(BufferToBeValidated, BufferSize, 1);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_INVALID_USER_BUFFER;
    }

    return NtStatus;
}


NTSTATUS
MRxDAVSkipIrps(
    IN PIRP Irp,
    IN PUNICODE_STRING fileName,
    IN BOOL fCheckAny
    )
/*++

Routine Description:

    This routine skips IRPs coming to the DAV redir which may cause deadlock. 
    Webdav's user mode component uses wininet to get to DAV servers. When a 
    service which is running this server process satisfying key wininet needs
    makes a remote call we deadlock. The two such services are winsock and Sense.
    When another service in the svchost which they are running under tries to do
    a loadlibrary located on a remote machine (in our famous example of \\davis\
    tools\ifsproxy.dll), loader APIs get invoked. These APis take the loader lock
    and issue an NtQueryAttributes call. This call is translated into QUERY_PATH
    ioctl by the MUP whci it send to all redirs, including webdav. Webdav refelcts
    it up to the usermode and the webdav service issues wininet call to look for
    the server (davis in the above example). Wininet issues a call to winsock to
    makes a sockets call. This call ends up issuing an rpc to the NLA service in
    another svchost which is the same svchost process that initiated the loadlibrary
    call. The server now tries to take the loader lock and the webdav redir is now
    deadlocked.
    
    This scheme also protects us from looping back to ourselves because of
    wininet's loadlibrary calls as webdav service also runs as part of an svchost.
    
    This routine looks for the process issuing the irp to webdav and if it is an
    svchost process and it is trying to look for a dll or an exe then we return it
    as being not found. This implies that dlls and exes kept on a webdav server
    cannot be loaded from svchosts till we get away from wininet.


Arguments:

    Irp - The irp that came to webdav.
    
    filename - Name of the file if any.
    
    fCheckAny - If this is TRUE, then we reject this IRP if the process is
                svchost.exe. If this is FALSE, then we only reject the IRP if
                the filename has the extension dll or exe and the process is
                svchost.exe.

Return Value:

    STATUS_SUCCESS - Skip this IRP.
    
    STATUS_UNSUCCESSFUL - Do not skip this IRP.

--*/
{
    WCHAR ImageFileName[DAV_SVCHOST_NAME_SIZE]; //keep some reasonable stack space
    ULONG UnicodeSize = 0;
    UNICODE_STRING uniImageFileName;
    UCHAR *pchImageFileName = PsGetProcessImageFileName(PsGetCurrentProcess());
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    RtlZeroMemory(ImageFileName, sizeof(ImageFileName));
    
    RtlMultiByteToUnicodeN(ImageFileName, sizeof(ImageFileName), &UnicodeSize, pchImageFileName, 16);

    uniImageFileName.Buffer = ImageFileName;
    uniImageFileName.Length = uniImageFileName.MaximumLength = uniSvcHost.Length;

    //
    // Check whether the calling process is svchost.exe.
    //
    if (!RtlCompareUnicodeString(&uniImageFileName, &uniSvcHost, TRUE))
    {
        if (!fCheckAny)
        {
            UNICODE_STRING exe = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"exe" };
            UNICODE_STRING dll = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"dll" };
            UNICODE_STRING s;
            //
            // If the filename ends in .DLL or .exe, we return success, which will
            // end up failing the operation.
            //
            if( fileName->Length > 4 * sizeof(WCHAR) &&
                fileName->Buffer[ fileName->Length/sizeof(WCHAR) - 4 ] == L'.'){

                s.Length = s.MaximumLength = 3 * sizeof( WCHAR );
                s.Buffer = &fileName->Buffer[ (fileName->Length - s.Length)/sizeof(WCHAR) ];

                if( RtlCompareUnicodeString( &s, &exe, TRUE ) == 0 ||
                    RtlCompareUnicodeString( &s, &dll, TRUE ) == 0 ) {
            
                    return STATUS_SUCCESS;
                }
            }
        }
        else
        {
            return STATUS_SUCCESS;
        }
        
    }
    
    return STATUS_UNSUCCESSFUL;
}

#ifdef DAVWMILOGGING_K

NTSTATUS
MRxDAVProcessSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for WMI requests.

Arguments:

    DeviceObject - Pointer to the class device object.
    
    Irp - Pointer to the request packet.

Return Value:

    NTSTATUS is returned.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WML_TINY_INFO WmlTinyInfo;
    UNICODE_STRING DavRegPath;

    PAGED_CODE();

    if (DavEnableWmiLog) {
        
        RtlInitUnicodeString ( &(DavRegPath), L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MRxDAV" );

        RtlZeroMemory ( &(WmlTinyInfo), sizeof(WmlTinyInfo) );

        WmlTinyInfo.ControlGuids = MRxDav_ControlGuids;
        WmlTinyInfo.GuidCount = MRxDav_ControlGuids_len;
        WmlTinyInfo.DriverRegPath = &(DavRegPath);

        NtStatus = WmlTinySystemControl( &(WmlTinyInfo), DeviceObject, Irp );
        if (NtStatus != STATUS_SUCCESS) {
            DbgPrint("MRxDAVProcessSystemControlIrp/WmlTinySystemControl:"
                     " NtStatus = %08lx\n", NtStatus);
        }
    
    } else {
        
        NtStatus = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = NtStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    }

    return NtStatus;
}

#endif // DAVWMILOGGING_K
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\locks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
UMRxLocks(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("UMRxLocks\n", 0 ));

    IF_DEBUG {
        RxCaptureFobx;
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  //ok
    }

    Status = STATUS_NOT_IMPLEMENTED;


    RxDbgTrace(-1, Dbg, ("UMRxLocks  exit with status=%08lx\n", Status ));
    return(Status);

}

#if 0
NTSTATUS
UMRxUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    )
/*++

Routine Description:

    This routine is called from the RDBSS whenever the fsrtl lock package calls the rdbss unlock routine.
    CODE.IMPROVEMENT what should really happen is that this should only be called for unlockall and unlockbykey;
    the other cases should be handled in the rdbss.

Arguments:

    Context - the RxContext associated with this request
    LockInfo - gives information about the particular range being unlocked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
       return STATUS_SUCCESS;
    case LOWIO_OP_UNLOCKALL:
    case LOWIO_OP_UNLOCKALLBYKEY:
    default:
       return STATUS_NOT_IMPLEMENTED;
    }
}
#endif


NTSTATUS
UMRxCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used. CODE.IMPROVEMENT this param is redundant if the rxcontext is filled out completely

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    PUMRX_SRV_OPEN umrxSrvOpen = UMRxGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("UMRxCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("-->Context %lx\n",pContext));

    Status = STATUS_SUCCESS;

    RxDbgTrace(-1, Dbg, ("UMRxAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}



NTSTATUS
UMRxIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
{

    PAGED_CODE();
    return(STATUS_SUCCESS);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

//
// A MiniRedir must declare its name and imports ptr.
//
#define MINIRDR__NAME MRxDAV
#define ___MINIRDR_IMPORTS_NAME (MRxDAVDeviceObject->RdbssExports)
#define RX_PRIVATE_BUILD 1

//
// Get the minirdr environment.
//
#include "rx.h"

//
// NT network file system driver include files.
//
#include "ntddnfs2.h"

//
// Reflector library's user mode header file.
//
#include "ntumrefl.h"

//
// Describes the data structures shared by the user and kernel mode
// components of the DAV miniredir.
//
#include "usrmddav.h"

#include "netevent.h"

#include "davname.h"

#include "infocach.h"


//
// Reflector library's kernel mode header file.
//
#include "umrx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\srvcall.c ===
/*++ 

Copyright (c) 1999  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation 
    of server entries in the connection engine database. 

Author:

    Balan Sethu Raman  [SethuR]
    
    Rohan Kumar        [RohanK]       04-April-1999

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

VOID
MRxDAVSrvCallWrapper(
    PVOID Context
    );

NTSTATUS
MRxDAVCreateSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVFinalizeSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVCreateSrvCall)
#pragma alloc_text(PAGE, MRxDAVSrvCallWrapper)
#pragma alloc_text(PAGE, MRxDAVCreateSrvCallContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSrvCallCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSrvCallCreateRequest)
#pragma alloc_text(PAGE, MRxDAVFinalizeSrvCall)
#pragma alloc_text(PAGE, MRxDAVFinalizeSrvCallContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSrvCallFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSrvCallFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVSrvCallWinnerNotify)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVCreateSrvCall(
    PMRX_SRV_CALL SrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT CallbackContext
    )
/*++

Routine Description:

   This routine handles the creation of SrvCalls.

Arguments:

    SrvCall - 

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = CallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PRX_CONTEXT RxContext = NULL;

    PAGED_CODE();

#if 1
    
    SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(CallbackContext->SrvCalldownStructure);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateSrvCall!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateSrvCall: SrvCall: %08lx, CallbackContext: "
                 "%08lx.\n", PsGetCurrentThreadId(), SrvCall, CallbackContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateSrvCall: SrvCallName: %wZ\n",
                 PsGetCurrentThreadId(), SrvCall->pSrvCallName));

    //
    // Perform the following checks.
    //
    ASSERT(NodeType(SrvCall) == RDBSS_NTC_SRVCALL);
    ASSERT(SrvCall);
    ASSERT(SrvCall->pSrvCallName);
    ASSERT(SrvCall->pSrvCallName->Buffer);
    ASSERT(SCCBC->RxDeviceObject);

    //
    // Before delaying the final close, RDBSS looks at the number of closes that
    // have been delayed and compares it against this value.
    //
    SrvCall->MaximumNumberOfCloseDelayedFiles = 150;

    //
    // Allocate memory for the context pointer in the SrvCall structure. This is
    // for the Mini-Redirs use.
    //
    ASSERT(SrvCall->Context == NULL);
    SrvCall->Context = RxAllocatePoolWithTag(NonPagedPool,
                                             sizeof(WEBDAV_SRV_CALL),
                                             DAV_SRVCALL_POOLTAG);
    if (SrvCall->Context == NULL) {
        //
        // There was an error in dispatching the MRxDAVSrvCallWrapper method to
        // a worker thread. Complete the request and return STATUS_PENDING.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVCreateSrvCall/RxAllocatePoolWithTag.\n",
                     PsGetCurrentThreadId()));
        SCCBC->Status = STATUS_INSUFFICIENT_RESOURCES;
        SrvCalldownStructure->CallBack(SCCBC);
        NtStatus = STATUS_PENDING;
        return NtStatus;
    }

    RtlZeroMemory(SrvCall->Context, sizeof(WEBDAV_SRV_CALL));

    //
    // Check to see if the DAV server mentioned in the SrvCall exists. To do 
    // this, we need to go to the usermode and call GetHostByName on the name
    // mentioned in the SrvCall strucutre.
    //
    RxContext = SrvCalldownStructure->RxContext;

    //
    // We need to pass the server name to the user mode to check whether such a 
    // server actually exists. RxContext has 4 pointers that the mini-redirs 
    // can use. Here we use MRxContext[1]. We store a reference to the SCCBC
    // strucutre which contains the name of the server. MRxContext[0] is used to 
    // store a reference to the AsynEngineContext and this is done when the 
    // context gets created in the function UMRxCreateAsyncEngineContext. The
    // pointer to SCCBC is also used while calling the callback function to
    // complete the creation of the SrvCall.
    //
    RxContext->MRxContext[1] = SCCBC;

    //
    // Dispatch the request to a system thread.
    //
    NtStatus = RxDispatchToWorkerThread((PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject,
                                        DelayedWorkQueue,
                                        MRxDAVSrvCallWrapper,
                                        RxContext);
    if (NtStatus == STATUS_SUCCESS) {
        //
        // Map the return value since the wrapper expects STATUS_PENDING.
        //
        NtStatus = STATUS_PENDING;
    } else {
        //
        // There was an error in dispatching the MRxDAVSrvCallWrapper method to
        // a worker thread. Complete the request and return STATUS_PENDING.
        //
        SCCBC->Status = NtStatus;
        SrvCalldownStructure->CallBack(SCCBC);
        NtStatus = STATUS_PENDING;
    }

#else 
    
    SCCBC->Status = STATUS_SUCCESS;
    SrvCalldownStructure->CallBack(SCCBC);
    NtStatus = STATUS_PENDING;

#endif

    return(NtStatus);
}


VOID
MRxDAVSrvCallWrapper(
    PVOID Context
    )
/*++

Routine Description:

   This routine is called by the worker thread. Its a routine that wraps the 
   call to MRxDAVOuterWrapper.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVSrvCallWrapper!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVSrvCallWrapper: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL,
                                        MRxDAVCreateSrvCallContinuation,
                                        "MRxDAVCreateSrvCall");

    //
    // If we failed to queue the request to be sent to the usermode, then we
    // need to do some cleanup.
    //
    if (NtStatus != STATUS_SUCCESS &&  NtStatus != STATUS_PENDING) {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVSrvCallWrapper/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));

        //
        // The SrvCall pointer is stored in the SCCBC structure which is
        // stored in the MRxContext[1] pointer of the RxContext structure.
        // This is done in the MRxDAVCreateSrvCall function.
        //
        ASSERT(RxContext->MRxContext[1] != NULL);
        SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];

        SrvCalldownStructure = SCCBC->SrvCalldownStructure;
        ASSERT(SrvCalldownStructure != NULL);

        SrvCall = SrvCalldownStructure->SrvCall;
        ASSERT(SrvCall != NULL);

        DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
        ASSERT(DavSrvCall != NULL);

        //
        // Free the memory that was allocatted for the SecurityClientContext in
        // the function MRxDAVFormatTheDAVContext. Before Freeing the memory, we
        // need to delete the SecurityClientContext.
        //
        if (DavSrvCall->SCAlreadyInitialized) {
            ASSERT(RxContext->MRxContext[2] != NULL);
            SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
            RxFreePool(RxContext->MRxContext[2]);
            RxContext->MRxContext[2] = NULL;
            DavSrvCall->SCAlreadyInitialized = FALSE;
        }

        SCCBC->Status = NtStatus;
        SrvCalldownStructure->CallBack(SCCBC);

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVSrvCallWrapper with NtStatus = %08lx.\n",
                 PsGetCurrentThreadId(), NtStatus));

    return;
}


NTSTATUS
MRxDAVCreateSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This routine checks to see if the server for which a SrvCall is being
    created exists or not.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateSrvCallContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateSrvCallContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // We are executing in the context of a worker thread. No point in holding
    // onto this thread. Set the Async flag irrespective of the nature of the
    // request. By nature we mean sync or async. Also since CreateSrvCall has 
    // its own Callback, we do not need to call RxLowIoCompletion when the
    // AsyncEngineContext is getting finalized.
    //
    SetFlag(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
    AsyncEngineContext->ShouldCallLowIoCompletion = FALSE;

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                UMRX_ASYNCENGINE_ARGUMENTS,
                                MRxDAVFormatUserModeSrvCallCreateRequest,
                                MRxDAVPrecompleteUserModeSrvCallCreateRequest
                                );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateSrvCallContinuation with NtStatus ="
                 " %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}
    

NTSTATUS
MRxDAVFormatUserModeSrvCallCreateRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SrvCall create request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWCHAR ServerName = NULL;
    DWORD ServerNameLenInBytes = 0;
    PBYTE SecondaryBuff = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST SrvCallCreateReq = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PSECURITY_SUBJECT_CONTEXT SecSubCtx = NULL;
    PNT_CREATE_PARAMETERS NtCP = &(RxContext->Create.NtCreateParameters);
    PACCESS_TOKEN AccessToken = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSrvCallCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSrvCallCreateRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    SrvCallCreateReq = &(DavWorkItem->CreateSrvCallRequest);
    
    //
    // Get the SecuritySubjectContext.
    //
    ASSERT(NtCP->SecurityContext->AccessState != NULL);
    SecSubCtx = &(NtCP->SecurityContext->AccessState->SubjectSecurityContext);

    //
    // Get the AccessToken.
    //
    AccessToken = SeQuerySubjectContextToken(SecSubCtx);
    
    //
    // Get the LogonID for this user/session.
    //
    if (!SeTokenIsRestricted(AccessToken)) {
        NtStatus = SeQueryAuthenticationIdToken(AccessToken, 
                                                &(SrvCallCreateReq->LogonID));
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                         "SeQueryAuthenticationIdToken. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        NtStatus = STATUS_ACCESS_DENIED;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                     "SeTokenIsRestricted. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck. The SecurityClientContext is stored in
    // RxContext->MRxContext[2]. This was done in MRxDAVFormatTheDAVContext.
    //
    ASSERT(RxContext->MRxContext[2] != NULL);
    SecurityClientContext = (PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2];
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->WorkItemType = UserModeCreateSrvCall;

    SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
    SrvCall = SCCBC->SrvCalldownStructure->SrvCall;

    //
    // Set the name of the server to be verified. We need to allocate memory
    // for the UserModeInfoBuff before filling in the ServerName in it.
    //
    ASSERT(SrvCall->pSrvCallName);
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLenInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLenInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeSrvCallCreateRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    SrvCallCreateReq->ServerName = (PWCHAR)SecondaryBuff;
    wcscpy(SrvCallCreateReq->ServerName, ServerName);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("ld: MRxDAVFormatUserModeSrvCallCreateRequest: ServerName = %ws\n",
                 PsGetCurrentThreadId(), SrvCallCreateReq->ServerName));

    if (RxContext->Create.UserName.Length) {
        RtlCopyMemory(DavWorkItem->UserName,RxContext->Create.UserName.Buffer,RxContext->Create.UserName.Length);
    }

    if (RxContext->Create.Password.Length) {
        RtlCopyMemory(DavWorkItem->Password,RxContext->Create.Password.Buffer,RxContext->Create.Password.Length);
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeSrvCallCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    FALSE - UMRxAsyncEngineCalldownIrpCompletion is NOT called by the function
            UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST SrvCallCreateReq = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse = NULL; 
    BOOL didFinalize = FALSE;                                          
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    BOOL AsyncOperation = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeSrvCallCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
    ASSERT(AsyncOperation == TRUE);

    //
    // We do the following only if the Operation has not been cancelled. If it
    // has been then this would have been done by the timer thread.
    //
    if (!OperationCancelled) {

        SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
        ASSERT(SCCBC != NULL);
        SrvCalldownStructure = SCCBC->SrvCalldownStructure;
        ASSERT(SrvCalldownStructure != NULL);
        SrvCall = SrvCalldownStructure->SrvCall;
        ASSERT(SrvCall != NULL);

        //
        // We allocated memory for it, so it better not be NULL.
        //
        DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
        ASSERT(DavSrvCall != NULL);

        //
        // Free the memory that was allocatted for the SecurityClientContext in the
        // function MRxDAVFormatTheDAVContext. Before Freeing the memory, we need
        // to delete the SecurityClientContext.
        //
        ASSERT(DavSrvCall->SCAlreadyInitialized == TRUE);
        ASSERT(RxContext->MRxContext[2] != NULL);
        SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
        RxFreePool(RxContext->MRxContext[2]);
        RxContext->MRxContext[2] = NULL;
        DavSrvCall->SCAlreadyInitialized = FALSE;

    } else {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    }

    SrvCallCreateReq = &(WorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(WorkItem->CreateSrvCallResponse);

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (SrvCallCreateReq->ServerName != NULL) {

        if (AsyncEngineContext->Status != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallCreateRequest."
                         " Server \"%ws\" is not a DAV server.\n",
                         PsGetCurrentThreadId(), SrvCallCreateReq->ServerName));
        }

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                       (PBYTE)SrvCallCreateReq->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (!OperationCancelled) {
        
        //
        // Get this servers unique ID.
        //
        DavSrvCall->ServerID = CreateSrvCallResponse->ServerID;
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: "
                     "ServerID = %ld assigned to this server entry.\n", 
                     PsGetCurrentThreadId(), DavSrvCall->ServerID));

        //
        // Set the status in the callback structure.
        //
        SCCBC->Status = AsyncEngineContext->Status;

    }

    //
    // We call the first finalize here since we return STATUS_PENDING back to 
    // the continuation routine in the create srvcall case. So the reference 
    // that was made at the time of creation of the AsyncEngineContext is not 
    // removed in the wrapper routine. The second finalize is because, we do not
    // call UMRxAsyncEngineCalldownIrpCompletion.
    //
    didFinalize = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
    didFinalize = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    if (!OperationCancelled) {
        //
        // Call the callback function supplied by RDBSS.
        //
        SrvCalldownStructure->CallBack(SCCBC);
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeSrvCallCreateRequest.\n",
                 PsGetCurrentThreadId()));
    
    return FALSE;
}


NTSTATUS
MRxDAVFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN Force
    )
/*++

Routine Description:

   This routine destroys a given server call instance.

Arguments:

    pSrvCall  - The server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pSrvCall->RxDeviceObject;
    PWEBDAV_SRV_CALL DavSrvCall;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeSrvCall.\n", 
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeSrvCall: SrvCall: %08lx, Force: %d.\n",
                 PsGetCurrentThreadId(), pSrvCall, Force));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFinalizeSrvCall: SrvCallName: %wZ\n",
                 PsGetCurrentThreadId(), pSrvCall->pSrvCallName));
    
    //
    // We allocated memory for pSrvCall->Context, so it better not be NULL.
    //
    ASSERT(pSrvCall != NULL);

    //
    // If the MiniRedir didn't get a chance to allocate a SrvCall, then we 
    // should return right away.
    //
    if (pSrvCall->Context == NULL) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFinalizeSrvCall. pSrvCall->Context == NULL\n", 
                     PsGetCurrentThreadId()));
        return NtStatus;
    }

    ASSERT(pSrvCall->Context != NULL);

    //
    // If we did not create any server entry for this server in the user mode,
    // then we do not need to go to the user mode at all. This fact is 
    // indicated by the ServerID field in the WEBDAV_SRV_CALL strucutre. If the
    // ID value is zero, that implies that the server entry was not created.
    //
    DavSrvCall = (PWEBDAV_SRV_CALL)pSrvCall->Context;
    if (DavSrvCall->ServerID == 0) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: No server entry was created in the user mode.\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeSrvCall/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to send the SrvCall to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pSrvCall;

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL,
                                        MRxDAVFinalizeSrvCallContinuation,
                                        "MRxDAVFinalizeSrvCall");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeSrvCall/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }
    
EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    //
    // Free up the memory allocated for the context pointer.
    //
    RxFreePool(pSrvCall->Context);
    pSrvCall->Context = NULL;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCall with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDAVFinalizeSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which finalizes a SrvCall.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeSrvCallContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeSrvCallContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeSrvCallFinalizeRequest,
                              MRxDAVPrecompleteUserModeSrvCallFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCallContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeSrvCallFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SrvCall finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinSrvCallReq = NULL;
    PWCHAR ServerName = NULL;
    ULONG ServerNameLengthInBytes = 0;
    PBYTE SecondaryBuff = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSrvCallFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSrvCallFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // SrvCall was set to MRxContext[0] in MRxDAVFinalizeSrvCall. We need it to
    // get the ServerID.
    //
    SrvCall = (PMRX_SRV_CALL)RxContext->MRxContext[1];
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);
    
    DavWorkItem->WorkItemType = UserModeFinalizeSrvCall;

    FinSrvCallReq = &(DavWorkItem->FinalizeSrvCallRequest);

    //
    // Set the ServerID.
    //
    FinSrvCallReq->ServerID = DavSrvCall->ServerID;
    
    //
    // Set the Server name.
    //
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLengthInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeSrvCallFinalizeRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    FinSrvCallReq->ServerName = (PWCHAR)SecondaryBuff;
    
    wcscpy(FinSrvCallReq->ServerName, ServerName);

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeSrvCallFinalizeRequest "
                 "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinSrvCallReq;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeSrvCallFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    FinSrvCallReq = &(WorkItem->FinalizeSrvCallRequest);

    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (FinSrvCallReq->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)FinSrvCallReq->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest. "
                     "Finalize SrvCall Failed!!!\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeSrvCallFinalizeRequest\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}


NTSTATUS
MRxDAVSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext
    )
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\stubs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements the mini redirector call down routines that are essentially
    just noops but which have to be implemented because the wrapper calls them without
    checking. In most cases, CODE.IMPROVEMENT the wrapper should either provide a stub
    to be used or check before calling.


Author:

    Joe Linn      [joelinn]      3-December-96

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbgg                              (0)


#if 0
NTSTATUS
UMRxTransportUpdateHandler(
    PRXCE_TRANSPORT_NOTIFICATION pTransportNotification)
/*++

Routine Description:

    This routine is the callback handler that is invoked by the RxCe when transports
    are either enabled or disabled. Since we do not use transports, we just return success.

Arguments:

    pTransportNotification - information pertaining to the transport

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:


--*/
{
    return STATUS_SUCCESS;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\webdav.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    webdav.h

Abstract:

    This module defines the data structures and functions related to the
    WebDav protocol.

Author:

    Rohan Kumar [rohank] 17-Mar-1999

Revision History:

--*/

#ifndef _WEBDAV_H
#define _WEBDAV_H

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif

//
// The miniredir dipatch vector used by RDBSS.
//
extern struct _MINIRDR_DISPATCH  MRxDAVDispatch;

//
// A serialization mutex used for various things.
//
extern FAST_MUTEX MRxDAVSerializationMutex;

//
// A pointer to the process that the RDBSS posts to. This is a non disappearing
// process!
//
extern PEPROCESS MRxDAVSystemProcess;

//
// The DavWinInetCachePath which is used in satisfying volume related queries.
//
extern WCHAR DavWinInetCachePath[MAX_PATH];

//
// The ProcessId of the svchost.exe process that loads the webclnt.dll.
//
extern ULONG DavSvcHostProcessId;

//
// The exchange device name will be stored in this KEY_VALUE_PARTIAL_INFORMATION
// structure.
//
extern PBYTE DavExchangeDeviceName;

//
// Name cache stuff. These values are read from the registry during init time.
//
extern ULONG FileInformationCacheLifeTimeInSec;
extern ULONG FileNotFoundCacheLifeTimeInSec;
extern ULONG NameCacheMaxEntries;

//
// The timeout value used by the MiniRedir. If an operation is not completed
// within the timeout then it is cancelled. The user can set this to 0xffffffff
// to disable the timeout/cancel logic. In other words, if the timeout value
// is 0xffffffff, the requests will never timeout.
//
extern ULONG RequestTimeoutValueInSec;
extern LARGE_INTEGER RequestTimeoutValueInTickCount;

//
// The timer object used by the timer thread that cancels the requests which
// have not completed in a specified time.
//
extern KTIMER DavTimerObject;

//
// This is used to indicate the timer thread to shutdown. When the system is
// being shutdown this is set to TRUE. MRxDAVTimerThreadLock is the resource
// used to gain access to this variable.
//
extern BOOL TimerThreadShutDown;
extern ERESOURCE MRxDAVTimerThreadLock;

//
// The handle of the timer thread that is created using PsCreateSystemThread
// is stored this global.
//
extern HANDLE TimerThreadHandle;

//
// This event is signalled by the timer thread right before its going to
// terminate itself.
//
extern KEVENT TimerThreadEvent;

#define DAV_MJ_READ  0
#define DAV_MJ_WRITE 1

//
// Pool tags used by the reflector library. All the DAV MiniRedir pool tags 
// have "DV" as the first two characters.
//
#define DAV_SRVCALL_POOLTAG   ('cSVD')
#define DAV_NETROOT_POOLTAG   ('tNVD')
#define DAV_FILEINFO_POOLTAG  ('iFVD')
#define DAV_FILENAME_POOLTAG  ('nFVD')
#define DAV_EXCHANGE_POOLTAG  ('xEVD')
#define DAV_READWRITE_POOLTAG ('wRVD')
#define DAV_QUERYDIR_POOLTAG  ('dQVD')

//
// Use the DavDbgTrace macro for logging Mini-Redir stuff in the kernel 
// debugger.
//
#if DBG
extern ULONG MRxDavDebugVector;
#define DAV_TRACE_ERROR      0x00000001
#define DAV_TRACE_DEBUG      0x00000002
#define DAV_TRACE_CONTEXT    0x00000004
#define DAV_TRACE_DETAIL     0x00000008
#define DAV_TRACE_ENTRYEXIT  0x00000010
#define DAV_TRACE_QUERYDIR   0x00000020
#define DAV_TRACE_OPENCLOSE  0x00000040
#define DAV_TRACE_READ       0x00000080
#define DAV_TRACE_WRITE      0x00000100
#define DAV_TRACE_SRVCALL    0x00000200
#define DAV_TRACE_FCBFOBX    0x00000400
#define DAV_TRACE_DAVNETROOT 0x00000800
#define DAV_TRACE_INFOCACHE  0x00001000
#define DAV_TRACE_ALL        0xffffffff
#define DavDbgTrace(_x_, _y_) {          \
        if (_x_ & MRxDavDebugVector) {   \
            DbgPrint _y_;                \
        }                                \
}
#else
#define DavDbgTrace(_x_, _y_)
#endif

//
// The initialization states of the miniredir.
//
typedef enum _WEBDAV_INIT_STATES {
    MRxDAVINIT_START,
    MRxDAVINIT_MINIRDR_REGISTERED
} WEBDAV_INIT_STATES;

//
// These are used by the entry point routines to specify what entrypoint was
// called. This facilitates common continuation routines.
//
typedef enum _WEBDAV_MINIRDR_ENTRYPOINTS {
    DAV_MINIRDR_ENTRY_FROM_CREATE = 0,
    DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX,
    DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL,
    DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT,
    DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL,
    DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT,
    DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN,
    DAV_MINIRDR_ENTRY_FROM_RENAME,
    DAV_MINIRDR_ENTRY_FROM_READ,
    DAV_MINIRDR_ENTRY_FROM_WRITE,
    DAV_MINIRDR_ENTRY_FROM_QUERYDIR,
    DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION,
    DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION,
    DAV_MINIRDR_ENTRY_FROM_MAXIMUM
} WEBDAV_MINIRDR_ENTRYPOINTS;

//
// The states of the I/O operation(s).
//
typedef enum _WEBDAV_INNERIO_STATE {
    MRxDAVInnerIoStates_Initial = 0,
    MRxDAVInnerIoStates_ReadyToSend,
    MRxDAVInnerIoStates_OperationOutstanding
} WEBDAV_INNERIO_STATE;

//
// The WebDav context structure that encapsulates the AsyncEngineCtx structure
// and has the miniredir specific fields.
//
typedef struct _WEBDAV_CONTEXT {

    //
    // The AsyncEngineCtx Structure used by the Reflector library.
    //
    union {
        UMRX_ASYNCENGINE_CONTEXT;
        UMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    };

    //
    // This is used by the entry point routines to specify what entrypoint was
    // called. This facilitates common continuation routines.
    //
    WEBDAV_MINIRDR_ENTRYPOINTS EntryPoint;

    //
    // These describe the inner state of the I/O operation. These states are
    // described in the MRxDAV_INNERIO_STATE data structure.
    //
    UCHAR  OpSpecificState;

    //
    // Pointer to the information strucutre for the Create request.
    //
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo;

    //
    // This is used in the Continuation functions for the read, write and
    // querydir calls. It keeps track of the number of times the Continuation
    // routine has been called.
    //
    ULONG ContinueEntryCount;

} WEBDAV_CONTEXT, *PWEBDAV_CONTEXT;

//
// While creating the AsyncEngineContext, the extra space needed for the
// miniredir specific fields is also allocated. Thus, one doesn't need to
// allocate twice.
//
#define SIZEOF_DAV_SPECIFIC_CONTEXT \
                    sizeof(WEBDAV_CONTEXT) - sizeof(UMRX_ASYNCENGINE_CONTEXT)

//
// The WebDav device object structure that encapsulates the UMRX_DEVICE_OBJECT
// structure and has the miniredir specific fields.
//
typedef struct _WEBDAV_DEVICE_OBJECT {

    //
    // The UMRX_DEVICE_OBJECT structure.
    //
    union {
        UMRX_DEVICE_OBJECT;
        UMRX_DEVICE_OBJECT UMRefDeviceObject;
    };

    //
    // TRUE => miniredir has been started.
    //
    BOOLEAN IsStarted;

    //
    // The FCB of the device object.
    //
    PVOID CachedRxDeviceFcb;

    //
    // The process registering this device object.
    //
    PEPROCESS RegisteringProcess;

} WEBDAV_DEVICE_OBJECT, *PWEBDAV_DEVICE_OBJECT;

//
// The Dav device object.
//
extern PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject;

//
// The extra number of bytes needed for the device object. This info is used
// when the device object gets created.
//
#define WEBDAV_DEVICE_OBJECT_EXTENSION_SIZE \
                   (sizeof(WEBDAV_DEVICE_OBJECT) - sizeof(RDBSS_DEVICE_OBJECT))

//
// The WEBDAV specific FOBX structure.
//
typedef struct _WEBDAV_FOBX {

    //
    // The pointer to the DavFileAttribute list for this directory. This list
    // is created on the first call to Enumerate files in the directory.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

    //
    // Number of DavFileAttribute entries.
    //
    ULONG NumOfFileEntries;

    //
    // The index of the next file to be returned to the user. The file index 
    // starts from zero, hence file index = 0 => the first file entry etc.
    //
    ULONG CurrentFileIndex;

    //
    // Pointer to the next entry.
    //
    PLIST_ENTRY listEntry;

} WEBDAV_FOBX, *PWEBDAV_FOBX;

//
// A pointer to an instance of WEBDAV_SRV_OPEN is stored in the context field
// of MRX_SRV_OPEN strucutre.
//
#define MRxDAVGetFobxExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PWEBDAV_FOBX)((pFobx)->Context))

//
// The WEBDAV specific SRV_OPEN structure.
//
typedef struct _WEBDAV_SRV_OPEN {

    //
    // The file handle associated with this SrvOpen.
    //
    HANDLE UnderlyingHandle;

    //
    // This also is the handle got from the usermode. Its used for debugging
    // purposes.
    //
    PVOID UserModeKey;

    //
    // Pointer to the file object associated with the handle. This is set
    // after the handle is successfully created in the usermode.
    //
    PFILE_OBJECT UnderlyingFileObject;

    //
    // Pointer to the device object represented by the file object mentioned
    // above.
    //
    PDEVICE_OBJECT UnderlyingDeviceObject;

    //
    // This indicates whether we need to call IoRaiseInformationalHardError
    // when the close fails. We need to do this if the PUT or DELETE failed and
    // the operation which the user expects has succeeded actually failed.
    //
    BOOL RaiseHardErrorIfCloseFails;

    //
    // Created In Kernel.
    //
    BOOL createdInKernel;

} WEBDAV_SRV_OPEN, *PWEBDAV_SRV_OPEN;

//
// A pointer to an instance of WEBDAV_SRV_OPEN is stored in the context field
// of MRX_SRV_OPEN strucutre.
//
#define MRxDAVGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PWEBDAV_SRV_OPEN)((pSrvOpen)->Context))
        
//
// The WEBDAV specific FCB structure.
//
typedef struct _WEBDAV_FCB {

    //
    // Is this FCB for a directory ?
    //
    BOOL isDirectory;

    //
    // Does the File exist in the WinInet cache ??
    //
    BOOL isFileCached;
    
    //
    // Should this file be deleted on Close ?
    //
    BOOL DeleteOnClose;

    //
    // Was this file written to ?
    //
    BOOL FileWasModified;

    //
    // On Close, if the file has been modified, we PROPPATCH the time values
    // as well. We take the current time as the value of the "Last Modified Time"
    // (LMT). If the SetFileInformation of the LMT happens after the file has
    // been modifed, then we should use what ever LMT is already in the FCB as
    // the LMT. For example,
    // Create, Write, Close - Use the CurrentTime in close as the LMT.
    // Create, Write, SetFileInfo(LMT), Close - Use the LMT in the FCB.
    //
    BOOL DoNotTakeTheCurrentTimeAsLMT;

    //
    // This resource is used to synchronize the "Read-Modify-Write" routine
    // in the Write path of the DAV Redir. This is because when we get non-cached
    // writes to the MiniRedir which do not extend the VaildDataLength, RDBSS,
    // acquires the FCB resource shared. This means that multiple threads could
    // be writing data to the local file (in the DAV Redir case) in which case
    // they can overwrite each others changes since we do Read-Modify-Write.
    // Hence we need to protect this code using a resource which we acqiure
    // in an exclusive fashion when we do these writes. We allocate memory for 
    // this resource and initialize it the first time we need to acquire the
    // lock. If allocated and initialized, it will be uninitialized and 
    // deallocated when the FCB is being deallocated.
    //
    PERESOURCE DavReadModifyWriteLock;

    //
    // We store the file name information on create. This is used if the delayed
    // write failed to pop up the dialogue box and write an eventlog entry.
    //
    UNICODE_STRING FileNameInfo;
    BOOL FileNameInfoAllocated;
    
    //
    // Changes in directory entry.
    //
    BOOLEAN fCreationTimeChanged;
    
    BOOLEAN fLastAccessTimeChanged;
    
    BOOLEAN fLastModifiedTimeChanged;    
    
    BOOLEAN fFileAttributesChanged;

    //
    // Was this file renamed ?
    //
    BOOL FileWasRenamed;

    BOOL LocalFileIsEncrypted;

    SECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    // If the file gets renamed, the new name is copied into this buffer.
    //
    WCHAR NewFileName[MAX_PATH];

    //
    // Length of the new file name.
    //
    ULONG NewFileNameLength;
    
    LPVOID lpCEI;  // cache entry info
    
    //
    // The file name of the local file that represents the file on the DAV
    // server which has been created.
    //
    WCHAR FileName[MAX_PATH];
    WCHAR Url[MAX_PATH * 2];

} WEBDAV_FCB, *PWEBDAV_FCB;

//
// A pointer to an instance of WEBDAV_FCB is stored in the context field
// of MRX_FCB strucutre.
//
#define MRxDAVGetFcbExtension(pFcb)  \
        (((pFcb) == NULL) ? NULL : (PWEBDAV_FCB)((pFcb)->Context))
        
//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_V_NET_ROOT {

    //
    // The client's security context. This is set during the create call.
    //
    SECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    // Is set to true after the above context is set. This is used to avoid 
    // initialization of the SecurityContext.
    //
    BOOLEAN SCAlreadyInitialized;

    //
    // Has the LogonID of this V_NET_ROOT been set ?
    //
    BOOL LogonIDSet;

    //
    // The LogonID for this session.
    //
    LUID LogonID;

    //
    // Is this an Office Web Server share?
    //
    BOOL isOfficeShare;
    
    //
    // Is this a TAHOE share?
    //
    BOOL isTahoeShare;
    
    //
    // Is PROPATCH method allowed?
    //
    BOOL fAllowsProppatch;

    //
    // Was this VNetRoot "NOT" created successfully in the usermode? We keep this 
    // info because when a finalize VNetRoot request comes, we need to know 
    // whether need to go upto the usermode to finalize the PerUserEntry. If the
    // create failed then this BOOL is set to TRUE. If this is TRUE, then we 
    // don't go to the usermode to finalize the PerUserEntry.
    //
    BOOL createVNetRootUnSuccessful;
    

    // does he report available space?
        
    BOOL fReportsAvailableSpace;

} WEBDAV_V_NET_ROOT, *PWEBDAV_V_NET_ROOT;

//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_NET_ROOT {
    ULONG                    RefCount;
    PMRX_NET_ROOT            pRdbssNetRoot;           // The Rdbss NetRoot it belongs to
    NAME_CACHE_CONTROL       NameCacheCtlGFABasic;    // The basic file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlGFAStandard; // The standard file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlFNF;         // The File not found name cache control.
} WEBDAV_NET_ROOT, *PWEBDAV_NET_ROOT;

//
// A pointer to an instance of WEBDAV_V_NET_ROOT is stored in the context field
// of MRX_V_NET_ROOT strucutre.
//
#define MRxDAVGetVNetRootExtension(pVNetRoot)      \
    (((pVNetRoot) == NULL) ? NULL : (PWEBDAV_V_NET_ROOT)((pVNetRoot)->Context))

//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_SRV_CALL {

    //
    // The Unique ServerID.
    //
    ULONG ServerID;

    //
    // Is set to true after the above context is set. Used to check whether we
    // need to delete the SecurityClientContext when we are completing the
    // request.
    //
    BOOLEAN SCAlreadyInitialized;

} WEBDAV_SRV_CALL, *PWEBDAV_SRV_CALL;

//
// A pointer to an instance of WEBDAV_SRV_CALL is stored in the context field
// of MRX_SRV_CALL strucutre.
//
#define MRxDAVGetSrvCallExtension(pSrvCall)      \
    (((pSrvCall) == NULL) ? NULL : (PWEBDAV_SRV_CALL)((pSrvCall)->Context))

//
// Get the Security client context associated with this request.
//
#define MRxDAVGetSecurityClientContext() {                                     \
    if (RxContext != NULL && RxContext->pRelevantSrvOpen != NULL) {            \
        if (RxContext->pRelevantSrvOpen->pVNetRoot != NULL) {                  \
            if (RxContext->pRelevantSrvOpen->pVNetRoot->Context != NULL) {     \
                DavVNetRoot = (PWEBDAV_V_NET_ROOT)                             \
                              RxContext->pRelevantSrvOpen->pVNetRoot->Context; \
                SecurityClientContext = &(DavVNetRoot->SecurityClientContext); \
            }                                                                  \
        }                                                                      \
    }                                                                          \
}

//
// We turn away async operations that are not wait by posting. If we can wait
// then we turn off the sync flag so that things will just act synchronous.
//
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION)) {       \
        if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) {              \
            ClearFlag(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION)   \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return STATUS_PENDING;                                         \
        }                                                                  \
    }                                                                      \
}

//
// Global locking variables and macros.
//
extern RX_SPIN_LOCK   MRxDAVGlobalSpinLock;
extern KIRQL          MRxDAVGlobalSpinLockSavedIrql;
extern BOOLEAN        MRxDAVGlobalSpinLockAcquired;

#define MRxDAVAcquireGlobalSpinLock() \
        KeAcquireSpinLock(&MRxDAVGlobalSpinLock,&MRxDAVGlobalSpinLockSavedIrql); \
        MRxDAVGlobalSpinLockAcquired = TRUE

#define MRxDAVReleaseGlobalSpinLock()   \
        MRxDAVGlobalSpinLockAcquired = FALSE;  \
        KeReleaseSpinLock(&MRxDAVGlobalSpinLock,MRxDAVGlobalSpinLockSavedIrql)

#define MRxDAVGlobalSpinLockAcquired()   \
        (MRxDAVGlobalSpinLockAcquired == TRUE)

//
// The IrpCompletionContext structure that is used in the read/write operations.
// All we need is an event on which we will wait till the underlying file system
// completes the request. This event gets signalled in the Completion routine
// that we specify.
//
typedef struct _WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT {

    //
    // The event which is signalled in the Completion routine that is passed
    // to IoCallDriver in the read and write requests.
    //
    KEVENT DavReadWriteEvent;

} WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT, *PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT;


//
// The prototypes of functions defined for various I/O requests by the DAV
// miniredir are mentioned below.
//

//
// Create/Open/Cleanup/Close Request function prototypes.
//
NTSTATUS
MRxDAVCreate(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN PVOID pMRxContext,
    OUT ULONG *pNewBufferingState
    );

NTSTATUS
MRxDAVForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

NTSTATUS
MRxDAVShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxDAVSetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    );

NTSTATUS
MRxDAVFlush (
    IN OUT PRX_CONTEXT RxContext
    );

//
// Read prototypes.
//
NTSTATUS
MRxDAVRead (
    IN OUT PRX_CONTEXT RxContext
    );

//
// Write prototypes.
//
NTSTATUS
MRxDAVWrite(
    IN PRX_CONTEXT RxContext
    );

ULONG
MRxDAVExtendForCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    );

ULONG
MRxDAVExtendForNonCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    );


//
// SrvCall function prototypes.
//
NTSTATUS
MRxDAVCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext
    );

NTSTATUS
MRxDAVFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force
    );

NTSTATUS
MRxDAVSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext
    );

//
// NetRoot/VNetRoot function prototypes.
//
NTSTATUS
MRxDAVUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot
    );

NTSTATUS
MRxDAVCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
MRxDAVFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect
    );

NTSTATUS
MRxDAVFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect
    );

VOID
MRxDAVExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

//
// Query Directory prototypes.
//
NTSTATUS
MRxDAVQueryDirectory(
    IN PRX_CONTEXT RxContext
    );

//
// Query volume.
//
NTSTATUS
MRxDAVQueryVolumeInformation(
    IN PRX_CONTEXT RxContext
    );

//
// File Information.
//
NTSTATUS
MRxDAVQueryFileInformation(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVSetFileInformation(
    IN PRX_CONTEXT RxContext
    );

//
// DevFcb prototypes.
//
NTSTATUS
MRxDAVDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxDAVStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

BOOLEAN
MRxDAVFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
MRxDAVFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
MRxDAVFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Other Misc prototypes.
//
NTSTATUS
MRxDAVSyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG_PTR ReturnedLength OPTIONAL
    );

NTSTATUS
MRxDAVDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxDAVDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxDAVBuildAsynchronousRequest(
    IN PRX_CONTEXT RxContext,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    );

//
// The prototype of the routine that formats the DAV specific portion of the 
// context.
//
NTSTATUS
MRxDAVFormatTheDAVContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT EntryPoint
    );

NTSTATUS
DavXxxInformation(
    IN const int xMajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    );

ULONG
DavReadWriteFileEx(
    IN USHORT Operation,
    IN BOOL NonPagedBuffer,
    IN BOOL UseOriginalIrpsMDL,
    IN PMDL OriginalIrpsMdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONGLONG FileOffset,
    IN OUT PVOID DataBuffer,
    IN ULONG SizeInBytes,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
DavReadWriteIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

NTSTATUS
MRxDAVProbeForReadWrite(
    IN PBYTE BufferToBeValidated,
    IN DWORD BufferSize,
    IN BOOL doProbeForRead,
    IN BOOL doProbeForWrite
    );

NTSTATUS
MRxDAVFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVIsValidDirectory(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    );

NTSTATUS
MRxDAVCancelRoutine(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVTimeOutTheContexts(
    BOOL WindDownAllContexts
    );

VOID
MRxDAVContextTimerThread(
    PVOID DummyContext
    );

NTSTATUS
MRxDAVQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );
    
NTSTATUS
MRxDAVSetEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );
    
NTSTATUS
MRxDAVGetFullParentDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING ParentDirName
    );

NTSTATUS
MRxDAVGetFullDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING FileName,
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVCreateEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVRemoveEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVQueryEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

#endif //_WEBDAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\write.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to
    "write" of file system objects.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [RohanK]  02-Nov-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVWriteContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

VOID
MRxDAVCloseTheFileHandle(
    PRX_CONTEXT RxContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVWrite)
#pragma alloc_text(PAGE, MRxDAVWriteContinuation)
#pragma alloc_text(PAGE, MRxDAVExtendForCache)
#pragma alloc_text(PAGE, MRxDAVExtendForNonCache)
#pragma alloc_text(PAGE, MRxDAVFastIoWrite)
#pragma alloc_text(PAGE, MRxDAVCloseTheFileHandle)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVWrite(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network write requests.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVWrite!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVWrite: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_WRITE,
                                        MRxDAVWriteContinuation,
                                        "MRxDAVWrite");

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVWrite with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVWriteContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine the for write operation. It uses unbuffered
    write doing prereads as necessary. We cannot use buffered write because such
    a write could be arbitrarily deferred (in CcCanIWrite) so that we deadlock.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    RxContext - The RDBSS context.
    
Notes.

    The routine does this in (potentially) 3 phases.

    1) If the starting offset is not aligned on a page boundary then,
       - Read from the earlier page boundary to the next page boundary of the 
         starting offset.
       - Merge the passed in buffer.
       - Write the whole page.

    2) 0 or more page size writes.

    3) Residual write of less than page size, similar to what is explained in 
       1) above.
       
    Non-Cached writes that do not extend the file have the FCB acquired shared.
    We have an additional resource in the WEBDAV_FCB structure to synchronize
    the "read-modify-write" routine we have here. This is because multiple threads
    can (in the non-cached non extending scenario) overwrite each others data.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    LARGE_INTEGER ByteOffset = {0,0}, AlignedOffset = {0,0}, EndBytePlusOne = {0,0};
    ULONG ByteCount = 0, TotalLengthActuallyWritten = 0;
    ULONG LengthRead = 0, BytesToCopy = 0, BytesToWrite = 0, LengthWritten = 0;
    ULONG ByteOffsetMisAlignment = 0, InMemoryMisAlignment = 0;
    BOOLEAN  SynchronousIo = TRUE, PagingIo = TRUE, DavFcbResourceAcquired = FALSE;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE AllocatedSideBuffer = NULL, UserBuffer = NULL;
    HANDLE LocalFileHandle = INVALID_HANDLE_VALUE;
    ULONG SizeInBytes = 0;
    PWCHAR NtFileName = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeFileName;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    PDAV_GLOBAL_FILE_TABLE_ENTRY FileTableEntry = NULL;
    BOOL Exists = FALSE;
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH


    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVWriteContinuation.\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    //
    // We want to keep the AsyncEngineContext alive while we are doing this write
    // operation. The reference is taken away when we leave this function. 
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );
    
    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    
    LowIoContext = &(RxContext->LowIoContext);
    ASSERT(LowIoContext != NULL);
    
    ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    
    ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    
    EndBytePlusOne.QuadPart = (ByteOffset.QuadPart + ByteCount);
    
    UserBuffer = RxLowIoGetBufferAddress(RxContext);

    PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO);
    
    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);
    
    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    ASSERT(davSrvOpen->UnderlyingHandle != NULL);
    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    if ( davSrvOpen->UnderlyingHandle == NULL      ||
         davSrvOpen->UnderlyingFileObject == NULL  ||
         davSrvOpen->UnderlyingDeviceObject == NULL ) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation. Invalid davSrvOpen\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
    ASSERT(DavFcb != NULL);
    
    //
    // Create an NT path name for the cached file. This is used in the 
    // ZwCreateFile call below. If c:\foo\bar is the DOA path name,
    // the NT path name is \??\c:\foo\bar. We do the Create to query the 
    // filesize of the underlying file.
    //

    SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
    NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
    if (NtFileName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/RxAllocatePoolWithTag: Error Val"
                     " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(NtFileName, SizeInBytes);

    wcscpy( NtFileName, L"\\??\\" );
    wcscpy( &(NtFileName[4]), DavFcb->FileName );

    RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeFileName,
                               (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                               0,
                               NULL);
    
    NtStatus = ZwCreateFile(&(LocalFileHandle),
                            FILE_READ_ATTRIBUTES,
                            &(ObjectAttributes),
                            &(IoStatusBlock),
                            NULL,
                            0,
                            FILE_SHARE_VALID_FLAGS,
                            FILE_OPEN,
                            0,
                            NULL,
                            0);
    if (NtStatus != STATUS_SUCCESS) {
        LocalFileHandle = INVALID_HANDLE_VALUE;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVWriteContinuation/ZwCreateFile: "
                     "Error Val = %08lx\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation: FileHandle = %08lx\n",
                 PsGetCurrentThreadId(), LocalFileHandle));
    
    //
    // See what the current FileStandardInformation is. We don't use the file 
    // handle stored in the davSrvOpen structure, because this could have been
    // created in the svchost process and hence will not be valid in this 
    // process.
    //
    NtStatus = ZwQueryInformationFile(LocalFileHandle,
                                      &(IoStatusBlock),
                                      &(FileStandardInfo),
                                      sizeof(FILE_STANDARD_INFORMATION),
                                      FileStandardInformation);
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/ZwQueryInformationFile. "
                     "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. FileName = %wZ, PagingIo = %d, SynchronousIo = %d"
                 ", ByteOffset.HighPart = %d, ByteOffset.LowPart = %d, ByteCount = %d, EndOfFile.HighPart = %d, "
                 "EndOfFile.LowPart = %d\n",
                 PsGetCurrentThreadId(), RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                 PagingIo, SynchronousIo, ByteOffset.HighPart, ByteOffset.LowPart,
                 ByteCount, FileStandardInfo.EndOfFile.HighPart, FileStandardInfo.EndOfFile.LowPart));

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    Exists = DavDoesTheFileEntryExist(RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                                      &(FileTableEntry));
    if (!Exists) {
        DbgBreakPoint();
    }
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    //
    // Since we are going to do the write we mark this file as being modified.
    // When the Close happens, we check whether the file has been modified and
    // PUT the file on the server.
    //
    DavFcb->FileWasModified = TRUE;
    DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;

    if (PagingIo) {

        ASSERT(RxContext->CurrentIrp->MdlAddress != NULL);
        if (RxContext->CurrentIrp->MdlAddress == NULL) {
            DbgPrint("%ld: MRxDAVWriteContinuation: MdlAddress == NULL\n", PsGetCurrentThreadId());
            DbgBreakPoint();
        }

        BytesToWrite = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation(0). ByteCount = %d, BytesToWrite = %d\n",
                     PsGetCurrentThreadId(), ByteCount, BytesToWrite));

        if (BytesToWrite > 0) {
        
            LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                               FALSE,
                                               TRUE,
                                               RxContext->CurrentIrp->MdlAddress,
                                               davSrvOpen->UnderlyingDeviceObject,
                                               davSrvOpen->UnderlyingFileObject,
                                               ByteOffset.QuadPart,
                                               MmGetMdlBaseVa(RxContext->CurrentIrp->MdlAddress),
                                               BytesToWrite,
                                               &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(0). "
                             "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            if (LengthWritten != BytesToWrite) {
                DbgPrint("MRxDAVWriteContinuation(1): LengthWritten(%x) != BytesToWrite(%x)\n",
                         LengthWritten, BytesToWrite);
            }

            ASSERT(LengthWritten == BytesToWrite);

            TotalLengthActuallyWritten += BytesToWrite;

        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToWrite == ByteCount), then we are done and can exit now.
        //
        if (BytesToWrite == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(0)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToWrite;
        ASSERT(ByteCount < PAGE_SIZE);

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
        // the ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToWrite;

        //
        // Increment the UserBuffer pointer which currently points to the beginning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToWrite;

        //
        // We have written all the bytes that are multiple of pages. We now 
        // need to write out the remaining bytes from the last page. From here,
        // we go to Case 3 below.
        //

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Remaining ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));

    }

    //
    // We allocate a page size buffer to be used for helping read the data 
    // which is not aligned at page boundaries.
    //
    AllocatedSideBuffer = RxAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, DAV_READWRITE_POOLTAG);
    if (AllocatedSideBuffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/RxAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // When we issue a write down to the underlying file system, we need to make 
    // sure that the offset is page aligned and the bytecount is a multiple of 
    // PAGE_SIZE. This is because we created the local handle with the
    // NO_INTERMEDIATE_BUFFERING option. Since there is no cache map for this 
    // handle, all the data is read from the disk and hence the alignment issue.
    //

    //
    // Case 1: ByteOffset is not page aligned. In this case we read the page
    // which contains the ByteOffset and copy the data from the ByteOffset to
    // the end of the page into the PAGE_SIZE buffer (which we allocated above)
    // and write the buffer back to the file.
    //
    
    //
    // The "and" operation below does the following. If the ByteOffset is 6377
    // and the PAGE_SIZE is 4096, then the MisAlignment is 2281.
    //
    ByteOffsetMisAlignment = ( ByteOffset.LowPart & (PAGE_SIZE - 1) );

    if (ByteOffsetMisAlignment != 0) {
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1. ByteOffsetMisAlignment = %d\n",
                     PsGetCurrentThreadId(), ByteOffsetMisAlignment));

        //
        // Acquire the DavFcb resource exclusively before proceeding further with
        // the "read-modify-write" routing.
        //
        ExAcquireResourceExclusiveLite(DavFcb->DavReadModifyWriteLock, TRUE);
        DavFcbResourceAcquired = TRUE;

        AlignedOffset = ByteOffset;

        //
        // The byte offset is not aligned. We need to read the page containing
        // the offset now.
        //
    
        //
        // If the PAGE_SIZE is 4096 (0x1000) then (PAGE_SIZE - 1) is 0xFFF.
        // ~(PAGE_SIZE - 1) is 0x000. The bit operation below masks the lower 3
        // bytes of the aligned offset to make it page aligned.
        //
        AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);
    
        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);

        //
        // If the AliignedOffset is within the file then we read the whole page
        // containing the offset first before writing it out.
        //
        if ( (FileStandardInfo.EndOfFile.QuadPart != 0) &&
              (AlignedOffset.QuadPart < FileStandardInfo.EndOfFile.QuadPart) ) {
    
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case 1. AlignedOffset.QuadPart"
                         " < FileStandardInfo.EndOfFile.QuadPart\n",
                         PsGetCurrentThreadId()));

            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            TRUE,
                                            FALSE,
                                            NULL,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            AlignedOffset.QuadPart,
                                            AllocatedSideBuffer,
                                            PAGE_SIZE,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;
    
            if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_END_OF_FILE) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(1). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        } else {

            LengthRead = 0;

        }

        //
        // Copy the right number of bytes into the buffer.
        //
        BytesToCopy = min( ByteCount, (PAGE_SIZE - ByteOffsetMisAlignment) );

        //
        // Copy the bytes to be written back from the UserBuffer into the
        // AllocatedSideBuffer.
        //
        RtlCopyMemory((AllocatedSideBuffer + ByteOffsetMisAlignment),
                      UserBuffer,
                      BytesToCopy);

        BytesToWrite = (ByteOffsetMisAlignment + BytesToCopy);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1: LengthRead = %d, BytesToCopy = %d"
                     " BytesToWrite = %d\n", PsGetCurrentThreadId(), LengthRead,
                     BytesToCopy, BytesToWrite));

        //
        // If the BytesToWrite is less that LengthRead (which is one page in this
        // case) then we make BytesToWrite to be the LengthRead. This is possible
        // if the bytes to be written are contained in a Page starting at a
        // mis-aligned offset.
        //
        if (BytesToWrite < LengthRead) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case 1: BytesToWrite < LengthRead\n",
                         PsGetCurrentThreadId()));
            BytesToWrite = LengthRead;
        }
    
        //
        // Now we write out the entire page to the disk.
        //
        LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                           TRUE,
                                           FALSE,
                                           NULL,
                                           davSrvOpen->UnderlyingDeviceObject,
                                           davSrvOpen->UnderlyingFileObject,
                                           AlignedOffset.QuadPart,
                                           AllocatedSideBuffer,
                                           BytesToWrite,
                                           &(IoStatusBlock));
        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(2). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));

            goto EXIT_THE_FUNCTION;

        } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

            PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

            DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
            if (DavPagingWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

            DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();
    
            DavPagingWriteEntry->LocByteOffset.QuadPart = AlignedOffset.QuadPart;

            DavPagingWriteEntry->LocByteCount = BytesToWrite;

            DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

            RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWrite);

            wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

            InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

        }

        if (LengthWritten != BytesToWrite) {
            DbgPrint("MRxDAVWriteContinuation(2): LengthWritten(%x) != BytesToWrite(%x)\n",
                     LengthWritten, BytesToWrite);
        }

        //  
        // If we were successful, then we should have ready PAGE_SIZE bytes.
        //
        ASSERT(LengthWritten == BytesToWrite);

        TotalLengthActuallyWritten += BytesToCopy;

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;

        //
        // Increment the ByteOffset with the number of bytes that have been 
        // copied. The ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the beginning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

        //
        // If we acquired the DavFcb resource, then we need to release it since
        // we are done with this "read-modify-write" sequence.
        //
        if (DavFcbResourceAcquired) {
            ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
            DavFcbResourceAcquired = FALSE;
        }
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1: ByteCount = %d"
                     " ByteOffSet.HighPart = %d, ByteOffSet.LowPart = %d\n",
                     PsGetCurrentThreadId(), ByteOffset.HighPart, ByteOffset.LowPart));

    }

    //
    // Case 2: At this stage we have copied the bytes from the unaligned offset 
    // (if it the ByteOffset was unaligned) to the next page bouandary. Now we 
    // write as many pages as we can without copying. If the end pointer is
    // aligned OR we cover the end of file, then we write out everything. If not,
    // we write out as many pages as we can.
    //
    
    //
    // We also have to be back to just writing full pages, if including the
    // "trailing bytes" would take us onto a new physical page of memory because 
    // we are doing this write under the original Mdl lock?? What does this
    // mean?? Copied this comment from Joe Linn's code in csc.nt5\readrite.c.
    //
    
    //
    // If 4200 bytes are remaining, the operation below sets BytesToWrite to
    // 4096.
    //
    BytesToWrite = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

    //
    // Get the ByteOffsetMisAlignment of the EndBytePlusOne position.
    //
    ByteOffsetMisAlignment = (EndBytePlusOne.LowPart & (PAGE_SIZE - 1));

    InMemoryMisAlignment = (ULONG)( ((ULONG_PTR)UserBuffer) & (PAGE_SIZE - 1) );
    
    if ( ( InMemoryMisAlignment == 0 ) &&
         ( (EndBytePlusOne.QuadPart) >= (FileStandardInfo.EndOfFile.QuadPart) ) ) {
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 2: UserBuff Page Aligned\n",
                     PsGetCurrentThreadId()));
        
        BytesToWrite = ByteCount;
    
    }

    if ( (BytesToWrite != 0) && (BytesToWrite >= PAGE_SIZE) ) {
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Entered Case 2\n",
                     PsGetCurrentThreadId()));
        
        if ( ( (ULONG_PTR)UserBuffer & 0x3 ) == 0 ) {
        
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. UserBuffer DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                               FALSE,
                                               FALSE,
                                               NULL,
                                               davSrvOpen->UnderlyingDeviceObject,
                                               davSrvOpen->UnderlyingFileObject,
                                               ByteOffset.QuadPart,
                                               UserBuffer,
                                               BytesToWrite,
                                               &(IoStatusBlock));
            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(3). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                
                goto EXIT_THE_FUNCTION;
            
            } else {
            
#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
                
                PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

                DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
                if (DavPagingWriteEntry == NULL) {
                    DbgBreakPoint();
                }

                RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

                DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

                DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

                DavPagingWriteEntry->LocByteCount = BytesToWrite;

                DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

                RtlCopyMemory(DavPagingWriteEntry->DataBuffer, UserBuffer, BytesToWrite);

                wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

                InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
            
            }
        
            if (LengthWritten != BytesToWrite) {
                DbgPrint("MRxDAVWriteContinuation(3): LengthWritten(%x) != BytesToWrite(%x)\n",
                         LengthWritten, BytesToWrite);
            }

            //  
            // If we were successful, then we should have ready PAGE_SIZE bytes.
            //
            ASSERT(LengthWritten == BytesToWrite);

            TotalLengthActuallyWritten += BytesToWrite;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. BytesToWrite = %d, "
                         " LengthWritten = %d\n", PsGetCurrentThreadId(),
                         BytesToWrite, LengthWritten));

            //
            // If we have already written out the required number of bytes (which
            // means BytesToWrite == ByteCount), then we are done and can exit now.
            //
            if (BytesToWrite == ByteCount) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Decrement the ByteCount by the number of bytes that have been copied.
            //
            ByteCount -= BytesToWrite;

            //
            // Increment the ByteOffset with the number of bytes that have been copied.
            // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
            // the ByteOffset is now page aligned.
            //
            ByteOffset.QuadPart += BytesToWrite;

            //
            // Increment the UserBuffer pointer which currently points to the beginning
            // of the buffer which the user supplied by the number of bytes which have
            // been copied.
            //
            UserBuffer += BytesToWrite;

        } else {

            ULONG BytesToWriteThisIteration = 0;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. UserBuffer NOT DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // This is the case when the offsets are aligned but the user 
            // supplied buffer is not aligned. In such cases we have to resort 
            // to copying the user supplied buffer onto the local buffer 
            // allocated and then spin out the writes.
            //
            while (BytesToWrite > 0) {
            
                //
                // If the BytesToWrite is less than the PAGE_SIZE then we copy
                // the bytes left. If not, we write a PAGE.
                //
                BytesToWriteThisIteration = ( (BytesToWrite < PAGE_SIZE) ? BytesToWrite : PAGE_SIZE );

                //
                // Copy the memory from the UserBuffer to the AllocatedSideBuffer.
                //
                RtlCopyMemory(AllocatedSideBuffer, UserBuffer, BytesToWriteThisIteration);

                LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                                   TRUE,
                                                   FALSE,
                                                   NULL,
                                                   davSrvOpen->UnderlyingDeviceObject,
                                                   davSrvOpen->UnderlyingFileObject,
                                                   ByteOffset.QuadPart,
                                                   AllocatedSideBuffer,
                                                   BytesToWriteThisIteration,
                                                   &(IoStatusBlock));
                NtStatus = IoStatusBlock.Status;

                if (NtStatus != STATUS_SUCCESS) {
                    
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(4). "
                                 "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                    
                    goto EXIT_THE_FUNCTION;
                
                } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

                    PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

                    DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
                    if (DavPagingWriteEntry == NULL) {
                        DbgBreakPoint();
                    }

                    RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

                    DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

                    DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

                    DavPagingWriteEntry->LocByteCount = BytesToWriteThisIteration;

                    DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWriteThisIteration);

                    RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWriteThisIteration);

                    wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

                    InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
                
                }

                if (LengthWritten != BytesToWriteThisIteration) {
                    DbgPrint("MRxDAVWriteContinuation(4): LengthWritten(%x) != BytesToWriteThisIteration(%x)\n",
                             LengthWritten, BytesToWriteThisIteration);
                }

                //  
                // If we were successful, then we should have ready PAGE_SIZE bytes.
                //
                ASSERT(LengthWritten == BytesToWriteThisIteration);

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVWriteContinuation. Case2. BytesToWriteThisIteration = %d, "
                             " LengthWritten = %d\n", PsGetCurrentThreadId(),
                             BytesToWriteThisIteration, LengthWritten));

                //
                // Decrement the ByteCount by the number of bytes that have been copied.
                //
                ByteCount -= LengthWritten;

                //
                // Increment the ByteOffset with the number of bytes that have been copied.
                // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
                // the ByteOffset is now page aligned.
                //
                ByteOffset.QuadPart += LengthWritten;

                //
                // Increment the UserBuffer pointer which currently points to the beginning
                // of the buffer which the user supplied by the number of bytes which have
                // been copied.
                //
                UserBuffer += LengthWritten;

                TotalLengthActuallyWritten += LengthWritten;

                //
                // Subtract the LengthWritten from the number of bytes to write.
                //
                BytesToWrite -= LengthWritten;
            
            }

            //
            // IMPORTANT!!! Need to find out why if TotalLengthActuallyWritten == ByteCount
            // is TRUE we are done. This was as Joe Linn did for CSC. Ofcourse
            // if ByteCount is 0, it means we are done.
            //
            if ( (TotalLengthActuallyWritten == ByteCount) || (ByteCount == 0) ) {
                if ((TotalLengthActuallyWritten == ByteCount)) {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVWriteContinuation. Case2. TotalLengthActuallyWritten == ByteCount\n",
                                 PsGetCurrentThreadId()));
                } else {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVWriteContinuation. Case2. Leaving!!! ByteCount = 0\n",
                                 PsGetCurrentThreadId()));
                }
                goto EXIT_THE_FUNCTION;
            }
        
        }
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 2: ByteCount = %d"
                     " ByteOffSet.HighPart = %d, ByteOffSet.LowPart = %d\n",
                     PsGetCurrentThreadId(), ByteOffset.HighPart, ByteOffset.LowPart));

    }
    
    //
    // CASE 3: We don't have the whole buffer, ByteCount is non zero and is less 
    // than PAGE_SIZE.
    //

    ASSERT(ByteCount != 0);
    ASSERT(ByteCount < PAGE_SIZE);
    
    //
    // Acquire the DavFcb resource exclusively before proceeding further with
    // the "read-modify-write" routing.
    //
    ExAcquireResourceExclusiveLite(DavFcb->DavReadModifyWriteLock, TRUE);
    DavFcbResourceAcquired = TRUE;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. Entered Case 3\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. Case3. ByteCount = %d\n",
                 PsGetCurrentThreadId(), ByteCount));

    RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
    LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                    TRUE,
                                    FALSE,
                                    NULL,
                                    davSrvOpen->UnderlyingDeviceObject,
                                    davSrvOpen->UnderlyingFileObject,
                                    ByteOffset.QuadPart,
                                    AllocatedSideBuffer,
                                    PAGE_SIZE,
                                    &(IoStatusBlock));

    NtStatus = IoStatusBlock.Status;

    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_END_OF_FILE) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(5). "
                     "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyMemory(AllocatedSideBuffer, UserBuffer, ByteCount);
    
    BytesToWrite = ByteCount;

    //
    // Here, if the ByetsToWrite is not page/sector aligned, it gets so because 
    // LengthRead must be page/sector aligned.
    //
    if (BytesToWrite < LengthRead) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case3. BytesToWrite < LengthRead\n",
                     PsGetCurrentThreadId()));
        BytesToWrite = LengthRead;
    }

    if (BytesToWrite) {
        
        LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                           TRUE,
                                           FALSE,
                                           NULL,
                                           davSrvOpen->UnderlyingDeviceObject,
                                           davSrvOpen->UnderlyingFileObject,
                                           ByteOffset.QuadPart,
                                           AllocatedSideBuffer,
                                           BytesToWrite,
                                           &(IoStatusBlock));
        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(6). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            
            goto EXIT_THE_FUNCTION;
        
        } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

            PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

            DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
            if (DavPagingWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

            DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();
    
            DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

            DavPagingWriteEntry->LocByteCount = BytesToWrite;

            DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

            RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWrite);

            wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

            InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
        
        }

        if (LengthWritten != BytesToWrite) {
            DbgPrint("MRxDAVWriteContinuation(5): LengthWritten(%x) != BytesToWrite(%x)\n",
                     LengthWritten, BytesToWrite);
        }

        //  
        // If we were successful, then we should have ready PAGE_SIZE bytes.
        //
        ASSERT(LengthWritten == BytesToWrite);

        //
        // Even though we might have written more than ByteCount, the actual 
        // amount of User data written is ByteCount bytes.
        //
        TotalLengthActuallyWritten += ByteCount;
    
    }

    //
    // If we acquired the DavFcb resource, then we need to release it since
    // we are done with this "read-modify-write" sequence.
    //
    if (DavFcbResourceAcquired) {
        ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
        DavFcbResourceAcquired = FALSE;
    }

EXIT_THE_FUNCTION:

    //
    // We allocate a page size buffer for the read and the write operations. We
    // need to free it now.
    //
    if (AllocatedSideBuffer) {
        RxFreePool(AllocatedSideBuffer);
    }

    //
    // If we succeeded, we update the filesize in the namecache just in case we
    // extended the file or reduced the filesize. In case when the filesize
    // does not change, this is a no-op.
    //
    if (NtStatus == STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. NewFileSize.HighPart = %x, NewFileSize.LowPart = %x\n",
                     PsGetCurrentThreadId(),
                     RxContext->pFcb->Header.FileSize.HighPart,
                     RxContext->pFcb->Header.FileSize.LowPart));
        MRxDAVUpdateFileInfoCacheFileSize(RxContext, &(RxContext->pFcb->Header.FileSize));
    }

    //
    // If we allocated an NtFileName to do the create, we need to free it now.
    //
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

    //
    // If we acquired the DavFcb resource and came down through some error path,
    // and have not released the resource then we need to release it now.
    //
    if (DavFcbResourceAcquired) {
        ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
        DavFcbResourceAcquired = FALSE;
    }

    //
    // If we created a LocalFileHandle, we need to close it by posting it to
    // a system worker thread. This is because we cannot be calling ZwClose
    // in the write path of a MappedPageWriter thread. Moreover this handle
    // was created in the kernel handle table and hence can be closed in any
    // system thread. Store the LocalFileHandle in the MRxContext[1] pointer
    // of the RxContext. The AsyncEngineContext of this operation is stored
    // in the MRxContext[0] pointer. We need to keep the RxContext alive till
    // the worker thread that picks up this request completes it. Hence we
    // remove the reference we took (on the RxContext) at the beginning of this
    // routine in the MRxDAVCloseTheFileHandle routine. If the handle did not
    // get created (which means the request failed), we remove the reference
    // right here by calling UMRxResumeAsyncEngineContext.
    //
    if (LocalFileHandle != INVALID_HANDLE_VALUE) {
        RxContext->MRxContext[1] = LocalFileHandle;
        RxPostToWorkerThread(RxContext->RxDeviceObject,
                             CriticalWorkQueue,
                             &(AsyncEngineContext->WorkQueueItem),
                             MRxDAVCloseTheFileHandle,
                             RxContext);
    } else {
        //
        // We need to remove the reference we took at the beginning of this
        // routine.
        //
        UMRxResumeAsyncEngineContext(RxContext);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVWriteContinuation. NtStatus = %08lx, "
                 "TotalLengthActuallyWritten = %d\n", 
                 PsGetCurrentThreadId(), NtStatus, TotalLengthActuallyWritten));
    
    AsyncEngineContext->Status = NtStatus;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
   
    if (NtStatus == STATUS_SUCCESS) {
        
        PDAV_MR_WRITE_ENTRY DavMRWriteEntry = NULL;
        PBYTE ThisBuffer = NULL;
        
        if ( RxContext->pRelevantSrvOpen->pAlreadyPrefixedName != NULL &&
             RxContext->pRelevantSrvOpen->pAlreadyPrefixedName->Length > 0 ) {
            

            DavMRWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_WRITE_ENTRY));
            if (DavMRWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavMRWriteEntry, sizeof(DAV_RDBSS_WRITE_ENTRY));

            DavMRWriteEntry->DataBuffer = RxAllocatePool(PagedPool, LowIoContext->ParamsFor.ReadWrite.ByteCount);
            if (DavMRWriteEntry->DataBuffer == NULL) {
                DbgBreakPoint();
            }

            ThisBuffer = RxLowIoGetBufferAddress(RxContext);

            RtlCopyMemory((PBYTE)DavMRWriteEntry->DataBuffer,
                          ThisBuffer,
                          LowIoContext->ParamsFor.ReadWrite.ByteCount);

            wcscpy(DavMRWriteEntry->FileName, DavFcb->FileName);

            DavMRWriteEntry->ThisThreadId = PsGetCurrentThreadId();

            DavMRWriteEntry->LocByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

            DavMRWriteEntry->LocByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

            InsertHeadList( &(FileTableEntry->DavMREntry), &(DavMRWriteEntry->thisMWriteEntry) );

        }
    
    }

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    //
    // We need to set these values in the RxContext. There is code in RDBSS
    // which takes care of putting these values in the IRP.
    //
    RxContext->StoredStatus = NtStatus;
    RxContext->InformationToReturn = TotalLengthActuallyWritten;

    return NtStatus;
}


ULONG
MRxDAVExtendForCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    )
/*++

Routine Description:

    This routines reserves the necessary space for a file which is being 
    extended. This reservation occurs before the actual write takes place. This
    routine handles the case for a cached file.

Arguments:

    RxContext - The RDBSS context.
    
    NewFileSize - The new file size after the write.
    
    NewAllocationSize - The allocation size reserved.
    
Return Value:

    The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NewAllocationSize->QuadPart = NewFileSize->QuadPart;
    MRxDAVUpdateFileInfoCacheFileSize(RxContext, NewFileSize);

    return NtStatus;
}


ULONG
MRxDAVExtendForNonCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    )
/*++

Routine Description:

    This routines reserves the necessary space for a file which is being 
    extended. This reservation occurs before the actual write takes place. This
    routine handles the case for a non-cached file.

Arguments:

    RxContext - The RDBSS context.
    
    NewFileSize - The new file size after the write.
    
    NewAllocationSize - The allocation size reserved.
    
Return Value:

    The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NewAllocationSize->QuadPart = NewFileSize->QuadPart;
    MRxDAVUpdateFileInfoCacheFileSize(RxContext, NewFileSize);

    return NtStatus;
}


BOOLEAN
MRxDAVFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is the routine that handles fast I/O for write operation.

Arguments:

Return Value:

    TRUE (succeeded) or FALSE.

--*/
{
    BOOLEAN ReturnVal = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entered MRxDAVFastIoWrite.\n", PsGetCurrentThreadId()));
    
    IoStatus->Status = STATUS_NOT_IMPLEMENTED;
    IoStatus->Information = 0;

    return (ReturnVal);
}


VOID
MRxDAVCloseTheFileHandle(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the routine that is called in the context of a worker thread to
    close the handle created in the MRxDAVWriteContinuation routine.

Arguments:

    RxContext - The RxContext of this write operation.

Return Value:

    None.

--*/
{
    HANDLE LocalFileHandle = INVALID_HANDLE_VALUE;

    PAGED_CODE();

    LocalFileHandle = RxContext->MRxContext[1];

    ZwClose(LocalFileHandle);

    RxContext->MRxContext[1] = NULL;

    //
    // We need to remove the reference we took at the beginning of the
    // routine MRxDAVWriteContinuation.
    //
    UMRxResumeAsyncEngineContext(RxContext);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\read.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to 
    "read" of file system objects.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [RohanK]     04-April-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVReadContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVRead)
#pragma alloc_text(PAGE, MRxDAVReadContinuation)
#pragma alloc_text(PAGE, MRxDAVFastIoRead)
#pragma alloc_text(PAGE, DavReadWriteFileEx)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVRead!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVRead: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_READ,
                                        MRxDAVReadContinuation,
                                        "MRxDAVRead");

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVRead with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVReadContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for read operation.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    LARGE_INTEGER ByteOffset = {0,0}, AlignedOffset = {0,0};
    ULONG ByteCount = 0, ByteOffsetMisAlignment = 0, LengthRead = 0;
    ULONG TotalLengthActuallyRead = 0, BytesToCopy = 0;
    PIRP TopIrp = NULL;
    BOOLEAN  SynchronousIo = FALSE, PagingIo = FALSE, readLessThanAsked = FALSE;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE AllocatedSideBuffer = NULL, UserBuffer = NULL;
    
    PAGED_CODE();    
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVReadContinuation.\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    //
    // We want to keep the AsyncEngineContext alive while we are doing this read 
    // operation. The reference is taken away when we leave this function. 
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    LowIoContext = &(RxContext->LowIoContext);
    ASSERT(LowIoContext != NULL);

    ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

    //
    // If the bytecount is zero then we can return right away. We don't need to
    // do any further processing.
    //
    ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    
    UserBuffer = RxLowIoGetBufferAddress(RxContext);

    PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO);
    
    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);

    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    ASSERT(davSrvOpen->UnderlyingHandle != NULL);
    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    if ( davSrvOpen->UnderlyingHandle == NULL      ||
         davSrvOpen->UnderlyingFileObject == NULL  ||
         davSrvOpen->UnderlyingDeviceObject == NULL ) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVReadContinuation. Invalid davSrvOpen\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVReadContinuation. FileName = %wZ, PagingIo = %d, SynchronousIo = %d"
                 ", ByteOffset.HighPart = %d, ByteOffset.LowPart = %d, ByteCount = %d\n",
                 PsGetCurrentThreadId(), RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                 PagingIo, SynchronousIo, ByteOffset.HighPart, ByteOffset.LowPart,
                 ByteCount));

    if (PagingIo) {

        ASSERT(RxContext->CurrentIrp->MdlAddress != NULL);
        if (RxContext->CurrentIrp->MdlAddress == NULL) {
            DbgPrint("%ld: MRxDAVReadContinuation: MdlAddress == NULL\n", PsGetCurrentThreadId());
            DbgBreakPoint();
        }

        BytesToCopy = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation(0). ByteCount = %d, BytesToCopy = %d\n",
                     PsGetCurrentThreadId(), ByteCount, BytesToCopy));

        if (BytesToCopy > 0) {

            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            FALSE,
                                            TRUE,
                                            RxContext->CurrentIrp->MdlAddress,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            ByteOffset.QuadPart,
                                            MmGetMdlBaseVa(RxContext->CurrentIrp->MdlAddress),
                                            BytesToCopy,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(0). "
                             "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Add the actual bytes read to the TotalLengthActuallyRead.
            //
            TotalLengthActuallyRead += LengthRead;

            //
            // If LengthRead < BytesToCopy, it implies that the filesize of the
            // underlying file is less than the data being read. In such a case,
            // we return right away since we have already read whatever we could.
            //
            if (LengthRead < BytesToCopy) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. LengthRead < BytesToCopy\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(0)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;
        ASSERT(ByteCount < PAGE_SIZE);

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // Since this is PagingIo, the start address was page-aligned and we 
        // have read integral number of pages so ByteOffset+BytesToCopy should 
        // be page aligned as well.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the begenning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

        //
        // We have read all the bytes that are multiple of pages. We now need
        // to read the remaining bytes needed from the last page. From here,
        // we go to Case 3 below.
        //

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Remaining ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));
    
    }

    //
    // We allocate a page size buffer to be used for helping read the data 
    // which is not aligned at page boundaries.
    //
    AllocatedSideBuffer = RxAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, DAV_READWRITE_POOLTAG);
    if (AllocatedSideBuffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVReadContinuation/RxAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // When we issue a read down to the underlying file system, we need to make 
    // sure that the offset is page aligned and the bytecount is a multiple of 
    // PAGE_SIZE. This is because we created the local handle with the
    // NO_INTERMEDIATE_BUFFERING option. Since there is no cache map for this 
    // handle, all the data is read from the disk and hence the alignment issue.
    //

    //
    // Case 1: ByteOffset is not page aligned. In this case we read the page 
    // which contains the ByteOffset and copy the data from the ByteOffset to
    // the end of the page.
    //
    
    //
    // The "and" operation below does the following. If the ByteOffset is 6377
    // and the PAGE_SIZE is 4096, then the MisAlignment is 2281.
    //
    ByteOffsetMisAlignment = ( ByteOffset.LowPart & (PAGE_SIZE - 1) );

    if (ByteOffsetMisAlignment != 0) {
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 1\n",
                     PsGetCurrentThreadId()));
        
        AlignedOffset = ByteOffset;

        //
        // The byte offset is not aligned. We need to read the page containing
        // the offset now.
        //
    
        //
        // If the PAGE_SIZE is 4096 (0x1000) then (PAGE_SIZE - 1) is 0xFFF.
        // ~(PAGE_SIZE - 1) is 0x000. The bit operation below masks the lower 3
        // bytes of the aligned offset to make it page aligned.
        //
        AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);
    
        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
        LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                        TRUE,
                                        FALSE,
                                        NULL,
                                        davSrvOpen->UnderlyingDeviceObject,
                                        davSrvOpen->UnderlyingFileObject,
                                        AlignedOffset.QuadPart,
                                        AllocatedSideBuffer,
                                        PAGE_SIZE,
                                        &(IoStatusBlock));

        NtStatus = IoStatusBlock.Status;
    
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(1). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the length we read is less than the offset at which we have been
        // asked to read ( (LengthRead - ByteOffsetMisAlignment) <= 0 ) then
        // we return STATUS_END_OF_FILE. This is because we have been asked
        // to read beyond the current filesize.
        //
        if ( (LengthRead - ByteOffsetMisAlignment) <= 0 ) {
            NtStatus = STATUS_END_OF_FILE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. (LengthRead - ByteOffsetMisAlignment) <= 0\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the right number of bytes into the buffer.
        //
        BytesToCopy = min( ByteCount, (PAGE_SIZE - ByteOffsetMisAlignment) );

        //
        // If the data actually read is less than what BytesToCopy is from our
        // calculations above, it means that the amount of data requested is
        // more than the filesize. We only copy the right amount of data.
        //
        if ( BytesToCopy > (LengthRead - ByteOffsetMisAlignment) ) {
            BytesToCopy = (LengthRead - ByteOffsetMisAlignment);
            readLessThanAsked = TRUE;
        }

        //
        // Copy the bytes read into the user buffer starting at the correct offset.
        //
        RtlCopyMemory(UserBuffer,
                      (AllocatedSideBuffer + ByteOffsetMisAlignment),
                      BytesToCopy);

        //
        // Add the actual bytes read to the TotalLengthActuallyRead.
        //
        TotalLengthActuallyRead += BytesToCopy;

        //
        // If readLessThanAsked is TRUE, it implies that we have no more data
        // to read so we leave.
        //
        if (readLessThanAsked) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. readLessThanAsked(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
        // the ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the begenning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

    }

    //
    // Case 2: At this stage we have copied the bytes from the unaligned offset 
    // (if it the ByteOffset was unaligned) to the next page bouandary. Now we 
    // copy as many pages as we can.
    //
    
    //
    // If 4100 bytes are remaining, the operation below sets BytesToCopy to
    // 4096 and BytesLeftToCopy to 4.
    //
    BytesToCopy = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVReadContinuation. BytesToCopy = %d\n",
                 PsGetCurrentThreadId(), BytesToCopy));

    //
    // If we have any bytes (which are multiple of pages) to copy, we copy them
    // now.
    //
    if (BytesToCopy != 0) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 2\n",
                     PsGetCurrentThreadId()));
        
        //
        // If the UserBuffer is DWORD aligned then we copy the data directly 
        // the UserBuffer. If not then we read one page at a time and copy it
        // into the UserBuffer.
        //
        if ( ( (ULONG_PTR)UserBuffer & 0x3 ) == 0 ) {

            //
            // The UserBuffer is DWORD aligned.
            //

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. UserBuffer is DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // The offset is now page aligned. Zero out the number of bytes which 
            // will be read into the UserBuffer.
            //
            RtlZeroMemory(UserBuffer, BytesToCopy);

            //
            // BytesToCopy is a multiple of pages.
            //
            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            FALSE,
                                            FALSE,
                                            NULL,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            ByteOffset.QuadPart,
                                            UserBuffer,
                                            BytesToCopy,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                //
                // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
                // is > 0, it implies that the user asked for data from within
                // the file to beyond EOF. The EOF is page aligned. We just return
                // the data that we read till the EOF.
                //
                if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                    NtStatus = STATUS_SUCCESS;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVReadContinuation(1). EOF && TotalLengthActuallyRead\n",
                                 PsGetCurrentThreadId()));
                    goto EXIT_THE_FUNCTION;
                }
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(2). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the amount of data we read is less than what we asked for then
            // we only return the data that got read.
            //
            if (LengthRead < BytesToCopy) {
                BytesToCopy = LengthRead;
                readLessThanAsked = TRUE;
            }

            //
            // Add the actual bytes read to the TotalLengthActuallyRead.
            //
            TotalLengthActuallyRead += BytesToCopy;
            
            //
            // If readLessThanAsked is TRUE, it implies that we have no more data
            // to read so we leave.
            //
            if (readLessThanAsked) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. readLessThanAsked(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // If we have already written out the required number of bytes (which
            // means BytesToCopy == ByteCount), then we are done and can exit now.
            //
            if (BytesToCopy == ByteCount) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Decrement the ByteCount by the number of bytes that have been copied.
            //
            ByteCount -= BytesToCopy;

            //
            // Increment the ByteOffset with the number of bytes that have been copied.
            // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
            // the ByteOffset is now page aligned.
            //
            ByteOffset.QuadPart += BytesToCopy;

            //
            // Increment the UserBuffer pointer which currently points to the begenning
            // of the buffer which the user supplied by the number of bytes which have
            // been copied.
            //
            UserBuffer += BytesToCopy;

        } else {

            ULONG BytesToCopyThisIteration = 0;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. UserBuffer is NOT DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // The UserBuffer is not DWORD aligned, but the Offset is now 
            // Page aligned. We loop and copy one page at a time. The BytesToCopy
            // value below is a multiple of pages.
            //
            while (BytesToCopy > 0) {
            
                BytesToCopyThisIteration = ( (BytesToCopy < PAGE_SIZE) ? BytesToCopy : PAGE_SIZE );
            
                //
                // Copy the memory from the UserBuffer to the AllocatedSideBuffer.
                //
                RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
            
                LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                                TRUE,
                                                FALSE,
                                                NULL,
                                                davSrvOpen->UnderlyingDeviceObject,
                                                davSrvOpen->UnderlyingFileObject,
                                                ByteOffset.QuadPart,
                                                AllocatedSideBuffer,
                                                BytesToCopyThisIteration,
                                                &(IoStatusBlock));

                NtStatus = IoStatusBlock.Status;

                if (NtStatus != STATUS_SUCCESS) {
                    //
                    // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
                    // is > 0, it implies that the user asked for data from within
                    // the file to beyond EOF. The EOF is page aligned. We just
                    // return the data that we read till the EOF.
                    //
                    if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                        NtStatus = STATUS_SUCCESS;
                        DavDbgTrace(DAV_TRACE_DETAIL,
                                    ("%ld: MRxDAVReadContinuation(2). EOF && TotalLengthActuallyRead\n",
                                     PsGetCurrentThreadId()));
                        goto EXIT_THE_FUNCTION;
                    }
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(3). "
                                 "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // If the amount of data we read is less than what we asked for then
                // we only return the data that got read.
                //
                if (LengthRead < BytesToCopyThisIteration) {
                    BytesToCopyThisIteration = LengthRead;
                    readLessThanAsked = TRUE;
                }

                //
                // Copy the number of bytes read into the UserBuffer.
                //
                RtlCopyMemory(UserBuffer, AllocatedSideBuffer, BytesToCopyThisIteration);

                //
                // Add the actual bytes read to the TotalLengthActuallyRead.
                //
                TotalLengthActuallyRead += BytesToCopyThisIteration;

                //
                // If readLessThanAsked is TRUE, it implies that we have no more
                // data to read so we leave.
                //
                if (readLessThanAsked) {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVReadContinuation. readLessThanAsked(3)\n",
                                 PsGetCurrentThreadId()));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Decrement the ByteCount by the number of bytes that have been copied.
                //
                ByteCount -= LengthRead;

                //
                // Increment the ByteOffset with the number of bytes that have been copied.
                // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
                // the ByteOffset is now page aligned.
                //
                ByteOffset.QuadPart += LengthRead;

                //
                // Increment the UserBuffer pointer which currently points to the begenning
                // of the buffer which the user supplied by the number of bytes which have
                // been copied.
                //
                UserBuffer += LengthRead;

                //
                // Subtract the LengthWritten from the number of bytes to write.
                //
                BytesToCopy -= LengthRead;

            }

            //
            // If we have already written out the required number of bytes
            // (which means ByteCount == 0), then we are done and can exit now.
            //
            if (ByteCount == 0) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. Leaving!!! ByteCount = 0\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

        }
    
    }

    //
    // Case 3. Now we copy the trailing bytes which are not page aligned. This
    // is the last step. If the inital (ByteOffset + ByteCount) ended being
    // page aligned then ByteCount would be zero now.
    //

    if (ByteCount != 0) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 3\n",
                     PsGetCurrentThreadId()));

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));

        ASSERT(ByteCount < PAGE_SIZE);

        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
        //
        // Though we are issuing a read for PAGE_SIZE bytes, we might get less
        // less number of bytes if the EOF is reached.
        //
        LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                        TRUE,
                                        FALSE,
                                        NULL,
                                        davSrvOpen->UnderlyingDeviceObject,
                                        davSrvOpen->UnderlyingFileObject,
                                        ByteOffset.QuadPart,
                                        AllocatedSideBuffer,
                                        PAGE_SIZE,
                                        &(IoStatusBlock));

        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {
            //
            // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
            // is > 0, it implies that the user asked for data from within
            // the file to beyond EOF. The EOF is page aligned. We just return
            // the data that we read till the EOF.
            //
            if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                NtStatus = STATUS_SUCCESS;
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation(3). EOF && TotalLengthActuallyRead\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(4). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the amount of data read is less than what the user asked for then
        // we only return the data that is available.
        //
        if (LengthRead < ByteCount) {
            BytesToCopy = LengthRead;
            readLessThanAsked = TRUE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. readLessThanAsked(4)\n",
                         PsGetCurrentThreadId()));
        } else {
            BytesToCopy = ByteCount;
        }

        RtlCopyMemory(UserBuffer, AllocatedSideBuffer, BytesToCopy);

        //
        // Add the actual bytes read to the TotalLengthActuallyRead.
        //
        TotalLengthActuallyRead += BytesToCopy;

    }

EXIT_THE_FUNCTION:

    //
    // We allocate a page size buffer for the read and the write operations. We
    // need to free it now.
    //
    if (AllocatedSideBuffer) {
        RxFreePool(AllocatedSideBuffer);
    }

    //
    // We need to remove the reference we took at the begenning of this routine.
    //
    UMRxResumeAsyncEngineContext(RxContext);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVReadContinuation. NtStatus = %08lx, "
                 "TotalLengthActuallyRead = %d\n", 
                 PsGetCurrentThreadId(), NtStatus, TotalLengthActuallyRead));
    
    AsyncEngineContext->Status = NtStatus;

    //
    // We need to set these values in the RxContext. There is code in RDBSS
    // which takes care of putting these values in the IRP.
    //
    RxContext->StoredStatus = NtStatus;
    RxContext->InformationToReturn = TotalLengthActuallyRead;

    return NtStatus;
}


BOOLEAN
MRxDAVFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is the routine that handles fast I/O for read operation.

Arguments:

Return Value:

    TRUE (succeeded) or FALSE.

--*/
{
    BOOLEAN ReturnVal = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entered MRxDAVFastIoRead.\n", PsGetCurrentThreadId()));
    
    IoStatus->Status = STATUS_NOT_IMPLEMENTED;
    IoStatus->Information = 0;

    return (ReturnVal);
}


ULONG
DavReadWriteFileEx(
    IN USHORT Operation,
    IN BOOL NonPagedBuffer,
    IN BOOL UseOriginalIrpsMDL,
    IN PMDL OriginalIrpsMdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONGLONG FileOffset,
    IN OUT PVOID DataBuffer,
    IN ULONG SizeInBytes,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:

    This is the routine reads or writes (Operation) SizeInBytes bytes of data of 
    the file (FileObject) and copies (in case of read) it in the DataBuffer. In
    case of write the data from DataBuffer is written onto the file. The result 
    of the operation is set in the IoStatusBlock.

Arguments:

    Operation - Whether this is a Read or a Write operation.
    
    NonPagedBuffer - TRUE if the DataBuffer is from NonPagedPool which we
                     allocated in the read and write continuation routines to
                     make sure that the writes and reads that we pass down to
                     the underlying filesystem are page aligned.

    FileObject - The file object of the file in question.
    
    FileOffset - The offset at which the data is read or written.
    
    DataBuffer - The data buffer in which the data is copied in case of a read 
                 or the data is written to the file from the data buffer in
                 the write case. 
    
    SizeInBytes - Size in bytes of the DataBuffer.
    
    IoStatusBlock - The IO_STATUS_BLOCK which contains the return status.

Return Value:

    The number of bytes read or written.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ReadWriteLength = 0, MdlLength = 0;
    LARGE_INTEGER ByteOffset = {0,0};
    ULONG MajorFunction;
    PIRP Irp = NULL, TopIrp = NULL;
    PIO_STACK_LOCATION IrpSp = NULL;
    WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT DavIrpCompletionContext;
    LOCK_OPERATION ProbeOperation = 0;
    BOOL didProbeAndLock = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. Operation = %d, NonPagedBuffer = %d, "
                 "FileObject = %08lx, FileOffset = %d",
                 PsGetCurrentThreadId(), Operation, 
                 NonPagedBuffer, FileObject, FileOffset));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. SizeInBytes = %d\n", 
                 PsGetCurrentThreadId(), SizeInBytes));
    
    IoStatusBlock->Information = 0;

    if ( (DeviceObject->Flags & DO_BUFFERED_IO) ) {
        //
        // We cannot handle Buffered I/O Devices.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx. DeviceObject->Flags & DO_BUFFERED_IO\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INVALID_DEVICE_REQUEST;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we want to write the data OUT of the memory ON to the disk, we should
    // be probing with IoReadAccess. If we are reading data FROM the disk INTO
    // the memory, I should probe it with IoWriteAccess (since you the data you
    // read could be written to).
    //
    if (Operation == DAV_MJ_READ) {
        MajorFunction = IRP_MJ_READ;
        ProbeOperation = IoWriteAccess;
    } else {
        ASSERT(Operation == DAV_MJ_WRITE);
        MajorFunction = IRP_MJ_WRITE;
        ProbeOperation = IoReadAccess;
    }

    //
    // Set the Offset at which we are going to read or write.
    //
    ByteOffset.QuadPart = FileOffset;

    //
    // Allocate the new IRP that we will send down to the underlying file system.
    //
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (Irp == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoAllocateIrp\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked. This is where the function codes and the parameters are set.
    //
    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = (UCHAR)MajorFunction;
    
    IrpSp->FileObject = FileObject;
    
    //
    // Set the completion routine to be called everytime.
    //
    IoSetCompletionRoutine(Irp,
                           DavReadWriteIrpCompletionRoutine,
                           &(DavIrpCompletionContext),
                           TRUE,
                           TRUE,
                           TRUE);

    ASSERT( &(IrpSp->Parameters.Write.Key) == &(IrpSp->Parameters.Read.Key) );
    
    ASSERT( &(IrpSp->Parameters.Write.Length) == &(IrpSp->Parameters.Read.Length) );
    
    ASSERT( &(IrpSp->Parameters.Write.ByteOffset) == &(IrpSp->Parameters.Read.ByteOffset) );
    
    //
    // Set the length to be read/written to the number of bytes supplied by the
    // caller of the function.
    //
    IrpSp->Parameters.Read.Length = MdlLength = SizeInBytes;
    
    //
    // Set the offset to the value suppiled by the caller of the function.
    //
    IrpSp->Parameters.Read.ByteOffset = ByteOffset;
    
    IrpSp->Parameters.Read.Key = 0;
    
    Irp->RequestorMode = KernelMode;
    
    //
    // Set the UserBuffer of the Irp to the DataBuffer supplied by the caller.
    //
    Irp->UserBuffer = DataBuffer;

    //
    // Also the SizeInBytes which is set to the MdlLength above is always a
    // multiple of PAGE_SIZE.
    //
    // MdlLength = (ULONG)ROUND_TO_PAGES(MdlLength);

    //
    // Allocate the MDL for this Irp.
    //
    Irp->MdlAddress = IoAllocateMdl(Irp->UserBuffer, MdlLength, FALSE, FALSE, NULL);
    if (Irp->MdlAddress == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoAllocateMdl\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // We always do IRP_NOCACHE since the create of the local file was done with
    // NO_INTERMEDIATE_BUFFERING.
    //
    Irp->Flags |= IRP_NOCACHE;

    //
    // If we got a PagingIo, we build a partial MDL using the one that come down
    // in the original (PagingIo) IRP and send it down. We do this since the MDL
    // would have been probed and locked already and we don't need to do it
    // again.
    //
    if (UseOriginalIrpsMDL) {
        ASSERT(OriginalIrpsMdl != NULL);
        IoBuildPartialMdl(OriginalIrpsMdl, Irp->MdlAddress, Irp->UserBuffer, MdlLength);
    } else {
        //
        // If the DataBuffer that was supplied (which we set to the UserBuffer in 
        // the Irp above) is the one we allocated from the nonpaged pool, then we 
        // build the MDL from non-paged pool. We don't need to call ProbeAndLock
        // since we ourselves allocated it from Non-Paged Pool in the read and
        // write continuation routines. If this is not the buffer that we allocated
        // then we call MmProbeAndLockPages. We need to Probe because we allocated
        // the MDL above and it needs to be filled in with the correct address values
        // of where the data is.
        //
        if (NonPagedBuffer) {
            MmBuildMdlForNonPagedPool(Irp->MdlAddress);
        } else {
            try {
                MmProbeAndLockPages(Irp->MdlAddress, KernelMode, ProbeOperation);
                didProbeAndLock = TRUE;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NtStatus = GetExceptionCode();
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: DavReadWriteFileEx/MmProbeAndLockPages. NtStatus"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
                ReadWriteLength = -1;
                goto EXIT_THE_FUNCTION;
            }
        }
    }

    //
    // Initialize the event on which we will wait after we call IoCallDriver.
    // This event will be signalled in the Completion routine which will be 
    // called by the underlying file system after it completes the operation.
    //
    KeInitializeEvent(&(DavIrpCompletionContext.DavReadWriteEvent), 
                      NotificationEvent, 
                      FALSE);

    //
    // Now is the time to call the underlying file system with the Irp that we
    // just created.
    //
    try {
        
        //
        // Save the TopLevel Irp.
        //
        TopIrp = IoGetTopLevelIrp();
        
        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);
        
        //
        // Finally, call the underlying file system to process the request.
        //
        NtStatus = IoCallDriver(DeviceObject, Irp);

    } finally {
        
        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp); 
    
    }

    if (NtStatus == STATUS_PENDING) {
        
        //
        // If STATUS_PENDING was returned by the underlying file system then we
        // wait here till the operation gets completed.
        //
        KeWaitForSingleObject(&(DavIrpCompletionContext.DavReadWriteEvent),
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        
        NtStatus = Irp->IoStatus.Status;
    
    }

    if (NtStatus == STATUS_SUCCESS) {
        //
        // If the IoCallDriver was successful, then Irp->IoStatus.Information
        // contains the number of bytes read or written.
        //
        ReadWriteLength = (ULONG)Irp->IoStatus.Information;
        IoStatusBlock->Information = ReadWriteLength;
    } else if (NtStatus == STATUS_END_OF_FILE) {
        ReadWriteLength = 0;
    } else {
        ReadWriteLength = -1;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoCallDriver. NtStatus = %08lx\n",
                     PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Free the Irp that we allocated above.
    //
    if (Irp) {
        //
        // Free the MDL only if we allocated it in the first place.
        //
        if (Irp->MdlAddress) {
            //
            // If it was not from NonPagedPool, we would have locked it. So, we
            // need to unlock before freeing.
            //
            if (didProbeAndLock) {
                MmUnlockPages(Irp->MdlAddress);
            }
            IoFreeMdl(Irp->MdlAddress);
        }
        IoFreeIrp(Irp);
    }

    IoStatusBlock->Status = NtStatus;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. ReadWriteLength = %d\n",
                 PsGetCurrentThreadId(), ReadWriteLength));

    return ReadWriteLength;
}


NTSTATUS
DavReadWriteIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the read/write IRP that was sent to the 
    underlying file system is completed.

Arguments:

    DeviceObject - The WebDav Device object.

    CalldownIrp - The IRP that was created and sent to the underlying file 
                  system.

    Context - The context that was set in the IoSetCompletionRoutine function.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT DavIrpCompletionContext = NULL;

    DavIrpCompletionContext = (PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT)Context;

    //
    // This is not Pageable Code.
    //

    //
    // If the IoCallDriver routine returned pending then it will be set in the
    // IRP's PendingReturned field. In this case we need to set the event on 
    // which the thread which issued IoCallDriver will be waiting.
    //
    if (CalldownIrp->PendingReturned) {
        KeSetEvent( &(DavIrpCompletionContext->DavReadWriteEvent), 0 , FALSE );
    }
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\querydir.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    querydir.c

Abstract:

    This module implements the DAV mini redirector call down routines pertaining
    to query directory.

Author:

    Joe Linn
    
    Rohan Kumar [RohanK] 20-Sept-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVQueryDirectoryContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeQueryDirectoryRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeQueryDirectoryRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVQueryDirectoryFromCache(
    IN PRX_CONTEXT RxContext,
    IN PBYTE Buffer,
    IN PFILE_BASIC_INFORMATION Basic,
    IN PFILE_STANDARD_INFORMATION Standard,
    IN ULONG FileIndex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryDirectory)
#pragma alloc_text(PAGE, MRxDAVQueryDirectoryFromCache)
#pragma alloc_text(PAGE, MRxDAVQueryDirectoryContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeQueryDirectoryRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeQueryDirectoryRequest)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryDirectory(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles querydir requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    UNICODE_STRING CacheName;
    PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryDirectory.\n", PsGetCurrentThreadId()));
    
    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVQueryDirectory: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    CacheName.Buffer = RxAllocatePoolWithTag(PagedPool,
                                             MAX_PATH * sizeof(WCHAR),
                                             DAV_QUERYDIR_POOLTAG);

    if (CacheName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(CacheName.Buffer, MAX_PATH * sizeof(WCHAR));
    
    RtlCopyMemory(CacheName.Buffer,DirectoryName->Buffer,DirectoryName->Length);
    
    CacheName.Buffer[DirectoryName->Length/2] = L'\\';
    
    RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2 + 1],
                  capFobx->UnicodeQueryTemplate.Buffer,
                  capFobx->UnicodeQueryTemplate.Length);
    
    CacheName.Length =  ( DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR) );
    CacheName.MaximumLength = ( DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR) );

    if (!FsRtlDoesNameContainWildCards(&capFobx->UnicodeQueryTemplate)) {
        DAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo;
        PWEBDAV_FOBX DavFobx = MRxDAVGetFobxExtension(capFobx);

        if (DavFobx->CurrentFileIndex > 0) {
            DavFobx->NumOfFileEntries = 0;
            DavFobx->CurrentFileIndex = 0;
            NtStatus = STATUS_NO_MORE_FILES;
            goto EXIT_THE_FUNCTION;
        }
        
        if (MRxDAVIsFileNotFoundCachedWithName(&CacheName,capFcb->pNetRoot)) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVCreateContinuation file not found %wZ\n",&CacheName));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }

        if (MRxDAVIsFileInfoCacheFound(RxContext,&FileInfo,&NtStatus,&CacheName)) {
            PBYTE Buffer = RxContext->Info.Buffer;
            ULONG BufferLength = RxContext->Info.LengthRemaining;
            
            //
            // Zero the buffer supplied.
            //
            RtlZeroMemory(Buffer, BufferLength);

            NtStatus = MRxDAVQueryDirectoryFromCache(RxContext,
                                           Buffer,
                                           &FileInfo.BasicInformation,
                                           &FileInfo.StandardInformation,
                                           1);

            DavFobx->NumOfFileEntries = 1;
            DavFobx->CurrentFileIndex = 1;

            goto EXIT_THE_FUNCTION;
        }
    }
    
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_QUERYDIR,
                                        MRxDAVQueryDirectoryContinuation,
                                        "MRxDAVQueryDirectory");
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryDirectory with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    if (NtStatus == STATUS_NO_SUCH_FILE ||
        NtStatus == STATUS_OBJECT_PATH_NOT_FOUND ||
        NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        MRxDAVCacheFileNotFoundWithName(&CacheName,RxContext->pFcb->pNetRoot);
        MRxDAVInvalidateFileInfoCacheWithName(&CacheName,RxContext->pFcb->pNetRoot);
    }

EXIT_THE_FUNCTION:

    if (CacheName.Buffer != NULL) {
        RxFreePool(CacheName.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
MRxDAVQueryDirectoryContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for query directory operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus;
    BOOL SynchronousIo;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryDirectoryContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVQueryDirectoryContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);
    
    if (!SynchronousIo) {

        //
        // Set the asynchronous flag. This is done since we do not want this 
        // thread to block in the UMRxSubmitAsyncEngUserModeRequest function.
        // Also, since we need to call RxLowIoCompletion once we are done, set
        // ShouldCallLowIoCompletion in the context to TRUE.
        //
        SetFlag(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
        AsyncEngineContext->ShouldCallLowIoCompletion = TRUE;

        //
        // Set the CancelRoutine on the RxContext. Since this is an Async
        // operation, it can be cancelled.
        //
        NtStatus = RxSetMinirdrCancelRoutine(RxContext, MRxDAVCancelRoutine);
        if (NtStatus != STATUS_SUCCESS) {
            ASSERT(NtStatus = STATUS_CANCELLED);
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryContinuation: "
                         "AsyncEngineContext: %08lx. STATUS_CANCELLED\n", 
                         PsGetCurrentThreadId(), AsyncEngineContext));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Since this is an Asyncchronous operation, mark the IRP as pending.
        // Its OK if you mark an IRP pending and complete it on the same thread
        // without returning STATUS_PENDING.
        //
        IoMarkIrpPending(RxContext->CurrentIrp);

    }

    //  
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                 UMRX_ASYNCENGINE_ARGUMENTS,
                                 MRxDAVFormatUserModeQueryDirectoryRequest,
                                 MRxDAVPrecompleteUserModeQueryDirectoryRequest
                                 );

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryDirectoryContinuation with NtStatus "
                 "= %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeQueryDirectoryRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the QueryDirectory request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWCHAR ServerName = NULL, NetRootName = NULL, JustTheNetRootName = NULL;
    PBYTE PathName = NULL;
    ULONG ServerNameLengthInBytes, PathNameLengthInBytes, NetRootNameLengthInBytes;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    BOOLEAN ReturnVal;
    PUNICODE_STRING Template;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

    DavWorkItem->WorkItemType = UserModeQueryDirectory;
    
    QueryDirRequest = &(DavWorkItem->QueryDirRequest);

    DavFobx = MRxDAVGetFobxExtension(capFobx);
    ASSERT(DavFobx != NULL);

    NetRoot = SrvOpen->pFcb->pNetRoot;

    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: SrvCallName = %wZ, "
                 "SrvCallNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pSrvCall->pSrvCallName, NetRoot->pSrvCall->pSrvCallName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: NetRootName = %wZ, "
                 "NetRootNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pNetRootName, NetRoot->pNetRootName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: PathName = %wZ, "
                 "PathNameLength = %d\n", PsGetCurrentThreadId(), 
                 SrvOpen->pAlreadyPrefixedName, SrvOpen->pAlreadyPrefixedName->Length));

    //
    // Have we already created the DavFileAttributes list. If we have, then we 
    // tell the user mode process to do nothing and return. Here we do need to
    // impersonate becuase the usermode will fail otherwise. This is becuase
    // of the way the usermode code is structured.
    //
    if (DavFobx->DavFileAttributes) {
        QueryDirRequest->AlreadyDone = TRUE;
        goto IMPERSONATE_AND_EXIT;
    }
    
    QueryDirRequest->AlreadyDone = FALSE;
    
    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    QueryDirRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    QueryDirRequest->ServerID = DavSrvCall->ServerID;

    Template = &(capFobx->UnicodeQueryTemplate);
    
    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');

    //
    // Copy the PathName of the Directory. If the template does not contain any
    // wild cards, then we just need to get the attributes of this file from
    // the server. We only get the attributes of all the files, if a wild card
    // is specified in the template.
    //
    ReturnVal = FsRtlDoesNameContainWildCards(Template);

    if (ReturnVal) {
    
        //
        // The sizeof(WCHAR) is for the final '\0' char.
        //
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + sizeof(WCHAR) );
        
        //
        // We need to allocate memory for the backslash and the Remaining name
        // only if the remaining name exists.
        //
        if (SrvOpen->pAlreadyPrefixedName->Length) {
            //
            // The sizeof(WCHAR) is for the backslash after the NetRootName.
            //
            PathNameLengthInBytes += ( SrvOpen->pAlreadyPrefixedName->Length + sizeof(WCHAR) );
        }

        PathName = (PBYTE) UMRxAllocateSecondaryBuffer(AsyncEngineContext, PathNameLengthInBytes);
        if (PathName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        QueryDirRequest->PathName = (PWCHAR)PathName;
        
        RtlZeroMemory(QueryDirRequest->PathName, PathNameLengthInBytes);
        
        //
        // Copy the NetRootName.
        //
        RtlCopyMemory(PathName, JustTheNetRootName, NetRootNameLengthInBytes);

        //
        // We need to copy the backclash and the remaining path name only if
        // the remaining path name exists.
        //
        if (SrvOpen->pAlreadyPrefixedName->Length) {
            if (SrvOpen->pAlreadyPrefixedName->Buffer[0] != L'\\') {

                //
                // Copy the backslash.
                //
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes), L"\\", sizeof(WCHAR) );

                //
                // Copy the remaining path name after the NetRootName.
                //
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ), 
                               SrvOpen->pAlreadyPrefixedName->Buffer, 
                               SrvOpen->pAlreadyPrefixedName->Length);
            } else {
                //
                // Copy the remaining path name after the NetRootName which has the leading
                // backslash already.
                //
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes ), 
                               SrvOpen->pAlreadyPrefixedName->Buffer, 
                               SrvOpen->pAlreadyPrefixedName->Length);
            }
        }
    
        QueryDirRequest->NoWildCards = FALSE;

    } else {

        //
        // The Template is just a filename without any wild card chars. We copy
        // the filaname after the pathname and send it to the user mode. First,
        // we need to figure out if the path name has a trailing '\'.
        //

        BOOL trailingSlash = FALSE;
        PWCHAR PName = SrvOpen->pAlreadyPrefixedName->Buffer;
        ULONG PLen = SrvOpen->pAlreadyPrefixedName->Length;

        if (PLen) {
            if ( PName[ ( ( PLen / sizeof(WCHAR) ) - 1 ) ] == L'\\' ) {
                trailingSlash = TRUE;
            }
        } else {
            PName = NULL;
        }

        if (trailingSlash) {
            //
            // The first sizeof(WCHAR) is for the backslash after the NetRootName.
            // The second sizeof(WCHAR) for the final \0.
            //
            PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                      sizeof(WCHAR) +
                                      SrvOpen->pAlreadyPrefixedName->Length + 
                                      Template->Length + 
                                      sizeof(WCHAR) );
        } else {
            //
            // The first sizeof(WCHAR) is for the backslash after the NetRootName.
            // The second sizeof(WCHAR) is for the final '\0' char.
            //
            PathNameLengthInBytes = ( NetRootNameLengthInBytes +
                                      sizeof(WCHAR) +
                                      Template->Length +
                                      sizeof(WCHAR) );
            
            //
            // The sizeof(WCHAR) if for the '\\' between the pathname and the 
            // template name. We need to add this only if the remaining path
            // name exists.
            //
            if (PName) {
                PathNameLengthInBytes += ( SrvOpen->pAlreadyPrefixedName->Length +
                                           sizeof(WCHAR) );
            }
        }

        PathName = (PBYTE)UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      PathNameLengthInBytes);
        if (PathName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        QueryDirRequest->PathName = (PWCHAR)PathName;
        
        RtlZeroMemory(QueryDirRequest->PathName, PathNameLengthInBytes);
        
        //
        // Copy the NetRootName.
        //
        RtlCopyMemory(PathName, JustTheNetRootName, NetRootNameLengthInBytes);

        //
        // Copy the backclash.
        //
        RtlCopyMemory( (PathName + NetRootNameLengthInBytes), L"\\", sizeof(WCHAR) );
        
        //
        // If PName is not NULL, we need to copy the remaining name and then
        // the template name.
        //
        if (PName) {
            
            RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ),
                           SrvOpen->pAlreadyPrefixedName->Buffer,
                           SrvOpen->pAlreadyPrefixedName->Length);
            
            if (trailingSlash) {
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes + 
                                sizeof(WCHAR) + SrvOpen->pAlreadyPrefixedName->Length),
                               Template->Buffer, 
                               Template->Length );
            } else {
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes + sizeof(WCHAR) 
                                + SrvOpen->pAlreadyPrefixedName->Length), 
                               L"\\", 
                               sizeof(WCHAR) );
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) 
                                 + SrvOpen->pAlreadyPrefixedName->Length + sizeof(WCHAR) ), 
                               Template->Buffer, 
                               Template->Length );
            }
        
        } else {
            //
            // A backslash has already been copied after the NetRootName.
            //
            RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ), 
                           Template->Buffer, 
                           Template->Length );
        }

        QueryDirRequest->NoWildCards = TRUE;
    
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. PathName ="
                 " %ws\n", PsGetCurrentThreadId(), PathName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    QueryDirRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    QueryDirRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. DavVNetRoot"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. LogonID.LowPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. LogonID.HighPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
IMPERSONATE_AND_EXIT:

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeQueryDirectoryRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeQueryDirectoryRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = NULL;
    PFILE_NAMES_INFORMATION FileNamesInfo = NULL;
    PFILE_DIRECTORY_INFORMATION FileDirInfo = NULL;
    PFILE_FULL_DIR_INFORMATION FileFullDirInfo = NULL;
    PFILE_BOTH_DIR_INFORMATION FileBothDirInfo = NULL;
    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE Buffer = NULL;
    BOOL SingleEntry, InitialQuery, IndexSpecified, EndOfBuffer = FALSE;
    BOOLEAN ReturnVal, RestartScan, NoWildCards = FALSE, AsyncOperation = FALSE;
    ULONG FileIndex, BufferLength, BufferLengthUsed = 0, NextEntryOffset = 0;
    PUNICODE_STRING Template = NULL;
    UNICODE_STRING UnicodeFileName;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL, TempDFA = NULL;
    PLIST_ENTRY listEntry = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    PVOID PreviousBlock = NULL;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_STANDARD_INFORMATION StandardInfo;
    UNICODE_STRING CacheName;
    PUNICODE_STRING DirectoryName = NULL;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVPrecompleteUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    
    QueryDirRequest  = &(DavWorkItem->QueryDirRequest);
    QueryDirResponse = &(DavWorkItem->QueryDirResponse);

    //
    // If the operation is cancelled, then there is no guarantee that the FCB,
    // FOBX etc are still valid. All that we need to do is cleanup and bail.
    //
    if (!OperationCancelled) {
        //
        // We store the DavFileAttributes in the DAV FOBX extension. These will
        // be used on subsequent calls to the Enumerate directory call.
        //
        DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        DavFobx = MRxDAVGetFobxExtension(capFobx);
        ASSERT(DavFobx != NULL);
    }

    if ( QueryDirRequest->AlreadyDone == FALSE ) {
    
        //
        // If the operation is cancelled, then there is no guarantee that the FCB,
        // FOBX etc are still valid. All that we need to do is cleanup and bail.
        //
        if (!OperationCancelled) {

            //
            // Get the response items only if we succeeded in the user mode and if
            // we got the properties of all the files in the directory.
            //  
            if ( AsyncEngineContext->Status == STATUS_SUCCESS && 
                 QueryDirResponse->DavFileAttributes != NULL ) {

                DavFobx->DavFileAttributes = QueryDirResponse->DavFileAttributes;

                DavFobx->NumOfFileEntries = QueryDirResponse->NumOfFileEntries;

                DavFobx->CurrentFileIndex = 0;

                DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);

                DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "DavFileAttributes = %08lx, NumOfFileEntries = %d.\n", 
                             PsGetCurrentThreadId(), DavFobx->DavFileAttributes,
                             DavFobx->NumOfFileEntries));

            }

        } else {

            //
            // If the operation was cancelled and we allocated the
            // DavFileAttributeList in the usermode, we need to set 
            // callWorkItemCleanup to TRUE, so that it gets cleaned up.
            //
            if ( AsyncEngineContext->Status == STATUS_SUCCESS && 
                 QueryDirResponse->DavFileAttributes != NULL ) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "callWorkItemCleanup\n", PsGetCurrentThreadId()));
                DavWorkItem->callWorkItemCleanup = TRUE;
            }

        }

        //  
        // We need to free up the heaps, we allocated in the format routine.
        //
    
        if (QueryDirRequest->ServerName != NULL) {

            NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                               (PBYTE)QueryDirRequest->ServerName);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest/"
                             "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        }

        if (QueryDirRequest->PathName != NULL) {
    
            NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                               (PBYTE)QueryDirRequest->PathName);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest/"
                             "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        }
    
    }

    //
    // Before proceeding further, we need to check the following. Its very
    // important that these checks (Async and Cancel) are done before anything
    // else is done.
    //

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    if (AsyncOperation) {
        //
        // If this was an Async operation then we need to remove a reference on
        // the AsyncEngineContext which was taken before it was placed on the
        // KQueue to go to the usermode. Also, the context should have one more
        // reference.
        //
        ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        ASSERT(!ReturnVal);
    }

    //
    // If this operation was cancelled, then all that we need to do is finalize
    // the AsyncEngineContext, if the call was Async and return FALSE. If the
    // call was sync then we don't need to finalize.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "Operation Cancelled.\n", PsGetCurrentThreadId()));
        if (AsyncOperation) {
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
        }
        return FALSE;
    }

    CacheName.Buffer = RxAllocatePoolWithTag(PagedPool,
                                             MAX_PATH * sizeof(WCHAR),
                                             DAV_QUERYDIR_POOLTAG);
    if (CacheName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(CacheName.Buffer,MAX_PATH * sizeof(WCHAR));
    RtlCopyMemory(CacheName.Buffer,DirectoryName->Buffer,DirectoryName->Length);
    CacheName.Buffer[DirectoryName->Length/2] = L'\\';
    RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2 + 1],
                  capFobx->UnicodeQueryTemplate.Buffer,
                  capFobx->UnicodeQueryTemplate.Length);
    CacheName.Length =
    CacheName.MaximumLength = DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR);

    NtStatus = AsyncEngineContext->Status;

    if (NtStatus != STATUS_SUCCESS) {
        //
        // We failed in the user mode.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                     "QueryDirectory failed with NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
        
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(DavFobx->DavFileAttributes != NULL);

    SingleEntry = RxContext->QueryDirectory.ReturnSingleEntry;
    InitialQuery = RxContext->QueryDirectory.InitialQuery;
    RestartScan = RxContext->QueryDirectory.RestartScan;
    IndexSpecified = RxContext->QueryDirectory.IndexSpecified;
    FileIndex = RxContext->QueryDirectory.FileIndex;
    Buffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.LengthRemaining;
    Template = &(capFobx->UnicodeQueryTemplate);
    FileInformationClass = RxContext->Info.FileInformationClass;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "FileInformationClass = %d.\n", 
                 PsGetCurrentThreadId(), FileInformationClass));
    
    //
    // Zero the buffer supplied.
    //
    RtlZeroMemory(Buffer, BufferLength);

    //
    // See, if we need to restart from the beginning.
    //
    if (RestartScan) {
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
    }

    //
    // Response has a pointer to the list of DavFileAttributes.
    //
    DavFileAttributes = DavFobx->DavFileAttributes;
    listEntry = DavFobx->listEntry;

    //
    // If we have returned all the entries, inform the user that they are no 
    // more entries to return.
    //
    if ( DavFobx->CurrentFileIndex == DavFobx->NumOfFileEntries ) {
        DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                    ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "No more entries to return.\n", PsGetCurrentThreadId()));
        NtStatus = STATUS_NO_MORE_FILES;
        //
        // Reset the index for the next call.
        //
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "TLength = %d, TMaxLength = %d, Template = %wZ.\n", 
                 PsGetCurrentThreadId(), 
                 Template->Length, Template->MaximumLength, Template));

    do {

        TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

        //
        // If this file did not come back with a 200 OK in the PROPFIND response
        // then we need to skip it. The response of a PROPFIND is a multi-status
        // with each file/directory having its own status.
        //
        if (TempDFA->InvalidNode) {
            
            listEntry = listEntry->Flink;
            
            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // Check to see if the name of this entry matches the pattern supplied 
        // by the user. If it does not, then we don't need to return it.
        //
        RtlInitUnicodeString(&(UnicodeFileName), TempDFA->FileName);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "FileName = %ws\n", PsGetCurrentThreadId(), TempDFA->FileName));
        
        //
        // If the template does not contain any wild cards then we need to just
        // check if the unicode strings are equal. If it does contain wild cards,
        // then upcase the characters of the template and call 
        // FsRtlIsNameInExpression.
        //
        ReturnVal = FsRtlDoesNameContainWildCards(Template);

        if (ReturnVal) {

            UNICODE_STRING UpperCaseString;

            UpperCaseString.Buffer = NULL;
            UpperCaseString.Length = UpperCaseString.MaximumLength = 0;
            
            NtStatus = RtlUpcaseUnicodeString(&(UpperCaseString), Template, TRUE);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                             "/RtlUpcaseUnicodeString. NtStatus = %08lx.\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            ReturnVal = FsRtlIsNameInExpression(&(UpperCaseString),
                                                &(UnicodeFileName),
                                                TRUE,
                                                FALSE);
            
            //
            // RtlUpcaseUnicodeString allocates memory for the buffer field of 
            // the UpperCaseString. We need to free it now.
            //
            RtlFreeUnicodeString( &(UpperCaseString) );
        
        } else {

            NoWildCards = TRUE;
            
            ReturnVal = RtlEqualUnicodeString(Template,
                                              &(UnicodeFileName),
                                              TRUE);
        
        }

        if (!ReturnVal) {
            //
            // This name does not match the pattern, so ignore it. Get the 
            // next listEntry.
            //
            listEntry = listEntry->Flink;
            
            DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileName %ws does not belong to pattern.\n",
                         PsGetCurrentThreadId(), TempDFA->FileName));

            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // The first entry in the DavFileAttributes list is the directory being
        // enumerated. In this case NoWildCards == FALSE. We shouldn't be 
        // including this in the list of files returned. If we did a FindFirst 
        // on a particular file, then the only entry is for the file itself. In
        // this case NoWildCards == TRUE.
        //
        if ( DavFobx->CurrentFileIndex == 0 && !NoWildCards ) {
            
            listEntry = listEntry->Flink;
            
            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // If we did not get any FileAttributes for this file from the server,
        // set the attribute value to FILE_ATTRIBUTE_ARCHIVE since the apps 
        // expect this.
        //
        if (TempDFA->dwFileAttributes == 0) {
            TempDFA->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
        }

        RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2+1],
                      UnicodeFileName.Buffer,
                      UnicodeFileName.Length);
        CacheName.Length =
        CacheName.MaximumLength = DirectoryName->Length + UnicodeFileName.Length + sizeof(WCHAR);

        switch (FileInformationClass) {
    
        case FileNamesInformation:
        
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileNamesInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileNamesInfo = (PFILE_NAMES_INFORMATION)PreviousBlock;
                FileNamesInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_NAMES_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );
            
            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            //
            // Is there enough space in the user supplied buffer to store the
            // next entry ? If not, we need to return now since we cannot store
            // any more entries.
            //
            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileNamesInfo = (PFILE_NAMES_INFORMATION)PreviousBlock;
                    FileNamesInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }
            
            FileNamesInfo = (PFILE_NAMES_INFORMATION)Buffer;
            
            //
            // The NextEntryOffset gets set on the next cycle. This way, for 
            // the last entry it will be zero.
            //
            FileNamesInfo->NextEntryOffset = 0; 
            
            FileNamesInfo->FileIndex = TempDFA->FileIndex;
            
            FileNamesInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );
            
            wcscpy(FileNamesInfo->FileName, TempDFA->FileName);

            PreviousBlock = (PVOID)FileNamesInfo;
            
            //
            // Increment the pointer to point at the next byte.
            //
            Buffer += NextEntryOffset;

            //
            // We have written "NextEntryOffset" bytes, so decrement the number
            // of bytes available pointer.
            //
            BufferLength -= NextEntryOffset;

            //
            // Increment the total number of bytes written.
            //
            BufferLengthUsed += NextEntryOffset;

            break;

        case FileDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileDirInfo = (PFILE_DIRECTORY_INFORMATION)PreviousBlock;
                FileDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_DIRECTORY_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileDirInfo = (PFILE_DIRECTORY_INFORMATION)PreviousBlock;
                    FileDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileDirInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;

            FileDirInfo->NextEntryOffset = 0;
            
            FileDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;

            FileDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;
            
            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }
                    
                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }

                BasicInfo.CreationTime   = FileDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileDirInfo->FileAttributes;

                StandardInfo.AllocationSize = FileDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;


                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }
            
            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        case FileFullDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileFullDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)PreviousBlock;
                FileFullDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_FULL_DIR_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)PreviousBlock;
                    FileFullDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;

            FileFullDirInfo->NextEntryOffset = 0;
            
            FileFullDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileFullDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileFullDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileFullDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileFullDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileFullDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileFullDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileFullDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileFullDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileFullDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;

            FileFullDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileFullDirInfo->EaSize = 0;

            FileFullDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileFullDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileFullDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;

            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileFullDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }
                    
                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }
                
                BasicInfo.CreationTime   = FileFullDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileFullDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileFullDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileFullDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileFullDirInfo->FileAttributes;
    
                StandardInfo.AllocationSize = FileFullDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileFullDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;
    
                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileFullDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        case FileBothDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileBothDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousBlock;
                FileBothDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_BOTH_DIR_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                             " Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousBlock;
                    FileBothDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

            FileBothDirInfo->NextEntryOffset = 0;
            
            FileBothDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileBothDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileBothDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileBothDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileBothDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileBothDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileBothDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileBothDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileBothDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileBothDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;
            
            FileBothDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileBothDirInfo->EaSize = 0;

            //
            // We don't support short file names. We add L'\0' as the first
            // character in the ShortName string to make it a zero length name.
            //
            FileBothDirInfo->ShortNameLength = 0;
            FileBothDirInfo->ShortName[0] = L'\0';

            FileBothDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileBothDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileBothDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;

            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileBothDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }

                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }
                
                BasicInfo.CreationTime   = FileBothDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileBothDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileBothDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileBothDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileBothDirInfo->FileAttributes;
    
                StandardInfo.AllocationSize = FileBothDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileBothDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;
    
                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileBothDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        default:

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = UnKnown(%d).\n",
                         PsGetCurrentThreadId(), FileInformationClass));

            NtStatus = STATUS_NOT_SUPPORTED;
            goto EXIT_THE_FUNCTION;

            break;

        } // end of switch(FileInformationClass)

        //
        // If the user supplied buffer is not enough to store any more 
        // information, we are done. This check should be done before
        // changing the values below.
        //        
        if (EndOfBuffer) {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        //
        // These values should be changed after the "EndOfBuffer" check and 
        // before the "SingleEntry" check.
        //

        listEntry = listEntry->Flink;

        DavFobx->listEntry = listEntry;

        DavFobx->CurrentFileIndex++;
    
        //
        // If the user only asked for a single entry, we are done. This check 
        // should be done, after changing the values above.
        //
        if (SingleEntry) {
            break;
        }

    } while ( listEntry != &(DavFileAttributes->NextEntry) );

    //
    // If we have gone through all the entries and the BufferLengthUsed is 0,
    // then we need to return
    //
    if ( BufferLengthUsed == 0 && listEntry == &(DavFileAttributes->NextEntry) ) {
        NtStatus = STATUS_NO_MORE_FILES;
        //
        // Reset the index for the next call.
        //
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
        goto EXIT_THE_FUNCTION;
    }

    RxContext->Info.LengthRemaining -= BufferLengthUsed;
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVPrecompleteUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));
    
EXIT_THE_FUNCTION:

    AsyncEngineContext->Status = NtStatus;

    if (CacheName.Buffer != NULL) {
        RxFreePool(CacheName.Buffer);
    }

    return(TRUE);
}


NTSTATUS
MRxDAVQueryDirectoryFromCache(
    IN PRX_CONTEXT RxContext,
    IN PBYTE Buffer,
    IN PFILE_BASIC_INFORMATION BasicInfo,
    IN PFILE_STANDARD_INFORMATION StandardInfo,
    IN ULONG FileIndex
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

Return Value:

    TRUE or FALSE.

--*/
{
    RxCaptureFobx;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PFILE_NAMES_INFORMATION FileNamesInfo = NULL;
    PFILE_DIRECTORY_INFORMATION FileDirInfo = NULL;
    PFILE_FULL_DIR_INFORMATION FileFullDirInfo = NULL;
    PFILE_BOTH_DIR_INFORMATION FileBothDirInfo = NULL;
    ULONG BufferLength;
    PUNICODE_STRING FileName = &capFobx->UnicodeQueryTemplate;
    ULONG SpaceNeeded = 0;

    PAGED_CODE();

    BufferLength = RxContext->Info.LengthRemaining;
    SpaceNeeded = FileName->Length;
    
    switch (RxContext->Info.FileInformationClass) {
    
    case FileNamesInformation:
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileNamesInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_NAMES_INFORMATION);
        
        //
        // Is there enough space in the user supplied buffer to store the
        // next entry ? If not, we need to return now since we cannot store
        // any more entries.
        //
        if (SpaceNeeded > BufferLength) {
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }

        FileNamesInfo = (PFILE_NAMES_INFORMATION)Buffer;
        
        FileNamesInfo->NextEntryOffset = 0; 
        FileNamesInfo->FileIndex = FileIndex;
        FileNamesInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileNamesInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_DIRECTORY_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }

        FileDirInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
        FileDirInfo->NextEntryOffset = 0;
        FileDirInfo->FileIndex = FileIndex;
        
        FileDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileFullDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileFullDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_FULL_DIR_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }
        

        FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;

        FileFullDirInfo->NextEntryOffset = 0;
        FileFullDirInfo->FileIndex = FileIndex;
        
        FileFullDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileFullDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileFullDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileFullDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileFullDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileFullDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileFullDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileFullDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileFullDirInfo->EaSize = 0;

        FileFullDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileFullDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileBothDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileBothDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_BOTH_DIR_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }
        

        FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

        FileBothDirInfo->NextEntryOffset = 0;
        FileBothDirInfo->FileIndex = FileIndex;
        
        FileBothDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileBothDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileBothDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileBothDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileBothDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileBothDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileBothDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileBothDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileBothDirInfo->EaSize = 0;

        //
        // We don't support short file names. We add L'\0' as the first
        // character in the ShortName string to make it a zero length name.
        //
        FileBothDirInfo->ShortNameLength = 0;
        FileBothDirInfo->ShortName[0] = L'\0';
        
        FileBothDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileBothDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    default:

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = UnKnown(%d).\n",
                     PsGetCurrentThreadId(), RxContext->Info.FileInformationClass));

        NtStatus = STATUS_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;

        break;

    } // end of switch(FileInformationClass)

    RxContext->Info.LengthRemaining -= SpaceNeeded;

EXIT_THE_FUNCTION:

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davcreat.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davcreat.c

Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to
    creation of files.

Author:

    Rohan Kumar      [RohanK]      30-March-1999

Revision History:

Notes:

    Webdav Service is running in Local Services group. The local cache of the 
    URL is stored in the Local Services profile directories. These directories
    have the ACLs set to allow Local Services and Local System to access. 
    
    The encryption is done on the local cache file. Since encrypted file can
    only be operated in the user context, We have to impersonate before access
    the local cache file. In order to get the access to the file that is created
    in the Local Services profile directory in the user's context, we need to
    set the ACL to the encrypted file to allow everybody to access it. It won't
    result in a security hole because the file is encrypted.

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "efsstruc.h" // For EFS Stuff.
#include "UniUtf.h"
#include <sddl.h>

#define FILE_SIGNATURE    L"ROBS"
#define STREAM_SIGNATURE  L"NTFS"
#define DATA_SIGNATURE    L"GURE"


BOOL
DavIsThisFileEncrypted(
    PVOID DataBuff
    );

ULONG
DavCheckSignature(
    PVOID Signature
    );

DWORD
DavRestoreEncryptedFile(
    PWCHAR ExportFile,
    PWCHAR ImportFile
    );

DWORD
DavWriteRawCallback(
    PBYTE DataBuff,
    PVOID CallbackContext,
    PULONG DataLength
    );

DWORD
DavReuseCacheFileIfNotModified(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );


DWORD
DavCreateUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavCommitUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    );

DWORD
DavGetUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavAddIfModifiedSinceHeader(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavQueryUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavAsyncCreatePropFind(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncCreateQueryParentDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncCreateGet(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

#define FileCacheExpiryInterval 600000000 // 60 seconds

CHAR   rgchIMS[] = "If-Modified-Since";
//
// Implementation of functions begins here.
//

ULONG
DavFsCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV create/open requests that get reflected from the
    kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle;
    PWCHAR ServerName = NULL, FileName = NULL, CanName, UrlBuffer = NULL;
    PWCHAR CompletePathName, cPtr, FileNameBuff = NULL;
    DWORD urlLength = 0, ServerLen, ServerLenInBytes, PathLen, PathLenInBytes;
    DWORD FileNameBuffBytes, i = 0, ServerID;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL ReturnVal, CallBackContextInitialized = FALSE, EnCriSec = FALSE;
    BOOL didImpersonate = FALSE;
    URL_COMPONENTSW UrlComponents;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    //
    // Get the request buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    ServerID = CreateRequest->ServerID;

    //
    // If the complete path name is NULL, then we have nothing to create.
    //
    if (CreateRequest->CompletePathName == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate: ERROR: CompletePathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // CreateRequest->CompletePathName contains the complete path name.
    //

    DavPrint((DEBUG_MISC, "DavFsCreate: DavWorkItem = %08lx\n", DavWorkItem));

    DavPrint((DEBUG_MISC,
              "DavFsCreate: CompletePathName: %ws\n", CreateRequest->CompletePathName));

    //
    // We need to do some name munging, if the create is because of a local
    // drive being mapped to a UNC name. The fomat in that case would be
    // \;X:0\server\share
    //
    if ( CreateRequest->CompletePathName[1] == L';') {
        CompletePathName = &(CreateRequest->CompletePathName[6]);
    } else{
        CompletePathName = &(CreateRequest->CompletePathName[1]);
    }
    
    //
    // Here, we parse the Complete path name and remove the server name and the
    // file name from it. We use these to construct the URL for the WinInet
    // calls. The complete path name is of the form \server\filename.
    // The name ends with a '\0'. Note that the filename could be of the form
    // share\foo\bar\duh.txt.
    //

    //       [\;X:0]\server\filename
    //               ^
    //               |
    //               CompletePathName(CPN)


    //              \server\filename
    //               ^     ^
    //               |     |
    //               CPN   cPtr
    cPtr = wcschr(CompletePathName, '\\');

    //
    // Length of the server name including the terminating '\0' char.
    //
    ServerLen = 1 + (((PBYTE)cPtr - (PBYTE)CompletePathName) / sizeof(WCHAR));
    ServerLenInBytes = ServerLen * sizeof(WCHAR);

    //              \server\filename
    //               ^      ^
    //               |      |
    //               CPN    cPtr
    cPtr++;

    //
    // Length of the server name including the terminating '\0' char.
    //
    PathLen = 1 + wcslen(cPtr);
    PathLenInBytes = PathLen * sizeof(WCHAR);

    //
    // Allocate the memory and fill in the server name char by char.
    //
    ServerName = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                     ServerLenInBytes);
    if (ServerName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //              \server\filename
    //               ^^^^^^ ^
    //               |||||| |
    //               CPN    cPtr
    while(CompletePathName[i] != '\\') {
        ASSERT(i < ServerLen);
        ServerName[i] = CompletePathName[i];
        i++;
    }
    ASSERT((i + 1) == ServerLen);
    ServerName[i] = '\0';

    //
    // Allocate the memory and copy the file name.
    //
    FileName = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, PathLenInBytes);
    if (FileName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // This remaining path name is needed in Async Create Callback function.
    //
    DavWorkItem->AsyncCreate.RemPathName = FileName;

    wcscpy(FileName, cPtr);

    CanName = FileName;

    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    //
    // Check if this is a stream, if so, bailout right from here.
    //
    if(wcschr(FileName, L':')) {
        WStatus = ERROR_INVALID_NAME;
            DavPrint((DEBUG_MISC, "DavFsCreate: Trying to create streams\n"));
            goto EXIT_THE_FUNCTION;
    }
    
    //
    // If we have a dummy share name in the FileName, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(FileName);

    DavPrint((DEBUG_MISC,
             "DavFsCreate: ServerName: %ws, File Name: %ws\n",
             ServerName, FileName));

    //
    // Create the URL to be sent to the server. Initialize the UrlComponents
    // structure before making the call.
    //
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    UrlComponents.lpszScheme = NULL;
    UrlComponents.dwSchemeLength = 0;
    UrlComponents.nScheme = INTERNET_SCHEME_HTTP;
    UrlComponents.lpszHostName = ServerName;
    UrlComponents.dwHostNameLength = wcslen(ServerName);
    UrlComponents.nPort = DEFAULT_HTTP_PORT;
    UrlComponents.lpszUserName = NULL;
    UrlComponents.dwUserNameLength = 0;
    UrlComponents.lpszPassword = NULL;
    UrlComponents.dwPasswordLength = 0;
    UrlComponents.lpszUrlPath = FileName;
    UrlComponents.dwUrlPathLength = wcslen(FileName);
    UrlComponents.lpszExtraInfo = NULL;
    UrlComponents.dwExtraInfoLength = 0;
    ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                   0,
                                   NULL,
                                   &(urlLength));
    if (!ReturnVal) {

        ULONG urlLengthInWChars = 0;

        WStatus = GetLastError();

        // 
        // We pre-allocate the Url buffer on the CreateResponse with the size of
        // MAX_PATH * 2. Any Url longer than that will overrun the buffer. The Url
        // will be used to update the LastAccessTime of the WinInet cache on rename 
        // and close later. Note urlLength is the number of bytes.
        //
        if (urlLength >= MAX_PATH * 4) {
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }

        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {

            UrlBuffer = (PWCHAR) LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT,
                                             urlLength);
            if (UrlBuffer != NULL) {

                ZeroMemory(UrlBuffer, urlLength);

                //
                // This UrlBuffer is needed in Async Create Callback function.
                // We need to supply the length (4th Parameter) in WChars.
                //
                DavWorkItem->AsyncCreate.UrlBuffer = UrlBuffer;

                urlLengthInWChars = ( urlLength/sizeof(WCHAR) );

                ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                               0,
                                               UrlBuffer,
                                               &(urlLengthInWChars));
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsCreate/InternetCreateUrl. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            } else {

                WStatus = GetLastError();

                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));

                goto EXIT_THE_FUNCTION;

            }

        } else {

            DavPrint((DEBUG_ERRORS,
                      "DavFsCreate/InternetCreateUrl. Error Val = %d\n",
                      WStatus));

            goto EXIT_THE_FUNCTION;

        }

    }
    
    DavPrint((DEBUG_MISC, "URL: %ws\n", UrlBuffer));
    
    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/DavFsSetTheDavCallBackContext. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the
    // variable CallBackContext. This will now be used in all the async calls
    // that follow. This needs to be done only if we are calling the WinInet
    // APIs asynchronously.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavFsCreate: LogonId.LowPart = %d, LogonId.HighPart = %d\n",
              CreateRequest->LogonID.LowPart, CreateRequest->LogonID.HighPart));
    
    //
    // Find out whether we already have a "InternetConnect" handle to the
    // server. One could have been created during the CreateSrvCall process.
    // We can check the per user entries hanging off this server to see if an
    // entry for this user exists. If it does, use the InternetConnect handle
    // to do the HttpOpen. Otherwise, create and entry for this user and add it
    // to the list of the per user entries of the server.
    //

    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID,
                                      &(CreateRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the Create request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsCreate: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncCreate.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncCreate.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;
        
    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now. We shouldn't do it before we call CreateUrlCacheEntry
    // because that call will fail if the thread is not running in the context
    // of the Web Client Service.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif
    
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

    DavPrint((DEBUG_MISC, "DavFsCreate: DavConnHandle = %08lx.\n", DavConnHandle));

    DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePropFind;
    DavWorkItem->DavMinorOperation = DavMinorQueryInfo;
    DavWorkItem->AsyncCreate.DataBuff = NULL;
    DavWorkItem->AsyncCreate.didRead = NULL;
    DavWorkItem->AsyncCreate.Context1 = NULL;
    DavWorkItem->AsyncCreate.Context2 = NULL;

    if (CreateRequest->FileInformationCached) {
        DavPrint((DEBUG_MISC,
                 "Cached info   %x %x %x %ws\n",
                 CreateResponse->BasicInformation.FileAttributes,
                 CreateResponse->StandardInformation.AllocationSize.LowPart,
                 CreateResponse->StandardInformation.EndOfFile.LowPart,
                 DavWorkItem->AsyncCreate.UrlBuffer));
    }

    if ((CreateRequest->FileNotExists) || (CreateRequest->FileInformationCached)) {
        FILE_BASIC_INFORMATION BasicInformation = CreateResponse->BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation = CreateResponse->StandardInformation;
        
        RtlZeroMemory(CreateResponse, sizeof(*CreateResponse));

        //
        // Restore the file information on the create request
        //
        if (CreateRequest->FileInformationCached) {
            CreateResponse->BasicInformation = BasicInformation;
            CreateResponse->StandardInformation = StandardInformation;
            DavWorkItem->AsyncCreate.doesTheFileExist = TRUE;
        }

        if (!didImpersonate) {
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/UMReflectorImpersonate. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }
            didImpersonate = TRUE;
        }
        
        DavPrint((DEBUG_MISC,
                 "DavFsCreate skip PROPFIND for %x %x %ws\n", 
                 CreateRequest->FileAttributes,
                 CreateResponse->BasicInformation.FileAttributes,
                 DavWorkItem->AsyncCreate.UrlBuffer));

        WStatus = DavAsyncCreatePropFind(DavWorkItem);
    } else {
        RtlZeroMemory(CreateResponse, sizeof(*CreateResponse));
        
        //
        // Convert the unicode object name to UTF-8 URL format. Space and other 
        // white characters will remain untouched. These should be taken care of by 
        // the wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavConnHandle,
                                      L"PROPFIND",
                                      FileName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_RESYNCHRONIZE |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"DavFsCreate",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle));
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/HttpOpenRequestW. Error Val = %d.\n",
                          WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING && WStatus != ERROR_FILE_NOT_FOUND) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreate/DavAsyncCommonStates. Error Val = %08lx\n",
                      WStatus));
        }
    }

EXIT_THE_FUNCTION: // Do the necessary cleanup and return.

    //
    // We could have taken the lock and come down an error path without
    // releasing it. If thats the case, then we need to release the lock now.
    //
    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    if (ServerName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)ServerName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreate/LocalFree. Error Val = %d\n", FreeStatus));
        }
    }
    
    if (WStatus == ERROR_SUCCESS) {
        wcscpy(CreateResponse->Url, DavWorkItem->AsyncCreate.UrlBuffer);
        
        DavPrint((DEBUG_MISC,
                 "Returned info %x %x %x %ws\n",
                 CreateResponse->BasicInformation.FileAttributes,
                 CreateResponse->StandardInformation.AllocationSize.LowPart,
                 CreateResponse->StandardInformation.EndOfFile.LowPart,
                 DavWorkItem->AsyncCreate.UrlBuffer));
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
        
        DavAsyncCreateCompletion(DavWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavFsCreate: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        
        //
        // The error cannot map to STATUS_SUCCESS. If it does, we need to
        // break here and investigate.
        //
        if (DavWorkItem->Status == STATUS_SUCCESS) {
            DbgBreakPoint();
        }
    
    } else {
        
        PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
        
        CreateResponse = &(DavWorkItem->CreateResponse);

        DavWorkItem->Status = STATUS_SUCCESS;

        //
        // If we suceeded and it was a file and the open was not a pseudo open, 
        // the handle should be set. Otherwise we screwed up. We should then 
        // break here and investigate.
        //
        if ( !(CreateResponse->StandardInformation.Directory) && 
             !(CreateResponse->fPsuedoOpen) ) {
            if (CreateResponse->Handle == NULL) {
                DbgBreakPoint();
            }
        }
    
    }
    
    DavAsyncCreateCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD
DavAsyncCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the create operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NumOfFileEntries = 0;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = FALSE, readDone = FALSE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD toRead = 0, didRead = 0, didWrite = 0;
    LPDWORD NumRead = NULL;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes;
    PCHAR DataBuff = NULL;
    DWORD DataBuffBytes;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR pEncryptedCachedFile = NULL;
    PDAV_FILE_ATTRIBUTES DavDirectoryAttributes = NULL;
    ACCESS_MASK DesiredAccess = 0;
    BOOL BStatus = FALSE, fCacheFileReused = FALSE;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // We set the CallbackContext only if we are calling the WinInet APIs
    // asynchronously.
    //
    CallBackContext = (ULONG_PTR)DavWorkItem;

    //
    // If this function was called by the thread that picked off the DavWorkItem
    // from the Callback function, we need to do a few things first. These are
    // done below.
    //
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorImpersonate. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {

            WStatus = DavWorkItem->AsyncResult->dwError;

            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else if (WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {

                //
                // MSN has this BUG where it returns 302 instead of 404 when
                // queried for a file (eg:Desktop.ini) which does not exist at
                // the share level.
                //
                WStatus = ERROR_FILE_NOT_FOUND;

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate. AsyncFunction failed. Error Val = %d\n",
                          WStatus));

            }

            goto EXIT_THE_FUNCTION;

        }

    }

#else

    //
    // If we are using synchronous WinInet then we enter this function 
    // impersonating the client.
    //
    didImpersonate = TRUE;

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    switch (DavWorkItem->DavOperation) {

    case DAV_CALLBACK_HTTP_END:
    case DAV_CALLBACK_HTTP_READ: {


        if (DavWorkItem->AsyncCreate.DataBuff == NULL) {
            //
            // Need to allocate memory for the read buffer.
            //
            DataBuffBytes = NUM_OF_BYTES_TO_READ;
            DataBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
            if (DataBuff == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.DataBuff = DataBuff;
        }

        if (DavWorkItem->AsyncCreate.didRead == NULL) {
            //
            // Allocate memory for the DWORD that stores the number of bytes read.
            //
            NumRead = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, sizeof(DWORD));
            if (NumRead == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.didRead = NumRead;
        }

        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreate: AsyncCreateState = %d\n",
                  DavWorkItem->AsyncCreate.AsyncCreateState));

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreate: CalledByCallBackThread = %d\n",
                  CalledByCallBackThread));

        //
        // When we come here, we could either be doing a PROPFIND or GET on the
        // file. The PROPFIND is done to get the file attributes and the GET to
        // get the whole file from the server.
        //

        if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind) {

            if (DavWorkItem->DavMinorOperation == DavMinorQueryInfo) {

                ULONG ResponseStatus;

                //
                // If the file for which the PROPFIND was done does not exist, then
                // we need to Create one or fail, depending on the create options
                // specified by the application.
                //

                //
                // Does this file exist ? If the ResponseStatus is not
                // ERROR_SUCCESS, then we are sure that the file does not
                // exist. But, if it is we cannot be sure that the file exists.
                //
                ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
                if (ResponseStatus == ERROR_SUCCESS) {
                    doesTheFileExist = TRUE;
                } else {
                    //
                    // Carry on only if http really didn't find it. Bailout if 
                    // there is some other error.
                    //
                    if (ResponseStatus == ERROR_FILE_NOT_FOUND) {
                        doesTheFileExist = FALSE;
                    } else {
                        WStatus = ResponseStatus;
                        goto EXIT_THE_FUNCTION;
                    }
                }

                DavWorkItem->AsyncCreate.doesTheFileExist = doesTheFileExist;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: doesTheFileExist = %d\n", doesTheFileExist));

                //
                // Since the file existed, the next thing we do is read the
                // XML response which contains the properties of the file.
                //
                DavWorkItem->DavMinorOperation = DavMinorReadData;

            }

            doesTheFileExist = DavWorkItem->AsyncCreate.doesTheFileExist;

            if (doesTheFileExist) {

                NumRead = DavWorkItem->AsyncCreate.didRead;
                DataBuff = DavWorkItem->AsyncCreate.DataBuff;
                Ctx1 = DavWorkItem->AsyncCreate.Context1;
                Ctx2 = DavWorkItem->AsyncCreate.Context2;

                do {

                    switch (DavWorkItem->DavMinorOperation) {

                    case DavMinorReadData:

                        DavWorkItem->DavMinorOperation = DavMinorPushData;

                        ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                                     (LPVOID)DataBuff,
                                                     NUM_OF_BYTES_TO_READ,
                                                     NumRead);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            if (WStatus != ERROR_IO_PENDING) {
                                DavCloseContext(Ctx1, Ctx2);
                                DavPrint((DEBUG_ERRORS,
                                          "DavAsyncCreate/InternetReadFile. Error Val"
                                          " = %d\n", WStatus));
                            }
                            DavPrint((DEBUG_MISC,
                                      "DavAsyncCreate/InternetReadFile(1). "
                                      "ERROR_IO_PENDING.\n"));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // Lack of break is intentional.
                        //

                    case DavMinorPushData:

                        DavWorkItem->DavMinorOperation = DavMinorReadData;

                        didRead = *NumRead;

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(1): toRead = %d, didRead = %d.\n",
                                  NUM_OF_BYTES_TO_READ, didRead));

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(1): DataBuff = %s\n", DataBuff));

                        readDone = (didRead == 0) ? TRUE : FALSE;

                        WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                        if (WStatus != ERROR_SUCCESS) {
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/DavPushData. Error Val = %d\n",
                                      WStatus));
                            goto EXIT_THE_FUNCTION;
                        }

                        if (DavWorkItem->AsyncCreate.Context1 == NULL) {
                            DavWorkItem->AsyncCreate.Context1 = Ctx1;
                        }

                        if (DavWorkItem->AsyncCreate.Context2 == NULL) {
                            DavWorkItem->AsyncCreate.Context2 = Ctx2;
                        }

                        break;

                    default:

                        WStatus = ERROR_INVALID_PARAMETER;

                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate. Invalid DavMinorOperation = %d.\n",
                                  DavWorkItem->DavMinorOperation));

                        goto EXIT_THE_FUNCTION;

                        break;

                    }

                    if (readDone) {
                        break;
                    }

                } while ( TRUE );

                //
                // We now need to parse the data.
                //

                DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof(DAV_FILE_ATTRIBUTES) );
                if (DavFileAttributes == NULL) {
                    DavCloseContext(Ctx1, Ctx2);
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/LocalAlloc. Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                InitializeListHead( &(DavFileAttributes->NextEntry) );

                WStatus = DavParseData(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
                if (WStatus != ERROR_SUCCESS) {
                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavParseData. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Its possible to get a 207 response for the PROPFIND request
                // even if the request failed. In such a case the status value
                // in the XML response indicates the error. If this happens, 
                // set InvalidNode to TRUE.
                //
                if (DavFileAttributes->InvalidNode) {
                    WStatus = ERROR_INTERNAL_ERROR;
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate. Invalid Node!! Status = %ws\n",
                              DavFileAttributes->Status));
                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    goto EXIT_THE_FUNCTION;
                }

                DavPrint((DEBUG_MISC,"DavAsyncCreate: NumOfFileEntries = %d\n", NumOfFileEntries));

                //
                // If this is a directory create and the intention is to delete
                // it, we perform the following checks.
                //
                if ( (DavFileAttributes->isCollection) &&
                     (CreateRequest->DesiredAccess & DELETE ||
                      CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE)) {

                    PWCHAR CPN1 = NULL;
                    BOOL ServerShareDelete = TRUE;
                    DWORD wackCount = 0;

                    //
                    // If the delete is just for \\server\share then we return
                    // ERROR_ACCESS_DENIED. CompletePathName has the form
                    // \server\share\dir. If its \server\share or \server\share\,
                    // we return the error. This is because we do not allow
                    // a client to delete a share on the server.
                    //
                    CPN1 = CreateRequest->CompletePathName;
                    while ( *CPN1 != L'\0' ) {
                        if ( *CPN1 == L'\\' || *CPN1 == L'/' ) {
                            wackCount++;
                            if ( (wackCount > 2) && (*(CPN1 + 1) != L'\0') ) {
                                ServerShareDelete = FALSE;
                                break;
                            }
                        }
                        CPN1++;
                    }

                    if (ServerShareDelete) {
                        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                        DavFileAttributes = NULL;
                        WStatus = ERROR_ACCESS_DENIED;
                        DavPrint((DEBUG_ERRORS, "DavAsyncCreate: ServerShareDelete & ERROR_ACCESS_DENIED\n"));
                        goto EXIT_THE_FUNCTION;
                    }

                    //
                    // If the directory is not empty, we return the following.
                    //
                    if (NumOfFileEntries > 1) {
                        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                        DavFileAttributes = NULL;
                        WStatus = ERROR_DIR_NOT_EMPTY;
                        DavPrint((DEBUG_ERRORS, "DavAsyncCreate: ERROR_DIR_NOT_EMPTY\n"));
                        goto EXIT_THE_FUNCTION;
                    }
                
                }

                //
                // During the create call, we only query the attributes for the file
                // or the directory. Hence if the request succeeded, the number of
                // DavFileAttribute entries created should be = 1. If it failed,
                // the NumOfFileEntries == 0. The request could fail even if the
                // response was "HTTP/1.1 207 Multi-Status". The status is returned
                // in the XML response.
                //
                if (NumOfFileEntries != 1) {
                    
                    PLIST_ENTRY listEntry = &(DavFileAttributes->NextEntry);
                    PDAV_FILE_ATTRIBUTES DavFA = NULL;
                    
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate. NumOfFileEntries = %d\n",
                              NumOfFileEntries));
                    
                    do {
                        DavFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);
                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate. FileName = %ws\n",
                                  DavFA->FileName));
                        listEntry = listEntry->Flink;
                    } while ( listEntry != &(DavFileAttributes->NextEntry) );

                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    doesTheFileExist = FALSE;

                    DavWorkItem->AsyncCreate.doesTheFileExist = FALSE;
                
                }
            
            }

            if (doesTheFileExist) {
                
                //
                // Set the FILE_BASIC_INFORMATION.
                //

                CreateResponse->BasicInformation.CreationTime.HighPart =
                                       DavFileAttributes->CreationTime.HighPart;
                CreateResponse->BasicInformation.CreationTime.LowPart =
                                       DavFileAttributes->CreationTime.LowPart;

                CreateResponse->BasicInformation.LastAccessTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.LastAccessTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.LastWriteTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.LastWriteTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.ChangeTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.ChangeTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.FileAttributes = DavFileAttributes->dwFileAttributes;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate. attributes %x %ws\n",DavFileAttributes->dwFileAttributes,DavWorkItem->AsyncCreate.RemPathName));

                if (DavFileAttributes->isHidden || 
                    (DavFileAttributes->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) {
                    CreateResponse->BasicInformation.FileAttributes |=
                                                          FILE_ATTRIBUTE_HIDDEN;
                } else {
                    CreateResponse->BasicInformation.FileAttributes &=
                                                          ~FILE_ATTRIBUTE_HIDDEN;
                }

                if (DavFileAttributes->isCollection) {
                    CreateResponse->BasicInformation.FileAttributes |=
                                                          FILE_ATTRIBUTE_DIRECTORY;
                } else {
                    CreateResponse->BasicInformation.FileAttributes &=
                                                          ~FILE_ATTRIBUTE_DIRECTORY;
                }

                //
                // Set the FILE_STANDARD_INFORMATION.
                //

                CreateResponse->StandardInformation.AllocationSize.HighPart =
                                               DavFileAttributes->FileSize.HighPart;
                CreateResponse->StandardInformation.AllocationSize.LowPart =
                                               DavFileAttributes->FileSize.LowPart;

                CreateResponse->StandardInformation.EndOfFile.HighPart =
                                               DavFileAttributes->FileSize.HighPart;
                CreateResponse->StandardInformation.EndOfFile.LowPart =
                                               DavFileAttributes->FileSize.LowPart;

                CreateResponse->StandardInformation.NumberOfLinks = 0;

                CreateResponse->StandardInformation.DeletePending = 0;

                CreateResponse->StandardInformation.Directory =
                                                    DavFileAttributes->isCollection;
                
                //
                // We don't need the attributes list any more, so finalize it.
                //
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;

                //
                // CLose the XML parser contexts.
                //
                DavCloseContext(Ctx1, Ctx2);
                DavWorkItem->AsyncCreate.Context1 = NULL;
                DavWorkItem->AsyncCreate.Context2 = NULL;
            
            }
            
            //
            // We are done with the Open handle to PROPFIND. Now we need to GET
            // the file from the server.
            //
            InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
            DavWorkItem->AsyncCreate.DavOpenHandle = NULL;
            
            ASSERT(didImpersonate);
            WStatus = DavAsyncCreatePropFind(DavWorkItem);

        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateQueryParentDirectory) {
            
            ULONG ResponseStatus;
            BOOL doesTheDirectoryExist = FALSE;

            //
            // If the parent directory for which the PROPFIND was done do not have encryption flag set,
            // the file will be created normally. Otherwise, the file will be encrypted when created.
            //

            DavPrint((DEBUG_MISC, "AsyncCreateQueryParentDirectory\n"));
            
            NumRead = DavWorkItem->AsyncCreate.didRead;
            DataBuff = DavWorkItem->AsyncCreate.DataBuff;
            Ctx1 = DavWorkItem->AsyncCreate.Context1;
            Ctx2 = DavWorkItem->AsyncCreate.Context2;
            
            //
            // Does this file exist ? If the ResponseStatus is not
            // ERROR_SUCCESS, then we are sure that the file does not
            // exist. But, if it is we cannot be sure that the file exists.
            //
            ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (ResponseStatus != ERROR_SUCCESS) {
                //
                // If the parent directory does not exist, return error.
                //
                WStatus = ResponseStatus;
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreate/QueryPDirectory/DavQueryAndParseResponse %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }

            do {
                ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                             (LPVOID)DataBuff,
                                             NUM_OF_BYTES_TO_READ,
                                             NumRead);
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    if (WStatus != ERROR_IO_PENDING) {
                        DavCloseContext(Ctx1, Ctx2);
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate/InternetReadFile. Error Val"
                                  " = %d\n", WStatus));
                    }
                    DavPrint((DEBUG_MISC,
                              "DavAsyncCreate/InternetReadFile(1). "
                              "ERROR_IO_PENDING.\n"));
                    goto EXIT_THE_FUNCTION;
                }


                didRead = *NumRead;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate(1): toRead = %d, didRead = %d.\n",
                          NUM_OF_BYTES_TO_READ, didRead));

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate(1): DataBuff = %s\n", DataBuff));

                readDone = (didRead == 0) ? TRUE : FALSE;

                WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavPushData. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (DavWorkItem->AsyncCreate.Context1 == NULL) {
                    DavWorkItem->AsyncCreate.Context1 = Ctx1;
                }

                if (DavWorkItem->AsyncCreate.Context2 == NULL) {
                    DavWorkItem->AsyncCreate.Context2 = Ctx2;
                }
            } while (!readDone);
          
            //
            // We now need to parse the data.
            //

            DavDirectoryAttributes = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,sizeof(DAV_FILE_ATTRIBUTES));

            if (DavDirectoryAttributes == NULL) {
                DavCloseContext(Ctx1, Ctx2);
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            InitializeListHead( &(DavDirectoryAttributes->NextEntry) );
            
            WStatus = DavParseData(DavDirectoryAttributes, Ctx1, Ctx2, &NumOfFileEntries);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/DavParseData. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            if ((CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ||
                (DavDirectoryAttributes->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: ParentDirectory Is Encrypted\n"));
            } else {
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: ParentDirectory Is Not Encrypted\n"));
            }

            DavFinalizeFileAttributesList(DavDirectoryAttributes, TRUE);
            DavDirectoryAttributes = NULL;
            
            DavCloseContext(Ctx1, Ctx2);
            DavWorkItem->AsyncCreate.Context1 = NULL;
            DavWorkItem->AsyncCreate.Context2 = NULL;

            ASSERT(didImpersonate == TRUE);
            
            WStatus = DavAsyncCreateQueryParentDirectory(DavWorkItem);
        
        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateGet) {

            LARGE_INTEGER ByteOffset;
            ULONG BytesToRead;
            BOOL EncryptedFile = FALSE, ZeroByteFile = FALSE;
            FILE_STANDARD_INFORMATION FileStdInfo;
            ULONG ResponseStatus;

            ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (ResponseStatus != ERROR_SUCCESS) {
                WStatus = ResponseStatus;
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreate(AsyncCreateGet)/DavQueryAndParseResponse: WStatus = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // This thread is currently impersonating the client that 
            // made this request. Before we call CreateFile, we need to 
            // revert back to the context of the Web Client service.
            //
            RevertToSelf();
            didImpersonate = FALSE;            

            if (DavReuseCacheFileIfNotModified(DavWorkItem) == ERROR_SUCCESS)
            {
                fCacheFileReused = TRUE;
            }

            if (!fCacheFileReused)
            {
                //
                // Call DavCreateUrlCacheEntry to create an entry in the 
                // WinInet's cache.
                //
            
                WStatus = DavCreateUrlCacheEntry(DavWorkItem);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavCreateUrlCacheEntry %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
                                
            if (DavWorkItem->AsyncCreate.FileHandle == NULL) {

                //
                // Create a handle to the file whose entry was created in the
                // cache.
                //
                FileHandle = CreateFileW(DavWorkItem->AsyncCreate.FileName,
                                         (GENERIC_READ | GENERIC_WRITE),
                                         FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL);
                
                if (FileHandle == INVALID_HANDLE_VALUE) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/CreateFile. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                DavWorkItem->AsyncCreate.FileHandle = FileHandle;
            
                //
                // Impersonate back again, so that we are in the context of
                // the user who issued this request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/UMReflectorImpersonate. "
                          "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;

            }

            FileHandle = DavWorkItem->AsyncCreate.FileHandle;
            DataBuff = DavWorkItem->AsyncCreate.DataBuff;
            NumRead = DavWorkItem->AsyncCreate.didRead;
            
            if (!fCacheFileReused)
            {
                do {
        
                    switch (DavWorkItem->DavMinorOperation) {

                    case DavMinorReadData:
                    
                        DavWorkItem->DavMinorOperation = DavMinorWriteData;

                        ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                                     (LPVOID)DataBuff,
                                                     NUM_OF_BYTES_TO_READ,
                                                     NumRead);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            if (WStatus != ERROR_IO_PENDING) {
                                DavPrint((DEBUG_ERRORS,
                                          "DavAsyncCreate/InternetReadFile. Error Val"
                                          " = %08lx.\n", WStatus));
                            }
                            DavPrint((DEBUG_MISC,
                                      "DavAsyncCreate/InternetReadFile(2). "
                                      "ERROR_IO_PENDING.\n"));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // Lack of break is intentional.
                        //

                    case DavMinorWriteData:

                        DavWorkItem->DavMinorOperation = DavMinorReadData;
        
                        didRead = *NumRead;

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(2): toRead = %d, didRead = %d.\n",
                                  NUM_OF_BYTES_TO_READ, didRead));

                        readDone = (didRead == 0) ? TRUE : FALSE;

                        if (readDone) {
                            break;
                        }

                        //
                        // This thread is currently impersonating the client that 
                        // made this request. Before we call WriteFile, we need to 
                        // revert back to the context of the Web Client service.
                        //
                        RevertToSelf();
                        didImpersonate = FALSE;
                    
                        //
                        // Write the buffer to the file which has been cached on
                        // persistent storage.
                        //
                        ReturnVal = WriteFile(FileHandle, DataBuff, didRead, &didWrite, NULL);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/WriteFile. Error Val = %d\n", WStatus));
                            goto EXIT_THE_FUNCTION;
                        }

                        ASSERT(didRead == didWrite);

                        //
                        // Impersonate back again, so that we are in the context of
                        // the user who issued this request.
                        //
                        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                        if (WStatus != ERROR_SUCCESS) {
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/UMReflectorImpersonate. "
                                      "Error Val = %d\n", WStatus));
                            goto EXIT_THE_FUNCTION;
                        }
                        didImpersonate = TRUE;
                    
                        break;
        
                    default:

                        WStatus = ERROR_INVALID_PARAMETER;

                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate. Invalid DavMinorOperation = %d.\n",
                                  DavWorkItem->DavMinorOperation));

                        goto EXIT_THE_FUNCTION;

                        break;

                    }

                    if (readDone) {
                        break;
                    }

                } while ( TRUE );
            }

            //
            // At this point, we have read the entire file.
            // We need to figure out if this is an encrypted file.
            // If it is, we need to RESTORE it, since it was stored as a
            // Backup stream on the server. We read the first 100 bytes of the
            // file to check for the EFS signature.
            //

            //
            // This thread could be currently impersonating the client that made 
            // this request. Before we call ReadFile, we need to revert back to 
            // the context of the Web Client service.
            //
            if (didImpersonate) {
                RevertToSelf();
                didImpersonate = FALSE;
            }

            //
            // Set the last access time on the Url cache so that we can avoid GET later
            //
            if (!fCacheFileReused) {
                // commit to the cache only if it is not being reused            
                WStatus = DavCommitUrlCacheEntry(DavWorkItem);
                
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavCommitUrlCacheEntry(2). "
                              "WStatus = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    //
                    // set the ACLs so that the cache can be accessed after impersonating the user
                    //
                    WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
                    if (WStatus != ERROR_SUCCESS) {
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate/DavSetAclForEncryptedFile. Error Val"
                                  " = %d %ws\n", WStatus,DavWorkItem->AsyncCreate.FileName));
                        goto EXIT_THE_FUNCTION;
                    }
                }
            }
            
            WStatus = DavQueryUrlCacheEntry(DavWorkItem);

            if (WStatus == ERROR_SUCCESS) {
                SYSTEMTIME SystemTime;

                GetSystemTime(&SystemTime);

                SystemTimeToFileTime(
                    &SystemTime,
                    &((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime);
                
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate/SetUrlCacheEntryInfo %u %ws\n",
                         ((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime.dwLowDateTime, 
                         DavWorkItem->AsyncCreate.UrlBuffer));

                SetUrlCacheEntryInfo(
                    DavWorkItem->AsyncCreate.UrlBuffer, 
                    (LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI, 
                    CACHE_ENTRY_ACCTIME_FC);
            }
            
            WStatus = DavAsyncCreateGet(DavWorkItem);

        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateMkCol) {

            WStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }

            WStatus = ERROR_SUCCESS;

        } else {

            ASSERT(DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePut);

            WStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }

            //
            // The CreateResponse structure has already been set. All we need to
            // do now is return.
            //
            WStatus = ERROR_SUCCESS;

        }

    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreate: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;

    } // End of switch.

EXIT_THE_FUNCTION:

    //
    // Free the pEncryptedCachedFile since we have allocated a new file name
    // for the restored encrypted file.
    //
    if (pEncryptedCachedFile) {
        LocalFree(pEncryptedCachedFile);
    }

    if (DavDirectoryAttributes) {
        DavFinalizeFileAttributesList(DavDirectoryAttributes, TRUE);
        DavDirectoryAttributes = NULL;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorRevert. Error Val = %d\n",
                      RStatus));
        }
    }

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {

        DavPrint((DEBUG_MISC, "DavAsyncCreate: Leaving!!! WStatus = %08lx\n", WStatus));

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the AsyncCreateCompletion routine.
        //
        DavAsyncCreateCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    }

    if (WStatus == ERROR_IO_PENDING ) {
        DavPrint((DEBUG_MISC, "DavAsyncCreate: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, we need to impersonate the client
    // if we somehow reverted in between and failed. This is because we came
    // into this function impersonating a client and the final revert happens
    // in DavFsCreate.
    //
    if ( !didImpersonate ) {
        ULONG IStatus;
        IStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (IStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorImpersonate. "
                      "Error Val = %d\n", IStatus));
        }
    }

#endif

    return WStatus;
}

DWORD
DavAsyncCreatePropFind(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = TRUE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR ParentDirectoryName = NULL;
    BOOL BStatus = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;
    
    doesTheFileExist = DavWorkItem->AsyncCreate.doesTheFileExist;

    DavPrint((DEBUG_MISC,
              "DavAsyncCreatePropFind: DesiredAccess = %x, FileAttributes = %x,"
              "ShareAccess = %x, CreateDisposition = %x, CreateOptions = %x,"
              "FileName = %ws\n",
              CreateRequest->DesiredAccess, CreateRequest->FileAttributes,
              CreateRequest->ShareAccess, CreateRequest->CreateDisposition,
              CreateRequest->CreateOptions, CreateRequest->CompletePathName));

    //
    // We don't support compression of files or directories over the 
    // DAV Redir since there is no way to do this with the current status
    // of the protocol (Jan 2001) and hence we filter this flag so that
    // we never set any attributes. Also, for this version ,we are 
    // emulating FAT which doesn't support compression. Similarly we don't
    // support the Offline scenario.
    //
    CreateRequest->FileAttributes &= ~(FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE);

    //
    // If this file is a new file (not a directory), then according to 
    // functionality expected from CreateFile, FILE_ATTRIBUTE_ARCHIVE 
    // should be combined with specified value of attributes.
    //
    if ( (doesTheFileExist == FALSE) && 
         !(CreateRequest->CreateOptions & (FILE_DIRECTORY_FILE)) ) {
            CreateRequest->FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
    }

    //
    // If the file exists, we need to make sure that a few things are
    // right before proceeding further.
    //
    if (doesTheFileExist) {
        //
        // If the dwFileAttributes had the READ_ONLY bit set, then
        // these cannot be TRUE.
        // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
        //    FILE_OVERWRITE or FILE_SUPERSEDE. 
        // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
        // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
        //    FILE_WRITE_DATA or FILE_APPEND_DATA.
        // This is because these intend to overwrite the existing file.
        //
        if ( (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) &&
             ( (CreateRequest->CreateDisposition == FILE_OVERWRITE)          ||
               (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF)       ||
               (CreateRequest->CreateDisposition == FILE_SUPERSEDE)          ||
               (CreateRequest->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
               (CreateRequest->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateDisposition = "
                      "%d, DesiredAccess = %x, dwFileAttributes = %x\n",
                      CreateRequest->CreateDisposition, 
                      CreateRequest->DesiredAccess, 
                      CreateResponse->BasicInformation.FileAttributes));
            WStatus = ERROR_ACCESS_DENIED; // mismatch
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the file is a directory and the caller supplied 
        // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
        // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
        // then we return error. There is no good WIN32 errors for these situations.
        // ERROR_ACCESS_DENIED will cause confusion for EFS.
        //
        if ((CreateRequest->CreateOptions & FILE_DIRECTORY_FILE) && 
            !CreateResponse->StandardInformation.Directory) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateOptions = "
                      "%x, CreateResponse = %x\n",
                      CreateRequest->CreateOptions, CreateResponse->BasicInformation.FileAttributes));
            WStatus = STATUS_NOT_A_DIRECTORY; // mismatch
            goto EXIT_THE_FUNCTION;
        }

        if ((CreateRequest->CreateOptions & FILE_NON_DIRECTORY_FILE) && 
            CreateResponse->StandardInformation.Directory) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateOptions = "
                      "%x, CreateResponse = %x\n",
                      CreateRequest->CreateOptions, CreateResponse->BasicInformation.FileAttributes));
            WStatus = STATUS_FILE_IS_A_DIRECTORY; // mismatch
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // If the file exists, we need to set the information field if the 
    // CreateDisposition is one of the following. This is because the
    // CreateFile API expects these values to be set on return.
    //
    if (doesTheFileExist) {
        switch (CreateRequest->CreateDisposition) {
        case FILE_OVERWRITE:
        case FILE_OVERWRITE_IF:
            DavWorkItem->Information = FILE_OVERWRITTEN;
            break;

        case FILE_SUPERSEDE:
            DavWorkItem->Information = FILE_SUPERSEDED;
            break;

        default:
            DavWorkItem->Information = FILE_OPENED;
        }
    } else {
        DavWorkItem->Information = FILE_CREATED;
    }
    
    //
    // If the file does not exist on the server, create one locally.
    // Once its closed, we will PUT it on the server. If the file
    // exists on the server, and the CreateDisposition is equal to
    // FILE_OVERWRITE_IF, we create a copy locally and PUT it on the
    // server (overwrite) on close.
    //
    if ( ( !doesTheFileExist ) ||
         ( doesTheFileExist && CreateRequest->CreateDisposition == FILE_OVERWRITE_IF ) ) {
        DWORD  NameLength = 0, i;
        BOOL   BackSlashFound = FALSE;

        DavPrint((DEBUG_MISC, "DavAsyncCreatePropFind: doesTheFileExist = "
                  "%d, CreateDisposition = %d\n",
                  doesTheFileExist, CreateRequest->CreateDisposition));
        
        DavPrint((DEBUG_MISC, "DavAsyncCreatePropFind: CreateOptions = %d\n", 
                  CreateRequest->CreateOptions));

        //
        // We need to check the CreateDisposition value to figure
        // out what to do next.
        //
        switch (CreateRequest->CreateDisposition) {

        //
        // If FILE_OPEN was specified, we need to return failure
        // since the specified file does not exist.
        //
        case FILE_OPEN:

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind. CreateDisposition & FILE_OPEN\n"));

            goto EXIT_THE_FUNCTION;

        //
        // If FILE_OVERWRITE was specified, we need to return failure
        // since the specified file does not exist.
        //
        case FILE_OVERWRITE:

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;                    

            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind. CreateDisposition & FILE_OVERWRITE\n"));

            goto EXIT_THE_FUNCTION;

        default:

            break;

        }

        if (CreateRequest->ParentDirInfomationCached ||
            (CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            
            //
            // We already know whether to encrypt the file, don't need to query the parent directory
            //

            if (CreateRequest->ParentDirIsEncrypted ||
                (CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            }
            
            BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                          L"PROPFIND",
                                          L"",
                                          L"HTTP/1.1",
                                          NULL,
                                          NULL,
                                          INTERNET_FLAG_KEEP_CONNECTION |
                                          INTERNET_FLAG_NO_COOKIES,
                                          CallBackContext,
                                          L"DavAsyncCreatePropFind",
                                          &(DavWorkItem->AsyncCreate.DavOpenHandle));

            if(BStatus == FALSE) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreatePropFind/DavHttpOpenRequestW failed %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            ASSERT(didImpersonate == TRUE);
            WStatus = DavAsyncCreateQueryParentDirectory(DavWorkItem);
        } else {
            //
            // We need to query the attributes of the parent directory of this new file 
            // on the server. If it is encrypted, the new file needs to be encrypted as well.
            //
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Query Parent Directory for %ws\n",DavWorkItem->AsyncCreate.RemPathName));

            NameLength = wcslen(DavWorkItem->AsyncCreate.RemPathName);

            for (i=NameLength;i>0;i--) {
                if (DavWorkItem->AsyncCreate.RemPathName[i] == L'/') {
                    BackSlashFound = TRUE;
                    break;
                }
            }

            if (!BackSlashFound) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind: Invalid file path %ws\n",DavWorkItem->AsyncCreate.RemPathName));
                WStatus = ERROR_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }

            ParentDirectoryName = (PWCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (i+1)*sizeof(WCHAR));

            if (ParentDirectoryName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlCopyMemory(ParentDirectoryName,
                          DavWorkItem->AsyncCreate.RemPathName,
                          i*sizeof(WCHAR));

            DavPrint((DEBUG_MISC,
                     "DavAsyncCreatePropFind/ParentDirectoryName %ws\n",ParentDirectoryName));

            //
            // Set the DavOperation and AsyncCreateState values.For PUT 
            // the DavMinorOperation value is irrelavant.
            //
            DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
            DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateQueryParentDirectory;
            DavWorkItem->DavMinorOperation = DavMinorQueryInfo;

            //
            // Convert the unicode object name to UTF-8 URL format.
            // Space and other white characters will remain untouched. 
            // These should be taken care of by wininet calls.
            //
            BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                          L"PROPFIND",
                                          ParentDirectoryName,
                                          L"HTTP/1.1",
                                          NULL,
                                          NULL,
                                          INTERNET_FLAG_KEEP_CONNECTION |
                                          INTERNET_FLAG_NO_COOKIES,
                                          CallBackContext,
                                          L"DavAsyncCreate",
                                          &(DavWorkItem->AsyncCreate.DavOpenHandle));

            if(BStatus == FALSE) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreatePropFind/DavHttpOpenRequestW failed %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }

            if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
                WStatus = GetLastError();
                if (WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreatePropFind/HttpOpenRequestW"
                              ". Error Val = %d\n", WStatus));
                }
                goto EXIT_THE_FUNCTION;
            }

            WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind/DavAsyncCommonStates(PUT). "
                          "Error Val = %08lx\n", WStatus));
            }
        }

        goto EXIT_THE_FUNCTION;

    } else {

        //
        // The file exists on the server and the value of
        // CreateDisposition != FILE_OVERWRITE_IF.
        //

        //
        // We return failure if FILE_CREATE was specified since the
        // file already exists.
        //
        if (CreateRequest->CreateDisposition == FILE_CREATE) {

            WStatus = ERROR_ALREADY_EXISTS; // STATUS_OBJECT_NAME_COLLISION

            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate. CreateDisposition & FILE_CREATE\n"));

            goto EXIT_THE_FUNCTION;

        }
    }

    //
    // If "FILE_DELETE_ON_CLOSE" flag was specified as one of
    // the CreateOptions, then we need to remember this and
    // delete this file on close.
    //
    if (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE) {
        DavPrint((DEBUG_MISC,
                  "DavAsyncCreatePropFind: FileName: %ws. FILE_DELETE_ON_CLOSE.\n",
                  DavWorkItem->AsyncCreate.RemPathName));
        CreateResponse->DeleteOnClose = TRUE;
    }

    //
    // In some cases, we don't need to do a GET.
    //
    if (CreateResponse->StandardInformation.Directory) {

        //
        // We do not need to GET a directory.
        //
        goto EXIT_THE_FUNCTION;
    
    } else if (!(CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
               (CreateRequest->DesiredAccess & 
                ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES)) == 0 ) {

        //
        // If we don't need to GET the file from the server because the
        // user doesn't intend to manipulate the data, we return right
        // now. We call such an open a Pseudo open.Set the fPsuedoOpen 
        // field to TRUE in the CreateResponse.
        //
        CreateResponse->fPsuedoOpen = TRUE;
                    
        goto EXIT_THE_FUNCTION;
    } else {
        if (didImpersonate) {
            RevertToSelf();
            didImpersonate = FALSE;
        }

        DavQueryUrlCacheEntry(DavWorkItem);

        if (DavWorkItem->AsyncCreate.lpCEI) {
            SYSTEMTIME SystemTime;
            FILETIME CurrentFileTime;
            FILETIME LastAccessTime;
            LARGE_INTEGER Difference;
            LPINTERNET_CACHE_ENTRY_INFOW lpCEI = (LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI;

            LastAccessTime = ((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime;

            GetSystemTime(&SystemTime);
            SystemTimeToFileTime(&SystemTime,&CurrentFileTime);

            Difference.QuadPart = *((LONGLONG *)(&CurrentFileTime)) - *((LONGLONG *)(&LastAccessTime));

            //
            // If the local cache has not timed out, we don't need to query the server
            //
            if (Difference.QuadPart < FileCacheExpiryInterval) {
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreatePropFind/Skip GET %u %u %u %ws\n",
                         CurrentFileTime.dwLowDateTime,
                         LastAccessTime.dwLowDateTime,
                         Difference.LowPart,
                         DavWorkItem->AsyncCreate.UrlBuffer));
                
                ASSERT(DavWorkItem->AsyncCreate.FileName == NULL);
                DavWorkItem->AsyncCreate.FileName = LocalAlloc(LPTR, (lstrlen(lpCEI->lpszLocalFileName)+1)*sizeof(WCHAR));

                if (DavWorkItem->AsyncCreate.FileName) {
                    wcscpy(DavWorkItem->CreateResponse.FileName, lpCEI->lpszLocalFileName);
                    wcscpy(DavWorkItem->AsyncCreate.FileName, lpCEI->lpszLocalFileName);

                    ASSERT(DavWorkItem->AsyncCreate.FileHandle == NULL);
                    
                    //
                    // Create a handle to the file whose entry was created in the
                    // cache.
                    //
                    DavWorkItem->AsyncCreate.FileHandle = CreateFileW(DavWorkItem->AsyncCreate.FileName,
                                             (GENERIC_READ | GENERIC_WRITE),
                                             FILE_SHARE_WRITE,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL);
                    if (DavWorkItem->AsyncCreate.FileHandle == INVALID_HANDLE_VALUE) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreatePropFind/CreateFile. Error Val = %d\n",
                                  WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                    
                    WStatus = DavAsyncCreateGet(DavWorkItem);
                    
                    didImpersonate = TRUE;
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreatePropFind/CreateFile. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
        }

        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/UMReflectorImpersonate. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
    }

    //
    // PROPFIND is done. Now we need to do a GET.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateGet;
    DavWorkItem->DavMinorOperation = DavMinorReadData;

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these
    // should be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                  L"GET",
                                  DavWorkItem->AsyncCreate.RemPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_RELOAD |
                                  INTERNET_FLAG_NO_CACHE_WRITE |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavAsyncCreate",
                                  &(DavWorkItem->AsyncCreate.DavOpenHandle));
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }

    if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/HttpOpenRequest. Error Val = %d\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(didImpersonate);
    RevertToSelf();
    didImpersonate = FALSE;

    // try to add if-modified-since header. don't sweat it if we fail            
    DavAddIfModifiedSinceHeader(DavWorkItem);
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreate/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;
    
    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreatePropFind/DavAsyncCommonStates. "
                  "Error Val(GET) = %08lx\n", WStatus));
    }

EXIT_THE_FUNCTION:
            
    if (ParentDirectoryName) {
        LocalFree(ParentDirectoryName);
    }

    //
    // Impersonate back again, so that we are in the context of
    // the user who issued this request.
    //
    if (!didImpersonate) {
        ULONG LocalStatus;

        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));
            
            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
    }

    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_FILE_NOT_FOUND) {
        DavPrint((DEBUG_ERRORS,"DavAsyncCreatePropFind return %x\n", WStatus));
    }

    return WStatus;
}

DWORD
DavAsyncCreateQueryParentDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = TRUE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    UNICODE_STRING UnicodeFileName;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    ACCESS_MASK DesiredAccess = 0;
    BOOL BStatus = FALSE, ShouldEncrypt = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    
    if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        ShouldEncrypt = TRUE;
    }

    //
    // If this is a create of a new directory, then we need to
    // send a MKCOL to the server to create this new directory.
    // If this is a create of a file, then the create
    // options will have FILE_DIRECTORY_FILE set.
    //

    if ( !(CreateRequest->CreateOptions & FILE_DIRECTORY_FILE) ) {

        //
        // This Create is for a file.
        // This thread is currently impersonating the client that 
        // made this request. Before we call DavDavCreateUrlCacheEntry,
        // we need to revert back to the context of the Web Client
        // service.
        //
        RevertToSelf();
        didImpersonate = FALSE;

        //
        // Call DavCreateUrlCacheEntry to create an entry in the 
        // WinInet's cache.
        //
        WStatus = DavCreateUrlCacheEntry(DavWorkItem);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/DavCreateUrlCacheEntry(1). "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Call DavCommitUrlCacheEntry to commit (pin) the entry 
        // created above in the WinInet's cache.
        //
        WStatus = DavCommitUrlCacheEntry(DavWorkItem);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/DavCommitUrlCacheEntry(1). "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (ShouldEncrypt) {
            //
            // if the file will be encrypted, we set the ACL to allow everyone to access. This
            // is because the thread needs to be impersonated to do encrypt the file in the user's
            // context. The URL cache in created in the Local System's context which won't be
            // accessiable to the user if the ACL is not set.
            //
            WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
            
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/DavSetAclForEncryptedFile(1). Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // Impersonate back again, so that we are in the context of
        // the user who issued this request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/UMReflectorImpersonate. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // This file exists on the server, but this create operation
        // has FILE_OVERWRITE_IF as its CreateDisposition. So, we
        // can create this file locally overwrite the one on the
        // server on close.
        //
        if (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: FileName: %ws. ExistsAndOverWriteIf = TRUE\n",
                      DavWorkItem->AsyncCreate.FileName));
            ASSERT(CreateRequest->CreateDisposition == FILE_OVERWRITE_IF);
            CreateResponse->ExistsAndOverWriteIf = TRUE;
        }

        //
        // If "FILE_DELETE_ON_CLOSE" flag was specified as one of
        // the CreateOptions, then we need to remember this and
        // delete this file on close.
        //
        if (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: FileName: %ws. DeleteOnClose = TRUE\n",
                      DavWorkItem->AsyncCreate.FileName));
            CreateResponse->DeleteOnClose = TRUE;
        }

        //
        // Create the file handle to be returned back to the kernel.
        //

        QualityOfService.Length = sizeof(QualityOfService);
        QualityOfService.ImpersonationLevel = CreateRequest->ImpersonationLevel;
        QualityOfService.ContextTrackingMode = FALSE;
        QualityOfService.EffectiveOnly = (BOOLEAN)
        (CreateRequest->SecurityFlags & DAV_SECURITY_EFFECTIVE_ONLY);

        //
        // Create an NT path name for the cached file. This is used in the
        // NtCreateFile call below.
        //
        ReturnVal = RtlDosPathNameToNtPathName_U(DavWorkItem->AsyncCreate.FileName,
                                                 &UnicodeFileName,
                                                 NULL,
                                                 NULL);
        if (!ReturnVal) {
            WStatus = ERROR_BAD_PATHNAME;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/RtlDosPathNameToNtPathName. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   0,
                                   NULL);

        if (CreateRequest->SecurityDescriptor != NULL) {
            ObjectAttributes.SecurityDescriptor = CreateRequest->SecurityDescriptor;
        }
        ObjectAttributes.SecurityQualityOfService = &QualityOfService;

        //
        // If CreateRequest->CreateDisposition == FILE_CREATE, then
        // the NtCreateFile operation below will fail because we
        // have already created the file with the CreateUrlCacheEntry
        // call. So we change the value to FILE_OPEN_IF.
        //
        if (CreateRequest->CreateDisposition == FILE_CREATE) {
            CreateRequest->CreateDisposition = FILE_OPEN_IF;
        }

        if (ShouldEncrypt) {
            //
            // The file is encrypted in the user's context
            //
            BStatus = EncryptFile(DavWorkItem->AsyncCreate.FileName);
            
            if (BStatus) {
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate: Local cache is encrypted %wZ\n",
                          &UnicodeFileName));
                CreateResponse->LocalFileIsEncrypted = TRUE;
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/EncryptFile. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }
        } else {
            DavPrint((DEBUG_MISC,
                     "DavAsyncCreate: Local cache is not encrypted %wZ\n",
                      &UnicodeFileName));
            //
            // This thread is currently impersonating the client that 
            // made this request. Before we call NtCreateFile, we need 
            // to revert back to the context of the Web Client service.
            //
            RevertToSelf();
            didImpersonate = FALSE;
        }
        
        //
        // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
        // checks this for us. Moreover, we delay the close after the final 
        // close happens and this could cause problems. Consider the scenario.
        // 1. Open with NO share access.
        // 2. We create a local handle with this share access.
        // 3. The app closes the handle. We delay the close and keep the local
        //    handle.
        // 4. Another open comes with any share access. This will be 
        //    conflicting share access since the first one was done with no
        //    share access. This should succeed since the previous open has 
        //    been closed from the app and the I/O systems point of view.
        // 5. It will not if we have created the local handle with the share
        //    access which came with the first open.
        // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
        // the local handle.
        //

        //
        // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
        // the user specified, becuase we don't want the underlying file system
        // to create another cache map. This way all the I/O that comes to us
        // will directly go to the disk. BUG 128843 in the Windows RAID database
        // explains some deadlock scenarios that could happen with PagingIo if
        // we don't do this. Also since we supply the FILE_NO_INTERMEDIATE_BUFFERING
        // option we filter out the FILE_APPEND_DATA from the DesiredAccess flags
        // since the filesystem expects this.
        //
         
        //
        // We also always create the file with DesiredAccess ORed with FILE_WRITE_DATA
        // if either FILE_READ_DATA or FILE_EXECUTE was specified because there
        // can be situations where we get write IRPs on a FILE_OBJECT which was
        // not opened with Write Access and was only opened with FILE_READ_DATA
        // or FILE_EXECUTE. This is BUG 284557. To get around the problem, we do
        // this.
        //

        //
        // We filter the FILE_ATTRIBUTE_READONLY attribute during the create.
        // This is done because we store the READ_ONLY bit in the FCB and do
        // the checks at the RDBSS level before going to the local filesystem.
        // Also, since some of our creates open the file with FILE_WRITE_DATA,
        // if someone creates a read_only file and we stamp the read_only
        // attribute on the local file then all subsequent creates will fail
        // since we always ask for Write access to the underlying file as
        // explained above.
        //

        DesiredAccess = (CreateRequest->DesiredAccess & ~(FILE_APPEND_DATA));
        if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
            DesiredAccess |= (FILE_WRITE_DATA);
        }

        NtStatus = NtCreateFile(&(FileHandle),
                                DesiredAccess,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                &CreateRequest->AllocationSize,
                                (CreateRequest->FileAttributes & ~FILE_ATTRIBUTE_READONLY),
                                FILE_SHARE_VALID_FLAGS,
                                CreateRequest->CreateDisposition,
                                (CreateRequest->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                                CreateRequest->EaBuffer,
                                CreateRequest->EaLength);

        if (NtStatus != STATUS_SUCCESS) {
            //
            // We convert the NtStatus to DOS error here. The Win32
            // error code is finally set to an NTSTATUS value in
            // the DavFsCreate function just before returning.
            //
            WStatus = RtlNtStatusToDosError(NtStatus);
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/NtCreateFile(1). Error Val = "
                      "%08lx\n", NtStatus));
            CreateResponse->Handle = NULL;
            CreateResponse->UserModeKey = NULL;
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: DavWorkItem = %08lx.\n",
                  DavWorkItem));

        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: FileHandle = %08lx.\n",
                  FileHandle));

        CreateResponse->Handle = FileHandle;
        CreateResponse->UserModeKey = (PVOID)FileHandle;

        //
        // If the file already exists on the server, then we don't
        // need to create it and are done.
        //
        if (DavWorkItem->AsyncCreate.doesTheFileExist) {
            
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: doesTheFileExist == TRUE\n"));
            
            WStatus = ERROR_SUCCESS;
            
            goto EXIT_THE_FUNCTION;
        
        } else {
            
            SYSTEMTIME CurrentSystemTime, NewSystemTime;
            FILETIME CurrentFileTime;
            BOOL ConvertTime = FALSE;
            LARGE_INTEGER CurrentTime;
            WCHAR chTimeBuff[INTERNET_RFC1123_BUFSIZE + 4];

            //
            // This file may have been created locally and does not exist
            // on the server. We need to remember this information and
            // set attributes on this file on the server on close.
            //
            if (CreateRequest->FileAttributes != 0) {
                CreateResponse->NewFileCreatedAndSetAttributes = TRUE;
                //
                // Copy the attributes in the CreateResponse. These 
                // will get PROPPATCHED to the server on Close.
                //
                CreateResponse->BasicInformation.FileAttributes = CreateRequest->FileAttributes;
                
                if (ShouldEncrypt) {
                    CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            DavPrint((DEBUG_MISC,
                     "DavAsyncCreate/QueryPDirectory NewFileCreatedAndSetAttributes %x %x %ws\n",
                      CreateRequest->FileAttributes,
                      CreateResponse->BasicInformation.FileAttributes,
                      DavWorkItem->AsyncCreate.FileName));

            //
            // We also need to set the FILE_BASIC_INFORMATION time values to 
            // the current time. We get the systemtime, convert it into the 
            // RFC1123 format and then convert the format back into systemtime.
            // We do this because on close when we PROPPATCH these times we send
            // them in the RFC1123 format. Since the least count of this format is
            // seconds, some data is lost when we convert the LARGE_INTEGER to
            // RFC1123 format and back. So, we lose this data right now to be 
            // consistent. To give an example about the loss, see below.
            // CreationTime.LowPart = 802029d0, CreationTime.HighPart = 1c0def1
            // maps to "Thu, 17 May 2001 16:50:38 GMT"
            // And "Thu, 17 May 2001 16:50:38 GMT" is what we get back when we do a
            // PROPFIND which converts back into
            // CreationTime.LowPart = 7fdc4300, CreationTime.HighPart = 1c0def1
            // Note that the LowPart is different. So, the values in the name cache
            // and the server will be different. To avoid this inconsistency we lose
            // this data by doing the conversion right away.
            //

            GetSystemTime( &(CurrentSystemTime) );

            RtlZeroMemory(chTimeBuff, sizeof(chTimeBuff));

            ConvertTime = InternetTimeFromSystemTimeW(&(CurrentSystemTime),
                                                      INTERNET_RFC1123_FORMAT,
                                                      chTimeBuff,
                                                      sizeof(chTimeBuff));
            if (ConvertTime) {
                ConvertTime = InternetTimeToSystemTimeW(chTimeBuff, &(NewSystemTime), 0);
                if (ConvertTime) {
                    ConvertTime = SystemTimeToFileTime( &(NewSystemTime), &(CurrentFileTime) );
                    if (ConvertTime) {
                        CreateResponse->PropPatchTheTimeValues = TRUE;
                        CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                        CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                        CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                    }
                }
            }

            //
            // If the above conversion from systemtime to RFC1123 format and then
            // back to systemtime from RFc1123 format failed then we go ahead and
            // convert the systemtime to filetime and use that.
            //

            if (!ConvertTime) {
                ConvertTime = SystemTimeToFileTime( &(CurrentSystemTime), &(CurrentFileTime) );
                if (ConvertTime) {
                    CreateResponse->PropPatchTheTimeValues = TRUE;
                    CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                    CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                    CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                } else {
                    //
                    // This is not a fatal error. We can still continie with the
                    // Create call.
                    //
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateQueryParentDirectory/SystemTimeToFileTime(1): %x\n",
                              GetLastError()));
                }
            }
        
        }

        //
        // We are done with the Open handle to PROPFIND. 
        // Now we need to create the directory on the server.
        //
        if (DavWorkItem->AsyncCreate.DavOpenHandle) {
            InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
            DavWorkItem->AsyncCreate.DavOpenHandle = NULL;
        }

        //
        // We need to "PUT" this new file on the server.
        //
        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: PUT New File\n"));

        //
        // Set the DavOperation and AsyncCreateState values.For PUT 
        // the DavMinorOperation value is irrelavant.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePut;

        //
        // Convert the unicode object name to UTF-8 URL format.
        // Space and other white characters will remain untouched. 
        // These should be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                      L"PUT",
                                      DavWorkItem->AsyncCreate.RemPathName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"QueryPDirectory",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle));

        if(BStatus == FALSE) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,"DavAsyncCreate/QueryPDirectory/DavHttpOpenRequestW error: %x\n",WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/HttpOpenRequestW"
                          ". Error Val = %d\n", WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/DavAsyncCommonStates(PUT). "
                      "Error Val = %08lx\n", WStatus));
        }

        goto EXIT_THE_FUNCTION;

    } else {

        SYSTEMTIME CurrentSystemTime, NewSystemTime;
        FILETIME CurrentFileTime;
        BOOL ConvertTime = FALSE;
        LARGE_INTEGER CurrentTime;
        WCHAR chTimeBuff[INTERNET_RFC1123_BUFSIZE + 4];

        //
        // We are done with the Open handle to PROPFIND. 
        // Now we need to create the directory on the server.
        //
        InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
        DavWorkItem->AsyncCreate.DavOpenHandle = NULL;

        //
        // This Create is for a Directory. We need to send an
        // MKCOL to the server.
        //
        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: Create Directory\n"));

        //
        // Set the DavOperation and AsyncCreateState values.
        // For MKCOL the DavMinorOperation value is irrelavant.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateMkCol;

        //
        // The data is parsed. We now need to set the file attributes in the
        // response buffer.
        //
        CreateResponse->BasicInformation.FileAttributes = CreateRequest->FileAttributes;
        CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        CreateResponse->StandardInformation.Directory = TRUE;

        //
        // Since we are creating a new directory we need to PROPPATCH the 
        // attributes on the directory that is getting created below on close.
        //
        CreateResponse->NewFileCreatedAndSetAttributes = TRUE;

        if (ShouldEncrypt) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate: New directory is encrypted\n"));
            CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
        }
        
        //
        // We also need to set the FILE_BASIC_INFORMATION time values to 
        // the current time. We get the systemtime, convert it into the 
        // RFC1123 format and then convert the format back into systemtime.
        // We do this because on close when we PROPPATCH these times we send
        // them in the RFC1123 format. Since the least count of this format is
        // seconds, some data is lost when we convert the LARGE_INTEGER to
        // RFC1123 format and back. So, we lose this data right now to be 
        // consistent. To give an example about the loss, see below.
        // CreationTime.LowPart = 802029d0, CreationTime.HighPart = 1c0def1
        // maps to "Thu, 17 May 2001 16:50:38 GMT"
        // And "Thu, 17 May 2001 16:50:38 GMT" is what we get back when we do a
        // PROPFIND which converts back into
        // CreationTime.LowPart = 7fdc4300, CreationTime.HighPart = 1c0def1
        // Note that the LowPart is different. So, the values in the name cache
        // and the server will be different. To avoid this inconsistency we lose
        // this data by doing the conversion right away.
        //

        GetSystemTime( &(CurrentSystemTime) );

        RtlZeroMemory(chTimeBuff, sizeof(chTimeBuff));

        ConvertTime = InternetTimeFromSystemTimeW(&(CurrentSystemTime),
                                                  INTERNET_RFC1123_FORMAT,
                                                  chTimeBuff,
                                                  sizeof(chTimeBuff));
        if (ConvertTime) {
            ConvertTime = InternetTimeToSystemTimeW(chTimeBuff, &(NewSystemTime), 0);
            if (ConvertTime) {
                ConvertTime = SystemTimeToFileTime( &(NewSystemTime), &(CurrentFileTime) );
                if (ConvertTime) {
                    CreateResponse->PropPatchTheTimeValues = TRUE;
                    CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                    CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                    CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                }
            }
        }

        //
        // If the above conversion from systemtime to RFC1123 format and then
        // back to systemtime from RFc1123 format failed then we go ahead and
        // convert the systemtime to filetime and use that.
        //
        
        if (!ConvertTime) {
            ConvertTime = SystemTimeToFileTime( &(CurrentSystemTime), &(CurrentFileTime) );
            if (ConvertTime) {
                CreateResponse->PropPatchTheTimeValues = TRUE;
                CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
            } else {
                //
                // This is not a fatal error. We can still continie with the
                // Create call.
                //
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateQueryParentDirectory/SystemTimeToFileTime(2): %x\n",
                          GetLastError()));
            }
        }
        
        //
        // Convert the unicode object name to UTF-8 URL format.
        // Space and other white characters will remain untouched. 
        // These should be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                      L"MKCOL",
                                      DavWorkItem->AsyncCreate.RemPathName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"QueryPDirectory",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle ));
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }
        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/HttpOpenRequestW"
                          ". Error Val = %d\n", WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/DavAsyncCommonStates(MKCOL). "
                      "Error Val = %08lx\n", WStatus));
        }

        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    if (!didImpersonate) {
        ULONG LocalStatus;
        //
        // Impersonate back again, so that we are in the context of
        // the user who issued this request.
        //
        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));
            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
    }

    return WStatus;
}


DWORD
DavAsyncCreateGet(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    UNICODE_STRING UnicodeFileName;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR pEncryptedCachedFile = NULL;
    ACCESS_MASK DesiredAccess = 0;
    BOOL EncryptedFile = FALSE;
    FILE_STANDARD_INFORMATION FileStdInfo;
            
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;
    
    if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        //
        // This file is encrypted. We need to restore the file. For
        // doing this we need to create another entry in the WinInet
        // cache in which the file will be restored.
        //
        DavPrint((DEBUG_MISC, "DavAsyncCreateGet: This is an Encrypted File.\n"));

        EncryptedFile = TRUE;

        //
        // Save the encrypted file name.
        //
        pEncryptedCachedFile = DavWorkItem->AsyncCreate.FileName;
        
        DavWorkItem->AsyncCreate.FileName = NULL;

        WStatus = DavCreateUrlCacheEntry(DavWorkItem);                
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/CreateUrlCacheEntry. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreateGet: EncryptedCachedFile = %ws\n", pEncryptedCachedFile));

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreateGet: NewFileName = %ws\n", DavWorkItem->AsyncCreate.FileName));

        WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
        
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/DavSetAclForEncryptedFile(3). Error Val"
                      " = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
            //
            // Close the opened file handle since we don't need it anymore. We close the file
            // after setting the ACLs so that the file won't be scavenged by WinInet by any
            // chance.
            //
            ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/CloseHandle. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.FileHandle = NULL;
        }
        
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/UMReflectorImpersonate. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        WStatus = DavRestoreEncryptedFile(pEncryptedCachedFile, DavWorkItem->AsyncCreate.FileName);
        
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/DavRestoreEncryptedFile. Error Val"
                      " = %d %x %x\n", 
                      WStatus,
                      CreateRequest->FileAttributes,
                      CreateResponse->BasicInformation.FileAttributes));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the "new" file name in the response buffer.
        //
        wcscpy(CreateResponse->FileName, DavWorkItem->AsyncCreate.FileName);

        CreateResponse->LocalFileIsEncrypted = TRUE;

        // Don't commit the restored EFS file so that the next open will still
        // see the file in the back up format and the EFS header.
    } else {
        if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
            //
            // Close the opened file handle since we don't need it anymore.
            //
            ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/CloseHandle. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.FileHandle = NULL;
        }

        //
        // If the file already exists, encryption can only be taken place if the create
        // disposition is not FILE_SUPERSEDE, FILE_OVERWRITE or FILE_OVERWRITE_IF
        //
        if ((CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            ((CreateRequest->CreateDisposition == FILE_SUPERSEDE) ||
             (CreateRequest->CreateDisposition == FILE_OVERWRITE) ||
             (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF))) {
            
            WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/DavSetAclForEncryptedFile. Error Val"
                          " = %d %ws\n", WStatus,DavWorkItem->AsyncCreate.FileName));
                goto EXIT_THE_FUNCTION;
            }
            
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/UMReflectorImpersonate. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
            didImpersonate = TRUE;
            
            //
            // The file is encrypted in the user's context
            //
            if (EncryptFile(DavWorkItem->AsyncCreate.FileName)) {
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate: Local cache is encrypted %wZ\n",
                          &UnicodeFileName));
                CreateResponse->LocalFileIsEncrypted = TRUE;
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/EncryptFile. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            CreateRequest->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
            CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            CreateResponse->LocalFileIsEncrypted = TRUE;
        }
    }
    
#ifdef WEBCLIENT_SUPPORTS_BACKUP_RESTORE_FOR_EFS
    //
    // Enable the Backup/Restore privilege on the thread for the encrypted file
    // so that Backup/Restore operation can be done to the file even if the
    // the thread is not impersonated to the owner of the file.
    //
    
    if (EncryptedFile) {
        PTOKEN_PRIVILEGES pPrevPriv = NULL;
        DWORD cbPrevPriv = sizeof(TOKEN_PRIVILEGES);
        BYTE rgbNewPriv[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
        HANDLE hToken = 0;

        for (;;) {
            if (!OpenThreadToken(GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                 FALSE,
                                 &hToken)) {
                DbgPrint("OpenThreadToken failed %d\n", GetLastError());
                break;

                // need to close the hToken at the end.
            }

            // set up the new priviledge state
            memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
            pNewPriv->PrivilegeCount = 1;
            if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                                      &(pNewPriv->Privileges[0].Luid))) {
                DbgPrint("LookupPrivilegeValueW failed \n");
                break;
            }

            pNewPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            pNewPriv->Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

            // alloc for the previous state
            pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,sizeof(TOKEN_PRIVILEGES));

            if (!pPrevPriv) {
                DbgPrint("LocalAlloc for Adjust token failed \n");
                break;
            }

            // adjust the priviledge and get the previous state
            if (!AdjustTokenPrivileges(hToken,
                                       FALSE,
                                       pNewPriv,
                                       cbPrevPriv,
                                       (PTOKEN_PRIVILEGES)pPrevPriv,
                                       &cbPrevPriv)) {
                DbgPrint("AdjustTokenPrivileges failed %d\n", GetLastError());
                break;
            }

            DbgPrint("AdjustTokenPrivileges succeeded\n")
            break;
        }

        if (pPrevPriv) {
            LocalFree(pPrevPriv);
        } 
    } 
#endif

    //
    // Create the file handle to be returned back to the kernel.
    //

    QualityOfService.Length = sizeof(QualityOfService);
    QualityOfService.ImpersonationLevel = CreateRequest->ImpersonationLevel;
    QualityOfService.ContextTrackingMode = FALSE;
    QualityOfService.EffectiveOnly = (BOOLEAN)(CreateRequest->SecurityFlags & DAV_SECURITY_EFFECTIVE_ONLY);

    //
    // Create an NT path name for the cached file. This is used in the
    // NtCreateFile call below.
    //
    ReturnVal = RtlDosPathNameToNtPathName_U(DavWorkItem->AsyncCreate.FileName,
                                             &UnicodeFileName,
                                             NULL,
                                             NULL);
    if (!ReturnVal) {
        WStatus = ERROR_BAD_PATHNAME;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/RtlDosPathNameToNtPathName. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeFileName,
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);

    if (CreateRequest->SecurityDescriptor != NULL) {
        ObjectAttributes.SecurityDescriptor = CreateRequest->SecurityDescriptor;
    }
    
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    //
    // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
    // checks this for us. Moreover, we delay the close after the final 
    // close happens and this could cause problems. Consider the scenario.
    // 1. Open with NO share access.
    // 2. We create a local handle with this share access.
    // 3. The app closes the handle. We delay the close and keep the local
    //    handle.
    // 4. Another open comes with any share access. This will be 
    //    conflicting share access since the first one was done with no
    //    share access. This should succeed since the previous open has 
    //    been closed from the app and the I/O systems point of view.
    // 5. It will not if we have created the local handle with the share
    //    access which came with the first open.
    // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
    // the local handle.
    //

    //
    // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
    // the user specified, becuase we don't want the underlying file system
    // to create another cache map. This way all the I/O that comes to us
    // will directly go to the disk. BUG 128843 in the Windows RAID database
    // explains some deadlock scenarios that could happen with PagingIo if
    // we don't do this. Also since we supply the FILE_NO_INTERMEDIATE_BUFFERING
    // option we filter out the FILE_APPEND_DATA from the DesiredAccess flags
    // since the filesystem expects this.
    //

    //
    // We also always create the file with DesiredAccess ORed with FILE_WRITE_DATA
    // if either FILE_READ_DATA or FILE_EXECUTE was specified because there can
    // be situations where we get write IRPs on a FILE_OBJECT which was not
    // opened with Write Access and was only opened with FILE_READ_DATA or
    // FILE_EXECUTE. This is BUG 284557. To get around the problem, we do this.
    //

    //
    // We filter the FILE_ATTRIBUTE_READONLY attribute during the create.
    // This is done because we store the READ_ONLY bit in the FCB and do
    // the checks at the RDBSS level before going to the local filesystem.
    // Also, since some of our creates open the file with FILE_WRITE_DATA,
    // if someone creates a read_only file and we stamp the read_only
    // attribute on the local file then all subsequent creates will fail
    // since we always ask for Write access to the underlying file as
    // explained above.
    //

    //
    // We add to the DesiredAccess FILE_READ_ATTRIBUTES since we read the
    // attributes of this file since the file size value we got from the server
    // could be different from the GET Content-Length.
    //

    //
    // We need to remove the ACCESS_SYSTEM_SECURITY which will prevent us from
    // opening the file in the LocalService context even if the file is created
    // in LocalService context.
    //

    DesiredAccess = (CreateRequest->DesiredAccess & ~(FILE_APPEND_DATA | ACCESS_SYSTEM_SECURITY));
    DesiredAccess |= (FILE_READ_ATTRIBUTES);
    if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
        DesiredAccess |= (FILE_WRITE_DATA);
    }

    NtStatus = NtCreateFile(&(FileHandle),
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            &CreateRequest->AllocationSize,
                            (CreateRequest->FileAttributes & ~FILE_ATTRIBUTE_READONLY),
                            FILE_SHARE_VALID_FLAGS,
                            CreateRequest->CreateDisposition,
                            (CreateRequest->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                            CreateRequest->EaBuffer,
                            CreateRequest->EaLength);

    if (NtStatus != STATUS_SUCCESS) {
        //
        // We convert the NtStatus to DOS error here. The Win32
        // error code is finally set to an NTSTATUS value in
        // the DavFsCreate function just before returning.
        //
        WStatus = RtlNtStatusToDosError(NtStatus);
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/NtCreateFile(2). Error Val = "
                  "%x %x %x %x %x %x %x %x %ws\n", 
                  NtStatus, 
                  CreateRequest->ImpersonationLevel,
                  CreateRequest->SecurityFlags,
                  CreateRequest->SecurityDescriptor,
                  DesiredAccess,
                  CreateRequest->FileAttributes,
                  CreateRequest->CreateDisposition,
                  CreateRequest->CreateOptions,
                  DavWorkItem->AsyncCreate.FileName));
        CreateResponse->Handle = NULL;
        CreateResponse->UserModeKey = NULL;
        FileHandle = INVALID_HANDLE_VALUE;

        goto EXIT_THE_FUNCTION;
    }

    //
    // We don't impersonate back the client as yet since we might need 
    // to call NtQueryInformationFile next (if the file is encrypted)
    // which requires us to be in the context of the Web Client Service.
    //

    DavPrint((DEBUG_MISC, "DavAsyncCreateGet(2): FileHandle = %08lx\n", FileHandle));

    //
    // We query the StandardInformation of the file to find out if the FileSize
    // returned by PROPFIND is different from the content-length returned by GET.
    //
    NtStatus = NtQueryInformationFile(FileHandle,
                                      &(IoStatusBlock),
                                      &(FileStdInfo),
                                      sizeof(FILE_STANDARD_INFORMATION),
                                      FileStandardInformation);
    if (NtStatus != STATUS_SUCCESS) {
        //
        // We convert the NtStatus to DOS error here. The Win32
        // error code is finally set to an NTSTATUS value in
        // the DavFsCreate function just before returning.
        //
        WStatus = RtlNtStatusToDosError(NtStatus);
        NtClose(FileHandle);
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/NtQueryInformationFile. Error Val "
                  "= %08lx\n", NtStatus));
        CreateResponse->Handle = NULL;
        CreateResponse->UserModeKey = NULL;
        FileHandle = INVALID_HANDLE_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The FileSize returned by PROPFIND is different from the the amount of
    // data that GET returned. Server screwup. We reset the filesize and the
    // allocationsize to match the underlying file.
    //
    if (FileStdInfo.EndOfFile.QuadPart != CreateResponse->StandardInformation.EndOfFile.QuadPart) {
        //
        // Reset the FileSize and AllocationSize info in the response to the
        // FileSize and AllocationSize of the underlying file.
        //
        DavPrint((DEBUG_DEBUG,
                  "DavAsyncCreate: FileSizes Different!! CPN = %ws, "
                  "FileStdInfo.EndOfFile.HighPart = %x, "
                  "FileStdInfo.EndOfFile.LowPart = %x, "
                  "CreateResponse.EndOfFile.HighPart = %x, "
                  "CreateResponse.EndOfFile.LowPart = %x\n",
                  CreateRequest->CompletePathName,
                  FileStdInfo.EndOfFile.HighPart, FileStdInfo.EndOfFile.LowPart,
                  CreateResponse->StandardInformation.EndOfFile.HighPart,
                  CreateResponse->StandardInformation.EndOfFile.LowPart));
        CreateResponse->StandardInformation.EndOfFile.QuadPart = FileStdInfo.EndOfFile.QuadPart;
        CreateResponse->StandardInformation.AllocationSize.QuadPart = FileStdInfo.AllocationSize.QuadPart;
    }

    //
    // If the File was encrypted, we need to reset the file size in the response
    // buffer.
    //
    if (EncryptedFile) {
        //
        // Set the new AllocationSize and EndOfFile values.
        //
        CreateResponse->StandardInformation.AllocationSize.QuadPart = FileStdInfo.AllocationSize.QuadPart;
        CreateResponse->StandardInformation.EndOfFile.QuadPart = FileStdInfo.EndOfFile.QuadPart;
    }

    CreateResponse->Handle = FileHandle;
    CreateResponse->UserModeKey = (PVOID)FileHandle;

EXIT_THE_FUNCTION:

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    //
    // Impersonate back again, so that we are in the context of
    // the user who issued this request.
    //
    if (!didImpersonate) {
        ULONG LocalStatus;

        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));

            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
        didImpersonate = TRUE;
    }

    return WStatus;
}


VOID
DavAsyncCreateCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Create completion. It basically frees up the
   resources allocated during the Create operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{

    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    
    CreateResponse = &(DavWorkItem->CreateResponse);
    
    if (DavWorkItem->AsyncCreate.RemPathName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.RemPathName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncCreate.UrlBuffer != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.UrlBuffer);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    } 

    if (DavWorkItem->AsyncCreate.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.didRead != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.didRead);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.FileName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.FileName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
        BOOL ReturnVal;
        ULONG CloseStatus;
        ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
        if (!ReturnVal) {
            CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/CloseHandle. "
                      "Error Val = %d\n", CloseStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        ReturnVal = InternetCloseHandle( DavWorkItem->AsyncCreate.DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncCreate.lpCEI)
    {
        LocalFree(DavWorkItem->AsyncCreate.lpCEI);
        DavWorkItem->AsyncCreate.lpCEI = NULL;
    } 

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    //
    // If we did not succeed, but landed up creating a handle to the local file,
    // we need to close that now.
    //
    if (DavWorkItem->Status != ERROR_SUCCESS) {
        if (CreateResponse->Handle != NULL) {
            NtClose(CreateResponse->Handle);
            CreateResponse->Handle = NULL;
            CreateResponse->UserModeKey = NULL;
        }
    }

    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncCreate.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncCreate.PerUserEntry) );
    }

    return;
}


BOOL
DavIsThisFileEncrypted(
    PVOID DataBuff
    )
/*++

Routine Description:

   This routine checks the buffer supplied to see if it matches the first few
   bytes of a BackedUp encrypted file.

Arguments:

    DataBuff - The buffer to be checked.

Return Value:

    TRUE - DataBuff matches the first few bytes of a BackedUp encrypted file.

    FALSE - It does not.

--*/
{
    if ( SIG_EFS_FILE   != DavCheckSignature((char *)DataBuff + sizeof(ULONG)) ||

         SIG_EFS_STREAM != DavCheckSignature((char *)DataBuff +
                                             sizeof(EFSEXP_FILE_HEADER) +
                                             sizeof(ULONG))                    ||

         SIG_EFS_DATA   != DavCheckSignature((char *)DataBuff +
                                             sizeof(EFSEXP_FILE_HEADER) +
                                             sizeof(EFSEXP_STREAM_HEADER) +
                                             sizeof(USHORT) +
                                             sizeof(ULONG))                    ||

         EFS_STREAM_ID  != *((USHORT *)((char *)DataBuff +
                                        sizeof(EFSEXP_FILE_HEADER) +
                                        sizeof(EFSEXP_STREAM_HEADER)))         ||

         EFS_EXP_FORMAT_CURRENT_VERSION != ((PEFSEXP_FILE_HEADER)DataBuff)->VersionID ) {

        //
        // Signature does not match.
        //
        return FALSE;

    } else {

        return TRUE;

    }
}


ULONG
DavCheckSignature(
    PVOID Signature
    )
/*++

Routine Description:

    This routine returns the signature type.

Arguments:

    Signature - Signature string.

Return Value:

    The type of signature. SIG_NO_MATCH for bogus signature.

--*/
{

    if ( !memcmp( Signature, FILE_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_FILE;

    }

    if ( !memcmp( Signature, STREAM_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_STREAM;

    }

    if ( !memcmp( Signature, DATA_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_DATA;

    }

    return SIG_NO_MATCH;
}


DWORD
DavRestoreEncryptedFile(
    PWCHAR ExportFile,
    PWCHAR ImportFile
    )
/*++

Routine Description:

    This function performs the restoration of encrypted files. In other words
    the import operation of the exported file by calling the appropriate EFS
    APIs.

Arguments:

    ExportFile - The File containing the backup.

    ImportFile - The File with the restored data.

Return Value:

    Returned value of the EFS APIs.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HANDLE RawImport = INVALID_HANDLE_VALUE;
    PVOID RawContext = NULL;

    DavPrint((DEBUG_MISC,
              "DavRestoreEncryptedFile: ExportFile = %ws, ImportFile = %ws\n",
              ExportFile, ImportFile));

    RawImport = CreateFileW(ExportFile,
                            (GENERIC_WRITE | GENERIC_READ),
                            0, // Exclusive access.
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_ARCHIVE,
                            NULL);
    if (RawImport == INVALID_HANDLE_VALUE) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/CreateFileW. Error Val = %d %ws\n",
                  WStatus,ExportFile));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Open a raw context to the file.
    //
    WStatus = OpenEncryptedFileRawW(ImportFile, CREATE_FOR_IMPORT, &(RawContext));
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/OpenEncryptedFileRaw. Error Val = %d %ws\n",
                  WStatus,ImportFile));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = WriteEncryptedFileRaw((PFE_IMPORT_FUNC)DavWriteRawCallback,
                                    (PVOID)RawImport,
                                    RawContext);

    if (WStatus == RPC_X_PIPE_DISCIPLINE_ERROR) {
        WStatus = ERROR_ACCESS_DENIED;
    }

    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/WriteEncryptedFileRaw. Error Val = %d %ws\n",
                  WStatus,ImportFile));
    }

EXIT_THE_FUNCTION:

    if (RawImport != INVALID_HANDLE_VALUE) {
        CloseHandle(RawImport);
    }

    if (RawContext) {
        CloseEncryptedFileRaw(RawContext);
    }

    return WStatus;
}


DWORD
DavWriteRawCallback(
    PBYTE DataBuff,
    PVOID CallbackContext,
    PULONG DataLength
    )
/*++

Routine Description:

    Call-back function for WriteEncryptedFileRaw() called in Restore(). This
    function reads the backed up data from the backup file, and provides it to
    WriteEncryptedFileRaw() through this callback function which in turn
    transforms the raw data back to its original form. This call-back function
    is called until all the data content has been read.

Arguments:

    DataBuffer - Data to be read.

    CallbackContext - Handle to the Backup file.

    DataLength - Size of the DataBuffer.

Return Value:

    Returned value of the operation.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;
    DWORD BytesRead = 0;

    DavPrint((DEBUG_MISC, "DavWriteRawCallback: DataLength = %d\n", *DataLength));

    //
    // Restore the file's content with the information stored in the temporary
    // location.
    //

    ReturnVal = ReadFile((HANDLE)CallbackContext,
                         DataBuff,
                         *DataLength,
                         &(BytesRead),
                         NULL);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavWriteRawCallback/ReadFile. Error Val = %d\n", WStatus));
    }

    DavPrint((DEBUG_MISC, "DavWriteRawCallback: BytesRead = %d\n", BytesRead));

    *DataLength = BytesRead;

    return WStatus;
}


DWORD
DavReuseCacheFileIfNotModified(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    If we get an NOT-MODIFIED response, then we just get the filename from wininet and use it

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PWCHAR pFileNameBuff = NULL;
    DWORD   dwBufferSize, dwStatus=0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = (LPINTERNET_CACHE_ENTRY_INFOW)pDavWorkItem->AsyncCreate.lpCEI;

    if (!pDavWorkItem->AsyncCreate.lpCEI)
    {
        return ERROR_FILE_NOT_FOUND;        
    }
    
    dwBufferSize = sizeof(dwStatus);
    
    if (!HttpQueryInfoW(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                        (HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER),
                        (LPVOID)&dwStatus,
                        &dwBufferSize,
                        NULL))
    {
        return GetLastError();
    }

    if (dwStatus == HTTP_STATUS_NOT_MODIFIED)
    {
        pFileNameBuff = LocalAlloc(LPTR, (lstrlen(lpCEI->lpszLocalFileName)+1)*sizeof(WCHAR));
        
        if (pFileNameBuff)
        {
            dwError = ERROR_SUCCESS;
            pDavWorkItem->AsyncCreate.FileName = pFileNameBuff;
            if (!InternetCloseHandle(pDavWorkItem->AsyncCreate.DavOpenHandle))
            {
                dwError = GetLastError();
                LocalFree(pFileNameBuff);
                pFileNameBuff = NULL; // general paranoia
                pDavWorkItem->AsyncCreate.FileName = NULL;
            }
            else
            {
                pDavWorkItem->AsyncCreate.DavOpenHandle = NULL;
                //
                //
                //
                wcscpy(pDavWorkItem->CreateResponse.FileName, lpCEI->lpszLocalFileName);
                wcscpy(pDavWorkItem->AsyncCreate.FileName, lpCEI->lpszLocalFileName);
            }
            goto EXIT_THE_FUNCTION;
        }
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }
    
EXIT_THE_FUNCTION:

    return dwError;
}

DWORD
DavCreateUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine creates an entry for a file in the WinInet's cache.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD  dwError = ERROR_SUCCESS;
    PWCHAR pFileExt = NULL;
    PWCHAR pFileNameBuff = NULL;
    BOOL ReturnVal = FALSE;

    //
    // Get the file extension. For now we assume that the extension follows the
    // last '.' char. We do a ++ after the call to wcsrchr to go past the '.'.
    // If '.' itself is the last char, the extension is NULL.
    //
    if ( *(pDavWorkItem->AsyncCreate.RemPathName) ) {
        pFileExt = ( pDavWorkItem->AsyncCreate.RemPathName + (wcslen(pDavWorkItem->AsyncCreate.RemPathName) - 1) );
        while (pFileExt != pDavWorkItem->AsyncCreate.RemPathName) {
            if ( *pFileExt == L'.' || *pFileExt == L'/' || *pFileExt == L'\\' ) {
                break;
            }
            pFileExt--;
        }
        if ( pFileExt != pDavWorkItem->AsyncCreate.RemPathName && *pFileExt == L'.' && *(pFileExt + 1) != '\0' ) {
            pFileExt++;
            DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. FileExt: %ws\n", pFileExt));
        } else {
            pFileExt = NULL;
            DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. No FileExt.\n"));
        }
    } else {
        pFileExt = NULL;
        DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. No FileExt.\n"));
    }

    DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. pFileExt: %ws\n", pFileExt));
    
    //
    // Allocate memory for pFileNameBuff.
    //
    pFileNameBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, MAX_PATH * sizeof(WCHAR));
    if (pFileNameBuff == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/LocalAlloc. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create a file name for the URL in the cache.
    //
    ReturnVal = CreateUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                     0,
                                     pFileExt,
                                     pFileNameBuff,
                                     0);
    
    // 
    // The CreateUrlCacheEntry API call may fail with GetLastError() = 
    // ERROR_FILENAME_EXCED_RANGE for long extension names. In such a scenario
    // we make the call again with the file extension set to NULL.
    //
    if (!ReturnVal && pFileExt != NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry(1). Error Val = %d\n",
                  GetLastError()));
        //
        // Another attempt to create a file name for the URL in the cache with 
        // no extension name.
        // 
        pFileExt = NULL;
        ReturnVal = CreateUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                         0,
                                         NULL,
                                         pFileNameBuff,
                                         0);
    }
    
    //
    // If we've failed the both the calls, then we return the failure.
    //
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry(2). Error Val = %d %ws\n",
                  dwError, pDavWorkItem->AsyncCreate.FileName));
        goto EXIT_THE_FUNCTION;
    }
    
    pDavWorkItem->AsyncCreate.FileName = pFileNameBuff;
    
    DavPrint((DEBUG_MISC, 
              "DavCreateUrlCacheEntry: FileName = %ws\n", 
              pDavWorkItem->AsyncCreate.FileName));
    
    //
    // Copy the file name in the response buffer.
    //
    wcscpy(pDavWorkItem->CreateResponse.FileName, pDavWorkItem->AsyncCreate.FileName);
    
EXIT_THE_FUNCTION:

    //
    // If we did not succeed then we need to free up the memory allocated for 
    // pFileNameBuff (if we did allocate at all).
    //
    if (dwError != ERROR_SUCCESS) {
        if (pFileNameBuff != NULL) {
            LocalFree(pFileNameBuff);
            pDavWorkItem->AsyncCreate.FileName = NULL;
        }
        
    }

    return dwError;
}


WCHAR wszEtagHeader[] = L"ETag: ";
#define CONST_TEN_MINUTES   ((LONGLONG)10 * 60 * 10000000)

DWORD
DavCommitUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine commits (pins) the entry for a file in the WinInet's cache. 
    This entry would have been created using DavCreateUrlCacheEntry.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwTemp, dwIndex;
    SYSTEMTIME sSystemTime;
    BOOL fRet, fHasEtag=FALSE;                
    FILETIME ExTime, LmTime;
    char chEtagBuff[1024];

    dwTemp = sizeof(SYSTEMTIME);
    dwIndex = 0;
    
    //
    // If the expiry time is available in the OpenHandle, get it.
    //
    if( !HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                       (HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME), 
                       &sSystemTime, 
                       &dwTemp, 
                       &dwIndex) 
        
        ||
        
        !SystemTimeToFileTime(&sSystemTime, &ExTime) ) {
        
        SYSTEMTIME sSysT;
    
        GetSystemTime(&sSysT);
        
        SystemTimeToFileTime(&sSysT, &ExTime);
        
        *(LONGLONG *)&ExTime += CONST_TEN_MINUTES;
    
    }
    
    dwTemp = sizeof(SYSTEMTIME);
    dwIndex = 0;
    
    //
    // If the last modified time is available in the OpenHandle, get it.
    //
    if( !HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                       (HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME),
                       &sSystemTime, 
                       &dwTemp, 
                       &dwIndex) 
        
        ||
        
        !SystemTimeToFileTime(&sSystemTime, &LmTime) ) {
        
        LmTime.dwLowDateTime = 0;
        
        LmTime.dwHighDateTime = 0;
    
    }

#if 0
    
    dwIndex = 0;
    memcpy(chEtagBuff, wszEtagHeader, sizeof(wszEtagHeader)-2);
    dwTemp = sizeof(chEtagBuff)-(sizeof(wszEtagHeader)-2);
    
    if( HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                      HTTP_QUERY_ETAG, 
                      ( chEtagBuff + sizeof(wszEtagHeader) - 2 ),
                      &dwTemp, 
                      &dwIndex) ) {
        
        fHasEtag = TRUE;
        
        dwTemp += sizeof(wszEtagHeader)-2;
        
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry. Etag %s\n",
                  chEtagBuff));
    
    }

#endif    
    
    //
    // Close the DavOpenHandle. This needs to be done, otherwise the commit
    // below will fail with SHARING_VIOLATON as WinInet has a cached file open.
    //
    fRet = InternetCloseHandle(pDavWorkItem->AsyncCreate.DavOpenHandle);
    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavCommitUrlCacheEntry/InternetCloseHandle = %d\n", 
                  GetLastError()));
        goto bailout;
    }

    pDavWorkItem->AsyncCreate.DavOpenHandle = NULL;
    
    fRet = CommitUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                pDavWorkItem->AsyncCreate.FileName,
                                ExTime,
                                LmTime,
                                STICKY_CACHE_ENTRY,
                                (fHasEtag ? ((LPWSTR)chEtagBuff) : NULL), 
                                (fHasEtag ? dwTemp : 0),
                                NULL,
                                NULL);
    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavCommitUrlCacheEntry/CommitUrlCacheEntryW = %d\n", 
                  GetLastError()));
    }

bailout:    
    
    if (!fRet) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}


DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    )
/*++

Routine Description:

    This routine set the ACLs on the file that allows everybody to access it.

Arguments:

    FilePath - The path of the file.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD status = NO_ERROR;
    DWORD cb = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    
    //
    // Initialize the Security Descriptor with the ACL allowing everybody to access the file
    //

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            L"D:(A;;GAGRGWGX;;;WD)",
            SDDL_REVISION_1,
            &SecurityDescriptor,
            &cb)) {
        status = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetAclForEncryptedFile/ConvertStringSecurityDescriptorToSecurityDescriptorW = %d\n", 
                  status));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Put the DACL onto the file
    //

    if (!SetFileSecurity(
                 FilePath,
                 DACL_SECURITY_INFORMATION,
                 SecurityDescriptor)) {
        status = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetAclForEncryptedFile/SetFileSecurity = %d\n", 
                  status));
    }

EXIT_THE_FUNCTION:
    
    if (SecurityDescriptor) {
        LocalFree(SecurityDescriptor);
    }

    return status;
}


DWORD
DavQueryUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:


Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD   cbCEI = 0, dwError = ERROR_SUCCESS, count=0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = NULL;
    CHAR   chBuff[sizeof(rgchIMS)+INTERNET_RFC1123_BUFSIZE+5];// some extra slop
    SYSTEMTIME    systemtime;
    
    if (pDavWorkItem->AsyncCreate.lpCEI != NULL) {
        return ERROR_SUCCESS;
    }
    
    cbCEI = sizeof(INTERNET_CACHE_ENTRY_INFOW)+(MAX_PATH * 2);

    do
    {
        lpCEI = LocalAlloc(LPTR, cbCEI);

        if (!lpCEI)
        {
            dwError = GetLastError();
            break;
        }
        
        ++count;
            
        if (!GetUrlCacheEntryInfo(pDavWorkItem->AsyncCreate.UrlBuffer, lpCEI, &cbCEI))
        {
            if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
            {
                LocalFree(lpCEI);
                lpCEI = NULL;
            }
            else
            {
                DavPrint((DEBUG_MISC, 
                         "DavQueryUrlCacheEntry failed %d %ws\n",dwError,pDavWorkItem->AsyncCreate.UrlBuffer));
                break;                
            }
        }
        else
        {
            dwError = ERROR_SUCCESS;
            break;
        }

    } while (count < 2);    

    if (dwError == ERROR_SUCCESS)
    {
        pDavWorkItem->AsyncCreate.lpCEI = lpCEI;
    } 
    else
    {
        // if some error occurred in adding the header, set the correct error code.
        dwError = GetLastError();
        if (lpCEI) {
            LocalFree(lpCEI);
            lpCEI = NULL;
        }
    }

    return dwError;
}


DWORD
DavAddIfModifiedSinceHeader(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:


Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD   cbCEI = 0, dwError = ERROR_SUCCESS, count=0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = NULL;
    CHAR   chBuff[sizeof(rgchIMS)+INTERNET_RFC1123_BUFSIZE+5];// some extra slop
    SYSTEMTIME    systemtime;
    
    if (pDavWorkItem->AsyncCreate.lpCEI == NULL) {
        DavQueryUrlCacheEntry(pDavWorkItem);
    }

    lpCEI = pDavWorkItem->AsyncCreate.lpCEI;        
    
    if ((lpCEI != NULL) &&
        ((lpCEI->LastModifiedTime.dwLowDateTime != 0) ||
         (lpCEI->LastModifiedTime.dwHighDateTime != 0)) &&
        FileTimeToSystemTime((CONST FILETIME *)&(lpCEI->LastModifiedTime), &systemtime)) {
        memcpy(chBuff, rgchIMS, sizeof(rgchIMS)-1);
        chBuff[(sizeof(rgchIMS))-1]  = ':';
        chBuff[sizeof(rgchIMS)] = ' ';
        if (InternetTimeFromSystemTimeA((CONST SYSTEMTIME *)&systemtime,
                                   INTERNET_RFC1123_FORMAT,
                                   &chBuff[sizeof(rgchIMS)+1],
                                   sizeof(chBuff) - sizeof(rgchIMS)-2))
        {
            HttpAddRequestHeadersA( pDavWorkItem->AsyncCreate.DavOpenHandle,
                                    chBuff, 
                                    lstrlenA(chBuff),
                                    HTTP_ADDREQ_FLAG_ADD|HTTP_ADDREQ_FLAG_REPLACE);
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davclose.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davclose.c
    
Abstract:

    This module implements the user mode DAV MiniRedir routines pertaining to 
    closing of files.

Author:

    Rohan Kumar      [RohanK]      02-June-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"

CHAR rgXmlHeader[] = "Content-Type: text/xml; charset=\"utf-8\"";
CHAR rgPropPatchHeader[] = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"urn:schemas-microsoft-com:\"><D:set><D:prop>";
CHAR rgPropPatchTrailer[] = "</D:prop></D:set></D:propertyupdate>";
CHAR rgCreationTimeTagHeader[] = "<Z:Win32CreationTime>";
CHAR rgCreationTimeTagTrailer[] = "</Z:Win32CreationTime>";
CHAR rgLastAccessTimeTagHeader[] = "<Z:Win32LastAccessTime>";
CHAR rgLastAccessTimeTagTrailer[] = "</Z:Win32LastAccessTime>";
CHAR rgLastModifiedTimeTagHeader[] = "<Z:Win32LastModifiedTime>";
CHAR rgLastModifiedTimeTagTrailer[] = "</Z:Win32LastModifiedTime>";
CHAR rgFileAttributesTagHeader[] = "<Z:Win32FileAttributes>";
CHAR rgFileAttributesTagTrailer[] = "</Z:Win32FileAttributes>";
CHAR rgDummyAttributes[] = "<Z:Dummy>0</Z:Dummy>";

#define MAX_DWORD 0xffffffff

//
// These two functions are used in saving an encrypted file on the server.
//

DWORD
DavReadRawCallback(
    PBYTE DataBuffer,
    PVOID CallbackContext,
    ULONG DataLength
    );


BOOL
DavConvertTimeToXml(
    IN PCHAR lpTagHeader,
    IN DWORD dwHeaderSize,
    IN PCHAR lpTagTrailer,
    IN DWORD dwTrailerSize,
    IN LARGE_INTEGER *lpTime,
    OUT PCHAR *lplpBuffer,
    IN OUT DWORD *lpdwBufferSize    
    );

DWORD
DavSetProperties(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName,
    LPSTR lpPropertiesBuffer
    );

DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName
    );

extern DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    );

//
// Implementation of functions begins here.
//

ULONG
DavFsClose(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV close request that get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    PWCHAR OpenVerb = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE, fSetDirectoryEntry = FALSE;
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(DavWorkItem->CloseRequest);
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    PBYTE DataBuff = NULL;
    LARGE_INTEGER FileSize, ByteOffset;
    BY_HANDLE_FILE_INFORMATION FileInfo; 
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle = NULL;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static UINT UniqueTempId = 1;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    DavPrint((DEBUG_MISC, "DavFsClose: FileName = %ws.\n", CloseRequest->FileName));
    DavPrint((DEBUG_MISC, "DavFsClose: Modified = %d.\n", CloseRequest->FileWasModified));

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;
    
    //
    // If any of the time values have changed, then we need to PROPPATCH the 
    // information back to the server.
    //
    if  ( !CloseRequest->DeleteOnClose &&
          ( CloseRequest->fCreationTimeChanged     || 
            CloseRequest->fLastAccessTimeChanged   ||         
            CloseRequest->fLastModifiedTimeChanged || 
            CloseRequest->fFileAttributesChanged ) ) {
        fSetDirectoryEntry = TRUE;
    }

    DavPrint((DEBUG_MISC, "DavFsClose: fSetDirectoryEntry = %x \n", fSetDirectoryEntry));
    
    if ( CloseRequest->isDirectory    &&
         !CloseRequest->DeleteOnClose && 
         !fSetDirectoryEntry ) {
        //
        // If this is a directory close, then the only reason to contact the
        // server is when we are deleting the directory and all the files 
        // under it. If not, we can return right now.
        //
        WStatus = ERROR_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    if ( !CloseRequest->isDirectory  ) {

        //
        // We need to close the handle only if it was created in the user mode.
        //
        if ( !CloseRequest->createdInKernel && CloseRequest->Handle ) {

            DavPrint((DEBUG_MISC, "DavFsClose: OpenHandle = %08lx.\n", CloseRequest->Handle));
        
            //
            // Close the handle that was opened during the Create call.
            //
            ASSERT((CloseRequest->UserModeKey) == ((PVOID)CloseRequest->Handle));

            ReturnVal = CloseHandle(CloseRequest->Handle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/CloseHandle: Return Val = %08lx.\n", WStatus));
            } else {
                CloseRequest->UserModeKey = NULL;
                CloseRequest->Handle = INVALID_HANDLE_VALUE;
            }

        }

        //
        //    DeleteOnClose    FileCreatedLocally    FileModified     Action
        //    -------------    ------------------    ------------     -------
        //         0                   0                  0           NOTHING
        //         0                   0                  1             PUT
        //         0                   1                  0             PUT
        //         0                   1                  1             PUT
        //         1                   0                  0            DELETE
        //         1                   0                  1            DELETE
        //         1                   1                  0           NOTHING 
        //         1                   1                  1           NOTHING
        //
        // The FileCreatedLocally no longer matters since we PUT the file
        // immediately as soon as we create a local copy to claim the name on
        // the server.
        //

        //
        // If this file doesn't have to be deleted, was not created locally and 
        // was not written to, or direntry not modified, then we are done.
        //
        if ( !(CloseRequest->DeleteOnClose)      &&
             !(CloseRequest->FileWasModified)    &&
             ! fSetDirectoryEntry ) {
                         
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // In all other cases (or combinations of the above three booleans), we 
    // need to go to the server. So, before we procced to decide what to do
    // on the server with this file, we need to set up the parameters for the
    // WinInet calls.
    //

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(CloseRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsClose: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsClose: ServerName = %ws.\n", ServerName));
    
    ServerID = CloseRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsClose: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(CloseRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsClose: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsClose: DirectoryPath = %ws.\n", DirectoryPath));
    
    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/DavFsSetTheDavCallBackContext. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;
    
    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif
    
    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, "DavFsClose/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(CloseRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsClose: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncClose.PerUserEntry = PerUserEntry;

    DavWorkItem->AsyncClose.ServerHashEntry = ServerHashEntry;
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    if ( !CloseRequest->isDirectory ) {

        //
        // If the file has to be deleted on close, we need to send a DELETE for 
        // this file to the server. It does not matter if the file has been 
        // modified or not.
        //
        if ( (CloseRequest->DeleteOnClose) ) {

            DavWorkItem->DavMinorOperation = DavMinorDeleteFile;

            OpenVerb = L"DELETE";

            DavWorkItem->AsyncClose.DataBuff = NULL;

        } else if (CloseRequest->FileWasModified) {

            //
            // The file has been changed and needs to be PUT on the server.
            //
            DavWorkItem->DavMinorOperation = DavMinorPutFile;

            OpenVerb = L"PUT";

            //
            // We need to check if this file is encrypted. If it is, we need to 
            // BackUp the encrypted file to a temp file and send the BackedUp file
            // to the server.
            //
            if ( !( CloseRequest->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ) ) {

                DavPrint((DEBUG_MISC, "DavFsClose. This is NOT an Encrypted file.\n"));

                //
                // Create an NT path name for the cached file. This is used in the 
                // NtCreateFile call below.
                //
                ReturnVal = RtlDosPathNameToNtPathName_U(CloseRequest->FileName,
                                                         &(UnicodeFileName), 
                                                         NULL, 
                                                         NULL);
                if (!ReturnVal) {
                    WStatus = ERROR_BAD_PATHNAME;
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/RtlDosPathNameToNtPathName. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                InitializeObjectAttributes(&(ObjectAttributes),
                                           &(UnicodeFileName),
                                           OBJ_CASE_INSENSITIVE,  
                                           0,
                                           NULL);

                //
                // This #if 0 below was added because the NtCreateFile was failing
                // with ERROR_ACCESS_DENIED. This is because this file has been
                // created in the LocalService's %USERPROFILE% and you need to be
                // in the context of the LocalService before calling NtCreateFile.
                // By impersonating below we were getting into the context of the
                // user and hence the call failed.
                //

    #if 0
                //
                // We are running in the context of the Web Client service. Before 
                // contacting the server below, we need to impersonate the client 
                // that issued this request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/UMReflectorImpersonate. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;
    #endif

                //
                // Create a handle to the local file, for reading its attributes and data.
                // We read the whole file into a buffer and send it across to the server.
                //
                NtStatus = NtCreateFile(&(FileHandle),
                                        (SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_READ_DATA),
                                        &(ObjectAttributes),
                                        &(IoStatusBlock),
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                        FILE_OPEN,
                                        (FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT),
                                        NULL,
                                        0);
                if (NtStatus != STATUS_SUCCESS) {
                    //
                    // We convert the NtStatus to DOS error here. The Win32
                    // error code is finally set to an NTSTATUS value in
                    // the DavFsCreate function just before returning.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/NtCreateFile(1). Error Val = %08lx\n", 
                              NtStatus));
                    goto EXIT_THE_FUNCTION;
                }

                ReturnVal = GetFileInformationByHandle(FileHandle, &(FileInfo));
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/GetFileInformationByHandle: Return Val = %08lx.\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (didImpersonate) {
                    RevertToSelf();
                    didImpersonate = FALSE;
                }

                FileSize.LowPart = FileInfo.nFileSizeLow;
                FileSize.HighPart = FileInfo.nFileSizeHigh;

                if ( FileSize.QuadPart > (LONGLONG)0 ) {

                    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, FileSize.LowPart);
                    if (DataBuff == NULL) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/LocalAlloc. Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.DataBuff = DataBuff;

                    //
                    // Start reading at the first byte.
                    //
                    ByteOffset.LowPart = 0;
                    ByteOffset.HighPart = 0;

                    NtStatus = NtReadFile(FileHandle, 
                                          NULL,
                                          NULL,
                                          NULL,
                                          &(IoStatusBlock),
                                          DataBuff,
                                          FileSize.LowPart, 
                                          &(ByteOffset),
                                          NULL);
                    if (NtStatus != STATUS_SUCCESS) {
                        //
                        // We convert the NtStatus to DOS error here. The Win32
                        // error code is finally set to an NTSTATUS value in
                        // the DavFsCreate function just before returning.
                        //
                        WStatus = RtlNtStatusToDosError(NtStatus);
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/NtReadFile. Error Val = %08lx\n", 
                                  NtStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.DataBuffSizeInBytes = FileSize.LowPart;

                    NtStatus = NtClose(FileHandle);
                    if (NtStatus != STATUS_SUCCESS) {
                        //
                        // We convert the NtStatus to DOS error here. The Win32
                        // error code is finally set to an NTSTATUS value in
                        // the DavFsCreate function just before returning.
                        //
                        WStatus = RtlNtStatusToDosError(NtStatus);
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/NtClose. Error Val = %08lx\n", 
                                  NtStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                } else {

                    DavPrint((DEBUG_MISC, "DavFsClose. Zero Byte File.\n"));

                    DavWorkItem->AsyncClose.DataBuff = NULL;

                }

            } else {

                DWORD err;
                UINT tempErr;
                BOOL copyErr;
                PVOID RawContext = NULL;

                //
                // This is an encrypted file. Create a BackUp stream, store it into
                // a temp file and PUT the temp file (BLOB) on the server.
                //
                DavPrint((DEBUG_MISC, "DavFsClose. This is an Encrypted file.\n"));

                //
                // We loop till we can come up with a FileName in the TEMP directory
                // of the user which has not been used.
                //

                DavPrint((DEBUG_MISC, 
                          "DavFsClose: FileName = %ws\n", CloseRequest->FileName));

                //
                // If the file was opened as non-encrypted, the local cache file does not have
                // the ACL allowing everyone to access. Set the ACL here before impersonating.
                //
                WStatus = DavSetAclForEncryptedFile(CloseRequest->FileName);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncClose/DavSetAclForEncryptedFile. Error Val"
                              " = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                
                //
                // We are running in the context of the Web Client service. Before contacting
                // the server below, we need to impersonate the client that issued this
                // request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/UMReflectorImpersonate. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;

                //
                // Open a Raw context to the file.
                //
                WStatus = OpenEncryptedFileRawW(CloseRequest->FileName, 0, &(RawContext));
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/OpenEncryptedFileRaw. Error Val = %d %ws\n", 
                              WStatus,CloseRequest->FileName));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // The extra space prepared for the EFS stream.
                //

                DavWorkItem->AsyncClose.DataBuffAllocationSize = (CloseRequest->FileSize >> 4) + 0x1000;

                if (MAX_DWORD - CloseRequest->FileSize < DavWorkItem->AsyncClose.DataBuffAllocationSize) {
                    WStatus = ERROR_NO_SYSTEM_RESOURCES;
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/backup size exceeds MRX_DWORD!"));
                    goto EXIT_THE_FUNCTION;
                }
                
                DavWorkItem->AsyncClose.DataBuffAllocationSize += CloseRequest->FileSize;
                
                DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DavWorkItem->AsyncClose.DataBuffAllocationSize);

                if (DataBuff == NULL) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/LocalAlloc. Error Val = %d\n", WStatus));
                    
                    if (RawContext) {
                        CloseEncryptedFileRaw(RawContext);
                    }
                    goto EXIT_THE_FUNCTION;
                }

                DavWorkItem->AsyncClose.DataBuff = DataBuff;
                DavPrint((DEBUG_MISC, 
                          "DavFsClose: allocate backup buffer %x %x\n",DataBuff,DavWorkItem->AsyncClose.DataBuffAllocationSize));
                
                WStatus = ReadEncryptedFileRaw((PFE_EXPORT_FUNC)DavReadRawCallback,
                                               (PVOID)DavWorkItem,
                                               RawContext);
                
                if (RawContext) {
                    CloseEncryptedFileRaw(RawContext);
                }

                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/ReadEncryptedFileRaw. Error Val = %d\n", 
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                
                if (didImpersonate) {
                    RevertToSelf();
                    didImpersonate = FALSE;
                }
            }
        } else {
            ASSERT(fSetDirectoryEntry);
            //
            // If it is only an attribute change, we send the PROPPATCH
            //
            WStatus = ERROR_SUCCESS;
            goto EXIT_THE_FUNCTION;
        
        }
    } else {

        if (CloseRequest->DeleteOnClose) {
            //
            // This is a directory and needs to be deleted from the server.
            //
            DavWorkItem->DavMinorOperation = DavMinorDeleteFile;

            OpenVerb = L"DELETE";

            DavWorkItem->AsyncClose.DataBuff = NULL;
        } else if (fSetDirectoryEntry) {
            //
            // If this is a directory close, then the only reason to contact the
            // server is when we are deleting the directory and all the files 
            // under it. If not, we can return right now.
            //
            WStatus = ERROR_SUCCESS;
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // We are running in the context of the Web Client service. Before contacting
    // the server below, we need to impersonate the client that issued this
    // request.
    //
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    //
    // We now call the DavHttpOpenRequest function.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    
    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                  OpenVerb,
                                  DirectoryPath,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavFsClose",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsClose/DavHttpOpenRequestW. Error Val = %d\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncClose.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

    if (WStatus == ERROR_SUCCESS) {
        INTERNET_CACHE_ENTRY_INFOW CEI;

        CEI.LastAccessTime.dwLowDateTime = 0;
        CEI.LastAccessTime.dwHighDateTime = 0;

        SetUrlCacheEntryInfo(CloseRequest->Url,&CEI,CACHE_ENTRY_ACCTIME_FC);
        
        DavPrint((DEBUG_MISC,
                  "DavFsClose Reset LastAccessTime for      %ws\n",CloseRequest->Url));
        
        if (CloseRequest->FileWasModified &&
            (CloseRequest->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            //
            // Reset the LastModifiedTime on URL cache of the encrypted file
            // so that the public cache will be updated on the next GET.
            //
            CEI.LastModifiedTime.dwLowDateTime = 0;
            CEI.LastModifiedTime.dwHighDateTime = 0;

            SetUrlCacheEntryInfo(CloseRequest->Url,&CEI,CACHE_ENTRY_MODTIME_FC);
            
            DavPrint((DEBUG_MISC,
                      "DavFsClose Reset LastModifiedTime %ws\n",CloseRequest->Url));
        }

    }

EXIT_THE_FUNCTION:

    if (fSetDirectoryEntry && (WStatus == ERROR_SUCCESS)) {
        
        if (!didImpersonate) {
            //
            // If we are using WinInet synchronously, then we need to impersonate the
            // clients context now. This is becuase the DavSetProperties call below
            // contacts the DAV Server and we need to be impersonating the correct 
            // client when contacting it.
            //
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/UMReflectorImpersonate(2). Error Val = %d\n",
                          WStatus));
            } else {
                didImpersonate = TRUE;
            }
        }

        if (WStatus == ERROR_SUCCESS) {

            DavWorkItem->DavMinorOperation = DavMinorProppatchFile;

            WStatus = DavSetBasicInformation(DavWorkItem,
                                             DavConnHandle,
                                             DirectoryPath,
                                             CloseRequest->fCreationTimeChanged,
                                             CloseRequest->fLastAccessTimeChanged,
                                             CloseRequest->fLastModifiedTimeChanged,
                                             CloseRequest->fFileAttributesChanged,
                                             &CloseRequest->CreationTime,
                                             &CloseRequest->LastAccessTime,
                                             &CloseRequest->LastModifiedTime,
                                             CloseRequest->dwFileAttributes);

            if (WStatus != ERROR_SUCCESS) {

                ULONG LogStatus;

                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/DavSetBasicInformation. WStatus = %d\n",
                          WStatus));
            
                LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
                if (LogStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/DavFomatAndLogError. LogStatus = %d\n",
                              LogStatus));
                }
            
            }

            DavPrint((DEBUG_MISC,
                      "DavFsClose set BasicInformation(2). %d %x %ws\n",
                       WStatus,CloseRequest->dwFileAttributes,DirectoryPath));

            //
            // If the PROPPATCH fails, we don't fail the close call. This is 
            // because the PUT (if one was needed) has suceeded and we reset the
            // FileWasModified flag in the FCB based on whether this call succeeds.
            // On the final close, we check to see if this flag is set to FALSE
            // and pop up a box saying that the "delayed write failed". We 
            // shouldn't be doing it if the PUT succeeds and the PROPPATCH fails.
            // We log an entry in the EventLog (under application) that the
            // PROPPATCH has failed though.
            //
            WStatus = ERROR_SUCCESS;

        }

    } else {
        DavPrint((DEBUG_MISC,
                  "DavFsClose not set BasicInformation(2). %x %ws\n",
                   CloseRequest->dwFileAttributes,DirectoryPath));
    }

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the 
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {
            
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
    
        DavAsyncCloseCompletion(DavWorkItem);
    
    } else {
        DavPrint((DEBUG_MISC, "DavFsClose: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }

    DavAsyncCloseCompletion(DavWorkItem);
        
#endif

    return WStatus;
}


DWORD 
DavAsyncClose(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the close operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
    DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/UMReflectorImpersonate. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncClose/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncClose. AsyncFunction failed. Error Val = %d\n", 
                          WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    //
    // We return what ever the response code from the Http server was for this
    // request.
    //
    WStatus = DavQueryAndParseResponse(DavOpenHandle);

    if (WStatus != ERROR_SUCCESS) {

        ULONG LogStatus;

        LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
        if (LogStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/DavFormatAndLogError. LogStatus = %d\n", 
                      LogStatus));
        }
    
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
EXIT_THE_FUNCTION:
#endif

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }


        //
        // Call the DavAsyncCloseCompletion routine.
        //
        DavAsyncCloseCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncClose: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncCloseCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Async Close completion. It basically frees up 
   the resources allocated during the Async Close operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncClose.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncClose.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncClose.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncClose.InternetBuffers != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncClose.InternetBuffers);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncClose.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncClose.PerUserEntry) );
    }

    return;
}

DWORD
DavReadRawCallback(
    PBYTE DataBuffer,
    PVOID CallbackContext,
    ULONG DataLength
    )
/*++

Routine Description:

    Call-back function for ReadEncryptedFileRaw(). This function allocate a buffer for
    async close and writes back the data to this buffer specified on because 
    ReadEncryptedFileRaw() provides the raw data to this callback function
    which in turn stores it in a backup file. This call-back function is called 
    until there is no more data left.

Arguments:

    DataBuffer - Data to be written.

    CallbackContext - Handle to the Backup file.

    DataLength - Size of the DataBuffer.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    DWORD BytesWritten = 0;
    BOOL  ReturnVal;
    PBYTE PreviousBuffer = NULL;
    ULONG PreviousDataLength = 0;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)CallbackContext;

    DavPrint((DEBUG_MISC, "DavReadRawCallback: DataLength = %d\n", DataLength));
    
    if ( !DataLength ) {
        return WStatus;
    }

    ASSERT(DavWorkItem->AsyncClose.DataBuff != NULL);

    PreviousDataLength = DavWorkItem->AsyncClose.DataBuffSizeInBytes;
    
    //
    // If the backup size exceeds the pre-allocation size, we have to allocate a bigger buffer.
    //
    if (PreviousDataLength + DataLength > DavWorkItem->AsyncClose.DataBuffAllocationSize) {

        if ((MAX_DWORD - PreviousDataLength < DataLength) ||
            (MAX_DWORD - PreviousDataLength - DataLength < 0x10000)) {
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            DavPrint((DEBUG_ERRORS,
                      "DavReadRawCallback/backup size exceeds MRX_DWORD!"));
            goto EXIT_THE_FUNCTION;
        }
        
        PreviousBuffer = DavWorkItem->AsyncClose.DataBuff;
        DavWorkItem->AsyncClose.DataBuffAllocationSize = DataLength+PreviousDataLength+0x10000;

        DavWorkItem->AsyncClose.DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DavWorkItem->AsyncClose.DataBuffAllocationSize);

        if (DavWorkItem->AsyncClose.DataBuff == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavReadRawCallback/LocalAlloc. Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        RtlCopyMemory(DavWorkItem->AsyncClose.DataBuff,
                      PreviousBuffer,
                      PreviousDataLength);
        
        DavPrint((DEBUG_MISC, 
                  "DavReadRawCallback: allocate a bigger buffer %x %x\n",
                  DavWorkItem->AsyncClose.DataBuff,
                  DavWorkItem->AsyncClose.DataBuffAllocationSize));
    }
    
    RtlCopyMemory((PBYTE)(DavWorkItem->AsyncClose.DataBuff + PreviousDataLength),
                  DataBuffer,
                  DataLength);

    DavWorkItem->AsyncClose.DataBuffSizeInBytes += DataLength;

    DavPrint((DEBUG_MISC, "DavReadRawCallback: Buffer %x DataLength %d\n",
              DavWorkItem->AsyncClose.DataBuff,DavWorkItem->AsyncClose.DataBuffSizeInBytes));

EXIT_THE_FUNCTION:

    if (PreviousBuffer) {
        LocalFree(PreviousBuffer);
    }

    return WStatus;
}


DWORD
DavSetBasicInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  PathName,
    BOOL fCreationTimeChanged,
    BOOL fLastAccessTimeChanged,
    BOOL fLastModifiedTimeChanged,
    BOOL fFileAttributesChanged,
    IN LARGE_INTEGER *lpCreationTime,
    IN LARGE_INTEGER *lpLastAccessTime,
    IN LARGE_INTEGER *lpLastModifiedTime,
    DWORD dwFileAttributes
    )
/*++

Routine Description:

    This routine sets DAV properties on a file or a directory. It formats an XML requests and sends it
    to the server.
    
Arguments:

    DavConnectHandle - Server connection.
    
    CloseRequest - Usemode close request corresponding to the kernelmode close.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    CHAR *lpTemp = NULL, Buffer[1024];
    DWORD dwError = ERROR_SUCCESS, dwSizeRemaining, dwTemp;    
    BOOL fRet = FALSE;    
    BOOL fInfoChange = TRUE;
    DWORD dwOverrideAttribMask = (FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_ENCRYPTED |
                                  FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                                  FILE_ATTRIBUTE_OFFLINE |  FILE_ATTRIBUTE_READONLY |
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_TEMPORARY |
                                  FILE_ATTRIBUTE_DIRECTORY);

    fInfoChange = (fCreationTimeChanged | fLastAccessTimeChanged | 
                   fLastModifiedTimeChanged | fFileAttributesChanged);
    
    DavPrint((DEBUG_MISC, "DavSetBasicInformation: Attributes = %x %x\n", dwFileAttributes,fInfoChange));

    //
    // We do not proceed further since there is no information to change. Also,
    // in this case we return SUCCESS back to the caller.
    //
    if(fInfoChange == FALSE) {
        fRet = TRUE;
        dwError = ERROR_SUCCESS;
        goto bailout;
    }

    //
    // If attributes have changed, then verify that the new attributes are in 
    // valid combination i.e. If either of following attributes is present:
    // FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_ENCRYPTED, 
    // FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
    // FILE_ATTRIBUTE_OFFLINE, FILE_ATTRIBUTE_READONLY, 
    // FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_TEMPORARY, FILE_ATTRIBUTE_DIRECTORY
    // and if FILE_ATTRIBUTE_NORMAL is present, then FILE_ATTRIBUTE_NORMAL 
    // should be filtered.
    //

    if (fFileAttributesChanged == TRUE && (dwOverrideAttribMask & dwFileAttributes)) {
        dwFileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
    }

    //
    // If this is a directoy and the attributes being set include 
    // FILE_TEMPORARY_FILE then we return ERROR_INVALID_PARAMETER since a 
    // directory cannot have this attribute.
    //
    if ( (fFileAttributesChanged)                         &&
         (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)    &&
         (dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) ) {
        fRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    dwSizeRemaining = sizeof(rgPropPatchHeader) + sizeof(rgPropPatchTrailer) + 8 +
            ((fCreationTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgCreationTimeTagHeader)+
                                                    sizeof(rgCreationTimeTagTrailer)):0)+
            ((fLastAccessTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgLastAccessTimeTagHeader)+
                                                    sizeof(rgLastAccessTimeTagTrailer)):0)+
            ((fLastModifiedTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgLastModifiedTimeTagHeader)+
                                                    sizeof(rgLastModifiedTimeTagTrailer)):0)+
            ((fFileAttributesChanged)?(8+sizeof(rgFileAttributesTagHeader)+
                                                        sizeof(rgFileAttributesTagTrailer)):0);
                        

    if (dwSizeRemaining > sizeof(Buffer)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Insufficient buffer %d %d\n", dwSizeRemaining, sizeof(Buffer)));
    }

    memset(Buffer, 0, sizeof(Buffer));    

    dwSizeRemaining = sizeof(Buffer);

    lpTemp = Buffer;

    memcpy(lpTemp, rgPropPatchHeader, (sizeof(rgPropPatchHeader)-1));

    lpTemp += (sizeof(rgPropPatchHeader)-1);

    dwSizeRemaining -= (sizeof(rgPropPatchHeader)-1);
    
    dwTemp = dwSizeRemaining;
    
    if (fCreationTimeChanged) {
        if (!DavConvertTimeToXml(rgCreationTimeTagHeader, (sizeof(rgCreationTimeTagHeader)-1),
                                 rgCreationTimeTagTrailer, (sizeof(rgCreationTimeTagTrailer)-1),
                                 lpCreationTime,
                                 &lpTemp,
                                 &dwTemp)) {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert creationtime\n"));
            goto bailout;
        }
    }

    if (fLastAccessTimeChanged)
    {
        if (!DavConvertTimeToXml(rgLastAccessTimeTagHeader, (sizeof(rgLastAccessTimeTagHeader)-1),
                                 rgLastAccessTimeTagTrailer, (sizeof(rgLastAccessTimeTagTrailer)-1),
                                 lpLastAccessTime,
                                 &lpTemp,
                                 &dwTemp))
        {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert lastaccesstime\n"));
            goto bailout;
        }
    }

    if (fLastModifiedTimeChanged)
    {
        if (!DavConvertTimeToXml(rgLastModifiedTimeTagHeader, (sizeof(rgLastModifiedTimeTagHeader)-1),
                                 rgLastModifiedTimeTagTrailer, (sizeof(rgLastModifiedTimeTagTrailer)-1),
                                 lpLastModifiedTime,
                                 &lpTemp,
                                 &dwTemp))
        {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert lastmodifiedtime\n"));
            goto bailout;
        }
    }

    if (fFileAttributesChanged)
    {
        memcpy(lpTemp, rgFileAttributesTagHeader, sizeof(rgFileAttributesTagHeader)-1);
        lpTemp += (sizeof(rgFileAttributesTagHeader)-1);
        
        sprintf(lpTemp, "%8.8x", dwFileAttributes);
        lpTemp += 8;
        
        memcpy(lpTemp, rgFileAttributesTagTrailer, sizeof(rgFileAttributesTagTrailer)-1);
        lpTemp += (sizeof(rgFileAttributesTagTrailer)-1);
    }

    memcpy(lpTemp, rgPropPatchTrailer, sizeof(rgPropPatchTrailer)-1);

    dwError = DavSetProperties(DavWorkItem, hDavConnect, PathName, Buffer);

    fRet = (dwError == ERROR_SUCCESS);

    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavSetBasicInformation/DavSetProperties: dwError = %d\n",
                  dwError));
        SetLastError(dwError);
    }

bailout:

    if (!fRet) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetBasicInformation: dwError = %x\n", GetLastError()));
    }
    
    return dwError;
}


BOOL
DavConvertTimeToXml(
    IN PCHAR lpTagHeader,
    IN DWORD dwHeaderSize,
    IN PCHAR lpTagTrailer,
    IN DWORD dwTrailerSize,
    IN LARGE_INTEGER *lpTime,
    OUT PCHAR *lplpBuffer,
    IN OUT DWORD *lpdwBufferSize    
    )
/*++

Routine Description:

    Creates an xml piece for setting a time property. The format is
    <TagHeader>TimeString in RFC 1123 format<TagTrailer>
    
Arguments:

    lpTagHeader     tag beginning e.g. <Z:Win32CreationTime>
    
    dwHeaderSize    size of the above header in bytes
    
    lpTagTrailer    tag end e.g. </Z:Win32CreationTime>
    
    dwTrailerSize   size of the trailer in bytes
    
    lplpBuffer      pointer to a buffer pointer. On successful return the pointer is moved ahead.
    
    lpdwBufferSize  contains the passed in buffersize. On successful return, this value
                    is reduced by the amount of space consumed in this routine.

Return Value:

    ERROR_SUCCESS or Win32 Error Code. If the buffersize is not enough, the 
    error code is ERROR_INSUFFICIENT_BUFFER and lpdwBufferSize contains the 
    amount necessary to succeed.

--*/
{
    SYSTEMTIME  sSystemTime;
    DWORD   cbTimeSize;
    CHAR   chTimeBuff[INTERNET_RFC1123_BUFSIZE+4], *lpTemp;

                
    if(!FileTimeToSystemTime((FILETIME *)lpTime, &sSystemTime))
    {
        return FALSE;
    }

    if(!InternetTimeFromSystemTimeA(&sSystemTime, INTERNET_RFC1123_FORMAT, chTimeBuff, sizeof(chTimeBuff)))
    {
        return FALSE;
    }


    cbTimeSize = strlen(chTimeBuff);
    
    if (*lpdwBufferSize < (cbTimeSize + dwHeaderSize + dwTrailerSize))
    {
        *lpdwBufferSize =  (cbTimeSize + dwHeaderSize + dwTrailerSize);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }




    // all is well, start copying
    
    lpTemp = *lplpBuffer;

    // header tag eg: <Z:Win32CreationTime>
    memcpy(lpTemp, lpTagHeader, dwHeaderSize);
    
    lpTemp += dwHeaderSize;


    // Time in the RFC_1123 format    
    memcpy(lpTemp, chTimeBuff, cbTimeSize);
    
    lpTemp += cbTimeSize;
    
    // trailer tag eg: </Z:Win32CreationTime>
    memcpy(lpTemp, lpTagTrailer, dwTrailerSize);
    
    lpTemp += dwTrailerSize;
    

    // adjust the remainign size and the pointers    
    *lpdwBufferSize -=  (cbTimeSize + dwHeaderSize + dwTrailerSize);
    *lplpBuffer = lpTemp;
    
    return TRUE;
}


DWORD
DavParseXmlResponse(
    HINTERNET DavOpenHandle,
    DAV_FILE_ATTRIBUTES *pDavFileAttributesIn,
    DWORD               *pNumFileEntries
    )
/*++

Routine Description:

    This routine parses the xml response. This is mainly useful for verbs which 
    may get back xml response.
    
Arguments:

    DavOpenHandle   Handle obtained from HttpOpenRequest. A send is already issued on this handle                    
                    

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL ReturnVal, readDone;
    PCHAR DataBuff = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    DAV_FILE_ATTRIBUTES DavFileAttributes, *pDavFileAttributesLocal = NULL;

    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
    if (DataBuff == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavParseXmlResponse/LocalAlloc: dwError = %08lx\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Read the response and parse it.
    //
    do {

        ReturnVal = InternetReadFile(DavOpenHandle, 
                                     (LPVOID)DataBuff,
                                     NUM_OF_BYTES_TO_READ,
                                     &(NumRead));
        if (!ReturnVal) {
            dwError = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavParseXmlResponse/InternetReadFile: dwError = "
                      "%08lx\n", dwError));
            goto EXIT_THE_FUNCTION;
        }
    
        DavPrint((DEBUG_MISC, "DavParseXmlResponse: NumRead = %d\n", NumRead));
        
        readDone = (NumRead == 0) ? TRUE : FALSE;

        dwError = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
        if (dwError != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavParseXmlResponse/DavPushData."
                      " Error Val = %d\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        if (readDone) {
            break;
        }
    
    } while ( TRUE );

    if (Ctx2) {
        if (pDavFileAttributesIn)
        {
            pDavFileAttributesLocal = pDavFileAttributesIn;
        }
        else
        {
            pDavFileAttributesLocal = &DavFileAttributes;
        }
        memset(pDavFileAttributesLocal, 0, sizeof(DavFileAttributes));
        InitializeListHead(&(pDavFileAttributesLocal->NextEntry));
        dwError = DavParseData(pDavFileAttributesLocal, Ctx1, Ctx2, &NumOfFileEntries);
        if (dwError != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                              "DavParseXmlResponse/DavParseData. "
                              "Error Val = %d\n", dwError));
            DavFinalizeFileAttributesList(pDavFileAttributesLocal, FALSE);
            goto EXIT_THE_FUNCTION;
        }
        if (!pDavFileAttributesIn)
        {
            DavFinalizeFileAttributesList(pDavFileAttributesLocal, FALSE);
        }
        DavCloseContext(Ctx1, Ctx2);
    }

    if (pNumFileEntries)
    {
        *pNumFileEntries = NumOfFileEntries;
    }
    
    dwError = ERROR_SUCCESS;

EXIT_THE_FUNCTION:

    if (DataBuff) {
        LocalFree(DataBuff);
        DataBuff = NULL;
    }
    
    return dwError; 
}


DWORD
DavSetProperties(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName,
    LPSTR lpPropertiesBuffer
    )
/*++

Routine Description:

    This routine sets DAV properties on a file or a directory. It formats an XML requests and sends it
    to the server.
    
Arguments:

    DavConnectHandle - Server connection.
    
    CloseRequest - Usemode close request corresponding to the kernelmode close.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    HINTERNET hRequest = NULL;
    BOOL BStatus = FALSE, ReturnVal = FALSE;
    PWCHAR PassportCookie = NULL;

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls. 
    // This has to be a W API as the name in CloseRequest is unicode.
    //
    BStatus = DavHttpOpenRequestW(hDavConnect,
                                  L"PROPPATCH",
                                  lpPathName, 
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES |
                                  INTERNET_FLAG_RELOAD,
                                  0,
                                  L"DavSetProperties",
                                  &hRequest);
    if(BStatus == FALSE) {
        dwError = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (hRequest == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/DavHttpOpenRequestW. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersA(hRequest,
                                       "translate: f\n",
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/HttpAddRequestHeadersA. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavAttachPassportCookie(DavWorkItem,hRequest,&PassportCookie);

    if (dwError != ERROR_SUCCESS) {
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavInternetSetOption(DavWorkItem,hRequest);

    if (dwError != ERROR_SUCCESS) {
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpSendRequestA(hRequest,
                                 rgXmlHeader,
                                 strlen(rgXmlHeader),
                                 (LPVOID)lpPropertiesBuffer,
                                 strlen(lpPropertiesBuffer));
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/HttpSendRequestA: Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavQueryAndParseResponse(hRequest);
    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);                
        DavPrint((DEBUG_ERRORS, 
                  "DavSetProperties/DavQueryAndParseResponse: Error Val = %d\n", 
                  dwError));
        goto EXIT_THE_FUNCTION;
    }
    
    dwError = DavParseXmlResponse(hRequest, NULL, NULL);
    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/DavParseXmlResponse: dwError = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;    
    }
    
EXIT_THE_FUNCTION:
    
    if (hRequest) {
        InternetCloseHandle(hRequest);    
    }
    
    if (PassportCookie) {
        LocalFree(PassportCookie);
    }
    
    return dwError;
}


DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  lpPathName
)
/*++

Routine Description:

    This routine tests whether DAV properties can be set on this root directory.
    
Arguments:

    DavConnectHandle - Server connection.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    CHAR *lpTemp = NULL, Buffer[1024];
    DWORD dwError = ERROR_SUCCESS, dwSizeRemaining, dwTemp;    
    
    memset(Buffer, 0, sizeof(Buffer));    
    
    dwSizeRemaining = sizeof(Buffer);
        
    lpTemp = Buffer;
    
    memcpy(lpTemp, rgPropPatchHeader, (sizeof(rgPropPatchHeader)-1));

    lpTemp += (sizeof(rgPropPatchHeader)-1);

    dwSizeRemaining -= (sizeof(rgPropPatchHeader)-1);
    
    dwTemp = dwSizeRemaining;
    
    memcpy(lpTemp, rgDummyAttributes, sizeof(rgDummyAttributes)-1);
    lpTemp += (sizeof(rgDummyAttributes)-1);
    
    memcpy(lpTemp, rgPropPatchTrailer, sizeof(rgPropPatchTrailer)-1);

    dwError = DavSetProperties(DavWorkItem, hDavConnect, lpPathName, Buffer);
    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davrpc_server.c ===
#include <davrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\dllmain.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This is the dll entry point for the web dav mini redir service dll.

Author:

    Andy Herron (andyhe) 29-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason) {

        InitializeCriticalSection (&g_DavServiceLock);

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;

        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

    } else if (DLL_PROCESS_DETACH == dwReason) {

        DeleteCriticalSection (&g_DavServiceLock);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davsrv.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davsrv.c

Abstract:

    This has all of our server side entry points for the DAV Mini-Redir
    RPC service interface. It also contains the helper functions for the 
    service interface.

Author:

    Rohan Kumar   [RohanK]   01-Dec-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include <lmuseflg.h>
#include "global.h"
#include <time.h>
#include "nodefac.h"
#include "UniUtf.h"

DWORD
DavCheckLocalName (
    LPWSTR LocalName,
    PWCHAR OutputLocalDeviceBuffer
    );

DWORD
DavCheckRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
DavCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    IN ULONG SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    );

DWORD
DavOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    );

DWORD
DavImpersonateClient(
    VOID
    );

ULONG
DavImpersonateAndGetSessionId(
    PULONG pSessionId
    );

ULONG
DavImpersonateAndGetLogonId(
    PLUID pLogonId
    );

DWORD
DavCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN OUT LPWSTR *Session
    );

DWORD
DavDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName
    );

ULONG
DavImpersonateAndGetUserId(
    LPWSTR UserName,
    LPDWORD UserNameMaxLen
    );

DWORD
DavRevertToSelf(
    VOID
    );

NET_API_STATUS
DavGetUserEntry(
    IN  PDAV_USERS_OBJECT DavUsers,
    IN  PLUID LogonId,
    OUT PULONG Index,
    IN  BOOL IsAdd
    );

NET_API_STATUS
DavGrowTable(
    IN  PDAV_USERS_OBJECT DavUsers
    );

LPWSTR
DavReturnSessionPath(
    IN  LPWSTR LocalDeviceName
    );

NET_API_STATUS
DavAddUse(
    IN PLUID LogonId,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    );

VOID
DavFindInsertLocation(
    IN PDAV_USE_ENTRY UseList,
    IN LPWSTR UncName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *InsertPointer
    );

NET_API_STATUS
DavCreateNewEntry(
    OUT PDAV_USE_ENTRY *NewUse,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName OPTIONAL,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    );

NET_API_STATUS
DavFindUse(
    IN  PLUID LogonId,
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR UseName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer OPTIONAL
    );

VOID
DavFindLocal(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPTSTR Local,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    );

VOID
DavFindRemote(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPTSTR RemoteName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    );

NET_API_STATUS
DavDeleteUse(
    IN  PLUID LogonId,
    IN  DWORD ForceLevel,
    IN  PDAV_USE_ENTRY MatchedPointer,
    IN  DWORD Index
    );

VOID
DavInitializeAndInsertTheServerShareEntry(
    IN OUT PDAV_SERVER_SHARE_ENTRY ServerShareEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    );

BOOL 
DavIsServerInServerShareTable(
    IN PWCHAR ServerName,
    OUT PDAV_SERVER_SHARE_ENTRY *ServerShEntry
    );

DWORD
DavGetShareListFromServer(
    PDAV_SERVER_SHARE_ENTRY ServerShEntry
    );

BOOL
DavCheckTheNonDAVServerList(
    PWCHAR ServerName
    );

//
// DAV Use Table.
//
DAV_USERS_OBJECT DavUseObject;

//
// The hash table of DAV_SERVER_SHARE_TABLE entries. This is hashed on the 
// server name.
//
LIST_ENTRY ServerShareTable[SERVER_SHARE_TABLE_SIZE];

CRITICAL_SECTION ServerShareTableLock;

//
// Number of users logged on to the system. The Critical section below it
// synchronizes the acces to this variable.
//
ULONG DavNumberOfLoggedOnUsers = 0;
CRITICAL_SECTION DavLoggedOnUsersLock;

//
// Whenever we encounter a server that does not speak the DAV protocol in the
// DavrDoesServerDoDav function, we add it to the NonDAVServerList. An entry
// is kept on this list for ServerNotFoundCacheLifeTimeInSec (a global read
// from the registry during service start-up). Before going on the network
// to figure out whether a server does DAV, we look in the list to see if we
// have already seen this server (which does not do DAV) and fail the call.
//
LIST_ENTRY NonDAVServerList;
CRITICAL_SECTION NonDAVServerListLock = {0};

//
// Implementation of functions begins here.
//

DWORD
DavrCreateConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

Arguments:

    dav_binding_h - The explicit RPC binding handle.

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
                 of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
               server.  The password should be encoded with DAV_ENCODE_SEED.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR -
    
    ERROR_INVALID_HANDLE - 
    
    ERROR_INVALID_PARAMETER -
    
    ERROR_ALREADY_ASSIGNED - Local DOS device name is already in use.
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_INVALID_PASSWORD - Invalid password.

--*/
{
    DWORD dwErr = NO_ERROR;
    ULONG SessionId;
    LUID LogonId;
    BOOLEAN createdLink = FALSE;
    HANDLE TreeConnection = INVALID_HANDLE_VALUE;
    LPWSTR Unc = NULL;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR LocalDriveName = NULL;
    DWORD LocalLength = 0, UncLength = 0;
    UNICODE_STRING EncodedPassword;
    UNICODE_STRING TreeConnectStr;
    LPWSTR Session = NULL;
    LPWSTR Cookie = NULL;
    LPWSTR UserNameBuffer = NULL;
    DWORD  UserNameLength = 0;

    DavPrint((DEBUG_MISC,
              "DavrCreateConnection: Entered. Local = %ws, Remote = %ws\n",
              LocalName, RemoteName));
    
    EncodedPassword.Length = 0;
    
    TreeConnectStr.Buffer = NULL;
    TreeConnectStr.Length = TreeConnectStr.MaximumLength = 0;

    //
    // If the RemoteName is not valid, we return right away.
    //
    if ( RemoteName == NULL || RemoteName[0] != L'\\' || RemoteName[1] != L'\\' ) {
        dwErr = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "DavrCreateConnection: RemoteName == NULL\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If a LocalName has been specified, its always of the format X: and so its
    // 3 WCHARS long including the final '\0'.
    //
    if (LocalName) {
        
        DavPrint((DEBUG_MISC,
                  "DavrCreateConnection: Local = %ws, Remote = %ws\n",
                  LocalName, RemoteName));

        LocalLength = 3;
        
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( LocalName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrCreateConnection/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrCreateConnection: LocalDrive = %ws\n", &localDrive[0]));

        LocalDriveName = &localDrive[0];
    
    }

    if (Type != RESOURCETYPE_ANY && Type != RESOURCETYPE_DISK) {
        dwErr = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid Type.\n"));
        goto EXIT_THE_FUNCTION;
    }

#if 0
    //
    // Decode the password.
    //
    if (Password != NULL) {
        RtlInitUnicodeString(&EncodedPassword, Password);
        RtlRunDecodeUnicodeString(DAV_ENCODE_SEED, &EncodedPassword);
    }
#endif

    if (UserName != NULL) {
        
        // 
        // We want to use local copy of buffer name. We don't want to
        // alter original UserName buffer passed else constant UserName buffer
        // passed will result in exception.
        //
        UserNameLength = wcslen(UserName);
        UserNameBuffer = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                     (UserNameLength + 1) * sizeof(WCHAR) );
        if (!UserNameBuffer) {
             dwErr = GetLastError();
             DavPrint((DEBUG_ERRORS,
                       "DavrCreateConnection/LocalAlloc. Error Val = %d\n",
                       dwErr));
             goto EXIT_THE_FUNCTION;
        }
        
        wcscpy(UserNameBuffer, UserName);

        // 
        // Check if the UserName passed is valid. If it is, then we will use
        // local buffer as it is for further use. Else we will copy modified
        // version of name in local buffer.
        //
        if ( !IS_VALID_USERNAME_TOKEN(UserName, UserNameLength) ) {
            
            DWORD BlackSlashOffset = 0;
            BOOL BackSlashFound = FALSE;

            for (BlackSlashOffset = 0; BlackSlashOffset < UserNameLength; BlackSlashOffset++) {
                if (UserName[BlackSlashOffset] == L'\\') {
                    BackSlashFound = TRUE;
                    break;
                }
            }

            if (BackSlashFound) {
                
                //
                // Replace the UserName in the form of Domain\User with the form 
                // of User@Domain, which can be accepted by WinInet.
                //

                RtlCopyMemory(UserNameBuffer,
                              &(UserName[BlackSlashOffset+1]),
                              (UserNameLength-BlackSlashOffset-1)*sizeof(WCHAR));
                
                UserNameBuffer[UserNameLength-BlackSlashOffset-1] = L'@';
                
                RtlCopyMemory(&(UserNameBuffer[UserNameLength-BlackSlashOffset]),
                              UserName,
                              BlackSlashOffset*sizeof(WCHAR));

                if (!IS_VALID_USERNAME_TOKEN(UserNameBuffer, UserNameLength)) {
                    DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid UserName\n"));
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto EXIT_THE_FUNCTION;
                }
            
            } else {
                DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid UserName\n"));
                dwErr = ERROR_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }
        }
    }

    DavPrint((DEBUG_MISC, "DavrCreateConnection: UserName = %ws\n", UserNameBuffer));

    //
    // Check the remote name to ensure that has a proper syntax.
    //
    dwErr = DavCheckRemoteName(LocalDriveName, RemoteName, &Unc, NULL);
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavCheckRemoteName: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    UncLength = wcslen(Unc);
    DavPrint((DEBUG_MISC, "DavrCreateConnection: Unc = %ws\n", Unc));

    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrCreateConnection: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Impersonate caller and get the SessionId.
    //
    dwErr = DavImpersonateAndGetSessionId( &(SessionId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavImpersonateAndGetSessionId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrCreateConnection: SessionId = %d\n", SessionId));
    
    //
    // Now we create an NT-style tree connection name.
    //
    dwErr = DavCreateTreeConnectName(Unc, LocalDriveName, SessionId, &TreeConnectStr);
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavCreateTreeConnectName: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavrCreateConnection: TreeConnectStr = %wZ.\n",
              &(TreeConnectStr)));
    
    if (LocalDriveName) {
        
        //
        // Create symbolic link for local device name. If there are multiple
        // threads trying to do this, only one will succeed.
        //
        dwErr = DavCreateSymbolicLink(LocalDriveName,
                                      TreeConnectStr.Buffer,
                                      &Session);
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS,
                      "DavrCreateConnection/DavCreateSymbolicLink: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }
        
        createdLink = TRUE;
    
    }

    dwErr = DavOpenCreateConnection(&TreeConnectStr,
                                    UserNameBuffer,
                                    Password,
                                    Unc,
                                    SYNCHRONIZE,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_CREATE_TREE_CONNECTION,
                                    Type,
                                    &TreeConnection,
                                    NULL);

    if (dwErr == NO_ERROR) {
        HANDLE TempTreeConnection = INVALID_HANDLE_VALUE;

        //
        // Check whether the directory really exists. This is our way of
        // avoiding to write a lot of code in the kernel to check for a deep net use case
        //
        dwErr = DavOpenCreateConnection(&TreeConnectStr,
                                        NULL,
                                        NULL,
                                        Unc,
                                        SYNCHRONIZE |FILE_READ_DATA,
                                        FILE_OPEN,
                                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                                        Type,
                                        &TempTreeConnection,
                                        NULL);

        if (dwErr == NO_ERROR) {
            NtClose(TempTreeConnection);
        } else {
            NtClose(TreeConnection);
            TreeConnection = INVALID_HANDLE_VALUE;        
        }
    }
    
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavOpenCreateConnection: dwErr = %08lx\n",
                  dwErr));
        
        switch(dwErr) {
        case ERROR_NOT_CONNECTED:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_INVALID_NAME:
            dwErr = ERROR_BAD_NETPATH;
            break;
        case ERROR_CONNECTION_INVALID:
            dwErr = WN_BAD_NETNAME;
            break;
        }

        goto EXIT_THE_FUNCTION;
    }

    //
    // Add use to the Use Table. We want to always add a user name to the
    // UserEntry. So if a user name is not given explicitly, then we will use
    // the UserId of the client.
    //
    if (UserNameBuffer == NULL) {
        DWORD UserNameMaxLen = UserNameLength = (UNLEN + 1);
        UserNameBuffer = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                     (UserNameMaxLen + 1) * sizeof(WCHAR) );
        if (!UserNameBuffer) {
             dwErr = GetLastError();
             DavPrint((DEBUG_ERRORS,
                              "DavrCreateConnection/LocalAlloc. Error Val = %d.\n",
                              dwErr));
             goto EXIT_THE_FUNCTION;
        }
        dwErr = DavImpersonateAndGetUserId(UserNameBuffer, &UserNameMaxLen);
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrCreateConnection/DavImpersonateAndGetUserId: dwErr = %x\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }
    }

    ASSERT(UserNameBuffer);

    dwErr = DavAddUse( &(LogonId),
                       LocalDriveName,
                       LocalLength,
                       UserNameBuffer,
                       Unc,
                       UncLength,
                       &(TreeConnectStr),
                       TreeConnection );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavAddUse: dwErr = %08lx\n", dwErr));
    }

EXIT_THE_FUNCTION:

    if (createdLink && dwErr != NO_ERROR) {
        DWORD DeleteStatus;
        DeleteStatus = DavDeleteSymbolicLink(LocalDriveName,
                                             TreeConnectStr.Buffer,
                                             NULL);
    }

    //
    // If we failed after creating a handle then we need to close the handle
    // before leaving. Otherwise, this handle is closed when the connection is
    // deleted (in DavrCancelConnection).
    //
    if (TreeConnection != INVALID_HANDLE_VALUE && dwErr != NO_ERROR) {
        NtClose(TreeConnection);
    }

    if (EncodedPassword.Length != 0) {
        UCHAR Seed = DAV_ENCODE_SEED;
        RtlRunEncodeUnicodeString(&Seed, &EncodedPassword);
    }
   
    if (UserNameBuffer != NULL) {
        LocalFree((HLOCAL)UserNameBuffer);
        UserNameBuffer = NULL;
    }

    if (TreeConnectStr.Buffer != NULL) {
        LocalFree((HLOCAL)TreeConnectStr.Buffer);
    }

    if (Session != NULL) {
        LocalFree( Session );
    }

    if (Unc != NULL) {
        LocalFree( Unc );
    }

    return dwErr;
}

DWORD
DavrDeleteConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR ConnectionName,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function deletes a remote connection to the network resource and 
    the symbolic link which was created between the network resource and the 
    local device.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name
                     if it is a UNC connection to delete.
    
    UseForce - If TRUE, the connection should be broken even if open files
               exist.

Return Value:

    WN_SUCCESS - Successful. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_OPEN_FILES - fForce is FALSE and there are opened files on the 
                       connection.
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToDelete = NULL;
    DWORD ForceLevel;
    LUID LogonId; // Logon Id of user.
    ULONG Index;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;
    
    DavPrint((DEBUG_MISC, "DavrDeleteConnection: Entered. ConnectionName = "
              "%ws\n", ConnectionName));
    
    ForceLevel = (UseForce ? USE_LOTS_OF_FORCE : USE_NOFORCE);

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if(ConnectionName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
        
    }

    //
    // The ConnectionName could be local or remote.
    //
    if ( ConnectionName[0] != L'\\' ) {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrDeleteConnection/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrDeleteConnection: LocalDrive = %ws\n", 
                  &localDrive[0]));

        NameToDelete = &localDrive[0];

    } else {

        //
        // This is a remote name.
        //
        NameToDelete = ConnectionName;

    }
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrDeleteConnection: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
    } else {
        UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;
    }

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToDelete,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavFindUse: dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }

    if (MatchedPointer == NULL) {
        DavPrint((DEBUG_MISC,
                  "DavrDeleteConnection: UseName has an implicit connection.\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Delete tree connection and remove use entry from Dav Use Table.
    //
    dwErr = DavDeleteUse( &(LogonId), ForceLevel, MatchedPointer, Index );
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavDeleteUse: dwErr = %08lx\n", dwErr));
    }
    
EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavrConnectionExist(
    IN handle_t dav_binding_h,
    IN LPWSTR ConnectionName
    )
/*++

Routine Description:

    This function finds if given connection exists. Given connection can be a
    local DOS device name or it can be a remote UNC connection name.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name.
    
Return Value:

    WN_SUCCESS - If connection exist. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToQuery = NULL;
    LUID LogonId; // Logon Id of user.
    ULONG Index = 0;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;
    
    DavPrint((DEBUG_MISC,
              "DavrConnectionExist: Entered. ConnectionName = %ws\n",
              ConnectionName));

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if(ConnectionName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
        
    }

    //
    // The ConnectionName could be local or remote.
    //
    if ( ConnectionName[0] != L'\\' ) {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &(localDrive[0]) );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrConnectionExist/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC,
                  "DavrConnectionExist: LocalDrive = %ws\n",
                  &(localDrive[0])));

        NameToQuery = &(localDrive[0]);

    } else {

        //
        // This is a remote name.
        //
        NameToQuery = ConnectionName;

    }
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC,
              "DavrConnectionExist: LogonId = %d %d\n",
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToQuery,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/DavFindUse: dwErr = %08lx\n", dwErr));
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(MatchedPointer != NULL);
    
    DavPrint((DEBUG_MISC, 
              "DavrConnectionExist. AuthUserName = %ws, AuthUserNameLen = %d\n", 
              MatchedPointer->AuthUserName,MatchedPointer->AuthUserNameLength));

    dwErr = WN_SUCCESS;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
        ResAcquired = FALSE;
    }

    return dwErr;
}


DWORD
DavrGetUser(
    IN handle_t dav_binding_h,
    IN OUT LPDWORD UserNameLength,
    IN LPWSTR ConnectionName,
    OUT LPWSTR UserName
    )
/*++

Routine Description:

    This function returns the UserName that mapped a given connection.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    UserNameLength - The length of the UserName buffer.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name.
    
    UserName - The buffer where the UserName will be filled.

Return Value:

    WN_SUCCESS - If connection exist. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

    NERR_UserNotFound - Connection is found, but User name not found in it.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToQuery = NULL;
    LUID LogonId; // Logon Id of user.
    ULONG Index = 0;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;

    DavPrint((DEBUG_MISC,
              "DavrGetUser: Entered. UserNameLength= %d, ConnectionName = %ws\n",
              *UserNameLength, ConnectionName));

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if( (ConnectionName == NULL || UserNameLength == NULL ||
         (UserName == NULL && *UserNameLength != 0)) ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The ConnectionName could be local or remote.
    //
    if ( ConnectionName[0] != L'\\' ) {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrGetUser/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrGetUser: LocalDrive = %ws\n", 
                  &localDrive[0]));

        NameToQuery = &localDrive[0];

    } else {

        //
        // This is a remote name.
        //
        NameToQuery = ConnectionName;

    }
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/DavImpersonateAndGetLogonId: "
                  "dwErr = %x\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC,
              "DavrGetUser: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToQuery,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/DavFindUse: dwErr = %08lx\n", dwErr));
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(MatchedPointer != NULL);
    
    DavPrint((DEBUG_MISC, 
              "DavrGetUser. AuthUserName=%ws, AuthUserNameLen=%d\n", 
              MatchedPointer->AuthUserName,MatchedPointer->AuthUserNameLength));

    if ( MatchedPointer->AuthUserName == NULL ) {
        // 
        // We are always storing a user name when adding connection. So we should always
        // have a user name.
        //
        ASSERT(FALSE);
        dwErr = NERR_UserNotFound;
        DavPrint((DEBUG_ERRORS, "DavrGetUser:MatchedPointer->AuthUserName == NULL."
                                "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }

    if( (*UserNameLength < MatchedPointer->AuthUserNameLength) ) {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser: RequiredLength = %d, SuppliedName = %d. dwErr = %08lx\n",
                  MatchedPointer->AuthUserNameLength, *UserNameLength, dwErr));
        *UserNameLength = MatchedPointer->AuthUserNameLength;
        goto EXIT_THE_FUNCTION;
    }
    
    wcscpy(UserName, MatchedPointer->AuthUserName);
    
    DavPrint((DEBUG_MISC,
              "DavrGetUser: Successful. ConnectionName = "
              "0x%x, %ws, UserNameLength=0x%x, *UserNameLength = %d,"
              "UserName=0x%x, %ws\n", ConnectionName, ConnectionName, 
              UserNameLength, *UserNameLength,
              UserName, UserName));

    dwErr = WN_SUCCESS;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
        ResAcquired = FALSE;
    }

    return dwErr;
}


DWORD
DavrDoesServerDoDav(
    IN handle_t dav_binding_h,
    IN LPWSTR lpServerName,
    OUT PBOOLEAN DoesDav
    )
/*++

Routine Description:

    This routine checks whether the ServerName passed in is a valid DAV server.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    lpServerName - The name of the Server to query.
    
    DoesDav - TRUE if a the server is a DAV server, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE, fIsDav = FALSE;
    PWCHAR DataBuff = NULL;
    DWORD DataBuffBytes = 0;
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
    WCHAR DavCustomBuffer[100];
    BOOL bStatus = TRUE, revert = FALSE;

    DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: ServerName = %ws\n", lpServerName));

    //
    // Go through the NonDAVServerList to see if we have an entry for this
    // server. If we do then we need not go on the network. We can fail this
    // call (return server does not speak DAV) right away. Before we call 
    // DavCheckTheNonDAVServerList, we need to take the lock that synchronizes
    // it (NonDAVServerListLock).
    //
    EnterCriticalSection( &(NonDAVServerListLock) );
    ReturnVal = DavCheckTheNonDAVServerList(lpServerName);
    LeaveCriticalSection( &(NonDAVServerListLock) );

    //
    // If we found an entry (implies ReturnVal == TRUE) for this ServerName in
    // the list of servers that do not speak DAV, we return from here.
    //
    if (ReturnVal) {
        WStatus = NO_ERROR;
        *DoesDav = FALSE;
        return WStatus;
    }

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDoesServerDoDav/DavImpersonateClient: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    DavConnHandle = InternetConnectW(ISyncHandle,
                                     lpServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/InternetConnectW. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    bStatus = DavHttpOpenRequestW(DavConnHandle,
                                  L"OPTIONS",
                                  L"/",
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  0,
                                  L"DavrDoesServerDoDav",
                                  &DavOpenHandle);
    if(bStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpOpenRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpSendRequestExW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
        // is trying to authenticate itself with the server. If we get back
        // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
        // confirm that the redirect needs to be followed. In these scenarios,
        // we need to repeat the HttpSend and HttpEnd request calls.
        //
        if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
            goto RESEND_THE_REQUEST;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpEndRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/DavQueryAndParseResponse: WStatus = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We read the value of AcceptOfficeAndTahoeServers from the registry when
    // the WebClient service starts up. If this is set to 0, it means that we
    // should be rejecting OfficeWebServers, Tahoe servers and the shares on
    // these servers even though they speak DAV. We do this since WebFolders
    // needs to claim this name and Shell will only call into WebFolders if the
    // DAV Redir fails. If this value is non-zero, we accept all servers that
    // speak DAV.
    // 
    //
    if (AcceptOfficeAndTahoeServers == 0) {

        //
        // Figure out if this is an OFFICE Web Server. If it is then the response 
        // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
        // If this is an OFFICE share then we should not claim it since the user 
        // actually intends to use the OFFICE specific features in Shell.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
        OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(OfficeCustomHeaderLength), 
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                NTSTATUS NtStatus;
                //
                // First, covert wininet error to NtStatus.
                //
                NtStatus = DavMapErrorToNtStatus(WStatus);
                //
                // Now, convert NtStatus to a win32 error.
                //
                WStatus = RtlNtStatusToDosError(NtStatus);
                DavPrint((DEBUG_ERRORS, 
                          "DavrDoesServerDoDav/HttpQueryInfoW(1): Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: NOT OFFICE Web Server\n"));
            }
        } else {
            DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: OFFICE Web Server\n"));
            WStatus = ERROR_SUCCESS;
            *DoesDav = FALSE;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Figure out if this is a TAHOE server. If it is then the response will 
        // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
        // TAHOE server then we should not claim it since the user actually 
        // intends to use the TAHOE specific features in Rosebud.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
        TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(TahoeCustomHeaderLength),
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                NTSTATUS NtStatus;
                //
                // First, covert wininet error to NtStatus.
                //
                NtStatus = DavMapErrorToNtStatus(WStatus);
                //
                // Now, convert NtStatus to a win32 error.
                //
                WStatus = RtlNtStatusToDosError(NtStatus);
                DavPrint((DEBUG_ERRORS, 
                          "DavrDoesServerDoDav/HttpQueryInfoW(2): Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: NOT TAHOE Server\n"));
            }
        } else {
            DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: TAHOE Server\n"));
            WStatus = ERROR_SUCCESS;
            *DoesDav = FALSE;
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // This is NOT a TAHOE server nor an OFFICE Web Server. We go ahead and
    // query some other stuff from the header to make sure that this is a
    // DAV server.
    //

    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_RAW_HEADERS_CRLF,
                               DataBuff,
                               &(DataBuffBytes),
                               NULL);
    if (!ReturnVal) {
        WStatus = GetLastError();
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            DavPrint((DEBUG_ERRORS,
                      "DavrDoesServerDoDav/HttpQueryInfo(3). Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        } else {
            DavPrint((DEBUG_MISC,
                      "DavrDoesServerDoDav: HttpQueryInfo: Need Buff.\n"));
        }
    }

    //
    // Allocate memory for copying the header.
    //
    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_RAW_HEADERS_CRLF,
                               DataBuff,
                               &(DataBuffBytes),
                               NULL);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpQueryInfo(4). Error Val = "
                  "%d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see whether this server is a DAV server, Http Server etc.
    //
    DavObtainServerProperties(DataBuff, NULL, NULL, &fIsDav);

    //
    // NB!!!
    //
    *DoesDav = (BOOLEAN)fIsDav;

    WStatus = NO_ERROR;

EXIT_THE_FUNCTION:

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrDoesServerDoDav/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }

    if (DataBuff) {
        LocalFree(DataBuff);
    }

    //
    // If this Server is not a DAV server then we need to add it to the
    // NonDAVServerList to enable -ve caching. If WStatus is ERROR_ACCESS_DENIED
    // or ERROR_ LOGON_FAILURE, then we failed since the credentials were not
    // correct. That doesn't mean that this server is not a DAV server and hence
    // we don't add it to the NonDAVServerList.
    //
    if ( (WStatus != ERROR_SUCCESS && WStatus != ERROR_ACCESS_DENIED && WStatus != ERROR_LOGON_FAILURE) ||
         (WStatus == ERROR_SUCCESS && *DoesDav == FALSE) ) {

        PNON_DAV_SERVER_ENTRY NonDavServerEntry = NULL;

        NonDavServerEntry = LocalAlloc(LPTR, sizeof(NON_DAV_SERVER_ENTRY));
        if (NonDavServerEntry != NULL) {
            NonDavServerEntry->ServerName = LocalAlloc( LPTR, ((1 + wcslen(lpServerName)) * sizeof(WCHAR)) );
            if (NonDavServerEntry->ServerName != NULL) {
                wcscpy(NonDavServerEntry->ServerName, lpServerName);
                NonDavServerEntry->TimeValueInSec = time(NULL);
                EnterCriticalSection( &(NonDAVServerListLock) );
                InsertHeadList( &(NonDAVServerList), &(NonDavServerEntry->listEntry) );
                LeaveCriticalSection( &(NonDAVServerListLock) );
            } else {
                LocalFree(NonDavServerEntry);
                NonDavServerEntry = NULL;
            }
        }

    }

    return WStatus;
}


DWORD
DavrIsValidShare(
    IN handle_t dav_binding_h,
    IN PWCHAR ServerName,
    IN PWCHAR ShareName,
    OUT PBOOLEAN ValidShare
    )
/*++

Routine Description:

    This routine checks whether the ShareName is a valid share of the server
    ServerName.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ServerName - The name of the Server.
    
    ShareName - The share whose validity has to be checked.
    
    ValidShare - TRUE if a the share is valid, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    BOOL CricSec = FALSE, doesServerExist = FALSE, ReturnVal = FALSE;
    PDAV_SERVER_SHARE_ENTRY ServerShareEntry = NULL;
    DWORD TotalLength = 0;
    PLIST_ENTRY listEntry = NULL;
    PDAV_FILE_ATTRIBUTES ShareEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL EnCriSec = FALSE;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    LUID LogonId;
    BOOL bStatus = TRUE, revert = FALSE;
    WCHAR DavCustomBuffer[100];
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;

    DavPrint((DEBUG_MISC,
              "DavrIsValidShare: ServerName = %ws, ShareName = %ws\n",
              ServerName, ShareName));

    //
    // Check the ServerShareTable to see if we have an entry for this
    // server. Need to take a lock on the table before doing the check.
    //
    EnterCriticalSection( &(ServerShareTableLock) );
    CricSec = TRUE;

    doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));
    
    if (doesServerExist) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: doesServerExist = TRUE\n"));

        //
        // If the server entry exists, but is very old, we need to discard the
        // list of shares that are hanging of this entry since they could have
        // changed.
        //

        if (ServerShareEntry->DavShareList) {

            if ( ( time(NULL) - ServerShareEntry->TimeValueInSec ) > 6000 ) {

                DavPrint((DEBUG_MISC, "DavrIsValidShare: ServerEntry is OLD\n"));

                //
                // We need to go to the server again.
                //
                DavFinalizeFileAttributesList(ServerShareEntry->DavShareList, TRUE);

                ServerShareEntry->DavShareList = NULL;

            }

        }

    }

    //
    // If we have an entry for this server and the share list is not NULL
    // then we will check thru this shares list. If we don't find the share,
    // then we will do a PROPFIND against this share name and figure out if it
    // exists on the server. This is because the server may NOT support the 
    // enumeration of shares at the root level OR a share might not exist in 
    // this list since it has been recently created on the server.
    //
    if (ServerShareEntry != NULL && ServerShareEntry->DavShareList != NULL ) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: Loop the share list\n"));
        
        //
        // We need to hold onto the critical section while looping through the
        // list of shares.
        //

        listEntry = &(ServerShareEntry->DavShareList->NextEntry);

        do {

            ShareEntry = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

            DavPrint((DEBUG_MISC, 
                      "DavrIsValidShare: FileName = %ws\n", ShareEntry->FileName));
        
            //
            // We are not interested in files.
            //
            if (ShareEntry->isCollection == FALSE) {
                listEntry = listEntry->Flink;
                continue;
            }

            //
            // This is a share. See if it is the same as the share passed in.
            // The comparison should be case insensitive.
            //
            if ( _wcsicmp(ShareEntry->FileName, ShareName) == 0 ) {
                DavPrint((DEBUG_MISC, 
                          "DavrIsValidShare: ShareName = %ws. Found!!\n", ShareName));
                *ValidShare = TRUE;
                WStatus = NO_ERROR;
                goto EXIT_THE_FUNCTION;
            }

            listEntry = listEntry->Flink;

        } while ( listEntry != &(ServerShareEntry->DavShareList->NextEntry) );
        //
        // If we come here, it implies that we are done looking at all the shares
        // and a match was not found.
        //
        *ValidShare = FALSE;
        WStatus = NO_ERROR;

    } else {
        *ValidShare = FALSE;
        WStatus = NO_ERROR;
    }

    ASSERT(*ValidShare == FALSE);
    ASSERT(WStatus == NO_ERROR);


    //
    // If we don't have an entry for this server or is the ShareList is NULL or
    // if we don't find this share in the shareList of this server, then we do
    // a PROPFIND against this share name and figure out if it exists on the
    // server.
    //
    
    //
    // We need to leave the CriticalSection now since we are going to go
    // over the network to figure out if a share by this name exists on the
    // server. Since we are finding this out, we can allow other threads
    // to come and look at the ServerShareTable.
    //
    LeaveCriticalSection( &(ServerShareTableLock) );
    CricSec = FALSE;

    if ( *ValidShare == FALSE && WStatus == NO_ERROR ) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: Send PROPFIND\n"));

        //
        // Impersonate caller and get the LogonId. We need this to figure out
        // whether we need to attach a cookie later on.
        //
        WStatus = DavImpersonateAndGetLogonId( &(LogonId) );
        if (WStatus != NOERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavImpersonateAndGetLogonId: "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        //
        // We need to impersonate the client since we are calling into WinInet.
        //

        WStatus = DavImpersonateClient();
        if (WStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavImpersonateClient: WStatus = %08lx\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        revert = TRUE;

        DavConnHandle = InternetConnectW(ISyncHandle,
                                         ServerName,
                                         INTERNET_DEFAULT_HTTP_PORT,
                                         NULL,
                                         NULL,
                                         INTERNET_SERVICE_HTTP,
                                         0,
                                         0);
        if (DavConnHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/InternetConnectW. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // To find out if this is a valid share, we issue a PROPFIND against
        // this ShareName.
        //

        bStatus = DavHttpOpenRequestW(DavConnHandle,
                                      L"PROPFIND",
                                      ShareName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      0,
                                      L"DavIsValidShare",
                                      &DavOpenHandle);
        if(bStatus == FALSE) {
                WStatus = GetLastError();
                goto EXIT_THE_FUNCTION;
        }
        if (DavOpenHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpOpenRequestW. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to figure out if we need to add any cookies for the MSN
        // scenario.
        //

        EnterCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = TRUE;

        ReturnVal = DavIsThisServerInTheTable(ServerName, &(ServerHashEntry));

        if (ReturnVal) {
        
            ASSERT(ServerHashEntry != NULL);
            
            ReturnVal = DavDoesUserEntryExist(ServerName,
                                              ServerHashEntry->ServerID,
                                              &(LogonId),
                                              &(PerUserEntry),
                                              &(ServerHashEntry));

            if (ReturnVal) {
            
                ASSERT(PerUserEntry != NULL);

                if (PerUserEntry->Cookie != NULL) {
                
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: Adding Cookie\n"));
                    
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       PerUserEntry->Cookie,
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavrIsValidShare/HttpAddRequestHeadersW: "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                
                }

            }

        }
        
        //
        // We don't need to hold this critical section any longer.
        //
        if (EnCriSec) {
            LeaveCriticalSection(&(HashServerEntryTableLock) );
            EnCriSec = FALSE;
        }

        //
        // Since all we need to do is figure out if this share exists, we set 
        // the depth header to 0.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"Depth: 0\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to add the header "translate:f" to tell IIS that it should 
        // allow the user to excecute this VERB on the specified path which it 
        // would not allow (in some cases) otherwise. Finally, there is a special 
        // flag in the metabase to allow for uploading of "dangerous" content 
        // (anything that can be run on the server). This is the ScriptSourceAccess
        // flag in the UI or the AccessSource flag in the metabase. You will need
        // to set this bit to true as well as correct NT ACLs in order to be able
        // to upload .exes or anything executable.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"translate: f\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

RESEND_THE_REQUEST:

        ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
        if (!ReturnVal) {
            WStatus = GetLastError();
            //
            // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
            // following call so that WinInet picks up the correct proxy settings
            // if they have changed. This is because we do call InternetOpen
            // (to create a global handle from which every other handle is derived)
            // when the service starts and this could be before the user logon
            // happpens. In such a case the HKCU would not have been initialized
            // and WinInet wouldn't get the correct proxy settings.
            //
            if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
                InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
            }
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpSendRequestExW. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
        if (!ReturnVal) {
            WStatus = GetLastError();
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
            // is trying to authenticate itself with the server. If we get back
            // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
            // confirm that the redirect needs to be followed. In these scenarios,
            // we need to repeat the HttpSend and HttpEnd request calls.
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
                goto RESEND_THE_REQUEST;
            }
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpEndRequestW. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Query the response the server sent to see if this share exists. We
        // don't need to parse the XML response that gets returned for this
        // PROPFIND request since all that we are interested in is to find out 
        // if this share exists, not what its properties are.
        //
        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpEndRequestW. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We read the value of AcceptOfficeAndTahoeServers from the registry when
        // the WebClient service starts up. If this is set to 0, it means that we
        // should be rejecting OfficeWebServers, Tahoe servers and the shares on
        // these servers even though they speak DAV. We do this since WebFolders
        // needs to claim this name and Shell will only call into WebFolders if the
        // DAV Redir fails. If this value is non-zero, we accept all servers that
        // speak DAV.
        // 
        //
        if (AcceptOfficeAndTahoeServers == 0) {

            //
            // Figure out if this is an OFFICE Web Share. If it is then the response 
            // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
            // If this is an OFFICE share then we should not claim it since the user 
            // actually intends to use the OFFICE specific features in Shell.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
            OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(OfficeCustomHeaderLength), 
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    NTSTATUS NtStatus;
                    //
                    // First, covert wininet error to NtStatus.
                    //
                    NtStatus = DavMapErrorToNtStatus(WStatus);
                    //
                    // Now, convert NtStatus to a win32 error.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    DavPrint((DEBUG_ERRORS, 
                              "DavrIsValidShare/HttpQueryInfoW(1): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: NOT OFFICE Web Share\n"));
                }
            } else {
                DavPrint((DEBUG_MISC, "DavrIsValidShare: OFFICE Web Share\n"));
                WStatus = ERROR_BAD_NET_NAME;
                goto EXIT_THE_FUNCTION;
            }
    
            //
            // Figure out if this is a TAHOE share. If it is then the response will 
            // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
            // TAHOE server then we should not claim it since the user actually 
            // intends to use the TAHOE specific features in Rosebud.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
            TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(TahoeCustomHeaderLength),
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    NTSTATUS NtStatus;
                    //
                    // First, covert wininet error to NtStatus.
                    //
                    NtStatus = DavMapErrorToNtStatus(WStatus);
                    //
                    // Now, convert NtStatus to a win32 error.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    DavPrint((DEBUG_ERRORS, 
                              "DavrIsValidShare/HttpQueryInfoW(2): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: NOT TAHOE Share\n"));
                }
            } else {
                DavPrint((DEBUG_MISC, "DavrIsValidShare: TAHOE Share\n"));
                WStatus = ERROR_BAD_NET_NAME;
                goto EXIT_THE_FUNCTION;
            }

        }

        //
        // If we've come here, it implies that this share exists on the server.
        //
        DavPrint((DEBUG_MISC, "DavrIsValidShare: ShareName = %ws. Exists!!\n", ShareName));
        *ValidShare = TRUE;
        WStatus = NO_ERROR;

    }

EXIT_THE_FUNCTION:

    //
    // If we are returning failure, we set ValidShare to FALSE.
    //
    if (WStatus != NO_ERROR) {
        *ValidShare = FALSE;
    }

    if (CricSec) {
        LeaveCriticalSection( &(ServerShareTableLock) );
        CricSec = FALSE;
    }

    if (EnCriSec) {
        LeaveCriticalSection(&(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
        DavOpenHandle = NULL;
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
        DavConnHandle = NULL;
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }
    
    return WStatus;
}


DWORD
DavrGetConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR lpLocalName,
    OUT LPWSTR lpRemoteName,
    IN OUT LPDWORD lpBufferSize,
    OUT PBOOLEAN Connected
    )
/*++

Routine Description:

    This routine checks whether the LocalName passed in is mapped to a network
    drive. If it is, then the RemoteName buffer is filled in with the remote
    name the Local drive is mapped to.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    lpLocalName - The Local device name to be checked.
    
    lpRemoteName - Buffer to fill in the remote name if the local name is
                   connected.
    
    lpBufferSize - Size of the RemoteName buffer.
    
    Connected - TRUE if a connection exists, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD dwErr = NO_ERROR;
    BOOLEAN ResAcquired = FALSE;
    DWORD index = 0;
    PDAV_USE_ENTRY DavUseEntry = NULL;
    LUID LogonId; // Logon Id of user.

    DavPrint((DEBUG_MISC, "DavrGetConnection: lpLocalName = %ws\n", lpLocalName));
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetConnection/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC,
              "DavrGetConnection: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to query.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetConnection/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(index), FALSE );
    if (dwErr != NERR_Success) {
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }
    
    DavUseEntry = (PDAV_USE_ENTRY) DavUseObject.Table[index].List;

    while (DavUseEntry != NULL) {

        //
        // If this connection has no local name, then we just continue.
        //
        if (DavUseEntry->Local == NULL) {
            DavUseEntry = DavUseEntry->Next;
            continue;
       }

       if ( _wcsicmp(DavUseEntry->Local, lpLocalName) == 0 ) {
         
           //
           // We found a remote name that is associated with a LocalName
           // on this machine. 
           //
           if(Connected != NULL) {
               *Connected = TRUE;
           }
           if(lpBufferSize == NULL) {
               dwErr = ERROR_INVALID_PARAMETER;
               goto EXIT_THE_FUNCTION;
           }

           //
           // We now need to see if the Buffer supplied is large enough to 
           // hold the Remote name. If it is not, then we return 
           // WN_MORE_DATA to the calling app.
           //
           if ( (lpRemoteName == NULL ) || 
                ((DavUseEntry->Remote->UncNameLength + 1) > *lpBufferSize) ) {
              
                DavPrint((DEBUG_ERRORS, "DavrGetConnection: WN_MORE_DATA returned\n"));
                    
                *lpBufferSize = (DavUseEntry->Remote->UncNameLength + 1);

                dwErr = WN_MORE_DATA;
                
                goto EXIT_THE_FUNCTION;

           } else {

                //
                // The Buffer is large enough to copy the RemoteName. Copy
                // it and return SUCCESS to the caller.
                //
                wcscpy(lpRemoteName, (LPWSTR)DavUseEntry->Remote->UncName);
                lpRemoteName[DavUseEntry->Remote->UncNameLength] = L'\0';

                DavPrint((DEBUG_MISC,
                          "DavrGetConnection: FOUND!!! LocalName = %ws,"
                          " RemoteName = %ws\n", lpLocalName, lpRemoteName));
                
                dwErr = NO_ERROR;
            
                goto EXIT_THE_FUNCTION;

            }

        }

        DavUseEntry = DavUseEntry->Next;
    
    } // end while

    // 
    // The use is not found after while loop.
    //
    dwErr = ERROR_NOT_FOUND;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavrEnumServers(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    IN OUT LPDWORD ServerNameMaxLen,
    OUT PWCHAR ServerName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Server names on accessed on this machine. This is called by 
    NPEnumResource on the client when it is enumerating all the DAV servers. One server 
    is returned per call.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    Note: Do not alter value of this entry outside this function - else it may result in 
    unexpected behavior of enumeration.

    ServerName - The server being returned.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    BOOL CricSec = FALSE, fPresent = FALSE, fDone = FALSE;
    PHASH_SERVER_ENTRY SHEntry = NULL;
    DWORD IndexCount = 0;
    PLIST_ENTRY listEntry = NULL;
    PWCHAR EntryServerName = NULL;
    DWORD EntryServerNameLen = 0;
    DWORD LookFromServerHashId = 0;
    DWORD IndexOfEntryInHashList = 0;
    DWORD EntryCount = 0;

    DavPrint((DEBUG_MISC,
              "DavrEnumServers: *EntryIndex = %u, *ServerNameMaxLen = %d,"
              " *Done = %d\n", *EntryIndex, *ServerNameMaxLen, *Done));

    if ( (EntryIndex == NULL || ServerNameMaxLen == NULL ||
                    Done == NULL || ( ServerName == NULL && *ServerNameMaxLen != 0)) ) {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "DavrEnumServers : Invalid parameters\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // To enumerate the servers - we have to go thru whole hash table.
    // This function can be called many time in one single enumeration operation,
    // each time with different EntryIndex to say: return next entry.
    // 
    // EntryIndex is used to indicate entry number to be returned from the whole list
    // of enumeration. It can start from 0: 0,1,2,...
    // In such case, to return any next server entry, we have to go thru all entries in 
    // hash table until the desired entry number is reached.
    //
    // To optimize here, we are using special coding of variable EntryIndex. In
    // this case it won't follow standard sequence 0,1,2,...
    // Rather:
    //        EntryIndex = SERVER_TABLE_SIZE * LookFromServerHashId + 
    //                                         IndexOfEntryInHashList
    // => Start looking from HashList of ServerHashId (LookFromServerHashId ), and return
    // entry number (IndexOfEntryInHashList) in this list. If this list don't
    // contain any entry of this number, then go to next HashList and so on...
    //
    // For first time, EntryIndex is 0 => Start from HashId = 0 in table, 
    // from first entry of it.
    //
    // Now IndexOfEntryInHashList = [0,...,MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID]
    //
    // So:
    //    LookFromServerHashId = EntryIndex / MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID
    //    IndexOfEntryInHashList = 
    //                           EntryIndex % MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID
    //
    // We are defining:
    //     MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID = Max(DWORD)/ SERVER_TABLE_SIZE
    //     Where Max(DWORD) = Maximum value of DWORD => (DWORD)(-1)
    //

    fPresent = FALSE;
    fDone = FALSE;
    *Done = FALSE;
    EntryCount = 0;

    if (ServerIDCount == 0) {
        *Done = TRUE;
        WStatus = NO_ERROR;
        DavPrint((DEBUG_MISC, "DavrEnumServers : No server entry in hash table\n"));
        goto EXIT_THE_FUNCTION;
    }


    LookFromServerHashId = (*EntryIndex) / MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID;
    IndexOfEntryInHashList = (*EntryIndex) % MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID;

    if (LookFromServerHashId >= SERVER_TABLE_SIZE) {
        WStatus = NO_ERROR;
        *Done = TRUE;
        DavPrint((DEBUG_MISC,
                  "DavrEnumServers : *EntryIndex OUTSIDE HashTable = %u\n",
                  *EntryIndex));
        goto EXIT_THE_FUNCTION;
    }

    EnterCriticalSection( &(HashServerEntryTableLock) );
    CricSec = TRUE;

    while (fDone == FALSE) {
        // 
        // Get Server entry of index = IndexOfEntryInHashList in the 
        // current Servers HashList.
        //
        IndexCount = 0;
        listEntry = ServerHashTable[LookFromServerHashId].Flink;
        while( listEntry != NULL && 
               listEntry != &(ServerHashTable[LookFromServerHashId]) && 
               IndexCount != IndexOfEntryInHashList ) {
            listEntry = listEntry->Flink;
            IndexCount++;
            EntryCount++;
        }
        if ( listEntry == NULL || listEntry == &(ServerHashTable[LookFromServerHashId]) ) {
            LookFromServerHashId ++;
            IndexOfEntryInHashList = 0;
            if (EntryCount >= ServerIDCount || LookFromServerHashId >= SERVER_TABLE_SIZE) {
                fDone = TRUE;
            }
        } else {
            SHEntry = CONTAINING_RECORD(listEntry, HASH_SERVER_ENTRY, ServerListEntry);
            // 
            // Check that the entry found is of DAV server.
            // If Yes, then return else move on to next entries.
            //
            if (SHEntry->isDavServer == TRUE) {
                fDone = TRUE;
                fPresent = TRUE;
            } else {
                LookFromServerHashId ++;
                IndexOfEntryInHashList = 0;
                if (LookFromServerHashId >= SERVER_TABLE_SIZE) {
                    fDone = TRUE;
                }
            }
        }
    }
    
    //
    // There could be no DAV servers accessed yet.
    //
    if (fPresent == FALSE) {
        DavPrint((DEBUG_MISC, "DavrEnumServers : No Servers found\n"));
        *Done = TRUE;
        WStatus = NO_ERROR;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Control comes here if a server of required *EntryIndex is found.
    // i.e. fPresent = TRUE.
    // 

    EntryServerName = SHEntry->ServerName;
    EntryServerNameLen = 2 + wcslen(EntryServerName) + 1; // 2 for L"\\" before name.

    ASSERT(EntryServerName != NULL);
    
    if ( EntryServerNameLen > *ServerNameMaxLen) {
        DavPrint((DEBUG_ERRORS,
              "DavrEnumServers: ServerName = %ws, RequiredLen=%d, SuppliedLen=%d\n", 
              EntryServerName, EntryServerNameLen, *ServerNameMaxLen));
        WStatus = ERROR_INSUFFICIENT_BUFFER;
        *ServerNameMaxLen = EntryServerNameLen;
        goto EXIT_THE_FUNCTION;
    }
            
    // 
    // We have to return UNC-server name.
    //
    wcscpy(ServerName, L"\\\\");
    wcscat(ServerName, EntryServerName);
    //
    // We return one entry at a time.
    //
    *EntryIndex = ((LookFromServerHashId * MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID) + 
                   IndexOfEntryInHashList + 
                   1); // for next entry.
    
    DavPrint((DEBUG_MISC,
              "DavrEnumServers: NextIndex = %u, ServerName = %ws\n",
              *EntryIndex, ServerName));
    
    WStatus = NO_ERROR;
    goto EXIT_THE_FUNCTION;
    
EXIT_THE_FUNCTION:

    if (CricSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;
    }

    return WStatus;
}


DWORD
DavrEnumShares(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    IN PWCHAR ServerName,
    OUT PWCHAR ShareName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Share names on this server. This is called by 
    NPEnumResource on the client when it is enumerating all the DAV shares
    on the server. One share is returned per call.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    LocalName - The Server whose shares are being enumerated.
    
    ShareName - The share being returned.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    BOOL CricSec = FALSE, doesServerExist = FALSE;
    PDAV_SERVER_SHARE_ENTRY ServerShareEntry = NULL;
    DWORD TotalLength, IndexCount = 0;
    PLIST_ENTRY listEntry = NULL;
    PDAV_FILE_ATTRIBUTES ShareEntry;

    DavPrint((DEBUG_MISC,
              "DavrEnumShares: Index = %d, ServerName = %ws\n",
              *EntryIndex, ServerName));

    //
    // Check the ServerShareTable to see if we have an entry for this
    // server. Need to take a lock on the table before doing the check.
    //
    EnterCriticalSection( &(ServerShareTableLock) );
    CricSec = TRUE;

    //
    // If we are starting the enumeration, we need to figure out the following:
    // 1. The server exists.
    // 2. If it does, whether the DavShareList is still valid.
    //
    if ( *EntryIndex == 0 ) {
    
        doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));

        if ( !doesServerExist ) {

            //
            // Create a new ServerShare entry for this server.
            //
            TotalLength = ( sizeof(DAV_SERVER_SHARE_ENTRY) + 
                            ( ( wcslen(ServerName) + 1 ) * sizeof(WCHAR) ) );

            ServerShareEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TotalLength);
            if (ServerShareEntry == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavrEnumShares/LocalAlloc. Error Val = %d.\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Initialize the ServerShare entry and insert it into the global 
            // ServerShareEntry table.
            //
            DavInitializeAndInsertTheServerShareEntry(ServerShareEntry,
                                                      ServerName,
                                                      TotalLength);

    
        } else {

            //
            // If the server entry exists, but is very old, we need to update it
            // by going to the server again.
            //

            if ( ( time(NULL) - ServerShareEntry->TimeValueInSec ) > 6000 ) {

                //
                // We need to go to the server again.
                //
                DavFinalizeFileAttributesList(ServerShareEntry->DavShareList, TRUE);

                ServerShareEntry->DavShareList = NULL;
            
            }

        }

    } else {

        doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));

        if (!doesServerExist) {
            ASSERT(FALSE);
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // If we don't have a list of shares, then we need to go to the server and 
    // get them.
    //
    if ( ServerShareEntry->DavShareList == NULL ) {
        
        ASSERT(*EntryIndex == 0);
        
        WStatus = DavGetShareListFromServer(ServerShareEntry);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavrEnumShares/DavGetShareListFromServer. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // There could be no shares exposed on the DAV server.
        //
        if (ServerShareEntry->NumOfShares == 0) {
            DavPrint((DEBUG_MISC,
                      "DavrEnumShares: ServerName = %ws. No Shares\n", ServerName));
            *Done = TRUE;
            WStatus = NO_ERROR;
            goto EXIT_THE_FUNCTION;
        }
    
    }

    listEntry = &(ServerShareEntry->DavShareList->NextEntry);

    do {

        ShareEntry = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

        //
        // We are not interested in files and the share /.
        //
        if (ShareEntry->isCollection == FALSE || 
            _wcsicmp(ShareEntry->FileName, L"/") == 0) {
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // We might have already returned a few share names.
        //
        if ( IndexCount < *EntryIndex ) {
            IndexCount++;
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // We haven't sent this one. Copy the share name and return.
        //
        wcscpy(ShareName, ShareEntry->FileName);

        //
        // We return one entry at a time.
        //
        WStatus = NO_ERROR;
        goto EXIT_THE_FUNCTION;

    } while ( listEntry != &(ServerShareEntry->DavShareList->NextEntry) );

    //
    // If we come here, it implies that we are done returning all the entries.
    //
    *Done = TRUE;
    WStatus = NO_ERROR;
    
EXIT_THE_FUNCTION:

    if (CricSec) {
        LeaveCriticalSection( &(ServerShareTableLock) );
    }

    return WStatus;
}


DWORD
DavrEnumNetUses(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    OUT PWCHAR LocalName,
    OUT PWCHAR RemoteName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Local and Remote names of a net use. This is 
    called by NPEnumResource on the client when it is enumerating all the net
    uses on the machine.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    LocalName - The LocalName of a net use.
    
    RemoteName - The RemoteName of a net use.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD dwErr = NO_ERROR;
    DWORD BeginIndex, IndexCount = 0, index;
    BOOLEAN ResAcquired = FALSE;
    PDAV_USE_ENTRY DavUseEntry = NULL;
    LUID LogonId;

    BeginIndex = *EntryIndex;
    
    DavPrint((DEBUG_MISC, "DavrEnumNetUses: BeginIndex = %d\n", BeginIndex));
    
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrEnumNetUses/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }

    if ( !RtlAcquireResourceExclusive(&DavUseObject.TableResource, TRUE) ) {
        dwErr = NERR_InternalError;
        DavPrint((DEBUG_ERRORS,
                  "DavrEnumNetUses/RtlAcquireResourceExclusive: Internal Error.\n"));
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // Go through the DAV_USE_ENTRY list of all the users.
    //
    for (index = 0; index < DavUseObject.TableSize; index++) {
    
        if ( !DavUseObject.Table[index].List ) {
            continue;
        }
        
        if (!RtlEqualLuid(&(DavUseObject.Table[index].LogonId), &LogonId)) {
            continue;
        }
        
        DavUseEntry = (PDAV_USE_ENTRY)DavUseObject.Table[index].List;

        while (DavUseEntry) {

            //
            // We could have returned a few entries already. BeginIndex gives
            // us the number of entries we have already returned. In this case, 
            // we should start from the first entry which was not returned.
            //
            if (IndexCount < BeginIndex) {
                IndexCount++;
                DavUseEntry = DavUseEntry->Next;
                continue;
            }

            //
            // The LocalName may or may not exist. The LocalNamelength already
            // includes the extra 1 for the '\0' in the end.
            //
            if (DavUseEntry->Local) {
                wcscpy(LocalName, DavUseEntry->Local);
                DavPrint((DEBUG_MISC, "DavrEnumNetUses: Local= %ws\n", LocalName));
            }

            //
            // Copy the RemoteName.
            //
            wcscpy(RemoteName, (LPWSTR)DavUseEntry->Remote->UncName);
            DavPrint((DEBUG_MISC, "DavrEnumNetUses: Remote = %ws\n", RemoteName));
            
            //
            // We return one pair of Local and Remote names at a time.
            //
            dwErr = NO_ERROR;
            goto EXIT_THE_FUNCTION;
        
        } // end while
    
    } // end for

    //
    // If we come here, it means that we are done sending all the net uses.
    //
    dwErr = NO_ERROR;
    *Done = TRUE;
    
EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavCheckLocalName(
    LPWSTR LocalName,
    PWCHAR OutputLocalDeviceBuffer
    )
/*++

Routine Description:

    This only handles NULL, empty string, and L"X:" formats.

Arguments:

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

    OutputLocalDeviceBuffer - The drive letter is copied into this and returned.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD LocalNameLength;

    LocalNameLength = ( LocalName == NULL ) ? 0 : wcslen( LocalName );

    if (LocalNameLength == 0) {
        *OutputLocalDeviceBuffer = L'\0';
        return ERROR_SUCCESS;
    }

    if (LocalNameLength != 2 || !iswalpha(*LocalName) || LocalName[1] != L':') {
        return ERROR_BAD_DEVICE;
    }

    lstrcpyW( OutputLocalDeviceBuffer, LocalName );
    
    _wcsupr( OutputLocalDeviceBuffer );

    return ERROR_SUCCESS;
}


DWORD
DavCheckRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine validates and canonicalizes the supplied
    UNC name.  It can be of any length in the form of:

        \\Server\Volume\Directory\Subdirectory

Arguments:

    LocalName - Supplies the local device name.  If it is NULL or empty, then
                \\Server is an acceptable format for the UNC name.

    RemoteName - Supplies the UNC name.

    OutputBuffer - Receives a pointer to the canonicalized RemoteName.

    OutputBufferLength - Receives the length of the canonicalized name in
                         number of characters, if specified.

Return Value:

    NO_ERROR - RemoteName is valid.

    WN_BAD_NETNAME - RemoteName is invalid.

--*/
{
    DWORD RemoteNameLength;
    DWORD i;
    DWORD TokenLength;
    LPWSTR TokenPtr = NULL;
    BOOL  fFirstToken = TRUE;
    BOOL  fLocalNamePresent = FALSE;

    //
    // If a LocalName was specified, we set fLocalNamePresent to TRUE.
    //
    if (LocalName) {
        fLocalNamePresent = TRUE;
    }

    DavPrint((DEBUG_MISC, "DavCheckRemoteName: fLocalNamePresent = %d\n", 
              fLocalNamePresent));
    
    //
    // The remote name cannot be a NULL or an empty string.
    //
    if (RemoteName == NULL || *RemoteName == 0) {
        return WN_BAD_NETNAME;
    }

    RemoteNameLength = wcslen(RemoteName);

    //
    // Must be at least \\x\y if local device name is specified. Otherwise it 
    // must be at least \\x.
    //
    if ( (RemoteNameLength < 5 && fLocalNamePresent) || (RemoteNameLength < 3) ) {
        return WN_BAD_NETNAME;
    }

    //
    // First two characters must be "\\"
    //
    if (*RemoteName != L'\\' || RemoteName[1] != L'\\') {
        return WN_BAD_NETNAME;
    }

    if (!fLocalNamePresent && (IS_VALID_SERVER_TOKEN(&RemoteName[2], RemoteNameLength - 2))) {

        //
        // Return success for \\Server case.
        //
        *OutputBuffer = (PVOID) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                           (RemoteNameLength + 1) * sizeof(WCHAR));
        if (*OutputBuffer == NULL) {
            KdPrint(("DAV: DAVCanonRemoteName LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*OutputBuffer, RemoteName);

        return NO_ERROR;
    }

    //
    // Must have at least one more backslash after the third character.
    //
    if (wcschr(&RemoteName[3], L'\\') == NULL) {
        return WN_BAD_NETNAME;
    }

    //
    // Last character cannot a backward slash.
    //
    if (RemoteName[RemoteNameLength - 1] == L'\\') {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the RemoteName
    // and space for an extra character to simplify parsing code below.
    //
    *OutputBuffer = (PVOID) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       (RemoteNameLength + 2) * sizeof(WCHAR));
    if (*OutputBuffer == NULL) {
        KdPrint(("DAV: DAVCanonRemoteName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, RemoteName);

    //
    // Convert all backslashes to NULL terminator, skipping first 2 chars.
    //
    for (i = 2; i < RemoteNameLength; i++) {
        
        if ((*OutputBuffer)[i] == L'\\') {

            (*OutputBuffer)[i] = 0;

            //
            // Two consecutive forward or backslashes is bad.
            //
            if ( ( (i + 1) < RemoteNameLength ) 
                 && ( (*OutputBuffer)[i + 1] == L'\\' ) ) {

                LocalFree((HLOCAL) *OutputBuffer);
                *OutputBuffer = NULL;
                return WN_BAD_NETNAME;
            }
        }
    }

    //
    // Validate each token of the RemoteName, separated by NULL terminator.
    //
    TokenPtr = *OutputBuffer + 2;  // Skip first 2 chars

    while (*TokenPtr != 0) {

        TokenLength = wcslen(TokenPtr);

        if ( ( fFirstToken && !IS_VALID_SERVER_TOKEN(TokenPtr, TokenLength)) ||
             ( !fFirstToken && !IS_VALID_TOKEN(TokenPtr, TokenLength)) ) {

            (void) LocalFree((HLOCAL) *OutputBuffer);
            *OutputBuffer = NULL;
            return WN_BAD_NETNAME;
        }

        fFirstToken = FALSE;
        TokenPtr += TokenLength + 1;
    }

    //
    // Convert NULL separators back to backslashes.
    //
    for (i = 0; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == 0) {
            (*OutputBuffer)[i] = L'\\';
        }
    }

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = RemoteNameLength;
    }

    return NO_ERROR;
}


DWORD
DavCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    IN ULONG SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    )
/*++

Routine Description:

    This function replaces \\ with \Device\DavRdr\LocalName:\ in the
    UncName to form the NT-style tree connection name.  LocalName:\ is part
    of the tree connection name only if LocalName is specified.  A buffer
    is allocated by this function and returned as the output string.

Arguments:

    UncName - Supplies the UNC name of the shared resource.

    LocalName - Supplies the local device name for the redirection.

    SessionId - Id that uniquely identifies a Hydra session. This value is 
                always 0 for non-hydra NT and console hydra session.

    TreeConnectStr - Returns a string with a newly allocated buffer that
                     contains the NT-style tree connection name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD UncNameLength = wcslen(UncName);
    BOOL  fLocalNamePresent = FALSE;
    WCHAR IdBuffer[18];
    UNICODE_STRING IdString;

    if ( g_LUIDDeviceMapsEnabled == TRUE ) {
        LUID LogonId;
        DWORD dwErr;

        dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateTreeConnectName/DavImpersonateAndGetLogonId: "
                      "dwErr = %08lx\n", dwErr));
            return (dwErr);
        }

        _snwprintf( IdBuffer,
                    sizeof(IdBuffer)/sizeof(WCHAR),
                    L"%08x%08x",
                    LogonId.HighPart,
                    LogonId.LowPart );

        RtlInitUnicodeString( &IdString, IdBuffer );
    }
    else {
        IdString.Length = 0;
        IdString.MaximumLength = sizeof(IdBuffer);
        IdString.Buffer = IdBuffer;

        RtlIntegerToUnicodeString(SessionId, 10, &IdString);
    }

    //
    // If a LocalName was specified, we set fLocalNamePresent to TRUE.
    //
    if (LocalName) {
        fLocalNamePresent = TRUE;
    }

    //
    // Initialize tree connect string maximum length to hold
    // "\Device\DavRdr\;LocalName:ID\Server\Volume\Path".
    // The ";Localname:ID" is done because that is what RDBSS expects. 
    // Its one of those legacy things!!!
    // If LUID DosDevice enabled, then ID = SessionId, else ID = LogonId
    //
    TreeConnectStr->MaximumLength = wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR);
    TreeConnectStr->MaximumLength += sizeof(WCHAR); // For '\'
    TreeConnectStr->MaximumLength += 
      (ARGUMENT_PRESENT(LocalName) ? (wcslen(LocalName) * sizeof(WCHAR)) : 0);
    
    //
    // Includes '\' and the term char.
    //
    TreeConnectStr->MaximumLength += (USHORT) ( UncNameLength * sizeof(WCHAR) );

    //
    // For ; in ";LocalName:ID".
    //
    TreeConnectStr->MaximumLength += sizeof(WCHAR);

    //
    // For the ID in ";LocalName:ID".
    //
    TreeConnectStr->MaximumLength += IdString.Length;
    
    TreeConnectStr->Buffer = (PWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                TreeConnectStr->MaximumLength);
    if (TreeConnectStr->Buffer == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavCreateTreeConnectName/LocalAlloc: WStatus = %08lx\n",
                  GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\DavRdr.
    //
    RtlCopyMemory(TreeConnectStr->Buffer, 
                  DD_DAV_DEVICE_NAME_U, 
                  ( wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR) ));

    TreeConnectStr->Length = ( wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR) );
    
    //
    // Concatenate "\;LocalName:ID".
    //
    if (fLocalNamePresent) {
        
        wcscat(TreeConnectStr->Buffer, L"\\");
        
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, L";");
        
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, LocalName);

        TreeConnectStr->Length += (USHORT) (wcslen(LocalName) * sizeof(WCHAR));
    
        RtlAppendUnicodeStringToString( TreeConnectStr, &IdString );
        
    }

    //
    // Concatenate \Server\Volume\Path.
    //
    wcscat(TreeConnectStr->Buffer, &UncName[1]);
    TreeConnectStr->Length += (USHORT) ((UncNameLength - 1) * sizeof(WCHAR));

    return NO_ERROR;
}


DWORD
DavOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function asks the redirector to either open an existing tree
    connection (CreateDisposition == FILE_OPEN), or create a new tree
    connection if one does not exist (CreateDisposition == FILE_CREATE).

    The password and user name passed to the redirector via the EA buffer
    in the NtCreateFile call.  The EA buffer is NULL if neither password
    or user name is specified.

    The redirector expects the EA descriptor strings to be in ANSI
    but the password and username themselves are in Unicode.
    
    We also add webdav signature string, which tells our redir that we
    are calling it

Arguments:

    TreeConnectionName - Supplies the name of the tree connection in NT-style
                         file name format: 
                         \Device\WebDavRedirector\Server\Volume\Directory

    UserName - Supplies the user name to create the tree connection with.

    Password - Supplies the password to create the tree connection with.

    DesiredAccess - Supplies the access need on the connection handle.

    CreateDisposition - Supplies the create disposition value to either
                        open or create the tree connection.

    CreateOptions - Supplies the options used when creating or opening
                    the tree connection.

    ConnectionType - Supplies the type of the connection (DISK, PRINT,
                     or ANY).

    TreeConnectionHandle - Returns the handle to the tree connection
                           created/opened by the redirector.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES UncNameAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea = NULL;
    ULONG EaBufferSize = 0;

    UCHAR EaNamePasswordSize = 
               (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                       ALIGN_WCHAR) - sizeof(CHAR));
    
    UCHAR EaNameUserNameSize = 
               (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                       ALIGN_WCHAR) - sizeof(CHAR));

    UCHAR EaNameTypeSize = 
                   (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                           ALIGN_DWORD) - sizeof(CHAR));

    UCHAR EaNameWebDavSignatureSize = 
                   (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_WEBDAV_SIGNATURE) + sizeof(CHAR),
                                           ALIGN_DWORD) - sizeof(CHAR));


    USHORT PasswordSize = 0;
    USHORT UserNameSize = 0;
    USHORT TypeSize = sizeof(ULONG);
    USHORT WebDavSignatureSize = 0;
    
    InitializeObjectAttributes(&UncNameAttributes,
                               TreeConnectionName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Calculate the number of bytes needed for the EA buffer to put the
    // password or user name.
    //
    if (ARGUMENT_PRESENT(Password)) {

        PasswordSize = (USHORT) (wcslen(Password) * sizeof(WCHAR));

        EaBufferSize = ROUND_UP_COUNT(
                           FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                           EaNamePasswordSize + sizeof(CHAR) +
                           PasswordSize,
                           ALIGN_DWORD
                           );
    }

    if (ARGUMENT_PRESENT(UserName)) {

        UserNameSize = (USHORT) (wcslen(UserName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameUserNameSize + sizeof(CHAR) +
                            UserNameSize,
                            ALIGN_DWORD
                            );
    }

    EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTypeSize + sizeof(CHAR) +
                            TypeSize,
                            ALIGN_DWORD
                        );

    // round up just so we get some slop                            
    EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameWebDavSignatureSize + sizeof(CHAR) +
                            WebDavSignatureSize,
                            ALIGN_DWORD
                        );

    //
    // Allocate the EA buffer.
    //
    EaBuffer = (PFILE_FULL_EA_INFORMATION) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                      EaBufferSize);
    if (EaBuffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/LocalAlloc: WStatus = %08lx\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(Password)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_PASSWORD);
        Ea->EaNameLength = EaNamePasswordSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy((LPWSTR) &(Ea->EaName[EaNamePasswordSize + sizeof(CHAR)]),
               Password);

        Ea->EaValueLength = PasswordSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNamePasswordSize + sizeof(CHAR) +
                                  PasswordSize,
                                  ALIGN_DWORD
                                  );

        Ea->Flags = 0;
        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(UserName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_USERNAME);
        Ea->EaNameLength = EaNameUserNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy((LPWSTR) &(Ea->EaName[EaNameUserNameSize + sizeof(CHAR)]),
               UserName);

        Ea->EaValueLength = UserNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameUserNameSize + sizeof(CHAR) +
                                  UserNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;

    }

    //
    // Copy the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //

    strcpy( (LPSTR)Ea->EaName, EA_NAME_TYPE );
    Ea->EaNameLength = EaNameTypeSize;
    
    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;
    Ea->EaValueLength = TypeSize;
    Ea->Flags = 0;

    Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameTypeSize + sizeof(CHAR) +
                                  TypeSize,
                                  ALIGN_DWORD
                                  );


    (ULONG_PTR) Ea += Ea->NextEntryOffset;

    strcpy( (LPSTR)Ea->EaName, EA_NAME_WEBDAV_SIGNATURE );
    Ea->EaNameLength = EaNameWebDavSignatureSize;
    Ea->EaValueLength = 0;
    
    //
    // Terminate the EA.
    //
    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/DavImpersonateClient: WStatus = "
                  "%08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create or open a tree connection.
    //
    NtStatus = NtCreateFile(TreeConnectionHandle,
                            DesiredAccess,
                            &UncNameAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_VALID_FLAGS,
                            CreateDisposition,
                            CreateOptions,
                            (PVOID) EaBuffer,
                            EaBufferSize);
    if (NtStatus != STATUS_SUCCESS) {
        
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/NtCreateFile: NtStatus = %08lx\n", 
                  NtStatus));
        
        WStatus = DavRevertToSelf();
        if (WStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenCreateConnection/DavRevertToSelf: WStatus = "
                      "%08lx\n", WStatus));
        }
        
        WStatus = WsMapStatus(NtStatus);

        goto EXIT_THE_FUNCTION;
    
    }

    WStatus = WsMapStatus(NtStatus);
    
    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    WStatus = DavRevertToSelf();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/DavRevertToSelf: WStatus = "
                  "%08lx\n", WStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Clear the password to prevent it from making it to pagefile and free the 
    // memory.
    //
    if (EaBuffer != NULL) {
        RtlZeroMemory( EaBuffer, EaBufferSize );
        LocalFree((HLOCAL) EaBuffer);
    }

    return WStatus;
}


ULONG
DavImpersonateAndGetUserId(
    LPWSTR UserName,
    LPDWORD UserNameMaxLen
    )
/*++

Routine Description:

    This function gets the user id of the current thread.

Arguments:

    UserName - Returns the user id of the current process.

    UserNameMaxLen - Pointer to variable containing max length of UserName passed
                     to this function. It will be set to the length of name filled
                     or required.

Return Value:

    Win32 Error - ERROR_SUCCESS or reason for failure.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOLEAN revert = FALSE;
    BOOL bStatus = FALSE;

    dwError = DavImpersonateClient();
    if (dwError != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetUserId/DavImpersonateClient: dwError = %x\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    // 
    // Get user name in the buffer passed to this function.
    //
    bStatus = GetUserName(UserName, UserNameMaxLen);
    if (bStatus != TRUE) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS, 
                 "DavImpersonateAndGetUserId/GetUserName: dwError = %x\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (revert) {
        dwError = DavRevertToSelf();
        if (dwError != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetUserId/DavRevertToSelf: dwError = %x\n",
                      dwError));
        }
    }

    return dwError;
}


ULONG
DavImpersonateAndGetSessionId(
    PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the current thread.

Arguments:

    pSessionId - Returns the session id of the current process.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NET_API_STATUS NetApiStatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;
    BOOLEAN revert = FALSE;
    DWORD   dwError = NO_ERROR;
    
    dwError = DavImpersonateClient();
    if (dwError != NO_ERROR) {
        NtStatus = DavMapErrorToNtStatus(dwError);
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetSessionId/DavImpersonateClient: "
                  "dwError = %08lx NtStatus = %08lx\n", dwError, NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    revert = TRUE;

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                 TOKEN_QUERY,
                                 TRUE,
                                 &(CurrentThreadToken));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavpImpersonateAndGetSessionId/NtOpenThreadToken."
                   " NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the Session Id of the current thread.
    //
    NtStatus = NtQueryInformationToken(CurrentThreadToken,
                                       TokenSessionId,
                                       &SessionId,
                                       sizeof(ULONG),
                                       &(ReturnLength));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavpImpersonateAndGetSessionId/NtQueryInformationToken."
                   " NtStatus = %08lx\n", NtStatus));
        NtClose(CurrentThreadToken);
        goto EXIT_THE_FUNCTION;
    }

    NtClose(CurrentThreadToken);

    *pSessionId = SessionId;

EXIT_THE_FUNCTION:

    if (revert) {
        NtStatus = DavRevertToSelf();
        if (NtStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetSessionId/DavRevertToSelf: "
                      "NtStatus = %08lx\n", NtStatus));
        }
    }

    NetApiStatus = NetpNtStatusToApiStatus(NtStatus);

    return NetApiStatus;
}


ULONG
DavImpersonateAndGetLogonId(
    PLUID pLogonId
    )
/*++

Routine Description:

    This function gets the Logon Id of the current thread.

Arguments:

    pLogonId - Returns the Logon Id of the current thread.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetApiStatus;
    HANDLE CurrentThreadToken;
    TOKEN_STATISTICS TokenStats;
    ULONG ReturnLength;
    BOOLEAN revert = FALSE;

    NtStatus = DavImpersonateClient();
    if (NtStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetLogonId/DavImpersonateClient: "
                  "NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                  TOKEN_QUERY,
                                  TRUE,
                                  &(CurrentThreadToken));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateAndGetLogonId/NtOpenThreadToken."
                   " NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the LogonId of the current thread.
    //
    NtStatus = NtQueryInformationToken(CurrentThreadToken,
                                       TokenStatistics,
                                       (PVOID) &TokenStats,
                                       sizeof(TokenStats),
                                       &ReturnLength);
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateAndGetLogonId/NtQueryInformationToken."
                   " NtStatus = %08lx\n", NtStatus));
        NtClose(CurrentThreadToken);
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyLuid( pLogonId, &(TokenStats.AuthenticationId) );

    NtClose(CurrentThreadToken);

EXIT_THE_FUNCTION:

    if (revert) {
        NtStatus = DavRevertToSelf();
        if (NtStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetLogonId/DavRevertToSelf: "
                      "NtStatus = %08lx\n", NtStatus));
        }
    }

    NetApiStatus = NetpNtStatusToApiStatus(NtStatus);

    return NetApiStatus;
}


DWORD
DavCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN OUT LPWSTR *Session
    )
/*++

Routine Description:

    This function creates a symbolic link object for the specified local
    device name which is linked to the tree connection name that has a
    format of \Device\DavRdr\Device:\Server\Volume\Directory.

Arguments:

    Local - Supplies the local device name.

    TreeConnectStr - Supplies the tree connection name string which is the
                     link target of the symbolick link object.

    Session - The Session Path is filled into this buffer.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD dwError = NO_ERROR;
    WCHAR TempBuf[64];
    DWORD Flags;
    BOOL revert = FALSE;

    //
    // Multiple session support.
    //
    *Session = DavReturnSessionPath(Local);
    if ( *Session == NULL ) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateSymbolicLink/DavReturnSessionPath: dwError = "
                  "%08lx\n", dwError));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavCreateSymbolicLink: *Session = %ws\n", *Session));

    if ( g_LUIDDeviceMapsEnabled == TRUE ) {
        dwError = DavImpersonateClient();

        if (dwError != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateSymbolicLink/DavImpersonateClient: "
                      "dwError = %08lx\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        revert = TRUE;
    }

    //
    // Local device is some X:.
    //
    if ( !QueryDosDeviceW( *Session, TempBuf, 64 ) ) {

        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            
            //
            // Most likely failure occurred because our output
            // buffer is too small. It still means someone already
            // has an existing symbolic link for this device.
            //
            dwError = ERROR_ALREADY_ASSIGNED;
            
            DavPrint((DEBUG_ERRORS,
                      "DavCreateSymbolicLink/QueryDosDeviceW: dwError = "
                      "%08lx\n", dwError));
            
            goto EXIT_THE_FUNCTION;
        
        }
    
        //
        // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
        // means it does not exist and we can redirect this device.
        //
    
    } else {
        
        //
        // QueryDosDevice successfully an existing symbolic link. Somebody is 
        // already using this device.
        //
        dwError = ERROR_ALREADY_ASSIGNED;
        
        DavPrint((DEBUG_ERRORS,
                  "DavCreateSymbolicLink/QueryDosDeviceW: Device already exists.\n"));
        
        goto EXIT_THE_FUNCTION;
    
    }

    Flags = (DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM);

    //
    // Create a symbolic link object to the device we are redirecting.
    //
    if ( !DefineDosDeviceW( Flags, *Session, TreeConnectStr ) ) {
        
        dwError = GetLastError();
        
        DavPrint((DEBUG_ERRORS,
                  "DavCreateSymbolicLink/DefineDosDeviceW: dwError = "
                  "%08lx\n", dwError));
        
    }

EXIT_THE_FUNCTION:

    if ( revert == TRUE ) {
        DWORD   dwErrLocal;
        dwErrLocal = DavRevertToSelf();
        if (dwErrLocal != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateSymbolicLink/DavRevertToSelf: "
                      "NtStatus = %08lx\n", dwErrLocal));
            dwError = dwErrLocal;
        }
    }

    return dwError;
}


DWORD
DavDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName
    )
/*++

Routine Description:

    This function deletes the symbolic link we had created earlier for
    the device.

Arguments:

    LocalDeviceName - Supplies the local device name string of which the
                      symbolic link object is created.

    TreeConnectStr - Supplies a pointer to the Unicode string which
                     contains the link target string we want to match and 
                     delete.
                     
    SessionDeviceName - Terminal Server Addition. This parameter is required 
                        because the device created is per session.

Return Value:

    Win32 Error value or NO_ERROR.

--*/
{
    DWORD WStatus = NO_ERROR;
    DWORD CallFlags = 0;
    BOOLEAN DeleteSession = FALSE;
    BOOL revert = FALSE;

    CallFlags = (DDD_REMOVE_DEFINITION | DDD_NO_BROADCAST_SYSTEM);

    //
    // If the Targetpath (TreeConnectStr) is specified, we need the following 
    // flags.
    //
    if (TreeConnectStr) {

        CallFlags |= ( DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE );

    }

    if (LocalDeviceName != NULL || SessionDeviceName != NULL) {

        if (SessionDeviceName == NULL) {
            SessionDeviceName = DavReturnSessionPath(LocalDeviceName);
            if ( SessionDeviceName == NULL ) {
                WStatus = ERROR_INVALID_PARAMETER;
                DavPrint((DEBUG_ERRORS,
                          "DavDeleteSymbolicLink/DavReturnSessionPath: WStatus ="
                          " %08lx\n", WStatus));
                return WStatus;
            }
            DeleteSession = TRUE;
        }

        if ( g_LUIDDeviceMapsEnabled == TRUE ) {
            WStatus = DavImpersonateClient();

            if (WStatus != NO_ERROR) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCreateSymbolicLink/DavImpersonateClient: "
                          "WStatus = %08lx\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            revert = TRUE;
        }

        //
        // Delete the symbolic link.
        //
        if ( !DefineDosDeviceW(CallFlags, SessionDeviceName, TreeConnectStr) ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavDeleteSymbolicLink/DefineDosDeviceW: WStatus ="
                      " %08lx\n", WStatus));
        }

    }

EXIT_THE_FUNCTION:

    if ( revert == TRUE ) {
        WStatus = DavRevertToSelf();
        if (WStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateSymbolicLink/DavRevertToSelf: "
                      "WStatus = %08lx\n", WStatus));
        }
    }

    if (SessionDeviceName && DeleteSession) {
        LocalFree( SessionDeviceName );
    }

    return WStatus;
}


DWORD
DavImpersonateClient(
    VOID
    )
/*++

Routine Description:

    This function calls RpcImpersonateClient to impersonate the current caller
    of an API.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;

    WStatus = RpcImpersonateClient(NULL);
    if ( WStatus != NO_ERROR ) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateClient/RpcImpersonateClient: WStatus = %08lx\n",
                  WStatus));
    }

    return WStatus;
}


DWORD
DavRevertToSelf(
    VOID
    )
/*++

Routine Description:

    This function calls RpcRevertToSelf to undo an impersonation.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;

    WStatus = RpcRevertToSelf();
    if ( WStatus != NO_ERROR ) {
        DavPrint((DEBUG_ERRORS,
                  "DavRevertToSelf/RpcRevertToSelf: WStatus = %08lx\n",
                  WStatus));
    }

    return WStatus;
}


NET_API_STATUS
DavGetUserEntry(
    IN  PDAV_USERS_OBJECT DavUsers,
    IN  PLUID LogonId,
    OUT PULONG Index,
    IN  BOOL IsAdd
    )
/*++

Routine Description:

    This function searches the table of user entries for one that matches the
    specified LogonId, and returns the index to the entry found.  If none is
    found, an error is returned if IsAdd is FALSE.  If IsAdd is TRUE a new
    entry in the users table is created for the user and the index to this
    new entry is returned.
        
    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    DavUsers - Supplies a pointer to the DavUseObject.

    LogonId - Supplies the pointer to the current user's Logon Id.

    Index - Returns the index to the users table of entry belonging to the
            current user.

    IsAdd - Supplies flag to indicate whether to add a new entry for the
            current user if none is found.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus;
    DWORD i;
    ULONG FreeEntryIndex = MAXULONG;

    for (i = 0; i < DavUsers->TableSize; i++) {
        //
        // If the LogonId matches the entry in the DavUsers Table, we've found 
        // the correct user entry.
        //
        if ( RtlEqualLuid( LogonId, &(DavUsers->Table[i].LogonId) ) ) {
            *Index = i;
            return NERR_Success;
        }
        else if (FreeEntryIndex == MAXULONG && DavUsers->Table[i].List == NULL) {
            //
            // Save away first unused entry in table.
            //
            FreeEntryIndex = i;
        }
    }

    if ( !IsAdd ) {
        //
        // Current user is not found in users table and we are told not to
        // create a new entry
        //
        return NERR_UserNotFound;
    }

    DavPrint((DEBUG_MISC,
              "DavGetUserEntry: New Entry. LogonID.Low = %d, LogonId.High = %d\n",
              LogonId->LowPart, LogonId->HighPart));

    //
    // Could not find an empty entry in the UsersTable, need to grow
    //
    if (FreeEntryIndex == MAXULONG) {
        NetApiStatus = DavGrowTable(DavUsers);
        if (NetApiStatus != NERR_Success) {
            return NetApiStatus;
        }
        FreeEntryIndex = i;
    }

    DavPrint((DEBUG_MISC, "DavGetUserEntry: FreeEntryIndex = %d\n", FreeEntryIndex));

    //
    // Create a new entry for current user
    //
    RtlCopyLuid( &(DavUsers->Table[FreeEntryIndex].LogonId), LogonId);
    *Index = FreeEntryIndex;

    return NERR_Success;
}


NET_API_STATUS
DavGrowTable(
    IN  PDAV_USERS_OBJECT DavUsers
    )
/*++

Routine Description:

    This function grows the users table to accomodate more users.

    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    DavUsers - Supplies a pointer to the DavUsersObject.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    ULONG Size;
    BOOL ReturnVal;

    DavPrint((DEBUG_MISC, "DavGrowTable: Grow the DavUsers table\n"));
    
    Size = (DavUsers->TableSize + DAV_GROW_USER_COUNT) * sizeof(DAV_PER_USER_ENTRY);
    
    if (DavUsers->TableSize > 0) {

        //
        // Unlock the Use Table virtual memory so that Win32 can move it
        // around to find a larger piece of contiguous virtual memory if
        // necessary.
        //
        ReturnVal = LocalUnlock(DavUsers->TableMemory);
        if ( !ReturnVal ) {
            NetApiStatus = GetLastError();
            if ( NetApiStatus != NO_ERROR ) {
                DavPrint((DEBUG_ERRORS,
                          "DavGrowTable/LocalUnlock. NetApiStatus = %08lx\n",
                          NetApiStatus));
                return NetApiStatus;
            }
        }

        //
        // Grow users table.
        //
        DavUsers->TableMemory = LocalReAlloc(DavUsers->TableMemory,
                                             Size,
                                             LMEM_ZEROINIT | LMEM_MOVEABLE);
        if (DavUsers->TableMemory == NULL) {
            NetApiStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavGrowTable/LocalReAlloc. NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }

    } else {

        //
        // This is the first allocation being made for the Dav Use Table.
        //
        DavUsers->TableMemory = LocalAlloc(LMEM_ZEROINIT | LMEM_MOVEABLE, Size);
        if (DavUsers->TableMemory == NULL) {
            NetApiStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavGrowTable/LocalAlloc. NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }

    }

    //
    // Update new size of Use Table.
    //
    DavUsers->TableSize += DAV_GROW_USER_COUNT;

    //
    // Lock Use Table virtual memory so that it cannot be moved.
    //
    DavUsers->Table = (PDAV_PER_USER_ENTRY) LocalLock(DavUsers->TableMemory);
    if (DavUsers->Table == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavGrowTable/LocalAlloc. NetApiStatus = %08lx\n",
                  NetApiStatus));
        return NetApiStatus;
    }

    return NetApiStatus;
}


LPWSTR
DavReturnSessionPath(
    IN LPWSTR LocalDeviceName
    )
/*++

Routine Description:

    This function returns the per session path to access the specific dos device
    for multiple session support.


Arguments:

    LocalDeviceName - Supplies the local device name specified by the API
                      caller.

Return Value:

    LPWSTR - Pointer to per session path in newly allocated memory
             by LocalAlloc().

--*/
{
    BOOL rc;
    DWORD SessionId = 0;
    CLIENT_ID ClientId;
    LPWSTR SessionDeviceName = NULL;
    NET_API_STATUS NetApiStatus;

    NetApiStatus = DavImpersonateAndGetSessionId( &(SessionId) );
    if (NetApiStatus != NERR_Success) {
        DavPrint((DEBUG_ERRORS,
                  "DavReturnSessionPath/DavImpersonateAndGetSessionId: "
                  "NetApiStatus = %08lx\n", NetApiStatus));
        return NULL;
    }

    rc = DosPathToSessionPathW(SessionId, LocalDeviceName, &SessionDeviceName);
    if( !rc ) {
        NetApiStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReturnSessionPath/DosPathToSessionPathW: "
                  "NetApiStatus = %08lx\n", NetApiStatus));
        return NULL;
    }

    return SessionDeviceName;
}


NET_API_STATUS
DavAddUse(
    IN PLUID LogonId,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    )
/*++

Routine Description:

    This function adds a Dav "net use" entry into the DavUseTable for the user
    specified by the Logon Id. There is a linked list of uses for each user. 
    Each new use entry is inserted into the end of the linked list so that 
    enumeration of the list is resumable.

    NOTE: This function locks the DavUseTable. 

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Local - Supplies the string of the local device name.

    LocalLength - Supplies the length of the local device name.

    UncName - Supplies the name of the shared resource (UNC name).

    UncNameLength - Supplies the length of the shared resource.

    TreeConnectStr - Supplies the string of UNC name in NT-style format.
    
    DavCreateFileHandle - The file handle that was created using NtCreateFile on 
                          the net use path. This is stored in the new user entry
                          structure being created and is closed when the user
                          entry gets deleted.
Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    DWORD Index;                          // Index to user entry in Use Table.
    PDAV_USE_ENTRY MatchedPointer = NULL; // Points to matching shared resource.
    PDAV_USE_ENTRY InsertPointer = NULL;  // Point of insertion into use list.
    PDAV_USE_ENTRY NewUse;                // Pointer to the new use entry.
    BOOLEAN ResAcquired = FALSE;
    LPWSTR UserName = NULL;

    if ( !RtlAcquireResourceExclusive(&DavUseObject.TableResource, TRUE) ) {
        NetApiStatus = NERR_InternalError;
        DavPrint((DEBUG_ERRORS,
                  "DavAddUse/RtlAcquireResourceExclusive: Internal Error.\n"));
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    // 
    // We will always save the user-name for any new use entry created.
    // This user-name is either explicitly given or if NULL, is taken as
    // Logged-On user. This should be taken care OF by the caller function.
    //
    UserName = AuthUserName;
    ASSERT(UserName != NULL);

    //
    // Look for the matching LogonId in the Use Table. If none matched create a 
    // new entry.
    //
    NetApiStatus = DavGetUserEntry(&DavUseObject, LogonId, &Index, TRUE);
    if (NetApiStatus != NERR_Success) {
        DavPrint((DEBUG_ERRORS,
                  "DavAddUse/RtlAcquireResourceExclusive: NetApiStatus = "
                  "%08lx\n", NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }

    if ( DavUseObject.Table[Index].List != NULL ) {

        DavPrint((DEBUG_MISC, "DavAddUse: DavUseObject.Table[Index].List != NULL\n"));

        //
        // Traverse use list to look for location to insert new use entry.
        //
        DavFindInsertLocation((PDAV_USE_ENTRY)DavUseObject.Table[Index].List,
                              UncName,
                              &(MatchedPointer),
                              &(InsertPointer));

    }

    if (MatchedPointer == NULL) {

        DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer == NULL\n"));

        //
        // No matching UNC name found.  Create a new entry with a
        // corresponding remote entry.
        //
        NetApiStatus = DavCreateNewEntry(&NewUse,
                                         Local,
                                         LocalLength,
                                         UserName,
                                         UncName,
                                         UncNameLength,
                                         TreeConnectStr,
                                         DavCreateFileHandle);
        if (NetApiStatus != NERR_Success) {
            DavPrint((DEBUG_ERRORS,
                      "DavAddUse/DavCreateNewEntry: NetApiStatus = %08lx\n", 
                      NetApiStatus));
            goto EXIT_THE_FUNCTION;
        }
    
    } else {

        //
        // Matching UNC name found.
        //

        DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer != NULL\n"));

        //
        // It may be unnecessary to create a new use entry if the use
        // we are adding has a NULL local device and a NULL local device
        // entry already exists.
        //
        if (Local == NULL) {
            
            DavPrint((DEBUG_MISC, "DavAddUse: Local == NULL\n"));
           
            if (MatchedPointer->Local == NULL) {

                DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer->Local == NULL\n"));

                //
                // We don't increment the reference count below because this is
                // the behavior SMB has. So, if a user does the following.
                // 1. net use http://server/share
                // 2. net use http://server/share
                // 3. net use http://server/share /d
                // The last delete lands up deleting the mapping even though the
                // user mapped it twice.
                // If this #if 0 is changed to #if 1, then the NtClose that is
                // being done below should not be done. This is why its included
                // in the #else clause.
                //

#if 0

                //
                // Yes, there is a NULL local device entry already.
                // Increment the use count and we are done.
                //
                MatchedPointer->UseCount++;
                MatchedPointer->Remote->TotalUseCount++;

#else 
                
                //
                // We close the file handle here, because we don't need to keep
                // it since this net use has no impact. As explained above, this
                // is because this user has already done a net use to the same
                // path with no local name and has repeated the command. This
                // should only be done if we are not taking the reference above.
                // If the above #if 0 is changed to add a reference to this 
                // entry then we need to keep this handle somewhere.
                //
                NtClose(DavCreateFileHandle);

#endif

                RtlReleaseResource( &(DavUseObject.TableResource) );
                ResAcquired = FALSE;

                return NetApiStatus;
           
            } else {
                DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer->Local != NULL\n"));
            }
        
        } else {
            DavPrint((DEBUG_MISC, "DavAddUse: Local != NULL\n"));
        }

        DavPrint((DEBUG_MISC, "DavAddUse: New Entry!!!\n"));
        
        //
        // If we get here it means we need to create a new use entry but not
        // a corresponding remote entry because a use with the same UNC
        // name already exists.
        //
        NetApiStatus = DavCreateNewEntry(&NewUse,
                                         Local,
                                         LocalLength,
                                         UserName,
                                         NULL,
                                         0,
                                         TreeConnectStr,
                                         DavCreateFileHandle);
        if (NetApiStatus != NERR_Success) {
            DavPrint((DEBUG_ERRORS,
                      "DavAddUse/DavCreateNewEntry: NetApiStatus = %08lx\n", 
                      NetApiStatus));
            goto EXIT_THE_FUNCTION;
        }

        NewUse->Remote = MatchedPointer->Remote;
        NewUse->Remote->TotalUseCount++;
    
    }

    //
    // Insert the new use entry into use list.
    //
    if (InsertPointer == NULL) {
        //
        // Inserting into the head of list
        //
        DavPrint((DEBUG_MISC, "DavAddUse: InsertPointer == NULL\n"));
        DavUseObject.Table[Index].List = (PVOID)NewUse;
    }
    else {
        DavPrint((DEBUG_MISC, "DavAddUse: InsertPointer != NULL\n"));
        InsertPointer->Next = NewUse;
    }

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return NetApiStatus;
}


VOID
DavFindInsertLocation(
    IN PDAV_USE_ENTRY DavUseList,
    IN LPWSTR UncName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *InsertPointer
    )
/*++

Routine Description:

    This function searches the use list for the location to insert a new use
    entry.  The use entry is inserted to the end of the use list so the
    pointer to the last node in the use list is returned via InsertPointer.
    We also have to save a pointer to the node with the same UNC name so that
    the new use entry can be set to point to the same remote node (where the
    UNC name is stored). This pointer is returned as MatchedPointer.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    DavUseList - Supplies the pointer to the use list.

    UncName - Supplies the pointer to the shared resource.

    MatchedPointer - Returns a pointer to the node that holds the matching
                     UncName. If no matching UncName is found, this pointer is 
                     set to NULL. If there is more than one node that has the 
                     same UNC name, this pointer will point to the node with the
                     NULL local device name, if any; otherwise, if all nodes 
                     with matching UNC names have non-null local device names, 
                     the pointer to the last matching node will be returned.

    InsertPointer - Returns a pointer to the last use entry, after which the
                    new entry is to be inserted.

Return Value:

    None.

--*/
{
    BOOL IsMatchWithNullDevice = FALSE;
    
    *MatchedPointer = NULL;

    while (DavUseList != NULL) {

        //
        // Do the string comparison only if we haven't found a matching UNC
        // name with a NULL local device name.
        //
        if ( !IsMatchWithNullDevice &&
             ( _wcsicmp((LPWSTR)DavUseList->Remote->UncName, UncName) == 0 ) ) {

            //
            // Found matching entry.
            //
            *MatchedPointer = DavUseList;

            IsMatchWithNullDevice = (DavUseList->Local == NULL);
        }

        *InsertPointer = DavUseList;
        
        DavUseList = DavUseList->Next;
    
    }

    return;
}


NET_API_STATUS
DavCreateNewEntry(
    OUT PDAV_USE_ENTRY *NewUse,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName OPTIONAL,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    )
/*++

Routine Description:

    This function creates and initializes a new use entry.  If the UncName
    is specified, a new remote entry is created and initialized with UncName.

Arguments:

    NewUse - Returns a pointer to the newly allocated and initialized use
             entry.

    Local - Supplies the local device name string to be copied into the new
            use entry.

    LocalLength - Supplies the length of the local device name string.

    AuthUserName - Supplies the authentication user name string to be copied into the new
                   use entry.

    UncName - Supplies the UNC name string to be copied into the new use entry.

    UncNameLength - Supplies the length of the UNC name string.

    TreeConnectStr - Supplies the string of UNC name in NT-style format
    
    DavCreateFileHandle - The file handle that was created using NtCreateFile on 
                          the net use path. This is stored in the new user entry
                          structure being created and is closed when the user 
                          entry gets deleted.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    PUNC_NAME NewRemoteEntry = NULL;
    SIZE_T Size = 0, AlignedSize = 0;
    DWORD AuthUserNameLength = 0;
    SIZE_T BuffOffset = 0;

    //
    // The extra 1 is for last L'\0'.
    //
    AuthUserNameLength = ( ARGUMENT_PRESENT(AuthUserName) ? wcslen(AuthUserName)+1 : 0 );

    // 
    // We add TreeConnectStr only if Local is present.
    // 
    
    Size = ROUND_UP_COUNT( sizeof(DAV_USE_ENTRY), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(Local) ? 
                             (LocalLength) * sizeof(WCHAR) : 0), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(Local) && ARGUMENT_PRESENT(TreeConnectStr) ? 
                             TreeConnectStr->MaximumLength : 0 ), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(AuthUserName) ? 
                             (AuthUserNameLength) * sizeof(WCHAR) : 0 ), ALIGN_WCHAR);
    
    AlignedSize = ROUND_UP_COUNT(Size, ALIGN_WCHAR);

    *NewUse = (PDAV_USE_ENTRY) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, AlignedSize);
    if ( *NewUse == NULL ) {
        NetApiStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateNewEntry/LocalAlloc: NetApiStatus = %08lx\n",
                  NetApiStatus));
        return NetApiStatus;
    }

    //
    // Put the use information into the new use node.
    //
    (*NewUse)->Next = NULL;
    (*NewUse)->UseCount = 1;

    ASSERT ( Local == NULL || LocalLength == (wcslen(Local)+1));

    // 
    // Goto next free location in the buffer.
    //
    BuffOffset = ( (DWORD_PTR) *NewUse + sizeof(DAV_USE_ENTRY) );
    BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);

    //
    // Copy local device name into use entry after the LocalLength field,
    // if it is specified.
    //
    if (ARGUMENT_PRESENT(Local)) {

        
        //  
        //  Copy local device name.
        //  
        (*NewUse)->Local = (LPWSTR)BuffOffset;
        (*NewUse)->LocalLength = LocalLength;
        wcscpy((*NewUse)->Local, Local);

        BuffOffset += ((LocalLength) * sizeof(WCHAR));
        BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);

        // 
        // Copy TreeConnectStr.
        //
        if (ARGUMENT_PRESENT(TreeConnectStr)) {
            (*NewUse)->TreeConnectStr = (LPWSTR)BuffOffset;
            wcscpy((*NewUse)->TreeConnectStr, TreeConnectStr->Buffer);

            BuffOffset += (TreeConnectStr->MaximumLength);
            BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);
        }

    } else {
        
        (*NewUse)->Local = NULL;
        
        (*NewUse)->TreeConnectStr = NULL;
    }

    // 
    // Copy AuthUserName.
    //
    if (ARGUMENT_PRESENT(AuthUserName)) {
        (*NewUse)->AuthUserName = (LPWSTR)BuffOffset;
        (*NewUse)->AuthUserNameLength = AuthUserNameLength;
        wcscpy((*NewUse)->AuthUserName, AuthUserName);

        BuffOffset += ((AuthUserNameLength) * sizeof(WCHAR));
        BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);
    }

    //
    // If shared resource name is specified, create a new remote entry to hold
    // the UNC name, and total number of uses on this shared resource.
    //
    if (ARGUMENT_PRESENT(UncName)) {

        SIZE_T UncNameSize;

        UncNameSize = ( sizeof(UNC_NAME) + (UncNameLength * sizeof(WCHAR)) );

        NewRemoteEntry = (PUNC_NAME) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                UncNameSize);
        if (NewRemoteEntry == NULL) {
            NetApiStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavCreateNewEntry/LocalAlloc: NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }
    
        wcscpy((LPWSTR)NewRemoteEntry->UncName, UncName);
        NewRemoteEntry->UncNameLength = UncNameLength;
        NewRemoteEntry->TotalUseCount = 1;
        
        (*NewUse)->Remote = NewRemoteEntry;
    
    }

    //
    // Finally, store the handle that has been created in the new user entry
    // structure.
    //
    (*NewUse)->DavCreateFileHandle = DavCreateFileHandle;

    return NetApiStatus;
}


NET_API_STATUS
DavFindUse(
    IN  PLUID LogonId,
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR UseName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer OPTIONAL
    )
/*++

Routine Description:

    This function searches the Dav Use Table for the specified use connection.
    If the UseName is found in the Use Table (explicit connection), a pointer 
    to the matching use entry is returned.  Otherwise, MatchedPointer is set to 
    NULL.

    WARNING: This function assumes that the DavUseObject.TableResource is 
             claimed.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    UseList - Supplies the use list of the user.

    UseName - Supplies the name of the tree connection, this is either a
              local device name or a UNC name.

    MatchedPointer - Returns the pointer to the matching use entry.  This
                     pointer is set to NULL if the specified use is an implicit
                     connection.

    BackPointer - Returns the pointer to the entry previous to the matching use 
                  entry if MatchedPointer is not NULL.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    PDAV_USE_ENTRY Back = NULL;

    //
    // Look for use entry depending on whether the local device name or UNC name 
    // is specified.
    //
    if (UseName[0] != L'\\') {
        //
        // Local device name is specified.
        //
        DavFindLocal( UseList, UseName, MatchedPointer, &(Back) );
    } else {
        //
        // A UNC name has been specified.
        //
        DavFindRemote( UseList, UseName, MatchedPointer, &(Back) );
    }

    if ( *MatchedPointer == NULL ) {
        DavPrint((DEBUG_ERRORS, "DavFindUse: %ws NOT found\n", UseName));
        return NERR_UseNotFound;
    } else {
        if (ARGUMENT_PRESENT(BackPointer)) {
            *BackPointer = Back;
        }
        return NERR_Success;
    }
}


VOID
DavFindLocal(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR Local,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the specified local device name.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    Local - Supplies the local device name.

    MatchedPointer - Returns a pointer to the use entry that holds the matching
                     local device name.  If no matching local device name is 
                     found, this pointer is set to NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
                  If the local device name is not found, this pointer is set to 
                  NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    DavPrint((DEBUG_MISC, "DavFindLocal: LocalName = %ws\n", Local));

    while (UseList != NULL) {

        if ( (UseList->Local != NULL) && (_wcsicmp(UseList->Local, Local) == 0) ) {

            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            
            return;
        
        } else {
            
            *BackPointer = UseList;
            
            UseList = UseList->Next;
        
        }
    
    }

    DavPrint((DEBUG_ERRORS, "DavFindLocal: LocalName NOT found\n"));

    //
    // Did not find matching local device name in the entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;

    return;
}


VOID
DavFindRemote(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR RemoteName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the specified UNC name.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    RemoteName - Supplies the UNC name.

    MatchedPointer - Returns a pointer to the use entry that holds the matching
                     UNC name.  If no matching UNC name is found, this pointer 
                     is set to NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
                  If the UNC name is not found, this pointer is set to NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    DavPrint((DEBUG_MISC, "DavFindRemote: RemoteName = %ws\n", RemoteName));
    
    while (UseList != NULL) {

        //
        // When we are trying to delete a UNC connection, then we should make
        // sure that the one we are deleting does not have a local name 
        // associted with it. Only if "net use http://foo/bar" was done is
        // "net use http://foo/bar /d" allowed.
        //
        if ( (UseList->Local == NULL) &&
             (UseList->Remote->UncName != NULL) &&
             (_wcsicmp((LPWSTR)UseList->Remote->UncName, RemoteName) == 0) ) {

            DavPrint((DEBUG_MISC, "DavFindRemote: UncName = %ws\n", 
                      UseList->Remote->UncName));
            
            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            
            return;
        
        } else {
            
            *BackPointer = UseList;
            
            UseList = UseList->Next;
        
        }
    
    }

    DavPrint((DEBUG_ERRORS, "DavFindRemote: RemoteName NOT found\n"));

    //
    // Did not find matching local device name in the entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;

    return;
}


NET_API_STATUS
DavDeleteUse(
    IN  PLUID LogonId,
    IN  DWORD ForceLevel,
    IN  PDAV_USE_ENTRY MatchedPointer,
    IN  DWORD Index
    )
/*++

Routine Description:

    This function removes the use entry pointed by MatchedPointer and frees its 
    memory if, it is a UNC connection deleted with force, or if it is a UNC 
    connection deleted with no force and the use count is decremented to 0, or 
    it is a connection mapped to a local device.

    WARNING: This function assumes that the Use.TableResource is claimed.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    ForceLevel - Supplies the level of force to delete.

    MatchedPointer - Supplies the pointer to the use entry to be deleted.

    Index - The index to the users table of entry belonging to the current user.

Return Value:

    NET_API_STATUS.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    PDAV_USE_ENTRY BackPointer = NULL;
    NTSTATUS CloseStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL didImpersonate = FALSE;
    
    DavPrint((DEBUG_MISC, "DavDeleteUse: ForceLevel = %d\n", ForceLevel));

    //
    // No need to remove entry if UNC connection is deleted with USE_NOFORCE
    // level, and use count is not 0 after the deletion.
    //
    if ( ( MatchedPointer->Local == NULL ) && ( ForceLevel == USE_NOFORCE ) && 
         ( (MatchedPointer->UseCount - 1) > 0 ) ) {

        DavPrint((DEBUG_MISC, "DavDeleteUse: MatchedPointer->UseCount = %d\n",
                  MatchedPointer->UseCount));
        
        MatchedPointer->UseCount--;
            
        MatchedPointer->Remote->TotalUseCount--;
            
        ASSERT(MatchedPointer->Remote->TotalUseCount);

        goto EXIT_THE_FUNCTION;
    }

    NetApiStatus = DavImpersonateClient();
    if (NetApiStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteUse/DavImpersonateClient: NetApiStatus = %08lx\n", 
                  NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    CloseStatus = NtFsControlFile(MatchedPointer->DavCreateFileHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &(IoStatusBlock),
                                  FSCTL_DAV_DELETE_CONNECTION,
                                  &(ForceLevel),
                                  sizeof(ForceLevel),
                                  NULL,
                                  0);
    
    if (NT_SUCCESS(CloseStatus)) {
        CloseStatus = IoStatusBlock.Status;
    } else {
        NetApiStatus = RtlNtStatusToDosError(CloseStatus);
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to close the file handle that was created when the "net use" was
    // done. This handle is kept so that the underlying data structures in the
    // kernel (like SrvCall, VNetRoot etc.) remain valid for this connection.
    // Since we are deleting this connection now, we need to close this handle.
    // Before closing we impersonate the client that issues this request, just 
    // to be in the safe side. Hence we impersonated the client above.
    //
    DavPrint((DEBUG_MISC,
              "DavDeleteUse: Closing DavCreateFileHandle = %08lx\n",
              MatchedPointer->DavCreateFileHandle));

    CloseStatus = NtClose(MatchedPointer->DavCreateFileHandle);
    if (CloseStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteUse/NtClose: CloseStatus = %08lx\n", 
                  CloseStatus));
    }
    
    NetApiStatus = DavRevertToSelf();
    if (NetApiStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavDeleteUse/DavRevertToSelf: NetApiStatus = %08lx\n",
                  NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = FALSE;
    
    //
    // Successfully deleted connection, and refound our entry. Delete symbolic 
    // link, if any.
    //
    NetApiStatus = DavDeleteSymbolicLink(MatchedPointer->Local, 
                                         MatchedPointer->TreeConnectStr,
                                         NULL);
    if (NetApiStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteuse/DavDeleteSymbolicLink: NetApiStatus = %08lx\n",
                  NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    BackPointer = (PDAV_USE_ENTRY)DavUseObject.Table[Index].List;

    if (BackPointer != MatchedPointer) {
        
        while (BackPointer->Next != NULL) {
            
            if (BackPointer->Next == MatchedPointer) {
                break;
            } else {
                BackPointer = BackPointer->Next;
            }
        
        }

        ASSERT(BackPointer->Next == MatchedPointer);

        BackPointer->Next = MatchedPointer->Next;

    } else {
        
        //
        // Use entry is the first one on the use list
        //
        DavUseObject.Table[Index].List = (PVOID)MatchedPointer->Next;
    
    }

    MatchedPointer->Remote->TotalUseCount -= MatchedPointer->UseCount;

    if (MatchedPointer->Remote->TotalUseCount == 0) {
        LocalFree((HLOCAL)MatchedPointer->Remote);
    }

    // 
    // Since MatchedPointer was allocated as one-chunk, and AuthUserName
    // was stored in that chunk - so do not free AuthUserName 
    // separatly.
    //
    MatchedPointer->AuthUserName = NULL;
    MatchedPointer->AuthUserNameLength = 0;

    LocalFree((HLOCAL)MatchedPointer);

EXIT_THE_FUNCTION:

    if (didImpersonate) {
        DavRevertToSelf();
    }

    return NetApiStatus;
}


VOID
DavInitializeAndInsertTheServerShareEntry(
    IN OUT PDAV_SERVER_SHARE_ENTRY ServerShEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    )
/*++

Routine Description:

    This routine initializes a newly created ServerShare entry strucutre and 
    inserts it into the global ServerShareEntry table. Note that the caller 
    should take a lock on the ServerShareEntry Table before calling this routine.
    
Arguments:

    ServerShEntry - Pointer to the ServerShare entry structure to be 
                    initialized and inserted.

    ServerName - Name of the server.
    
    EntrySize - Size of the server entry including the server name.
    
Return Value:

    none.

--*/
{
    ULONG ServerHashID;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerShareTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC,
              "DavInitializeAndInsertTheServerShareEntry: ServerName: %ws\n",
              ServerName));

    ServerShEntry->ServerName = &ServerShEntry->StrBuffer[0];
    wcscpy(ServerShEntry->ServerName, ServerName);

    ServerShEntry->TimeValueInSec = time(NULL);

    ServerShEntry->DavShareList = NULL;

    ServerShEntry->NumOfShares = 0;

    ServerHashID = DavHashTheServerName(ServerName);

    //
    // Insert the entry into the global ServerShareEntry table.
    //
    InsertHeadList( &(ServerShareTable[ServerHashID]), 
                                         &(ServerShEntry->ServerShareEntry) );
    
    return;
}


BOOL 
DavIsServerInServerShareTable(
    IN PWCHAR ServerName,
    OUT PDAV_SERVER_SHARE_ENTRY *ServerShEntry
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the global ServerShare table. If it does, the address of 
    the entry is returned in the caller supplied buffer. Note that the caller 
    should take a lock on the ServerShareTable before calling this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerShEntry - Pointer to the ServerShare entry structure.

Return Value:

    TRUE - Server entry exists in the ServerShare table.
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PDAV_SERVER_SHARE_ENTRY SSEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerShareTable 
    // before calling this routine.
    //
    
    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC,
              "DavIsServerInServerShareTable: ServerName = %ws\n", ServerName));
    
    //
    // Get the hash index of the server.
    //
    ServerHashID = DavHashTheServerName(ServerName);

    //
    // Search the ServerShare table at this index to see if an entry for this 
    // server exists.
    //
    listEntry = ServerShareTable[ServerHashID].Flink;
    while ( listEntry != &ServerShareTable[ServerHashID] ) {
        //
        // Get the pointer to the DAV_SERVER_SHARE_ENTRY structure.
        //
        SSEntry = CONTAINING_RECORD(listEntry,
                                    DAV_SERVER_SHARE_ENTRY,
                                    ServerShareEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, SSEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        listEntry = listEntry->Flink;
    }

    if (isPresent) {
        //
        // Yes, we found the entry for this server. Return its address to the
        // caller in the supplied buffer.
        //
        *ServerShEntry = SSEntry;
        return isPresent;
    } 

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerShEntry = NULL;
    
    return isPresent;
}


DWORD
DavGetShareListFromServer(
    PDAV_SERVER_SHARE_ENTRY ServerShEntry
    )
/*++

Routine Description:

    This routine gets the shares of the server in the ServerShEntry structure.

Arguments:

    ServerShEntry - Pointer to the ServerShare entry structure.

Return Value:

    ERROR_SUCESS or the Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE, readDone = FALSE;
    PCHAR DataBuff = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    BOOL bStatus  = TRUE, revert = FALSE;
    
    DavPrint((DEBUG_MISC, 
              "DavGetShareListFromServer: ServerName = %ws\n", 
              ServerShEntry->ServerName));

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavGetShareListFromServer/DavImpersonateClient: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    DavConnHandle = InternetConnectW(ISyncHandle,
                                     ServerShEntry->ServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/InternetConnectW. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // To get the shares, we do a PROPFIND on the root directory. The Depth
    // header should be set to 1. The directory browsing should be enabled on 
    // the DAV server to enumerate the shares.
    //
    
    bStatus = DavHttpOpenRequestW(DavConnHandle,
                                     L"PROPFIND",
                                     L"/",
                                     L"HTTP/1.1",
                                     NULL,
                                     NULL,
                                     INTERNET_FLAG_KEEP_CONNECTION |
                                     INTERNET_FLAG_NO_COOKIES,
                                     0,
                                     L"DavGetSharesListFromServer",
                                     &DavOpenHandle);
    if(bStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpOpenRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"Depth: 1\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpSendRequestExW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
        // WinInet is trying to authenticate itself with the server. We need to 
        // repeat the HttpSend and HttpEnd request calls.
        //
        if (WStatus == ERROR_INTERNET_FORCE_RETRY) {
            goto RESEND_THE_REQUEST;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpEndRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check for return status. Server may have returned error. Like no-access or
    // others.
    // 
    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/DavQueryAndParseResponse: WStatus = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/LocalAlloc: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Read the response and parse it.
    //
    do {

        ReturnVal = InternetReadFile(DavOpenHandle, 
                                     (LPVOID)DataBuff,
                                     NUM_OF_BYTES_TO_READ,
                                     &(NumRead));
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavGetShareListFromServer/InternetReadFile: WStatus = "
                      "%08lx\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        DavPrint((DEBUG_MISC, "DavGetShareListFromServer: NumRead = %d\n", NumRead));
        
        readDone = (NumRead == 0) ? TRUE : FALSE;

        WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavGetShareListFromServer/DavPushData."
                      " Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (readDone) {
            break;
        }
    
    } while ( TRUE );

    //
    // We now need to parse the data.
    //

    DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                    sizeof(DAV_FILE_ATTRIBUTES) );
    if (DavFileAttributes == NULL) {
        WStatus = GetLastError();
        DavCloseContext(Ctx1, Ctx2);
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/LocalAlloc. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    InitializeListHead( &(DavFileAttributes->NextEntry) );

    WStatus = DavParseData(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
    if (WStatus != ERROR_SUCCESS) {
        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
        DavFileAttributes = NULL;
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/DavParseData. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ServerShEntry->NumOfShares = NumOfFileEntries;

    ServerShEntry->DavShareList = DavFileAttributes;

    DavCloseContext(Ctx1, Ctx2);
    
    WStatus = ERROR_SUCCESS;
    
EXIT_THE_FUNCTION:

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavGetShareListFromServer/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }

    if (DataBuff) {
        LocalFree(DataBuff);
    }

    return WStatus;
}


DWORD
DavrWinlogonLogonEvent(
    IN handle_t dav_binding_h
    )
/*++

Routine Description:

    This routine implements an RPC server function. Its called by davclnt.dll
    everytime a user logs on to the system. It increments the global variable 
    DavNumberOfLoggedOnUsers.
    
Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    EnterCriticalSection( &(DavLoggedOnUsersLock) );

    //
    // Increment the Number of logged on users.
    //
    DavNumberOfLoggedOnUsers += 1;

    LeaveCriticalSection( &(DavLoggedOnUsersLock) );

    return WStatus;
}


DWORD
DavrWinlogonLogoffEvent(
    IN handle_t dav_binding_h
    )
/*++

Routine Description:

    This routine implements an RPC server function. Its called by davclnt.dll
    everytime a user logs off from the system. It decrements the global variable 
    DavNumberOfLoggedOnUsers.
    
Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    EnterCriticalSection( &(DavLoggedOnUsersLock) );

    //
    // Decrement the Number of logged on users.
    //
    DavNumberOfLoggedOnUsers -= 1;

    LeaveCriticalSection( &(DavLoggedOnUsersLock) );

    return WStatus;
}


BOOL
DavCheckTheNonDAVServerList(
    PWCHAR ServerName
    )
/*++

Routine Description:

    This routine checks to see if the ServerName passed is in the list of
    servers that do not speak DAV (NonDAVServerList). Before we check, we go
    through the list once and free up all the old entries.

    IMPORTANT!!!    
    The caller of this routine must acquire the NonDAVServerListLock which is
    used to synchronize access to this global list.

Arguments:

    ServerName - The ServerName that needs to be checked.

Returns:

    TRUE - ServerName is a part of the NonDAVServerList.

    FALSE - ServerName is NOT a part of the NonDAVServerList.

--*/
{
    PLIST_ENTRY thisListEntry = NULL;
    PNON_DAV_SERVER_ENTRY NonDavServerEntry = NULL;
    time_t CurrentTimeInSec;
    BOOL foundEntry = FALSE;
    ULONGLONG TimeDiff; 

    DavPrint((DEBUG_DEBUG,
              "DavCheckTheNonDAVServerList: ServerName = %ws\n",
              ServerName));

    //
    // First go through the entire list and clean up the old entries.
    //

    thisListEntry = NonDAVServerList.Flink;

    while ( thisListEntry != &(NonDAVServerList) ) {

        NonDavServerEntry = CONTAINING_RECORD(thisListEntry,
                                              NON_DAV_SERVER_ENTRY,
                                              listEntry);

        thisListEntry = thisListEntry->Flink;

        CurrentTimeInSec = time(NULL);

        TimeDiff = (CurrentTimeInSec - NonDavServerEntry->TimeValueInSec);

        if (TimeDiff >= ServerNotFoundCacheLifeTimeInSec) {

            RemoveEntryList( &(NonDavServerEntry->listEntry) );

            LocalFree(NonDavServerEntry->ServerName);
            NonDavServerEntry->ServerName = NULL;

            LocalFree(NonDavServerEntry);
            NonDavServerEntry = NULL;

        }

    }

    //
    // Now that we have cleaned up all the old entries, go through the list
    // and find out the entry that matches the ServerName.
    //

    thisListEntry = NonDAVServerList.Flink;

    while ( thisListEntry != &(NonDAVServerList) ) {

        NonDavServerEntry = CONTAINING_RECORD(thisListEntry,
                                              NON_DAV_SERVER_ENTRY,
                                              listEntry);

        thisListEntry = thisListEntry->Flink;

        if ( !_wcsicmp(ServerName, NonDavServerEntry->ServerName) ) {
            foundEntry = TRUE;
            break;
        }

    }

    return foundEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\fcbfobx.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fcbfobx.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    finalizition of Fobxs.

Author:

    Rohan Kumar      [RohanK]      30-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"

//
// Implementation of functions begins here.
//

ULONG
DavFsFinalizeFobx(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV finalize Fobx requests that get reflected from the 
    kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_FOBX_REQUEST DavFinFobxReq = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;

    DavFinFobxReq = &(DavWorkItem->FinalizeFobxRequest);

    DavFileAttributes = DavFinFobxReq->DavFileAttributes;

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeFobx: DavFileAttributes = %08lx.\n", 
              DavFileAttributes));
    
    DavWorkItem->Status = WStatus;

    //
    // Finalize the list of DavFileAttributes.
    //
    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
    DavFileAttributes = NULL;
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef DAV_DEBUG_H
#define DAV_DEBUG_H

#if DBG

//
// Memory allocation and tracking
//
#define DEBUG_OUTPUT_BUFFER_SIZE 1024
typedef struct _MEMORYBLOCK {
    HLOCAL hlocal;
    DWORD dwBytes;
    UINT uFlags;
    LPCSTR pszFile;
    UINT uLine;
    LPCSTR pszModule;
    LPCSTR pszComment;
    struct _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE  (1024 * 1024)

//
// Controls access to the memeory tracing routines. We need this since multiple
// threads could be allocating memory simultaneously.
//
EXTERN CRITICAL_SECTION g_TraceMemoryCS;

//
// List of memory blocks (see the structure defined above) being maintained for 
// tracking memory.
//
EXTERN LPVOID g_TraceMemoryTable INIT_GLOBAL(NULL);

//
// Controls access to the debug log file. We need this since multiple threads
// could be writing to it simultaneously.
//
EXTERN CRITICAL_SECTION DavGlobalDebugFileCritSect;

//
// These are used in persistent logging. They define the file handle of the
// file to which the debug o/p is written, the max file size and the path
// of the file.
//
EXTERN HANDLE DavGlobalDebugFileHandle INIT_GLOBAL(INVALID_HANDLE_VALUE);
EXTERN ULONG DavGlobalDebugFileMaxSize INIT_GLOBAL(DEFAULT_MAXIMUM_DEBUGFILE_SIZE);
EXTERN LPWSTR DavGlobalDebugSharePath;

//
// This flag (value) is used in filtering/controlling the debug messages.
//
EXTERN ULONG DavGlobalDebugFlag;

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\davclnt.log"
#define DEBUG_BAK_FILE      L"\\davclnt.bak"

HLOCAL
DebugAlloc(
    LPCSTR pszFile,
    UINT uLine,
    LPCSTR pszModule,
    UINT uFlags,
    DWORD dwBytes,
    LPCSTR pszComment
    );

#define DavAllocateMemory(x)  (                   \
        DebugAlloc(__FILE__,                      \
                   __LINE__,                      \
                   "DAV",                         \
                   LMEM_FIXED | LMEM_ZEROINIT,    \
                   x,                             \
                   #x)                            \
        )

HLOCAL
DebugFree(
    HLOCAL hglobal
    );

#define DavFreeMemory(x) DebugFree(x)

VOID
DebugInitialize(
    VOID
    );

VOID
DebugUninitialize(
    VOID
    );


VOID
DavAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DavAssert(Predicate) {                                       \
        if (!(Predicate)) {                                          \
            DavAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        }                                                            \
    }

#define DavAssertMsg(Predicate, Message) {                               \
    if (!(Predicate)) {                                                  \
            DavAssertFailed( #Predicate, __FILE__, __LINE__, #Message ); \
        }                                                                \
    }

#define IF_DEBUG(flag) if (DavGlobalDebugFlag & (DEBUG_ ## flag))

//
// The debug flags used. 
//
#define DEBUG_CONNECT           0x00000001  // connect events
#define DEBUG_ERRORS            0x00000002  // errors
#define DEBUG_INIT              0x00000004  // init events
#define DEBUG_SCAVENGER         0x00000008  // sacvenger error
#define DEBUG_REGISTRY          0x00000010  // Registry operation
#define DEBUG_MISC              0x00000020  // misc info.
#define DEBUG_RPC               0x00000040  // debug rpc messages
#define DEBUG_MEMORY            0x00000080  // Memory Allocation Tracking Spew
#define DEBUG_FUNC              0x00000100  // function entry/exit
#define DEBUG_STARTUP_BRK       0x00000200  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x00000400  // log debug output in a file.
#define DEBUG_DEBUG             0x00000800  // scope the debugging

VOID
DavPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DavPrint(_x_)   DavPrintRoutine _x_;

VOID
DebugMemoryCheck(
    VOID
    );

#else   // not DBG

#define DavAllocateMemory(x) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, x)
#define DavFreeMemory(x)     LocalFree(x)
#define IF_DEBUG(flag) if (FALSE)
#define DavPrint(_x_)
#define DavAssert(_x_)
#define DavAssertMsg(_x_, _y_)

#endif // DBG

VOID
DavClientEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

#endif // DAV_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\debug.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

#include "pch.h"
#pragma hdrstop

#include <stdio.h>
#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"


#if DBG

VOID
DavOpenDebugFile(
    IN BOOL ReopenFlag
    );

HLOCAL
DebugMemoryAdd(
    HLOCAL hglobal,
    LPCSTR pszFile,
    UINT uLine,
    LPCSTR pszModule,
    UINT uFlags,
    DWORD dwBytes,
    LPCSTR pszComment
    );

VOID
DebugMemoryDelete(
    HLOCAL hlocal
    );

#endif // DBG


#if DBG

VOID
DebugInitialize(
    VOID
    )
/*++

Routine Description:

    This routine initializes the DAV debug environment. Its called by the init
    function ServiveMain().

Arguments:

    none.

Return Value:

    none.

--*/
{
    DWORD dwErr;
    HKEY KeyHandle;

    //
    // We enclose the call to InitializeCriticalSection in a try-except block
    // because its possible for it to raise a  STATUS_NO_MEMORY exception.
    //
    try {
        InitializeCriticalSection( &(g_TraceMemoryCS) );
        InitializeCriticalSection( &(DavGlobalDebugFileCritSect) );
    } except(EXCEPTION_EXECUTE_HANDLER) {
          dwErr = GetExceptionCode();
          DbgPrint("%ld: ERROR: DebugInitialize/InitializeCriticalSection: "
                   "Exception Code = %08lx.\n", GetCurrentThreadId(), dwErr);
          return;
    }

    //
    // These are used in persistent logging. They define the file handle of the
    // file to which the debug o/p is written, the max file size and the path
    // of the file.
    //
    DavGlobalDebugFileHandle = NULL;
    DavGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
    DavGlobalDebugSharePath = NULL;

    //
    // Read DebugFlags value from the registry. If the entry exists, the global
    // filter "DavGlobalDebugFlag" is set to this value. This value is used in
    // filtering the debug messages.
    //
    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         DAV_PARAMETERS_KEY,
                         0,
                         KEY_QUERY_VALUE,
                         &(KeyHandle));
    if (dwErr == ERROR_SUCCESS) {
        //
        // Read the value into DavGlobalDebugFlag.
        //
        DavGlobalDebugFlag = ReadDWord(KeyHandle, DAV_DEBUG_KEY, 0);
        RegCloseKey(KeyHandle);
    }

    //
    // Break in the debugger if we are asked to do so.
    //
    if(DavGlobalDebugFlag & DEBUG_STARTUP_BRK) {
        DavPrint((DEBUG_INIT,
                  "DebugInitialize: Stopping at DebugBreak().\n" ));
        DebugBreak();
    }

    //
    // If we want to do persistent logging, open the debug log file.
    //
    if ( DavGlobalDebugFlag & DEBUG_LOG_IN_FILE ) {
        DavOpenDebugFile( FALSE );
    }

    return;
}


VOID
DebugUninitialize (
    VOID
    )
/*++

Routine Description:

    This routine uninitializes the DAV debug environment. It basically frees up
    the resources that were allocated for debugging/logging during debug
    initialization.

Arguments:

    none.

Return Value:

    none.

--*/
{
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );

    if ( DavGlobalDebugFileHandle != NULL ) {
        CloseHandle( DavGlobalDebugFileHandle );
        DavGlobalDebugFileHandle = NULL;
    }
    if( DavGlobalDebugSharePath != NULL ) {
        DavFreeMemory( DavGlobalDebugSharePath );
        DavGlobalDebugSharePath = NULL;
    }

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    DeleteCriticalSection( &(DavGlobalDebugFileCritSect) );

    DeleteCriticalSection( &(g_TraceMemoryCS) );

    return;
}


VOID
DavOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file. This file is used in persistent logging.

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
                 and recreated.

Return Value:

    None.

--*/
{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    if ( DavGlobalDebugFileHandle != NULL ) {
        CloseHandle( DavGlobalDebugFileHandle );
        DavGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    //
    // Create the debug directory path first, if it is not made before.
    //
    if( DavGlobalDebugSharePath == NULL ) {

        UINT Val, LogFileSize;
        ULONG LogFileNameSizeInBytes;

        LogFileSize = ( sizeof(LogFileName)/sizeof(WCHAR) );
        Val = GetWindowsDirectoryW(LogFileName, LogFileSize);
        if ( Val == 0 ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Window Directory Path can't be "
                      "retrieved, %d.\n", GetLastError() ));
            goto ErrorReturn;
        }

        //
        // Check debug path length. The filename buffer needs to be of a
        // minimum size.
        //
        PathLength = (wcslen(LogFileName) * sizeof(WCHAR)) + sizeof(DEBUG_DIR)
                                            + sizeof(WCHAR);

        if( ( PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            ( PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Debug directory path (%ws) length is "
                      "too long.\n", LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // Copy debug directory name to global var.
        //
        LogFileNameSizeInBytes = ( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        //
        // We need to make the LogFileNameSizeInBytes a multiple of 8. This is
        // because DavAllocateMemory calls DebugAlloc which does some stuff which
        // requires this. The equation below does this.
        //
        LogFileNameSizeInBytes = ( ( ( LogFileNameSizeInBytes + 7 ) / 8 ) * 8 );


        DavGlobalDebugSharePath = DavAllocateMemory( LogFileNameSizeInBytes );
        if( DavGlobalDebugSharePath == NULL ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Can't allocated memory for debug share"
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(DavGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, DavGlobalDebugSharePath);
    }

    //
    // Check whether this path exists.
    //
    FileAttributes = GetFileAttributesW( LogFileName );
    if( FileAttributes == 0xFFFFFFFF ) {
        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {
            BOOL RetVal;
            //
            // Create debug directory.
            //
            RetVal = CreateDirectoryW( LogFileName, NULL );
            if( !RetVal ) {
                DavPrint((DEBUG_ERRORS,
                          "DavOpenDebugFile: Can't create Debug directory (%ws)"
                          ", %d.\n", LogFileName, GetLastError()));
                goto ErrorReturn;
            }
        }
        else {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Can't Get File attributes(%ws), %ld.\n",
                      LogFileName, WinError));
            goto ErrorReturn;
        }
    }
    else {
        //
        // If this is not a directory, then we fail.
        //
        if( !(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Debug directory path (%ws) exists "
                      "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //
    wcscpy( BakFileName, LogFileName );
    wcscat( LogFileName, DEBUG_FILE );
    wcscat( BakFileName, DEBUG_BAK_FILE );

    //
    // If this is a re-open, delete the backup file, rename the current file to
    // the backup file.
    //
    if ( ReopenFlag ) {
        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                DavPrint((DEBUG_ERRORS,
                          "DavOpenDebugFile: Cannot delete %ws (%ld)\n",
                          BakFileName, WinError));
                DavPrint((DEBUG_ERRORS,
                              "DavOpenDebugFile: Try to re-open the file.\n"));
                    ReopenFlag = FALSE;
                }
            }
        }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Cannot rename %ws to %ws (%ld)\n",
                      LogFileName, BakFileName, GetLastError()));
            DavPrint((DEBUG_ERRORS,
                      "DavopenDebugFile: Try to re-open the file.\n"));
            ReopenFlag = FALSE;
        }
    }

    //
    // Open the file.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    DavGlobalDebugFileHandle = CreateFileW(LogFileName,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           NULL,
                                           (ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS),
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);


    if ( DavGlobalDebugFileHandle == INVALID_HANDLE_VALUE ) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenDebugFile: Cannot open (%ws).\n", LogFileName));
        LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );
        goto ErrorReturn;
    } else {
        //
        // Position the log file at the end.
        //
        SetFilePointer( DavGlobalDebugFileHandle, 0, NULL, FILE_END );
    }

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    return;

ErrorReturn:

    DavPrint((DEBUG_ERRORS,
              "DavOpenDebugFile: Debug o/p will be written to terminal.\n"));
    return;
}


VOID
DavPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:

    This routine prints the string passed in to the debug terminal and/or the
    persistent log file.

Arguments:

    DebugFlag - The debug flag which indicates whether thi string should be
                printed or not.

    Format - The string to be printed and its format.

Return Value:

    None.

--*/
{

#define MAX_PRINTF_LEN 8192

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    char OutputBuffer2[MAX_PRINTF_LEN]; // this buffer will remove any % in OutputBuffer
    ULONG length = 0;
    DWORD ThreadId;
    // DWORD BytesWritten, ThreadId;
    // static BeginningOfLine = TRUE;
    // static LineCount = 0;
    // static TruncateLogFileInProgress = FALSE;
    LPSTR Text;
    DWORD PosInBuf1=0,PosInBuf2=0;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag == 0 || (DavGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded and we don't want to intermingle output
    // from different threads.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    length = 0;

    //
    // Print the ThreadId at the start.
    //
    ThreadId = GetCurrentThreadId();
    length += (ULONG) sprintf( &(OutputBuffer[length]), "%ld ", ThreadId );

    //
    // If this is an error, print the string "ERROR: " next.
    //
    if (DebugFlag & DEBUG_ERRORS) {
        Text  = "ERROR: ";
        length += (ULONG) sprintf( &(OutputBuffer[length]), "%s", Text );
    }
    //
    // Finally, print the string.
    //
    va_start(arglist, Format);
    length += (ULONG) vsprintf( &(OutputBuffer[length]), Format, arglist );
    va_end(arglist);

    DavAssert(length < MAX_PRINTF_LEN); //last one for '\0' char

    // Remove all % strings from Output buffer as this will be passed as format string 
    // to DbgPrint
    PosInBuf1=0; PosInBuf2=0;
    while(PosInBuf1<length) {
        OutputBuffer2[PosInBuf2] = OutputBuffer[PosInBuf1];
        PosInBuf2++;
        if(OutputBuffer2[PosInBuf2-1] == '%') {
            OutputBuffer2[PosInBuf2] = '%';
            PosInBuf2++;
        }
        PosInBuf1++; 
    }
    length = PosInBuf2;
    OutputBuffer2[length]='\0';

    DavAssert(length < MAX_PRINTF_LEN);

    DbgPrint( (PCH)OutputBuffer2 );

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    return;

#if 0
    //
    // If the log file is getting huge, truncate it.
    //
    if ( DavGlobalDebugFileHandle != NULL && !TruncateLogFileInProgress ) {
        //
        // Only check every 50 lines,
        //
        LineCount++;
        if ( LineCount >= 50 ) {
            DWORD FileSize;
            LineCount = 0;
            //
            // Is the log file too big?
            //
            FileSize = GetFileSize( DavGlobalDebugFileHandle, NULL );
            if ( FileSize == 0xFFFFFFFF ) {
                DbgPrint("DavPrintRoutine: Cannot GetFileSize. ErrorVal = %d.\n",
                         GetLastError());
            } else if ( FileSize > DavGlobalDebugFileMaxSize ) {
                TruncateLogFileInProgress = TRUE;
                LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );
                DavOpenDebugFile( TRUE );
                DavPrint((DEBUG_MISC,
                          "Logfile truncated because it was larger than %ld bytes\n",
                          DavGlobalDebugFileMaxSize));
                EnterCriticalSection( &DavGlobalDebugFileCritSect );
                TruncateLogFileInProgress = FALSE;
            }
        }
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile(DavGlobalDebugFileHandle,
                    OutputBuffer,
                    lstrlenA( OutputBuffer ),
                    &BytesWritten,
                    NULL) ) {
        DbgPrint( (PCH) OutputBuffer);
    }


ExitDavPrintRoutine:
    LeaveCriticalSection( &DavGlobalDebugFileCritSect );
#endif

}


VOID
DavAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    This routine is called if a DAV assertion failed.

Arguments:

    FailedAssertion : The assertion string that failed.

    FileName : The file in which this assert was called.

    LineNumber : The line on which this assert was called.

    Message : The message to be printed if the assertion failed.

Return Value:

    none.

--*/
{
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Assert: %s.\n", FailedAssertion));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Filename: %s.\n", FileName));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Line Num: %ld.\n", LineNumber));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Message: %s.\n", Message));

    RtlAssert(FailedAssertion, FileName, (ULONG)LineNumber, (PCHAR)Message);

#if DBG
    DebugBreak();
#endif

    return;
}


LPSTR
dbgmakefilelinestring(
    LPSTR  pszBuf,
    LPCSTR pszFile,
    UINT    uLine
    )
/*++

Routine Description:

    Takes the filename and line number and put them into a string buffer.
    NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.

Arguments:

    pszBuf - The buffer to be written to.

    pszFile - The filename.

    uLine - The line in the file.

Return Value:

--*/
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) ((ULONG_PTR)uLine);

    FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   "%1(%2!u!):",
                   0,                          // error code
                   0,                          // default language
                   (LPSTR) pszBuf,             // output buffer
                   DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                   (va_list*)&args);           // arguments

    return pszBuf;
}


HLOCAL
DebugMemoryAdd(
    HLOCAL hlocal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment
    )
/*++

Routine Description:

     Adds a MEMORYBLOCK to the memory tracking list.

Arguments:

    hlocal - The handle (pointer) to the allocated memroy block.

    pszFile - The file in which this allocation took place.

    uLine - The line in which this allocation took place.

    pszModule - DAV in our case.

    uFlags - Allocation flags passed to LocalAlloc().

    dwBytes - Number of bytes to allocate.

    Comm - The allocation string (i.e argument to DavAllocateMemory).

Return Value:

    Handle (pointer) to the memory block.

--*/
{
    LPMEMORYBLOCK pmb;

    if ( hlocal ) {

        pmb = (LPMEMORYBLOCK) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(MEMORYBLOCK));
        if ( !pmb ) {
            LocalFree( hlocal );
            return NULL;
        }

        pmb->hlocal     = hlocal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &(g_TraceMemoryCS) );

        //
        // Add this block to the list.
        //
        pmb->pNext = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        DavPrint((DEBUG_MEMORY,
                  "DebugMemoryAdd: Handle = 0x%08lx. Argument: (%s)\n",
                  hlocal, pmb->pszComment));

        LeaveCriticalSection( &(g_TraceMemoryCS) );
    }

    return hlocal;
}


HLOCAL
DebugAlloc(
    LPCSTR File,
    UINT Line,
    LPCSTR Module,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR Comm
    )
/*++

Routine Description:

   Allocates memory and adds the MEMORYBLOCK to the memory tracking list.

Arguments:

    File - The file in which this allocation took place.

    Line - The line in which this allocation took place.

    Module - DAV in our case.

    uFlags - Allocation flags passed to LocalAlloc().

    dwBytes - Number of bytes to allocate.

    Comm - The allocation string (i.e argument to DavAllocateMemory).

Return Value:

    Handle (pointer) to the memory block.

--*/
{
    HLOCAL hlocal;
    HLOCAL *p;
    ULONG ShouldBeZero;

    //
    // dwBytes should be a multiple of 8. This is because of the pointer math
    // that is being done below to store the value of hlocal in the memory 
    // allocated for it.
    //
    ShouldBeZero = (dwBytes & 0x7);

    DavPrint((DEBUG_MISC, "DebugAlloc: ShouldBeZero = %d\n", ShouldBeZero));

    ASSERT(ShouldBeZero == (ULONG)0);

    hlocal = LocalAlloc( uFlags, dwBytes + sizeof(HLOCAL));
    if (hlocal == NULL) {
        return NULL;
    }

    p = (HLOCAL)((LPBYTE)hlocal + dwBytes);
    
    *p = hlocal;

    return DebugMemoryAdd(hlocal, File, Line, Module, uFlags, dwBytes, Comm);
}


VOID
DebugMemoryDelete(
    HLOCAL hlocal
    )
/*++

Routine Description:

     Removes a MEMORYBLOCK to the memory tracking list.

Arguments:

    hlocal - The handle to be removed.

Return Value:

    none.

--*/
{
    LPMEMORYBLOCK pmbHead;
    LPMEMORYBLOCK pmbLast = NULL;

    if ( hlocal ) {

        EnterCriticalSection( &(g_TraceMemoryCS) );

        pmbHead = g_TraceMemoryTable;

        //
        // Search the list for the handle being freed.
        //
        while ( pmbHead && pmbHead->hlocal != hlocal ) {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead ) {
            HLOCAL *p;

            if ( pmbLast ) {
                //
                // Reset the "next" pointer of the previous block.
                //
                pmbLast->pNext = pmbHead->pNext;
            } else {
                //
                // First entry is being freed.
                //
                g_TraceMemoryTable = pmbHead->pNext;
            }

            DavPrint((DEBUG_MEMORY,
                      "DebugMemoryDelete: Handle 0x%08x freed. Comm: (%s)\n",
                      hlocal, pmbHead->pszComment ));

            p = (HLOCAL)((LPBYTE)hlocal + pmbHead->dwBytes);
            if ( *p != hlocal ) {
                DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                          "DebugMemoryDelete: Heap check FAILED for %0x08x %u bytes (%s).\n",
                          hlocal, pmbHead->dwBytes, pmbHead->pszComment));
                DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                          "DebugMemoryDelete: File: %s, Line: %u.\n",
                          pmbHead->pszFile, pmbHead->uLine ));
                DavAssert( *p == hlocal );
            }

            memset( hlocal, 0xFE, pmbHead->dwBytes + sizeof(HLOCAL) );
            memset( pmbHead, 0xFD, sizeof(MEMORYBLOCK) );

            LocalFree( pmbHead );

        } else {
            DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                      "DebugMemoryDelete: Handle 0x%08x not found in memory "
                      "table.\n", hlocal));
            memset( hlocal, 0xFE, (int)LocalSize( hlocal ));
        }

        LeaveCriticalSection( &(g_TraceMemoryCS) );
    }

    return;
}


HLOCAL
DebugFree(
    HLOCAL hlocal
    )
/*++

Routine Description:

     Remove the MEMORYBLOCK from the memory tracking list, memsets the memory to
     0xFE and then frees the memory.

Arguments:

    hlocal - The handle to be freed.

Return Value:

    Whatever LocalFree returns.

--*/
{
    //
    // Remove it from the tracking list and free it.
    //
    DebugMemoryDelete( hlocal );
    return LocalFree( hlocal );
}


VOID
DebugMemoryCheck(
    VOID
    )
/*++

Routine Description:

    Checks the memory tracking list. If it is not empty, it will dump the
    list and break.

Arguments:

    none.

Return Value:

    none.

--*/
{
    BOOL fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &(g_TraceMemoryCS) );

    pmb = g_TraceMemoryTable;

    while ( pmb ) {

        LPMEMORYBLOCK pTemp;
        LPVOID args[5];
        CHAR  szOutput[DEBUG_OUTPUT_BUFFER_SIZE];
        CHAR  szFileLine[DEBUG_OUTPUT_BUFFER_SIZE];

        if ( fFoundLeak == FALSE ) {
            DavPrintRoutine(DEBUG_MEMORY | DEBUG_ERRORS,
                            "************ Memory leak detected ************\n");
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hlocal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) ((ULONG_PTR) pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) ) {
            FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           "%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n",
                           0,                           // error code
                           0,                           // default language
                           (LPSTR) &szOutput,           // output buffer
                           DEBUG_OUTPUT_BUFFER_SIZE,    // size of buffer
                           (va_list*) &args);           // arguments
        } else {
            FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           "%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n",
                           0,                           // error code
                           0,                           // default language
                           (LPSTR) &szOutput,           // output buffer
                           DEBUG_OUTPUT_BUFFER_SIZE,    // size of buffer
                           (va_list*) &args);           // arguments
        }

        DavPrintRoutine(DEBUG_MEMORY | DEBUG_ERRORS,  szOutput);

        pTemp = pmb;

        pmb = pmb->pNext;

        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );

        LocalFree( pTemp );
    }

    LeaveCriticalSection( &(g_TraceMemoryCS) );

    return;
}

#endif // DBG


DWORD
DavReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;

    //
    // Open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    //
    // Log the error code specified.
    //
    if( !ReportEventW(EventlogHandle,
                      (WORD)EventType,
                      0,            // event category
                      EventID,
                      NULL,
                      (WORD)NumStrings,
                      DataLength,
                      Strings,
                      Data) ) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DavReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;

    //
    // Open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    //
    // Log the error code specified.
    //
    if( !ReportEventA(EventlogHandle,
                      (WORD)EventType,
                      0,            // event category
                      EventID,
                      NULL,
                      (WORD)NumStrings,
                      DataLength,
                      Strings,
                      Data) ) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


VOID
DavClientEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/
{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    wsprintfA( ErrorCodeOemString, "%lu", ErrorCode );

    Strings[0] = ErrorCodeOemString;

    Error = DavReportEventA(EventID,
                            EventType,
                            1,
                            sizeof(ErrorCode),
                            Strings,
                            &ErrorCode);
    if( Error != ERROR_SUCCESS ) {
        DavPrint(( DEBUG_ERRORS, "DavReportEventA failed, %ld.\n", Error ));
    }

    return;
}


#if 1

typedef ULONG (*DBGPRINTEX)(ULONG, ULONG, PCH, va_list);

ULONG
vDbgPrintEx(
    ULONG ComponentId,
    ULONG Level,
    PCH Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine has been written to help load the service on Win2K machines.
    The debug version of some libraries call vDbgPrintfEx which has been
    implemented in Whistler and hence does not exist in Win2k's ntdll.dll.
    BryanT added it to help solve this problem.

Arguments:

    ComponentId -
    
    Level -
    
    Format -
    
    arglist -

Return Value:

    ERROR_SUCCESS or the Win32 error code.

--*/
{

    DBGPRINTEX pfnDbgPrintEx = (DBGPRINTEX) GetProcAddress(GetModuleHandle(L"ntdll"), "vDbgPrintEx");
    if (pfnDbgPrintEx) {
        return (*pfnDbgPrintEx)(ComponentId, Level, Format, arglist);
    } else {
        char Buf[2048];
        _vsnprintf(Buf, sizeof(Buf), Format, arglist);
        DbgPrint(Buf);
        return 0;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This file contains globals and prototypes for user mode webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999
    
    Rohan Kumar [RohanK]  01-Sept-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DAVGLOBAL_H
#define _DAVGLOBAL_H

#pragma once

#include <winsock2.h>
#include <align.h>
#include <winbasep.h>
#include "validc.h"

//
// If the following line is commented, the WinInet calls that are made will be
// synchronous and we use the Win32 thread pool to do the management. If its
// not commented, then we use WinInet asynchronously.
//
// #define DAV_USE_WININET_ASYNCHRONOUSLY 1

//
// svcmain.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef  GLOBAL_DATA_ALLOCATE
#undef EXTERN
#define EXTERN
#define GLOBAL_DATA_ALLOCATED
#undef INIT_GLOBAL
#define INIT_GLOBAL(v) =v
#else
#define EXTERN extern
#define INIT_GLOBAL(v)
#endif

#define DAV_MAXTHREADCOUNT_DEFAULT 6
#define DAV_THREADCOUNT_DEFAULT 2

//
// Define all global variables here.
//
EXTERN HANDLE DavRedirDeviceHandle INIT_GLOBAL(INVALID_HANDLE_VALUE);

EXTERN CRITICAL_SECTION         g_DavServiceLock;
EXTERN HINSTANCE                g_hinst;

EXTERN BOOL                     g_RpcActive INIT_GLOBAL(FALSE);
EXTERN BOOL                     g_RedirLoaded INIT_GLOBAL(FALSE);
EXTERN BOOL                     g_registeredService INIT_GLOBAL(FALSE);

EXTERN BOOL                     g_WorkersActive INIT_GLOBAL(FALSE);

EXTERN SERVICE_STATUS_HANDLE    g_hStatus;
EXTERN SERVICE_STATUS           g_status;

EXTERN ULONG                    DavInitialThreadCount;
EXTERN ULONG                    DavMaxThreadCount;

EXTERN PUMRX_USERMODE_REFLECT_BLOCK DavReflectorHandle INIT_GLOBAL(NULL);

EXTERN WSADATA g_wsaData;
EXTERN BOOLEAN g_socketinit;

EXTERN BOOL g_LUIDDeviceMapsEnabled;

EXTERN UNICODE_STRING RedirDeviceName;

//
// This handle is set using InternetOpen function. The process passes this
// handle to subsequent functions like InternetConnect. Its maintained as a
// global to avoid creating such a handle on every call which goes to the
// server.
//
extern HINTERNET IHandle;

//
// A synchronous version of the Internet handle. This is used to satisfy some
// if the NP APIs without going to the kernel.
//
extern HINTERNET ISyncHandle;

//
// Dav Use Table. This table stores the "net use" connections made by the users
// per LogonId.
//
extern DAV_USERS_OBJECT DavUseObject;

//
// Number of users logged on to the system. The Critical section below it
// synchronizes the acces to this variable.
//
extern ULONG DavNumberOfLoggedOnUsers;
extern CRITICAL_SECTION DavLoggedOnUsersLock;
extern CRITICAL_SECTION DavPassportLock;

//
// The "wait hint time" told to the service control manager when the DAV
// service is starting.
//
#define DAV_WAIT_HINT_TIME 60000 // 60 Seconds

//
// Error codes special to DAV. Defined in RFC 2518 (Section 10). Its interesting
// to note that the value DAV_STATUS_INSUFFICIENT_STORAGE (below) has a higher
// value than HTTP_STATUS_LAST defined in WinInet.h. So, this value (507)
// becomes the highest possible return status from a Http/Dav server.
//
#define DAV_MULTI_STATUS                  207
#define DAV_STATUS_UNPROCESSABLE_ENTITY   422
#define DAV_STATUS_LOCKED                 423
#define DAV_STATUS_FAILED_DEPENDENCY      424
#define DAV_STATUS_INSUFFICIENT_STORAGE   507

//
// The dummy share that is added when a user does a "net use * http://server". 
// We allow this since this implies mapping a drive to the root of the DAV
// server.
//
#define DAV_DUMMY_SHARE L"DavWWWRoot"

//
// The different states of a server entry.
//
typedef enum _SERVER_ENTRY_STATES {

    //
    // Some thread is currently initializing this server entry.
    //
    ServerEntryInitializing = 0,

    //
    // The initialization was unsuccessful and this server is not being
    // considered a DAV server.
    //
    ServerEntryInitializationError,

    //
    // The server entry has been initializeed and is ready to use.
    //
    ServerEntryInitialized

} SERVER_ENTRY_STATES;

//
// The Server Hash Table entry.
//
typedef struct _HASH_SERVER_ENTRY {

    //
    // Name.
    //
    PWCHAR ServerName;

    //
    // Server ID. This ID is sent up by the kernel and is unique per server.
    //
    ULONG ServerID;

    //
    // The state of the server entry.
    //
    SERVER_ENTRY_STATES ServerEntryState;

    //
    // This event is set by the thread which creates and initializes a server
    // after it has initialized it. This is to wake up any threads which could
    // have been waiting for the initialization to finish.
    //
    HANDLE ServerEventHandle;
    
    //
    // If the initialization was unsuccessful, the error status is filled in
    // this varriable.
    //
    ULONG ErrorStatus;

    //
    // Is it a HTTP server ?
    //
    BOOL isHttpServer;

    //
    // Does it support the DAV extensions ?
    //
    BOOL isDavServer;

    //
    // Is it the Microsoft IIS ?
    //
    BOOL isMSIIS;

    //
    // Is it an Office Web Server?
    //
    BOOL isOfficeServer;
    
    //
    // Is it a TAHOE Server?
    //
    BOOL isTahoeServer;
    
    //
    // Does it support PROPPATCH ?
    //
    BOOL fSupportsProppatch;    
    
    //
    // Pointer to the per user list.
    //
    LIST_ENTRY PerUserEntry;

    //
    // The next entry.
    //
    LIST_ENTRY ServerListEntry;

    //
    // We need to keep a reference count on this ServerEntry.
    //
    ULONG ServerEntryRefCount;

    //
    // Size of this entry including the server name.
    //
    ULONG EntrySize;

    //
    // The timer value used in the delayed SrvCall finalization.
    //
    time_t TimeValueInSec;

    //
    // This is set to TRUE if the worker thread tried to finalize this server
    // hash entry. If this server entry is moved from "to be finalized" list
    // to the hash table, this value is checked. If its TRUE, it implies that
    // the reference counts on the user entries were decremented by the worker
    // thread and have to be incremented back again. It also implies that the
    // state of the user entry was set to closing and has to be reset.
    //
    BOOL HasItBeenScavenged;
    BOOL CookieIsNotUsed;

    //
    // This should be the last field.
    //
    WCHAR StrBuffer[1];

} HASH_SERVER_ENTRY, *PHASH_SERVER_ENTRY;

//
// TimeValueInSec is set to this value if it should not be removed from the
// Server hash table.
//
#define DONT_EXPIRE -1

//
// Whenever we encounter a server that does not speak the DAV protocol in the
// DavrDoesServerDoDav function, we add it to the NonDAVServerList. An entry
// is kept on this list for ServerNotFoundCacheLifeTimeInSec (a global read
// from the registry during service start-up). Before going on the network
// to figure out whether a server does DAV, we look in the list to see if we
// have already seen this server (which does not do DAV) and fail the call.
//
extern LIST_ENTRY NonDAVServerList;
extern CRITICAL_SECTION NonDAVServerListLock;

//
// The ServerEntry that is created and added to the NonDAVServerList each time
// we encounter a server that does not speak the DAV protocol in the 
// 
//
typedef struct _NON_DAV_SERVER_ENTRY {

    LIST_ENTRY listEntry;

    //
    // The name of the server which does not speak WebDAV.
    //
    PWCHAR ServerName;

    //
    // The time of creation of this entry.
    //
    time_t TimeValueInSec;

} NON_DAV_SERVER_ENTRY, *PNON_DAV_SERVER_ENTRY;

//
// The delay in sec that the user mode adds (to the finalization of the SrvCall)
// after the kernel mode does the finalization of the SrvCall.
//
#define DAV_SERV_CACHE_VALUE L"ServerNotFoundCacheLifeTimeInSec"
extern ULONG ServerNotFoundCacheLifeTimeInSec;

//
// Should we accept/claim the OfficeWebServers and TahoeWebServers.
//
#define DAV_ACCEPT_TAHOE_OFFICE_SERVERS L"AcceptOfficeAndTahoeServers"
extern ULONG AcceptOfficeAndTahoeServers;

//
// The Global HashTable containing the HashServerEntries and the lock used while
// accessing it. The server table has 512 entries because each entry is 8 bytes
// and so the table size is 4096 bytes (1 page).
//
#define SERVER_TABLE_SIZE  512
#define MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID (((DWORD)(-1))/SERVER_TABLE_SIZE)

//
// The hash table containing server entries. When a CreateSrvCall requests comes
// up, this table is checked to see if the server entry exists. if it does not
// a new entry is created and added to the list.
//
extern LIST_ENTRY ServerHashTable[SERVER_TABLE_SIZE];

//
// This critical section synchronizes access to the ServerHashTable.
//
extern CRITICAL_SECTION HashServerEntryTableLock;

//
// This is a counter that gets incremented everytime a new server entry is
// created in the hash table. This defines the unique server id for the entry.
// The id values are never reused.
//
extern ULONG ServerIDCount;

//
// Mentioned below are the custom OFFICE and TAHOE headers which will be 
// returned in the response to a PROPFIND request.
//
extern WCHAR *DavTahoeCustomHeader;
extern WCHAR *DavOfficeCustomHeader;

//
// This list contains the following types of server entries:
// 1. The server entires for whom the SrvCall finalization has been received
//    from the kernel mode.
// 2. Server entries which failed during the Creation of SrvCall (after the
//    memory was allocated for the entry) and,
// This list is maintained for two reasons:
// 1. To delay the finalization of the SrvCall in user mode.  Instead of
//    finalizing these entries right away (after receiving the request from the
//    kernel), we keep them around for a certain time (say t sec). If a request
//    for creating a SrvCall for this server comes up again in these t sec, then
//    we just move this entry back to the ServerHashTable. This helps us in
//    avoiding network calls and,
// 2. To do negative caching. If a machine (for which the CreateSrvCall request
//    came up) is not a DAV server, we maintain this info for a while (t sec).
//    If another SrvCall request for the same server comes up in this t sec,
//    we can return error without going to the net. This is what we mean by
//    negative caching.
// A worker thread periodically goes over the list and checks the time each
// entry has spent in the list. If the time exceeds a certain threshold (t sec
// as defined above), it is removed from the list and finalized. The lock used
// to synchronize access to this list is the same one used to aceess the
// ServerHashEntry table.
//
extern LIST_ENTRY ToBeFinalizedServerEntries;

//
// The different states of a user entry.
//
typedef enum _USER_ENTRY_STATES {

    //
    // This user entry has been created, but not initialized.
    //
    UserEntryAllocated = 0,

    //
    // Some thread is currently initializing this entry.
    //
    UserEntryInitializing,

    //
    // The initialization was unsuccessful.
    //
    UserEntryInitializationError,

    //
    // The entry has been initialized and is ready to use.
    //
    UserEntryInitialized,

    //
    // The entry is going to be freed soon. If the entry is in this state,
    // no one should be using it.
    //
    UserEntryClosing

} USER_ENTRY_STATES;

//
// The "Per User Entry" data structure. A list of such entries is maintained
// per server entry in the server hash table (see below).
//
typedef struct _PER_USER_ENTRY {

    //
    // Unique logon/user ID for this session.
    //
    LUID LogonID;

    //
    // The server hash entry off which this user entry is hanging.
    //
    PHASH_SERVER_ENTRY ServerHashEntry;

    //
    // Pointer to the next "per user entry" for this server.
    //
    LIST_ENTRY UserEntry;

    //
    // The InternetConnect handle.
    //
    HINTERNET DavConnHandle;

    //
    // The state of this user entry. The thread that creates this user entry
    // sets its state to "UserEntryInitializing" before it initializes it.
    // This is done so that any other thread that comes in looking for this
    // entry when its in the middle of its initialization process can wait.
    //
    USER_ENTRY_STATES UserEntryState;

    //
    // This event is set by the thread which creates and initializes a user
    // after it has initialized it. This is to wake up any threads which could
    // have been waiting for the initialization to finish.
    //
    HANDLE UserEventHandle;

    //
    // The reference count value of this entry. This value is used in managing
    // the resource.
    //
    ULONG UserEntryRefCount;

    //
    // If the initialization was unsuccessful, the error status is filled in
    // this varriable.
    //
    ULONG ErrorStatus;

    //
    // The passport cookie for the this user/server pair.
    //
    PWCHAR Cookie;

    PWCHAR UserName;
    PWCHAR Password;
  
} PER_USER_ENTRY, *PPER_USER_ENTRY;

#define PASSWORD_SEED 0x25

#include <davrpc.h>
#include "debug.h"

//
// Function prototypes go here.
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    );

DWORD
SetupRpcServer(
    VOID
    );

DWORD
StopRpcServer(
    VOID
    );

VOID
UpdateServiceStatus (
    DWORD dwState
    );

NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    );

NET_API_STATUS
WsMapStatus(
    IN NTSTATUS NtStatus
    );

DWORD
DavReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

NET_API_STATUS
WsLoadRedir(
    VOID
    );

NET_API_STATUS
WsUnloadRedir(
    VOID
    );

DWORD
DavInitWorkerThreads(
    IN  ULONG  InitialThreadCount,
    IN  ULONG  MaxThreadCount
    );

DWORD
DavTerminateWorkerThreads(
    VOID
    );

ULONG
DavInit(
    VOID
    );

VOID
DavClose(
    VOID
    );

ULONG
DavHashTheServerName(
    PWCHAR ServerName
    );

BOOL
DavIsThisServerInTheTable(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    );

BOOL 
DavIsServerInFinalizeList(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry,
    IN BOOL ReactivateIfExists
    );

VOID
DavInitializeAndInsertTheServerEntry(
    IN OUT PHASH_SERVER_ENTRY ServerHashEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    );

VOID
DavFinalizeToBeFinalizedList(
    VOID
    );

DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    );

ULONG
InitializeTheSocketInterface(
    VOID
    );

NTSTATUS
CleanupTheSocketInterface(
    VOID
    );

DWORD
DavAsyncCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateSrvCallCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncQueryDirectoryCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateVNetRootCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncReName(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncReNameCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


DWORD
DavAsyncSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncSetFileInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncClose(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCloseCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavQueryPassportCookie(
    IN HINTERNET RequestHandle,
    IN OUT PWCHAR *Cookie
    );

VOID
DavDumpHttpResponseHeader(
    HINTERNET OpenHandle
    );

VOID
DavDumpHttpResponseData(
    HINTERNET OpenHandle
    );

ULONG
DavQueryAndParseResponse(
    HINTERNET DavOpenHandle
    );

ULONG
DavQueryAndParseResponseEx(
    IN HINTERNET DavOpenHandle,
    OUT PULONG HttpResponseStatus OPTIONAL
    );

VOID
DavRemoveDummyShareFromFileName(
    PWCHAR FileName
    );

ULONG
DavMapHttpErrorToDosError(
    ULONG HttpResponseStatus
    );

//
// The callback function used in asynchronous requests.
//
VOID
_stdcall
DavHandleAsyncResponse(
    HINTERNET IHandle,
    DWORD_PTR CallBackContext,
    DWORD InternetStatus,
    LPVOID StatusInformation,
    DWORD StatusInformationLength
    );

DWORD
WINAPI
DavCommonDispatch(
    LPVOID Context
    );

DWORD 
DavAsyncCommonStates(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

BOOL
DavDoesUserEntryExist(
    IN PWCHAR ServerName,
    IN ULONG ServerID,
    IN PLUID LogonID,
    OUT PPER_USER_ENTRY *PerUserEntry,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    );

BOOL
DavFinalizePerUserEntry(
    PPER_USER_ENTRY *PUE
    );

ULONG
DavFsSetTheDavCallBackContext(
    IN OUT PDAV_USERMODE_WORKITEM pDavWorkItem
    );

VOID
DavFsFinalizeTheDavCallBackContext(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

//
// Functions exposed to the usermode reflector library.
//
ULONG
DavFsCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeFobx(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncQueryVolumeInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );
    
ULONG
DavFsReName(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


ULONG
DavFsSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );
    
ULONG
DavFsClose(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

NTSTATUS
DavMapErrorToNtStatus(
    DWORD dwWininetError
    );

NTSTATUS
DavDosErrorToNtStatus(
    DWORD dwError
    );
VOID
DavObtainServerProperties(
    PWCHAR lpInParseData, 
    BOOL    *lpfIsHttpServer,
    BOOL    *lpfIsIIs,
    BOOL    *lpfIsDavServer
    );

DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  lpPathName
    );

DWORD
DavSetBasicInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  PathName,
    BOOL fCreationTimeChanged,
    BOOL fLastAccessTimeChanged,
    BOOL fLastModifiedTimeChanged,
    BOOL fFileAttributesChanged,
    IN LARGE_INTEGER *lpCreationTime,
    IN LARGE_INTEGER *lpLastAccessTime,
    IN LARGE_INTEGER *lpLastModifiedTime,
    DWORD   dwFileAttributes
    );

DWORD
DavReportEventInEventLog(
    DWORD EventType,
    DWORD EventId,
    DWORD NumberOfStrings,
    PWCHAR *EventStrings
    );

DWORD
DavFormatAndLogError(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    DWORD Win32Status
    );


DWORD
DavParseXmlResponse(
    HINTERNET DavOpenHandle,
    DAV_FILE_ATTRIBUTES *pDavFileAttributesIn,
    DWORD               *pNumFileEntries
    );

DWORD
DavAttachPassportCookie(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle,
    PWCHAR *PassportCookie
    );

DWORD
DavInternetSetOption(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle
    );

#endif // DAVGLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main entry point for the service control manager for the web
    dav mini-redir service.

Author:

    Rohan Kumar        [RohanK]        08-Feb-2000

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include <svcs.h>

//
// Allocate global data in this file.
//
#define GLOBAL_DATA_ALLOCATE
#include "global.h"

DWORD DavStop = 0;

//
// The amount of time in seconds a server entry is cached in the ServerNotFound
// cache.
//
ULONG ServerNotFoundCacheLifeTimeInSec = 0;

//
// Should we accept/claim the OfficeWebServers and TahoeWebServers.
//
ULONG AcceptOfficeAndTahoeServers = 0;

PSVCHOST_GLOBAL_DATA DavSvcsGlobalData;

DWORD
DavNotRunningAsAService(
    VOID
    );

DWORD 
WINAPI
DavFakeServiceController(
    LPVOID Parameter
    );

BOOL
DavCheckLUIDDeviceMapsEnabled(
    VOID
    );

VOID
DavReadRegistryValues(
    VOID
    );

VOID
WINAPI
DavServiceHandler (
    DWORD dwOpcode
    )
/*++

Routine Description:

    This function is called by the Service Controller at various times when the
    service is running.

Arguments:

    dwOpcode - Reason for calling the service handler.

Return Value:

    none.

--*/
{
    DWORD err;
    switch (dwOpcode) {

    case SERVICE_CONTROL_SHUTDOWN:

        //
        // Lack of break is intentional!
        //

    case SERVICE_CONTROL_STOP:
        
        DavPrint((DEBUG_INIT, "DavServiceHandler: WebClient service is stopping.\n"));
        
        UpdateServiceStatus(SERVICE_STOP_PENDING);
        
        if (g_WorkersActive) {
            err = DavTerminateWorkerThreads();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/DavTerminateWorkerThreads: "
                          "Error Val = %u.\n", err));
            }
            g_WorkersActive = FALSE;
        }

        //
        // Close and free up the DAV stuff.
        //
        DavClose();

        if (g_socketinit) {
            err = CleanupTheSocketInterface();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/CleanupTheSocketInterface: "
                          "Error Val = %u.\n", err));
            }
            g_socketinit = FALSE;
        }

        if (g_RpcActive) {
            DavSvcsGlobalData->StopRpcServer(davclntrpc_ServerIfHandle);
            g_RpcActive = FALSE;
        }

        if (DavReflectorHandle != NULL) {
            err = UMReflectorStop(DavReflectorHandle);
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/UMReflectorStop: Error Val = %u.\n", err));
            }
            err = UMReflectorUnregister(DavReflectorHandle);
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/UMReflectorUnregister: Error Val = 0x%x.\n", err));
            }
            DavReflectorHandle = NULL;
        }

        if (g_RedirLoaded) {
            err = WsUnloadRedir();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/WsUnloadRedir: Error Val = %u.\n", err));
            }
            g_RedirLoaded = FALSE;
        }

        DeleteCriticalSection ( &(g_DavServiceLock) );

        DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is stopped.\n"));

        UpdateServiceStatus(SERVICE_STOPPED);
        
        break;

     case SERVICE_CONTROL_INTERROGATE:
        
         //
         // Refresh our status to the SCM.
         //
         SetServiceStatus(g_hStatus, &g_status);
        
         break;

    default:
        
        //
        // This may not be needed, but refresh our status to the service
        // controller.
        //
        DavPrint((DEBUG_INIT, "DavServiceHandler: WebClient service received SCM "
                  "Opcode = %08lx\n", dwOpcode));
        
        ASSERT (g_hStatus);
        
        SetServiceStatus (g_hStatus, &g_status);
        
        break;

    }

    return;
}

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    DavSvcsGlobalData = pGlobals;
}

VOID
WINAPI
ServiceMain (
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    )
/*++

Routine Description:

    This function is called by the Service Control Manager when starting this 
    service.

Arguments:

    dwNumServicesArgs - Number of arguments.
    
    lpServiceArgVectors - Array of arguments.

Return Value:

    None.

--*/
{
    DWORD err = ERROR_SUCCESS;
    DWORD exitErr = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG maxThreads = 0, initialThreads = 0, RedirRegisterCount = 0;
    BOOL RunningAsAService = TRUE;

#if DBG
    DebugInitialize();
#endif

    DavReadRegistryValues();

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(DavSvcsGlobalData != NULL);
    
#if DBG
    {
        DWORD cbP = 0;
        WCHAR m_szProfilePath[MAX_PATH];
        cbP = GetEnvironmentVariable(L"USERPROFILE", m_szProfilePath, MAX_PATH);
        m_szProfilePath[cbP] = L'\0';
        DavPrint((DEBUG_MISC, "DavServiceMain: USERPROFILE: %ws\n", m_szProfilePath));
    }
#endif

    g_RedirLoaded = FALSE;
    
    g_WorkersActive = FALSE;
    
    g_registeredService = FALSE;

    //
    // Initialize the SERVICE_STATUS structure g_status.
    //
    ZeroMemory (&g_status, sizeof(g_status));
    
    g_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;

    g_status.dwControlsAccepted = (SERVICE_ACCEPT_STOP | SERVICE_CONTROL_SHUTDOWN);

    g_status.dwCheckPoint = 1;

    g_status.dwWaitHint = DAV_WAIT_HINT_TIME;

    DavPrint((DEBUG_MISC, 
              "DavServiceMain: lpServiceArgVectors[0] = %ws\n", lpServiceArgVectors[0]));
    
    if ( lpServiceArgVectors[0] && 
         ( wcscmp(lpServiceArgVectors[0], L"notservice") == 0 ) ) {

        DavPrint((DEBUG_MISC, "DavServiceMain: WebClient is not running as a Service.\n"));

    } else {

        DavPrint((DEBUG_MISC, "DavServiceMain: WebClient is running as a Service.\n"));

        try {
            InitializeCriticalSection ( &(g_DavServiceLock) );
        } except(EXCEPTION_EXECUTE_HANDLER) {
              err = GetExceptionCode();
              DavPrint((DEBUG_ERRORS,
                        "DavServiceMain/InitializeCriticalSection: Exception Code ="
                        " = %08lx.\n", err));
              goto exitServiceMain;
        }
        
        //
        // Register the service control handler.
        //
        g_hStatus = RegisterServiceCtrlHandler(SERVICE_DAVCLIENT, DavServiceHandler);
        if (g_hStatus) {
            g_registeredService = TRUE;
            DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is pending start.\n"));
        } else {
            DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service failed to register.\n"));
            goto exitServiceMain;
        }
    }

    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Attempt to load the mini-redir driver.  If this fails, no point in us
    // starting up.
    //
    while (TRUE) {
    
        err = WsLoadRedir();
        if (err == ERROR_SERVICE_ALREADY_RUNNING || err == ERROR_SUCCESS) {
            DavPrint((DEBUG_MISC, "DavServiceMain/WsLoadRedir. Succeeded\n"));
            break;
        }

        //
        // If the transports are not ready, the MiniRedir returns an
        // error STATUS_REDIRECTOR_NOT_STARTED which maps to the Win32 error
        // ERROR_PATH_NOT_FOUND. In this case we sleep for 3 seconds and try 
        // again with the hope that the transports will be ready soon. Also,
        // we update the service status to inform the SCM that we are doing
        // some work. We try this 5 times (till RedirRegisterCount == 4) and 
        // if are unsuccessful, we give up.
        //
        if (err == ERROR_PATH_NOT_FOUND) {
        
            RedirRegisterCount++;

            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsLoadRedir. RedirRegisterCount = %d\n",
                      RedirRegisterCount));

            if (RedirRegisterCount >= 4) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/WsLoadRedir(1). Error Val = %d\n",
                          err));
                goto exitServiceMain;
            }

            //
            // Sleep for 3 seconds.
            //
            Sleep(3000);

            (g_status.dwCheckPoint)++;
            UpdateServiceStatus(SERVICE_START_PENDING);

            continue;

        } else {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsLoadRedir(2). Error Val = %d\n",
                      err));
            goto exitServiceMain;
        }

    }

    g_RedirLoaded = TRUE;

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Initialize the global NT-style redirector device name string.
    //
    RtlInitUnicodeString(&RedirDeviceName, DD_DAV_DEVICE_NAME_U);

    //
    // Try to register the mini-redir.
    //
    err = UMReflectorRegister(DD_DAV_DEVICE_NAME_U,
                              UMREFLECTOR_CURRENT_VERSION,
                              &(DavReflectorHandle));
    if ((DavReflectorHandle == NULL) || (err != ERROR_SUCCESS)) {
        if (err == ERROR_SUCCESS) {
            err = ERROR_BAD_DRIVER;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/UMReflectorRegister. Error Val = %d\n",
                  err));
        goto exitServiceMain;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Try to start the mini-redir.
    //
    err = UMReflectorStart(UMREFLECTOR_CURRENT_VERSION, DavReflectorHandle);
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/UMReflectorStart. Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);
    
    //
    // Initialize the socket interface.
    //
    err = InitializeTheSocketInterface();
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/InitializeTheSocketInterface: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    //
    // Setup the DAV/WinInet environment.
    //
    err = DavInit();
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/DavInit: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    //
    // Start the worker thread.  This will handle completion routines queued
    // from other worker threads and from the request ioctl threads.
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DAV_PARAMETERS_KEY,
                       0,
                       KEY_QUERY_VALUE,
                       &KeyHandle);
    if (err == ERROR_SUCCESS) {
        maxThreads = ReadDWord(KeyHandle,
                               DAV_MAXTHREADS_KEY,
                               DAV_MAXTHREADCOUNT_DEFAULT);
        initialThreads = ReadDWord(KeyHandle,
                                   DAV_THREADS_KEY,
                                   DAV_THREADCOUNT_DEFAULT);
        RegCloseKey(KeyHandle);
    } else {
        maxThreads = DAV_MAXTHREADCOUNT_DEFAULT;
        initialThreads = DAV_THREADCOUNT_DEFAULT;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);
    
    err = DavInitWorkerThreads(initialThreads, maxThreads);
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/DavInitWorkerThread: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    g_WorkersActive = TRUE;

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    g_LUIDDeviceMapsEnabled = DavCheckLUIDDeviceMapsEnabled();

    //
    // Immediately report that we are running.  All non-essential initialization
    // is deferred until we are called by clients to do some work.
    //
    DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is now running.\n"));
    
    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Setup RPC server for this service.
    //
    if (!g_RpcActive) {
        err = DavSvcsGlobalData->StartRpcServer(L"DAV RPC SERVICE",
                                                davclntrpc_ServerIfHandle);
        if (err == STATUS_SUCCESS) {
            g_RpcActive = TRUE;
        } else {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/SetupRpcServer: Error Val = %u.\n", err));
        }
    }

    UpdateServiceStatus(SERVICE_RUNNING);
    
    return;

exitServiceMain:

    if (g_WorkersActive) {
        exitErr = DavTerminateWorkerThreads();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/DavTerminateWorkerThreads: "
                      "Error Val = %u.\n", exitErr));
        }
        g_WorkersActive = FALSE;
    }

    //
    // Close and free up the DAV stuff.
    //
    DavClose();

    if (g_socketinit) {
        exitErr = CleanupTheSocketInterface();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/CleanupTheSocketInterface: "
                      "Error Val = %u.\n", exitErr));
        }
        g_socketinit = FALSE;
    }

    if (g_RpcActive) {
        DavSvcsGlobalData->StopRpcServer(davclntrpc_ServerIfHandle);
        g_RpcActive = FALSE;
    }

    if (DavReflectorHandle != NULL) {
        exitErr = UMReflectorStop(DavReflectorHandle);
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/UMReflectorStop: Error Val = %u.\n", exitErr));
        }
        exitErr = UMReflectorUnregister(DavReflectorHandle);
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/UMReflectorUnregister: Error Val = 0x%x.\n", exitErr));
        }
        DavReflectorHandle = NULL;
    }

    if (g_RedirLoaded) {
        exitErr = WsUnloadRedir();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsUnloadRedir: Error Val = %u.\n", exitErr));
        }
        g_RedirLoaded = FALSE;
    }

    DeleteCriticalSection ( &(g_DavServiceLock) );

    //
    // Let the SCM know why the service did not start.
    //
    if (err != NO_ERROR) {
        UpdateServiceStatus(err);
    }
    
    DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is stopped.\n"));

#if DBG
    DebugUninitialize();
#endif

    return;
}


DWORD
DavNotRunningAsAService(
    VOID
    )
/*++

Routine Description:
    
    The DavClient is not being run as a Service.

Arguments:
    
    None.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
    Win32 Error Code - Something went wrong.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HANDLE Thread;
    DWORD  ThreadId;
    PWCHAR NotSrv = L"notservice";
    
    //
    // Create a thread for the fake service controller.
    //
    Thread = CreateThread( NULL, 0, DavFakeServiceController, 0, 0, &ThreadId );
    if (Thread == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavNotRunningAsAService/CreateThread: Error Val = %d.\n", WStatus));
        return WStatus;
    }

    //
    // Call the Sevice Main function of the DavClient service.
    //
    ServiceMain( 2, &(NotSrv) );
    
    return WStatus;
}


DWORD 
WINAPI
DavFakeServiceController(
    LPVOID Parameter
    )
/*++

Routine Description:
    
    The Fake service control for the DavClient when it is not running as a 
    service. This is used to send a STOP signal to the DavClient. 

Arguments:
    
    Parameter - Dummy parameter.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
--*/
{
    while (DavStop == 0) {
        Sleep(1000);
    }

    DavServiceHandler( SERVICE_CONTROL_STOP );

    return 0;
}

BOOL
DavCheckLUIDDeviceMapsEnabled(
    VOID
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    none

Return Value:

    TRUE - LUID device maps are enabled

    FALSE - LUID device maps are disabled

--*/

{

    NTSTATUS   Status;
    ULONG      LUIDDeviceMapsEnabled;
    BOOL       Result;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}


VOID
_cdecl
main (
    IN INT ArgC,
    IN PCHAR ArgV[]
    )
/*++

Routine Description:
    
    Main (DavClient) runs as either a service or an exe.

Arguments:
    
    ArgC - Number of arguments.
    
    ArgV - Array of arguments.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
    Win32 Error Code - Something went wrong.

--*/
{

    BOOL RunningAsAService = TRUE;
    BOOL ReturnVal = FALSE;
    SERVICE_TABLE_ENTRYW DavServiceTableEntry[] = { 
                                                    { SERVICE_DAVCLIENT, ServiceMain },
                                                    { NULL,              NULL }
                                                  };

    //
    // Are we running as a service or an exe ?
    //
    if ( ArgV[1] != NULL ) {
        if ( strstr(ArgV[1], "notservice") != NULL) {
            RunningAsAService = FALSE;
        }
    }

    if (RunningAsAService) {

        ReturnVal = StartServiceCtrlDispatcher(DavServiceTableEntry);
        if ( !ReturnVal ) {
            DavPrint((DEBUG_ERRORS,
                      "main/StartServiceCtrlDispatcher: Error Val = %d.\n", 
                      GetLastError()));
        }

    } else {

        DWORD WStatus;

        WStatus = DavNotRunningAsAService();
        if ( WStatus != ERROR_SUCCESS ) {
            DavPrint((DEBUG_ERRORS,
                      "main/DavNotRunningAsAService: Error Val = %d.\n", 
                      WStatus));
        }

    }

    return;
}


VOID
DavReadRegistryValues(
    VOID
    )
/*++

Routine Description:
    
    This function reads some values from the registry and sets the globals in
    the WebClient service.

Arguments:
    
    None.

Return Value:
    
    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG ValueType = 0, ValueSize = 0;

    WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            DAV_PARAMETERS_KEY,
                            0,
                            KEY_QUERY_VALUE,
                            &(KeyHandle));
    if (WStatus != ERROR_SUCCESS) {
        KeyHandle = NULL;
        ServerNotFoundCacheLifeTimeInSec = 60;
        AcceptOfficeAndTahoeServers = 0;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegOpenKeyExW. WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we fail in getting the values from the registry, set them to default
    // values.
    //
    
    ValueSize = sizeof(ServerNotFoundCacheLifeTimeInSec);

    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_SERV_CACHE_VALUE,
                               0,
                               &(ValueType),
                               (LPBYTE)&(ServerNotFoundCacheLifeTimeInSec),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        ServerNotFoundCacheLifeTimeInSec = 60;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(1). WStatus = %d\n", WStatus);
    }

    ValueSize = sizeof(AcceptOfficeAndTahoeServers);
    
    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_ACCEPT_TAHOE_OFFICE_SERVERS,
                               0,
                               &(ValueType),
                               (LPBYTE)&(AcceptOfficeAndTahoeServers),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        AcceptOfficeAndTahoeServers = 0;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(2). WStatus = %d\n", WStatus);
    }

EXIT_THE_FUNCTION:

    if (KeyHandle) {
        RegCloseKey(KeyHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davutil.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davutil.c
    
Abstract:

    This module implements the user mode DAV miniredir routines pertaining to 
    initialization, callbacks etc.

Author:

    Rohan Kumar      [RohanK]      07-July-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include <time.h>
#include <objbase.h>
#include "UniUtf.h"
#include <netevent.h>

//
// Global definitions used in the DAV user mode process. These are explained
// in the header file "global.h".
//

HINTERNET IHandle = INVALID_HANDLE_VALUE;

HINTERNET ISyncHandle = INVALID_HANDLE_VALUE;

LIST_ENTRY ServerHashTable[SERVER_TABLE_SIZE];

CRITICAL_SECTION HashServerEntryTableLock = {0};
CRITICAL_SECTION DavPassportLock = {0};

//
// The BOOL is used in DavClose() to check if the critical section (see above)
// "HashServerEntryTableLock" was initialized. Since this is only used in 
// DavInit() and DavClose() functions, both os which are implemented in this
// file, this global is not exported in any header file.
//
BOOL ServerTableLockSet = FALSE;

ULONG ServerIDCount;

LIST_ENTRY ToBeFinalizedServerEntries;

BOOL didComInitialize = FALSE;

BOOL didDavUseObjectInitialize = FALSE;

BOOL DavUsingWinInetSynchronously = FALSE;

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

BOOL
DavFinalizeServerEntry (
    PHASH_SERVER_ENTRY ServerHashEntry
    );

//
// Implementation of functions begins here.
//

ULONG
DavInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the DAV environment.
    
Arguments:

    none.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    ULONG count = 0;
    DWORD NumOfConnections = 0, ConnBuffSize = 0;
    INTERNET_STATUS_CALLBACK DavCallBack;
    HRESULT hResult;
    BOOL ReturnVal;
    ULONG_PTR CallbackStatus;
    LPWSTR DAVUserAgent = NULL;
    OSVERSIONINFO osVersionInfo;
    WCHAR DAVUserAgentNameStr[] = L"Microsoft-WebDAV-MiniRedir";
    LONG DisableHKCUCaching = 0;

    // 
    // Get the OS version. This will be used to form WebDAV User Agent string.
    // This String is used in HttpPackects xchange.
    // 
    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFO));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo)) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/GetVersionEx. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DAVUserAgent = (LPWSTR) LocalAlloc ( LMEM_FIXED | LMEM_ZEROINIT,
              ( wcslen(DAVUserAgentNameStr) + // for: Microsoft-WebDAV-MiniRedir
            1 + // for L"/"
                5 + // for Major-Version
                1 + // for '.'
            5 + // for Minor-Version
            1 + // for '.'
            10  // for Build-No
            ) * sizeof (WCHAR));
            
    if (DAVUserAgent == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, "DavInit/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    swprintf(DAVUserAgent, L"%s/%d.%d.%d",
            DAVUserAgentNameStr,
            osVersionInfo.dwMajorVersion,
            osVersionInfo.dwMinorVersion,
            osVersionInfo.dwBuildNumber
            );
    
    
    //
    // Set the ConnectionsPerServer limit to infinity.
    //

    NumOfConnections = 0xffffffff;
    ConnBuffSize = sizeof(DWORD);
    
    ReturnVal = InternetSetOptionW(NULL,
                                   INTERNET_OPTION_MAX_CONNS_PER_SERVER,
                                   &(NumOfConnections),
                                   ConnBuffSize);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOptionW(1). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = InternetSetOptionW(NULL,
                                   INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER,
                                   &(NumOfConnections),
                                   ConnBuffSize);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOptionW(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }


    DavPrint((DEBUG_MISC, "DavInit: Using WinInet Synchronously\n"));

    DavUsingWinInetSynchronously = TRUE;
    
    //
    // Initialize an Internet handle for synchronous use.
    //
    IHandle = InternetOpenW((LPCWSTR)DAVUserAgent, //L"WebDav Miniredir",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (IHandle == NULL) {
        IHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetOpenW(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    {
        DWORD   dwDisable = 0;
        if(!InternetSetOptionW(IHandle, INTERNET_OPTION_DISABLE_AUTODIAL, &dwDisable, sizeof(DWORD)))
        {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        
        }
    }
    
    //
    // Initialize a synchronous Internet handle for synchronous use.
    //
    ISyncHandle = InternetOpenW((LPCWSTR)DAVUserAgent, //L"WebDav Miniredir",
                                INTERNET_OPEN_TYPE_PRECONFIG,
                                NULL,
                                NULL,
                                0);
    if (ISyncHandle == NULL) {
        ISyncHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetOpenW(3). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    {
        DWORD   dwDisable = 1;
        if(!InternetSetOptionW(ISyncHandle, INTERNET_OPTION_DISABLE_AUTODIAL, &dwDisable, sizeof(DWORD)))
        {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        
        }
    }
    //
    // Initialize the Global server hash table lock. Yes, 
    // InitializeCriticalSection can throw a STATUS_NO_MEMORY exception.
    //
    try {
        InitializeCriticalSection( &(HashServerEntryTableLock) );
        InitializeCriticalSection( &(ServerShareTableLock) );
        InitializeCriticalSection( &(DavLoggedOnUsersLock) );
        InitializeCriticalSection( &(DavPassportLock) );
        InitializeCriticalSection( &(NonDAVServerListLock) );
    } except(EXCEPTION_EXECUTE_HANDLER) {
          WStatus = GetExceptionCode();
          DavPrint((DEBUG_ERRORS,
                    "DavInit/InitializeCriticalSection: Exception Code ="
                    " = %08lx.\n", WStatus));
          goto EXIT_THE_FUNCTION;
    }
    ServerTableLockSet = TRUE;

    //
    // Initialize the hash table entries.
    //
    for (count = 0; count < SERVER_TABLE_SIZE; count++) {
        InitializeListHead( &(ServerHashTable[count]) );
    }

    //
    // Initialize the ServerShare table entries.
    //
    for (count = 0; count < SERVER_SHARE_TABLE_SIZE; count++) {
        InitializeListHead( &(ServerShareTable[count]) );
    }

    //
    // Set the ServerIDCount to zero;
    //
    ServerIDCount = 0;

    //
    // Set the number of logged on users to 0.
    //
    DavNumberOfLoggedOnUsers = 0;

    //
    // Initialize the "To Be Finalized Server Entries" list.
    //
    InitializeListHead( &(ToBeFinalizedServerEntries) );

    InitializeListHead( &(NonDAVServerList) );

    //
    // Initialize the COM library.
    //
    hResult = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (!SUCCEEDED(hResult)) {
        DavPrint((DEBUG_ERRORS, "DavInit/CoInitializeEx.\n"));
        goto EXIT_THE_FUNCTION;
    }
    didComInitialize = TRUE;

    //
    // Initialize the Dav "net use" table.
    //
    DavUseObject.TableSize = 0;
    DavUseObject.Table = NULL;
    RtlInitializeResource( &(DavUseObject.TableResource) );
    didDavUseObjectInitialize = TRUE;

    //
    // WinInet needs to store the secondary DA cache in the HKCU. Even though
    // the thread that is doing this write is impersonating a different user this
    // write happens in wind up in HKEY_USERS\S-1-5-19 (LocalSystem). This is
    // because of a bug in the registry APIs. First open of the predefined handle
    // will initialize the HKCU cache and any open after that doesn't take the
    // impersonation into account. Its not quite right, but its legacy by now
    // (been there since NT4) and cannot be changed. By calling the registry API
    // RegDisablePredefinedCache, we can disable this caching process wide. The
    // DA cache will now be stored in the right HKCU. Tweener spec states that
    // the secondary DA cache be stored in the HKCU hive so that all Tweener
    // apps (IE, WPW) can benefit from this single location.
    //
    DisableHKCUCaching = RegDisablePredefinedCache();
    if (DisableHKCUCaching != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavInit/RegDisablePredefinedCache: DisableHKCUCaching = %d\n",
                  DisableHKCUCaching));
    }

EXIT_THE_FUNCTION:

    if (WStatus != ERROR_SUCCESS) {

        if (IHandle != INVALID_HANDLE_VALUE) {
            BOOL ReturnVal;
            ReturnVal = InternetCloseHandle(IHandle);
            if (!ReturnVal) {
                ULONG CloseStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInit/InternetCloseHandle(1): Error Val = %d.\n", 
                          CloseStatus));
            }
            IHandle = INVALID_HANDLE_VALUE;
        }
    
        if (ISyncHandle != INVALID_HANDLE_VALUE) {
            BOOL ReturnVal;
            ReturnVal = InternetCloseHandle(ISyncHandle);
            if (!ReturnVal) {
                ULONG CloseStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInit/InternetCloseHandle(2): Error Val = %d.\n", 
                          CloseStatus));
            }
            ISyncHandle = INVALID_HANDLE_VALUE;
        }
    
    }

    if (DAVUserAgent != NULL) {
        LocalFree((HLOCAL)DAVUserAgent);
        DAVUserAgent = NULL;
    }
    
    return WStatus;
}


VOID
DavClose(
    VOID
    )
/*++

Routine Description:

    This routine frees up the resources acquired during the initialization of
    the DAV environment.
    
Arguments:

    none.
    
Return Value:

    none.

--*/
{
    //
    // Close IHandle if needed.
    //
    if (IHandle != INVALID_HANDLE_VALUE) {
        BOOL ReturnVal;
        ReturnVal = InternetCloseHandle(IHandle);
        if (!ReturnVal) {
            ULONG CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavClose/InternetCloseHandle(1): Error Val = %d.\n", 
                      CloseStatus));
        }
        IHandle = INVALID_HANDLE_VALUE;
    }

    if (ISyncHandle != INVALID_HANDLE_VALUE) {
        BOOL ReturnVal;
        ReturnVal = InternetCloseHandle(ISyncHandle);
        if (!ReturnVal) {
            ULONG CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavClose/InternetCloseHandle(2): Error Val = %d.\n", 
                      CloseStatus));
        }
        ISyncHandle = INVALID_HANDLE_VALUE;
    }
    
    //
    // Delete the critical section used for synchronizing the server hash table.
    //
    if (ServerTableLockSet) {
        DeleteCriticalSection( &(HashServerEntryTableLock) );
        DeleteCriticalSection( &(ServerShareTableLock) );
        DeleteCriticalSection( &(DavLoggedOnUsersLock) );
        DeleteCriticalSection( &(DavPassportLock) );
        ServerTableLockSet = FALSE;
    }

    if (didComInitialize) {
        CoUninitialize();
        didComInitialize = FALSE;
    }

    if (didDavUseObjectInitialize) {
        RtlDeleteResource( &(DavUseObject.TableResource) );
        didDavUseObjectInitialize = FALSE;
    }

    return;
}


ULONG
DavHashTheServerName(
    PWCHAR ServerName
    )
/*++

Routine Description:

    The hash function that takes in a string, hashes it to produce a ULONG
    which is returned to the caller.

Arguments:

    ServerName - Name to be hashed.

Return Value:

    The hashed value.

--*/
{
    ULONG HashedValue = 0, Val = 0, TotalVal = 0, shiftCount = 0;
    PWCHAR cPtr;

    if (ServerName == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavHashTheServerName. The ServerName is NULL.\n"));
        HashedValue = SERVER_TABLE_SIZE;
        return (HashedValue);
    }

    //
    // The for loop below forms the hashing logic. We take each character of the
    // server name, cast it to a ULONG, lshift it by shiftCount (0, 4, 8,...,28)
    // and add it to HashedValue. Once the shiftCount reaches 28, we reset it to
    // zero.
    //
    for (cPtr = ServerName; *cPtr != L'\0'; cPtr++) {
        Val = (ULONG)(*cPtr);
        Val = Val << shiftCount;
        shiftCount += 4;
        if (shiftCount == 28) {
            shiftCount = 0;
        }
        TotalVal += Val;
    }

    //
    // Fianlly we take the value % SERVER_TABLE_SIZE.
    //
    HashedValue = TotalVal % SERVER_TABLE_SIZE;

    DavPrint((DEBUG_MISC,
              "DavHashTheServerName. ServerName =%ws, HashValue = %d\n",
              ServerName, HashedValue));
    
    return (HashedValue);
}


BOOL 
DavIsThisServerInTheTable(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the hash table. If it does, the address of the entry is
    returned in the caller supplied buffer. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerHashEntry - Pointer to the Hash entry structure.

Return Value:

    TRUE - Server entry exists in the hash table
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PHASH_SERVER_ENTRY HashEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, 
              "DavIsThisServerInTheTable: Checking if ServerName: %ws exists "
              "in the table.\n", ServerName));
    
    //
    // Get the hash index of the server.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);

    //
    // Search the hash table at this index to see if an entry for this server
    // exists.
    //
    listEntry = ServerHashTable[ServerHashID].Flink;
    while ( listEntry != &ServerHashTable[ServerHashID] ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        HashEntry = CONTAINING_RECORD(listEntry,
                                      HASH_SERVER_ENTRY,
                                      ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, HashEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        listEntry = listEntry->Flink;
    }

    if (isPresent) {
        //
        // Yes, we found the entry for this server. Return its address to the
        // caller in the supplied buffer.
        //
        *ServerHashEntry = HashEntry;
        return isPresent;
    } 

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerHashEntry = NULL;
    
    return isPresent;
}


BOOL 
DavIsServerInFinalizeList(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry,
    IN BOOL ReactivateIfExists
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the "to be finalized" list. If it does, the address of the 
    entry is returned in the caller supplied buffer. It also moves the server
    entry from the "to be finalized list" to the hash table. Note that the 
    caller should take a lock on the "ToBeFinalizedServerEntries" before calling 
    this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerHashEntry - Pointer to the Hash entry structure.
    
    ReactivateIfExists - If this is TRUE, then if the ServerHashEntry exists, it
                         is reactivated. If this is FALSE, it means that the 
                         caller just wanted to know if the ServerHashEntry exists 
                         or not in the ServerHashTable and we shouldn't reactivate 
                         it.

Return Value:

    TRUE - Server entry exists in the list.
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PHASH_SERVER_ENTRY ServerEntry;
    PPER_USER_ENTRY PerUserEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    //
    // Before we search the ToBeFinalizedList for an entry for this Server, we
    // finalize the list to remove any stale entires. Once we are done with the
    // finalization, we can proceed.
    //
    DavFinalizeToBeFinalizedList();
    
    listEntry = ToBeFinalizedServerEntries.Flink;

    while ( listEntry != &ToBeFinalizedServerEntries ) {
        
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        ServerEntry = CONTAINING_RECORD(listEntry,
                                        HASH_SERVER_ENTRY,
                                        ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, ServerEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        
        listEntry = listEntry->Flink;
    
    }
    
    if (isPresent) {

        //
        // If this entry is not for a valid DAV server, then we return TRUE, but
        // set *ServerHashEntry to NULL. This gives an indication to the caller
        // that the entry exists, but is not a valid DAV server.
        //
        if (!ServerEntry->isDavServer) {
            *ServerHashEntry = NULL;
            return isPresent;
        }

        if (ReactivateIfExists) {

            //
            // OK, its a valid DAV server. Remove it from the "to be finalized" 
            // list.
            //
            RemoveEntryList( &(ServerEntry->ServerListEntry) );

            //
            // Check to see if the worker (scavenger) thread tried finalizing it.
            // If it did, we need to unfinalize it. By that we mean, go through all
            // the user entries (they should be marked closing), add a reference
            // count (the thread would have decremented it while finalizing) and set
            // the state to initialized.
            //
            if (ServerEntry->HasItBeenScavenged) {

                listEntry = ServerEntry->PerUserEntry.Flink;

                while ( listEntry != &(ServerEntry->PerUserEntry) ) {
                    //
                    // Get the pointer to the PER_USER_ENTRY structure.
                    //
                    PerUserEntry = CONTAINING_RECORD(listEntry,
                                                     PER_USER_ENTRY,
                                                     UserEntry);
                    //
                    // The current state should be closing.
                    //
                    ASSERT(PerUserEntry->UserEntryState == UserEntryClosing);

                    //
                    // Set the state to initialized.
                    //
                    PerUserEntry->UserEntryState = UserEntryInitialized;

                    //
                    // Increment the reference count.
                    //
                    PerUserEntry->UserEntryRefCount++;

                    listEntry = listEntry->Flink;
                }

                ServerEntry->HasItBeenScavenged = FALSE;
            }

            //
            // Set its RefCount to 1.
            //
            ServerEntry->ServerEntryRefCount = 1;

            //
            // Add it to the hash table.
            //
            ServerHashID = DavHashTheServerName(ServerName);
            ASSERT(ServerHashID != SERVER_TABLE_SIZE);
            InsertHeadList( &(ServerHashTable[ServerHashID]), 
                                             &(ServerEntry->ServerListEntry) );

            ServerEntry->TimeValueInSec = DONT_EXPIRE;

        }

        //
        // Yes, we found the entry for this server. We need to move this entry 
        // to the hash table.
        //
        *ServerHashEntry = ServerEntry;

        return isPresent;

    }

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerHashEntry = NULL;
    
    return isPresent;
}


VOID
DavInitializeAndInsertTheServerEntry(
    IN OUT PHASH_SERVER_ENTRY ServerHashEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    )
/*++

Routine Description:

    This routine initializes a newly created server entry strucutre and inserts
    it into the global server hash table. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.
    
Arguments:

    ServerHashEntry - Pointer to the Hash entry structure to be initialized and
                      inserted.

    ServerName - Name of the server.
    
    EntrySize - Size of the server entry including the server name.
    
Return Value:

    none.

--*/
{
    ULONG ServerHashID;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, 
              "DavInitializeAndInsertTheServerEntry: ServerName: %ws.\n",
              ServerName));
    //
    // Copy the server name to the end of the structure.
    //
    ASSERT( (EntrySize - sizeof(HASH_SERVER_ENTRY))  >= 
                                   ((wcslen(ServerName) + 1) * sizeof(WCHAR)) );
    ServerHashEntry->ServerName = &ServerHashEntry->StrBuffer[0];
    wcscpy(ServerHashEntry->ServerName, ServerName);

    ServerHashEntry->EntrySize = EntrySize;
    
    ServerHashEntry->TimeValueInSec = DONT_EXPIRE;

    ServerHashEntry->HasItBeenScavenged = FALSE;

    //
    // Increment the ID and assign it to the entry.
    //
    ServerIDCount++;
    ServerHashEntry->ServerID = ServerIDCount;

    //
    // Initialize the Per User list that hangs off the server entry.
    //
    InitializeListHead( &(ServerHashEntry->PerUserEntry) );

    //
    // Finally set the reference count of this entry to 1.
    //
    ServerHashEntry->ServerEntryRefCount = 1;

    //
    // Finally, get the hash ID and insert this new entry into the global server 
    // entry hash table.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);
    InsertHeadList( &(ServerHashTable[ServerHashID]), 
                                         &(ServerHashEntry->ServerListEntry) );
    
    return;
}


VOID
DavFinalizeToBeFinalizedList(
    VOID
    )
/*++

Routine Description:

    This routine walks through the list of ToBeFinalizedServerEntries and 
    finalizes those whose "to live" time has expired. When server entries 
    are added to this list, the time is saved. Periodically a worker thread
    calls this function and finalizes all the entries for whom,
    (CurrentTime - TimeSaved >= ThresholdValue).  Note that the caller should 
    take a lock on the "ToBeFinalizedServerEntries" before calling this routine.
    
Arguments:

    none.
    
Return Value:

    none.

--*/
{
    PLIST_ENTRY listEntry;
    time_t CurrentTimeInSec;
    ULONGLONG TimeDiff; 
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    BOOL shouldFree = TRUE;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    listEntry = ToBeFinalizedServerEntries.Flink;

    while ( listEntry != &ToBeFinalizedServerEntries) {

        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        ServerHashEntry = CONTAINING_RECORD(listEntry,
                                            HASH_SERVER_ENTRY,
                                            ServerListEntry);
        
        //
        // Get the next entry on the list.
        //
        listEntry = listEntry->Flink;

        //
        // If the ServerEntryRefCount is > 0 then we don't finalize this
        // ServerHashEntry since some thread is still accessing it.
        //
        if (ServerHashEntry->ServerEntryRefCount > 0) {
            continue;
        }

        CurrentTimeInSec = time(NULL);

        TimeDiff = ( CurrentTimeInSec - (ServerHashEntry->TimeValueInSec) );

        if ( TimeDiff >= ServerNotFoundCacheLifeTimeInSec ) {

            //
            // Finalize this server entry. If the return value is TRUE it means
            // that all the user entries that were hanging off this server 
            // entry have been finalized and so we can go ahead and free this
            // entry. If its FALSE, it means that the we have marked as closing
            // all the user entries, but not all of them were finalized. This
            // is because some thread still holds a reference to the user entry.
            // Finally, set the bool value that says it was scavenged to TRUE.
            //
            ServerHashEntry->HasItBeenScavenged = TRUE;
            
            shouldFree = DavFinalizeServerEntry(ServerHashEntry);
            
            if (shouldFree) {
                
                HLOCAL FreeHandle;
                ULONG FreeStatus;
                
                //
                // Remove this entry from the ToBeFinalizedList of Server 
                // entries.
                //
                RemoveEntryList( &(ServerHashEntry->ServerListEntry) );

                // if there is an event for this srvcall, we must close it before freeing the structure
                if (ServerHashEntry->ServerEventHandle != NULL)
                {
                    CloseHandle(ServerHashEntry->ServerEventHandle);
                }
                
                FreeHandle = LocalFree((HLOCAL)ServerHashEntry);
                if (FreeHandle != NULL) {
                    FreeStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFinalizeToBeFinalizedList/LocalFree. "
                              "Error Val = %d.\n", FreeStatus));
                }
            
            }
        
        }
    
    }

    return;
}


BOOL
DavFinalizeServerEntry (
    PHASH_SERVER_ENTRY ServerHashEntry
    )
/*++

Routine Description:

    This routine finalizes the server entry that is passed to the routine. Note
    that the caller should take a lock on the ServerHashTable before calling 
    this routine.
    
Arguments:

    ServerHashEntry - The server entry being finalized.
    
Return Value:

    none.

--*/
{
    PLIST_ENTRY listEntry;
    PPER_USER_ENTRY UserEntry;
    BOOL didFree = TRUE, didFinalize;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    DavPrint((DEBUG_MISC, 
              "DavFinalizeServerEntry: ServerEntry: %08lx.\n", ServerHashEntry));

    listEntry = ServerHashEntry->PerUserEntry.Flink;
    
    //
    // Go through all the User entries, mark them closing and finalize them.
    // If we have already marked them closing then we don't need to finalize 
    // them again.
    //
    while ( listEntry != &(ServerHashEntry->PerUserEntry) ) {
        
        //
        // Get the pointer to the PER_USER_ENTRY structure.
        //
        UserEntry = CONTAINING_RECORD(listEntry, PER_USER_ENTRY, UserEntry);

        //
        // Get the next entry on the list.
        //
        listEntry = listEntry->Flink;
        
        //
        // This is the only routine that marks the state of a user entry to be
        // closing. If the first one is marked closing, then we have already 
        // through this list before and hence we just return. Some other thread(s)
        // has(ve) a reference to this and will finalizeit when they are done.
        //
        if (UserEntry->UserEntryState == UserEntryClosing) {
            ASSERT(ServerHashEntry->HasItBeenScavenged == TRUE);
            didFree = FALSE;
            break;
        }

        //
        // Mark this entry closing and then call the finalization routine. If 
        // we did not finalize, then set didFree to FALSE. Since we do not wish
        // to free the server entry even if one user entry is not finalized.
        //
        UserEntry->UserEntryState = UserEntryClosing;
            
        didFree = FALSE;

    }

    return didFree;
}


VOID
_stdcall
DavHandleAsyncResponse(
    HINTERNET IHandle,
    DWORD_PTR CallBackContext,
    DWORD InternetStatus,
    LPVOID StatusInformation,
    DWORD StatusInformationLength
    )
/*++

Routine Description:

   This is the callback routine that gets called at various times during the 
   processing of an asynchronous request. 

Arguments:

    pDavCallBackContext - The context structure to be set.
    
    DavOperation - The Dav operation that will be called with this context. 

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{


    ASSERT(!"WinInet Callback should not be called");
    return;
}


DWORD 
WINAPI
DavCommonDispatch(
    LPVOID Context
    )
/*++

Routine Description:

   This is the callback routine that gets called at various times during the 
   processing of an asynchronous request. 

Arguments:

    Context - The DAV_USERMODE_WORKITEM value.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)Context;

    DavPrint((DEBUG_MISC,
              "DavCommonDispatch: DavWorkItem = %08lx, DavOperation = %d,"
              " WorkItemType = %d\n", DavWorkItem, DavWorkItem->DavOperation,
              DavWorkItem->WorkItemType));
    
    if (DavWorkItem->DavOperation <= DAV_CALLBACK_HTTP_SEND) {
        WStatus = DavAsyncCommonStates(DavWorkItem, TRUE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCommonDispatch/DavAsyncCommonStates. WStatus = "
                      "%08lx\n", WStatus));
        }
    } else {
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            WStatus = DavAsyncCreateSrvCall(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreateSrvCall. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeCreateVNetRoot: {
            WStatus = DavAsyncCreateVNetRoot(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreateVNetRoot. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeCreate: {
            WStatus = DavAsyncCreate(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreate. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
            break;
        
        case UserModeQueryDirectory: {
            WStatus = DavAsyncQueryDirectory(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncQueryDirectory. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeReName: {
            WStatus = DavAsyncReName(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncReName. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
        break;
        
       case UserModeSetFileInformation: {
            ASSERT(FALSE);
        }
        break;            
        
        case UserModeClose: {
            WStatus = DavAsyncClose(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncClose. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
            break;
        
        default: {
            ASSERT(!"Invalid DavWorkItem->WorkItemType");
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavCommonDispatch: Invalid DavWorkItem->WorkItemType = %d.\n",
                      DavWorkItem->WorkItemType));
        }
            break;
        
        }
    }

    return WStatus;
}


DWORD 
DavAsyncCommonStates(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This routine is called to handle the common operations during the Async 
   server calls. To avoid duplicating the code in every Async operation like
   CreateSrvCall, Create etc., the code handling the common states has been
   consolidated into this routine.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL ReturnVal, didImpersonate = FALSE;
    PWCHAR HTTPVerb = NULL;
    PWCHAR ObjectName = NULL;
    LPINTERNET_BUFFERS InternetBuffers = NULL;
    DWORD SendEndRequestFlags = 0;
    BOOL BStatus = FALSE;
    PWCHAR PassportCookie = NULL;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, the the flag value that is passed
    // to HttpSendRequestExW and HttpEndRequestW is HSR_SYNC.
    //
    SendEndRequestFlags = HSR_SYNC;
    
    switch (DavWorkItem->DavOperation) {
    
    case DAV_CALLBACK_INTERNET_CONNECT: {
        
        BOOL setEvt;
        PPER_USER_ENTRY PerUserEntry = NULL;

        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_INTERNET_CONNECT.\n"));

        //
        // We need to now do somethings depending on the WorkItemType.
        //
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {

            //
            // Select the verb to be used.
            //
            HTTPVerb = L"OPTIONS";
        
            ObjectName = L"/";
        }
            break;
        
        case UserModeCreate: {
            
            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreate.PerUserEntry;
            
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePropFind;
            DavWorkItem->DavMinorOperation = DavMinorReadData;
            DavWorkItem->AsyncCreate.DataBuff = NULL;
            DavWorkItem->AsyncCreate.didRead = NULL;
            DavWorkItem->AsyncCreate.Context1 = NULL;
            DavWorkItem->AsyncCreate.Context2 = NULL;

            ObjectName = DavWorkItem->AsyncCreate.RemPathName;
        }
            break;
        
        case UserModeCreateVNetRoot: {
            
            PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;

            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreateVNetRoot.PerUserEntry;
            
            //
            // Get the request buffer from the DavWorkItem.
            //
            CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);
            
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            //
            // The first character is a '\' which has to be stripped.
            //
            ObjectName = &(CreateVNetRootRequest->ShareName[1]);
            DavPrint((DEBUG_MISC, 
                      "DavAsyncCommonStates: ObjectName = %ws\n", ObjectName));
        }
        break;
        
        case UserModeQueryVolumeInformation:
        
            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreate.PerUserEntry;
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            //
            // The first character is a '\' which has to be stripped.
            //
            ObjectName = &(DavWorkItem->QueryVolumeInformationRequest.ShareName[1]);
            DavPrint((DEBUG_MISC, 
                      "DavAsyncCommonStates: ObjectName = %ws\n", ObjectName));
        break;
        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
            break;

        }
        
            
        //
        // If the WorkItem type is UserModeCreateSrvCall, then we don't have
        // a PerUserEntry. In this case, the DavConnHandle is stored in the
        // DavWorkItem structure.
        //
        if ( (DavWorkItem->WorkItemType == UserModeCreate) ||
             (DavWorkItem->WorkItemType == UserModeCreateVNetRoot)||
             (DavWorkItem->WorkItemType == UserModeQueryVolumeInformation)) {
            DavConnHandle = PerUserEntry->DavConnHandle;
        } else {
            ASSERT(DavWorkItem->WorkItemType == UserModeCreateSrvCall);
            DavConnHandle = DavWorkItem->AsyncCreateSrvCall.DavConnHandle;
        }
        

        if ( (DavWorkItem->WorkItemType == UserModeCreate) ||
             (DavWorkItem->WorkItemType == UserModeCreateVNetRoot) ) {

            //
            // We are in InternetConnect callback state. We need to cache this Conn
            // handle away in the PerUserEntry of the user which hangs off the 
            // server hash entry. We need to take a lock on the table before doing
            // this.
            //
            EnterCriticalSection( &(HashServerEntryTableLock) );

            //
            // Since the handle was created successfully, we store ERROR_SUCCESS
            // in the status field of the PerUserEntry.
            //
            PerUserEntry->ErrorStatus = ERROR_SUCCESS;

            
            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: PerUserEntry->DavConnHandle = "
                      "%08lx.\n", PerUserEntry->DavConnHandle));

            //
            // Set the state of the user entry to initialized.
            //
            PerUserEntry->UserEntryState = UserEntryInitialized;

            //
            // Signal the event of the user entry to wake up the threads which 
            // might be waiting for this to happen.
            //
            setEvt = SetEvent(PerUserEntry->UserEventHandle);
            if (!setEvt) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/SetEvent. Error Val = %d.\n", 
                          WStatus));
                LeaveCriticalSection( &(HashServerEntryTableLock) );
                goto EXIT_THE_FUNCTION;
            }

            //
            // This was acquired above.
            //
            LeaveCriticalSection( &(HashServerEntryTableLock) );

        }

        //
        // The next async operation is http open.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        
        //
        // Convert the unicode object name to a UTF-8 URL format.
        // Space and other white characters will remain untouched - these should
        // be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavConnHandle,
                                      (LPWSTR)HTTPVerb,
                                      (LPWSTR)ObjectName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES |
                                      INTERNET_FLAG_NO_CACHE_WRITE |
                                      INTERNET_FLAG_RESYNCHRONIZE,
                                      CallBackContext,
                                      L"DavAsyncCommonStates",
                                      &DavOpenHandle);
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }
        
        if (DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpOpenRequest. Error Val = %d\n", 
                          WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }
   }
   //
   // Lack of break is intentional.
   //

    case DAV_CALLBACK_HTTP_OPEN: {
        
        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_HTTP_OPEN.\n"));
        
        //
        // Get the handle from http open. If DavOpenHandle is NULL, it means 
        // that either the async request HttpOpenRequestW returned ERROR_IO_PENDING
        // and that the handle will be stored in DavWorkItem->pAsyncResult->
        // dwResult (implies CalledByCallBackThread == TRUE) or that the function
        // that called this function cached it in the DavWorkItm structure.
        //
        
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {


            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;

            } else {
                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncCreateSrvCall.DavOpenHandle = DavOpenHandle;

            }
            
        }
            break;

        case UserModeCreateVNetRoot: {

            {

                if (DavOpenHandle == NULL) {

                    //
                    // HttpOpen handle was cached away in the DavWorkItem by the
                    // function that called this function.
                    //

                    DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;

                } else {

                    //
                    // We need to cache the DavOpenHandle in the DavWorkItem.
                    //

                    DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle = DavOpenHandle;

                }

            }
            
            //
            // Since all that we need is information about this share, set the 
            // depth header to 0. This way the PROPFIND that we send will get 
            // back the properties of just this share.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               L"Depth: 0\n",
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
            
        }
            break;

        case UserModeCreate: {
            
            {

                if (DavOpenHandle == NULL) {

                    //
                    // HttpOpen handle was cached away in the DavWorkItem by the
                    // function that called this function.
                    //

                    DavOpenHandle = DavWorkItem->AsyncCreate.DavOpenHandle;

                } else {

                    //
                    // We need to cache the DavOpenHandle in the DavWorkItem.
                    //

                    DavWorkItem->AsyncCreate.DavOpenHandle = DavOpenHandle;

                }

            }
            
            //
            // If this is a PROPFIND, set the depth header to 0. This matters
            // when the open is being done for a directory. We only need the 
            // properties of the directory and not the files it contains.
            //
            if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind ||
                DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateQueryParentDirectory) {
                PDAV_USERMODE_CREATE_REQUEST CreateRequest = &(DavWorkItem->CreateRequest);
                
                if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind &&
                    CreateRequest->CreateOptions & FILE_DIRECTORY_FILE &&
                    (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE ||
                     CreateRequest->DesiredAccess & DELETE)) {
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       L"Depth: 1\n",
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                } else {
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       L"Depth: 0\n",
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                }
            }
        }

            break;

        case UserModeQueryDirectory: {
            
            {

                if (DavOpenHandle == NULL) {

                    //
                    // HttpOpen handle was cached away in the DavWorkItem by the
                    // function that called this function.
                    //

                    DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

                } else {

                    //
                    // We need to cache the DavOpenHandle in the DavWorkItem.
                    //

                    DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle = DavOpenHandle;

                }

            }
            
            if (DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) {
            
                //
                // If there are no wild cards, we have a filename and we set
                // the depth to 0.
                //

                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Depth: 0\n",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            } else {
            
                //
                // On a QueryDirectory, we do a PROPFIND on the directory. Since we
                // only need to get the properties of files within the first level
                // of the directory, we set the depth header of the request to 1. 
                //
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Depth: 1\n",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            }
        
        }
            break;

            case UserModeQueryVolumeInformation:
            //
            // Since all that we need is information about this share, set the 
            // depth header to 0. This way the PROPFIND that we send will get 
            // back the properties of just this share.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               L"Depth: 0\n",
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle = DavOpenHandle;
            break;
        case UserModeReName: {

            PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
            
            {

                if (DavOpenHandle == NULL) {

                    //
                    // HttpOpen handle was cached away in the DavWorkItem by the
                    // function that called this function.
                    //

                    DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;

                } else {

                    //
                    // We need to cache the DavOpenHandle in the DavWorkItem.
                    //

                    DavWorkItem->AsyncReName.DavOpenHandle = DavOpenHandle;

                }

            }

            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: Rename!! HeaderBuff: %ws\n",
                      DavWorkItem->AsyncReName.HeaderBuff));

            //
            // We are doing a "MOVE" and hence we need to set the DAV header
            // "Destination:". This has to be the URI of the new file.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               DavWorkItem->AsyncReName.HeaderBuff,
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Get the request buffer pointer from the DavWorkItem.
            //
            DavReNameRequest = &(DavWorkItem->ReNameRequest);

            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: Rename!! ReplaceIfExists: %d\n",
                      DavReNameRequest->ReplaceIfExists));

            //
            // We need to set the Overwrite header in this MOVE request. This
            // determines what is done if the destination file already exists.
            // If the ReplaceIfExists is set to TRUE, then we set the Overwrite
            // header to T (TRUE) else F (FALSE).
            //
            if (DavReNameRequest->ReplaceIfExists) {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Overwrite: T",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } else {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Overwrite: F",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
            
        }

            break;

        case UserModeClose: {
            
            {

                if (DavOpenHandle == NULL) {

                    //
                    // HttpOpen handle was cached away in the DavWorkItem by the
                    // function that called this function.
                    //

                    DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;

                } else {

                    //
                    // We need to cache the DavOpenHandle in the DavWorkItem.
                    //

                    DavWorkItem->AsyncClose.DavOpenHandle = DavOpenHandle;

                }

            }

            if (DavWorkItem->AsyncClose.DataBuff != NULL) {

                ASSERT(DavWorkItem->DavMinorOperation == DavMinorPutFile);

                if (DavWorkItem->AsyncClose.InternetBuffers == NULL) {
            
                    InternetBuffers = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                  sizeof(INTERNET_BUFFERS) );
                    if (InternetBuffers == NULL) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/LocalAlloc. Error Val = %d\n",
                                  WStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.InternetBuffers = InternetBuffers;

                    InternetBuffers->dwStructSize = sizeof(INTERNET_BUFFERS);
                    InternetBuffers->Next = NULL;
                    InternetBuffers->lpcszHeader = NULL;
                    InternetBuffers->dwHeadersLength = 0;
                    InternetBuffers->dwBufferTotal = 0;
                    InternetBuffers->lpvBuffer = DavWorkItem->AsyncClose.DataBuff;
                    InternetBuffers->dwBufferLength = (DWORD)DavWorkItem->AsyncClose.DataBuffSizeInBytes;
                    InternetBuffers->dwBufferTotal = 0;
                    InternetBuffers->dwOffsetLow = 0;
                    InternetBuffers->dwOffsetHigh = 0;
                
                } else {

                    InternetBuffers = DavWorkItem->AsyncClose.InternetBuffers;

                }
            
            } else {

                DavWorkItem->AsyncClose.InternetBuffers = NULL;

            }

        }
            break;

        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
            break;

        }
        
        DavPrint((DEBUG_MISC,
                  "DavAsyncCommonStates: DavOpenHandle = %08lx.\n", DavOpenHandle));
        
        //
        // In case of UserModeCreateSrvCall, we don't have a passport cookie yet.
        //
        if (DavWorkItem->WorkItemType != UserModeCreateSrvCall) {
            WStatus = DavAttachPassportCookie(DavWorkItem,DavOpenHandle,&PassportCookie);

            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // We need to add the header "translate:f" to tell IIS that it should 
        // allow the user to excecute this VERB on the specified path which it 
        // would not allow (in some cases) otherwise. Finally, there is a special 
        // flag in the metabase to allow for uploading of "dangerous" content 
        // (anything that can be run on the server). This is the ScriptSourceAccess
        // flag in the UI or the AccessSource flag in the metabase. You will need
        // to set this bit to true as well as correct NT ACLs in order to be able
        // to upload .exes or anything executable.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"translate: f\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavInternetSetOption(DavWorkItem,DavOpenHandle);

        if (WStatus != ERROR_SUCCESS) {
            goto EXIT_THE_FUNCTION;
        }

        //
        // Need to change the DavOperation field before submitting another
        // asynchronous request. The next async operation is http send.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_SEND;
        
        //
        // We need the following symbol if we are using WinInet synchronously.
        //
RESEND_THE_REQUEST:
        
        //
        // Send the request to the server.
        //
        ReturnVal = HttpSendRequestExW(DavOpenHandle, 
                                       InternetBuffers, 
                                       NULL, 
                                       SendEndRequestFlags,
                                       CallBackContext);
        if (!ReturnVal) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpSendRequest. Error Val = %d\n", 
                          WStatus));
            } 
            goto EXIT_THE_FUNCTION;
        }
    
    }
    //
    // Lack of break is intentional.
    //

    case DAV_CALLBACK_HTTP_SEND: {
        
        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_HTTP_SEND.\n"));
    
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;
        }
        break;

        case UserModeCreateVNetRoot: {
            DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
        }
            break;

        case UserModeCreate: {
            DavOpenHandle = DavWorkItem->AsyncCreate.DavOpenHandle;
        }
            break;

        case UserModeQueryDirectory: {
            DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;
        }
            break;
        case UserModeQueryVolumeInformation: {
            DavOpenHandle = DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle;
        }
            break;

        case UserModeReName: {
            DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
        }
            break;

        case UserModeClose: {
            DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
        }
            break;

        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
            break;
        
        }

        //
        // Need to change the DavOperation field before submitting another
        // asynchronous request. The next operation is http end.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_END;


        //
        // Issue the End request once send request completes.
        //
        ReturnVal = HttpEndRequestW(DavOpenHandle, 
                                    NULL, 
                                    SendEndRequestFlags,
                                    CallBackContext);
        if (!ReturnVal) {

            WStatus = GetLastError();

            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
            // is trying to authenticate itself with the server. If we get back
            // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
            // confirm that the redirect needs to be followed. In these scenarios,
            // we need to repeat the HttpSend and HttpEnd request calls.
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
                goto RESEND_THE_REQUEST;
            }

            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/HttpEndRequestW. Error Val = %d\n",
                      WStatus));

            goto EXIT_THE_FUNCTION;

        } else {

            PWCHAR Cookie = NULL;

            DavQueryPassportCookie(DavOpenHandle,&Cookie);

            if (Cookie) {
                DavPrint((DEBUG_MISC,
                         "Passport Cookie saved for PUE %x\n",DavWorkItem->ServerUserEntry.PerUserEntry));
                //
                // Set or renew passport cookie
                //
                EnterCriticalSection(&DavPassportLock);
                
                if (DavWorkItem->ServerUserEntry.PerUserEntry) {
                    if (DavWorkItem->ServerUserEntry.PerUserEntry->Cookie) {
                        LocalFree(DavWorkItem->ServerUserEntry.PerUserEntry->Cookie);
                    }

                    DavWorkItem->ServerUserEntry.PerUserEntry->Cookie = Cookie;
                }
                
                LeaveCriticalSection(&DavPassportLock);
            }
        
        }


        //
        // Now we need to call the Async routines that handle WorkItemType
        // specific things.
        //
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            WStatus = DavAsyncCreateSrvCall(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreateSrvCall. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeCreateVNetRoot: {
            WStatus = DavAsyncCreateVNetRoot(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreateVNetRoot. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeCreate: {
            WStatus = DavAsyncCreate(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING &&
                WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreate. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeQueryDirectory: {
            WStatus = DavAsyncQueryDirectory(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING &&
                WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncQueryDirectory. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        case UserModeQueryVolumeInformation: {
            WStatus = DavAsyncQueryVolumeInformation(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncQueryVolumeInformation. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeReName: {
            WStatus = DavAsyncReName(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncReName. WStatus = %08lx.\n", 
                          WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeClose: {
            WStatus = DavAsyncClose(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncClose. WStatus = %08lx.\n", 
                          WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
        }
            break;
        
        }
    
    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCommonStates: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;
    
    } // End of switch.

EXIT_THE_FUNCTION:
    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }   
    }

    if (PassportCookie) {
        LocalFree(PassportCookie);
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    return WStatus;
}
    

ULONG
DavFsSetTheDavCallBackContext(
    IN OUT PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine sets the callback context to be sent in subsequent asynchronous
   request.

Arguments:

    DavWorkItem - The work item that came down from the kernel. This is also
                   used as the callbackcontext.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    BOOL ReturnVal;
    ULONG WStatus = ERROR_SUCCESS;

    //
    // Make the handles invalid to begin with.
    //
    DavWorkItem->ImpersonationHandle = INVALID_HANDLE_VALUE;
        
    //
    // Get the handle used to impersonate this thread.
    //
    ReturnVal = OpenThreadToken(GetCurrentThread(),
                                TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                                FALSE,
                                &(DavWorkItem->ImpersonationHandle));
    if (!ReturnVal) {
        DavWorkItem->ImpersonationHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsSetTheDavCallBackContext/OpenThreadToken. Operation = %d"
                  ", Error Val = %d\n", DavWorkItem->WorkItemType, WStatus));
    }
    
    return WStatus;
}


VOID
DavFsFinalizeTheDavCallBackContext(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine finalizes the callback context which was used for some 
   asynchronous request. This basically amounts to freeing up any resources
   that were acquired by the context. Its called when the request associated 
   with this context completes.

Arguments:

    DavWorkItem - The context structure to be set.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    BOOL ReturnVal;
    ULONG WStatus;

    //
    // If the Impersonation handle was initialized, close it.
    //
    if (DavWorkItem->ImpersonationHandle != INVALID_HANDLE_VALUE) {
        ReturnVal = CloseHandle(DavWorkItem->ImpersonationHandle);
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "ERROR: DavFsFinalizeTheDavCallBackContext/CloseHandle."
                      "(Impersonation) Error Val = %d.\n", WStatus));
        }
    }

    return;
}


BOOL
DavDoesUserEntryExist(
    IN PWCHAR ServerName,
    IN ULONG ServerID,
    IN PLUID LogonID,
    OUT PPER_USER_ENTRY *PerUserEntry,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    )
/*++

Routine Description:

    This routine searches for a per user entry in the list of per user entries
    of a server entry in the hash table. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.

Arguments:

    ServerName - The server name whose per user entries should be searched.
    
    ServerID - The unique ID associated with this server. This ID is generated
               during the CreateSrvCall stage.
    
    LogonID - The LogonID of the user/session to be searched.
    
    PerUserEntry - The PerUserEntry of this user which hangs of the server.
    
    ServerHashEntry - The ServerHashEntry for this server. This is used to add 
                      the new user entry to its list if an entry for this user
                      does not exist.

Return Value:

    TRUE - The entry was found and FALSE otherwise.

--*/
{
    BOOL ReturnVal = FALSE;
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listServerEntry, listUserEntry;
    PHASH_SERVER_ENTRY HashEntry = NULL;
    PPER_USER_ENTRY UsrEntry = NULL;
    
    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerName: %ws, ServerID: "
              "%d.\n", ServerName, ServerID));
    
    //
    // Finally, get the hash ID and insert this new entry into the global server 
    // entry hash table.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);

    //
    // Search the hash table at this index to see if an entry for this server
    // exists.
    //
    listServerEntry = ServerHashTable[ServerHashID].Flink;
    while ( listServerEntry != &(ServerHashTable[ServerHashID]) ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        HashEntry = CONTAINING_RECORD(listServerEntry,
                                      HASH_SERVER_ENTRY,
                                      ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( ServerID == HashEntry->ServerID ) {
            //
            // If the ID's match, the server names should match.
            //
            ASSERT( wcscmp(ServerName, HashEntry->ServerName) == 0 );
            isPresent = TRUE;
            DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerName: %ws found"
                      ".\n", ServerName));
            break;
        }
        listServerEntry = listServerEntry->Flink;
    }

    //
    // If the ServerHashEntry does not exist, then return FALSE;
    //
    if (!isPresent) {
        DavPrint((DEBUG_MISC, 
                  "DavDoesUserEntryExist: ServerHashEntry not found. %ws\n",
                  ServerName));
        *ServerHashEntry = NULL;
        *PerUserEntry = NULL;
        return (isPresent);
    }
    
    //
    // Return the ServerHashEntry. This will be used to add the new user
    // entry to the user list of this server.
    //
    *ServerHashEntry = HashEntry;
    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerHashEntry = %08lx\n", 
              HashEntry));
    
    //
    // Now, search the "per user entries" that hang off this server entry to 
    // see if an entry for this user exists.
    //
    listUserEntry = HashEntry->PerUserEntry.Flink;
    while ( listUserEntry !=  &(HashEntry->PerUserEntry) ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        UsrEntry = CONTAINING_RECORD(listUserEntry,
                                     PER_USER_ENTRY,
                                     UserEntry);
        //
        // Check to see if this entry is for the user in question. We do this 
        // by comparing the LogonID values.
        //
        if ( (UsrEntry->LogonID.LowPart == LogonID->LowPart) &&
             (UsrEntry->LogonID.HighPart == LogonID->HighPart) ) {
            DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: User found.\n"));
            ReturnVal = TRUE;
            break;
        }
        listUserEntry = listUserEntry->Flink;
    }

    if (!ReturnVal) {
        DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: User not found.\n"));
        *PerUserEntry = NULL;
        return (ReturnVal);
    }

    //
    // Since the server has been found, return the PerUserEntry.
    //
    *PerUserEntry = UsrEntry;
    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: UsrEntry = %08lx\n", UsrEntry));

    return (ReturnVal);
}


BOOL
DavFinalizePerUserEntry(
    PPER_USER_ENTRY *PUE
    )
/*++

Routine Description:

    This routine decrements the reference count of the user entry by one. If 
    the count reduces to zero, the entry is freed.

Arguments:

    PUE - The per user entry to be finalized.

Return Value:

    TRUE - The user entry was finalized (freed).
    
    FALSE - Was not since the ref count was > 0.

--*/
{
    PPER_USER_ENTRY PerUserEntry = *PUE;
    BOOL retVal = TRUE;

    DavPrint((DEBUG_MISC,
              "DavFinalizePerUserEntry: Finalizing PerUserEntry: %08lx.\n",
              PerUserEntry));
    
    DavPrint((DEBUG_MISC,
              "DavFinalizePerUserEntry: UserEntryRefCount = %d, LogonId.LowPart = %d,"
              " LogonId.HighPart = %d\n", PerUserEntry->UserEntryRefCount,
              PerUserEntry->LogonID.LowPart, PerUserEntry->LogonID.HighPart));

    //
    // Before we modify the reference count, we need to take a lock.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );

    PerUserEntry->UserEntryRefCount--;

    //
    // If we had the last reference, we need to do the following :
    // 1. Remove the entry from the servers list.
    // 2. Close any open handles stored or cached in the entry.
    // 3. Free the cookie, if we allocated one for Passport Auth and,
    // 4. Free the entry.
    //
    if (PerUserEntry->UserEntryRefCount == 0) {
        
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        BOOL CloseStatus;
        PHASH_SERVER_ENTRY ServerHashEntry = NULL;

        DavPrint((DEBUG_MISC,
                  "DavFinalizePerUserEntry: Finalized!!! LogonId.LowPart = %d, LogonId.HighPart = %d\n",
                  PerUserEntry->LogonID.LowPart, PerUserEntry->LogonID.HighPart));

        ServerHashEntry = PerUserEntry->ServerHashEntry;

        //
        // Remove the entry from the servers list.
        //
        RemoveEntryList( &(PerUserEntry->UserEntry) );

        //
        // When this PerUserEntry was created, we took a reference on the
        // ServerHashEntry. We need to remove it now. Also, if the reference
        // on the ServerHashEntry goes to 0, we need to put it in the list of
        // "ToBeFinalized" ServerHashEntries.
        //
        ServerHashEntry->ServerEntryRefCount -= 1;

        if (ServerHashEntry->ServerEntryRefCount == 0) {

            ServerHashEntry->TimeValueInSec = time(NULL);

            //
            // Now move this server entry from the hash table to the
            // "to be finalized" list.
            //
            RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
            InsertHeadList( &(ToBeFinalizedServerEntries),
                                             &(ServerHashEntry->ServerListEntry) );

        }

        //
        // If we created the event handle, we need to close it now.
        //
        if (PerUserEntry->UserEventHandle != NULL) {
            CloseStatus = CloseHandle(PerUserEntry->UserEventHandle);
            if (!CloseStatus) {
                FreeStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFinalizePerUserEntry/CloseHandle. Error Val ="
                          " %d.\n", FreeStatus));
            }
        }
        
        //
        // If we created the DavConnHandle, we need to close it now.
        //
        if (PerUserEntry->DavConnHandle != NULL) {
            CloseStatus = InternetCloseHandle(PerUserEntry->DavConnHandle);
            if (!CloseStatus) {
                FreeStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFinalizePerUserEntry/InternetCloseHandle. "
                          "Error Val = %d.\n", FreeStatus));
            }
        }
        
        //
        // If we allocated memory for storing the cookies, we need to free it.
        //
        if (PerUserEntry->Cookie) {
            LocalFree(PerUserEntry->Cookie);
            PerUserEntry->Cookie = NULL;
        }

        if (PerUserEntry->UserName) {
            LocalFree(PerUserEntry->UserName);
            PerUserEntry->UserName = NULL;
        }
        
        if (PerUserEntry->Password) {
            LocalFree(PerUserEntry->Password);
            PerUserEntry->Password = NULL;
        }
        
        //
        // Finally, free the entry.
        //
        FreeHandle = LocalFree((HLOCAL)PerUserEntry);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFinalizePerUserEntry/LocalFree. Error Val = %d.\n",
                      FreeStatus));
        }
    
        //
        // Set the entry to NULL. Just in case !!!
        //
        *PUE = NULL;
    
    } else {
        
        DavPrint((DEBUG_MISC,
                  "DavFinalizePerUserEntry: Did not finalize %08lx. RefCount "
                  "= %d\n", PerUserEntry, PerUserEntry->UserEntryRefCount));
        
        retVal = FALSE;
    
    }

    //
    // Free the lock before leaving.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );

    return retVal;
}


DWORD
SetupRpcServer(
    VOID
    )
/*++

Routine Description:

    This routine sets up the RPC server of the WebClient service.

Arguments:

    none.

Return Value:

    A Win32 error code.

--*/
{
    RPC_STATUS rpcErr;
    RPC_BINDING_VECTOR *BindingVector = NULL;

    rpcErr = RpcServerRegisterIf(davclntrpc_ServerIfHandle, NULL, NULL);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerRegisterIf: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }

    rpcErr = RpcServerUseProtseqW(L"ncalrpc",
                                  RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                  NULL);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerUseProtseqEp: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }

    rpcErr = RpcServerInqBindings( &(BindingVector) );
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerInqBindings: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }
    
    rpcErr = RpcEpRegister(davclntrpc_ServerIfHandle,
                           BindingVector,
                           NULL,
                           L"DAV RPC SERVICE");
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcEpRegister: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }
    
    rpcErr = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerListen: rpcErr = %08lx\n", rpcErr));
    }

EXIT_THE_FUNCTION:

    if (BindingVector) {
        RpcBindingVectorFree( &(BindingVector) );
    }

    //
    // Luckily for us, RPC errors simply map into the Win32 error space.
    // If that ever changes, we need to make the mapping a bit more complex.
    //
    return (DWORD) rpcErr;
}


DWORD
StopRpcServer(
    VOID
    )
/*++

Routine Description:

    This routine stops the RPC server of the WebClient service.

Arguments:

    none.

Return Value:

    A Win32 error code.

--*/
{
    RPC_STATUS rpcErr;

    rpcErr = RpcMgmtStopServerListening(NULL);

    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_RPC,
                  "WebClient received err 0x%x during "
                  "RpcMgmtStopServerListening.\n", rpcErr));
    }

    rpcErr = RpcServerUnregisterIf(davclntrpc_ServerIfHandle, 0, TRUE);

    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_RPC,
                  "WebClient received err 0x%x during RpcServerUnregisterIf.\n",
                  rpcErr));
    }

    return (DWORD) rpcErr;
}


ULONG
DavQueryAndParseResponse(
    HINTERNET DavOpenHandle
    )
/*++

Routine Description:

    This function calls DavQueryAndParseResponseEx to map the Http/Dav response
    to the Win32 error code.

Arguments:

    DavOpenHandle - The handle created by HttpOpenRequest on which the request
                    was sent.

Return Value:

    A Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    WStatus = DavQueryAndParseResponseEx(DavOpenHandle, NULL);
    return WStatus;
}


ULONG
DavQueryAndParseResponseEx(
    IN HINTERNET DavOpenHandle,
    OUT PULONG HttpResponseStatus OPTIONAL
    )
/*++

Routine Description:

    This function queries the response header for the status value returned 
    from the server. It then maps the status to a Win32 error code and returns
    it to the caller. We added this function becuase some callers may be
    interested in special casing some of the Http/Dav responses. Before this we
    just had the DavQueryAndParseResponse function.

Arguments:

    DavOpenHandle - The handle created by HttpOpenRequest on which the request
                    was sent.
                    
    HttpResponseStatus - If this is non NULL, then the response status returned
                         by the server is filled in it. Some callers of this
                         function might need it to special case some of the 
                         Http/Dav responses.                

Return Value:

    A Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    DWORD ResponseStatus = 0;
    DWORD ResponseSize = 0;
    BOOL ReturnVal = FALSE;

    //
    // Query the header for the servers response status.
    //
    ResponseSize = sizeof(ResponseStatus);
    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                               &(ResponseStatus),
                               &(ResponseSize),
                               NULL);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavQueryAndParseResponseEx/HttpQueryInfoW: Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the caller is interested in the Http/Dav response status, we return
    // it.
    //
    if (HttpResponseStatus) {
        *HttpResponseStatus = ResponseStatus;
    }

    //
    // Map the Http response status code to the appropriate Http error.
    //
    WStatus = DavMapHttpErrorToDosError(ResponseStatus);
    if (WStatus != ERROR_SUCCESS &&
        WStatus != ERROR_FILE_NOT_FOUND) {
        DavPrint((DEBUG_ERRORS,
                  "DavQueryAndParseResponseEx/DavMapHttpErrorToDosError: WStatus = %d"
                  ", ResponseStatus = %d\n", WStatus, ResponseStatus));
    }
    
EXIT_THE_FUNCTION:

    return WStatus;
}


ULONG
DavMapHttpErrorToDosError(
    ULONG HttpResponseStatus
    )
/*++

Routine Description:

    This function maps the response status returned by the Http/Dav server to 
    the corresponding Win32 error code.

Arguments:

    HttpResponseStatus - The http status that has to be mapped to the Win32
                         error code.

Return Value:

    A Win32 error code.

--*/
{
    //
    // Map the HTTP response to the corresponding Win32 error. These will 
    // finally get mapped to an NTSTATUS value before the request is sent down 
    // to the kernel.
    //
    switch (HttpResponseStatus) {

    //
    // 100 OK to continue with request.
    //
    case HTTP_STATUS_CONTINUE:
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 101 server has switched protocols in upgrade header.
    //
    case HTTP_STATUS_SWITCH_PROTOCOLS:
        return ERROR_IO_DEVICE; // STATUS_DEVICE_PROTOCOL_ERROR;

    //
    // 200 Request completed.
    // 201 Object created, reason = new URI.
    // 202 Async completion (TBS).
    // 203 Partial completion.
    // 204 No info to return.
    // 205 Request completed, but clear form.
    // 206 Partial GET furfilled.
    // 207 Multi status response.
    //
    case HTTP_STATUS_OK:
    case HTTP_STATUS_CREATED:
    case HTTP_STATUS_ACCEPTED:
    case HTTP_STATUS_PARTIAL:
    case HTTP_STATUS_NO_CONTENT:
    case HTTP_STATUS_RESET_CONTENT:
    case HTTP_STATUS_PARTIAL_CONTENT:
    case DAV_MULTI_STATUS:
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 300 Server couldn't decide what to return.
    //
    case HTTP_STATUS_AMBIGUOUS:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 301 Object permanently moved.
    //
    case HTTP_STATUS_MOVED:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 302 Object temporarily moved.
    //
    case HTTP_STATUS_REDIRECT:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 303 Redirection w/new access method.
    //
    case HTTP_STATUS_REDIRECT_METHOD:         
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 304 If-modified-since was not modified.
    //
    case HTTP_STATUS_NOT_MODIFIED:            
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 305 Redirection to proxy, location header specifies proxy to use.
    //
    case HTTP_STATUS_USE_PROXY:               
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 307 HTTP/1.1: keep same verb.
    //
    case HTTP_STATUS_REDIRECT_KEEP_VERB:      
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 400 Invalid syntax.
    //
    case HTTP_STATUS_BAD_REQUEST:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 401 Access denied.
    //
    case HTTP_STATUS_DENIED:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 402 Payment required.
    //
    case HTTP_STATUS_PAYMENT_REQ:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 403 Request forbidden.
    //
    case HTTP_STATUS_FORBIDDEN:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 404 Object not found.
    //
    case HTTP_STATUS_NOT_FOUND:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 405 Method is not allowed.
    //
    case HTTP_STATUS_BAD_METHOD:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 406 No response acceptable to client found.
    //
    case HTTP_STATUS_NONE_ACCEPTABLE:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 407 Proxy authentication required.
    //
    case HTTP_STATUS_PROXY_AUTH_REQ:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 408 Server timed out waiting for request.
    //
    case HTTP_STATUS_REQUEST_TIMEOUT:
        return ERROR_SEM_TIMEOUT; // STATUS_IO_TIMEOUT;

    //
    // 409 User should resubmit with more info.
    //
    case HTTP_STATUS_CONFLICT:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 410 The resource is no longer available.
    //
    case HTTP_STATUS_GONE:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 411 The server refused to accept request w/o a length.
    //
    case HTTP_STATUS_LENGTH_REQUIRED:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 412 Precondition given in request failed.
    //
    case HTTP_STATUS_PRECOND_FAILED:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 413 Request entity was too large.
    //
    case HTTP_STATUS_REQUEST_TOO_LARGE:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 414 Request URI too long.
    //
    case HTTP_STATUS_URI_TOO_LONG:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 415 Unsupported media type.
    //
    case HTTP_STATUS_UNSUPPORTED_MEDIA:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 449 Retry after doing the appropriate action.
    //
    case HTTP_STATUS_RETRY_WITH:
        return ERROR_RETRY; // STATUS_RETRY;

    //
    // 500 Internal server error.
    //
    case HTTP_STATUS_SERVER_ERROR:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 501 Required not supported.
    //
    case HTTP_STATUS_NOT_SUPPORTED:
        return ERROR_NOT_SUPPORTED; // STATUS_NOT_SUPPORTED;

    //
    // 502 Error response received from gateway.
    //
    case HTTP_STATUS_BAD_GATEWAY:
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 503 Temporarily overloaded.
    //
    case HTTP_STATUS_SERVICE_UNAVAIL:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 504 Timed out waiting for gateway.
    //
    case HTTP_STATUS_GATEWAY_TIMEOUT:
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 505 HTTP version not supported.
    //
    case HTTP_STATUS_VERSION_NOT_SUP:
        return ERROR_NOT_SUPPORTED; // STATUS_NOT_SUPPORTED;

    //
    // WebDav specific status codes.
    //

    //
    // 507.
    //
    case DAV_STATUS_INSUFFICIENT_STORAGE:
        return ERROR_NOT_ENOUGH_QUOTA; // STATUS_QUOTA_EXCEEDED;

    //
    // 422.
    //
    case DAV_STATUS_UNPROCESSABLE_ENTITY:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 423.
    //
    case DAV_STATUS_LOCKED:
        return ERROR_ACCESS_DENIED; //STATUS_ACCESS_DENIED;

    //
    // 424.
    //
    case DAV_STATUS_FAILED_DEPENDENCY:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // This is not a valid Http error code. We return this back to the caller.
    //
    default:
        DavPrint((DEBUG_ERRORS,
                  "DavMapHttpErrorToDosError: Invalid!!! HttpResponseStatus = %d\n", 
                  HttpResponseStatus));
        return HttpResponseStatus;

    }
}


VOID
DavDumpHttpResponseHeader(
    HINTERNET OpenHandle
    )
/*++

Routine Description:

    This function dumps the response header that came back from the server.

Arguments:

    OpenHandle - The HttpOpenRequest handle on which the request was sent.

Return Value:

    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL IntRes;
    PWCHAR DataBuff = NULL;
    DWORD intLen = 0;

    IntRes = HttpQueryInfoW(OpenHandle,
                            HTTP_QUERY_RAW_HEADERS_CRLF,
                            DataBuff,
                            &intLen,
                            NULL);
    if ( !IntRes ) {
         WStatus = GetLastError();
         if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
             DavPrint((DEBUG_ERRORS, 
                       "DavDumpHttpResponseHeader/HttpQueryInfoW: Error Val = "
                       "%d\n", WStatus));
             goto EXIT_THE_FUNCTION;
         }
    }
        
    DataBuff = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, intLen);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, 
                  "DavDumpHttpResponseHeader/LocalAlloc: Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    IntRes = HttpQueryInfoW(OpenHandle,
                            HTTP_QUERY_RAW_HEADERS_CRLF,
                            DataBuff,
                            &intLen,
                            NULL);
    if ( !IntRes ) {
         WStatus = GetLastError();
         DavPrint((DEBUG_ERRORS, 
                   "DavDumpHttpResponseHeader/HttpQueryInfoW: Error Val = "
                   "%d\n", WStatus));
         goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_DEBUG, "DavDumpHttpResponseHeader:\n%ws\n", DataBuff));

EXIT_THE_FUNCTION:

    if (DataBuff) {
        LocalFree(DataBuff);
    }
    
    return;
}


VOID
DavDumpHttpResponseData(
    HINTERNET OpenHandle
    )
/*++

Routine Description:

    This function dumps the response data that came back from the server.

Arguments:

    OpenHandle - The HttpOpenRequest handle on which the request was sent.

Return Value:

    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReadRes;
    CHAR DataBuff[4096];
    DWORD didRead = 0;

    DavPrint((DEBUG_DEBUG, "DavDumpHttpResponseData:\n"));
    
    //
    // Read the Data in a loop and dump it.
    //
    do {

        RtlZeroMemory(DataBuff, 4096);

        ReadRes = InternetReadFile(OpenHandle, (LPVOID)DataBuff, 4096, &didRead);
        if ( !ReadRes ) {
             WStatus = GetLastError();
             DavPrint((DEBUG_ERRORS, 
                       "DavDumpHttpResponseData/InternetReadFile: Error Val = "
                       "%d\n", WStatus));
             goto EXIT_THE_FUNCTION;
        }

        if (didRead == 0) {
            break;
        }

        DavPrint((DEBUG_DEBUG, "%s", DataBuff));

    } while (TRUE);
    
    DavPrint((DEBUG_DEBUG, "\n"));
    
EXIT_THE_FUNCTION:

    return;
}


VOID
DavRemoveDummyShareFromFileName(
    PWCHAR FileName
    )
/*++

Routine Description:

    This function removes the DAV_DUMMY_SHARE from the FileName. This dummy
    share is added when a user tries to map a drive against http://server. This
    is allowed in DAV but doesn't fit well with the File system semantics. Hence
    a dummy share is added in WNetAddConnection3.

Arguments:

    FileName - The name of the file which has to be checked and modifed if 
               necessary.

Return Value:

    None.

--*/
{
    PWCHAR TempName1, TempName2 = NULL;
    ULONG i;

    TempName1 = wcsstr(FileName, DAV_DUMMY_SHARE);

    if (TempName1) {
        TempName2 = wcschr(TempName1, L'/');
        if (TempName2 != NULL) {
            TempName2++;
            for (i = 0; TempName2[i] != L'\0'; i++) {
                TempName1[i] = TempName2[i];
            }
            TempName1[i] = L'\0';
        } else {
            TempName1[0] = L'\0';
        }
    }

    return;
}


VOID
DavObtainServerProperties(
    PWCHAR DataBuff,
    BOOL *lpfIsHttpServer,
    BOOL *lpfIsIIS,
    BOOL *lpfIsDavServer
    )
/*++

Routine Description:

    This routine is used to parse the response (buffer) to the OPTIONS request 
    sent to server. This info helps to figure out if the HTTP server supports
    DAV extensions and whether it is an IIS (Microsoft's) server. The response
    buffer is split into lines and each line is sent to this routine.

Arguments:

    DataBuff - The Buffer containing the raw http response headers to be parsed.
    
    lpfIsHttpServer - Set to TRUE if this is a http server.
    
    lpfIsIIS - Set to TRUE if this is an IIS server.
    
    lpfIsDavServer - Set to TRUE if this is a DAV server.

Return Value:

    none.

--*/
{
    PWCHAR p, ParseData;

    if (lpfIsHttpServer)
    {
        *lpfIsHttpServer = FALSE;
    }

    if (lpfIsIIS)
    {
        *lpfIsIIS = FALSE;
    }

    if (lpfIsDavServer)
    {
        *lpfIsDavServer = FALSE;
    }

    //
    // Parse the DataBuff here.
    //
    ParseData = wcstok(DataBuff, L"\n");
    
    while (ParseData != NULL) {
    
        if ( ( p = wcsstr(ParseData, L"HTTP/1.1") ) != NULL ) {
            //
            // This is a HTTP server.
            //
            if (lpfIsHttpServer)
            {
                *lpfIsHttpServer = TRUE;
            }
        } else if ( ( p = wcsstr(ParseData, L"Microsoft-IIS") ) != NULL ) {
            //
            // This is a Microsoft IIS server.
            //
            if (lpfIsIIS)
            {
                *lpfIsIIS = TRUE;
            }
        } else if ( ( p = wcsstr(ParseData, L"DAV") ) != NULL ) {
            //
            // This HTTP server supports DAV extensions.
            //
            if (lpfIsDavServer)
            {
                *lpfIsDavServer = TRUE;
            }
        }
        
        ParseData = wcstok(NULL, L"\n");

    }

}


DWORD
DavReportEventInEventLog(
    DWORD EventType,
    DWORD EventId,
    DWORD NumberOfStrings,
    PWCHAR *EventStrings
    )
/*++

Routine Description:

    This routine logs a message in the EventLog under System section.

Arguments:

    EventType - Specifies the type of event being logged.
    
    EventId - Specifies the event. The event identifier specifies the message
              that goes with this event as an entry in the message file
              associated with the event source. 
    
    NumberOfStrings - Specifies the number of strings in the array pointed to by\
                      the EventStrings parameter. A value of zero indicates that
                      no strings are present. 
    
    EventStrings - Pointer to a buffer containing an array of null-terminated
                   strings which get logged in this message.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 Error.    

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HANDLE WebClientHandle = NULL;
    BOOL reportEvent = FALSE;

    WebClientHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (WebClientHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReportEventInEventLog/RegisterEventSourceW: Error Val = "
                  "%d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    reportEvent = ReportEventW(WebClientHandle,
                               (WORD)EventType,
                               0,
                               EventId,
                               NULL,
                               (WORD)NumberOfStrings,
                               0,
                               EventStrings,
                               NULL);
    if (!reportEvent) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReportEventInEventLog/ReportEventW: Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (WebClientHandle != NULL) {
        BOOL deRegister;
        deRegister = DeregisterEventSource(WebClientHandle);
        if (!deRegister) {
            DavPrint((DEBUG_ERRORS,
                      "DavReportEventInEventLog/DeregisterEventSource: Error Val = "
                      "%d\n", GetLastError()));
        }
    }

    return WStatus;
}


DWORD
DavFormatAndLogError(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    DWORD Win32Status
    )
/*++

Routine Description:

    This routine formats the Error Message and calls DavReportEventInEventLog
    to log it in the EventLog.

Arguments:

    DavWorkItem - The workitem for the failed request.
    
    Win32Status - The Win32 failure status.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 Error.    

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR *EventStrings = NULL, TempName = NULL;
    PWCHAR ServerName = NULL, PathName = NULL, CompleteFileName = NULL;
    ULONG StringCount = 0, EventId = 0, SizeInBytes = 0;
    UNICODE_STRING StatusString;

    StatusString.Buffer = NULL;
    StatusString.Length = 0;
    StatusString.MaximumLength = 0;

    switch (DavWorkItem->WorkItemType) {
 
    case UserModeClose: {

        ServerName = DavWorkItem->CloseRequest.ServerName;
        PathName = DavWorkItem->CloseRequest.PathName;

        switch (DavWorkItem->DavMinorOperation) {
        
        case DavMinorPutFile: 
            EventId = EVENT_WEBCLIENT_CLOSE_PUT_FAILED;
            break;

        case DavMinorDeleteFile:
            EventId = EVENT_WEBCLIENT_CLOSE_DELETE_FAILED;
            break;

        case DavMinorProppatchFile:
            EventId = EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED;
            break;
        
        default:
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;

        }

    }
    break;

    case UserModeSetFileInformation: {

        ServerName = DavWorkItem->SetFileInformationRequest.ServerName;
        PathName = DavWorkItem->SetFileInformationRequest.PathName;

        switch (DavWorkItem->DavMinorOperation) {
        
        case DavMinorProppatchFile:
            EventId = EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED;
            break;
        
        default:
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;

        }

    }
    break;

    default:

        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    
    }

    //
    // We always log 2 string in this function. One is the status value and the
    // other is the filename.
    //
    StringCount = 2;

    EventStrings = LocalAlloc(LPTR, StringCount * sizeof(PWCHAR));
    if (EventStrings == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(1): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Build the complete path name from the server name and the path name.
    //

    //
    // The extra 1 is for the \0 character.
    //
    SizeInBytes = ( (wcslen(ServerName) + wcslen(PathName) + 1) * sizeof(WCHAR) );

    CompleteFileName = LocalAlloc(LPTR, SizeInBytes);
    if (CompleteFileName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(2): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    wcsncpy( CompleteFileName, ServerName, wcslen(ServerName) );

    TempName = ( CompleteFileName + wcslen(ServerName) );

    wcsncpy( TempName, PathName, wcslen(PathName) );

    CompleteFileName[ ( (SizeInBytes / sizeof(WCHAR)) - 1 ) ] = L'\0';

    //
    // Replace all '/'s with '\'s.
    //
    for (TempName = CompleteFileName; *TempName != L'\0'; TempName++) {
        if (*TempName == L'/') {
            *TempName = L'\\';
        }
    }

    //
    // Build a string out of the WStatus. We assume that the ErrorCode will not
    // be more than 8 digits.
    //
    StatusString.Length = ( 10 * sizeof(WCHAR) );
    StatusString.MaximumLength = ( 10 * sizeof(WCHAR) );
    StatusString.Buffer = LocalAlloc(LPTR, StatusString.Length);
    if (StatusString.Buffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(3): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = RtlIntegerToUnicodeString(Win32Status, 0, &(StatusString));
    if (WStatus != STATUS_SUCCESS) {
        WStatus = RtlNtStatusToDosError(WStatus);
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/RtlIntegerToUnicodeString: WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavFormatAndLogError: CompleteFileName = %ws, ErrorString = %ws\n",
              CompleteFileName, StatusString.Buffer));

    EventStrings[0] = CompleteFileName;
    EventStrings[1] = StatusString.Buffer;

    WStatus = DavReportEventInEventLog(EVENTLOG_WARNING_TYPE,
                                       EventId,
                                       StringCount,
                                       EventStrings);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/DavReportEventInEventLog: WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (CompleteFileName) {
        LocalFree(CompleteFileName);
        CompleteFileName = NULL;
    }

    if (StatusString.Buffer) {
        LocalFree(StatusString.Buffer);
        StatusString.Buffer = NULL;
        StatusString.Length = 0;
        StatusString.MaximumLength = 0;
    }

    if (EventStrings) {
        LocalFree(EventStrings);
        EventStrings = NULL;
    }

    return WStatus;
}

DWORD
DavAttachPassportCookie(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle,
    PWCHAR *PassportCookie
    )
/*++

Routine Description:

   This routine attaches the passport cookie to the Http request header if it exists.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
    DavOpenHandle - The Wininet request handle.
    
    PassportCookie - The buffer contains the cookie sent to Wininet
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.
    
Note:

    The caller of this routine should free the PassportCookie at the end of the request.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;

    EnterCriticalSection(&DavPassportLock);

    if (DavWorkItem->ServerUserEntry.PerUserEntry->Cookie != NULL) {

        *PassportCookie = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                    (wcslen(DavWorkItem->ServerUserEntry.PerUserEntry->Cookie)+1)*sizeof(WCHAR));

        if (*PassportCookie == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, 
                      "DavAttachPassportCookie/LocalAlloc: Error Val = %d\n", 
                      WStatus));

            LeaveCriticalSection(&DavPassportLock);
            goto EXIT_THE_FUNCTION;
        }

        wcscpy(*PassportCookie,DavWorkItem->ServerUserEntry.PerUserEntry->Cookie);

        LeaveCriticalSection(&DavPassportLock);

        DavPrint((DEBUG_MISC,
                  "DavAttachPassportCookie: %x %d %ws\n", 
                  DavWorkItem->ServerUserEntry.PerUserEntry,
                  wcslen(*PassportCookie)*sizeof(WCHAR),
                  *PassportCookie));

        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           *PassportCookie,
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAttachPassportCookie/Add Cookie. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        LeaveCriticalSection(&DavPassportLock);
    }

EXIT_THE_FUNCTION:

    return WStatus;
}

DWORD
DavInternetSetOption(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle
    )
/*++

Routine Description:

   This routine set the user name and password to the internet handle.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
    DavOpenHandle - The Wininet request handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;

    //
    // In case of UserModeCreateSrvCall, we don't have a PerUserEntry yet.
    //
    if (DavWorkItem->WorkItemType == UserModeCreateSrvCall) {
        if (lstrlenW(DavWorkItem->UserName)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                               INTERNET_OPTION_USERNAME, 
                               DavWorkItem->UserName, 
                               lstrlenW(DavWorkItem->UserName));
            DavPrint((DEBUG_MISC, 
                      "InternetSetOptionW username %x %ws\n",DavWorkItem,DavWorkItem->UserName));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_USERNAME,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(1). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (lstrlenW(DavWorkItem->Password)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                               INTERNET_OPTION_PASSWORD, 
                               DavWorkItem->Password, 
                               lstrlenW(DavWorkItem->Password) );
            DavPrint((DEBUG_MISC, 
                      "InternetSetOptionW password %x ????????\n",DavWorkItem,DavWorkItem->Password));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_PASSWORD,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(2). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        if (lstrlenW(DavWorkItem->ServerUserEntry.PerUserEntry->UserName)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                               INTERNET_OPTION_USERNAME, 
                               DavWorkItem->ServerUserEntry.PerUserEntry->UserName, 
                               lstrlenW(DavWorkItem->ServerUserEntry.PerUserEntry->UserName));
            DavPrint((DEBUG_MISC, 
                      "InternetSetOptionW username %ws\n",DavWorkItem->ServerUserEntry.PerUserEntry->UserName));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_USERNAME,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (lstrlenW(DavWorkItem->ServerUserEntry.PerUserEntry->Password)) {
            UNICODE_STRING EncodedPassword;
            PWCHAR Password = NULL;

            Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                  (wcslen(DavWorkItem->ServerUserEntry.PerUserEntry->Password)+1)*sizeof(WCHAR));

            if (Password == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            wcscpy(Password,DavWorkItem->ServerUserEntry.PerUserEntry->Password);

            RtlInitUnicodeString(&EncodedPassword,Password);
            RtlRunDecodeUnicodeString(PASSWORD_SEED,&EncodedPassword);

            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                               INTERNET_OPTION_PASSWORD, 
                               Password, 
                               lstrlenW(Password) );

            DavPrint((DEBUG_MISC, 
                      "InternetSetOptionW password %ws\n",DavWorkItem->ServerUserEntry.PerUserEntry->Password));

            LocalFree(Password);
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_PASSWORD,L"",1);
        }
    
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(4). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

EXIT_THE_FUNCTION:
    
    return WStatus;
}

ULONG
DavQueryPassportCookie(
    IN HINTERNET RequestHandle,
    IN OUT PWCHAR *Cookie
    )
/*++

Routine Description:

    This function get the Set-Cookie strings from the HTTP response.

Arguments:

    RequestHandle - The handle from HttpOpenRequestW.
    
    Cookie - The pointer of the buffer that stores the pointer of the cookies
    
Return Value:

    NO_ERROR - Success or the appropriate Win32 error code.
    
Notes:

   Here are the exsample of the Set-Cookies on the PROPFIND response from a Tweener server:
   
   MSPProf=1AAAAAARAHWeNZdbsWxdhaoUAQ0TfwgHdg7f%2A4ShKm5kK%2AhXHJOsOdPyG27%2A8sh7cirwMRoJoIu764HkLE9lZeKQHOxHw5ZaU2Be0I4BNcxKksiv1vgKvc0Dzy7rlZrOGt6W6efmkr8f8%24; domain=.pp.test.microsoft.com; path=/
   MSPAuth=1AAAAAASAHimsAU2%2AhA9F60NUehefWQp%2AqMNG6%2AWP3f4H25EBsGW8Zo1dZGwVG5txt; domain=.pp.test.microsoft.com; path=/
   MSPProfC=; path=/; expires=Tue 1-Jan-1980 12:00:00 GMT;
   
   We are only interested in part of them:
   
   MSPProf=1AAAAAARAHWeNZdbsWxdhaoUAQ0TfwgHdg7f%2A4ShKm5kK%2AhXHJOsOdPyG27%2A8sh7cirwMRoJoIu764HkLE9lZeKQHOxHw5ZaU2Be0I4BNcxKksiv1vgKvc0Dzy7rlZrOGt6W6efmkr8f8%24;
   MSPAuth=1AAAAAASAHimsAU2%2AhA9F60NUehefWQp%2AqMNG6%2AWP3f4H25EBsGW8Zo1dZGwVG5txt;
   MSPProfC=;
   
   This routine allocates a buffer to save the cookie, which should be freed at
   the end of the connection.
   
--*/
{
    ULONG  WStatus = ERROR_SUCCESS;
    BOOL   ReturnVal = FALSE;
    PWCHAR SetCookies = NULL;
    DWORD  TotalLength = 0;
    DWORD  Current = 0;
    WCHAR  CustomBuffer[30];
    ULONG  CustomBufferLength = 0;
    DWORD  Index = 0;

    ASSERT(*Cookie == NULL);

    RtlZeroMemory(CustomBuffer, sizeof(CustomBuffer));
    wcscpy(CustomBuffer, L"Authentication-Info:");

    CustomBufferLength = sizeof(CustomBuffer);

    ReturnVal = HttpQueryInfoW(RequestHandle,
                               HTTP_QUERY_CUSTOM,
                               (PVOID)CustomBuffer,
                               &(CustomBufferLength),
                               &Index);
    
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            //
            // The reponse with the valid passport cookie should always have the 
            // "Authentication-Info:" included on the header.
            //
            DavPrint((DEBUG_MISC,"DavQuerySetCookie/HttpQueryInfoW(0): WStatus = %d\n",WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    DavPrint((DEBUG_MISC,"Authentication-Info found\n"));
    
    RtlZeroMemory(CustomBuffer, sizeof(CustomBuffer));
    wcscpy(CustomBuffer, L"Set-Cookie:");

    Index = 0;

    for ( ; ; ) {

        //
        // Query the size of the each Set-Cookie string.
        //

        CustomBufferLength = sizeof(CustomBuffer);

        ReturnVal = HttpQueryInfoW(RequestHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)CustomBuffer,
                                   &(CustomBufferLength),
                                   &Index);

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                DavPrint((DEBUG_MISC, 
                          "DavQuerySetCookie/HttpQueryInfoW(1): WStatus = %d, "
                          "TotalLength = %d, Index = %d\n",
                          WStatus, TotalLength, Index));
                                
                                if (WStatus == ERROR_HTTP_HEADER_NOT_FOUND) {
                    //
                    // No more Set-Cookie string exists
                    //
                    break;
                } else {
                    goto EXIT_THE_FUNCTION;
                }
            }
        }

        TotalLength += CustomBufferLength;
        Index ++;

        if (Index > 20) {
            break;
        }
    }

    DavPrint((DEBUG_MISC,"DavQuerySetCookie: TotalLength = %d, Index = %d\n",TotalLength, Index));

    if (TotalLength > 0) {
        
        SetCookies = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), TotalLength);
        if (SetCookies == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, 
                      "DavQuerySetCookie/LocalAlloc: Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(SetCookies, TotalLength);
        wcscpy(SetCookies, L"Cookie: ");
        Current = wcslen(L"Cookie: ") * sizeof(WCHAR);

        Index = 0;

        for ( ; ; ) {
            
            ULONG i;

            //
            // Save the Set-Cookie strings to a single buffer.
            //

            wcscpy(&SetCookies[Current/sizeof(WCHAR)], L"Set-Cookie:");
            CustomBufferLength = TotalLength - Current;

            ReturnVal = HttpQueryInfoW(RequestHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)(&SetCookies[Current/sizeof(WCHAR)]),
                                       &(CustomBufferLength),
                                       &(Index));
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavQuerySetCookie/HttpQueryInfoW(2): Error Val = %d\n", 
                          WStatus));
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    goto EXIT_THE_FUNCTION;
                } else {
                    break;
                }
            }

            for (i = Current; i < (Current + CustomBufferLength); i += sizeof(WCHAR)) {
                if (SetCookies[ i / sizeof(WCHAR) ] == L' ') {
                    i += sizeof(WCHAR);
                    break;
                }
            }

            //
            // Only interested in the first string of the set-cookie.
            //
            Current = i;
            RtlZeroMemory( &SetCookies[ i / sizeof(WCHAR) ], (TotalLength - i) );

            DavPrint((DEBUG_MISC,
                      "DavQuerySetCookie: Current = %d, CustomBufferLength = %d, "
                      "Index = %d, SetCookies = %ws\n",
                      Current, CustomBufferLength, Index, SetCookies));

            if (Index > 20) {
                break;
            }
        }

        //
        // Get rid of the last "Set-Cookie:" used for HttpQueryInfoW.
        //
        RtlZeroMemory( &SetCookies[ Current / sizeof(WCHAR) ], (TotalLength-Current) );
        *Cookie = SetCookies;

        WStatus = ERROR_SUCCESS;  
    }

EXIT_THE_FUNCTION:
    
    if ((WStatus != ERROR_SUCCESS) && (SetCookies != NULL)) {
        LocalFree(SetCookies);
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\nodefac.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nodefac.cpp
    
Abstract:

    This file implements the CDavNodefactory class which is used to parse the 
    XML responses we get from the DAV server.

Author:

    Rohan Kumar      [RohanK]      14-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <stdio.h>
#include <windows.h>
#include "usrmddav.h"
#include "nodefac.h"
#include "stdlib.h"
#include "wininet.h"
#include "UniUtf.h"

//
// WebDAV Properties - RFC 2518
//
WCHAR   rgCreationDate[]= L":creationdate";
WCHAR   rgDisplayName[]= L":displayname"; // Ignored for now - href will be used to get name
WCHAR   rgGetContentLanguage[]= L"getcontentlanguage"; // Ignored for now
WCHAR   rgGetContentLength[] = L":getcontentlength"; 
WCHAR   rgGetContentType[] = L":getcontenttype"; // Ignored for now
WCHAR   rgGetETag[] = L":getetag"; // Ignored for now
WCHAR   rgGetLastModified[] = L":getlastmodified";
WCHAR   rgLockDiscovery[]= L":lockdiscovery"; // Ignored for now
WCHAR   rgResourceType[]= L":resourcetype";  
WCHAR   rgSource[]= L":source"; // Ignored for now
WCHAR   rgSupportedLock[]= L":supportedlock"; // Ignored for now


//
// Properties which this client will set on DAV resources to improve performance
//
WCHAR   rgIsHidden[]= L":ishidden";
WCHAR   rgIsCollection[]= L":iscollection";
WCHAR   rgIsReadOnly[]= L":isreadonly";

WCHAR   rgHref[] = L":href";
WCHAR   rgStatus[] = L":status";
WCHAR   rgResponse[] = L":response";

WCHAR   rgWin32FileAttributes[] = L":Win32FileAttributes";
WCHAR   rgWin32CreationTime[] = L":Win32CreationTime";
WCHAR   rgWin32LastAccessTime[] = L":Win32LastAccessTime";
WCHAR   rgWin32LastModifiedTime[] = L":Win32LastModifiedTime";

//
// MSN specific
//

WCHAR   rgAvailableSpace[]= L":availablespace";
WCHAR   rgTotalSpace[]= L":totalspace";

DWORD
DavInternetTimeToFileTime(
    PWCHAR lpTimeString,
    FILETIME *lpft
    );

VOID
DavOverrideAttributes(
    PDAV_FILE_ATTRIBUTES pDavFileAttributes
    );


STDMETHODIMP_(ULONG) 
CDavNodeFactory::AddRef(
    VOID
    )
/*++

Routine Description:

    The AddRef function of the IUnknown class.

Arguments:

    none.

Return Value:

    The new reference count of the object.

--*/
{
    return (ULONG)InterlockedIncrement((long *)&m_ulRefCount);
}


STDMETHODIMP_(ULONG) 
CDavNodeFactory::Release(
    VOID
    )
/*++

Routine Description:

    The Release function of the IUnknown class.

Arguments:

    none.

Return Value:

    The reference count remaining on the object.

--*/
{
    ULONG   ulRefCount = InterlockedDecrement((long *)&m_ulRefCount);

    if (ulRefCount == 0) {
        delete this;
    }

    return ulRefCount;
}


STDMETHODIMP 
CDavNodeFactory::QueryInterface(
    REFIID riid, 
    LPVOID *ppvObject
    )
/*++

Routine Description:

    The QueryInterface function of the IUnknown class.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hr = E_NOINTERFACE;

    if (ppvObject == NULL)
        return E_POINTER;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppvObject = (LPVOID) this;
        AddRef();
        hr = NOERROR;
    } else if (IsEqualIID(riid, IID_IXMLNodeFactory)) {
        *ppvObject = (LPVOID) this;
        AddRef();
        hr = NOERROR;
    }

    return hr;
}


STDMETHODIMP
CDavNodeFactory::NotifyEvent(
    IN IXMLNodeSource* pSource,
    IN XML_NODEFACTORY_EVENT iEvt
    )
/*++

Routine Description:

    The NotifyEvent function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    // XmlDavDbgPrint(("Entered NotifyEvent. Event = %d.\n", iEvt));
    return S_OK;
}


STDMETHODIMP
CDavNodeFactory::BeginChildren(
    IN IXMLNodeSource* pSource, 
    IN XML_NODE_INFO* pNodeInfo
    )
/*++

Routine Description:

    The BeginChildren function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    // XmlDavDbgPrint(("%ld: BeginChildren: pwcText = %ws\n",
    //                 GetCurrentThreadId(), pNodeInfo->pwcText));

    // XmlDavDbgPrint(("%ld: BeginChildren: fTerminal = %d\n",
    //                 GetCurrentThreadId(), pNodeInfo->fTerminal));

    return S_OK;
}
            

STDMETHODIMP
CDavNodeFactory::EndChildren(
    IN IXMLNodeSource* pSource,
    IN BOOL fEmpty,
    IN XML_NODE_INFO* pNodeInfo
    )
/*++

Routine Description:

    The EndChildren function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    IXMLParser *Xp = NULL;
    CDavNodeFactory *NodeFac = NULL;
    PWCHAR Temp = NULL, thirdWack = NULL, firstChar = NULL, lastChar = NULL;
    BOOL isAbsoluteName = FALSE, lastCharIsWack = FALSE, rootLevel = FALSE, freeTemp = TRUE;
    DWORD wackCount = 0;
    ULONG_PTR LengthInChars = 0;
    PDAV_FILE_ATTRIBUTES DFA = NULL;
    DWORD ConvertedLength = 0;
    DWORD fullFileNameLength = 0;
    
    // XmlDavDbgPrint(("%ld: EndChildren: fEmpty = %d\n",
    //                GetCurrentThreadId(), fEmpty));

    // XmlDavDbgPrint(("%ld: EndChildren: pwcText = %ws\n",
    //                GetCurrentThreadId(), pNodeInfo->pwcText));

    // XmlDavDbgPrint(("%ld: EndChildren: fTerminal = %d\n",
    //                GetCurrentThreadId(), pNodeInfo->fTerminal));
    
    Xp = (IXMLParser *)pSource;

    hResult = Xp->GetFactory( (IXMLNodeFactory **)&(NodeFac) );
    if (!SUCCEEDED(hResult)) {
        NodeFac = NULL;
        XmlDavDbgPrint(("%ld: ERROR: EndChildren/GetFactory.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // IMPORTANT!!!
    // If this was an empty node, then we should set the NodeFac->m_FoundEntry
    // to FALSE. This is because if we get a node like <foo>...</foo></bar><haha>...
    // then CreateNode would have been called for "bar". If we were interested
    // in the property "bar", we would have set NodeFac->m_FoundEntry to TRUE.
    // This is with the expectation that the next CreateNode will come with the
    // value of "bar". But in this case, "bar" does not have any value since its
    // empty. So, the next CreateNode will be called with pwcText == "haha" which
    // we will expect to be the value of "bar" and the parsing will screw up.
    // To avoid this we set  NodeFac->m_FoundEntry to FALSE here since between
    // the two CreateNodes, we get an EndChildren for "bar" with fEmpty set to
    // TRUE. This is the indication that we should not be looking for the value
    // of "bar" since its empty. By doing this, the parsing will continue smoothly
    // in CreateNode for the next element "haha".
    //
    if (fEmpty == TRUE) {
        NodeFac->m_FoundEntry = FALSE;
        goto EXIT_THE_FUNCTION;
    }


    // 
    // Since filename information can span over many CreateNode calls, so we collect
    // the complete filename information in CreateNode calls and then process them
    // here (EndChildren) to get the displayname.
    // Ex. <href>http://abc.com/AB&quot;123</href> has 3 CreateNode calls: 
    // 1] http://abc.com//AB
    // 2] "
    // 3] 123
    // and complete name is http://abc.com/AB"123.
    //
    if ( (NodeFac->m_FoundEntry == TRUE) && 
                    (NodeFac->m_CreateNodeAttribute == CreateNode_DisplayName) ) {

        DFA = NodeFac->m_DFAToUse;

        if(DFA->FileName == NULL || DFA->FileNameLength == 0) {
            XmlDavDbgPrint(("%ld: ERROR: EndChildren. Invalid FileName information. FileName=0x%x FileNameLength=%d.\n", 
                                    GetCurrentThreadId(), DFA->FileName, DFA->FileNameLength));
            hResult = CO_E_ERRORINAPP;
            goto EXIT_THE_FUNCTION;
        }

        //
        // Store the FullFileName Length in a local variable. This will be used to
        // find "parent DAV collection".
        //
        fullFileNameLength = DFA->FileNameLength;

        // 
        // DFA->FileName buffer has filename of length DFA->FileNameLength and a 
        // NULL character in the end.
        // 
        
        //
        // Names can be absoulte URLs or can be relative URLs. 
        // Format of absolute URLs::     scheme ":" (some path)
        // Format of relative URLs::     
        //                               "//" (some path)
        //                               "/" (some path)
        //                               (some name) ["/" (some path)]
        //
        //

        // 
        // Note : We are supporting only HTTP URLs "http://" (somepath) 
        // and relative path names
        //

        //
        // We need to parse the string NodeInfo->pwcText and get the
        // DisplayName out of it. Here are the 7 cases we handle.
        // 1. http://rohank-srv/ <===> DisplayName == NULL.
        // 2. http://rohank-srv/test <===> DisplayName == test.
        // 3. http://rohank-srv/test/ <===> DisplayName == test.
        // 4. /test/ <===> DisplayName == test
        // 5. /test <===> DisplayName == test
        // 6. /test/foo.txt <===> DisplayName == foo.txt
        // 7. / <===> DisplayName == NULL
        // In the above "test" could very well be a path like foo/bar.
        // http://rohank-srv/test/foo.txt <===> DisplayName == foo.txt.
        
            
        firstChar = (PWCHAR)(DFA->FileName);
        //
        // http://rohank-srv/test/foo.txt"
        //                               ^
        //                               |
        //                               lastChar
        //
        lastChar = (PWCHAR)(firstChar + DFA->FileNameLength);

        // 
        // Need to find if the name is Absolute name or Relative name. For this
        // if we find 'http://' in the start of name then it is a absolute name.
        //
        isAbsoluteName = FALSE;
        if((DFA->FileNameLength >= (sizeof(L"http://")/sizeof(WCHAR)-1)) &&
            (_wcsnicmp(firstChar, L"http://", (sizeof(L"http://")/sizeof(WCHAR))-1) == 0) ) {
            isAbsoluteName = TRUE;
        }

        //
        // If DFA->pwcText = http://rohank-srv/foo/bar.txt,
        // http://rohank-srv/foo/bar.txt
        //                  ^
        //                  |
        //                  thirdWack
        //
        thirdWack = firstChar;
        wackCount = 0;
        while(thirdWack < lastChar) {
            if (*thirdWack == L'/') {
                wackCount++;
                if (wackCount == 3) {
                    break;
                }
            }
            thirdWack++;
        }
        // 
        // After this loop, either thirdWack == 3rd Wack or thirdWack = lastChar.
        // 

        //
        // We need to deal with five special cases.
        // 1. http://rohank-srv/ and 
        // 2. http://rohank-srv/test/
        // 3. /
        // 4. test/
        // 5. //
        // 
        if ( *(lastChar - 1) == L'/' ) {

            lastCharIsWack = TRUE;
            
            //  
            // If URL = http://rohank-srv/, the display name should be 
            // NULL.
            // Same for URL = /  and URL = //
            //
            if ( ((lastChar - 1) == thirdWack && isAbsoluteName==TRUE) ||
                            (DFA->FileNameLength == 1) ||
                            (DFA->FileNameLength == 2 && *(lastChar-2) == L'/')) {
                rootLevel = TRUE;
            } else {
                rootLevel = FALSE;
                //
                // We subtract 2 here because of the way we do the 
                // parsing below.
                //
                lastChar -= 2;
            }

        } else {
            lastCharIsWack = FALSE;
            rootLevel = FALSE;
        }

        if (rootLevel == FALSE) {

            //
            // Becuase we check for L'/', we subtract 2 from the 
            // lastChar pointer above if the URL was of the form
            // 1. http://rohank-srv/test/.
            // 2. test/
            // We add the check lastChar != firstChar
            // in the loop below to make sure that we never go beyond the
            // begenning of the string. This could happen when pwcText is of the
            // form test/. In this case we will end at the character 't'.
            // 
            while(*lastChar != L'/' && lastChar != firstChar) {
                lastChar--;
            }
    
            //
            // As explained above the last char need not be a '/'. An example is 
            // when pwcText is test/. In this case lastChar points to 't'.
            //
            if(*lastChar == L'/') {
                lastChar++;
            }
        
            //
            // lastChar now points to the first char of the name after the
            // last backslash. The extra 1 is for the final \0 char.
            // http://rohank-srv/test/foo.txt
            //                        ^
            //                        |
            //                        lastChar
            //  
            //  Note: If last char is a wack, then it is included here.
            //
            LengthInChars = (ULONG_PTR)( (firstChar + DFA->FileNameLength + 1) - lastChar );
            if (LengthInChars <= 1) {
                XmlDavDbgPrint(("%ld: ERROR: EndChildren. Displayname length is 0.\n",
                                        GetCurrentThreadId()));
                hResult = CO_E_ERRORINAPP;
                goto EXIT_THE_FUNCTION;
            }
        } else {
            //
            // rootLevel = TRUE => FileName = L"/"
            LengthInChars = 2;
        }
         
        //
        // Allocate memory to contain Actual Display Name.
        // 

        Temp = (PWCHAR)LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, 
                                            LengthInChars * sizeof(WCHAR) );
        if(Temp == NULL) {
            ULONG WStatus;
            WStatus = GetLastError();
            XmlDavDbgPrint(("%ld: ERROR: EndChildren. LocalAlloc. Error Val = %d\n", 
                                    GetCurrentThreadId(), WStatus));
            hResult = CO_E_ERRORINAPP;
            goto EXIT_THE_FUNCTION;
        }
        freeTemp = TRUE;

        if(rootLevel == FALSE) {
            //  
            //  Copy the element. Displayname can be a unicode
            //  string, then server will send it as a UTF-8 format URL string 
            //  We need to convert such a display name to a Unicode string.
            //  Assumption: The URL is UTF-8 format encoded URL string.
            //  i.e. extended characters appear as %HH%HH... in URL string.
            //
            ConvertedLength = 0;
            hResult = UtfUrlStrToWideStr(lastChar, (DWORD)(LengthInChars-1), Temp, 
                                                            &ConvertedLength);
            if(hResult != ERROR_SUCCESS) {
                XmlDavDbgPrint(("%ld: ERROR: EndChildren/UtfUrlToWideStr = %u\n",
                                GetCurrentThreadId(), hResult));
                goto EXIT_THE_FUNCTION;
            }
    
            //
            // If the last char was a "/" like in http://rohank-srv/test/,
            // we would have copied "test/" as the name. We need to strip
            // out the last wack and the display name should be "test". ConvertedLength
            // points to the char next to the last char.
            //
            if (lastCharIsWack) {
                Temp[(ConvertedLength - 1)] = L'\0';
            }
        } else {
            //
            // The displayname is root level name - hence return L"/" for
            // actual displayname.
            //
            Temp[0] = L'/';
            Temp[1] = L'\0';
        }

        //XmlDavDbgPrint(("%ld. EndChildren. Temp=%ws, LengthInChars=%d\n", Temp, LengthInChars ));

        if ( DFA->FileName != NULL ) {
            LocalFree((HLOCAL)DFA->FileName);
            DFA->FileName = NULL;
        }
        DFA->FileNameLength = 0;
        
        NodeFac->m_DFAToUse->FileName = Temp;
        NodeFac->m_DFAToUse->FileNameLength = wcslen(Temp);
        freeTemp = FALSE;

        //
        // Files / Collections properties can come in any order in
        // a XML response. We want to have the DavFileAtrributes entry which
        // corresponds to Collection which "contains" all the other DAV resources
        // present in this XML response ("parent DAV collection").
        // 
        // NodeFac->m_CollectionDFA will point to DFA entry with smallest
        // Full-DisplayName (that comes in "<a:href>Full-DisplayName</a:href>") 
        // in the response. 
        // 
        // If XML response contains the properties of the "parent DAV collection"
        // then it will have smallest Full-DisplayName and in that case 
        // NodeFac->m_CollectionDFA will point to entry of "parent DAV 
        // collection".
        //
        // Caller of this function should know whether to expect entry for
        // "parent DAV resource" in this XML response.
        //
        if(fullFileNameLength < NodeFac->m_MinDisplayNameLength) {
            NodeFac->m_CollectionDFA = DFA;
            NodeFac->m_MinDisplayNameLength = fullFileNameLength;
        }
    }
        

EXIT_THE_FUNCTION:

    // 
    // Assumption: (this is TRUE according to our current implementation)
    // The XML_ELEMENTs which we parse to get information have atmost 1 child. 
    //
    // When we have parsed a XML_ELEMENT of our interest and has set NodeFac->m_FoundEntry
    // = TRUE, we should set NodeFac->m_FoundEntry=FALSE on "EndChildren call of either
    // this XML_ELEMENT" or the "EndChildren call of first child XML_ELEMENT".
    // 
    // NodeFac->m_FoundEntry = TRUE => We are parsing a XML_ELEMENT of our interest
    // and EndChildren is called either on ending of this XML_ELEMENT or on ending of
    // a child-element of this XML_ELEMENT.
    //
    if(NodeFac != NULL) {
        NodeFac->m_FoundEntry = FALSE;
    }

    if(freeTemp == TRUE && Temp != NULL) {
        LocalFree((HLOCAL)Temp);
        Temp = NULL;
    }

    return hResult;
}


STDMETHODIMP
CDavNodeFactory::Error(
    IN IXMLNodeSource* pSource,
    IN HRESULT hrErrorCode,
    IN USHORT cNumRecs,
    IN XML_NODE_INFO __RPC_FAR **aNodeInfo
    )
/*++

Routine Description:

    The Error function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    XML_NODE_INFO *NodeInfo = NULL;
    IXMLParser *Xp = NULL;
    BSTR ErrorStr = NULL;
    const WCHAR *LineBuffer = NULL;
    ULONG LineBuffLen = 0, ErrPos = 0, LineNumber = 0, LinePos = 0, AbsPos = 0;
    
    XmlDavDbgPrint(("%ld: Entered Error...\n", GetCurrentThreadId()));
    
    XmlDavDbgPrint(("%ld: Error: hrErrorCode = %08lx\n", GetCurrentThreadId(), hrErrorCode));

    XmlDavDbgPrint(("%ld: Error: cNumRecs = %d\n", GetCurrentThreadId(), cNumRecs));
    
    Xp = (IXMLParser *)pSource;
    
    LineNumber = Xp->GetLineNumber();
    XmlDavDbgPrint(("%ld: Error: LineNumber = %d\n", GetCurrentThreadId(), LineNumber));

    LinePos = Xp->GetLinePosition();
    XmlDavDbgPrint(("%ld: Error: LinePosition = %d\n", GetCurrentThreadId(), LinePos));

    AbsPos = Xp->GetAbsolutePosition();
    XmlDavDbgPrint(("%ld: Error: AbsPos = %d\n", GetCurrentThreadId(), AbsPos));

    hResult = Xp->GetErrorInfo( &(ErrorStr) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: Error/GetErrorInfo. hResult = %08lx\n", 
                        GetCurrentThreadId(), hResult));
        goto EXIT_THE_FUNCTION;
    }

    XmlDavDbgPrint(("%ld: Error: ErrorStr = %ws\n", GetCurrentThreadId(), ErrorStr));
    
    hResult = Xp->GetLineBuffer( &(LineBuffer), &(LineBuffLen), &(ErrPos) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: Error/GetErrorInfo. hResult = %08lx\n", 
                        GetCurrentThreadId(), hResult));
        goto EXIT_THE_FUNCTION;
    }

    XmlDavDbgPrint(("%ld: Error: LineBuffer = %ws\n", GetCurrentThreadId(), LineBuffer));
    XmlDavDbgPrint(("%ld: Error: LineBufferLen = %d\n", GetCurrentThreadId(), LineBuffLen));
    XmlDavDbgPrint(("%ld: Error: ErrorPos = %d\n", GetCurrentThreadId(), ErrPos));

EXIT_THE_FUNCTION:
    
    return S_OK;
}


STDMETHODIMP
CDavNodeFactory::CreateNode(
    IN IXMLNodeSource __RPC_FAR *pSource,
    IN PVOID pNodeParent,
    IN USHORT cNumRecs,
    IN XML_NODE_INFO __RPC_FAR **aNodeInfo
    )
/*++

Routine Description:

    The CreateNode function of the NodeFactory API.

Arguments:

    pSource - The XMLNodeSource pointer.
    
    pNodeParent - 
    
    cNumRecs - Number of NodeInfo pointers in the array.
    
    aNodeInfo - Array of NodeInfo pointers.

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    XML_NODE_INFO *NodeInfo = NULL;
    PWCHAR Temp = NULL;
    ULONG_PTR LengthInChars = 0; 
    BOOL freeTemp = TRUE, fPassElement = FALSE, fCopyInEnd = FALSE;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    CDavNodeFactory *NodeFac = NULL;
    IXMLParser *Xp = NULL;
    CREATE_NODE_ATTRIBUTES nextCreateNodeAttribute = CreateNode_Max;
    PWCHAR        startTag = NULL;
    ULONG_PTR     tagLength = 0;
    ULONG_PTR     tagOffset = 0;
    USHORT        i;


    Xp = (IXMLParser *)pSource;

    // XmlDavDbgPrint(("%ld: Entered CreateNode. cNumRecs = %d\n", 
    //                     GetCurrentThreadId(), cNumRecs));
    
    hResult = Xp->GetFactory( (IXMLNodeFactory **)&(NodeFac) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: CreateNode/GetFactory.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    for (i = 0; i < cNumRecs; i++) {
        
        NodeInfo = aNodeInfo[i];

        
        // XmlDavDbgPrint(("%ld: CreateNode: NodeInfo->ulLen = %d, prfxLen=%d\n", 
        //                 GetCurrentThreadId(), NodeInfo->ulLen, NodeInfo->ulNsPrefixLen));

        // XmlDavDbgPrint(("%ld: CreateNode: pwcText = %ws\n",
        //                 GetCurrentThreadId(), NodeInfo->pwcText));

        // XmlDavDbgPrint(("%ld: CreateNode: fTerminal = %d\n",
        //                 GetCurrentThreadId(), NodeInfo->fTerminal));


        //
        // The tags can be of types:  "a:response"   or "dp0:response".
        // In these cases NodeInfo->pwcText will point to first character ('a' or 'd')
        // Actual tag in these cases is ":response", so we need to get a pointer to
        // start of Actual-tag, and re-compute the remaining string length.
        //
        // Ex.       lp0:response
        //              ^
        //              |
        //             startTag
        //             tagOffset = NodeInfo->ulNsPrefixLen = 3
        //             NodeInfo->ulLen = 12 (don't account for L'\0')
        //             tagLength = 12 - 3 = 9  = Len(":response") (don't account for L'\0')
        // 
        tagOffset = NodeInfo->ulNsPrefixLen;
        startTag = (PWCHAR)(&(NodeInfo->pwcText[0]) + tagOffset);
        tagLength = NodeInfo->ulLen - tagOffset;
        
        //
        // If startTag == L":response", then we need a new 
        // DavFileAttributes entry. The first eNodeFac->m_CreateNodeAttributentry
        // is allocated by the caller of the parser. 
        // :response is an indication that in (multi status)
        // response that a new entry is going to begin.
        //
        // 
        // Note: use startTag which takes care of namespace prefix.
        // Length = (sizeof(rgCreationDate)/sizeof(WCHAR)) includes L'\0' (null terminator)
        // but NodeInfo->ulLen don't account for NULL terminator in NodeInfo->pwcText. So
        // add 1 to tagLength (to account for L'\0' in startTag) before comparing it
        // to Tags (rgCreationDate).
        //
        fPassElement = FALSE;
        if ( NodeInfo->dwType == XML_ELEMENT) {

            if( (tagLength + 1 == (sizeof(rgResponse)/sizeof(WCHAR))) &&
                        (_wcsicmp(startTag, rgResponse) == 0) ) {
            
                //
                // m_FileIndex = No of entries for which "<a:response...>" is found 
                // in response and memory is allocated for its DAV_FILE_ATTRIBUTES
                // structure. First entry is allocated by caller of this function, and 
                // now "<a:response...>" is detected for this entry in XML response, 
                // so increase m_FileIndex by 1.
                //
                if (NodeFac->m_FileIndex == 0) {
                        NodeFac->m_FileIndex = 1;
                }
                else {
                    //
                    // Since the first DavFileAttributes entry is allocated by the 
                    // caller, we need to allocate only from the second entry.
                    //
                    NodeFac->m_CreateNewEntry = TRUE;
                }
                // 
                // Since this CreateNode call has XML_ELEMENT ":reponse", we are done
                // with this call. Rest of NodeInfo in array contains information about
                // this xml element.
                //
                break; // Out of Loop
            }
        
            if ( ( tagLength + 1 == (sizeof(rgCreationDate)/sizeof(WCHAR)) && 
                                _wcsicmp(startTag, rgCreationDate) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_CreationTime;
            } else if ( ( tagLength + 1 == (sizeof(rgGetContentLength)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgGetContentLength) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_ContentLength;
            } else if ( ( tagLength + 1 == (sizeof(rgGetLastModified)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgGetLastModified) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_LastModifiedTime;
            } else if ( ( tagLength + 1 == (sizeof(rgResourceType)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgResourceType) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_ResourceType;
            } else if ( ( tagLength + 1 == (sizeof(rgIsHidden)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgIsHidden) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_isHidden;
            } else if ( ( tagLength + 1 == (sizeof(rgIsCollection)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgIsCollection) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_isCollection;
            } else if ( ( tagLength + 1 == (sizeof(rgHref)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgHref) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_DisplayName;
            } else if ( ( tagLength + 1 == (sizeof(rgStatus)/sizeof(WCHAR)) &&
                               _wcsicmp(startTag, rgStatus) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Status;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32FileAttributes)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32FileAttributes) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32FileAttributes;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32CreationTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32CreationTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32CreationTime;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32LastAccessTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32LastAccessTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32LastAccessTime;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32LastModifiedTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32LastModifiedTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32LastModifiedTime;
            } else if ( ( tagLength + 1 == (sizeof(rgAvailableSpace)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgAvailableSpace) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_AvailableSpace;
            } else if ( ( tagLength + 1 == (sizeof(rgTotalSpace)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgTotalSpace) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_TotalSpace;
            } else {
                //
                // One CreateNode call can contain only one XML_ELEMENT information
                // and since this element is none of our concerned elements, so
                // we pass this element information downward.
                //
                fPassElement = TRUE;
            }
            
            if(fPassElement == FALSE) {

                // 
                // Control comes here only if we have found an element of our interest.
                //
            
                NodeFac->m_FoundEntry = TRUE;

                //
                // If we have to create a new DavFileAttribute entry, do it now.
                // This entry should be added to the list of this CDavNodeFactory
                // structure.
                //
                if (NodeFac->m_CreateNewEntry) {

                    void *DFA = NULL;
                    
                    DavOverrideAttributes(NodeFac->m_DFAToUse);
                    
                    DFA = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(DAV_FILE_ATTRIBUTES) );
                    if (DFA == NULL) {
                        ULONG WStatus;
                        WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. LocalAlloc. Error Val = %d\n", 
                                        GetCurrentThreadId(), WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    DavFileAttributes = (PDAV_FILE_ATTRIBUTES)DFA;

                    //
                    // m_FileIndex = No of entries for which "<a:response...>" is found 
                    // in response and memory is allocated for its DAV_FILE_ATTRIBUTES
                    // structure. At this point: a new entry is allocated after 
                    // "<a:response...>" is detected in XML response, so increase
                    // m_FileIndex by 1.
                    //
                    NodeFac->m_FileIndex++;

                    //
                    // DavFileAttributes->FileIndex starts from 0, so subtract 1 from total 
                    // number of entries allocated and detected in XML response to get 
                    // FileIndex of that entry.
                    //
                    DavFileAttributes->FileIndex = NodeFac->m_FileIndex - 1;

                    InsertTailList( &(NodeFac->m_DavFileAttributes->NextEntry),
                                    &(DavFileAttributes->NextEntry) );
                
                    NodeFac->m_DFAToUse = DavFileAttributes;

                    NodeFac->m_CreateNewEntry = FALSE;
                
                }

                NodeFac->m_CreateNodeAttribute = nextCreateNodeAttribute;
                //XmlDavDbgPrint(("%ld: CreateNode. m_CreateNodeAttribute=%d\n",
                //                        GetCurrentThreadId(), nextCreateNodeAttribute));
                break; // Out of Loop

            } // fPassElement
        }

        if (NodeFac->m_FoundEntry) {

            if (NodeFac->m_CreateNodeAttribute != CreateNode_DisplayName) {
                
                //
                // The extra 1 is for the final \0 char.
                //
                LengthInChars = NodeInfo->ulLen + 1;
                
                //XmlDavDbgPrint(("%ld: CreateNode. Element=%d DataLen=%d Data=%ws\n",
                //                    GetCurrentThreadId(), NodeFac->m_CreateNodeAttribute,
                //                    NodeInfo->ulLen, NodeInfo->pwcText));

                //
                // Allocate memory for copying the parsed XML response element.
                //
                Temp = (PWCHAR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, 
                                            (LengthInChars) * sizeof(WCHAR) );
                if (Temp == NULL) {
                    DWORD WStatus = GetLastError();
                    XmlDavDbgPrint(("%ld: ERROR: CreateNode. LocalAlloc failed.GLE=%u\n",
                                    GetCurrentThreadId(), WStatus));
                    hResult = CO_E_ERRORINAPP;
                    goto EXIT_THE_FUNCTION;
                }

                //  
                //  Copy the element. 
                //
                wcsncpy(Temp, NodeInfo->pwcText, NodeInfo->ulLen);
                Temp[LengthInChars-1]=L'\0';

                //XmlDavDbgPrint(("%ld: CreateNode. Temp=%ws, LengthInChars=%d\n", 
                //                            GetCurrentThreadId(), Temp, LengthInChars ));

                switch (NodeFac->m_CreateNodeAttribute) {

                    case CreateNode_isHidden: {
                        NodeFac->m_DFAToUse->isHidden = (BOOL)_wtoi(Temp);
                    }
                    break;

                    case CreateNode_isCollection: {
                        NodeFac->m_DFAToUse->isCollection = (BOOL)_wtoi(Temp);
                    }
                    break;

                    case CreateNode_ContentLength: {
                        *((LONGLONG *)&NodeFac->m_DFAToUse->FileSize) = _wtoi64(Temp);
                    }
                    break;

                    case CreateNode_CreationTime: {
                        ULONG WStatus;
                        WStatus = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->DavCreationTime);
                        if (WStatus != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime.\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    }
                    break;

                    case CreateNode_LastModifiedTime: {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->DavLastModifiedTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    }
                    break;

                    case CreateNode_Status: {
                        NodeFac->m_DFAToUse->Status = Temp;
                        //
                        // Don't free Temp now. This allocation will be freed when this
                        // DavFileAttribute entry gets finalized.
                        //
                        freeTemp = FALSE;
                        //
                        // If the status is not 200 then this node is invalid. The Temp
                        // is of the form "HTTP/1.1 200 OK".
                        //
                        if ( wcslen(Temp) >= 12 ) {
                            if ( Temp[9] != L'2' || Temp[10] != L'0' || Temp[11] != L'0' ) {
                                NodeFac->m_DFAToUse->InvalidNode = TRUE;
                            } else{
                                NodeFac->m_DFAToUse->InvalidNode = FALSE;
                            }
                        } else {
                            NodeFac->m_DFAToUse->InvalidNode = TRUE;
                        }
                    }
                    break;

                    case CreateNode_Win32FileAttributes : {
                    DWORD dwFileAttributes = 0;
                        swscanf(Temp, L"%x", &(dwFileAttributes));
                        NodeFac->m_DFAToUse->dwFileAttributes |= dwFileAttributes;
                    }
                    break;

                    case CreateNode_Win32CreationTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->CreationTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;
                    
                    case CreateNode_Win32LastAccessTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->LastAccessTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;
                    
                    case CreateNode_Win32LastModifiedTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->LastModifiedTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;

                    case CreateNode_ResourceType : {
                            //
                            // Since data for tag=":resourceType" comes in form
                            // <d:resourcetype><lp0:collection/></d:resourcetype>, so
                            // here Temp[] = "lp0:collection". Since current NodeInfo is for 
                            // tag=<lp0:collection/>, so use namespace-prefix length i.e. 
                            // tagOffset to get Actual-tag(":collection").
                            // 
                            //XmlDavDbgPrint(("%ld:CreateNode. In resourceType. tagLength=%d, Temp=%ws.\n",
                            //                    GetCurrentThreadId(), tagLength, Temp));

                            if((wcslen(L":collection") <= tagLength) && 
                                    (_wcsnicmp(&(Temp[tagOffset]),L":collection",
                                                            wcslen(L":collection")) == 0) )
                                NodeFac->m_DFAToUse->isCollection = TRUE;
                    }
                    break;

                    case CreateNode_AvailableSpace :
                    {
                        NodeFac->m_DFAToUse->fReportsAvailableSpace = TRUE;

                        *((LONGLONG *)&NodeFac->m_DFAToUse->AvailableSpace) = _wtoi64(Temp);
                    }
                    break;
                    case CreateNode_TotalSpace :
                    {
                        *((LONGLONG *)&NodeFac->m_DFAToUse->TotalSpace) = _wtoi64(Temp);
                    
                    }
                    default: {
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. CreateAttribute is wrong.\n",
                                        GetCurrentThreadId()));
                    }
                    break;  // Out of switch
                };

                //
                // The information in this CreateNode is extracted. 
                // So we can quit this function now. After this, EndChildren should be
                // called. Since we do not expect more PCDATA to come for current ELEMENT
                // set NodeFac->m_FoundEntry to FALSE - so that our current information 
                // in NodeInfo->m_DFAToUse is not overwritten by following calls of
                // CreateNode for same XML_ELEMENT.
                //

                NodeFac->m_FoundEntry = FALSE;
                break; // Out of Loop

            } else {

                //
                // NodeFac->m_CreateNodeAttribute = CreateNode_DisplayName. Since 
                // DisplayName can span many consecutive CreateNode calls, each call
                // bring part of display name. So here we collect the parts of 
                // displayname coming in each CreateNode call and join them to form
                // complete name. 
                // After all parts are called, this EndChildren will be called. There
                // we process the name to get the actual display name.
                // 

                PDAV_FILE_ATTRIBUTES    CurrentDFA = NodeFac->m_DFAToUse;
                BOOL  fReAlloc = FALSE;
                DWORD TotalNameLength = NodeInfo->ulLen + 1; // 1 is for ending NULL=L'\0'.
                PWCHAR newFileName = NULL;
                BOOL fCopyInEnd = FALSE;
                DWORD AllocLength = 0;

                //XmlDavDbgPrint(("%ld: CreateNode. InDisplayName FileNameLength=%d FileName=%ws\n", 
                //                    GetCurrentThreadId(), CurrentDFA->FileNameLength, 
                //                    CurrentDFA->FileName?CurrentDFA->FileName : L"NULL"));
                                        
                if (NodeInfo->ulLen == 0) {
                    XmlDavDbgPrint(("%ld: ERROR: CreateNode. Displayname value is NULL, NodeInfo->ulLen = 0\n",
                                    GetCurrentThreadId()));
                    hResult = CO_E_ERRORINAPP;
                    goto EXIT_THE_FUNCTION;
                }

                //
                // If currentDFA has FileName = NULL, then this CreateNode call brings
                // first part of DisplayName. Allocate memory for holding this part.
                // 
                // If CurrentDFA->FileName != NULL, then current CreateNode call has 
                // next-part of the displayname. Check if the buffer allocated for 
                // old-parts is enough to contain new part also. If it is, then 
                // copy new part in the end else allocate new buffer. Copy old-parts
                // to new buffer and then copy new-part in the end of this buffer.
                //
                if ( CurrentDFA->FileName != NULL) {
                    TotalNameLength += CurrentDFA->FileNameLength;
                    //XmlDavDbgPrint(("%ld: CreateNode. ReqLen=%d PresentLen=%d\n",
                    //                    GetCurrentThreadId(), TotalNameLength,
                    //               LocalSize((HLOCAL)CurrentDFA->FileName)/sizeof(WCHAR)));
                    if(TotalNameLength > LocalSize((HLOCAL)CurrentDFA->FileName)/sizeof(WCHAR)) {
                        //
                        // Buffer allocated for old-parts is not long enough to
                        // contain new part also. Have to Reallocate new buffer.
                        //
                        fReAlloc = TRUE;
                    } else {
                        //
                        // Buffer allocated for old-parts is long enough to
                        // contain new part also. Copy new-part in the end.
                        //
                        fCopyInEnd = TRUE;
                        fReAlloc = FALSE;
                    }
                } else {
                    fReAlloc = FALSE;
                }


                if (fReAlloc == TRUE) {
                    //
                    // Allocate maximum of {256 , TotalNameLength}. We want to 
                    // allocate more first time to save possibility of re-allocation.
                    // 
                    AllocLength = TotalNameLength > 256 ? TotalNameLength : 256 ;
                    //XmlDavDbgPrint(("%ld: CreateNode. AllocLen=%d\n",
                    //                                GetCurrentThreadId(), AllocLength));
                    newFileName = (PWCHAR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,  
                                                        AllocLength*sizeof(WCHAR));
                    if(newFileName == NULL) {
                        DWORD WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. ReAllocLen = %d. LocalAlloc failed. GLE=%u\n",
                                        GetCurrentThreadId(), AllocLength, WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    //  
                    //  Copy the old-parts in the new buffer.
                    //
                    wcsncpy(newFileName,CurrentDFA->FileName, CurrentDFA->FileNameLength);

                    // 
                    // Free buffer allocated for old-parts and point it to new
                    // buffer allocated here.
                    //
                    if(CurrentDFA->FileName) {
                        LocalFree((HLOCAL)CurrentDFA->FileName);
                        CurrentDFA->FileName = NULL;
                    }
                    CurrentDFA->FileName = newFileName;

                    fReAlloc = FALSE;

                    // 
                    // New buffer is allocated with enough length to contain old-parts
                    // with new part. old-parts are copied to the buffer, copy new
                    // part in the end.
                    //
                    fCopyInEnd = TRUE;
                } 
                
                if (fCopyInEnd == FALSE) {
                    
                    //
                    // Allocate maximum of {128 , TotalNameLength}. We want to 
                    // allocate more first time to save possibility of re-allocation.
                    // 
                        
                    AllocLength = TotalNameLength > 128 ? TotalNameLength : 128;
                    //XmlDavDbgPrint(("%ld: CreateNode. AllocLen=%d\n",
                    //                        GetCurrentThreadId(), AllocLength));
                    newFileName = (PWCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                                        AllocLength*sizeof(WCHAR));
                    if(newFileName == NULL) {
                        DWORD WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. AllocLen = %d LocalAlloc failed. GLE=%u\n",
                                        GetCurrentThreadId(), AllocLength, WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    //  
                    //  Copy the element. 
                    //
                    wcsncpy(newFileName, NodeInfo->pwcText, NodeInfo->ulLen);

                    newFileName[TotalNameLength - 1] = L'\0';
                    CurrentDFA->FileName = newFileName;
                    CurrentDFA->FileNameLength = NodeInfo->ulLen;
                } 

                if (fCopyInEnd == TRUE) {
                    //  
                    //  Copy the element in the end of the already allocated buffer.
                    //
                    wcsncpy(&(CurrentDFA->FileName[CurrentDFA->FileNameLength]),
                                    NodeInfo->pwcText, NodeInfo->ulLen);
                    
                    CurrentDFA->FileName[TotalNameLength - 1] = L'\0';
                    CurrentDFA->FileNameLength = TotalNameLength - 1;
                    fCopyInEnd = FALSE;
                }


                // 
                // We have updated the DisplayName data in current DFA. Now following
                // calls of CreateNode may contain more data for this field and same
                // XML_ELEMENT.
                // This will continue until EndChildren call is made - where
                // data will be processed to generate filename and NodeFac->m_FoundEntry
                // will be set FALSE.
                // so we quit here WITHOUT setting NodeFac->m_FoundEntry to FALSE.
                // 

                //XmlDavDbgPrint(("%ld. CreateNode. FileName=%ws, FileNameLength=%d\n", 
                //                         GetCurrentThreadId(), CurrentDFA->FileName, 
                //                         CurrentDFA->FileNameLength));
                break; // Out of Loop
            }
        }

    } // end of for loop. 
    

EXIT_THE_FUNCTION:

    // XmlDavDbgPrint(("%ld: CreateNode. Leaving!!!\n", GetCurrentThreadId()));

    if (Temp && freeTemp) {
        LocalFree(Temp);
        Temp = NULL;
    }

    return hResult;
}


ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    )
/*++

Routine Description:

    This routine pushes the XML (response) data received from the server to the
    parser.

Arguments:

    DataBuff - The data to be sent to the parser.
    
    Context1 - The address of the CDavNodefactory object. This gets created
               during the first call to this function. 
    
    Context2 - The address of the IXMLParser. This gets created during the 
               first call to this function. 
    
    NumOfBytes - Number of bytes being sent.
    
    isLast - Is this the last buffer being sent.
        
Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HRESULT hResult;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)*Context1;
    IXMLParser *Xp = (IXMLParser *)*Context2;

    //
    // If this is the first call to push data, we need to associate a 
    // CDavNodeFactory and an XMLParser with it.
    //
    if (NodeFac == NULL) {
        
        NodeFac = new CDavNodeFactory();
        if (NodeFac == NULL) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData/new()\n", GetCurrentThreadId()));
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }

        NodeFac->AddRef();
        *Context1 = (PVOID)NodeFac;

        hResult = CoCreateInstance(CLSID_XMLParser,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IXMLParser,
                                   (void **)&Xp);
        
        if (!SUCCEEDED(hResult)) {
            
            if (hResult == CO_E_NOTINITIALIZED) {
                
                //
                // If hResult == CO_E_NOTINITIALIZED, it implies that COM has
                // not been initialized for this thread. In this case, we call
                // CoInitializeEx again.
                //
                hResult = CoInitializeEx(NULL, COINIT_MULTITHREADED);
                if (!SUCCEEDED(hResult)) {
                    XmlDavDbgPrint(("%ld: ERROR: DavPushData/CoInitializeEx: "
                                    "hResult = %08lx\n", 
                                    GetCurrentThreadId(), hResult));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Call CoCreateInstance again. We should succeed this time.
                //
                hResult = CoCreateInstance(CLSID_XMLParser,
                                           NULL,
                                           CLSCTX_INPROC_SERVER,
                                           IID_IXMLParser,
                                           (void **)&Xp);
            
            }
            
            if (!SUCCEEDED(hResult)) {
                XmlDavDbgPrint(("%ld: ERROR: DavPushData/CoCreateInstance: %08lx\n",
                                GetCurrentThreadId(), hResult));
                Xp = NULL;
                goto EXIT_THE_FUNCTION;
            }
        
        }

        *Context2 = (PVOID)Xp;

        hResult = Xp->SetFactory(NodeFac);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData: SetFactory.\n", GetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }
    
    }

    hResult = Xp->PushData(DataBuff, NumOfBytes, isLast);
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: DavPushData: PushData.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    return WStatus;

EXIT_THE_FUNCTION:

    //
    // Ok, we failed.
    //

    DavCloseContext(*Context1, *Context2);

    //
    // If the WStatus was not sent, then set it to ERROR_INVALID_PARAMETER.
    //
    if (WStatus == ERROR_SUCCESS) {
        WStatus = ERROR_INVALID_PARAMETER;
    }
    
    return WStatus;
}


ULONG
DavParseData(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries
    )
/*++

Routine Description:

    This routine calls the Run function (of the IXMLParser) to parse the XML 
    data that has been sent to the parser.

Arguments:

    DavFileAttributes - The structre wherein the parsed file attributes will
                        be stored.

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 
    
    NumOfFileEntries - Number of dav file attribute entries created during 
                       parsing.

Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    IXMLParser *Xp = (IXMLParser *)Context2;
    HRESULT hResult;

    //
    // We enclose the parsing code in a try/except just in case some random
    // server response completely screws us. In such a case, we catch the 
    // exception here and return ERROR_INVALID_PARAMETER to the caller. This
    // is also here to catch the STACK_OVERFLOW exception that can be thrown
    // under low memory conditions.
    //

    __try {

        NodeFac->m_DavFileAttributes = DavFileAttributes;

        NodeFac->m_DFAToUse = DavFileAttributes;

        // 
        // m_FileIndex = No of entries for which "<a:response...>" is found in
        // XML response and memory is allocated for its DAV_FILE_ATTRIBUTES
        // structure. Right now - first entry is allocated by caller of this
        // function but no "<a:response...>" is detected yet in response - so
        // NodeInfo->m_FileIndex = 0.
        // 

        DavFileAttributes->FileIndex = NodeFac->m_FileIndex = 0;

        //
        // Call Run to parse the XML data sent.
        //
        hResult = Xp->Run(-1);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavParseData/Run: hResult = %08lx\n", 
                            GetCurrentThreadId(), hResult));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to call this function for the last node that got created. This
        // is done becuase the DavOverrideAttributes in the CreateNode function
        // above does not cover the last node.
        //
        DavOverrideAttributes(NodeFac->m_DFAToUse);
   
        *NumOfFileEntries = NodeFac->m_FileIndex;

    } __except (1) {

          XmlDavDbgPrint(("%ld: ERROR: DavParseData: ExceptionCode = %d\n", 
                          GetCurrentThreadId(), GetExceptionCode()));

          goto EXIT_THE_FUNCTION;

    }

    return WStatus;

EXIT_THE_FUNCTION:

    DavCloseContext(Context1, Context2);

    WStatus = ERROR_INVALID_PARAMETER;
    
    return WStatus;
}


ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    )
/*++

Routine Description:

    This routine calls the Run function (of the IXMLParser) to parse the XML 
    data that has been sent to the parser. In addition to calling DavParseData(...)
    it returns the pointer to parent DAV collection resource being returned in XML response.

Arguments:

    DavFileAttributes - The structre wherein the parsed file attributes will
                        be stored.

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 
    
    NumOfFileEntries - Number of dav file attribute entries created during 
                       parsing.
    
    pCollectionDFA - This pointer will set to DavFileAttribute that corresponds to 
                    the DAV resource which has smallest Full-DisplayName (that comes in
                    "<a:href>Full-DisplayName</a:href>") in the response. If
                    XML response contains the properties of the parent DAV collection then
                    its entry should be the entry with smallest Full-DisplayName.

Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    
    if (pCollectionDFA != NULL) {
        *pCollectionDFA = NULL;
    }
    
    //
    // Call DavParseData(...) to parse the XML data sent.
    //
    WStatus = DavParseData(DavFileAttributes, Context1, Context2, NumOfFileEntries);
    if (WStatus != ERROR_SUCCESS) {
        XmlDavDbgPrint(("%ld: ERROR: DavParseDataEx/Run: WStatus = %08lx\n", 
                        GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Store location of DAV collection DFA in pCollectionDFA.
    // 
    if(pCollectionDFA != NULL) {
        *pCollectionDFA = NodeFac->m_CollectionDFA;
    }

    return WStatus;

EXIT_THE_FUNCTION:

    return WStatus;
}


VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    )
/*++

Routine Description:

    This routine closes the XML parser and the CDavNodeFactory object.

Arguments:

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 

Return Value:

    none.

--*/
{
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    IXMLParser *Xp = (IXMLParser *)Context2;

    if (NodeFac != NULL) {
        NodeFac->Release();
    }

    if (Xp != NULL) {
        Xp->Release();
    }

    return;
}


VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    BOOL fFreeHeadDFA
    )
/*++

Routine Description:

    This routine finalizes (frees) a DavFileAttributes list.

Arguments:

    DavFileAttributes - The DavFileAttributes list to be finalized.

Return Value:

    none.

--*/
{
    PDAV_FILE_ATTRIBUTES TempDFA;
    PLIST_ENTRY listEntry, backEntry;

    //
    // If there is nothing to finalize then we return.
    //
    if (DavFileAttributes == NULL) {
        return;
    }

    TempDFA = DavFileAttributes;

    listEntry = TempDFA->NextEntry.Flink;

    //
    // Travel the list and free the resources allocated.
    //
    while ((listEntry != NULL) &&  (listEntry != &(DavFileAttributes->NextEntry)) ) {

        TempDFA = CONTAINING_RECORD(listEntry,
                                    DAV_FILE_ATTRIBUTES,
                                    NextEntry);

        backEntry = listEntry;

        listEntry = listEntry->Flink;

        RemoveEntryList(backEntry);

        //
        // Free the Status string that was allocated while parsing.
        //
        if (TempDFA->Status) {
            LocalFree((HLOCAL)TempDFA->Status);
            TempDFA->Status = NULL;
        }

        //
        // Free the filename that was allocated while parsing.
        //
        if (TempDFA->FileName) {
            LocalFree((HLOCAL)TempDFA->FileName);
            TempDFA->FileName = NULL;
        }

        //
        // Free the DavFileAttributes entry.
        //
        LocalFree((HLOCAL)TempDFA);
        TempDFA = NULL;
    }

    //
    // Need to free the first entry.
    //
    
    if (DavFileAttributes->Status) {
        LocalFree((HLOCAL)DavFileAttributes->Status);
        DavFileAttributes->Status = NULL;
    }

    if (DavFileAttributes->FileName) {
        LocalFree((HLOCAL)DavFileAttributes->FileName);
        DavFileAttributes->FileName = NULL;
    }

    if(fFreeHeadDFA == TRUE) {
        LocalFree((HLOCAL)DavFileAttributes);
        DavFileAttributes = NULL;
    }
    
    return;
}


DWORD
DavInternetTimeToFileTime(
    PWCHAR lpTimeString,
    FILETIME *lpft
    )
{
    SYSTEMTIME  sSystemTime;
    DWORD   dwError = ERROR_SUCCESS;
        
    if (!InternetTimeToSystemTimeW(lpTimeString, &sSystemTime, 0))
    {
        
        dwError =  GetLastError();
        if (dwError == ERROR_INVALID_PARAMETER)
        {
            dwError = DavParsedateTimetzTimeString(lpTimeString, (PLARGE_INTEGER)lpft);
        }
    }
    else
    {
        SystemTimeToFileTime(&sSystemTime, lpft);
    }
    
    return dwError;
}

ULONG
DavParsedateTimetzTimeString(
    PWCHAR TimeString,
    LARGE_INTEGER *lpFileTime
    )
/*++

Routine Description:

    This routine parses a string in the dateTime.tz time format. It then sets 
    the last modified time attribute in the file attributes structure of the 
    node factory object.  

Arguments:

    TimeString - The string that needs to be parsed.

    lpFileTime - Time to get    

Return Value:

    ERROR_SUCESS or the appropriate Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR Head = NULL, Cp = NULL, Tail = NULL;
    TIME_FIELDS TimeFields;
    BOOL ReturnVal = FALSE;
    DWORD TimeStrLen = 0;
    WCHAR EndCharSet[]=L".+-zZ";
    WCHAR OffsetCharSet[]=L"+-zZ";
    WCHAR LastChar;

    ZeroMemory(&TimeFields, sizeof(TIME_FIELDS));

    //
    // Head->1999-03-17T00:46:24.557Z
    //                               ^
    //                               |
    //                               Tail
    //
    Head = TimeString;
    Tail = (PWCHAR)(Head + wcslen(Head));

    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: TimeString = %ws.\n", 
    //                 GetCurrentThreadId(), TimeString));

    //
    // The string can be of the format "1999-03-17T00:46:24.557Z"
    // The string can be of the format "1999-03-17T00:46:24Z"
    // The string can be of the format "1999-03-17T00:46:24.557+12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24.557-12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24+12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24-12:02" - Ignored for now
    //

    //
    // Head->1999-03-17T00:46:24.557Z
    //           ^
    //           |
    //           Cp
    //
    Cp = Head + 4;

    //
    // Head->"1999"03-17T00:46:24.557Z -- Head now points to the year.
    //            ^
    //            |
    //            Cp
    //
    
    if ((Cp > Tail) || (Cp[0] != L'-')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Year = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Year = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Year));

    //
    // Head->03-17T00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->03-17T00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"03"17T00:46:24.557Z -- Head now points to the month.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L'-')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Month = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Month = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Month));

    //
    // Head->17T00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->17T00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"17"00:46:24.557Z -- Head now points to the day.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L'T')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Day = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Day = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Day));

    //
    // Head->00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"00"46:24.557Z -- Head now points to the hour.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L':')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Hour = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Hour = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Hour));

    //
    // Head->46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"46"24.557Z -- Head now points to the minute.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L':')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Minute = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Minute = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Minute));

    //
    // Head->24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"24"557Z -- Head now points to the second.
    //          ^
    //          |
    //          Cp = {.,z,Z,+,-}
    //
    if ((Cp > Tail) || (wcspbrk(Cp,EndCharSet) != Cp)) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Second = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Seconds = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Second));


    if(LastChar == L'.') {
        //
        // Head->557Z
        //       ^
        //       |
        //       Cp
        //
        Cp++;
        Head = Cp;
        while(Cp < Tail && Cp[0] >= L'0' && Cp[0] <= L'9')
           Cp++;
        if(Cp == Head || wcspbrk(Cp,OffsetCharSet) != Cp) {
           goto bailout;
        }
        //
        // Head->"557" -- Head now points to the Milliseconds.
        //           ^
        //           |
        //           Cp = {z,Z,+,-}
        //
        LastChar = Cp[0];
        Cp[0] = L'\0';
        TimeFields.Milliseconds = (short)_wtoi(Head);
        // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Milliseconds = %d.\n", 
        //                 GetCurrentThreadId(), TimeFields.Milliseconds));
    }

    //
    // Head->"+DD:DD" or "-DD:DD" or "Z" or "z".
    //        ^
    //        |
    //        Cp = {z,Z,+,-}
    //
    if(LastChar == L'+' || LastChar == L'-') {
        //
        // Head->"+DD:DD" or "-DD:DD" -- Head now points to the Milliseconds.
        //        ^
        //        |
        //        Cp = {+,-}
        //
        // BUGBUG - Ignoring time zone adjustment settings for now
        //
    }


    //
    // We have set the time fields structure. Now its time to get the time 
    // value as a LARGE_INTEGER and store it in DavFileAttributes. The time
    // we need to set could either be the creation time or the last modified 
    // time.
    //
    ReturnVal = RtlTimeFieldsToTime(&TimeFields, lpFileTime);
bailout:    
    if (!ReturnVal) {
        XmlDavDbgPrint(("%ld: ERROR: DavParsedateTimetzTimeString/RtlTimeFieldsToTime.\n",
                        GetCurrentThreadId()));
        WStatus = ERROR_INVALID_PARAMETER;
     }

    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: LastModifiedTime = %d, %d.\n",
    //                 GetCurrentThreadId(),
    //                 DavFileAttributes->CreationTime.HighPart,
    //                 DavFileAttributes->CreationTime.LowPart));

    return WStatus;
}


#if 0
ULONG
DavParseRfc1123TimeString(
    PWCHAR TimeString,
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    CREATE_NODE_ATTRIBUTES CreateNodeAttribute
    )
/*++

Routine Description:

    This routine parses a string in the RFC 1123 time format. It then sets the 
    last modified time attribute in the file attributes structure of the 
    node factory object.  

Arguments:

    TimeString - The string that needs to be parsed.
    
    DavFileAttributes - The Dav File attributes structure which contains the
                        Time Value to be set.
    
    CreateNodeAttribute - Could be either CreateNode_CreationTime_rfc1123 or
                          CreateNode_LastModifiedTime_rfc1123.                        

Return Value:

    ERROR_SUCESS or the appropriate Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR Head, Cp;
    TIME_FIELDS TimeFields;
    BOOL ReturnVal;

    Head = TimeString;

    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: TimeString = %ws.\n", 
    //                 GetCurrentThreadId(), TimeString));


    //
    // The string is of the format "Tue, 06 Apr 1999 00:10:40\nGMT"
    //

    //
    // Head->Tue, 06 Apr 1999 00:10:40\nGMT
    //          ^
    //          |
    //          Cp
    //
    Cp = wcschr(Head, L',');

    //
    // Head->"Tue" 06 Apr 1999 00:10:40\nGMT -- Head points to weekday string.
    //           ^
    //           |
    //           Cp
    //
    *Cp = L'\0';

    if ( _wcsicmp(Head, L"Sun") == 0 ) {
        TimeFields.Weekday = 0;
    } else if( _wcsicmp(Head, L"Mon") == 0 ) {
        TimeFields.Weekday = 1;
    } else if( _wcsicmp(Head, L"Tue") == 0 ) {
        TimeFields.Weekday = 2;
    } else if( _wcsicmp(Head, L"Wed") == 0 ) {
        TimeFields.Weekday = 3;
    } else if( _wcsicmp(Head, L"Thu") == 0 ) {
        TimeFields.Weekday = 4;
    } else if( _wcsicmp(Head, L"Fri") == 0 ) {
        TimeFields.Weekday = 5;
    } else if( _wcsicmp(Head, L"Sat") == 0 ) {
        TimeFields.Weekday = 6;
    } else {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString: WeekDay = %ws.\n", Head));
        WStatus = ERROR_INVALID_PARAMETER;
        return WStatus;
    }
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: WeekDay = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Weekday));
    
    //
    // Head->06 Apr 1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Cp++;
    Head = Cp;

    //
    // Head->06 Apr 1999 00:10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"06"Apr 1999 00:10:40\nGMT -- Head points to Day string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Day = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Day = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Day));

    //
    // Head->Apr 1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->Apr 1999 00:10:40\nGMT
    //          ^
    //          |
    //          Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"Apr"1999 00:10:40\nGMT -- Head now points ti the month string.
    //           ^
    //           |
    //           Cp
    //
    *Cp = L'\0';

    if ( _wcsicmp(Head, L"Jan") == 0 ) {
        TimeFields.Month = 1;
    } else if( _wcsicmp(Head, L"Feb") == 0 ) {
        TimeFields.Month = 2;
    } else if( _wcsicmp(Head, L"Mar") == 0 ) {
        TimeFields.Month = 3;
    } else if( _wcsicmp(Head, L"Apr") == 0 ) {
        TimeFields.Month = 4;
    } else if( _wcsicmp(Head, L"May") == 0 ) {
        TimeFields.Month = 5;
    } else if( _wcsicmp(Head, L"Jun") == 0 ) {
        TimeFields.Month = 6;
    } else if( _wcsicmp(Head, L"Jul") == 0 ) {
        TimeFields.Month = 7;
    } else if( _wcsicmp(Head, L"Aug") == 0 ) {
        TimeFields.Month = 8;
    } else if( _wcsicmp(Head, L"Sep") == 0 ) {
        TimeFields.Month = 9;
    } else if( _wcsicmp(Head, L"Oct") == 0 ) {
        TimeFields.Month = 10;
    } else if( _wcsicmp(Head, L"Nov") == 0 ) {
        TimeFields.Month = 11;
    } else if( _wcsicmp(Head, L"Dec") == 0 ) {
        TimeFields.Month = 12;
    } else {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString: Month = %ws.\n", Head));
        WStatus = ERROR_INVALID_PARAMETER;
        return WStatus;
    }
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Month = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Month));

    //
    // Head->1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->1999 00:10:40\nGMT
    //           ^
    //           |
    //           Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"1999"00:10:40\nGMT -- Head now points to the year string.
    //            ^
    //            |
    //            Cp
    //
    *Cp = L'\0';

    TimeFields.Year = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Year = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Year));

    //
    // Head->00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->00:10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L':');

    //
    // Head->"00"10:40\nGMT -- Head now points to the hour string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Hour = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Hour = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Hour));

    //
    // Head->10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L':');

    //
    // Head->"10"40\nGMT -- Head now points to the minute string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Minute = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Minute = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Minute));

    //
    // Head->40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"40"GMT -- Head now points to the seconds string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Second = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Second = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Second));

    //
    // Since we don't know the millisec value, we set it to zero.
    //
    TimeFields.Milliseconds = 0;
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: MilliSec = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Milliseconds));

    //
    // We have set the time fields structure. Now its time to get the time 
    // value as a LARGE_INTEGER and store it in DavFileAttributes. The time
    // we need to set could either be the creation time or the last modified 
    // time.
    //
    if (CreateNodeAttribute == CreateNode_LastModifiedTime_rfc1123) {
        ReturnVal = RtlTimeFieldsToTime(&(TimeFields), 
                                        &(DavFileAttributes->LastModifiedTime));
    } else {
        ReturnVal = RtlTimeFieldsToTime(&(TimeFields), 
                                        &(DavFileAttributes->CreationTime));
    }
    
    if (!ReturnVal) {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString/RtlTimeFieldsToTime.\n"));
        WStatus = ERROR_INVALID_PARAMETER;
     }

    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: LastModifiedTime = %d, %d.\n",
    //                 GetCurrentThreadId(),
    //                 DavFileAttributes->LastModifiedTime.HighPart,
    //                 DavFileAttributes->LastModifiedTime.LowPart));

    return WStatus;
}

#endif

VOID
DavOverrideAttributes(
    PDAV_FILE_ATTRIBUTES pDavFileAttributes
    )
/*++

Routine Description:

    If win32 timestamps are not set, then set them with DAV timestamps

Arguments:

    DavFileAttributes - The Dav File attributes structure which contains the
                        Time Values
    

Return Value:

    None

--*/
{
    if (!pDavFileAttributes->CreationTime.HighPart)
    {
        pDavFileAttributes->CreationTime = pDavFileAttributes->DavCreationTime;
    }
    if (!pDavFileAttributes->LastModifiedTime.HighPart)
    {
        pDavFileAttributes->LastModifiedTime = pDavFileAttributes->DavLastModifiedTime;
    }
    if (pDavFileAttributes->isCollection)
    {
        pDavFileAttributes->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
    }
    else
    {
        pDavFileAttributes->dwFileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
    
    }
    if (!(pDavFileAttributes->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
    {
        if (pDavFileAttributes->isHidden)
        {
            pDavFileAttributes->dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }
        else
        {
            pDavFileAttributes->dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }    
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\midluser.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    
    25-Apr-1991    JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    
    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.
    
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

    10-Feb-1993     RitaW
        Copied to the NetWare tree so that the LPC transport can used for
        the local case.

--*/

#include <nt.h>
#include <ntrtl.h>              // needed for nturtl.h
#include <nturtl.h>             // needed for windows.h
#include <windows.h>            // win32 typedefs
#include <rpc.h>                // rpc prototypes

#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <winbase.h>            // LocalAlloc

PVOID
MIDL_user_allocate (
    IN unsigned int NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    LPVOID NewPointer;

    NewPointer = (LPVOID) LocalAlloc(
                              LMEM_ZEROINIT,
                              NumBytes
                              );

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree((HLOCAL) MemPointer);

} // MIDL_user_free

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN unsigned long NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.


    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = (LPVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  NewByteCount
                                  );

    } else if (NewByteCount == 0) {

        (void) LocalFree((HLOCAL) OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = (PVOID) LocalReAlloc(
                              hOldMem,               // old handle
                              NewByteCount,          // new size in bytes
                              LMEM_ZEROINIT |        // flags
                                  LMEM_MOVEABLE      //  (motion okay)
                              );

        if (hNewMem == NULL) {
            return (NULL);
        }

        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


ULONG_PTR
MIDL_user_size(
    IN void * Pointer
    )
{
    ULONG_PTR ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\nodefac.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nodefac.h
    
Abstract:

    This module defines the CDavnodefactory class, which implements the 
    NodeFactory API, used to parse XML. It also exports the wrapper functions
    that the C code uses to parse XML data. We need wrapper functions around the
    C++ API.

Author:

    Rohan Kumar      [RohanK]      14-Sept-1999

Revision History:

--*/

#ifndef _NODE_FACTORY_
#define _NODE_FACTORY_

#include <stdio.h>
#include <windows.h>

#ifdef __cplusplus

#include <objbase.h>
#include "xmlparser.h"

#if DBG
#define XmlDavDbgPrint(_x_) DbgPrint _x_
#else
#define XmlDavDbgPrint(_x_)
#endif

typedef enum _CREATE_NODE_ATTRIBUTES {
    CreateNode_isHidden = 0,
    CreateNode_isCollection,
    CreateNode_ContentLength,
    CreateNode_CreationTime,
    CreateNode_DisplayName,
    CreateNode_LastModifiedTime,
    CreateNode_Status,
    CreateNode_Win32FileAttributes,
    CreateNode_Win32CreationTime,
    CreateNode_Win32LastAccessTime,
    CreateNode_Win32LastModifiedTime,
    CreateNode_ResourceType,
    CreateNode_AvailableSpace,
    CreateNode_TotalSpace,
    CreateNode_Max
} CREATE_NODE_ATTRIBUTES;

//
// IMPORTANT!!! The next two typedefs have been copied from standard files. 
// This was done because including the standard header files was causing many 
// compilation errors. This should be changed at some point.
//
typedef short CSHORT;
typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS, *PTIME_FIELDS;

//
// Copied from a standard header file. Must be fixed.
//

#define InsertTailList(ListHead, Entry) { \
    PLIST_ENTRY _EX_Blink;                \
    PLIST_ENTRY _EX_ListHead;             \
    _EX_ListHead = (ListHead);            \
    _EX_Blink = _EX_ListHead->Blink;      \
    (Entry)->Flink = _EX_ListHead;        \
    (Entry)->Blink = _EX_Blink;           \
    _EX_Blink->Flink = (Entry);           \
    _EX_ListHead->Blink = (Entry);        \
}

#define RemoveEntryList(Entry) {          \
    PLIST_ENTRY _EX_Blink;                \
    PLIST_ENTRY _EX_Flink;                \
    _EX_Flink = (Entry)->Flink;           \
    _EX_Blink = (Entry)->Blink;           \
    _EX_Blink->Flink = _EX_Flink;         \
    _EX_Flink->Blink = _EX_Blink;         \
}

//
// The CDavNodeFactory class which implements the NodeFactory API for parsing 
// the XML responses from the DAV server. 
//
class CDavNodeFactory : public IXMLNodeFactory {

public:
        
    ULONG m_ulRefCount;
    PDAV_FILE_ATTRIBUTES m_DavFileAttributes;

    //
    // These are used in the CreateNode function to parse the XML responses.
    //
    BOOL m_FoundEntry, m_CreateNewEntry;
    ULONG m_FileIndex;
    CREATE_NODE_ATTRIBUTES m_CreateNodeAttribute;
    PDAV_FILE_ATTRIBUTES m_DFAToUse;
    PDAV_FILE_ATTRIBUTES m_CollectionDFA;
    DWORD m_MinDisplayNameLength;

    CDavNodeFactory() : m_ulRefCount(0), m_DavFileAttributes(NULL), 
                        m_FoundEntry(FALSE), m_FileIndex(0), m_DFAToUse(NULL), 
                        m_CollectionDFA(NULL), m_MinDisplayNameLength((DWORD)-1),
                        m_CreateNewEntry(FALSE), 
                        m_CreateNodeAttribute(CreateNode_Max)
    {}

    //
    // IUnknown interface methods.
    //
    
    virtual STDMETHODIMP_(ULONG) 
    AddRef(
        VOID
        );
    
    virtual STDMETHODIMP_(ULONG) 
    Release(
        VOID
        );

    virtual STDMETHODIMP 
    QueryInterface(
        REFIID riid, 
        LPVOID *ppvObject
        );

    //
    // IXMLNodeFactory interface methods.
    //
    
    virtual HRESULT STDMETHODCALLTYPE 
    NotifyEvent( 
        IXMLNodeSource __RPC_FAR *pSource,
        XML_NODEFACTORY_EVENT iEvt
        ); 
    
    virtual HRESULT STDMETHODCALLTYPE 
    BeginChildren(
        IXMLNodeSource __RPC_FAR * pSource,
        XML_NODE_INFO __RPC_FAR * pNodeInfo
        );

    virtual HRESULT STDMETHODCALLTYPE 
    EndChildren(
        IXMLNodeSource __RPC_FAR * pSource,
        BOOL fEmptyNode,
        XML_NODE_INFO __RPC_FAR * pNodeInfo
        );
    
    virtual HRESULT STDMETHODCALLTYPE 
    Error( 
        IXMLNodeSource __RPC_FAR *pSource,
        HRESULT hrErrorCode,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo
        );
    
    virtual HRESULT STDMETHODCALLTYPE 
    CreateNode(
        IN IXMLNodeSource __RPC_FAR *pSource,
        IN PVOID pNodeParent,
        IN USHORT cNumRecs,
        IN XML_NODE_INFO __RPC_FAR **aNodeInfo
        );
    
};

extern "C" {

ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    );

ULONG
DavParseData(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    PVOID Context1,
    PVOID Conttext2,
    ULONG *NumOfFileEntries
    );

ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    );

VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    BOOL fFreeHeadDFA
    );

VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    );

//
// IMPORTANT!!! The next prototype has been copied from a standard ".h" file. 
// This was done because including the standard header file was causing many 
// compilation errors. This should be changed at some point.
//
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

ULONG
DbgPrint(
    PSTR Format,
    ...
    );

}

ULONG
DavParsedateTimetzTimeString(
    PWCHAR TimeString,
    PLARGE_INTEGER lpft
    );

ULONG
DavParseRfc1123TimeString(
    PWCHAR TimeString,
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    CREATE_NODE_ATTRIBUTES CreateNodeAttribute
    );

#else

//
// These calls are wrapper routines used by the C code to parse XML using the
// NodeFactory C++ API that we are implementing.
//

ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    );

ULONG
DavParseData(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    PVOID Context1,
    PVOID Conttext2,
    ULONG *NumOfFileEntries
    );

ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    );

VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes, 
    BOOL fFreeHeadDFA
    );

VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    );

#endif // __cplusplus


#endif  // _NODE_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\netroot.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    netroot.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the CreateVNetRoot call.

Author:

    Rohan Kumar      [RohanK]      1-Sept-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"


//
// Mentioned below are the custom OFFICE and TAHOE headers which will be 
// returned in the response to a PROPFIND request.
//
WCHAR *DavTahoeCustomHeader = L"MicrosoftTahoeServer";
WCHAR *DavOfficeCustomHeader = L"MicrosoftOfficeWebServer";

ULONG
DavFsCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles CreateVNetRoot requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR ServerName = NULL, ShareName = NULL, CanName = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, CallBackContextInitialized = FALSE;
    BOOL didICreateUserEntry = FALSE;
    ULONG ServerID = 0;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;
    BOOL UserEntryExists = FALSE;

    //
    // Get the request buffer from the DavWorkItem.
    //
    CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(CreateVNetRootRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ServerName = %ws.\n", ServerName));

    ServerID = CreateVNetRootRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    ShareName = &(CreateVNetRootRequest->ShareName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ShareName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ShareName = %ws.\n", ShareName));

    //
    // If ShareName is a dummy share, we need to remove it right now before we 
    // contact the server.
    //
    DavRemoveDummyShareFromFileName(ShareName);

    DavPrint((DEBUG_MISC,
              "DavFsCreateVNetRoot: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              CreateVNetRootRequest->LogonID.LowPart,
              CreateVNetRootRequest->LogonID.HighPart));

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/DavFsSetTheDavCallBackContext. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Find out whether we already have a "InternetConnect" handle to the
    // server. One could have been created during the CreateSrvCall process.
    // We can check the per user entries hanging off this server to see if an
    // entry for this user exists. If it does, use the InternetConnect handle
    // to do the HttpOpen. Otherwise, create and entry for this user and add it
    // to the list of the per user entries of the server.
    //

    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    UserEntryExists = DavDoesUserEntryExist(ServerName,
                                            ServerID, 
                                            &(CreateVNetRootRequest->LogonID),
                                            &PerUserEntry,
                                            &ServerHashEntry);

    //
    // If the CreateVNetRoot gets cancelled in the kernel after the CreateSrvCall
    // succeeds, then you could get the FinalizeSrvCall go through if the thread
    // that picks up the CreateVNetRoot request gets preempted. This removes the
    // entry from the ServerHashList. We need to check for the value of
    // ServerHashEntry being NULL before proceeding further while Creating the
    // PerUserEntry below. Since this condition can only arise if the operation
    // has been cancelled we return ERROR_CANCELLED. Actually the return value
    // doesn't matter since the kernel request has already been cancelled.
    //
    if (ServerHashEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ServerHashEntry == NULL\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncCreateVNetRoot.ServerHashEntry = ServerHashEntry;

    if (!UserEntryExists) {
        
        //
        // The user entry was not found, so we need to create one.
        //
        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: UserEntryNotFound. Calling InternetConnect\n"));

        PerUserEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PER_USER_ENTRY));
        if (PerUserEntry == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateVNetRoot/LocalAlloc. Error Val = %d.\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Yes, I created this UserEntry. If I fail now, I need to finalize twice.
        // This is because, we don't want to keep this entry if we fail.
        //
        didICreateUserEntry = TRUE;

        //
        // Add the user entry to the per user list of the server.
        //
        InsertHeadList(&(ServerHashEntry->PerUserEntry), &(PerUserEntry->UserEntry));

        //
        // Take a reference on the ServerHashEntry. This ServerHashEntry needs
        // to be valid as long as this PerUserEntry is in use. With the logic
        // of cancellation that has been added to the kernel mode this can no
        // longer be guaranteed by the RDBSS logic. As an example, you can
        // get a FinalizeSrvCall while a usermode thread is creating a NetRoot,
        // because the CreateVNetRoot in the kernel got cancelled since the
        // usermode thread that was handling the CreateVNetRoot call took a
        // long time. You want the ServerHashEntry to hang around till all the
        // PerUserEntries associated with it are in use.
        //
        ServerHashEntry->ServerEntryRefCount++;

        //
        // Back pointer to the Server hash entry.
        //
        PerUserEntry->ServerHashEntry = ServerHashEntry;

        PerUserEntry->UserEntryState = UserEntryInitializing;

        //
        // Set the value of Reference count to 1. This value is decremented 
        // when the finalization of this VNetRoot happens.
        //
        PerUserEntry->UserEntryRefCount = 1;

        //
        // We keep track of the fact that we took a reference on this 
        // PerUserEntry.
        //
        DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;

        //
        // Copy the LogonID.
        //
        PerUserEntry->LogonID.LowPart = CreateVNetRootRequest->LogonID.LowPart;
        PerUserEntry->LogonID.HighPart = CreateVNetRootRequest->LogonID.HighPart;

        //
        // Create a event which has to be manually set to non-signalled state and
        // set it to "not signalled".
        //
        PerUserEntry->UserEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (PerUserEntry->UserEventHandle == NULL) {
            //
            // Set the state of the entry to error in initialization.
            //
            PerUserEntry->UserEntryState = UserEntryInitializationError;
            WStatus = GetLastError();
            PerUserEntry->ErrorStatus = WStatus;
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateVNetRoot/CreateEvent. Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        if (wcslen(DavWorkItem->UserName)) {

            PerUserEntry->UserName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                                (wcslen(DavWorkItem->UserName) + 1) * sizeof(WCHAR));
            if (PerUserEntry->UserName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavFsCreateVNetRoot/LocalAlloc: Error Val = %d\n", 
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            wcscpy(PerUserEntry->UserName,DavWorkItem->UserName);
        
        }

        if (wcslen(DavWorkItem->Password)) {

            UCHAR Seed = PASSWORD_SEED;
            UNICODE_STRING EncodedPassword;

            PerUserEntry->Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                                (wcslen(DavWorkItem->Password) + 1) * sizeof(WCHAR));
            if (PerUserEntry->Password == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavFsCreateVNetRoot/LocalAlloc: Error Val = %d\n", 
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            wcscpy(PerUserEntry->Password,DavWorkItem->Password);
            
            RtlInitUnicodeString(&EncodedPassword,PerUserEntry->Password);
            
            RtlRunEncodeUnicodeString(&Seed, &EncodedPassword);

        }

    } else {

        if ( PerUserEntry->UserName && wcslen(DavWorkItem->UserName) ) {

            if (wcscmp(PerUserEntry->UserName, DavWorkItem->UserName) != 0) {
                
                WStatus = ERROR_SESSION_CREDENTIAL_CONFLICT;
                
                goto EXIT_THE_FUNCTION;
            
            }
        
        }

    }

    //
    // If the user entry did not exist, we would have created one by now.
    //
    ASSERT(PerUserEntry != NULL);
    
    DavWorkItem->AsyncCreateVNetRoot.PerUserEntry = PerUserEntry;

    //
    // We enter the following if under two conditions.
    // 1. If the DavConnHandle is not NULL. This means that some other thread
    //    is either in the process of completing the VNetRoot create or that the
    //    VNetRoot create has already completed and we have a DavConnHandle 
    //    which can be used to issue the Http query. If the handle is in the 
    //    process if being created then we wait since the thread that is 
    //    creating the handle will finally signal when its done.
    // 2. DavConnHandle is NULL, but the UserEntryState is UserEntryInitializing 
    //    and this thread did not create this user entry. This means that some
    //    other thread which created the user entry or which took the created 
    //    user entry in UserEntryAllocated state is in the process of completing 
    //    the VNetRoot create. Once this is done the DavConnHandle will be 
    //    available to issue the Http queries. 
    //
    if ( ( PerUserEntry->DavConnHandle != NULL ||
           ( PerUserEntry->UserEntryState == UserEntryInitializing &&
             didICreateUserEntry == FALSE ) ) ) {

        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->DavConnHandle != NULL\n"));
        
        //
        // If the code comes here, it imples that this thread did not create
        // the PerUserEntry. This is because, if we created the PerUserEntry
        // above, PerUserEntry->DavConnHandle will be NULL and no one would have
        // changed it since we are still holding the CriticalSection lock.
        //
        ASSERT(didICreateUserEntry == FALSE);

        //
        // We need to increment the reference count on the PerUserEntry since
        // this VNetRoot create is for a different share than the one for which
        // a thread is currently creating or has already created the WinInet
        // InternetConnect handle.
        //
        PerUserEntry->UserEntryRefCount++;

        //
        // We keep track of the fact that we took a reference on this 
        // PerUserEntry.
        //
        DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;
        
        //
        // An entry does exist. But, we need to take the next step depending
        // upon the state of this entry.
        //

        //
        // If its initializing, then I need to free the lock and wait on the
        // event.
        //
        if (PerUserEntry->UserEntryState == UserEntryInitializing) {
            
            DWORD WaitStatus;

            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;

            WaitStatus = WaitForSingleObject(PerUserEntry->UserEventHandle, INFINITE);
            if (WaitStatus == WAIT_FAILED) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateVNetRoot/WaitForSingleObject. Error Val = %d.\n",
                           WStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            ASSERT(WaitStatus == WAIT_OBJECT_0);
        
        }

        //
        // We could have left the lock while waiting on an event. If we have,
        // then we need to acquire it back before proceeding further.
        //
        if (!EnCriSec) {
            EnterCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = TRUE;
        }

        if (PerUserEntry->UserEntryState == UserEntryClosing) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: UserEntryClosing.\n"));
            WStatus = ERROR_INVALID_PARAMETER;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        if (PerUserEntry->UserEntryState == UserEntryInitializationError) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: UserEntryInitializationError\n"));
            WStatus = PerUserEntry->ErrorStatus;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);

        //
        // Since its initialized, the DavConnHandle should be OK.
        //
        ASSERT(PerUserEntry->DavConnHandle != NULL);
        DavConnHandle = PerUserEntry->DavConnHandle;

        //
        // And yes, we obviously have to leave the critical section
        // before returning.
        //
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
        
    } else {
        
        //
        // If we come here, it means that the PerUserEntry has been created, but
        // the InternetConnect handle has not. We could have created the user
        // entry above or it could have been created in the Passport Auth code
        // which creates PerUserEnrty to store cookies, but does not do the 
        // InternetConnect.
        //

        if (PerUserEntry->UserEntryState == UserEntryInitializing) {
            
            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->UserEntryState == UserEntryInitializing\n"));
            
            ASSERT(didICreateUserEntry == TRUE);
        
        } else {
            
            //
            // This entry was created to store the Passport cookies and was not
            // created above. We need to add a reference to the PerUserEntry here
            // since this user entry was created in the DavAddEntriesForPassportCookies
            // routine. This reference count will be decremented when the 
            // finalization of this VNetRoot happens.
            //
            PerUserEntry->UserEntryRefCount++;
            
            //
            // We keep track of the fact that we took a reference on this 
            // PerUserEntry.
            //
            DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;

            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->UserEntryState != UserEntryInitializing\n"));
            
            ASSERT(PerUserEntry->UserEntryState == UserEntryAllocated);
            
            PerUserEntry->UserEntryState = UserEntryInitializing;
        
        }

        //
        // We don't need to hold the CriticalSection anymore.
        //
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;

        //
        // Need to set the DavOperation field before submitting the asynchronous
        // request. This is a internet connect operation.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;

        //
        // Create a handle to connect to a HTTP/DAV server.
        //
        DavConnHandle = InternetConnectW(IHandle,
                                         (LPCWSTR)ServerName,
                                         INTERNET_DEFAULT_HTTP_PORT,
                                         NULL,
                                         NULL,
                                         INTERNET_SERVICE_HTTP,
                                         0,
                                         CallBackContext);
        if (DavConnHandle == NULL) {

            WStatus = GetLastError();

            if (WStatus != ERROR_IO_PENDING) {

                //
                // Set the state of the entry to error in initialization.
                //

                EnterCriticalSection( &(HashServerEntryTableLock) );

                PerUserEntry->UserEntryState = UserEntryInitializationError;

                PerUserEntry->ErrorStatus = WStatus;

                SetEvent(PerUserEntry->UserEventHandle);

                LeaveCriticalSection( &(HashServerEntryTableLock) );

                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateVNetRoot/InternetConnect. Error Val = %d\n", WStatus));

            }

            goto EXIT_THE_FUNCTION;

        }

        //
        // Cache the InternetConnect handle in the PerUserEntry struct.
        //
        PerUserEntry->DavConnHandle = DavConnHandle;

        //
        // If we fail after this stage, we can keep the PerUserEntry since the
        // InternetConnect handle has already been stored successfully.
        //
        didICreateUserEntry = FALSE;

    }

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {
            
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        DavAsyncCreateVNetRootCompletion(DavWorkItem);
    
    } else {
        
        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: Returning ERROR_IO_PENDING.\n"));
    
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }

    DavAsyncCreateVNetRootCompletion(DavWorkItem);

#endif
        
    return WStatus;
}


DWORD 
DavAsyncCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the CreateVNetRoot operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE;
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
    PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse = NULL;
    WCHAR DavCustomBuffer[100];
    DAV_FILE_ATTRIBUTES DavFileAttributes;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    CreateVNetRootResponse = &(DavWorkItem->CreateVNetRootResponse);
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRoot/UMReflectorImpersonate. "
                      "Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateVNetRoot/DavAsyncCommonStates. "
                              "Error Val = %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateVNetRoot. AsyncFunction failed. "
                          "Error Val = %d\n", WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    
    if (WStatus != ERROR_SUCCESS) {
        //
        // The PROPFIND request that was sent to the server failed.
        //
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateVNetRoot/DavQueryAndParseResponse. "
                  "WStatus = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We read the value of AcceptOfficeAndTahoeServers from the registry when
    // the WebClient service starts up. If this is set to 0, it means that we
    // should be rejecting OfficeWebServers, Tahoe servers and the shares on
    // these servers even though they speak DAV. We do this since WebFolders
    // needs to claim this name and Shell will only call into WebFolders if the
    // DAV Redir fails. If this value is non-zero, we accept all servers that
    // speak DAV.
    // 
    //
    if (AcceptOfficeAndTahoeServers == 0) {

        //
        // Figure out if this is an OFFICE Web Server share. If it is then the 
        // response will have an entry "MicrosoftOfficeWebServer: ", in the header. 
        // If this is an OFFICE share then we should not claim it since the user 
        // actually intends to use the OFFICE specific features in Shell.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
        OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(OfficeCustomHeaderLength), 
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCreateVNetRoot/HttpQueryInfoW: Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: NOT OFFICE Share\n"));
                CreateVNetRootResponse->isOfficeShare = FALSE;
            }
        } else {
            DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: OFFICE Share\n"));
            CreateVNetRootResponse->isOfficeShare = TRUE;
        }
        
        //
        // Figure out if this is a TAHOE share. If it is then the response will have 
        // an entry "MicrosoftTahoeServer: ", in the header. If this is a TAHOE share 
        // then we should not claim it since the user actually intends to use the
        // TAHOE specific features in Rosebud.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
        TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(TahoeCustomHeaderLength),
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCreateVNetRoot/HttpQueryInfoW: Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: NOT TAHOE Share\n"));
                CreateVNetRootResponse->isTahoeShare = FALSE;
            }
        } else {
            DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: TAHOE Share\n"));
            CreateVNetRootResponse->isTahoeShare = TRUE;
        }

    }

    CreateVNetRootResponse->fAllowsProppatch = TRUE;

#if 0
    WStatus = DavTestProppatch(DavWorkItem,
                               DavWorkItem->AsyncCreateVNetRoot.PerUserEntry->DavConnHandle,
                               DavWorkItem->CreateVNetRootRequest.ShareName)
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavAsyncCreateVNetRoot/DavTestPropatch. WStatus = %d \n", 
                  WStatus));
        if (WStatus == HTTP_STATUS_BAD_METHOD) {
            CreateVNetRootResponse->fAllowsProppatch = FALSE;
        }
        WStatus = STATUS_SUCCESS;
    }
#endif

    WStatus = DavParseXmlResponse(DavOpenHandle, &DavFileAttributes, NULL);
    if (WStatus == ERROR_SUCCESS) {
        CreateVNetRootResponse->fReportsAvailableSpace = DavFileAttributes.fReportsAvailableSpace;
        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
    }

EXIT_THE_FUNCTION:

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRoot/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the DavAsyncCreateVNetRootCompletion routine.
        //
        DavAsyncCreateVNetRootCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It 
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncCreateVNetRootCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the CreateVNetRoot completion. It basically frees up the 
   resources allocated during the operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRootCompletion/InternetCloseHandle. Error Val "
                      "= %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRootCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // If we did not succeed, then we need to finalize this PerUserEntry. Also,
    // we only do this if we took a reference on this in the first place.
    //
    if (DavWorkItem->Status != STATUS_SUCCESS) {
        if ( (DavWorkItem->AsyncCreateVNetRoot.PerUserEntry) &&
             (DavWorkItem->AsyncCreateVNetRoot.didITakeReference) ) {
            DavFinalizePerUserEntry( &(DavWorkItem->AsyncCreateVNetRoot.PerUserEntry) );
        }
    }

    return;
}


ULONG
DavFsFinalizeVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles FinalizeVNetRoot requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PWCHAR ServerName = NULL;
    BOOL ReturnVal = FALSE;

    DavFinalizeVNetRootRequest = &(DavWorkItem->FinalizeVNetRootRequest);

    ServerName = DavFinalizeVNetRootRequest->ServerName;

    //
    // If the server name is NULL, return.
    //
    if (ServerName == NULL) {
        DavPrint((DEBUG_ERRORS, "DavFsFinalizeVNetRoot: ServerName == NULL\n"));
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavFsFinalizeVNetRoot: ServerName: %ws.\n", ServerName));

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeVNetRoot: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              DavFinalizeVNetRootRequest->LogonID.LowPart,
              DavFinalizeVNetRootRequest->LogonID.HighPart));
    
    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    
    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      DavFinalizeVNetRootRequest->ServerID,
                                      &(DavFinalizeVNetRootRequest->LogonID),
                                      &(PerUserEntry),
                                      &(ServerHashEntry));

    //
    // Since we are finalizing the PerUserEntry, its important that this entry
    // exists. This means that the following ASSERTs are TRUE. This is because
    // till a VNetRoot for this server exists for this user in the kernel, we
    // keep the PerUserEntry alive.
    //

    ASSERT(ReturnVal == TRUE);
    ASSERT(ServerHashEntry != NULL);
    ASSERT(PerUserEntry != NULL);
    
    //
    // Finalize the PerUserEntry. The function below will free the PerUserEntry
    // if the reference count goes to zero.
    //
    DavFinalizePerUserEntry( &(PerUserEntry) );

    //
    // We are done finalizing the entry so we can leave the critical section
    // now.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );

EXIT_THE_FUNCTION:

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\querydir.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    querydir.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the QueryDirectory call.

Author:

    Rohan Kumar      [RohanK]      20-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"

#define MSN_SPACE_FAKE_DELTA    52428800    // 50 MB


ULONG
DavFsQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles QueryDirectory requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    QueryDirRequest = &(DavWorkItem->QueryDirRequest);

    //
    // Check to see if we have already created the DavFileAttributes list. If
    // we have, we are already done and just need to return.
    //
    if (QueryDirRequest->AlreadyDone) {
        DavPrint((DEBUG_MISC, 
                  "DavFsQueryDirectory: DavFileAttributes already created.\n"));
        WStatus = ERROR_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(QueryDirRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, 
              "DavFsQueryDirectory: ServerName = %ws.\n", ServerName));

    ServerID = QueryDirRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsQueryDirectory: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(QueryDirRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: DirectoryPath = %ws.\n", DirectoryPath));

    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    //
    // If there are no wild cards, we set the depth of the DAV request to 0,
    // otherwise, we set the depth to 1.
    //
    DavWorkItem->AsyncQueryDirectoryCall.NoWildCards = QueryDirRequest->NoWildCards;
    DavPrint((DEBUG_MISC, 
              "DavFsQueryDirectory: NoWildCards = %d.\n", QueryDirRequest->NoWildCards));

    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: LogonId.LowPart = %08lx.\n", 
              QueryDirRequest->LogonID.LowPart));
    
    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: LogonId.HighPart = %08lx.\n", 
              QueryDirRequest->LogonID.HighPart));
    

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;



    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(QueryDirRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncQueryDirectoryCall.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry = PerUserEntry;

    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: PerUserEntry = %08lx.\n", 
              PerUserEntry));
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
        
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    DavWorkItem->DavMinorOperation = DavMinorReadData;
    DavWorkItem->AsyncQueryDirectoryCall.DataBuff = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.didRead = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.Context1 = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.Context2 = NULL;

    // convert the unicode directory path to UTF-8 URL format
    // space and other white characters will remain untouched - these should
    // be taken care of by wininet calls

    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                     L"PROPFIND",
                                     DirectoryPath,
                                     L"HTTP/1.1",
                                     NULL,
                                     NULL,
                                     INTERNET_FLAG_KEEP_CONNECTION |
                                     INTERNET_FLAG_NO_COOKIES,
                                     CallBackContext,
                                     L"DavFsQueryDirectory",
                                     &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsQueryDirectory/HttpOpenRequest. Error Val = %d\n", 
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncQueryDirectoryCompletion(DavWorkItem);

    return WStatus;
}


DWORD 
DavAsyncQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the query directory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    ULONG NumOfFileEntries = 0;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL didImpersonate = FALSE, ReturnVal, readDone = FALSE;
    HINTERNET DavOpenHandle = NULL;
    DWORD didRead, DataBuffBytes;
    PCHAR DataBuff = NULL;
    LPDWORD NumRead = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_FILE_ATTRIBUTES DFA1 = NULL, DFA2 = NULL, TempDFA = NULL;
    BOOL fFreeDFAs = TRUE;
    PDAV_FILE_ATTRIBUTES parentDFA = NULL;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    

    ASSERT(CalledByCallBackThread == FALSE);


    switch (DavWorkItem->DavOperation) {
    
    case DAV_CALLBACK_HTTP_END: {
        
        DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

        //
        // If the file for which the PROPFIND was done does not exist, then
        // we need to fail right away.
        //

        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            //
            // The file/directory for which the PROPFIND was done, does not
            // exist.
            //
            
            if (WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/DavQueryAndParseResponse. "
                          "WStatus = %d\n", WStatus));
            }

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // The file exists. The next thing we do is read the properties
        // of the file (or files in the directory).
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;
    
    }
    //
    // Lack of break is intentional.
    //

    case DAV_CALLBACK_HTTP_READ: {
            
        DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

        if (DavWorkItem->AsyncQueryDirectoryCall.DataBuff == NULL) {
            //
            // Need to allocate memory for the read buffer.
            //
            DataBuffBytes = NUM_OF_BYTES_TO_READ;
            DataBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
            if (DataBuff == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryDirectoryCall.DataBuff = DataBuff;
        }

        if (DavWorkItem->AsyncQueryDirectoryCall.didRead == NULL) {
            //
            // Allocate memory for the DWORD that stores the number of bytes 
            // read.
            //
            NumRead = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, sizeof(DWORD));
            if (NumRead == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryDirectoryCall.didRead = NumRead;
        }

        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;
        
        NumRead = DavWorkItem->AsyncQueryDirectoryCall.didRead;
        DataBuff = DavWorkItem->AsyncQueryDirectoryCall.DataBuff;
        Ctx1 = DavWorkItem->AsyncQueryDirectoryCall.Context1;
        Ctx2 = DavWorkItem->AsyncQueryDirectoryCall.Context2;
        
        do {
            
            switch (DavWorkItem->DavMinorOperation) {
            
            case DavMinorReadData:
            
                DavWorkItem->DavMinorOperation = DavMinorPushData;

                ReturnVal = InternetReadFile(DavOpenHandle, 
                                             (LPVOID)DataBuff,
                                             NUM_OF_BYTES_TO_READ,
                                             NumRead);
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    if (WStatus != ERROR_IO_PENDING) {
                        DavCloseContext(Ctx1, Ctx2);
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncQueryDirectory/InternetReadFile. "
                                  "Error Val = %d\n", WStatus));
                    }
                    DavPrint((DEBUG_MISC,
                              "DavAsyncQueryDirectory/InternetReadFile. "
                              "ERROR_IO_PENDING.\n"));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Lack of break is intentional.
                //

            case DavMinorPushData:

                DavWorkItem->DavMinorOperation = DavMinorReadData;

                didRead = *NumRead;

                readDone = (didRead == 0) ? TRUE : FALSE;

                WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncQueryDirectory/DavPushData."
                              " Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (DavWorkItem->AsyncQueryDirectoryCall.Context1 == NULL) {
                    DavWorkItem->AsyncQueryDirectoryCall.Context1 = Ctx1;
                }
                
                if (DavWorkItem->AsyncQueryDirectoryCall.Context2 == NULL) {
                    DavWorkItem->AsyncQueryDirectoryCall.Context2 = Ctx2;
                }

                break;

            default:

                WStatus = ERROR_INVALID_PARAMETER;

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory. Invalid DavMinorOperation ="
                          " %d.\n", DavWorkItem->DavMinorOperation));

                goto EXIT_THE_FUNCTION;

                break;

            }
            
            if (readDone) {
                break;
            }
            
        } while ( TRUE );

        //
        // We now need to parse the data.
        //

        DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                        sizeof(DAV_FILE_ATTRIBUTES) );
        if (DavFileAttributes == NULL) {
            WStatus = GetLastError();
            DavCloseContext(Ctx1, Ctx2);
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/LocalAlloc. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        InitializeListHead( &(DavFileAttributes->NextEntry) );

        WStatus = DavParseDataEx(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries, &parentDFA);
        if (WStatus != ERROR_SUCCESS) {
            DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
            DavFileAttributes = NULL;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/DavParseDataEx. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        QueryDirResponse = &(DavWorkItem->QueryDirResponse);
        
        //
        // If we queried the server for a file which did not exist, it may 
        // return 200 OK with no files in the XML response.
        //
        if (DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) {
            
            if (NumOfFileEntries != 1) {
                
                PLIST_ENTRY listEntry = &(DavFileAttributes->NextEntry);
                PDAV_FILE_ATTRIBUTES DavFA = NULL;
                
                DavPrint((DEBUG_MISC,
                          "DavAsyncQueryDirectory. NumOfFileEntries = %d\n",
                          NumOfFileEntries));
                
                do {
                    DavFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);
                    DavPrint((DEBUG_MISC,
                              "DavAsyncQueryDirectory. FileName = %ws\n",
                              DavFA->FileName));
                    listEntry = listEntry->Flink;
                } while ( listEntry != &(DavFileAttributes->NextEntry) );
                
                ASSERT(NumOfFileEntries == 0);
                
                DavCloseContext(Ctx1, Ctx2);
                
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                
                WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;
                
                goto EXIT_THE_FUNCTION;
            
            }
        } else {
            //
            // This Query is done for a Directory or for a collection of files 
            // (ex. dir Z:\ab*).
            //

            // In the DFA list (DavFileAttributes) returned by DavParseDataEx(...), 
            // we want to have DFA of the "directory being queried" at the head 
            // of the list.
            // List (DavFileAttributes) returned by DavParseDataEx(...) may not 
            // necessarily have this TRUE.
            // Since DavFileAttributes is a cyclic linked list (all entries are allocated
            // and are to be freed by this function), we will set DavFileAttributes to 
            // point to DFA pointed by parentDFA (points to DFA of "directory being
            // queried").
            //
            // Note: DavFileAttributes->FileIndex which is set in an increasing order
            // starting from 0 in DavParseDataEx(...), may no longer remain in this valid
            // order after re-pointing of DavFileAttributes pointer. We will set them
            // in valid order again here.
            //
            if (parentDFA != NULL && parentDFA != DavFileAttributes) {
                PLIST_ENTRY listEntry = NULL;
                PDAV_FILE_ATTRIBUTES TempDFA = NULL;
                ULONG Count = DavFileAttributes->FileIndex;
                
                DavPrint((DEBUG_DEBUG, "DavAsyncQueryDirectory. CollectionDFA=0x%x",
                                        parentDFA));
                                
                DavFileAttributes = parentDFA;

                //
                // We start the Count with first value DavParseDataEx (value of Head
                // entry in the List) is setting in DavFileAttributes List.
                //

                listEntry = DavFileAttributes->NextEntry.Flink;

                //
                // Set the file indices.
                //
                DavFileAttributes->FileIndex = Count;
                Count++;
                while ( listEntry != &(DavFileAttributes->NextEntry) ) {
            
                    TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

                    listEntry = listEntry->Flink;
            
                    TempDFA->FileIndex = Count;

                    Count++;
            
                }
            }
        }
                        

        //
        // If this was a query for all the files under the directory, then we
        // need to add the files . (current directory) and .. (parent directory)
        // since these are not returned by the server.
        //
        if ( !(DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) ) {
            
            PLIST_ENTRY listEntry = NULL;
            PLIST_ENTRY TempEntry = NULL;
            ULONG Count = 0;


            //
            // We first create the two entires and copy the file names in them.
            //

            DFA1 = LocalAlloc(LPTR, sizeof(DAV_FILE_ATTRIBUTES));
            if (DFA1 == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            InitializeListHead( &(DFA1->NextEntry) );

            //
            // Since the file name is ".", the amount of memory required to hold
            // this name is 2 * sizeof(WCHAR). The extra 1 is for the final L'\0'.
            //
            DFA1->FileName = LocalAlloc(LPTR, (2 * sizeof(WCHAR)));
            if (DFA1->FileName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            wcscpy(DFA1->FileName, L".");
            DFA1->FileNameLength = 1;


            DFA2 = LocalAlloc(LPTR, sizeof(DAV_FILE_ATTRIBUTES));
            if (DFA2 == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            InitializeListHead( &(DFA2->NextEntry) );

            //
            // Since the file name is "..", the amount of memory required to hold
            // this name is 3 * sizeof(WCHAR). The extra 1 is for the final L'\0'.
            //
            DFA2->FileName = LocalAlloc(LPTR, (3 * sizeof(WCHAR)));
            if (DFA2->FileName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            wcscpy(DFA2->FileName, L"..");
            DFA2->FileNameLength = 2;


            //
            // Both these are collections ofcourse.
            //
            DFA1->isCollection = DFA2->isCollection = TRUE;

            //
            // We set the following time values of the new entries to the value 
            // of the first entry in the DavFileAttributes list which is the 
            // directory being enumerated.
            //

            DFA1->CreationTime.HighPart = DFA2->CreationTime.HighPart = DavFileAttributes->CreationTime.HighPart;
            DFA1->CreationTime.LowPart = DFA2->CreationTime.LowPart = DavFileAttributes->CreationTime.LowPart;

            DFA1->DavCreationTime.HighPart = DFA2->DavCreationTime.HighPart = DavFileAttributes->DavCreationTime.HighPart;
            DFA1->DavCreationTime.LowPart = DFA2->DavCreationTime.LowPart = DavFileAttributes->DavCreationTime.LowPart;

            DFA1->LastModifiedTime.HighPart = DFA2->LastModifiedTime.HighPart = DavFileAttributes->LastModifiedTime.HighPart;
            DFA1->LastModifiedTime.LowPart = DFA2->LastModifiedTime.LowPart = DavFileAttributes->LastModifiedTime.LowPart;

            DFA1->DavLastModifiedTime.HighPart = DFA2->DavLastModifiedTime.HighPart = DavFileAttributes->DavLastModifiedTime.HighPart;
            DFA1->DavLastModifiedTime.LowPart = DFA2->DavLastModifiedTime.LowPart = DavFileAttributes->DavLastModifiedTime.LowPart;
            
            DFA1->LastAccessTime.HighPart = DFA2->LastAccessTime.HighPart = DavFileAttributes->LastAccessTime.HighPart;
            DFA1->LastAccessTime.LowPart = DFA2->LastAccessTime.LowPart = DavFileAttributes->LastAccessTime.LowPart;

            //
            // We need to add these two after the first entry. This is because
            // the first entry is always ignored when dealing with WildCard
            // queries in the kernel. This is done because the first entry is
            // the directory being enumerated and we don't need to show that.
            // So, if we had 1->2->3->....->n->1 (cyclic list), we need to insert 
            // DFA1 and DFA2 in the following manner.
            //                 1->DFA1->DFA2->2->3->......->n->1 (cyclic list)
            //                                ^
            //                                |
            //                                TempEntry
            // where DFA1 = L"." and DFA2 = L".."
            // We do this insertion below.
            //

            TempEntry = DavFileAttributes->NextEntry.Flink;
            InsertTailList(TempEntry, &(DFA1->NextEntry));
            InsertTailList(TempEntry, &(DFA2->NextEntry));
            TempEntry = NULL;
            fFreeDFAs = FALSE;

            //
            // We need to increment the number of file entries by 2 to take into
            // account the two new entries we added above.
            //
            NumOfFileEntries += 2;

            listEntry = DavFileAttributes->NextEntry.Flink;

            //
            // We start the Count with first value DavParseDataEx (value of Head
            // entry in the List) is setting in DavFileAttributes List.
            //
            Count = DavFileAttributes->FileIndex;

            //
            // Set the file indices.
            //
            DavFileAttributes->FileIndex = Count;
            Count++;
            while ( listEntry != &(DavFileAttributes->NextEntry) ) {
            
                TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

                listEntry = listEntry->Flink;
            
                TempDFA->FileIndex = Count;

                Count++;
            
            }

            DavPrint((DEBUG_MISC,
                      "DavAsyncQueryDirectory: NumOfFileEntries = %d, Count = %d\n", 
                      NumOfFileEntries, Count));
        
        }

        //
        // Set the response to be sent down to the kernel. We send the pointer
        // to the head of the list that was allocated during parsing.
        //
        QueryDirResponse->DavFileAttributes = DavFileAttributes;
        QueryDirResponse->NumOfFileEntries = NumOfFileEntries;

        DavCloseContext(Ctx1, Ctx2);

        DavPrint((DEBUG_MISC,
                  "DavAsyncQueryDirectory: DavFileAttributes = %08lx.\n", 
                  DavFileAttributes));

    }
        break;

    default:

        WStatus = ERROR_INVALID_PARAMETER;
        
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncQueryDirectory: Invalid DavOperation = %d.\n",
                  DavWorkItem->DavOperation));

        break;

    }

EXIT_THE_FUNCTION:

    
    if(fFreeDFAs == TRUE) {
        if(DFA1 != NULL) {
            DavFinalizeFileAttributesList(DFA1, TRUE);
            DFA1 = NULL;
        }
        if(DFA2 != NULL) {
            DavFinalizeFileAttributesList(DFA2, TRUE);
            DFA2 = NULL;
        }
        fFreeDFAs = FALSE;
    }
    
    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/UMReflectorRevert. Error Val"
                      " = %d\n", RStatus));
        }
    }
    

    return WStatus;
}


VOID
DavAsyncQueryDirectoryCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the QueryDirectory completion. It basically frees up 
   the resources allocated during the QueryDirectory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncQueryDirectoryCall.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncQueryDirectoryCall.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncQueryDirectoryCall.didRead != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncQueryDirectoryCall.didRead);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val ="
                      " %d\n", FreeStatus));
        }
    }
    
    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry) );
    }

    return;
}


ULONG
DavFsQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles QueryVolumeInformationRequest requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest;
    PWCHAR ServerName = NULL, ShareName = NULL;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;


    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // Get the request buffer from the DavWorkItem.
    //
    QueryVolumeInformationRequest = &(DavWorkItem->QueryVolumeInformationRequest);

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(QueryVolumeInformationRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ServerName = %ws.\n", ServerName));

    ServerID = QueryVolumeInformationRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    ShareName = &(QueryVolumeInformationRequest->ShareName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: ShareName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ShareName = %ws.\n", ShareName));

    //
    // If ShareName is a dummy share, we need to remove it right now before we 
    // contact the server.
    //
    DavRemoveDummyShareFromFileName(ShareName);

    DavPrint((DEBUG_MISC,
              "DavFsQueryVolumeInformation: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              QueryVolumeInformationRequest->LogonID.LowPart,
              QueryVolumeInformationRequest->LogonID.HighPart));
              
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;
    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryVolumeInformation/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(QueryVolumeInformationRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncQueryVolumeInformation.ServerHashEntry = ServerHashEntry;
    DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry = PerUserEntry;

    DavPrint((DEBUG_MISC,
              "DavFsQueryVolumeInformation: PerUserEntry = %08lx.\n", 
              PerUserEntry));
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
        
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;
    DavWorkItem->DavMinorOperation = DavMinorReadData;
    DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry = PerUserEntry;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncQueryVolumeInformationCompletion(DavWorkItem);

    return WStatus;
}


DWORD 
DavAsyncQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the query directory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    DAV_FILE_ATTRIBUTES DavFileAttributes;

    WStatus = DavParseXmlResponse(DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle, &DavFileAttributes, NULL);
    if (WStatus == ERROR_SUCCESS)
    {
        DavWorkItem->QueryVolumeInformationResponse.TotalSpace = 
        DavFileAttributes.TotalSpace;
        
        DavWorkItem->QueryVolumeInformationResponse.AvailableSpace = 
        DavFileAttributes.AvailableSpace;
        
        if (!*(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.TotalSpace))
        {
            *(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.TotalSpace) =             
            *(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.AvailableSpace)+MSN_SPACE_FAKE_DELTA;
        }
        
        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
    }

    return WStatus;
}



VOID
DavAsyncQueryVolumeInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the QueryVolumeInformation completion. It basically frees up 
   the resources allocated during the QueryVolumeInformation operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        ReturnVal = InternetCloseHandle(DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle);
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryVolumeInformationCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryVolumeInformationCompletion/LocalFree. Error Val ="
                      " %d\n", FreeStatus));
        }
    }
    
    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry) );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\rename.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rename.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the ReName call.

Author:

    Rohan Kumar      [RohanK]      20-Jan-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "UniUtf.h"

VOID
DavAsyncSetFileInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


ULONG
DavFsReName(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles ReName requests for the DAV Mini-Redir that get 
    reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PWCHAR ServerName = NULL, OldPathName = NULL, NewPathName = NULL;
    PWCHAR UtfServerName = NULL, UtfNewPathName = NULL;
    ULONG UtfServerNameLength = 0, UtfNewPathNameLength = 0;
    PWCHAR UrlBuffer = NULL, HeaderBuff = NULL, CanName = NULL;
    ULONG HeaderLength = 0, HeaderLengthInBytes = 0;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID = 0, urlLength = 0, TagLen = 0, convLen = 0;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    URL_COMPONENTSW UrlComponents;
    BOOL didImpersonate = FALSE, BStatus = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;

    //
    // Get the request buffer pointer from the DavWorkItem.
    //
    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //
    // The first character is a '\' which has to be stripped from the 
    // ServerName.
    //
    ServerName = &(DavReNameRequest->ServerName[1]);
    if ( !ServerName && ServerName[0] != L'\0' ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsReName: ServerName = %ws.\n", ServerName));

    ServerID = DavReNameRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsReName: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped from the 
    // OldPathName.
    //
    OldPathName = &(DavReNameRequest->OldPathName[1]);
    if ( !OldPathName ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: OldPathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    CanName = OldPathName;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }
    
    DavPrint((DEBUG_MISC, "DavFsReName: OldPathName = %ws.\n", OldPathName));

    //
    // The first character is a '\' which has to be stripped from the 
    // NewPathName.
    //
    NewPathName = &(DavReNameRequest->NewPathName[1]);
    if ( !NewPathName ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: NewPathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    CanName = NewPathName;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    DavPrint((DEBUG_MISC, "DavFsReName: NewPathName = %ws.\n", NewPathName));
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif
    
    //
    // If we have a dummy share name in the OldPathName and the NewPathName, we
    // need to remove it right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(OldPathName);
    DavRemoveDummyShareFromFileName(NewPathName);

    //
    // We need to convert the ServerName and the NewPathName into the UTF-8
    // format before we call into the InternetCreateUrlW function. This is
    // because if the localized Unicode characters are passed into this
    // function it converts them into ?. For example all the chinese unicode
    // characters will be converted into ?s.
    //

    UtfServerNameLength = WideStrToUtfUrlStr(ServerName, (wcslen(ServerName) + 1), NULL, 0);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(1). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfServerName = LocalAlloc(LPTR, UtfServerNameLength * sizeof(WCHAR));
    if (UtfServerName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    UtfServerNameLength = WideStrToUtfUrlStr(ServerName, (wcslen(ServerName) + 1), UtfServerName, UtfServerNameLength);
    if (GetLastError() != ERROR_SUCCESS) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathNameLength = WideStrToUtfUrlStr(NewPathName, (wcslen(NewPathName) + 1), NULL, 0);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(3). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathName = LocalAlloc(LPTR, UtfNewPathNameLength * sizeof(WCHAR));
    if (UtfNewPathName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathNameLength = WideStrToUtfUrlStr(NewPathName, (wcslen(NewPathName) + 1), UtfNewPathName, UtfNewPathNameLength);
    if (GetLastError() != ERROR_SUCCESS) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(4). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create the URL with the NewPathName to be sent to the server. Initialize 
    // the UrlComponents structure before making the call.
    //
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    UrlComponents.lpszScheme = NULL;
    UrlComponents.dwSchemeLength = 0;
    UrlComponents.nScheme = INTERNET_SCHEME_HTTP;
    UrlComponents.lpszHostName = UtfServerName;
    UrlComponents.dwHostNameLength = wcslen(UtfServerName); 
    UrlComponents.nPort = DEFAULT_HTTP_PORT;
    UrlComponents.lpszUserName = NULL;
    UrlComponents.dwUserNameLength = 0;
    UrlComponents.lpszPassword = NULL;
    UrlComponents.dwPasswordLength = 0;
    UrlComponents.lpszUrlPath = UtfNewPathName;
    UrlComponents.dwUrlPathLength = wcslen(UtfNewPathName);
    UrlComponents.lpszExtraInfo = NULL;
    UrlComponents.dwExtraInfoLength = 0;
    ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                   0,
                                   NULL,
                                   &(urlLength));
    if (!ReturnVal) {
        
        ULONG urlLengthInWChars = 0;
        
        WStatus = GetLastError();
        
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {
            
            UrlBuffer = (PWCHAR) LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, 
                                              urlLength);
            if (UrlBuffer != NULL) {
                
                ZeroMemory(UrlBuffer, urlLength);
                
                urlLengthInWChars = ( urlLength/sizeof(WCHAR) );
                
                ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                               0,
                                               UrlBuffer,
                                               &(urlLengthInWChars));
                if (!ReturnVal) {
                    
                    WStatus = GetLastError();
                    
                    DavPrint((DEBUG_ERRORS,
                              "DavFsReName/InternetCreateUrl. Error Val = %d\n",
                              WStatus));
                    
                    goto EXIT_THE_FUNCTION;

                }

            } else {

                WStatus = GetLastError();
                
                DavPrint((DEBUG_ERRORS,
                          "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
                
                goto EXIT_THE_FUNCTION;
            
            }

        } else {

            DavPrint((DEBUG_ERRORS,
                      "DavFsReName/InternetCreateUrl. Error Val = %d\n",
                      WStatus));
            
            goto EXIT_THE_FUNCTION;

        }

    }
    
    DavPrint((DEBUG_MISC, "DavFsReName: URL: %ws\n", UrlBuffer));

    //
    // We now need to create the Destination header that we will add to the
    // request to be sent to the server. This header has the following format.
    // "Destination: URL"
    //

    TagLen = wcslen(L"Destination: ");
    convLen = wcslen(UrlBuffer);
    HeaderLength = TagLen + convLen;
    HeaderLengthInBytes = ( (1 + HeaderLength) * sizeof(WCHAR) );
    HeaderBuff = (PWCHAR) LocalAlloc(LPTR, HeaderLengthInBytes);
    if (HeaderBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    wcscpy(HeaderBuff, L"Destination: ");
    wcscpy(&(HeaderBuff[TagLen]), UrlBuffer);

    DavWorkItem->AsyncReName.HeaderBuff = HeaderBuff;

    DavPrint((DEBUG_MISC, "DavFsReName: HeaderBuff: %ws\n", HeaderBuff));

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/DavFsSetTheDavCallBackContext. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(DavReNameRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsReName: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncReName.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncReName.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
    
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

    //
    // Convert the unicode directory path to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                  L"MOVE",
                                  OldPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavFsReName",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsReName/HttpOpenRequest. Error Val = %d\n", 
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncReName.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION: // Do the necessary cleanup and return.

    //
    // We could have taken the lock and come down an error path without 
    // releasing it. If thats the case, then we need to release the lock now.
    //
    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }
    
    if (UrlBuffer != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)UrlBuffer);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFsRename/LocalFree. Error Val = %d\n", FreeStatus));
        }
    }

    if (UtfServerName != NULL) {
        LocalFree(UtfServerName);
        UtfServerName = NULL;
    }

    if (UtfNewPathName != NULL) {
        LocalFree(UtfNewPathName);
        UtfNewPathName = NULL;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {
            
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
    
        DavAsyncReNameCompletion(DavWorkItem);
    
    } else {
        DavPrint((DEBUG_MISC, "DavFsReName: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        INTERNET_CACHE_ENTRY_INFOW CEI;

        CEI.LastAccessTime.dwLowDateTime = 0;
        CEI.LastAccessTime.dwHighDateTime = 0;

        SetUrlCacheEntryInfo(DavReNameRequest->Url,&CEI,CACHE_ENTRY_ACCTIME_FC);
        
        DavPrint((DEBUG_MISC,
                  "DavFsRename Reset LastAccessTime for     %ws\n",DavReNameRequest->Url));
        
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncReNameCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD 
DavAsyncReName(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the ReName operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    ULONG HttpResponseStatus = 0;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/UMReflectorImpersonate. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncReName/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncReName. AsyncFunction failed. Error Val = %d\n", 
                          WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
    WStatus = DavQueryAndParseResponseEx(DavOpenHandle, &(HttpResponseStatus));
    if (WStatus != ERROR_SUCCESS) {
        //
        // The MOVE request that was sent to the server failed.
        // If the response status is HTTP_STATUS_PRECOND_FAILED then it means
        // that we tried to rename a file to a file which already exists and
        // ReplaceIfExists (sent by the caller) was FALSE. In such a case we 
        // return ERROR_ALREADY_EXISTS.
        //
        if (HttpResponseStatus == HTTP_STATUS_PRECOND_FAILED) {
            WStatus = ERROR_ALREADY_EXISTS;
        } else {
            WStatus = ERROR_UNABLE_TO_MOVE_REPLACEMENT;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncReName/DavQueryAndParseResponse. WStatus = %d\n", 
                  WStatus));
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
EXIT_THE_FUNCTION:
#endif

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the DavAsyncReNameCompletion routine.
        //
        DavAsyncReNameCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It 
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncReName: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncReNameCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the ReName completion. It basically frees up the 
   resources allocated during the ReName operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncReName.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/InternetCloseHandle. Error Val "
                      "= %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncReName.HeaderBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncReName.HeaderBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncReName.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncReName.PerUserEntry) );
    }

    return;
}


ULONG
DavFsSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles SetFileInformation requests for the DAV Mini-Redir that get 
    reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    PWCHAR OpenVerb = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE, fSetDirectoryEntry = FALSE;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST SetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    PBYTE DataBuff = NULL;
    LARGE_INTEGER FileSize, ByteOffset;
    BY_HANDLE_FILE_INFORMATION FileInfo; 
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static UINT UniqueTempId = 1;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOLEAN didITakeAPUEReference = FALSE;

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(SetFileInformationRequest->ServerName[1]);
    
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: ServerName = %ws.\n", ServerName));
    
    ServerID = SetFileInformationRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(SetFileInformationRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: DirectoryPath = %ws.\n", DirectoryPath));
    
    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    
    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(SetFileInformationRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->ServerUserEntry.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry and set didITakeAPUEReference to TRUE.
    //
    PerUserEntry->UserEntryRefCount++;

    didITakeAPUEReference = TRUE;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsSetFileInformation/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    DavWorkItem->DavMinorOperation = DavMinorProppatchFile;

    WStatus = DavSetBasicInformation(DavWorkItem,
                                     PerUserEntry->DavConnHandle, 
                                     DirectoryPath,
                                     SetFileInformationRequest->fCreationTimeChanged,
                                     SetFileInformationRequest->fLastAccessTimeChanged,
                                     SetFileInformationRequest->fLastModifiedTimeChanged,
                                     SetFileInformationRequest->fFileAttributesChanged,
                                     &SetFileInformationRequest->FileBasicInformation.CreationTime,
                                     &SetFileInformationRequest->FileBasicInformation.LastAccessTime,
                                     &SetFileInformationRequest->FileBasicInformation.LastWriteTime,
                                     SetFileInformationRequest->FileBasicInformation.FileAttributes);
    if (WStatus != ERROR_SUCCESS) {

        ULONG LogStatus;

        DavPrint((DEBUG_ERRORS,
                  "DavFsSetFileInformation/DavSetBasicInformation. WStatus = %d\n",
                  WStatus));
        
        LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
        if (LogStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsSetFileInformation/DavFormatAndLogError. LogStatus = %d\n",
                      LogStatus));
        }
    
    }

    RevertToSelf();
    didImpersonate = FALSE;


EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    //
    // If didITakeAPUEReference is TRUE we need to remove the reference we 
    // took on the PerUserEntry.
    //
    if (didITakeAPUEReference) {
        DavFinalizePerUserEntry( &(DavWorkItem->ServerUserEntry.PerUserEntry) );
    }

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\srvcall.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the user mode DAV miniredir routines pertaining to
    creation of srvcalls.

Author:

    Rohan Kumar      [RohanK]      25-May-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "winsock2.h"
#include <time.h>

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

VOID
DavParseOPTIONSLine(
    PWCHAR ParseData, 
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

//
// Implementation of functions begins here.
//

ULONG
DavFsCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine verifies if the server for which a srvcall is being created in
    the kernel exists or not.

Arguments:

    DavWorkItem - The buffer that contains the server name.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PWCHAR ServerName = NULL;
    HINTERNET DavConnHandle = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL CallBackContextInitialized = FALSE, isPresent = FALSE, CricSec = FALSE;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse;
    ULONG ServerNameLengthInBytes, TotalLength;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;

    CreateSrvCallRequest = &(DavWorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(DavWorkItem->CreateSrvCallResponse);

    ServerName = CreateSrvCallRequest->ServerName;

    //
    // If the server name is NULL, return.
    //
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateSrvCall: ServerName == NULL\n"));
        //
        // Set the ServerID in the response to zero. This will help the
        // kernel mode realize that the ServerHashEntry was never created.
        // So, when finalize happens immediately after we fail from here,
        // the request is not sent to the user mode. The number 0 works
        // because the ID can never be zero in the normal case. The first
        // assigned ID number is 1.
        //
        CreateSrvCallResponse->ServerID = 0;
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavFsCreateSrvCall: ServerName: %ws.\n", ServerName));

    //
    // Check the ServerHashTable and/or the "to be finalized list" to see if we 
    // have an entry for this server. Need to take a lock on the table before 
    // doing the check.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    CricSec = TRUE;

    //
    // These will already be set to FALSE since the DavWorkItem is always zeroed
    // before its resued but set them to FALSE anyway.
    //
    CreateSrvCallRequest->didICreateThisSrvCall = FALSE;
    CreateSrvCallRequest->didIWaitAndTakeReference = FALSE;
    
    //
    // The entry is either in the ServerHashTable or in the "to be finalized" 
    // list, or we need to create a new entry for it.
    //

    //
    // We check the ServerHashTable first.
    //
    isPresent = DavIsThisServerInTheTable(ServerName, &ServerHashEntry);
    
    if (isPresent) {
        
        DavPrint((DEBUG_MISC,
                  "DavFsCreateSrvCall: ServerName: %ws does exist in"
                  " the \"ServerHashTable\"\n", ServerName));

        ASSERT(ServerHashEntry != NULL);

        //
        // Increment the Reference count of the ServerEntry by 1.
        //
        ServerHashEntry->ServerEntryRefCount += 1;

        //
        // Note that we are a thread that will wait for some other thread that
        // is initializing this ServerHashEntry and that we have taken a 
        // reference on this entry.
        //
        CreateSrvCallRequest->didIWaitAndTakeReference = TRUE;

        //
        // Set the ServerHashEntry in the DavWorkItem structure. We might need
        // this in DavAsyncCreateSrvCallCompletion.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry = ServerHashEntry;

        //
        // If its initializing, then I need to free the lock and wait on the
        // event.
        //
        if (ServerHashEntry->ServerEntryState == ServerEntryInitializing) {

            DWORD WaitStatus;

            LeaveCriticalSection( &(HashServerEntryTableLock) );
            CricSec = FALSE;

            WaitStatus = WaitForSingleObject(ServerHashEntry->ServerEventHandle, INFINITE);
            if (WaitStatus == WAIT_FAILED) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateSrvCall/WaitForSingleObject. Error Val = %d\n",
                           WStatus));
                goto EXIT_THE_FUNCTION;
            }

            ASSERT(WaitStatus == WAIT_OBJECT_0);

        }

        //
        // We could have left the lock while waiting on an event. If we have,
        // then we need to acquire it back before proceeding further.
        //
        if (!CricSec) {
            EnterCriticalSection( &(HashServerEntryTableLock) );
            CricSec = TRUE;
        }

        //
        // If the initialization failed then the error is stored in the 
        // ErrorStatus field.
        //
        if (ServerHashEntry->ServerEntryState == ServerEntryInitializationError) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateSrvCall: ServerEntryInitializationError\n"));
            WStatus = ServerHashEntry->ErrorStatus;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            CricSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        ASSERT(ServerHashEntry->ServerEntryState == ServerEntryInitialized);

        //
        // We got a Server that is valid. Set the ServerID and return.
        //
        WStatus = ERROR_SUCCESS;
        DavWorkItem->Status = WStatus;
        CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;

        goto EXIT_THE_FUNCTION;

    }

    DavPrint((DEBUG_MISC,
              "DavFsCreateSrvCall: ServerName: %ws does not exist in"
              " the \"ServerHashTable\"\n", ServerName));

    //
    // We need to find out if an entry for this server exists. Check the
    // "to be finalized" list of server entries. If the server entry exists
    // in the "to be finalized" list and is a valid DAV server, the rouitne
    // below, moves it to the hash table to reactivate it.
    //
    isPresent = DavIsServerInFinalizeList(ServerName, &ServerHashEntry, TRUE);
    
    if (isPresent) {

        DavPrint((DEBUG_MISC,
                  "DavFsCreateSrvCall: ServerName: %ws does exist in"
                  " the \"to be finalized\" list\n", ServerName));

        if (ServerHashEntry != NULL) {

            DavPrint((DEBUG_MISC,
                      "DavFsCreateSrvCall: ServerName: %ws is a valid "
                      " DAV server\n", ServerName));

            //
            // We got a Server that is valid. Set the ServerID and return.
            //
            WStatus = ERROR_SUCCESS;
            DavWorkItem->Status = WStatus;
            CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

        } else {

            DavPrint((DEBUG_MISC,
                      "DavFsCreateSrvCall: ServerName: %ws is NOT a valid "
                      " DAV server\n", ServerName));

            //
            // The entry is a not valid DAV server.
            //
            WStatus = ERROR_BAD_NETPATH; // STATUS_BAD_NETWORK_PATH;
            DavWorkItem->Status = WStatus;
            CreateSrvCallResponse->ServerID = 0;

        }

        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;

        goto EXIT_THE_FUNCTION;

    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif

    //
    // The entry does not exist in the "to be finalized" list. We need to
    // create a new one.
    //

    DavPrint((DEBUG_MISC,
              "DavFsCreateSrvCall: ServerName: %ws doesn't exist in the"
              " \"to be finalized\" list\n", ServerName));

    ASSERT(ServerHashEntry == NULL);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    TotalLength = ServerNameLengthInBytes + sizeof(HASH_SERVER_ENTRY);

    ServerHashEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TotalLength);
    if (ServerHashEntry == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Mark in the request that we are creating this SrvCall. This will be used
    // during SrvCallCompletion.
    //
    CreateSrvCallRequest->didICreateThisSrvCall = TRUE;

    //
    // Set the entry in the workitem which gets passed around in Async
    // calls.
    //
    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry = ServerHashEntry;

    //
    // Initialize the entry and insert it into the global hash table.
    //
    DavInitializeAndInsertTheServerEntry(ServerHashEntry,
                                         ServerName,
                                         TotalLength);

    ServerHashEntry->ServerEntryState = ServerEntryInitializing;

    //
    // Create a event which has to be manually set to non-signalled state and
    // set it to "not signalled".
    //
    ServerHashEntry->ServerEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ServerHashEntry->ServerEventHandle == NULL) {
        WStatus = GetLastError();
        ServerHashEntry->ServerEntryState = ServerEntryInitializationError;
        ServerHashEntry->ErrorStatus = WStatus;
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/CreateEvent. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the ServerID in the response.
    //
    CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

    //
    // Now, we need to figure out if this is a HTTP/DAV server or not.
    //

    //
    // IMPORTANT TO UNDERSTAND THIS!!!!!
    // This is a special case of user entry creation/initialization which is
    // done without holding a lock on the ServerHashTable. This is because
    // during CreateSrvCall, we are guaranteed that no other thread will ever
    // come up for this server till this request has been completed. All other
    // threads that carry "create" requests for files on this server are
    // blocked inside of RDBSS.
    //

    LeaveCriticalSection( &(HashServerEntryTableLock) );
    CricSec = FALSE;

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/DavFsSetTheDavCallBackContext. Error Val"
                  " = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the
    // variable CallBackContext. This will now be used in all the async calls
    // that follow. This needs to be done only if we are calling the WinInet
    // APIs asynchronously.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Need to set the DavOperation field before submitting the asynchronous
    // request. This is a internet connect operation.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;

    //
    // Create a handle to connect to a HTTP/DAV server.
    //
    DavConnHandle = InternetConnectW(IHandle,
                                     (LPCWSTR)ServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     CallBackContext);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateSrvCall/InternetConnect. Error Val = %d.\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the InternetConnect handle in the DavWorkItem.
    //
    DavWorkItem->AsyncCreateSrvCall.DavConnHandle = DavConnHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);

    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {

        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));

        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }

    }

EXIT_THE_FUNCTION:

    //
    // If we came along a path without freeing the lock, now is the  time to
    // free it.
    //
    if (CricSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING ) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
        
        //
        // Free up the resources that were allocated for the SrvCall creation.
        //
        DavAsyncCreateSrvCallCompletion(DavWorkItem);

    }

#else 
    
    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    //
    // Free up the resources that were allocated for the SrvCall creation.
    //
    DavAsyncCreateSrvCallCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD
DavAsyncCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the create srvcall operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    HINTERNET DavOpenHandle = NULL;
    BOOL ReturnVal, didImpersonate = FALSE;
    PWCHAR DataBuff = NULL, ParseData = NULL;
    DWORD DataBuffBytes = 0;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // If this function was called by the thread that picked off the DavWorkItem
    // from the Callback function, we need to do a few things first. These are
    // done below.
    //
    if (CalledByCallBackThread) {
    
        //
        // We are running in the context of a worker thread which has different
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/UMReflectorImpersonate. Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateSrvCall/DavAsyncCommonStates. "
                              "Error Val = %08lx\n", WStatus));
                }

            } else {
            
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCall. AsyncFunction failed. Error Val"
                          " = %d\n", WStatus));
            }

            goto EXIT_THE_FUNCTION;
        
        }
    
    }

#else 

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    switch (DavWorkItem->DavOperation) {

    case DAV_CALLBACK_HTTP_END: {

        ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
        WCHAR DavCustomBuffer[100];
        
        DavPrint((DEBUG_MISC,
                  "DavAsyncCreateSrvCall: Entering DAV_CALLBACK_HTTP_END.\n"));

        DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;

        //
        // First figure out if the OPTIONS response which was sent succeeded in 
        // the first place. If this failed then we bail right now.
        //
        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/DavQueryAndParseResponse. "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        //
        // We read the value of AcceptOfficeAndTahoeServers from the registry when
        // the WebClient service starts up. If this is set to 0, it means that we
        // should be rejecting OfficeWebServers, Tahoe servers and the shares on
        // these servers even though they speak DAV. We do this since WebFolders
        // needs to claim this name and Shell will only call into WebFolders if the
        // DAV Redir fails. If this value is non-zero, we accept all servers that
        // speak DAV.
        // 
        //
        if (AcceptOfficeAndTahoeServers == 0) {
    
            //
            // Figure out if this is an OFFICE Web Server. If it is then the response 
            // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
            // If this is an OFFICE server then we should not claim it since the 
            // user actually intends to use the OFFICE specific features in Shell.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
            OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(OfficeCustomHeaderLength), 
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    DavPrint((DEBUG_ERRORS, 
                              "DavAsyncCreateSrvCall/HttpQueryInfoW(1): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: NOT OFFICE Web Server\n"));
                    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer = FALSE;
                }
            } else {
                DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: OFFICE Web Server\n"));
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer = TRUE;
            }
    
            //
            // Figure out if this is a TAHOE server. If it is then the response will 
            // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
            // TAHOE server then we should not claim it since the user actually 
            // intends to use the TAHOE specific features in Rosebud.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
            TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(TahoeCustomHeaderLength),
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    DavPrint((DEBUG_ERRORS, 
                              "DavAsyncCreateSrvCall/HttpQueryInfoW(2): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: NOT TAHOE Server\n"));
                    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer = FALSE;
                }
            } else {
                DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: TAHOE Server\n"));
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer = TRUE;
            }
            
            //
            // If its either an Office Web Server or a TAHOE server, then we reject
            // this server and fail. As far as the DAV Redir is concerned, this is
            // NOT a valid DAV server (even though TAHOE and Office Severs are built
            // on IIS and are DAV servers by default).
            //
            if ( DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer ||
                 DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer ) {
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer = FALSE;
                WStatus = ERROR_BAD_NETPATH;
                goto EXIT_THE_FUNCTION;
            }
    
        }

        //
        // This is NOT a TAHOE server nor an OFFICE Web Server. We go ahead and
        // query some other stuff from the header to make sure that this is a
        // DAV server.
        //

        //
        // Query the header for the servers response. This query is done to get
        // the size of the header to be copied.
        //
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_RAW_HEADERS_CRLF,
                                   DataBuff,
                                   &(DataBuffBytes),
                                   NULL);
        if (!ReturnVal) {
            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCall/HttpQueryInfoW(3). Error Val = "
                          "%d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreateSrvCall: HttpQueryInfo: Need Buff.\n"));
            }
        }

        //
        // Allocate memory for copying the header.
        //
        DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
        if (DataBuff == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_RAW_HEADERS_CRLF,
                                   DataBuff,
                                   &(DataBuffBytes),
                                   NULL);
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/HttpQueryInfoW(4). Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Check to see whether this server is a DAV server, Http Server etc.
        //
        DavObtainServerProperties(DataBuff, 
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isHttpServer),
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isMSIIS),
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer));

        WStatus = ERROR_SUCCESS;

    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateSrvCall: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;
    
    }

EXIT_THE_FUNCTION:

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorRevert. Error Val = %d\n",
                      RStatus));
        }
    }

    //
    // Free the DataBuff if we allocated one.
    //
    if (DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // We need to do the following only if we are running in the context of the
    // worker thread that picked up the DavWorkItem from the Callback function.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the AsyncCreateCompletion routine.
        //
        DavAsyncCreateSrvCallCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    }

#endif

    return WStatus;
}


VOID
DavParseOPTIONSLine(
    PWCHAR ParseData, 
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine is used to parse the response (buffer) to the OPTIONS request 
    sent to server. This info helps to figure out if the HTTP server supports
    DAV extensions and whether it is an IIS (Microsoft's) server. The response
    buffer is split into lines and each line is sent to this routine.

Arguments:

    ParseData - The line to be parsed.
    
    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    PWCHAR p;

    //
    // IMPORTANT!!! We do not need to take a lock here since this is the
    // only thread which will be accessing this server structure. This is
    // because RDBSS holds up all the threads for this server till this
    // completes.
    //

    // DavPrint((DEBUG_MISC, "DavParseOPTIONSLine: ParseLine = %ws\n", ParseData));

    if ( ( p = wcsstr(ParseData, L"HTTP/1.1") ) != NULL ) {
        //
        // This is a HTTP server.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isHttpServer = TRUE;
    } else if ( ( p = wcsstr(ParseData, L"Microsoft-IIS") ) != NULL ) {
        //
        // This is a Microsoft server.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isMSIIS = TRUE;
    } else if ( ( p = wcsstr(ParseData, L"DAV") ) != NULL ) {
        //
        // This HTTP server supports DAV extensions.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer = TRUE;
    }

    return;
}


VOID
DavAsyncCreateSrvCallCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the CreateSrvCall completion. It basically frees up the
   resources allocated during the CreateSrvCall operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL;

    CreateSrvCallRequest = &(DavWorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(DavWorkItem->CreateSrvCallResponse);
    ServerHashEntry = DavWorkItem->AsyncCreateSrvCall.ServerHashEntry;

    if (DavWorkItem->AsyncCreateSrvCall.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/InternetCloseHandle"
                      "(0). Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreateSrvCall.DavConnHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavConnHandle = DavWorkItem->AsyncCreateSrvCall.DavConnHandle;
        ReturnVal = InternetCloseHandle( DavConnHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/InternetCloseHandle"
                      "(1). Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    //
    // If we were the thread that worked on the creation and initialization
    // of this SrvCall then we need to do somethings before we proceed further.
    // Its very important that we do this before we do the next step.
    //
    if (CreateSrvCallRequest->didICreateThisSrvCall) {

        BOOL setEvt = FALSE;

        ASSERT(CreateSrvCallRequest->didIWaitAndTakeReference == FALSE);

        if (ServerHashEntry != NULL) {

            EnterCriticalSection( &(HashServerEntryTableLock) );

            //
            // Depending on whether we succeeded or not, we mark the ServerHashEntry
            // as initialized or failed. Also, DavWorkItem->Status has an NTSTATUS
            // value at this stage so we use RtlNtStatusToDosError to convert it
            // back to the Win32 error.
            //
            if (DavWorkItem->Status != STATUS_SUCCESS) {
                ServerHashEntry->ErrorStatus = RtlNtStatusToDosError(DavWorkItem->Status);
                ServerHashEntry->ServerEntryState = ServerEntryInitializationError;
            } else {
                ServerHashEntry->ErrorStatus = ERROR_SUCCESS;
                ServerHashEntry->ServerEntryState = ServerEntryInitialized;
            }

            //
            // Signal the event of the server entry to wake up the threads which 
            // might be waiting for this to happen.
            //
            setEvt = SetEvent(ServerHashEntry->ServerEventHandle);
            if (!setEvt) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCallCompletion/SetEvent. Error Val = %d\n", 
                          GetLastError()));
            }

            LeaveCriticalSection( &(HashServerEntryTableLock) );

        }

    }

    //
    // Some resources should not be freed if we succeeded. Also, if we failed
    // we do different things depending upon whether or not we were the thread
    // that worked in creating and initializing this ServerHashEntry.
    //
    if (DavWorkItem->Status != STATUS_SUCCESS) {

        //
        // Set the ServerID to zero, so that the finalize never comes
        // to the user mode.
        //
        CreateSrvCallResponse->ServerID = 0;

        if (CreateSrvCallRequest->didICreateThisSrvCall) {

            ASSERT(CreateSrvCallRequest->didIWaitAndTakeReference == FALSE);

            if (ServerHashEntry != NULL) {

                EnterCriticalSection( &(HashServerEntryTableLock) );

                //
                // This is not a DAV server.
                //
                ServerHashEntry->isHttpServer = FALSE;
                ServerHashEntry->isDavServer = FALSE;
                ServerHashEntry->isMSIIS = FALSE;

                //
                // Since we are moving to the "to be finalized list", we need to
                // set the TimeValueInSec to the current time.
                //
                ServerHashEntry->TimeValueInSec = time(NULL);

                //
                // Remove the reference that we would have taken when we created
                // this ServerHashEntry.
                //
                ServerHashEntry->ServerEntryRefCount -= 1;

                //
                // Remove the ServerHashEntry from the HashTable. When we created
                // it, we added it to the HashTable. If the ErrorStatus is not
                // STATUS_ACCESS_DENIED or STATUS_LOGON_FAILURE, then we move the
                // ServerHashEntry to the "to be finalized" list. This is done to
                // enable -ve caching. If its STATUS_ACCESS_DENIED or LOGON_FAILURE,
                // then we failed since the credentials were not correct. That
                // doesn't mean that this server is not a DAV server and hence we
                // don't put it in the "to be finalized" list.
                //
                
                RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
    
                if (DavWorkItem->Status == STATUS_ACCESS_DENIED ||
                    DavWorkItem->Status == STATUS_LOGON_FAILURE) {
                    LocalFree(ServerHashEntry);
                } else {
                    InsertHeadList( &(ToBeFinalizedServerEntries),
                                                 &(ServerHashEntry->ServerListEntry) );
                }

                LeaveCriticalSection( &(HashServerEntryTableLock) );

            }

        } else {

            //
            // If we were the thread that waited for some other thread to
            // create and initialize the ServerHashEntry then we need to take
            // our reference out now.
            //
            if (CreateSrvCallRequest->didIWaitAndTakeReference) {

                ASSERT(CreateSrvCallRequest->didICreateThisSrvCall == FALSE);

                EnterCriticalSection( &(HashServerEntryTableLock) );

                ServerHashEntry->ServerEntryRefCount -= 1;

                LeaveCriticalSection( &(HashServerEntryTableLock) );

            }

        }

    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    return;
}


ULONG
DavFsFinalizeSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine finalizes a Server entry in the hash table. If the Ref count on
    the entry is 1, this basically amounts setting the timer in the entry to the 
    current time. The scavenger thread which periodically goes through all the 
    entries looks at the time elapsed after the server entry was finalized and 
    if this value exceeds a specified limit, it deletes the entry from the 
    table.

Arguments:

    DavWorkItem - The buffer that contains the server name.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST DavFinSrvCallReq;
    PWCHAR ServerName;
    BOOL isPresent = FALSE;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;

    DavFinSrvCallReq = &(DavWorkItem->FinalizeSrvCallRequest);

    //
    // If we are finalizing a server, it better not be NULL.
    //
    ASSERT(DavFinSrvCallReq->ServerName);
    ServerName = DavFinSrvCallReq->ServerName;

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeSrvCall: ServerName = %ws.\n", ServerName));

    EnterCriticalSection( &(HashServerEntryTableLock) );

    isPresent = DavIsThisServerInTheTable(ServerName, &ServerHashEntry);
    if (!isPresent) {
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER
        DavPrint((DEBUG_ERRORS,
                  "DavFsFinalizeSrvCall/DavIsThisServerInTheTable.\n"));
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        goto EXIT_THE_FUNCTION;
    }

    //
    // Found the entry. Set the timer.
    //
    ASSERT(ServerHashEntry != NULL);
    ASSERT(ServerHashEntry->ServerID == DavFinSrvCallReq->ServerID);

    //
    // Decrement the reference count on the ServerHashEntry by 1.
    //
    ServerHashEntry->ServerEntryRefCount -= 1;

    //
    // If the value of ServerHashEntry->ServerEntryRefCount is zero, we finalize
    // the entry.
    //
    if (ServerHashEntry->ServerEntryRefCount == 0) {

        ServerHashEntry->TimeValueInSec = time(NULL);

        //
        // Now move this server entry from the hash table to the "to be finalized"
        // list.
        //
        RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
        InsertHeadList( &(ToBeFinalizedServerEntries),
                                         &(ServerHashEntry->ServerListEntry) );
    
    }

    LeaveCriticalSection( &(HashServerEntryTableLock) );

EXIT_THE_FUNCTION:

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\socket.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    socket.c
    
Abstract:

    This module implements the user mode DAV miniredir routines pertaining to 
    initialization and closing of the socket data structures.

Author:

    Rohan Kumar      [RohanK]      27-May-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"

//
// Implementation of functions begins here.
//

//
// Data structure that is to receive details of the WinSock implementation.
//
WSADATA g_wsaData;
BOOLEAN g_socketinit = FALSE;

ULONG
InitializeTheSocketInterface(
    VOID
    )
/*++

Routine Description:

    This routine initializes the socket interface. This has to be done before
    any WinSock calls can be made.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    int err;
    WORD VersionRequested;

    //
    // Request version 2.0.
    //
    VersionRequested = MAKEWORD(2, 0);

    //
    // The WSAStartup function must be the first Windows Sockets function 
    // called. 
    //
    err = WSAStartup(VersionRequested, &g_wsaData);
    if (err != 0) {
        //
        // We could not find a suitable Winsock lib.
        //
        DavPrint((DEBUG_ERRORS,
                  "InitializeTheSocketInterface/WSAStartup: Error Val = %d.\n", 
                  err));
        WStatus = (ULONG)err;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Confirm that the lib supports version 2.0. Only Winsock versions 1.1 or
    // higher support the GetHostByName call.
    //
    if (LOBYTE(g_wsaData.wVersion) != 2 || HIBYTE(g_wsaData.wVersion) != 0) {
        DavPrint((DEBUG_ERRORS,
                  "InitializeTheSocketInterface/WSAStartup: Ver not supported.\n"));
        //
        // Cleanup and return error.
        //
        err = WSACleanup();
        if (err == SOCKET_ERROR) {
            WStatus = (ULONG)WSAGetLastError();
            DavPrint((DEBUG_ERRORS,
                      "InitializeTheSocketInterface/WSACleanup: Error Val = "
                      "%08lx.\n", WStatus));
        }
        WStatus = ERROR_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (WStatus == ERROR_SUCCESS) {
        g_socketinit = TRUE;
    }

    return WStatus;
}


NTSTATUS
CleanupTheSocketInterface(
    VOID
    )
/*++

Routine Description:

    This routine cleansup the data structures created during the initialization
    of the socket interface.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    int err;
    
    err = WSACleanup();
    if (err == SOCKET_ERROR) {
        WStatus = (ULONG)WSAGetLastError();
        DavPrint((DEBUG_ERRORS,
                  "CleanupTheSocketInterface/WSACleanup: Error Val = "
                  "%08lx.\n", WStatus));
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\uniutf.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UniUtf.h
    
Abstract:

    This file declares the functions used for Unicode object name to/from Utf8-URL coversion

Author:

    Mukul Gupta        [Mukgup]      20-Dec-2000

Revision History:

--*/

#ifndef _UNICODE_UTF8_
#define _UNICODE_UTF8_

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT 
UtfUrlStrToWideStr(
    IN LPWSTR UtfStr, 
    IN DWORD UtfStrLen, 
    OUT LPWSTR WideStr, 
    OUT LPDWORD pWideStrLen
    );

DWORD 
WideStrToUtfUrlStr(
    IN LPWSTR WideStr, 
    IN DWORD WideStrLen, 
    IN OUT LPWSTR InOutBuf,
    IN DWORD InOutBufLen
    );

BOOL 
DavHttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPWSTR lpszVerb,
    IN LPWSTR lpszObjectName,
    IN LPWSTR lpszVersion,
    IN LPWSTR lpszReferer,
    IN LPWSTR FAR * lpszAcceptTypes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN LPWSTR ErrMsgTag,
    OUT HINTERNET * phInternet
    );

    
#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // _UNICODE_UTF8_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Web DAV Service DLL"
#define VER_INTERNALNAME_STR            "davsvc.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization.

--*/

#ifndef _VALIDC_H_
#define _VALIDC_H_

//
// Disallowed control characters (not including \0).
//
#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"
#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets.
//
#define NON_COMPONENT_CHARS L"\\/:"
#define ILLEGAL_CHARS_STR   L"\"<>|"
#define SPACE_STR           L" "
#define PATH_SEPARATORS     L"\\/"

//
// Combinations of the above.
//
#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  L"\"/\\:|<>?" CTRL_CHARS_STR
#define STANDARD_ILLEGAL_CHARS  ILLEGAL_NAME_CHARS_STR L"*"
#define SERVER_ILLEGAL_CHARS    STANDARD_ILLEGAL_CHARS SPACE_STR L"[]+;,"
#define USERNAME_ILLEGAL_CHARS  L"\"/:|<>?" CTRL_CHARS_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |      
//
#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR L"\"*+,/:;<=>?[\\]|"

//
// Characters which may not appear in a canonicalized HPFS filename are:
//  0x00 - 0x1f " * / : < > ? \ |
//
#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR L"\"*/:<>?\\|"


//
// Checks if the token contains all valid characters
//
#define IS_VALID_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), STANDARD_ILLEGAL_CHARS) == (_StrLen)))

//
// Checks if the server name contains all valid characters for the server name
//
#define IS_VALID_SERVER_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), SERVER_ILLEGAL_CHARS) == (_StrLen)))
        
//
// Checks if the token contains all valid characters
//
#define IS_VALID_USERNAME_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), USERNAME_ILLEGAL_CHARS) == (_StrLen)))

//
// A remote entry for every unique shared resource name (\\server\share)
// of explicit connections.
//
typedef struct _UNC_NAME {
    
    DWORD TotalUseCount;
    
    DWORD UncNameLength;
    
    LPWSTR UncName[1];

} UNC_NAME, *PUNC_NAME;

//
// A DAV use entry in the linked list of connections.
//
typedef struct _DAV_USE_ENTRY {
    
    struct _DAV_USE_ENTRY *Next;

    BOOL isPassport;
    
    PUNC_NAME Remote;
    
    LPWSTR Local;
    
    DWORD LocalLength;
    
    DWORD UseCount;

    HANDLE DavCreateFileHandle;
    
    LPWSTR TreeConnectStr;

    LPWSTR AuthUserName;

    DWORD AuthUserNameLength;

} DAV_USE_ENTRY, *PDAV_USE_ENTRY;
    
typedef struct _DAV_PER_USER_ENTRY {

    //
    // Pointer to linked list of user data.
    //
    PVOID List;             

    //
    // Logon Id of user.
    //
    LUID LogonId;

} DAV_PER_USER_ENTRY, *PDAV_PER_USER_ENTRY;

typedef struct _DAV_USERS_OBJECT {
    
    //
    // Table of users.
    //
    PDAV_PER_USER_ENTRY Table;
    
    //
    // To serialize access to Table.
    //
    RTL_RESOURCE TableResource;
    
    //
    // Relocatable Table memory.
    //
    HANDLE TableMemory;
    
    //
    // Size of Table.
    //
    DWORD TableSize;

} DAV_USERS_OBJECT, *PDAV_USERS_OBJECT;

#define DAV_GROW_USER_COUNT   3

//
// The structure that contains a list of shares of a DAV server.
//
typedef struct _DAV_SERVER_SHARE_ENTRY {

    //
    // Name of the server.
    //
    PWCHAR ServerName;

    //
    // The list of structures containing the Dav shares.
    //
    PDAV_FILE_ATTRIBUTES DavShareList;

    //
    // Number of shares.
    //
    ULONG NumOfShares;

    //
    // The next entry.
    //
    LIST_ENTRY ServerShareEntry;

    //
    // The timer value used in the checking if we need to go to the server
    // again to get the list of shares.
    //
    time_t TimeValueInSec;

    //
    // This should be the last field.
    //
    WCHAR StrBuffer[1];

} DAV_SERVER_SHARE_ENTRY, *PDAV_SERVER_SHARE_ENTRY;

#define SERVER_SHARE_TABLE_SIZE 512

extern LIST_ENTRY ServerShareTable[SERVER_SHARE_TABLE_SIZE];

//
// This critical section synchronizes access to the ServerHashTable.
//
extern CRITICAL_SECTION ServerShareTableLock;

#endif // _VALIDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\uniutf.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UniUtf.cpp
    
Abstract:

    This file implements the Unicode object name to/from Utf8-URL coversion

Author:

    Mukul Gupta        [Mukgup]      20-Dec-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "UniUtf.h"

/*++
 * UTF8-URL  format and UNICODE Conversion Information:
 * 
    UTF8-URL is expected to have printable ASCII characters only (0-127 value characters)
    For extended characters (>127), they are converted into PrecentageStreams which will
    contain printable ASCII chars only. Sometimes special printable ASCII characters also
    converted to percentage streams to escape their special meanings (like 'Space')

    Percentage Streams: Every extended char can be converted to a type of printable ASCII 
    characters stream using UTF-8 encoding. These streams are of either of 3 formats:

    1. %HH (only for special chars <= 127)
    2. %HH%HH (for chars >127, <= 2047)
    3. %HH%HH%HH (for chars > 2048, <= 65535)
        H=A hexa-digit in {0-9,a-f,A-F}
            
    Any "%HH" is just a representation of a byte HH
        
    So a bytevalue = 32 base10 = 0001 0000 base2 = 0x20 = "%20" in UTF8-URL = Space

    For example:
        Space=%20
        =%C3%87
    
    Conversion scheme:
            UNICODE                            UTF-8(Byte Stream)        (UTF-8 URL)
        1. 0000000000000000..0000000001111111: 0xxxxxxx                    =>"%HH"
        2. 0000000010000000..0000011111111111: 110xxxxx 10xxxxxx           =>"%HH%HH"
        3. 0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx  =>"%HH%HH%HH"
    
        To know the format number of a percentage stream, check first 'H' after first '%'.

    If it is of format 0xxx (0-7), then stream is of format 1, bytelength = 1
    If it is of format 10xx (8-11), then stream is invalid
    If it is of format 110x (12-13), then stream is of format 2, bytelength = 2
    If it is of format 1110 (14), then stream is of format 3, bytelength = 3
    If it is of format 1111 (15), then stream is invalid

    Bits placement scheme: when converting between Unicode and UTf-8 ByteStream
    0xxx xxxx <=> 0000 0000 0xxx xxxx
    110x xxxx 10xx xxxx <=> 0000 0xxx xxxx xxxx
    1110 xxxx 10xx xxxx 10xx xxxx <=> xxxx xxxx xxxx xxxx
    
++*/

//
// This array maps special characters in printable ASCII char set to their equivalent 
// Percent strings in UTF-8 encoding. 
// URL don't allow many of the printable ASCII special characters so any such character
// in unicode filename string need to be converted to equvialent percent string.
// This table is used to speed up the conversion job else it will be very slow.
// 
WCHAR    EquivPercentStrings[128][4]={
    // Special character=NULL character
    L"", 
    // Special characters from 1-44
    L"%01", L"%02", L"%03", L"%04", L"%05", L"%06", L"%07", L"%08", L"%09",
    L"%0A", L"%0B", L"%0C", L"%0D", L"%0E", L"%0F", L"%10", L"%11", L"%12", L"%13",
    L"%14", L"%15", L"%16", L"%17", L"%18", L"%19", L"%1A", L"%1B", L"%1C", L"%1D",
    L"%1E", L"%1F", L"%20", L"%21", L"%22", L"%23", L"%24", L"%25", L"%26", L"%27",
    L"%28", L"%29", L"*", L"%2B", L"%2C", 
    // Valid printable characters from 45-57 
    L"-", L".", L"/", 
    L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", L"8", L"9", 
    // Special characters from 58-64
    L":", L"%3B", L"%3C", L"%3D", L"%3E", L"%3F", L"%40", 
    // Valid printable characters from 65-90 ('A'-'Z')
    L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", 
    L"N", L"O", L"P", L"Q", L"R", L"S", L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", 
    // Special character 91
    L"%5B",
    // Valid Printable character 92
    L"\\", 
    // Special characters 93-94
    L"%5D", L"%5E", 
    // Valid Printable character 95
    L"_", 
    // Special character 96
    L"%60", 
    // Valid printable Characters from 97-122 ('a'-'z')
    L"a", L"b", L"c", L"d", L"e", L"f", L"g", L"h", L"i", L"j", L"k", L"l", L"m", 
    L"n", L"o", L"p", L"q", L"r", L"s", L"t", L"u", L"v", L"w", L"x", L"y", L"z", 
    // Special characters from 123-127
    L"%7B", L"%7C", L"%7D", L"%7E", L"%7F"
};

// 
// Table To map HexaChars to HexaValue
// First 'H' after '%' (in URL) will be mapped to equivalent hexa-digit using this array
// If 'H' is not a valid hexa-digit, then it will be mapped to 0x10
// which can be used to indicate Invalid-HexaDigit.
//
BYTE    WCharToByte[128] = {
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,   // 0 - 47
    0,1,2,3,4,5,6,7,8,9, // 48-57  '0'-'9'   //HEXA CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10, //58-64
    0x0A,0x0B,0x0C,0x0D,0x0E,0x0F, //65-70  'a'-'f' // HEXA-CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10, // 71-96
    0x0A,0x0B,0x0C,0x0D,0x0E,0x0F, //97-102  'A'-'F' // HEXA-CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10 // 103-127
};


HRESULT
UtfUrlStrToWideStr(
    IN LPWSTR UtfStr, 
    IN DWORD UtfStrLen, 
    OUT LPWSTR WideStr, 
    OUT LPDWORD pWideStrLen
    )
/*++
Routine Description:

    Convert a URL in UTF-8 format to UNICODE characters:

Arguments:

    UtfStr - Input string- UTF-8 format URL

    UtfStrLen - Length of UtfStr to convert
    
    WideStr - pointer to buffer which will receive output=converted unicode string

    pWideStrLen - pointer to receive number of WIDE CHARS in output
                  This can be NULL

Returns:
    It Returns the WIN32 error
    and ERROR_SUCCESS on success.

Assumption: 
    The length of output buffer (WideStr) is enough to hold output string 
    Help: It is always <= UtfStrlen

Algorithm:
    (first go thru information about UTF-8 URL <-> UNICODE conversion given above)

    Go character by character through UTF-8 URL
        If character is not '%', then it is printable ASCII char, copy it to output
        and move to next char in input buffer
        else
        It is starting of a new PercentageStream
        Convert first 'H' to equivalent hexa-digit. From first-hexa digit, findout
        what is format type of percentage-stream and what will be its length. 
        Now parse the expected length of percentage stream in input buffer and 
        convert them into unicode format (using conversion scheme told above).
        Move to first char after last character of percentage stream
++*/
{
    // 
    // Table To find percentage stream byte length using first hexa-digit of 
    // percentage stream. This hexa-digit is returned by mapping array WCharToByte.
    //
    BYTE        PercentStreamByteLen[17]={
        1,1,1,1,1,1,1,1,  // 0***  => %HH
        0, 0, 0, 0, // 10**        => Invalid Percentage stream
        2, 2, // 110*              => %HH%HH
        3, // 1110                 => %HH%HH%HH
        0, //1111                  => Invalid Percentage stream
        0}; //0x10                 => Invalid Percentage stream

    DWORD       PosInInpBuf = 0, PosInOutBuf = 0;
    BYTE        ByteValue = 0;
    DWORD       WStatus = ERROR_SUCCESS;
 
    //
    // Check for invalid parameters.
    // 
    if(WideStr == NULL || UtfStr == NULL || UtfStrLen <=0) {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr. Invalid parameters. ErrorVal=%u",
                WStatus));
        return WStatus;
    }

    //
    // Go thru every character in the input buffer.
    // 
    while(PosInInpBuf<UtfStrLen) {

        // 
        // If it is not %, then it is a printable ASCII char, copy it to output
        // buffer as it is.
        // 
        if(UtfStr[PosInInpBuf] != L'%') {
            WideStr[PosInOutBuf] = UtfStr[PosInInpBuf];
            PosInOutBuf++;
            PosInInpBuf++;
            continue;
        }

        //
        // It is start of new percentage stream.
        // 
        if(PosInInpBuf+1 == UtfStrLen) {
            //
            // Error in string (unexpected end)- bad string.
            // 
            WStatus = ERROR_NO_UNICODE_TRANSLATION;
            DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:1: No unicode translation. ErrorVal=%u",
                    WStatus));
            return WStatus;
        }

        //
        // Verify input string for various bad forms but 
        // Not verifying whether the characters in UtfStr after '%' are 
        // printable ASCII set (0-127) characters only (assuming they are!). 
        // Using a crash-safe approach=>(char & 0x7F) will return value in (0-127) only.
        //
        ByteValue = WCharToByte[UtfStr[PosInInpBuf+1]&0x7F];
        
        switch(PercentStreamByteLen[ByteValue]) {
            case 1:

                //
                // One byte UTF-8 (%HH). %20 = blanks fall in this category.
                // Check for string length.
                // 
                if(PosInInpBuf+2 >= UtfStrLen) {
                    // 
                    // Error in string (unexpected end) - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:2: No unicode translation. ErrorVal=%d",
                             WStatus));
                    return WStatus;
                }

                WideStr[PosInOutBuf] = 
                (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+1]&0x7F]&0x0007)<<4 | 
                        (WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F);
        
                PosInOutBuf++;
                PosInInpBuf+=3;
                break;
            case 2:

                // 
                // Two byte UTF-8 (most common) (%HH%HH).
                // Check string length.
                // 
                if(PosInInpBuf+5 >= UtfStrLen || UtfStr[PosInInpBuf+3] != L'%') {
                    // 
                    // Error in string - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:3: No unicode translation. ErrorVal=%d",
                              WStatus));
                    return WStatus;
                }
    
                WideStr[PosInOutBuf] = 
                (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+1]&0x7F]&0x0001)<<10 | 
                        (WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F)<<6 | 
                        (WCharToByte[UtfStr[PosInInpBuf+4]&0x7F]&0x0003)<<4 |
                        (WCharToByte[UtfStr[PosInInpBuf+5]&0x7F]&0x000F);

                PosInOutBuf++;
                PosInInpBuf+=6;
                break;
            case 3:

                // 
                // Three byte UTF-8 (less common) (%HH%HH%HH).
                // Check for string length.
                // 
                if(PosInInpBuf+8 >= UtfStrLen || 
                        UtfStr[PosInInpBuf+3] != L'%' ||
                        UtfStr[PosInInpBuf+6] != L'%') {
                    // 
                    // Error in string - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:4: No unicode translation. ErrorVal=%d",
                            WStatus));
                    return WStatus;
                }

                WideStr[PosInOutBuf] = 
                    (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F)<<12 | 
                        (WCharToByte[UtfStr[PosInInpBuf+4]&0x7F]&0x0003)<<10 | 
                        (WCharToByte[UtfStr[PosInInpBuf+5]&0x7F]&0x000F)<<6 |
                        (WCharToByte[UtfStr[PosInInpBuf+7]&0x7F]&0x0003)<<4 |
                        (WCharToByte[UtfStr[PosInInpBuf+8]&0x7F]&0x000F);

                PosInOutBuf++;
                PosInInpBuf+=9;
                break;
            default: 

                // 
                // PercentageStreamByteLen = 0 comes here.
                // Error in string - bad string.
                // 
                WStatus = ERROR_NO_UNICODE_TRANSLATION;
                DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:5: No unicode translation. ErrorVal=%d",
                        WStatus));
                return WStatus;
            };
    }

    if(pWideStrLen) {
        *pWideStrLen = PosInOutBuf;
    }

    WStatus = ERROR_SUCCESS;
    return WStatus;
}


DWORD
WideStrToUtfUrlStr(
    IN    LPWSTR WideStr, 
    IN    DWORD WideStrLen, 
    IN OUT LPWSTR InOutBuf,
    IN    DWORD InOutBufLen
    )
/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8 URL:

Arguments:

    WideStr - pointer to input wide-character string

    WideStrLen - number of WIDE CHARS in input string

    InOutBuf - Converted string will be copied to this buffer if, this is not null,
               and InOutBufLen >= required length for converted string.
    
    InOutBufLen - Length of InOutBuf in WIDE CHARS
    
           If InOutBuf is not sufficient to contain converted string - Only
           the length of the converted string will be returned, and LastError is set to
           ERROR_INSUFFICIENT_BUFFER

Returns:

    It returns the Length of converted string in WCHARS
    In case of error - it returns 0, check GetLastError()
    If buffer is small for converted string then GetLastError is set to 
    ERROR_INSUFFICIENT_BUFFER

Algorithm:

    (first go thru information about UTF-8 URL <-> UNICODE conversion given above)

    Go thru each char in input buffer:
    If it is printable ASCII char, then 
        If it is special character, then copy its equivalent percent string
    else
    copy the character as it is
    else
        Find out to which percentage stream format it will convert to.
    Convert it using conversion scheme given above

Note: 

++*/
{
    LPWSTR       UtfUrlStr = NULL;
    DWORD        UrlLen = 0;
    WCHAR        HexDigit[17] = L"0123456789ABCDEF";
    WCHAR        WCharValue = 0;
    DWORD        PosInInpBuf = 0;
    DWORD        WStatus = ERROR_SUCCESS;


    WStatus = ERROR_SUCCESS;
    SetLastError(WStatus);

    // 
    // Check for valid parameters.
    // 
    if(WideStr == NULL || WideStrLen <=0) {
        WStatus = ERROR_INVALID_PARAMETER;
        SetLastError(WStatus);
        DavPrint((DEBUG_ERRORS, "WideStrToUtfUrlStr. Invalid parameters. ErrorVal=%d",
                    WStatus));
        return 0;
    }
    DavPrint((DEBUG_MISC,"WideStrToUtfUrlStr: WideStr=%ws, WideStrLen=%d\n", 
                WideStr, WideStrLen));

    // 
    // Calculate required length in WCHARS for storing converted string
    // Check from every unicode char - to which PercentageStream format it 
    // will convert to.
    // 
    for(PosInInpBuf = 0;PosInInpBuf<WideStrLen;PosInInpBuf++) {
        if(WideStr[PosInInpBuf] < 0x80) {
            // 
            // (0-127) => Printable ASCII char. Special characters in this range need
            // to be converted to equivalent percent strings
            // 
            // 
            // If character is NULL, then its equivalent string is L"". wcslen returns
            // 0 for this string so add 1 to UrlLen to account for this NULL character
            // 
            if(WideStr[PosInInpBuf] == 0)
               UrlLen += 1;
            else
               UrlLen += wcslen(&EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]);
        } else {
            if(WideStr[PosInInpBuf] < 0x0800) {
                //
                //( >127, <=2047) => "%HH%HH".
                //
                UrlLen += 6; 
            } else {
                //
                //( >2047, <=65535) => "%HH%HH%HH%HH".
                //
                UrlLen += 9; 
            }
        }
    }

    // 
    // If InOutBuf is not sufficient to contain the converted string then
    // required length of converted string is returned
    // 
    if(InOutBuf == NULL || InOutBufLen < UrlLen) {
        // 
        // Only converted string length is returned.
        // 
        WStatus = ERROR_INSUFFICIENT_BUFFER;
        SetLastError(WStatus);
        return UrlLen;
    }


    //
    // InOutBuf is sufficiently long enough to contain converted string, use it.
    //
    ASSERT(InOutBuf != NULL);
    ASSERT(InOutBufLen >= UrlLen);

    //
    // InOutBuf is long enough to contain converted string
    //
    UtfUrlStr = InOutBuf;

    // 
    // Check from every unicode char - to which PercentageStream format it 
    // will convert to.
    // 
    UrlLen=0;
    for(PosInInpBuf = 0;PosInInpBuf<WideStrLen;PosInInpBuf++) {
        if(WideStr[PosInInpBuf] < 0x80) {
            // 
            // (0-127) => Printable ASCII char. Special characters in this range need
            // to be converted to equivalent percent strings
            // 
            wcscpy(&UtfUrlStr[UrlLen], &EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]); 
            // 
            // If character is NULL, then its equivalent string is L"". wcslen returns
            // 0 for this string so add 1 to UrlLen to account for this NULL character
            // 
            if(WideStr[PosInInpBuf] == 0)
               UrlLen += 1;
            else
               UrlLen += wcslen(&EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]); 
        } else {
            if(WideStr[PosInInpBuf] < 0x0800) {
                // 
                // ( >127, <=2047) => "%HH%HH".
                // First %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x00C0 |             // 1100 0000
                    ((WideStr[PosInInpBuf] & 0x07C0)>>6); // Top 5 bits if UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4];    //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];       //H2
                //
                // Second %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 |                // 1000 0000 
                    (WideStr[PosInInpBuf] & 0x003F); // Last 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4];    //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];       //H2
            } else {
                // 
                // ( >2047, <=65535) => "%HH%HH%HH%HH".
                // First %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x00E0 |              // 1110 0000
                    ((WideStr[PosInInpBuf] & 0xF000)>>12); // Top 4 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
                //
                // Second %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 | // 1000 0000
                    ((WideStr[PosInInpBuf] & 0x0FC0)>>6); // Next 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
                // 
                // Third %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 | // 1000 0000
                    (WideStr[PosInInpBuf] & 0x003F);    // Last 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
            }
        }
    }

    DavPrint((DEBUG_MISC,"WideStrToUtfUrlStr: WideStr=%ws, WideStrLen=%d, UtfUrlStr=%ws, UrlLen=%d\n",
                WideStr, WideStrLen, UtfUrlStr, UrlLen));

    //
    // The converted string is stored in InOutBuf
    //

    WStatus = ERROR_SUCCESS;
    SetLastError(WStatus);
    return UrlLen;
}

BOOL
DavHttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPWSTR lpszVerb,
    IN LPWSTR lpszObjectName,
    IN LPWSTR lpszVersion,
    IN LPWSTR lpszReferer,
    IN LPWSTR FAR * lpszAcceptTypes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN LPWSTR ErrMsgTag,
    OUT HINTERNET * phInternet
    )
/*++
Routine Description:

    Convert a URL in UNICODE characters, to UTF-8 URL encoded format and use it in
    call to HttpOpenRequestW

Arguments:
    hConnect:
    lpszVerb:
    lpszVersion:
    lpszReferer:
    lpszAcceptTypes:
    dwFlags:
    dwContext:
                These parameters are to be passed to HttpOpenRequestW as it is.

    lpszObjectName: This parameter is the URL in unicode charaters - which will
                    be converted to UTF-8 URL format. Then converted format will 
                    be passed to HttpOpenRequestW
        
    ErrMsgTag: Any message tag to be printed along with debug messages.
    phInternet: Pointer that will receive the Handle returned by HttpOpenRequestW. If this
                parameter is NULL, then it will not be set

Returns:

    TRUE if HttpOpenRequestW is called. Check GetLastError() for error status from call.

    FALSE, if it could not call HttpOpenRequestW. Check GetLastError() for error.

Note: It don't process return status of HttpOpenRequestW. Check GetLastError() for error
      set by HttpOpenRequestW.

++*/
{
    LPWSTR       AllocUrlPath = NULL;
    HINTERNET    hInternet = NULL;
    DWORD        WStatus = ERROR_SUCCESS;
    BOOL         rval = FALSE;
    DWORD        convLen = 0;
    DWORD        ObjNameLen = 0;
    WCHAR        LocalUrlPath[128]=L"";
    LPWSTR       UrlPath = NULL;
    WCHAR        EmptyStrW[1]=L"";

    //
    // This error msg tag is just a string which a calling function might want to print 
    // along with the error messages printed inside this function
    //
    // Ex. Suppose FunctionA calls this function, then it can pass L"FunctionA" to print
    // along with error messages. Looking at the error mesg, a user can know that this 
    // function was called in FunctionA
    // 
    if(ErrMsgTag == NULL) {
            ErrMsgTag = EmptyStrW;
    }

    // 
    // Convert the unicode objectname to UTF-8 URL format
    // space and other white (special) characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    UrlPath = NULL;
    AllocUrlPath = NULL;
    ObjNameLen = wcslen(lpszObjectName)+1; // To take care of NULL char add 1 to length
    
    convLen = WideStrToUtfUrlStr(lpszObjectName, 
                    ObjNameLen, 
                    LocalUrlPath, 
                    sizeof(LocalUrlPath)/sizeof(WCHAR));
    WStatus = GetLastError();
    
    if(WStatus == ERROR_INSUFFICIENT_BUFFER) {
        
        ASSERT(convLen > 0);
        // 
        // Buffer passed to function WideStrToUtfUrlStr is small, need to allocate
        // new buffer of required length. The required length is returned by this function.
        // 
        AllocUrlPath = (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                            convLen*sizeof(WCHAR));
        if(AllocUrlPath == NULL) {
            // 
            // LocalAlloc sets Last error.
            // 
            WStatus = GetLastError();
            rval = FALSE;
            DavPrint((DEBUG_ERRORS, "%ws.DavHttpOpenRequestW/LocalAlloc failed. ErrorVal=%d",
                    ErrMsgTag, WStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // Call the function WideStrToUtfUrlStr with new allocated buffer (this buffer should
        // be sufficient to contain output coverted string
        //
        convLen = WideStrToUtfUrlStr(lpszObjectName, 
                             ObjNameLen, 
                             AllocUrlPath, 
                             convLen);
         WStatus = GetLastError();
    }

    if(WStatus != ERROR_SUCCESS) {
        rval = FALSE;
        DavPrint((DEBUG_ERRORS,"%ws.DavHttpOpenRequest/WideStrToUtfUrlStr. Error Val = %d\n", 
            ErrMsgTag, WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If converted string is stored in allocated buffer, then set UrlPath to point to 
    // buffer allocated else output string is stored in local buffer, so point UrlPath to it.
    //
    if (AllocUrlPath != NULL) {
        UrlPath = AllocUrlPath;
    } else {
        UrlPath = LocalUrlPath;
    }

    // 
    // Call to HttpOpenRequestW with converted URL.
    // 
    hInternet = HttpOpenRequestW(hConnect,
                                 lpszVerb,
                                 UrlPath,
                                 lpszVersion,
                                 lpszReferer,
                                 lpszAcceptTypes,
                                 dwFlags,
                                 dwContext);
    rval = TRUE;
    WStatus = GetLastError();
        
EXIT_THE_FUNCTION:
    //
    // Free UrlPath allocated in successful call to function WideStrToUtfUrlStr.
    //
    if(AllocUrlPath != NULL) {
        LocalFree((HANDLE)AllocUrlPath);
        AllocUrlPath = NULL;
        UrlPath = NULL;
    }

    if(phInternet) {
        *phInternet = hInternet;
    }
    
    //
    // We set the last error here because the caller of this function is expected
    // call GetLastError() to get the error status.
    //
    SetLastError(WStatus);
    
    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\utils.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Grab bag of functions used by the web dav mini-redir client service.

Author:

    Andy Herron (andyhe) 29-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"

//
// These tables translate wininet codes to the closest ntstatus codes. There are 
// two because there are some errors in wininet which come from ftp and gopher 
// which are not relevant to us.
//
typedef struct tagHTTP_TO_NTSTATUS_MAPPING {
    DWORD dwHttpError;
    NTSTATUS Status;
} HTTP_TO_NTSTATUS_MAPPING;

typedef struct tagWIN32_TO_NTSTATUS_MAPPING {
    DWORD dwWin32Error;
    NTSTATUS NtStatus;
} WIN32_TO_NTSTATUS_MAPPING;

HTTP_TO_NTSTATUS_MAPPING rgHttpToNtstatus1[] = {
     ERROR_INTERNET_OUT_OF_HANDLES           ,STATUS_INSUFFICIENT_RESOURCES     // (INTERNET_ERROR_BASE + 1) 
    ,ERROR_INTERNET_TIMEOUT                  ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 2) 
    ,ERROR_INTERNET_EXTENDED_ERROR           ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 3) 
    ,ERROR_INTERNET_INTERNAL_ERROR           ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 4) 
    ,ERROR_INTERNET_INVALID_URL              ,STATUS_OBJECT_NAME_INVALID        // (INTERNET_ERROR_BASE + 5) 
    ,ERROR_INTERNET_UNRECOGNIZED_SCHEME      ,STATUS_OBJECT_NAME_INVALID        // (INTERNET_ERROR_BASE + 6) 
    ,ERROR_INTERNET_NAME_NOT_RESOLVED        ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 7) 
    ,ERROR_INTERNET_PROTOCOL_NOT_FOUND       ,STATUS_OBJECT_TYPE_MISMATCH       // (INTERNET_ERROR_BASE + 8) 
    ,ERROR_INTERNET_INVALID_OPTION           ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 9) 
    ,ERROR_INTERNET_BAD_OPTION_LENGTH        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 10)
    ,ERROR_INTERNET_OPTION_NOT_SETTABLE      ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 11)
    ,ERROR_INTERNET_SHUTDOWN                 ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 12)
    ,ERROR_INTERNET_INCORRECT_USER_NAME      ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 13)
    ,ERROR_INTERNET_INCORRECT_PASSWORD       ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 14)
    ,ERROR_INTERNET_LOGIN_FAILURE            ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 15)
    ,ERROR_INTERNET_INVALID_OPERATION        ,STATUS_INVALID_DEVICE_REQUEST     // (INTERNET_ERROR_BASE + 16)
    ,ERROR_INTERNET_OPERATION_CANCELLED      ,STATUS_CANCELLED                  // (INTERNET_ERROR_BASE + 17)
    ,ERROR_INTERNET_INCORRECT_HANDLE_TYPE    ,STATUS_INVALID_HANDLE             // (INTERNET_ERROR_BASE + 18)
    ,ERROR_INTERNET_INCORRECT_HANDLE_STATE   ,STATUS_INVALID_HANDLE             // (INTERNET_ERROR_BASE + 19)
    ,ERROR_INTERNET_NOT_PROXY_REQUEST        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 20)
    ,ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND ,STATUS_OBJECT_NAME_NOT_FOUND      // (INTERNET_ERROR_BASE + 21)
    ,ERROR_INTERNET_BAD_REGISTRY_PARAMETER   ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 22)
    ,ERROR_INTERNET_NO_DIRECT_ACCESS         ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 23)
    ,ERROR_INTERNET_NO_CONTEXT               ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 24)
    ,ERROR_INTERNET_NO_CALLBACK              ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 25)
    ,ERROR_INTERNET_REQUEST_PENDING          ,STATUS_PENDING                    // (INTERNET_ERROR_BASE + 26)
    ,ERROR_INTERNET_INCORRECT_FORMAT         ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 27)
    ,ERROR_INTERNET_ITEM_NOT_FOUND           ,STATUS_OBJECT_PATH_NOT_FOUND      // (INTERNET_ERROR_BASE + 28)
    ,ERROR_INTERNET_CANNOT_CONNECT           ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 29)
    ,ERROR_INTERNET_CONNECTION_ABORTED       ,STATUS_REQUEST_ABORTED            // (INTERNET_ERROR_BASE + 30)
    ,ERROR_INTERNET_CONNECTION_RESET         ,STATUS_CONNECTION_RESET           // (INTERNET_ERROR_BASE + 31)
    ,ERROR_INTERNET_FORCE_RETRY              ,STATUS_RETRY                      // (INTERNET_ERROR_BASE + 32)
    ,ERROR_INTERNET_INVALID_PROXY_REQUEST    ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 33)
    ,ERROR_INTERNET_NEED_UI                  ,STATUS_ACCESS_DENIED              // (INTERNET_ERROR_BASE + 34)
    };
    
HTTP_TO_NTSTATUS_MAPPING rgHttpToNtstatus2[] = {
     ERROR_HTTP_HEADER_NOT_FOUND             ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 150)
    ,ERROR_HTTP_DOWNLEVEL_SERVER             ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 151)
    ,ERROR_HTTP_INVALID_SERVER_RESPONSE      ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 152)
    ,ERROR_HTTP_INVALID_HEADER               ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 153)
    ,ERROR_HTTP_INVALID_QUERY_REQUEST        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 154)
    ,ERROR_HTTP_HEADER_ALREADY_EXISTS        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 155)
    ,ERROR_HTTP_REDIRECT_FAILED              ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 156)
    ,ERROR_INTERNET_SECURITY_CHANNEL_ERROR   ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 157)
    ,ERROR_INTERNET_UNABLE_TO_CACHE_FILE     ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 158)
    ,ERROR_INTERNET_TCPIP_NOT_INSTALLED      ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 159)
    ,ERROR_HTTP_NOT_REDIRECTED               ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 160)
    ,ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION    ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 161)
    ,ERROR_HTTP_COOKIE_DECLINED              ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 162)
    ,ERROR_INTERNET_DISCONNECTED             ,STATUS_CONNECTION_DISCONNECTED    // (INTERNET_ERROR_BASE + 163)
    ,ERROR_INTERNET_SERVER_UNREACHABLE       ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 164)
    ,ERROR_INTERNET_PROXY_SERVER_UNREACHABLE ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 165)
    ,ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT     ,STATUS_DEVICE_CONFIGURATION_ERROR// (INTERNET_ERROR_BASE + 166)
    ,ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT ,STATUS_INTERNAL_ERROR            // (INTERNET_ERROR_BASE + 167)
    ,ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   ,STATUS_NETWORK_SESSION_EXPIRED   // (INTERNET_ERROR_BASE + 168)
    ,ERROR_INTERNET_SEC_INVALID_CERT          ,STATUS_ACCESS_DENIED             // (INTERNET_ERROR_BASE + 169)
    ,ERROR_INTERNET_SEC_CERT_REVOKED          ,STATUS_ACCESS_DENIED             // (INTERNET_ERROR_BASE + 170)
    };

WIN32_TO_NTSTATUS_MAPPING rgWin32ToNtStatus [] = {

    ERROR_SUCCESS, STATUS_SUCCESS                            // 0L

    ,ERROR_INVALID_FUNCTION, STATUS_NOT_IMPLEMENTED          // 1L

    ,ERROR_FILE_NOT_FOUND, STATUS_OBJECT_NAME_NOT_FOUND      // 2L

    ,ERROR_PATH_NOT_FOUND, STATUS_OBJECT_PATH_NOT_FOUND      // 3L

    ,ERROR_TOO_MANY_OPEN_FILES, STATUS_TOO_MANY_OPENED_FILES // 4L

    ,ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED               // 5L

    ,ERROR_INVALID_HANDLE, STATUS_INVALID_HANDLE             // 6L

    ,ERROR_ARENA_TRASHED, STATUS_UNSUCCESSFUL                // 7L

    ,ERROR_NOT_ENOUGH_MEMORY, STATUS_INSUFFICIENT_RESOURCES  // 8L

    ,ERROR_INVALID_BLOCK, STATUS_UNSUCCESSFUL                // 9L

    ,ERROR_BAD_ENVIRONMENT, STATUS_UNSUCCESSFUL              // 10L

    ,ERROR_BAD_FORMAT, STATUS_UNSUCCESSFUL                   // 11L

    ,ERROR_INVALID_ACCESS, STATUS_UNSUCCESSFUL               // 12L

    ,ERROR_INVALID_DATA, STATUS_UNSUCCESSFUL                 // 13L

    ,ERROR_OUTOFMEMORY, STATUS_UNSUCCESSFUL                  // 14L

    ,ERROR_INVALID_DRIVE, STATUS_UNSUCCESSFUL                // 15L

    ,ERROR_CURRENT_DIRECTORY, STATUS_UNSUCCESSFUL            // 16L

    ,ERROR_NOT_SAME_DEVICE, STATUS_UNSUCCESSFUL              // 17L

    ,ERROR_NO_MORE_FILES, STATUS_UNSUCCESSFUL                // 18L

    ,ERROR_WRITE_PROTECT, STATUS_UNSUCCESSFUL                // 19L

    ,ERROR_BAD_UNIT, STATUS_UNSUCCESSFUL                     // 20L

    ,ERROR_NOT_READY, STATUS_UNSUCCESSFUL                    // 21L

    ,ERROR_BAD_COMMAND, STATUS_UNSUCCESSFUL                  // 22L

    ,ERROR_CRC, STATUS_UNSUCCESSFUL                          // 23L

    ,ERROR_BAD_LENGTH, STATUS_UNSUCCESSFUL                   // 24L

    ,ERROR_SEEK, STATUS_UNSUCCESSFUL                         // 25L

    ,ERROR_NOT_DOS_DISK, STATUS_UNSUCCESSFUL                 // 26L

    ,ERROR_SECTOR_NOT_FOUND, STATUS_UNSUCCESSFUL             // 27L

    ,ERROR_OUT_OF_PAPER, STATUS_UNSUCCESSFUL                 // 28L

    ,ERROR_WRITE_FAULT, STATUS_UNSUCCESSFUL                  // 29L

    ,ERROR_READ_FAULT, STATUS_UNSUCCESSFUL                   // 30L

    ,ERROR_GEN_FAILURE, STATUS_UNSUCCESSFUL                  // 31L

    ,ERROR_SHARING_VIOLATION, STATUS_SHARING_VIOLATION       // 32L

    ,ERROR_LOCK_VIOLATION, STATUS_LOCK_NOT_GRANTED           // 33L

    ,ERROR_WRONG_DISK, STATUS_UNSUCCESSFUL                   // 34L
    
    ,0,0                                                     // 35L
    
    ,ERROR_SHARING_BUFFER_EXCEEDED, STATUS_UNSUCCESSFUL      // 36L
         
    ,0,0                                                     // 37L
    
    ,ERROR_HANDLE_EOF, STATUS_END_OF_FILE                    // 38L

    ,ERROR_HANDLE_DISK_FULL, STATUS_UNSUCCESSFUL             // 39L

};

//
// Implementation of functions begins here.
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    )
/*++

Routine Description:

    Read a DWORD value from the registry. If there is a problem then
    return the default value.
    
Arguments:

    KeyHandle - Handle of the key (value) being read.
    
    lpValueName - The value name.
    
    DefaultValue - The default value to return, if the name does not exists as
                   a value of the key handle.
                   
Return Value:                   

    Win32 error status.

--*/
{
    DWORD Value;
    DWORD ValueSize = sizeof(Value);
    DWORD ValueType;

    if ((KeyHandle) &&
        (RegQueryValueEx(KeyHandle,
                         lpValueName,
                         0,
                         &ValueType,
                         (PUCHAR)&Value,
                         &ValueSize ) == ERROR_SUCCESS )) {

        return Value;
    } else {
        return DefaultValue;
    }
}


VOID
UpdateServiceStatus (
    DWORD dwState
    )
/*++

Routine Description:

    This routines updates the service status.

Arguments:

    dwState - The state the service has to be updated to.

Return Value:

    none.

--*/
{
    if (g_registeredService) {
        ASSERT (g_hStatus);
        g_status.dwCurrentState = dwState;
        SetServiceStatus(g_hStatus, &g_status);
    } else {
        g_status.dwCurrentState = dwState;
    }
}


NET_API_STATUS
WsLoadRedir(
    VOID
    )
/*++

Routine Description:

    This loads, starts, and configures the kernel mini-redir.  If the redir
    is already loaded or started, it is not a fatal error.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    NET_API_STATUS err = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING DeviceName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOL driverAlreadyLoaded = FALSE;

    err = WsLoadDriver(DAVCLIENT_DRIVER);
    if (err == ERROR_SERVICE_ALREADY_RUNNING) {
        driverAlreadyLoaded = TRUE;
        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "WsLoadRedir/WsLoadDriver: Error Val = %08lx.\n", err));
        return err;
    }

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&(DeviceName), DD_DAV_DEVICE_NAME_U);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(DeviceName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenFile(&(DavRedirDeviceHandle),
                          SYNCHRONIZE,
                          &(ObjectAttributes),
                          &(IoStatusBlock),
                          FILE_SHARE_VALID_FLAGS,
                          FILE_SYNCHRONOUS_IO_NONALERT);
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS, "WsLoadRedir/NtOpenFile: Error Val = %08lx\n", NtStatus));
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
        return RtlNtStatusToDosError(NtStatus);
    }

    return ERROR_SUCCESS;
}


NET_API_STATUS
WsUnloadRedir(
    VOID
    )
/*++

Routine Description:

    This routine unloads the DAV driver. Calls the NtUnloadDriver function.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    LPWSTR DriverRegistryName;
    ULONG Privileges[1], DriverRegistryNameLength;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DriverRegistryNameLength = sizeof(SERVICE_REGISTRY_KEY);
    DriverRegistryNameLength += sizeof(DAVCLIENT_DRIVER);
    
    //
    // We need to make the DriverRegistryNameLength a multiple of 8. This is 
    // because DavAllocateMemory calls DebugAlloc which does some stuff which 
    // requires this. The equation below does this.
    //
    DriverRegistryNameLength = ( ( ( DriverRegistryNameLength + 7 ) / 8 ) * 8 );
    
    DriverRegistryName = (LPWSTR) DavAllocateMemory(DriverRegistryNameLength);
    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);
    if (Status != NERR_Success) {
        DavFreeMemory(DriverRegistryName);
        return Status;
    }

    if (DavRedirDeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(DavRedirDeviceHandle);
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DAVCLIENT_DRIVER);

    RtlInitUnicodeString(&(DriverRegistryString), DriverRegistryName);

    // Webclient should not unload the MRxDAV if it does not load it.

    DavFreeMemory(DriverRegistryName);

    NetpReleasePrivilege();

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    )
/*++

Routine Description:

    This routine loads the DAV driver. Calls the NtLoadDriver function.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    LPWSTR DriverRegistryName;
    ULONG Privileges[1], DriverRegistryNameLength;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DriverRegistryNameLength = sizeof(SERVICE_REGISTRY_KEY);
    DriverRegistryNameLength += ( wcslen(DriverNameString) * sizeof(WCHAR) );
    
    //
    // We need to make the DriverRegistryNameLength a multiple of 8. This is 
    // because DavAllocateMemory calls DebugAlloc which does some stuff which 
    // requires this. The equation below does this.
    //
    DriverRegistryNameLength = ( ( ( DriverRegistryNameLength + 7 ) / 8 ) * 8 );
    
    DriverRegistryName = (LPWSTR) DavAllocateMemory(DriverRegistryNameLength);
    if (DriverRegistryName == NULL) {
        DavPrint((DEBUG_ERRORS, "WsLoadDriver/DavAllocateMemory.\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);
    if (Status != NERR_Success) {
        DavPrint((DEBUG_ERRORS, "WsLoadDriver/NetpGetPrivilege.\n"));
        DavFreeMemory(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&(DriverRegistryString), DriverRegistryName);

    //
    // Webclient becomes a LocalService and can no longer load the MRxDAV. 
    // We make MRxDAV as a depend service of Webclient. Svchost will load it.
    //

    NetpReleasePrivilege();

    DavFreeMemory(DriverRegistryName);

    if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {
        
        LPWSTR  subString[1];
        subString[0] = DriverNameString;
        
        DavPrint((DEBUG_ERRORS, 
                  "WsLoadDriver/NtLoadDriver. NtStatus = %08lx\n", ntstatus));

#if 0
        DavReportEventW(NELOG_DriverNotLoaded,
                        EVENTLOG_ERROR_TYPE,
                        1,
                        sizeof(NTSTATUS),
                        subString,
                        &ntstatus);
#endif
    
    }

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    error code expected from calling a LAN Man API.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS) {
        return NERR_Success;
    }

    switch (NtStatus) {
        
    case STATUS_OBJECT_NAME_COLLISION:
        return ERROR_ALREADY_ASSIGNED;

    case STATUS_ACCESS_DENIED:
        return ERROR_ACCESS_DENIED;

    case STATUS_OBJECT_NAME_NOT_FOUND:
        return NERR_UseNotFound;

    case STATUS_IMAGE_ALREADY_LOADED:
    case STATUS_REDIRECTOR_STARTED:
        return ERROR_SERVICE_ALREADY_RUNNING;

    case STATUS_REDIRECTOR_HAS_OPEN_HANDLES:
        return ERROR_REDIRECTOR_HAS_OPEN_HANDLES;

    default:
        return NetpNtStatusToApiStatus(NtStatus);
    
    }

}


NTSTATUS
DavMapErrorToNtStatus(
    DWORD dwWin32Error
    )
/*++

Routine Description:

    This function takes an errorcode which is either a WinInet error code or
    a or a Win32 error code and converts it into an NTSTATUS value. It does the 
    following in the order mentioned below:
    
    1. Checks to see if the error code is a WinInet error code and if it is
       maps that to an NTSTATUS value. If not,
       
    2. Assumes that this is a Win32 error code and maps that to an NTSTATUS
       value.

Arguments:

    dwWin32Error - The win32 or wininet error code.
    
Return Value:

    Returns the most appropriate NtStatus value.

--*/
{
    int indexLast;

    DavPrint((DEBUG_MISC,
              "DavMapErrorToNtstatus. dwWin32Error = %08lx\n", dwWin32Error));
    
    //
    // Check if its a WinInet error.
    //
    if (dwWin32Error > INTERNET_ERROR_BASE && dwWin32Error <= INTERNET_ERROR_LAST) {
        
        indexLast = ( ( sizeof(rgHttpToNtstatus1) / sizeof(HTTP_TO_NTSTATUS_MAPPING) ) - 1 );
    
        if (dwWin32Error >= rgHttpToNtstatus1[0].dwHttpError && 
            dwWin32Error <= rgHttpToNtstatus1[indexLast].dwHttpError) {
            return rgHttpToNtstatus1[dwWin32Error-rgHttpToNtstatus1[0].dwHttpError].Status;
        }

        indexLast = ( ( sizeof(rgHttpToNtstatus2) / sizeof(HTTP_TO_NTSTATUS_MAPPING) ) - 1 );

        if (dwWin32Error >= rgHttpToNtstatus2[0].dwHttpError && 
            dwWin32Error <= rgHttpToNtstatus2[indexLast].dwHttpError) {
            return rgHttpToNtstatus2[dwWin32Error-rgHttpToNtstatus2[0].dwHttpError].Status;
        }
        
    } else if (dwWin32Error >= (DWORD)HTTP_STATUS_FIRST && dwWin32Error <= (DWORD)HTTP_STATUS_LAST) {

#if 0

        //
        // IMPORTANT!!!
        // We don't check for Http error codes here. This mapping is done in 
        // the DavMapHttpErrorToDosError function. The functions expecting a
        // Http response should call DavQueryAndParseResponse function.
        //

        //
        // Check if its a HTTP error code.
        //
        
        switch (dwWin32Error) {
            
        case HTTP_STATUS_CONTINUE:              // 100 OK to continue with request
                return STATUS_SUCCESS;               
                
        case HTTP_STATUS_SWITCH_PROTOCOLS:      // 101 server has switched protocols in upgrade header
            return STATUS_DEVICE_PROTOCOL_ERROR;
                
        case HTTP_STATUS_OK:                    // 200 // request completed
        case HTTP_STATUS_CREATED:               // 201 // object created, reason = new URI
        case HTTP_STATUS_ACCEPTED:              // 202 // async completion (TBS)
        case HTTP_STATUS_PARTIAL:               // 203 // partial completion
        case HTTP_STATUS_NO_CONTENT:            // 204 // no info to return
        case HTTP_STATUS_RESET_CONTENT:         // 205 // request completed, but clear form
        case HTTP_STATUS_PARTIAL_CONTENT:       // 206 // partial GET furfilled
        case DAV_MULTI_STATUS:                  // 207 // multi status response
            return STATUS_SUCCESS;



        case HTTP_STATUS_AMBIGUOUS:                 // 300 // server couldn't decide what to return
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_MOVED:                     // 301 // object permanently moved
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_REDIRECT:
            return STATUS_OBJECT_NAME_NOT_FOUND;    // 302 // object temporarily moved

        case HTTP_STATUS_REDIRECT_METHOD:         
            return STATUS_OBJECT_NAME_NOT_FOUND;     // 303 // redirection w/ new access method

        case HTTP_STATUS_NOT_MODIFIED:            
            return STATUS_SUCCESS;                  // 304 // if-modified-since was not modified

        case HTTP_STATUS_USE_PROXY:               
            return STATUS_HOST_UNREACHABLE;         // 305 // redirection to proxy, location header specifies proxy to use

        case HTTP_STATUS_REDIRECT_KEEP_VERB:      
            return STATUS_SUCCESS;                  // 307 // HTTP/1.1: keep same verb

        case HTTP_STATUS_BAD_REQUEST:               // 400 // invalid syntax
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_DENIED:                    // 401 // access denied
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_PAYMENT_REQ:               // 402 // payment required
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_FORBIDDEN:                 // 403 // request forbidden
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_NOT_FOUND:                 // 404 // object not found
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_BAD_METHOD:                // 405 // method is not allowed
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_NONE_ACCEPTABLE:           // 406 // no response acceptable to client found
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_PROXY_AUTH_REQ:            // 407 // proxy authentication required
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_REQUEST_TIMEOUT:           // 408 // server timed out waiting for request
            return STATUS_IO_TIMEOUT;

        case HTTP_STATUS_CONFLICT:                  // 409 // user should resubmit with more info
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_GONE:                      // 410 // the resource is no longer available
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_LENGTH_REQUIRED:           // 411 // the server refused to accept request w/o a length
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_PRECOND_FAILED:            // 412 // precondition given in request failed
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_REQUEST_TOO_LARGE:         // 413 // request entity was too large
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_URI_TOO_LONG:              // 414 // request URI too long
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_UNSUPPORTED_MEDIA:         // 415 // unsupported media type
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_RETRY_WITH:              // 449 // retry after doing the appropriate action.
            return STATUS_RETRY;

        case HTTP_STATUS_SERVER_ERROR:        // 500 // internal server error
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_NOT_SUPPORTED:         // 501 // required not supported
            return STATUS_NOT_SUPPORTED;

        case HTTP_STATUS_BAD_GATEWAY:           // 502 // error response received from gateway
            return STATUS_HOST_UNREACHABLE;

        case HTTP_STATUS_SERVICE_UNAVAIL:           // 503 // temporarily overloaded
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_GATEWAY_TIMEOUT:           // 504 // timed out waiting for gateway
            return STATUS_HOST_UNREACHABLE;

        case HTTP_STATUS_VERSION_NOT_SUP:           // 505 // HTTP version not supported
            return STATUS_NOT_SUPPORTED;

        //
        // WebDav specific status codes.
        //
        case DAV_STATUS_INSUFFICIENT_STORAGE:       // 507
            return STATUS_DISK_FULL;
        
        case DAV_STATUS_UNPROCESSABLE_ENTITY:       // 422
            return STATUS_INVALID_PARAMETER;

        case DAV_STATUS_LOCKED:                     // 423
            return STATUS_ACCESS_DENIED;
            
        case DAV_STATUS_FAILED_DEPENDENCY:          // 424
            return STATUS_INVALID_PARAMETER;
            
        default:
            break;                

        }

#endif
    
    }

    //
    // If none of the above match call this function which takes a Win32 error
    // and maps it to an NTSTATUS value.
    //
    return DavDosErrorToNtStatus(dwWin32Error);
}


NTSTATUS
DavDosErrorToNtStatus(
    DWORD dwError
    )
/*++

Routine Description:

    This function takes a win32 error code and converts to the closes NTSTATUS.
    As NTSTATUS->Win32Error is many to one mapping, there is a possible loss of 
    precision in this method of error reporting.

Arguments:

    dwError - The win32 error code.
    
Return Value:

    Returns the most appropriate NTSTATUS

--*/
{

    if (dwError < sizeof(rgWin32ToNtStatus)/sizeof(WIN32_TO_NTSTATUS_MAPPING)) {
        
        return rgWin32ToNtStatus[dwError].NtStatus;
    
    } else {
        
        switch (dwError) {
            
        case ERROR_BUFFER_OVERFLOW:
            return STATUS_BUFFER_OVERFLOW;

        case ERROR_NOT_SUPPORTED:
            return STATUS_NOT_SUPPORTED;

        case ERROR_DISK_FULL:
            return STATUS_DISK_FULL;

        case ERROR_FILE_EXISTS:
            return STATUS_OBJECT_NAME_EXISTS; 

        case ERROR_INVALID_PASSWORD:
            return STATUS_WRONG_PASSWORD;

        case ERROR_INVALID_PARAMETER:
            return STATUS_INVALID_PARAMETER;

        case ERROR_BAD_NETPATH:
            return STATUS_BAD_NETWORK_PATH;

        case ERROR_CALL_NOT_IMPLEMENTED:
            return STATUS_NOT_IMPLEMENTED;

        case ERROR_SEM_TIMEOUT:
            return STATUS_IO_TIMEOUT;

        case ERROR_INSUFFICIENT_BUFFER:
            return STATUS_BUFFER_TOO_SMALL;

        case ERROR_INVALID_NAME:
            return STATUS_OBJECT_NAME_INVALID;

        case ERROR_DIR_NOT_EMPTY:
            return STATUS_DIRECTORY_NOT_EMPTY;

        case ERROR_BUSY:
            return STATUS_DEVICE_BUSY;

        case ERROR_ALREADY_EXISTS:
            return STATUS_OBJECT_NAME_COLLISION;

        case ERROR_DIRECTORY:
            return STATUS_NOT_A_DIRECTORY;

        case ERROR_OPERATION_ABORTED:
            return STATUS_CANCELLED;

        case ERROR_IO_PENDING:
            return STATUS_PENDING;

        case ERROR_NOACCESS:
            return ERROR_ACCESS_DENIED;

        case ERROR_NOT_FOUND:
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case ERROR_NO_MATCH:
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case ERROR_CANCELLED:
            return STATUS_CANCELLED;

        case ERROR_RETRY:
            return STATUS_RETRY;

        case STATUS_NOT_A_DIRECTORY:
            return STATUS_NOT_A_DIRECTORY;

        case STATUS_FILE_IS_A_DIRECTORY:
            return STATUS_FILE_IS_A_DIRECTORY;

        case ERROR_NOT_ENOUGH_QUOTA:
            return STATUS_QUOTA_EXCEEDED;

        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            return STATUS_NETWORK_CREDENTIAL_CONFLICT;

        default:
            DavPrint((DEBUG_ERRORS, "DavDosErrorToNtStatus: dwError = %d\n", dwError));
            return STATUS_UNSUCCESSFUL;
        
        }                
    
    }

}

// #define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2

DWORD
DavrGetDiskSpaceUsage(
    IN handle_t dav_binding_h,
    LPWSTR      lptzLocation,
    LONG       lLenIn,
    LONG       *lplReturnLen,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    )
/*++

Routine Description:

    Finds out the amount of disk being consumed by wininet urlcache due to Webdav

Arguments:

    dav_binding_h - The explicit RPC binding handle.

    dwSize     -  Size of the cache location buffer. On return this will contain the actual size of the 
                    location string. 
                    
    lptzLocation  - Buffer to return Cache location string. As much of the location string as can fit
                    in the buffer is returned
                    
    lpdwReturnSize                    
    
    lpMaxSpace   -  Size of disk Quota set for webdav

    lpUsedSpace -   Size of disk consumed by the urlcache used by webdav
    
Return Value:

    Win32 error code

--*/
{
    // iterate through the cache to discover the actual size.
    INTERNET_CACHE_CONFIG_INFOW sConfigW;
    DWORD dwSize = sizeof(sConfigW), dwError = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    // should atleass have enough space for a drive letter
    if (lLenIn < 3)
    {
        return   ERROR_INVALID_PARAMETER;
    }
    try
    {
    
        sConfigW.dwContainer = 0;
        sConfigW.dwStructSize = sizeof(sConfigW);
        
        if (GetUrlCacheConfigInfoW(&sConfigW, &dwSize,  CACHE_CONFIG_DISK_CACHE_PATHS_FC |
                                                        CACHE_CONFIG_QUOTA_FC |
                                                        CACHE_CONFIG_CONTENT_USAGE_FC |
                                                        CACHE_CONFIG_STICKY_CONTENT_USAGE_FC))
        {
            *(ULONGLONG *)lpMaxSpace = (ULONGLONG)(sConfigW.dwQuota) * 1024;        
            *(ULONGLONG *)lpUsedSpace = (ULONGLONG)(sConfigW.dwNormalUsage+sConfigW.dwExemptUsage) * 1024;

            memset(lptzLocation, 0, lLenIn * sizeof(WCHAR));

            *lplReturnLen = wcslen(sConfigW.CachePath);

            if (*lplReturnLen < lLenIn)
            {
                // We have enough buffer
                memcpy(lptzLocation, sConfigW.CachePath,  *lplReturnLen * sizeof(WCHAR));
            }
            else
            {
                // We don't have enough buffer, we copy as much as we can
                memcpy(lptzLocation, sConfigW.CachePath,  lLenIn * sizeof(WCHAR));
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwError = ERROR_INVALID_PARAMETER;    
    }
    
    return dwError;
}

DWORD
DavrFreeUsedDiskSpace(
    IN handle_t dav_binding_h,
    DWORD   dwPercent
    )
/*++

Routine Description:

    Frees up dwPercent of the urlcache used by webdav


Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    dwPercent   - % of used space to be freed
    
Return Value:

    Win32 error code

--*/
{
    DWORD   dwError = ERROR_SUCCESS;

    if (dwPercent <= 100)
    {
        if (!FreeUrlCacheSpaceA(NULL, dwPercent, 0))
        {
            dwError = GetLastError();
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\util\credavsrv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credavsrv.c

Abstract:

    This is the module that helps install the DAV service in a SCM database.

Author:

    Rohan Kumar    [RohanK]     08-Feb-2000

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <windows.h>
#include <winsvc.h>
#include <string.h>

#define UNICODE
#define _UNICODE

VOID
_cdecl
main(
    IN INT      ArgC,
    IN PCHAR    ArgV[]
    )
/*++

Routine Description:
    
    Main function that installs the service.

Arguments:
    
    ArgC - Number of arguments.
    
    ArgV - Array of arguments.

Return Value:
    
    None.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    SC_HANDLE SCMHandle = NULL;
    SC_HANDLE DavServiceHandle = NULL;
    WCHAR PathName[MAX_PATH];

    //
    // Open the service control manager database of the local machine.
    //
    SCMHandle = OpenSCManagerW(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (SCMHandle == NULL) {
        WStatus = GetLastError();
        printf("ERROR: OpenSCManager: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    WStatus = GetEnvironmentVariableW(L"SystemRoot", PathName, MAX_PATH);
    if (WStatus == 0) {
        printf("ERROR: GetEnvironmentVariableW: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    wcscat(PathName, L"\\System32\\davclient.exe");

    DavServiceHandle = CreateServiceW(SCMHandle,
                                      L"WebClient",
                                      L"Web Client Network",
                                      SERVICE_ALL_ACCESS,
                                      SERVICE_WIN32_OWN_PROCESS,
                                      SERVICE_DEMAND_START,
                                      SERVICE_ERROR_NORMAL,
                                      PathName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
    if (DavServiceHandle == NULL) {
        WStatus = GetLastError();
        printf("ERROR: CreateServiceW: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    if (DavServiceHandle) {
        CloseServiceHandle(DavServiceHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\worker.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    Workter threads used by the web dav mini-redir client service.

Author:

    Andy Herron (andyhe) 15-Apr-1999

    Rohan Kumar [RohanK] 05-May-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"
#include "nodefac.h"

#define DAV_WORKITEM_ALLOC_FAIL_COUNT   10
#define DAV_WORKITEM_ALLOC_FAIL_WAIT    250
#define DAV_WORKITEM_FAIL_REQUEST       10
#define DAV_WORKITEM_FAIL_REQUEST_WAIT  100

LONG DavOutstandingWorkerRequests;

typedef struct _UMFS_WORKER_THREAD {
    struct _UMFS_THREAD_CONSTELLATION *Constellation;
    HANDLE ThisThreadHandle;
    ULONG  ThisThreadId;
    PDAV_USERMODE_WORKITEM pCurrentWorkItem;
    union {
        PVOID  Context1;
        ULONG  Context1u;
    };
    union {
        PVOID  Context2;
        ULONG  Context2u;
    };
} UMFS_WORKER_THREAD, *PUMFS_WORKER_THREAD;

typedef struct _UMFS_THREAD_CONSTELLATION {
    HANDLE DeviceObjectHandle;
    ULONG  MaximumNumberOfWorkers;
    ULONG  InitialNumberOfWorkers;
    BOOLEAN Terminating;
    UMFS_WORKER_THREAD WorkerThreads[1];
} UMFS_THREAD_CONSTELLATION, *PUMFS_THREAD_CONSTELLATION;

PUMFS_THREAD_CONSTELLATION DavThreadConstellation = NULL;

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

DWORD
WINAPI
DavRestartContext(
    LPVOID Context
    );

DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    );

DWORD
DavWorkerThread (
    PUMFS_WORKER_THREAD Worker
    );

//
// Implementation of functions begins here.
//

DWORD
DavInitWorkerThreads(
    IN ULONG InitialThreadCount,
    IN ULONG MaxThreadCount
    )
/*++

Routine Description:

    This routines creates the threads to be sent down to the kernel.

Arguments:

    InitialThreadCount - Initial number of threads sent down to get requests.

    MaxThreadCount - Max number of threads to be sent down to get requests.

Return Value:

    The return status for the operation

--*/
{
    DWORD WStatus;
    ULONG ConstellationSize;
    ULONG i;

    DavOutstandingWorkerRequests = 0;

    //
    // We need to allocate MaxThread number of UMFS_WORKER_THREAD strucutres +
    // the UMFS_THREAD_CONSTELLATION. Since the UMFS_THREAD_CONSTELLATION
    // structure already contains one UMFS_WORKER_THREAD field, we allocate
    // memory for (MaxThreadCount - 1) UMFS_WORKER_THREAD strucutres +
    // UMFS_THREAD_CONSTELLATION.
    //
    ConstellationSize = sizeof(UMFS_THREAD_CONSTELLATION);
    ConstellationSize += ( (MaxThreadCount - 1) * sizeof(UMFS_WORKER_THREAD) );

    //
    // We need to make the ConstellationSize a multiple of 8. This is because
    // DavAllocateMemory calls DebugAlloc which does some stuff which requires
    // this. The equation below does this.
    //
    ConstellationSize = ( ( ( ConstellationSize + 7 ) / 8 ) * 8 );

    DavThreadConstellation = (PUMFS_THREAD_CONSTELLATION)
                                          DavAllocateMemory(ConstellationSize);

    if (DavThreadConstellation == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInitWorkerThreads/DavAllocateMemory. Error Val = %d.\n",
                  WStatus));
        return WStatus;
    }

    DavThreadConstellation->Terminating = FALSE;
    DavThreadConstellation->InitialNumberOfWorkers = InitialThreadCount;
    DavThreadConstellation->MaximumNumberOfWorkers = MaxThreadCount;
    DavThreadConstellation->DeviceObjectHandle = DavRedirDeviceHandle;

    DavPrint((DEBUG_MISC,
              "DavInitWorkerThreads: Dav Thread Constellation allocated at "
              "0x%x\n", DavThreadConstellation));

    //
    // Just spin up initial threads and ignore the max.
    //
    for (i = 0; i < InitialThreadCount; i++) {
        PUMFS_WORKER_THREAD Worker = &(DavThreadConstellation->WorkerThreads[i]);
        Worker->Constellation = DavThreadConstellation;
        Worker->ThisThreadHandle = CreateThread(
                                        NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE)DavWorkerThread,
                                        (LPVOID)Worker,
                                        0,
                                        &Worker->ThisThreadId);
        if (Worker->ThisThreadHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInitWorkerThreads/CreateThread: Return Val is NULL. "
                      "Error Val = %08lx.\n", WStatus));
        } else {
            DavPrint((DEBUG_MISC, "DavInitWorkerThreads: Dav Thread %u has "
                      "ThreadId 0x%x and Handle 0x%x\n",
                      i, Worker->ThisThreadId, Worker->ThisThreadHandle));
        }
    }

    return STATUS_SUCCESS;
}


DWORD
DavTerminateWorkerThreads(
    VOID
    )
/*++

Routine Description:

    This routines terminates the threads sent down to the kernel.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    ULONG i = 0;
    OVERLAPPED OverLapped;

    if (DavThreadConstellation != NULL) {
        DavThreadConstellation->Terminating = TRUE;
        //
        // First we complete all pending IRPs waiting down in kernel so that we
        // can kill these threads.
        //
        WStatus = UMReflectorReleaseThreads(DavReflectorHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavTerminateWorkerThreads/UMReflectorReleaseThreads: "
                      "Error value returned = %u.\n", WStatus));
        }
    }

    //
    // We ensure all worker threads have completed before we close the ioctl
    // threads.
    //
    while (DavOutstandingWorkerRequests) {
        //
        // Wait for a 250 milliseconds to check again for all threads to have
        // completed.
        //
        Sleep(250);
    }

    if (DavThreadConstellation != NULL) {
        for ( i = 0; i < DavThreadConstellation->MaximumNumberOfWorkers; i++) {
            HANDLE ThreadHandle =
                     DavThreadConstellation->WorkerThreads[i].ThisThreadHandle;
            if (ThreadHandle != NULL) {
                DavPrint((DEBUG_MISC,
                          "DavTerminateWorkerThread: Waiting for ThreadId 0x%x"
                          ", ThreadHandle 0x%x.\n",
                          DavThreadConstellation->WorkerThreads[i].ThisThreadId,
                          ThreadHandle));
                WaitForSingleObject(ThreadHandle, INFINITE);
                NtClose(ThreadHandle);
            }
        }

        //
        // Now that we're done with the constellation, we free it.
        //
        DavFreeMemory(DavThreadConstellation);
        DavThreadConstellation = NULL;
    }

    return STATUS_SUCCESS;
}


DWORD
WINAPI
DavRestartContext(
    LPVOID Context
    )
/*++

Routine Description:

    This function gets called when a worker thread initiates work on one
    of our contexts.  We'll call off to the restart routine and then
    decrement the count of active work contexts. The argument passed to the
    restart routine is the context itself.

Arguments:

    Context - The context which contains the function to be called.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD err;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    PDAV_USERMODE_WORKITEM davContext = NULL;
    LPTHREAD_START_ROUTINE routine = NULL;

    davContext = (PDAV_USERMODE_WORKITEM) Context;
    routine = (LPTHREAD_START_ROUTINE) davContext->RestartRoutine;
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)davContext;

    //
    // We store the ThreadId in the DAV_USERMODE_WORKITEM structure for 
    // debugging purposes.
    //
    davContext->ThisThreadId = GetCurrentThreadId();

    DavPrint((DEBUG_MISC,
              "DavRestartContext: DavWorkItem = %08lx, ThisThreadId = %x\n",
              davContext, davContext->ThisThreadId));

    //
    // Invoke the function.
    //
    err = routine( (LPVOID)davContext );
    if (err != ERROR_SUCCESS && err != ERROR_IO_PENDING) {
        DavPrint((DEBUG_MISC,
                  "DavRestartContext: Routine at address %08lx returned error of"
                  " %08lx for context %08lx.\n", routine, err, davContext));
    }

    //
    // If we are using WinInet synchronously, then we need to finally complete
    // the request.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // This thread now needs to send the response back to the kernel. It
    // does not wait in the kernel (to get another request) after submitting
    // the response.
    //
    UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

#endif

    //
    // Decrement the number of requests posted.
    //
    InterlockedDecrement( &(DavOutstandingWorkerRequests) );

    return err;
}


VOID
DavCleanupWorkItem(
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem
    )
/*++

Routine Description:

    This function gets called when a kernelmode requests gets cancelled and we
    need to do some cleanup to free up the resources allocated for the response
    of this request. For example, in QueryDirectory, we allocate a list of
    DavFileAttributes for every file in the directory. Since the request has
    been cancelled in the kernel, we don't need this list anymore.

Arguments:

    UserWorkItem - The WorkItem that needs to be cleaned.

Return Value:

    None.

--*/
{
    PDAV_USERMODE_WORKITEM davContext = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = NULL;

    davContext = (PDAV_USERMODE_WORKITEM)UserWorkItem;

    switch (davContext->WorkItemType) {

    case UserModeQueryDirectory: {
        QueryDirResponse = &(davContext->QueryDirResponse);
        DavFinalizeFileAttributesList(QueryDirResponse->DavFileAttributes, TRUE);
        QueryDirResponse->DavFileAttributes = NULL;
    }
    break;

    case UserModeCreate: {
        CreateResponse = &(davContext->CreateResponse);
        NtClose(CreateResponse->Handle);
        CreateResponse->Handle = NULL;
    }
    break;

    }

    return;
}


DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    )
/*++

Routine Description:

    This function should be called to post a dav work context to a worker
    thread. We track the number of outstanding requests we have.

Arguments:

    Function - The Functon to be called by the worker thread.

    DavContext - The context to be passed to the function.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD err = ERROR_SUCCESS;
    BOOL qResult;

    DavContext->RestartRoutine = (LPVOID)Function;

    //
    // Increment the number of requests posted.
    //
    InterlockedIncrement( &(DavOutstandingWorkerRequests) );

    //
    // Queue the workitem context.
    //
    qResult = QueueUserWorkItem(DavRestartContext, (LPVOID)DavContext, 0);
    if (!qResult) {
        //
        // Decrement the number of requests posted.
        //
        InterlockedDecrement( &(DavOutstandingWorkerRequests) );
        err = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavPostWorkItem/QueueUserWorkItem: WStatus = %08lx.\n", err));
    }

    return err;
}


DWORD
DavWorkerThread (
    PUMFS_WORKER_THREAD Worker
    )
/*++

Routine Description:

    This is the routine that gets kicked off by the worker thread. It issues
    synchronous IOCTL's to the user mode reflctor. Whenever a request comes
    down to the reflector, it uses these IOCTL's to pass the request back to the
    user mode. On return, the output buffers contain the request that came down
    to the reflctor. The routine looks at the request type and appropriately
    handles it. The results are sent back to the reflctor in a similar fashion.

Arguments:

    Worker - The worker thread's data structure.

Return Value:

    None.

--*/
{
    DWORD err = ERROR_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItemToUse = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemToSendBack = NULL;
    PUMFS_THREAD_CONSTELLATION Constellation = Worker->Constellation;
    ULONG NumberOfBytesTransferred;
    DWORD CompletionKey;
    ULONG failedMallocCount = 0;
    ULONG failedGetRequest = 0;
    PUMRX_USERMODE_WORKER_INSTANCE davWorkerHandle = NULL;
    BOOL didCreateImpersonationToken = FALSE, revertAlreadyDone = FALSE;

    Worker->Context1u = (ULONG)(Worker - &Constellation->WorkerThreads[0]);

    DavPrint((DEBUG_MISC,
              "DavWorkerThread: DavClient Thread (handle = %08lx and id = %08lx)"
              "starting...\n", Worker->ThisThreadHandle, Worker->ThisThreadId));

    err = UMReflectorOpenWorker(DavReflectorHandle, &davWorkerHandle);

    if (err != ERROR_SUCCESS || davWorkerHandle == NULL) {
        if (err == ERROR_SUCCESS) {
            err = ERROR_INTERNAL_ERROR;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavWorkerThread: DavClient thread %08lx error %u on OpenWorker.\n",
                   Worker->ThisThreadId, err));
        goto ExitWorker;
    }

    //
    // Continue servicing requests till the thread constellation is active.
    //
    while (Constellation->Terminating == FALSE) {

        //
        // If there is no WorkItem associated with this thread, then get one
        // for it.
        //
        if (WorkItemToUse == NULL) {

            WorkItemToUse = (PDAV_USERMODE_WORKITEM)
                             UMReflectorAllocateWorkItem(
                                      davWorkerHandle,
                                      (sizeof(DAV_USERMODE_WORKITEM) -
                                       sizeof(UMRX_USERMODE_WORKITEM_HEADER)) +
                                       sizeof(ULONG));
            if (WorkItemToUse == NULL) {
                DavPrint((DEBUG_ERRORS,
                          "DavWorkerThread: DavClient Thread %08lx couldn't "
                          "allocate workitem. Retry %u\n", Worker->ThisThreadId,
                          DAV_WORKITEM_ALLOC_FAIL_COUNT - failedMallocCount));

                failedMallocCount++;

                if (failedMallocCount >= DAV_WORKITEM_ALLOC_FAIL_COUNT) {
                    err = GetLastError();
                    goto ExitWorker;
                }

                Sleep(DAV_WORKITEM_ALLOC_FAIL_WAIT);

                continue;
            }

            failedMallocCount = 0;

        }

        err = UMReflectorGetRequest(davWorkerHandle,
                                    WorkItemToSendBack,
                                    (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse,
                                    revertAlreadyDone);

        if (WorkItemToSendBack) {
            UMReflectorCompleteWorkItem(davWorkerHandle, WorkItemToSendBack);
            WorkItemToSendBack = NULL;
        }

        if (err != ERROR_SUCCESS) {

            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread/UMReflectorGetRequest: Thread: %08lx, "
                      "Error: %08lx,. Retry: %d\n", Worker->ThisThreadId, err,
                      DAV_WORKITEM_FAIL_REQUEST - failedGetRequest));

            failedGetRequest++;

            if ((failedGetRequest >= DAV_WORKITEM_FAIL_REQUEST) ||
                (Constellation->Terminating == TRUE)) {
                goto ExitWorker;
            }

            DavPrint((DEBUG_MISC,
                      "DavWorkerThread: DavClient thread %08lx waiting for small time\n",
                      Worker->ThisThreadId ));

            Sleep(DAV_WORKITEM_FAIL_REQUEST_WAIT);

            continue;

        }

        failedGetRequest = 0;

        //
        // If we are using WinInet synchronously, then we need to set the
        // impersonation token before we post this request to the Win32 thread
        // pool. We dont do this in the case of finalizesrvcall or finalizefobx
        // becuase these requests don't go over the network.
        //
        switch (WorkItemToUse->WorkItemType) {

        case UserModeCreate:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreate(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                //
                // We need to Revert before calling the DavPostWorkItem function
                // below to post this workitem to a Win32 thread. Otherwise the
                // worker thread will not able to to impersonate the user later.
                //
                RevertToSelf();

                //
                // Set this to TRUE since we don't need to revert back in the
                // kernel any more.
                //
                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreate, WorkItemToUse);

            }
#endif
            break;

        case UserModeCreateSrvCall:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreateSrvCall(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreateSrvCall, WorkItemToUse);

            }
#endif
            break;

        case UserModeCreateVNetRoot:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreateVNetRoot(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreateVNetRoot, WorkItemToUse);

            }
#endif
            break;

        case UserModeFinalizeSrvCall:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeSrvCall(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeSrvCall, WorkItemToUse);
#endif
            break;

        case UserModeFinalizeVNetRoot:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeVNetRoot(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeVNetRoot, WorkItemToUse);
#endif
            break;

        case UserModeFinalizeFobx:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeFobx(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeFobx, WorkItemToUse);
#endif
            break;

            //
            // Check to see if we have already created the DavFileAttributes
            // list. If we have, we are already done and just need to return.
            // If we have not, then we post the request.
            //
        case UserModeQueryDirectory:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsQueryDirectory(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsQueryDirectory, WorkItemToUse);

            }
#endif
            break;

        case UserModeQueryVolumeInformation:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsQueryVolumeInformation(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsQueryVolumeInformation, WorkItemToUse);

            }
#endif
            break;


        case UserModeReName:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsReName(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsReName, WorkItemToUse);

            }
#endif
            break;

        case UserModeClose:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsClose(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsClose, WorkItemToUse);

            }
#endif
            break;

        case UserModeSetFileInformation:

            err = DavFsSetTheDavCallBackContext(WorkItemToUse);

            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsSetFileInformation, WorkItemToUse);

            }

            break;

        default:
            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread: Invalid WorkItemType = %d.\n",
                      WorkItemToUse->WorkItemType));
            break;

        }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

        //
        // If ERROR_IO_PENDING has been returned by the function that is
        // handling this request, it means that the request will be completed
        // in the context of some worker thread. So, this thread is done with
        // the workitem and should discard (not worry) about (completing) it.
        //
        if (err == ERROR_IO_PENDING) {
            WorkItemToUse = NULL;
        }
#else

        //
        // If we are using WinInet synchronously, we would have posted the
        // request to the Win32 thread pool. If the request was successfully
        // queued, then the worker thread that picks it up will ultimately
        // complete it.
        //
        if (err == ERROR_SUCCESS) {

            WorkItemToUse = NULL;

        } else {

            DavPrint((DEBUG_ERRORS, "DavWorkerThread/DavPostWorkItem: err = %d\n", err));

            //
            // If we created the impersonation token, we need to close it now
            // since we falied to post the request.
            //
            if (didCreateImpersonationToken) {
                DavFsFinalizeTheDavCallBackContext(WorkItemToUse);
            }

            WorkItemToUse->Status = DavDosErrorToNtStatus(err);

            //
            // The error cannot map to STATUS_SUCCESS. If it does, we need to
            // break here and investigate.
            //
            if (WorkItemToUse->Status == STATUS_SUCCESS) {
                DbgBreakPoint();
            }

        }

#endif

        //
        // If ERROR_IO_PENDING has been returned, there is nothing to send
        // back now. The above "if" takes care of this.
        //
        WorkItemToSendBack = (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse;

        //
        // This is set to NULL to pick up another workitem.
        //
        WorkItemToUse = NULL;

    }

ExitWorker:

    if (WorkItemToSendBack) {
        ULONG SendStatus;
        SendStatus =  UMReflectorSendResponse(davWorkerHandle, WorkItemToSendBack);
        if (SendStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread/UMReflectorSendResponse: SendStatus = "
                      "%08lx.\n", SendStatus));
        }
        UMReflectorCompleteWorkItem(davWorkerHandle, WorkItemToSendBack);
    }

    if (WorkItemToUse) {
        UMReflectorCompleteWorkItem(davWorkerHandle,
                                    (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse);
    }

    if (davWorkerHandle) {
        UMReflectorCloseWorker(davWorkerHandle);
    }

    DavPrint((DEBUG_MISC,
              "DavWorkerThread: DavClient thread %08lx exiting with error %u\n",
              Worker->ThisThreadId, err));

    //
    // This return, exits the thread.
    //
    return err;
}

//  worker.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\npdll\ifsmrxnp.h ===
/*++

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    ifsmrxnp.h

Abstract:

    This module includes all network provider router interface related
    definitions for the sample

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _IFSMRXNP_H_
#define _IFSMRXNP_H_

#define IFSMRXNP_DEBUG_CALL     0x1
#define IFSMRXNP_DEBUG_ERROR    0x2
#define IFSMRXNP_DEBUG_INFO     0x4

extern DWORD IfsMRxNpDebugLevel;

#define TRACE_CALL(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_CALL) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_ERROR(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_ERROR) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_INFO(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_INFO) {    \
                DbgPrint##Args;                 \
            }

typedef struct _IFSMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} IFSMRXNP_ENUMERATION_HANDLE,
  *PIFSMRXNP_ENUMERATION_HANDLE;

extern BOOL InitializeSharedMemory();
extern VOID UninitializeSharedMemory();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\inc\ifsmrx.h ===
/*++

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    ifsmrx.h

Abstract:

    This module includes all IFS smaple mini redirector definitions shared
    between the utility, network provider DLL and teh mini redirector

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _IFSMRX_H_
#define _IFSMRX_H_

// This file contains all the definitions that are shared across the multiple
// components that constitute the mini rdr -- the mini redirector driver,
// the net provider dll and the utility.

#define IFSMRX_DEVICE_NAME_U L"IfsSampleMiniRedirector"
#define IFSMRX_DEVICE_NAME_A "IfsSampleMiniRedirector"

// The following constant defines the length of the above name.

#define IFSMRX_DEVICE_NAME_U_LENGTH (24 * sizeof(WCHAR))
#define IFSMRX_DEVICE_NAME_A_LENGTH (24)

#define IFSMRX_PROVIDER_NAME_U L"Ifs Sample Redirector Network"
#define IFSMRX_PROVIDER_NAME_A "Ifs Sample Redirector Network"

// The following constant defines the length of the above name.

#define IFSMRX_PROVIDER_NAME_U_LENGTH (30 * sizeof(WCHAR))
#define IFSMRX_PROVIDER_NAME_A_LENGTH (30)

#define DD_IFSMRX_FS_DEVICE_NAME_A "\\Device\\IfsSampleMiniRedirector"
#define DD_IFSMRX_FS_DEVICE_NAME_U L"\\Device\\IfsSampleMiniRedirector"

#define DD_IFSMRX_FS_DEVICE_NAME_U_LENGTH (32 * sizeof(WCHAR))
#define DD_IFSMRX_FS_DEVICE_NAME_A_LENGTH (32)


#define IOCTL_RDR_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _IFSMRX_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_RDR_BASE, request, method, access)


#define FSCTL_IFSMRX_START                  _IFSMRX_CONTROL_CODE(100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IFSMRX_STOP                   _IFSMRX_CONTROL_CODE(101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IFSMRX_DELETE_CONNECTION      _IFSMRX_CONTROL_CODE(102, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IFSMRXNP_MAX_DEVICES (26)

// The NP Dll updates a shared memory data structure to reflect the various
// drive mappings established from the various process. This shared memory
// is used in maintaining the data structures required for enumeration as
// well.

typedef struct _IFSMRXNP_NETRESOURCE_ {
    BOOL     InUse;
    USHORT   LocalNameLength;
    USHORT   RemoteNameLength;
    USHORT   ConnectionNameLength;
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    WCHAR    LocalName[MAX_PATH];
    WCHAR    RemoteName[MAX_PATH];
    WCHAR    ConnectionName[MAX_PATH];
} IFSMRXNP_NETRESOURCE,
  *PIFSMRXNP_NETRESOURCE;

typedef struct _IFSMRXNP_SHARED_MEMORY_ {
    INT                     HighestIndexInUse;
    INT                     NumberOfResourcesInUse;
    IFSMRXNP_NETRESOURCE    NetResources[IFSMRXNP_MAX_DEVICES];
} IFSMRXNP_SHARED_MEMORY,
  *PIFSMRXNP_SHARED_MEMORY;

#define IFSMRXNP_SHARED_MEMORY_NAME L"IFSMRXNPMEMORY"

#define IFSMRXNP_MUTEX_NAME  L"IFSMRXNPMUTEX"

#endif // _IFSMRX_H_




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\3connect.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    3connect.c

Abstract:

    This module implements the tree connect SMB related routines. It also implements the
    three flavours of this routine ( user level and share level non NT server tree connect
    SMB construction and the tree connect SMB construction for SMB servers)

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntlsapi.h"

//
// The order of these names should match the order in which the enumerated type
// NET_ROOT_TYPE is defined. This facilitates easy access of share type names
//

PCHAR s_NetRootTypeName[] = {
                              SHARE_TYPE_NAME_DISK,
                              SHARE_TYPE_NAME_PIPE,
                              SHARE_TYPE_NAME_COMM,
                              SHARE_TYPE_NAME_PRINT,
                              SHARE_TYPE_NAME_WILD
                            };

extern NTSTATUS
BuildTreeConnectSecurityInformation(
            PSMB_EXCHANGE  pExchange,
            PBYTE          pBuffer,
            PBYTE          pPasswordLength,
            PULONG         pSmbBufferSize);

NTSTATUS
BuildCanonicalNetRootInformation(
            PUNICODE_STRING     pServerName,
            PUNICODE_STRING     pNetRootName,
            NET_ROOT_TYPE       NetRootType,
            BOOLEAN             fUnicode,
            BOOLEAN             fPostPendServiceString,
            PBYTE               *pBufferPointer,
            PULONG              pBufferSize)
/*++

Routine Description:

   This routine builds the desired net root information for a tree connect SMB

Arguments:

    pServerName    - the server name

    pNetRootName   - the net root name

    NetRootType    - the net root type ( print,pipe,disk etc.,)

    fUnicode       - TRUE if it is to be built in UNICODE

    pBufferPointer - the SMB buffer

    pBufferSize    - the size on input. modified to the remaining size on output

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine relies upon the names being in certain formats to ensure that a
    valid UNC name can be formulated.
    1) The RDBSS netroot names start with a \ and also include the server name as
    part of the net root name. This is mandated by the prefix table search requirements
    in RDBSS.

--*/
{
   NTSTATUS Status;

   if (fUnicode)
   {
      // Align the buffer and adjust the size accordingly.

      PBYTE    pBuffer = *pBufferPointer;
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE),
                     ("BuildCanonicalNetRootInformation -- tcstring as unicode %wZ\n", pNetRootName));
      pBuffer = ALIGN_SMB_WSTR(pBuffer);
      *pBufferSize -= (pBuffer - *pBufferPointer);
      *pBufferPointer = pBuffer;

      *((PWCHAR)*pBufferPointer) = L'\\';
      *pBufferPointer = *pBufferPointer + sizeof(WCHAR);
      *pBufferSize -= sizeof(WCHAR);
      Status = SmbPutUnicodeStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   }
   else
   {
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE), ("BuildCanonicalNetRootInformation -- tcstring as ascii\n"));
      *((PCHAR)*pBufferPointer) = '\\';
      *pBufferPointer += sizeof(CHAR);
      *pBufferSize -= sizeof(CHAR);
      Status = SmbPutUnicodeStringAsOemStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   }

   if (NT_SUCCESS(Status) && fPostPendServiceString)
   {
      // Put the desired service name in ASCII ( always )

      ULONG Length = strlen(s_NetRootTypeName[NetRootType]) + 1;

      if (*pBufferSize >= Length) {
         RtlCopyMemory(*pBufferPointer,s_NetRootTypeName[NetRootType],Length);
         *pBufferSize -= Length;
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}


NTSTATUS
CoreBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;
   USHORT   PasswordLength;

   PMRX_NET_ROOT NetRoot;

   UNICODE_STRING ServerName;
   UNICODE_STRING NetRootName;

   PSMBCE_SERVER  pServer;

   PREQ_TREE_CONNECT pTreeConnect = (PREQ_TREE_CONNECT)pAndXSmb;

   ULONG OriginalBufferSize = *pAndXSmbBufferSize;

   BOOLEAN   AppendServiceString;
   PBYTE pBuffer;
   PCHAR ServiceName;    // = s_NetRootTypeName[NET_ROOT_WILD];
   ULONG Length;         // = strlen(ServiceName) + 1;

   NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;
   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
       ("CoreBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",pAndXSmb,pAndXSmbBufferSize,NetRoot->Type));

   pServer = &pExchange->SmbCeContext.pServerEntry->Server;
   SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
   SmbCeGetNetRootName(NetRoot,&NetRootName);
   ServiceName = s_NetRootTypeName[NetRoot->Type];
   Length = strlen(ServiceName) + 1;

   pTreeConnect->WordCount = 0;
   AppendServiceString     = FALSE;
   pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT,Buffer);
   *pBuffer = 0x04;
   pBuffer++;
   *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)+1);

   // put in the netname

   Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                     (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                     AppendServiceString,
                     &pBuffer,
                     pAndXSmbBufferSize);

   if (!NT_SUCCESS(Status))
      return Status;

   // put in the password

   pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;

   *pBuffer = 0x04;
   pBuffer++;
   *pAndXSmbBufferSize -= 1;

   if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL)
   {
      // The password information needs to be sent as part of the tree connect
      // SMB for share level servers.

      Status = BuildTreeConnectSecurityInformation(
                           pExchange,
                           pBuffer,
                           (PBYTE)&PasswordLength,
                           pAndXSmbBufferSize);
   }

   // string in the service string based on the netroot type

   pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
   *pBuffer = 0x04;
   pBuffer++;
   *pAndXSmbBufferSize -= 1;
   if (*pAndXSmbBufferSize >= Length) {
      RtlCopyMemory(pBuffer,ServiceName,Length);
      *pAndXSmbBufferSize -= Length;
   } else {
      Status = STATUS_BUFFER_OVERFLOW;
   }

   SmbPutUshort(&pTreeConnect->ByteCount,
                 (USHORT)(OriginalBufferSize
                             - *pAndXSmbBufferSize
                             - FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)
                         )
               );

   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
   return Status;
}



NTSTATUS
LmBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;
   USHORT   PasswordLength;

   PMRX_NET_ROOT NetRoot;

   UNICODE_STRING ServerName;
   UNICODE_STRING NetRootName;

   PSMBCE_SERVER  pServer;

   PREQ_TREE_CONNECT_ANDX pTreeConnectAndX = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

   ULONG OriginalBufferSize = *pAndXSmbBufferSize;

   BOOLEAN   AppendServiceString;
   PBYTE pBuffer;
   PCHAR ServiceName;
   ULONG Length;

   NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;
   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
       ("LmBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",pAndXSmb,pAndXSmbBufferSize,NetRoot->Type));

   pServer = &pExchange->SmbCeContext.pServerEntry->Server;
   SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
   SmbCeGetNetRootName(NetRoot,&NetRootName);
   ServiceName = s_NetRootTypeName[NetRoot->Type];
   Length = strlen(ServiceName) + 1;

   AppendServiceString         = TRUE;
   pTreeConnectAndX->WordCount = 4;
   SmbPutUshort(&pTreeConnectAndX->AndXReserved,0);
   SmbPutUshort(&pTreeConnectAndX->Flags,0);
   pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
   *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)+1);

   if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
      // The password information needs to be sent as part of the tree connect
      // SMB for share level servers.

      Status = BuildTreeConnectSecurityInformation(
                           pExchange,
                           pBuffer,
                           (PBYTE)&PasswordLength,
                           pAndXSmbBufferSize);
      if (Status == STATUS_SUCCESS) {
         pBuffer += PasswordLength;
         SmbPutUshort(&pTreeConnectAndX->PasswordLength,PasswordLength);
      }
   } else {
      pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
      *pAndXSmbBufferSize -= FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

      // No password is required for user level security servers as part of tree
      // connect
      SmbPutUshort(&pTreeConnectAndX->PasswordLength,0x1);
      *((PCHAR)pBuffer) = '\0';
      pBuffer    += sizeof(CHAR);
      *pAndXSmbBufferSize -= sizeof(CHAR);
      Status = STATUS_SUCCESS;
   }


   if (Status == STATUS_SUCCESS) {
      Status = BuildCanonicalNetRootInformation(
                        &ServerName,
                        &NetRootName,
                        pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                        (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                        AppendServiceString,
                        &pBuffer,
                        pAndXSmbBufferSize);


      if (Status == STATUS_SUCCESS) {
         SmbPutUshort(&pTreeConnectAndX->ByteCount,
                       (USHORT)(OriginalBufferSize
                                   - *pAndXSmbBufferSize
                                   - FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)
                               )
                     );
      }

      RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
   }

   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\npdll\dllmain.c ===
/*++

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for network
    provider router interface DLLT

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/

#include <windows.h>
#include <process.h>

#include "ifsmrx.h"
#include "ifsmrxnp.h"


// NOTE:
//
// Function:	DllMain
//
// Return:	TRUE  => Success
//		FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL	bStatus = TRUE;
    WORD	wVersionRequested;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return(bStatus);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\npdll\ifsmrxnp.c ===
/*++

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    ifsmrxnp.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/

// Include files from the NT public directories

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <npapi.h>

// include files from the IFS inc directory

#include <ifsmrx.h>
#include <ifsmrxnp.h>

// The debug level for this module

DWORD IfsMRxNpDebugLevel = 7;


// the IFS mini redirector and provider name. The original constants
// are defined in ifsmrx.h

UNICODE_STRING IfsMRxDeviceName = {
                                      DD_IFSMRX_FS_DEVICE_NAME_U_LENGTH,
                                      DD_IFSMRX_FS_DEVICE_NAME_U_LENGTH,
                                      DD_IFSMRX_FS_DEVICE_NAME_U
                                  };

UNICODE_STRING IfsMrxProviderName = {
                                        IFSMRX_PROVIDER_NAME_U_LENGTH,
                                        IFSMRX_PROVIDER_NAME_U_LENGTH,
                                        IFSMRX_PROVIDER_NAME_U
                                    };


DWORD
OpenSharedMemory(
    PHANDLE phMutex,
    PHANDLE phMemory,
    PVOID   *pMemory
)
/*++

Routine Description:

    This routine opens the shared memory for exclusive manipulation

Arguments:

    phMutex - the mutex handle

    phMemory - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

    WN_SUCCESS -- if successful

--*/
{
    DWORD   dwStatus;

    TRACE_CALL(("OpenSharedMemory\n"));

    *phMutex = 0;
    *phMemory = 0;
    *pMemory = NULL;

    *phMutex = OpenMutex(
                   SYNCHRONIZE,
                   FALSE,
                   IFSMRXNP_MUTEX_NAME);

    if (*phMutex == NULL) {
        dwStatus = GetLastError();
        TRACE_ERROR(("OpenSharedMemory:  CreateMutex failed\n"));
        goto OpenSharedMemoryAbort1;
    }

    TRACE_INFO(("OpenSharedMemory:  Calling WaitForSingleObject\n"));
    WaitForSingleObject(*phMutex, INFINITE);

    *phMemory = OpenFileMapping(
                    FILE_MAP_WRITE,
                    FALSE,
                    IFSMRXNP_SHARED_MEMORY_NAME);

    if (*phMemory == NULL) {
        dwStatus = GetLastError();
        TRACE_ERROR(("OpenSharedMemory:  OpenFileMapping failed\n"));
        goto OpenSharedMemoryAbort2;
    }

    *pMemory = MapViewOfFile(*phMemory, FILE_MAP_WRITE, 0, 0, 0);
    if (*pMemory == NULL) {
        dwStatus = GetLastError();
        TRACE_ERROR(("OpenSharedMemory:  MapViewOfFile failed\n"));
        goto OpenSharedMemoryAbort3;
    }

    TRACE_CALL(("OpenSharedMemory: return ERROR_SUCCESS\n"));
    return(ERROR_SUCCESS);

OpenSharedMemoryAbort3:
    CloseHandle(*phMemory);
OpenSharedMemoryAbort2:
    ReleaseMutex(*phMutex);
    CloseHandle(*phMutex);
    *phMutex = NULL;
OpenSharedMemoryAbort1:
    TRACE_ERROR(("OpenSharedMemory: return dwStatus: %d\n", dwStatus));
    return(dwStatus);
}

VOID
CloseSharedMemory(
    PHANDLE  hMutex,
    PHANDLE  hMemory,
    PVOID   *pMemory )
/*++

Routine Description:

    This routine relinquishes control of the shared memory after exclusive
    manipulation

Arguments:

    hMutex - the mutex handle

    hMemory  - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

--*/
{
    TRACE_CALL(("CloseSharedMemory\n"));
    if (*pMemory) {
        UnmapViewOfFile(*pMemory);
        *pMemory = NULL;
    }
    if (*hMemory) {
        CloseHandle(*hMemory);
        *hMemory = 0;
    }
    if (*hMutex) {
        if (ReleaseMutex(*hMutex) == FALSE) {
            TRACE_ERROR(("CloseSharedMemory: ReleaseMutex error: %d\n", GetLastError()));
        }
        CloseHandle(*hMutex);
        *hMutex = 0;
    }
    TRACE_CALL(("CloseSharedMemory: Return\n"));
}


DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capaboilities of the IFS Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{
    switch (nIndex) {
        case WNNC_SPEC_VERSION:
            return(WNNC_SPEC_VERSION51);

        case WNNC_NET_TYPE:
            return(0x00170000);

        case WNNC_DRIVER_VERSION:
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)
            return(WNNC_DRIVER(1, 0));

        case WNNC_USER:
            return(0);

        case WNNC_CONNECTION:
            return(WNNC_CON_GETCONNECTIONS |
                   WNNC_CON_CANCELCONNECTION |
                   WNNC_CON_ADDCONNECTION |
                   WNNC_CON_ADDCONNECTION3);

        case WNNC_DIALOG:
            return(0);

        case WNNC_ADMIN:
            return(0);

        case WNNC_ENUMERATION:
            return(WNNC_ENUM_LOCAL);

        case WNNC_START:
            return(1);

        default:
            return(0);
    }
}

DWORD APIENTRY
NPLogonNotify(
    PLUID   lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    LPWSTR  *lpLogonScript)
/*++

Routine Description:

    This routine handles the logon notifications

Arguments:

    lpLogonId -- the associated LUID

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    lpLogonScript - the logon script to be executed.

Return Value:

    WN_SUCCESS

Notes:

    This capability has not been implemented in the sample.

--*/
{
    *lpLogonScript = NULL;

    return(WN_SUCCESS);
}

DWORD APIENTRY
NPPasswordChangeNotify (
    LPCWSTR	lpAuthentInfoType,
    LPVOID	lpAuthentInfo,
    LPCWSTR	lpPreviousAuthentInfoType,
    LPVOID	lpPreviousAuthentInfo,
    LPWSTR	lpStationName,
    LPVOID	StationHandle,
    DWORD	dwChangeInfo )
/*++

Routine Description:

    This routine handles the password change notifications

Arguments:

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    dwChangeInfo - the password change information.

Return Value:

    WN_NOT_SUPPORTED

Notes:

    This capability has not been implemented in the sample.

--*/
{
    SetLastError(WN_NOT_SUPPORTED);
    return(WN_NOT_SUPPORTED);
}

DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. The only capability
    implemented in the sample is for enumerating connected shares

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - aptr. for passing nack the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status = 0;

    TRACE_CALL(("NPOpenEnum\n"));

    *lphEnum = NULL;

    switch (dwScope) {
    case RESOURCE_CONNECTED:
        {
            *lphEnum = LocalAlloc(
                            LMEM_ZEROINIT,
                            sizeof(IFSMRXNP_ENUMERATION_HANDLE));

            if (*lphEnum != NULL) {
                Status = WN_SUCCESS;
            } else {
                Status = WN_OUT_OF_MEMORY;
            }
            break;
        }
        break;
    case RESOURCE_CONTEXT:
    default:
        Status  = WN_NOT_SUPPORTED;
        break;
    }


    TRACE_ERROR(("NPOpenEnum returning Status %lx\n",Status));

    return(Status);
}

DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status = WN_SUCCESS;

    PIFSMRXNP_ENUMERATION_HANDLE pEnumHandle;

    LPNETRESOURCEW pBufferResource;

    DWORD   StringOffset;
    DWORD   AvailableBufferSize;

    HANDLE  hMutex, hMemory;
    PIFSMRXNP_SHARED_MEMORY  pSharedMemory;

    TRACE_CALL(("NPEnumResource\n"));

    TRACE_INFO(("NPEnumResource Count Requested %d\n",*lpcCount));

    AvailableBufferSize = *lpBufferSize;
    StringOffset        = *lpBufferSize;
    pBufferResource     = (LPNETRESOURCEW)lpBuffer;

    pEnumHandle = (PIFSMRXNP_ENUMERATION_HANDLE)hEnum;

    *lpcCount = 0;

    if (pEnumHandle->LastIndex >= IFSMRXNP_MAX_DEVICES) {
        return(WN_NO_MORE_ENTRIES);
    }

    Status = OpenSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS) {
        INT  Index;
        PIFSMRXNP_NETRESOURCE pNetResource;

        TRACE_INFO(("NPEnumResource: Highest Index %d Number Of resources %d\n",
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = pEnumHandle->LastIndex; Index <= pSharedMemory->HighestIndexInUse; Index++) {
            pNetResource = &pSharedMemory->NetResources[Index];

            TRACE_INFO(("NPEnumResource: Examining Index %d\n",Index));

            if (pNetResource->InUse) {
                DWORD ResourceSize;

                ResourceSize = sizeof(NETRESOURCE) +
                               pNetResource->LocalNameLength + sizeof(WCHAR) +
                               pNetResource->RemoteNameLength + sizeof(WCHAR) +
                               IfsMrxProviderName.Length + sizeof(WCHAR);

                if (AvailableBufferSize >= ResourceSize) {
                    *lpcCount =  *lpcCount + 1;
                    AvailableBufferSize -= ResourceSize;

                    pBufferResource->dwScope = RESOURCE_CONNECTED;
                    pBufferResource->dwType  = pNetResource->dwType;
                    pBufferResource->dwDisplayType = pNetResource->dwDisplayType;
                    pBufferResource->dwUsage   = pNetResource->dwUsage;

                    TRACE_INFO(("NPEnumResource: Copying local name Index %d\n",Index));

                    // set up the strings in the resource
                    StringOffset -= (pNetResource->LocalNameLength + sizeof(WCHAR));
                    pBufferResource->lpLocalName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    RtlCopyMemory(
                        pBufferResource->lpLocalName,
                        pNetResource->LocalName,
                        pNetResource->LocalNameLength);

                    pBufferResource->lpLocalName[
                        pNetResource->LocalNameLength/sizeof(WCHAR)] = L'\0';

                    TRACE_INFO(("NPEnumResource: Copying remote name Index %d\n",Index));

                    StringOffset -= (pNetResource->RemoteNameLength + sizeof(WCHAR));
                    pBufferResource->lpRemoteName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    RtlCopyMemory(
                        pBufferResource->lpRemoteName,
                        pNetResource->RemoteName,
                        pNetResource->RemoteNameLength);

                    pBufferResource->lpRemoteName[
                        pNetResource->RemoteNameLength/sizeof(WCHAR)] = L'\0';

                    TRACE_INFO(("NPEnumResource: Copying provider name Index %d\n",Index));

                    StringOffset -= (IfsMrxProviderName.Length + sizeof(WCHAR));
                    pBufferResource->lpProvider =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    RtlCopyMemory(
                        pBufferResource->lpProvider,
                        IfsMrxProviderName.Buffer,
                        IfsMrxProviderName.Length);

                    pBufferResource->lpProvider[
                        IfsMrxProviderName.Length/sizeof(WCHAR)] = L'\0';

                    pBufferResource->lpComment = NULL;

                    pBufferResource++;
                } else {
                    TRACE_INFO(("NPEnumResource: Buffer Overflow Index %d\n",Index));
                    Status = WN_MORE_DATA;
                    break;
                }
            }
        }

        pEnumHandle->LastIndex = Index;

        if ((Status == WN_SUCCESS) &&
            (pEnumHandle->LastIndex > pSharedMemory->HighestIndexInUse) &&
            (*lpcCount == 0)) {
            Status = WN_NO_MORE_ENTRIES;
        }

        CloseSharedMemory(
            &hMutex,
            &hMemory,
            (PVOID)&pSharedMemory);
    }

    TRACE_INFO(("NPEnumResource returning Count %d\n",*lpcCount));

    TRACE_CALL(("NPEnumResource returning Status %lx\n",Status));

    return(Status);
}

DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

--*/
{
    TRACE_CALL(("NPCloseEnum\n"));

    LocalFree(hEnum);

    return(WN_SUCCESS);
}


DWORD
OpenConnection(
    PUNICODE_STRING             pConnectionName,
    DWORD                       Disposition,
    PFILE_FULL_EA_INFORMATION	pEABuffer,
    DWORD                       EABufferLength,
    PHANDLE                     pConnectionHandle )
/*++

Routine Description:

    This routine opens the connection. This routine is shared by NpAddConnection
    and NPCancelConnection

Arguments:

    pConnectionName - the connection name

    Disposition - the Open disposition

    pEABuffer  - the EA buffer associated with the open

    EABufferLength - the EA buffer length

    pConnectionHandle - the placeholder for the connection handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES	ConnectionObjectAttributes;

    TRACE_CALL(("OpenConnection: ConnectionName: %S\n", pConnectionName->Buffer));

    InitializeObjectAttributes(
        &ConnectionObjectAttributes,
        pConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtCreateFile(
                 pConnectionHandle,
                 SYNCHRONIZE,
                 &ConnectionObjectAttributes,
                 &IoStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 Disposition,
                 (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                 pEABuffer,
                 EABufferLength);

    if (Status != STATUS_SUCCESS) {
        TRACE_ERROR(("OpenConnection: NtCreateFile Failed: NTStatus: %08x\n", Status));
        return(WN_BAD_NETNAME);
    }

    TRACE_CALL(("OpenConnection: return SUCCESS\n"));
    return(WN_SUCCESS);
}

DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    return(NPAddConnection3(NULL, lpNetResource, lpPassword, lpUserName, 0));
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The current sample does not handle explicitly passesd in credentials. Normally
    the credential information is passed in as EA parameters to the associated
    mini redirector for further manipulation

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING      ConnectionName;
    OBJECT_ATTRIBUTES   ConnectionAttributes;
    HANDLE              ConnectionHandle = INVALID_HANDLE_VALUE;

    IO_STATUS_BLOCK     IoStatusBlock;

    PWCHAR  pLocalName,pRemoteName;
    USHORT  LocalNameLength,RemoteNameLength;

    // The IFS mini supports only DISK type resources. The other resources
    // are not supported.

    if ((lpNetResource->lpRemoteName == NULL) ||
        (lpNetResource->lpRemoteName[0] != L'\\') ||
        (lpNetResource->lpRemoteName[1] != L'\\') ||
        (lpNetResource->dwType != RESOURCETYPE_DISK)) {
        return WN_BAD_NETNAME;
    }

    //
    // The remote name is in the UNC format \\Server\Share.  This name
    // needs to be translated to an appropriate NT name in order to
    // issue the request to the underlying mini redirector to create the
    // connection.
    //
    // The NT style name is of the form
    //
    //  \device\ifsminiredirector\;<DriveLetter>:\Server\Share
    //
    // The additional ; is required by the new RDR for extensibility.
    //

    pLocalName = lpNetResource->lpLocalName;
    pRemoteName = lpNetResource->lpRemoteName;

    // skip past the first back slash since the name to be appended for the
    // NT name does not require this.
    pRemoteName++;

    if (pLocalName != NULL) {
        LocalNameLength = wcslen(pLocalName) * sizeof(WCHAR);
    } else {
        LocalNameLength = 0;
    }

    RemoteNameLength = (wcslen(pRemoteName) - 1) * sizeof(WCHAR);

    ConnectionName.MaximumLength = (USHORT)(IfsMRxDeviceName.Length +
                                       (USHORT)RemoteNameLength +
                                        ((pLocalName != NULL)
                                         ? (LocalNameLength + sizeof(WCHAR)) //+1 for ';'
                                         : 0) +
                                       sizeof(WCHAR));

    ConnectionName.Length = ConnectionName.MaximumLength;

    ConnectionName.Buffer = LocalAlloc(
                                 LMEM_ZEROINIT,
                                 ConnectionName.Length);

    if (ConnectionName.Buffer == NULL) {
        return GetLastError();
    }

    // Copy the name into the buffer

    RtlCopyMemory(
        ConnectionName.Buffer,
        IfsMRxDeviceName.Buffer,
        IfsMRxDeviceName.Length);

    wcscat(ConnectionName.Buffer, L"\\");
    wcscat(ConnectionName.Buffer, L";");
    if (pLocalName != NULL) {
        wcscat(ConnectionName.Buffer, pLocalName);
    }

    wcscat(ConnectionName.Buffer, pRemoteName);

    Status = OpenConnection(
                 &ConnectionName,
                 FILE_OPEN_IF,
                 NULL,
                 0,
                 &ConnectionHandle);

    if ((Status == WN_SUCCESS) &&
        (pLocalName != NULL)) {
        WCHAR TempBuf[64];

        if (!QueryDosDeviceW(
                pLocalName,
                TempBuf,
                64)) {
            if (GetLastError() != ERROR_FILE_NOT_FOUND) {

                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //

                Status = ERROR_ALREADY_ASSIGNED;
            } else {
                //
                // ERROR_FILE_NOT_FOUND (translated fro