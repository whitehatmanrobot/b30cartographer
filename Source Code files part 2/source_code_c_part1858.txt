ODE;
            }
            else
            {
                if(G_fConsole && bInitCacheTable(ulTTFonts, ulT1Fonts, FntRegLWT, T1RegLWT, Win32kLWT, AtmfdLWT, (ULONG) AnsiCodePage))
                {

                    // If something will not match, then it means we need to create FNTCACHE again

                        gflFntCacheState = FNT_CACHE_CREATE_MODE;
                }
                else
                {
                    if (G_fConsole)
                    {
                        WARNING(" Boot time Font Cache failed\n");
                        WARNING(" The pTable is corrupted and font registry is failed to open\n");
                    }                        
                }
           }
        }
        else
        {
        // If there is no FNTCACHE.DAT file
        // Then we need to create it.
            if(G_fConsole && bInitCacheTable(ulTTFonts, ulT1Fonts, FntRegLWT, T1RegLWT, Win32kLWT, AtmfdLWT, (ULONG) AnsiCodePage))
            {
                gflFntCacheState = FNT_CACHE_CREATE_MODE;

            }
            else
            {
                if (G_fConsole)
                {
                    WARNING("Boot time Font Cache failed\n");
                    WARNING(" If you read this message, please contact YungT or NTFONTS\n");
                    WARNING(" You can continue without any harm, just hit g\n");
                }
            }
        }

    }

CleanUp:

// Semaphore initialized

    if (gflFntCacheState & FNT_CACHE_MASK)
    {

        ASSERTGDI(gFntCache->pTable, "Fnt Cache pTable did not open \n");

    // Initialize the start pointer of current Cache table

        gFntCache->pCacheBufStart = (PBYTE) gFntCache->pTable +
                             SZ_FNTCACHE(gFntCache->pTable->ulMaxFonts);
        gFntCache->pCacheBuf = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataUsed;
        gFntCache->pCacheBufEnd = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataAll +
                                  gFntCache->pTable->cjDataExtra;

        gFntCache->ulCurrentHlink = gFntCache->pTable->ulTotalLinks;

        if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
        {
        // Unlock the the font cache file to make other session to use it
            bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 0);
        }
        else // FNT_CACHE_CREATE_MODE
        {
            gFntCache->flThisBoot = 0;
        }
    }
    else
    {
        gflFntCacheState = 0;

    // Clean up the memory
        if (gFntCache)
        {
            if (gFntCache->pTable)
            {
                vUnmapFontCacheFile();
            }

            VFREEMEM((PVOID) gFntCache);
            gFntCache = NULL;
        }

        if (ghsemFntCache)
        {
            GreDeleteSemaphore(ghsemFntCache);
            ghsemFntCache = NULL;
        }

    }

    FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_1, ("FNT Cache Create mode %d\n", gflFntCacheState));
}


/*****************************************************************************
 * ULONG ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz)
 *
 * Helper function to compute fast checksum
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz, PFONTFILEVIEW *ppfv,ULONG cFiles, DESIGNVECTOR *pdv, ULONG cjDV)
{
    ULONG   i;
    ULONG   checksum = 0;
    USHORT  *pusCode;

    for ( i = 0; i < cFiles; i++)
    {
        checksum += (checksum * 256 + ppfv[i]->fv.cjView);
        checksum += (checksum * 256 + (ULONG) ppfv[i]->fv.LastWriteTime.LowPart);
        checksum += (checksum * 256 + (ULONG) ppfv[i]->fv.LastWriteTime.HighPart);
    }

    pusCode = (USHORT *) pwsz;

    for ( i = 0; i < cwc; i++, pusCode++)
    {
    // SUM offset by 1 bit, it will make FastCheckSum unique

        checksum += (checksum * 256 + (ULONG) *pusCode);
    }

    if (pdv && cjDV)
    {
        PULONG pulCur, pulEnd;

        pulCur = (PULONG) pdv;

        for (pulEnd = pulCur + cjDV / sizeof(ULONG); pulCur < pulEnd; pulCur ++)
        {
            checksum += 256 * checksum + *pulCur;
        }
    }

    return checksum;
}


/*****************************************************************************
 * ULONG   LookUpFNTCacheTable(ULONG cwc, PWSZ pwszPathname, PULONG pulFastCheckSum)
 *
 * Lookup hash table if UFI exist then we return it, otherwise return 0
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG   LookUpFNTCacheTable(ULONG cwc, PWSZ pwszPathname, PULONG pulFastCheckSum, PFONTFILEVIEW *ppfv, ULONG cFiles, PPDEV  * pppDevCache,
                                DESIGNVECTOR *pdv, ULONG cjDV)
{
    ULONG       ulUFI = 0;
    ULONG       ulBucket = 0;
    FNTHLINK    *pFntHlink;


    *pulFastCheckSum = 0;
    *pppDevCache = NULL;

    if (ghsemFntCache == NULL)
        return ulUFI;

    SEMOBJ          so(ghsemFntCache);

    if(cwc != 0)
    {
        *pulFastCheckSum = ComupteFNTCacheFastCheckSum ( cwc, pwszPathname, ppfv, cFiles, pdv, cjDV);

        // If in CREATE mode, then nothing is in the cache

        if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
        {
            pFntHlink = NULL;

            SearchFNTCacheHlink( *pulFastCheckSum, &pFntHlink, gFntCache->pTable);

            if(pFntHlink && !(pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
            {
                ASSERTGDI( pFntHlink->ulFastCheckSum == *pulFastCheckSum, "ulFastCheckSum != pFntHlink->ulFastCheckSum \n");
                ulUFI = pFntHlink->ulUFI;
                *pppDevCache = gFntCache->hDev[pFntHlink->ulDrvMode];
            }
        }
    }

    return ulUFI;
}

/*****************************************************************************
 * VOID SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppFntHlink)
 *
 * Hash table search function
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppFntHlink, FNTCACHEHEADER *pTable)
{
// If there is a Cache, then ppFntHlink will not be NULL

    FNTHLINK    *pFntHlink;

    *ppFntHlink = NULL;

    ULONG   ulHashBucket;

    DWORD   iNext;

// Calculate the hash buckets

    ulHashBucket = ulFastCheckSum % FNTCACHE_MAX_BUCKETS;

// Start from the first Offset.

    iNext = pTable->aiBuckets[ulHashBucket];

    while (iNext != FNTINDEX_INVALID)
    {
        pFntHlink = &pTable->ahlnk[iNext];

        if (ulFastCheckSum == pFntHlink->ulFastCheckSum)
        {
            *ppFntHlink = pFntHlink;
            break;
        }

        iNext = pFntHlink->iNext;
    }

    return;
}

FNTHLINK * SearchFntCacheNewLink(ULONG ulFastCheckSum)
{
    FNTHLINK        *pFntHlink = NULL;

// Search the new Link from pNewTable
    SearchFNTCacheHlink(ulFastCheckSum, &pFntHlink, gFntCache->pTable);

// new Link dose not exist, we got to create it from pNewTable
    if (!pFntHlink)
    {
        if (gFntCache->ulCurrentHlink < gFntCache->pTable->ulMaxFonts && bFntCacheCreateHLink(ulFastCheckSum))
        {
            pFntHlink = &gFntCache->pTable->ahlnk[gFntCache->ulCurrentHlink];
            pFntHlink->ulFastCheckSum = ulFastCheckSum;
            pFntHlink->ulUFI = 0;
            pFntHlink->iNext = FNTINDEX_INVALID;
            pFntHlink->cjData = 0;
            pFntHlink->dpData = 0;
            pFntHlink->flLink = 0;

            pFntHlink->ulDrvMode = FNT_DUMMY_DRV;
            gFntCache->ulCurrentHlink++;
        }
        else
        {
            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }

    return pFntHlink;
}

/*****************************************************************************
 * VOID PutFNTCacheCheckSum(ULONG ulFastCheckSum,ULONG ulUFI)
 *
 * Hash table write mode, the UFI does not have in hash and then we put it in.
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    PutFNTCacheCheckSum(ULONG ulFastCheckSum,ULONG ulUFI)
{
    FNTHLINK        *pFntHlink;
    
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ          so(ghsemFntCache);

    if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
    {

        pFntHlink = NULL;

        if (pFntHlink = SearchFntCacheNewLink(ulFastCheckSum))
        {
            // If fast check sum is conflict, we can not cache it.
            if(pFntHlink->ulUFI == 0)
            {
               pFntHlink->ulUFI = ulUFI;
            }
            else
            {
                WARNING("Checksum conflict in  PutFNTCacheCheckSum");
                pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
            }

            gFntCache->bWrite = TRUE;

        }
        else
        {
            WARNING("FNTCACHE is not big enough \n");
            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_1, ("Put Trace: buckets %d, FastCheckSum %x,Check Sum %x \n", 
                                                    gFntCache->ulCurrentHlink, ulFastCheckSum, ulUFI));
        }
    }
    else
    {
        ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE, "PutFNTCacheCheckSum: gflFntCacheState\n");
    // During read mode, it still wants to write into fntcache.dat
    // Then we will rebuild it at next boot time.
        gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
    }

}

/*****************************************************************************
 * void FntCacheCreateHLink
 *
 * Build hash link in hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFntCacheCreateHLink(ULONG ulFastCheckSum)
{
    ULONG       ulHashBucket;
    FNTHLINK    *pCurHlink;
    DWORD       iNextLink;

    ulHashBucket = ulFastCheckSum % FNTCACHE_MAX_BUCKETS;

    iNextLink = gFntCache->pTable->aiBuckets[ulHashBucket];

    if (iNextLink != FNTINDEX_INVALID)
    {
        if (iNextLink > gFntCache->pTable->ulMaxFonts)
            return FALSE;

        pCurHlink = &gFntCache->pTable->ahlnk[iNextLink];

    // We put the new link at the end so that the search time is faster

        while (pCurHlink->iNext != FNTINDEX_INVALID)
        {
            if (pCurHlink->iNext > gFntCache->pTable->ulMaxFonts)
            {
                gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
                return FALSE;
            }

            pCurHlink = &gFntCache->pTable->ahlnk[pCurHlink->iNext];

            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, ("Current iNextLink %x\n", pCurHlink->iNext));
        }

        pCurHlink->iNext = gFntCache->ulCurrentHlink;

    }
    else
    {
    // put it at the head of the linked list

        gFntCache->pTable->aiBuckets[ulHashBucket] = gFntCache->ulCurrentHlink;

        FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, ("Put on HashBuckets %x\n", ulHashBucket));
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontgdi.cxx                                                 *
*                                                                          *
* GDI functions for fonts.                                                 *
*                                                                          *
* Created: 31-Oct-1990 09:37:42                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                                 *
\**************************************************************************/
#pragma warning (disable: 4509)

#include "precomp.hxx"

extern BOOL G_fConsole;


/******************************Public*Routine******************************\
*
* BOOL APIENTRY GreSetFontXform
*
*
* Effects: sets page to device scaling factors that are used in computing
*          notional do device transform for the text. This funciton is
*          called only by metafile component and used when a 16 bit metafile
*          has to be rotated by a nontrivial world transform.
*
* History:
*  30-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetFontXform
(
HDC    hdc,
FLOATL exScale,
FLOATL eyScale
)
{
    BOOL bRet;

    DCOBJ   dco(hdc);

    if (bRet = dco.bValid())
    {
        dco.pdc->vSet_MetaPtoD(exScale,eyScale);      // Set new value

        //
        // flag that the transform has changed as fas as font component
        // is concerned, since this page to device xform will be used in
        // computing notional to device xform for this font:
        //

        dco.pdc->vXformChange(TRUE);
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* int APIENTRY AddFontResource
*
* The AddFontResource function adds the font resource from the file named
* by the pszFilename parameter to the Windows public font table. The font
* can subsequently be used by any application.
*
* Returns:
*   The number of font resources or faces added to the system from the font
*   file; returns 0 if error.
*
* History:
*  Thu 13-Oct-1994 11:18:27 by Kirk Olynyk [kirko]
* Now it has a single return point. Added timing.
*
*  Tue 30-Nov-1993 -by- Bodin Dresevic [BodinD]
* update: Added permanent flag for the fonts that are not to
* be unloaded at log off time
*
*  Mon 12-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to UNICODE
*
*  05-Nov-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

/*
struct {
    int doprint : 1;
    int dobreak : 1;
} afrDebug = { 1,1 };
*/

int GreAddFontResourceWInternal (
    LPWSTR  pwszFileName,            // ptr. to unicode filename string
    ULONG   cwc,
    ULONG   cFiles,
    FLONG   fl,
    DWORD   dwPidTid,
    DESIGNVECTOR *pdv,
    ULONG         cjDV
    )
{
    ULONG cFonts = 0;
//  ASSERTGDI((fl & (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT)) !=
//             (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT),
//              "GreAddFontResourceWInternal, fl \n");

//    ASSERTGDI((fl & ~(AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT
//                        |FR_PRIVATE|FR_NOT_ENUM|FRW_EMB_PID|FRW_EMB_TID)) == 0,
//              "GreAddFontResourceWInternal, bad fl\n");
 /*
    if (afrDebug.doprint)
    {
        KdPrint(("\n"
                 "GreAddFontResourceWInternal\n"
                 "\tpwszFileName %-#x \"%ws\"\n"
                 "\t         cwc %-#x\n"
                 "\t      cFiles %-#x\n"
                 "\t          fl %-#x\n"
                 "\t    dwPidTid %-#x\n"
                 "\t)\n"
                 "\n"
                 , pwszFileName, pwszFileName ? pwszFileName : L""
                 , cwc
                 , cFiles
                 , fl
                 , dwPidTid
                 ));
    }
    if (afrDebug.dobreak)
    {
        KdBreakPoint();
    }
*/
    TRACE_FONT(("Entering GreAddFontResourceWInternal\n\t*pwszFileName=\"%ws\"\n\tfl=%-#x\n", pwszFileName,  fl));
    if ( !pwszFileName )
    {
        WARNING("gdisrv!GreAddFontResourceW(): bad paramerter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        // Current ID needs to match the input dwPidTid if it is embedded font

        if ((fl & FRW_EMB_PID) && (dwPidTid != (DWORD)W32GetCurrentPID()))
        {
            return (cFonts);
        }

        if ((fl & FRW_EMB_TID) && (dwPidTid != (DWORD)W32GetCurrentTID()))
        {
            return (cFonts);
        }

        FLONG flPFF = 0;

        if (fl & AFRW_ADD_LOCAL_FONT)
        {
            flPFF |= PFF_STATE_PERMANENT_FONT;
        }
        if (fl & AFRW_ADD_REMOTE_FONT)
        {
            flPFF |= PFF_STATE_NETREMOTE_FONT;
        }

        PFF *placeholder;

        // need to initialize the private PFT if it is NULL

        if (fl & (FR_PRIVATE|FRW_EMB_TID|FRW_EMB_PID) && (gpPFTPrivate == NULL))
        {
            if (!bInitPrivatePFT())
            {
                return (cFonts);
            }
        }

        PUBLIC_PFTOBJ pfto(fl & (FR_PRIVATE|FRW_EMB_PID|FRW_EMB_TID) ? gpPFTPrivate : gpPFTPublic);

        if (!pfto.bValid() ||
            !pfto.bLoadFonts( pwszFileName, cwc, cFiles, pdv, cjDV,
                                      &cFonts, flPFF, &placeholder, fl, FALSE, NULL ) )
        {
            cFonts = 0;
        }

        if (cFonts)
        {
            GreQuerySystemTime( &PFTOBJ::FontChangeTime );
        }
    }
    TRACE_FONT(("Exiting GreAddFontResourceWInternal\n\treturn value = %d\n", cFonts));
    return((int) cFonts);
}


/******************************Public*Routine******************************\
* int GreGetTextFace (hdc,nCount,lpFaceName,pac)
*
* The GetTextFace function fills the return buffer, lpFaceName, with the
* facename of the font currently mapped to the logical font selected into
* the DC.
*
* [Window 3.1 compatibility]
*     Facename really refers to family name in this case, so family name
*     from the IFIMETRICS is copied rather than face name.
*
* Returns:
*   The number of bytes copied to the buffer.  Returns 0 if error occurs.
*
* History:
*
*  Tue 27-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: conveterted to unicode
*
*  05-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int GreGetTextFaceW
(
    HDC        hdc,
    int        cwch,           // max number of WCHAR's to be returned
    LPWSTR     pwszFaceName,
    BOOL       bAliasName
)
{
    int iRet = 0;
    PWSZ    pwszAlias;

    DCOBJ dcof(hdc);

    if (dcof.bValid())
    {
    // Get PDEV user object.  We also need to make
    // sure that we have loaded device fonts before we go off to the font mapper.
    // This must be done before the semaphore is locked.

        PDEVOBJ pdo(dcof.hdev());
        ASSERTGDI (
            pdo.bValid(),
            "gdisrv!bEnumFonts(): cannot access PDEV\n");

        if (!pdo.bGotFonts())
        {
            pdo.bGetDeviceFonts();
        }

    // Lock down the LFONT.

        LFONTOBJ lfo(dcof.pdc->hlfntNew(), &pdo);

        if (lfo.bValid())
        {
        // Stabilize font table (grab semaphore for public PFT).

            SEMOBJ  so(ghsemPublicPFT);

        // Lock down PFE user object.

            FLONG flSim;
            FLONG flAboutMatch;
            POINTL ptlSim;
            PWSZ pwszUseThis = NULL;
            BOOL bIsFamilyNameAlias;

            PFEOBJ pfeo(lfo.ppfeMapFont(dcof,&flSim,&ptlSim, &flAboutMatch));

            if (!pfeo.bValid())
                return(iRet);

        // Figure out which name should be returned: the facename of the physical
        // font, or the facename in the LOGFONT.  We use the facename in the LOGFONT
        // if the match was due to facename substitution (alternate facename).

            bIsFamilyNameAlias = FALSE;
            if((flAboutMatch & MAPFONT_ALTFACE_USED) && lfo.plfw()->lfFaceName[0])
                pwszUseThis = lfo.plfw()->lfFaceName ;
            else
                pwszUseThis = pfeo.pwszFamilyNameAlias(&bIsFamilyNameAlias);

        // Copy facename to return buffer, truncating if necessary.

            if (pwszFaceName != NULL)
            {
            // If it's length is 0 return 0 because the buffer is
            // not big enough to write the string terminator.

                if (cwch >= 1)
                {
                    if (bAliasName && bIsFamilyNameAlias)
                    {
                        pwszAlias = pwszUseThis;
                        iRet = 0;
                        while(*pwszAlias && _wcsicmp( lfo.plfw()->lfFaceName, pwszAlias))
                        {
                            iRet += (wcslen(pwszAlias) + 1);
                            pwszAlias = pwszUseThis + iRet;
                        }

                        if(*pwszAlias)
                            pwszUseThis = pwszAlias;
                    }

                    iRet = wcslen(pwszUseThis) + 1;

                    if (cwch < iRet)
                    {
                        iRet = cwch;
                    }

                    memcpy(pwszFaceName, pwszUseThis, iRet * sizeof(WCHAR));

                    pwszFaceName[iRet - 1] = L'\0';   // guarantee a terminating NULL

                }
                else
                {
                    WARNING("Calling GreGetTextFaceW with 0 and pointer\n");
                }
            }
            else
            {
            // Return length of family name (terminating NULL included).

                if (bAliasName && bIsFamilyNameAlias)
                {
                    pwszAlias = pwszUseThis;

                    iRet = 0;
                    while(*pwszAlias && _wcsicmp( lfo.plfw()->lfFaceName, pwszAlias))
                    {
                        iRet += (wcslen(pwszAlias) + 1);
                        pwszAlias = pwszUseThis + iRet;
                    }

                    if(*pwszAlias)
                        pwszUseThis = pwszAlias;
                }

                iRet = (wcslen(pwszUseThis) + 1);

            }
        }
        else
        {
            WARNING("gdisrv!GreGetTextFaceW(): could not lock HLFONT\n");
        }
    }
    else
    {
        WARNING1("gdisrv!GreGetTextFaceW(): bad HDC\n");
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextMetricsW (hdc,lpMetrics,pac)
*
* Retrieves IFIMETRICS for the font currently selected into the hdc and
* converts them into Windows-compatible TEXTMETRIC format.  The TEXTMETRIC
* units are in logical coordinates.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Wed 24-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Reduce size.
*
*  Tue 20-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to unicode version
*
*  19-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetTextMetricsW
(
    HDC          hdc,
    TMW_INTERNAL *ptmi
)
{
    BOOL bRet = FALSE;
    DCOBJ       dcof (hdc);

    if (dcof.bValid())
    {
    // Get and validate RFONT user object
    // (may cause font to become realized)

    #if DBG
        HLFONT hlfntNew = dcof.pdc->hlfntNew();
        HLFONT hlfntCur = dcof.pdc->hlfntCur();
    #endif

        RFONTOBJ rfo(dcof, FALSE);

        if (rfo.bValid())
        {
            bRet = bGetTextMetrics(rfo, dcof, ptmi);
        }
        else
        {
            WARNING("gdisrv!GreGetTextMetricsW(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING1("GreGetTextMetricsW failed - invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiRemoveFontResourceW()
*
* Have the engine remove this font resource (i.e., unload the font file).
* The resource will not be removed until all outstanding AddFontResource
* calls for a specified file have been matched by an equal number of
* RemoveFontResouce calls for the same file.
*
* Returns:
*   TRUE if successful, FALSE if error occurs.
*
* History:
*  27-Sept-1996  -by- Xudong Wu [TessieW]
* Embedded/Private fonts stored in Private PFT, add two parameter fl, dwPidTid
* to trace down the font resouce in the Private PFT.
*  Thu 28-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: try/excepts -> ntgdi.c, multiple paths
*  04-Feb-1996 -by- Andre Vachon [andreva]
* rewrote to include try\except.
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL GreRemoveFontResourceW(
    LPWSTR        pwszPath,
    ULONG         cwc,
    ULONG         cFiles,
    FLONG         fl,
    DWORD         dwPidTid,
    DESIGNVECTOR *pdv,
    ULONG         cjDV
)
{
    PFF *pPFF, **ppPFF;
    // WCHAR szUcPathName[MAX_PATH + 1];
    BOOL bRet = FALSE;

// Check the flag

    ASSERTGDI((fl & ~(FR_PRIVATE|FR_NOT_ENUM|FRW_EMB_PID|FRW_EMB_TID)) == 0,
                "win32k!GreRemoveFontResourceW: bad flag\n");

// for embedded fonts, current PID/TID needs to match input dwPidTid

    if ((fl & FRW_EMB_TID) && (dwPidTid != (DWORD)W32GetCurrentTID()))
    {
        return FALSE;
    }

    if ((fl & FRW_EMB_PID) && (dwPidTid != (DWORD)W32GetCurrentPID()))
    {
        return FALSE;
    }

// Add one to the length to account for internal processing of the
// cCapString routine

    PUBLIC_PFTOBJ pfto(fl & (FR_PRIVATE|FRW_EMB_PID|FRW_EMB_TID) ? gpPFTPrivate : gpPFTPublic);      // access the public font table

    if (!pfto.bValid())
    {
       return FALSE;
    }

    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);     // This is a very high granularity
                                     // and will prevent text output
    TRACE_FONT(("GreRemoveFontResourceW() acquiring ghsemPublicPFT\n"));

    pPFF = pfto.pPFFGet(pwszPath, cwc, cFiles, pdv, cjDV, &ppPFF);

    if (pPFF)
    {
        // bUnloadWorkhorse() guarantees that the public font table
        // semaphore will be released before it returns

        if (bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, fl))
        {
            GreQuerySystemTime( &PFTOBJ::FontChangeTime );
        }
    }
    else
    {
        TRACE_FONT(("NtGdiRemoveFontResourceW() releasing ghsemPublicPFT\n"));
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return( bRet );

}


/******************************Public*Routine******************************\
*
* BOOL APIENTRY GreRemoveAllButPermanentFonts()
*
* user is calling this on log off, unloads all but permanent fonts
* Should be called at the time when most of the references to the fonts
* are gone, for all the apps have been shut, so that all deletions proceed
* with no problem
*
* History:
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreRemoveAllButPermanentFonts()
{
// get and validate PFT user object

#ifdef FE_SB

// disable/unload system wide/facename eudc for current user.
// on win2k only.

// on hydra system, we will wait until the final clean up
// to avoid possible fe mem leak.

    if (G_fConsole)
    {
        GreEnableEUDC(FALSE);
    }

#endif

    BOOL bRet;
    {
        PUBLIC_PFTOBJ pfto;              // access the public font table

    // We really need to pass in the size of the string instead or 0~
    // This function should actually be completely removed and use
    // __bUnloadFont directly from the client.

        bRet = pfto.bUnloadAllButPermanentFonts();
    }

    if( bRet )
    {
        GreQuerySystemTime( &PFTOBJ::FontChangeTime );
    }

    return bRet;
}


/**************************************************************************\
*  Structures and constants for GreGetCharWidth()                          *
\**************************************************************************/

// BUFFER_MAX -- max number of elements in buffers on the frame

#define BUFFER_MAX 32

/******************************Public*Routine******************************\
* GreGetCharWidth                                                          *
*                                                                          *
* The GreGetCharWidth function retrieves the widths of individual          *
* characters in a consecutive group of characters from the                 *
* current font.  For example, if the wFirstChar parameter                  *
* identifies the letter a and the wLastChar parameter                      *
* identifies the letter z, the GetCharWidth function retrieves             *
* the widths of all lowercase characters.  The function stores             *
* the values in the buffer pointed to by the lpBuffer                      *
* parameter.                                                               *
*                                                                          *
* Return Value                                                             *
*                                                                          *
*   The return value specifies the outcome of the function.  It            *
*   is TRUE if the function is successful.  Otherwise, it is               *
*   FALSE.                                                                 *
*                                                                          *
* Comments                                                                 *
*                                                                          *
*   If a character in the consecutive group of characters does             *
*   not exist in a particular font, it will be assigned the                *
*   width value of the default character.                                  *
*                                                                          *
*   By complete fluke, the designers of the API allocated a WORD           *
*   for each character. This allows GPI to interpret the characters        *
*   as being part of the Unicode set. Old apps will still work.            *
*                                                                          *
* History:                                                                 *
*  Thu 24-Sep-1992 14:40:07 -by- Charles Whitmer [chuckwh]                 *
* Made it return an indication when the font is a simulated bitmap font.   *
* This allows WOW to make compatibility fixes.                             *
*                                                                          *
*  Wed 18-Mar-1992 08:58:40 -by- Charles Whitmer [chuckwh]                 *
* Made it use the very simple transform from device to world.  Added the   *
* FLOAT support.                                                           *
*                                                                          *
*  17-Dec-1991 by Gilman Wong [gilmanw]                                    *
* Removed RFONTOBJCACHE--cache access now merged into RFONTOBJ construc.   *
*                                                                          *
* converted to unicode (BodinD)                                            *
*                                                                          *
*  Fri 05-Apr-1991 15:20:39 by Kirk Olynyk [kirko]                         *
* Added wrapper class RFONTOBJCACHE to make sure that the cache is         *
* obtained before and released after getting glyph metric info.            *
*                                                                          *
*  Wed 13-Feb-1991 15:16:06 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/
/**************************************************************************\
* if pwc == NULL use the consecutive range                                 *
*   ulFirstChar, ulFirstChar + 1, ...., ulFirstChar + cwc - 1              *
*                                                                          *
* if pwc != NULL ignore ulFirstChar and use array of cwc WCHARS pointed to *
* by pwc                                                                   *
\**************************************************************************/

BOOL GreGetCharWidthW
(
    HDC    hdc,
    UINT   ulFirstChar,
    UINT   cwc,
    PWCHAR pwcFirst,     // ptr to the input buffer
    FLONG  fl,
    PVOID  lpBuffer
)
{
// we could put these two quantities in the union,
// wcCur is used iff pwcFirst is null, otherwise pwcCur is used

    UINT            wcCur;                 // Unicode of current element
    PWCHAR          pwcCur;                // ptr to the current element in the
                                           // input buffer.
    INT             ii;
    UINT            cBufferElements;        // count of elements in buffers

    EGLYPHPOS      *pgposCur;
    EFLOAT          efDtoW;
    PWCHAR          pwcBuffer;

    LONG *pl = (LONG *) lpBuffer;  // We assume sizeof(LONG)==sizeof(FLOAT).

    WCHAR           awcBuffer[BUFFER_MAX]; // Unicode buffer
    GLYPHPOS        agposBuffer[BUFFER_MAX]; // ptl fields not used

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (lpBuffer == (PVOID)NULL)
        return(FALSE);

    RFONTOBJ rfo(dco,FALSE, (fl & GCW_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetCharWidthW(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        if (pwcFirst)
            rfo.vFixUpGlyphIndices((USHORT *)pwcFirst, cwc);
        else
            rfo.vFixUpGlyphIndices((USHORT *)&ulFirstChar, 1);
    }

    efDtoW = rfo.efDtoWBase_31();          // Cache to reverse transform.

// Windows 3.1 has preserved a bug from long ago in which the extent of
// a bitmap simulated bold font is one pel too large.  We add this in for
// compatibility.  There's also an overhang with bitmap simulated italic
// fonts.

    FIX fxAdjust = 0;

    if (fl & GCW_WIN3)
    {
        fxAdjust = rfo.lOverhang() << 4;
    }

// a little initialization

    if (pwcFirst == (PWCHAR)NULL)
    {
        wcCur = ulFirstChar;
    }
    else
    {
        pwcCur = pwcFirst;
    }

// now do the work

    while (TRUE)
    {
    // fill the buffer

    // <calculate the number of items that will be placed in the buffer>
    // <update wcStart for the next filling of the buffer>
    // <fill the array of characters, awcBuffer,
    //  with a consecutive array of characters>
    // <translate the array of cBuffer codepoints to handles and place
    //  the array of glyph handles on the frame>
    // [Note: It is assumed in this code that characters that are
    //        not supported by the font are assigned the handle
    //        handle of the default character]

        WCHAR *pwc;
        UINT   wc,wcEnd;

        if (pwcFirst == (PWCHAR)NULL)
        {
        // are we done?

            if (wcCur > (ulFirstChar + cwc - 1))
            {
                break;
            }

            cBufferElements = min((cwc - (wcCur - ulFirstChar)),BUFFER_MAX);

            wcEnd = wcCur + cBufferElements;
            for (pwc = awcBuffer, wc = wcCur; wc < wcEnd; pwc++, wc++)
            {
                *pwc = (WCHAR)wc;
            }

            pwcBuffer = awcBuffer;
        }
        else
        {
        // are we done?

            if ((UINT)(pwcCur - pwcFirst) > (cwc - 1))
                break;

            //Sundown: safe to truncate to UINT
            cBufferElements = min((cwc - (UINT)(pwcCur - pwcFirst)),BUFFER_MAX);
            pwcBuffer = pwcCur;
        }

    // pwcBuffer now points to the next chars to be dealt with
    // cBufferElements now contains the number of chars at pwcBuffer


    // empty the buffer
    // Grab cGlyphMetrics pointers

        pgposCur = (EGLYPHPOS *) agposBuffer;

        if (!rfo.bGetGlyphMetrics(
            cBufferElements, // size of destination buffer
            pgposCur,        // pointer to destination buffe
            pwcBuffer,
            &dco))
        {
            return(FALSE);
        }

        if (fl & GCW_INT)
        {
            for (ii=0; ii<(INT) cBufferElements; ii++,pgposCur++)
            {
                *pl++ = lCvt(efDtoW,pgposCur->pgd()->fxD + fxAdjust);
            }
        }
        else
        {
            EFLOAT efWidth;

            for (ii=0; ii<(INT) cBufferElements; ii++,pgposCur++)
            {
                efWidth.vFxToEf(pgposCur->pgd()->fxD);
                efWidth *= efDtoW;
                *pl++ = efWidth.lEfToF();
            }
        }

        if (pwcFirst == (PWCHAR)NULL)
        {
            wcCur += cBufferElements;
        }
        else
        {
            pwcCur += (WCHAR) cBufferElements;
        }
    }
    return(TRUE);
}

BOOL GreFontIsLinked( HDC hdc )
{
    BOOL  bRet = FALSE;
    DCOBJ dco (hdc);

    if (dco.bValid())
    {
        // Realized the font
        RFONTOBJ rfo(dco, FALSE);

        if (rfo.bValid())
        {
            PRFONT   prfnt;
            PFEOBJ  pfeo(rfo.ppfe());

            // Don't change the EUDC
            INCREMENTEUDCCOUNT;

            prfnt = rfo.prfntFont();

            if (pfeo.bValid() && !pfeo.bEUDC())
            {
                if (prfnt->bIsSystemFont)
                {
                    if (gbSystemDBCSFontEnabled)
                        bRet = TRUE;
                }
                else
                {
                    if (IS_SYSTEM_EUDC_PRESENT())
                        bRet = TRUE;
                    else if (bFinallyInitializeFontAssocDefault)
                    {
                        IFIOBJR  ifio(pfeo.pifi(),rfo,dco);
                        BYTE jWinCharSet = (ifio.lfCharSet());

                        if ((jWinCharSet == ANSI_CHARSET) || (jWinCharSet == OEM_CHARSET) || (jWinCharSet == SYMBOL_CHARSET))
                        {
                            if(((jWinCharSet + 2) & 0xf) & fFontAssocStatus)
                                bRet = TRUE;
                        }
                    }

                    if (!bRet && pfeo.pGetLinkedFontEntry() != NULL)
                    {
                        bRet = TRUE;
                    }
                }
            }

            DECREMENTEUDCCOUNT;
        }
    }

    return bRet;
}

/**************************************************************************\
* GreGetCharWidthInfo                                                      *
*                                                                          *
* Get lMaxNegA lMaxNegC and lMinWidthC                                       *
*                                                                          *
* History:                                                                 *
*   09-Feb-1996  -by-  Xudong Wu  [tessiew]                                *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
GreGetCharWidthInfo(
   HDC           hdc,
   PCHWIDTHINFO  pChWidthInfo
)
{
   BOOL    bResult = FALSE; // essential
   DCOBJ   dco(hdc);

   if (dco.bValid())
   {
      RFONTOBJ  rfo(dco, FALSE);

      if (rfo.bValid())
      {
      // only support this for outline fonts for now
      // may remove this requirement later [bodind]

         PDEVOBJ pdo(rfo.hdevProducer());

      // As long as the driver LOOKS like the TrueType driver, we will
      // allow the call to succeed.  Otherwise, we quit right now!
      // In this case, TrueType means supporting the TrueType native-mode
      // outline format.

         if (PPFNVALID(pdo, QueryTrueTypeOutline) )
         {
            if (dco.pdc->bWorldToDeviceIdentity())
            {
               pChWidthInfo->lMaxNegA   = rfo.prfnt->lMaxNegA;
               pChWidthInfo->lMaxNegC   = rfo.prfnt->lMaxNegC;
               pChWidthInfo->lMinWidthD = rfo.prfnt->lMinWidthD;
            }
            else
            {

               EFLOAT   efDtoW;

               efDtoW = rfo.efDtoWBase_31();

            // transform from DEV to World

               pChWidthInfo->lMaxNegA   = lCvt(efDtoW, rfo.prfnt->lMaxNegA << 4);
               pChWidthInfo->lMaxNegC   = lCvt(efDtoW, rfo.prfnt->lMaxNegC << 4);
               pChWidthInfo->lMinWidthD = lCvt(efDtoW, rfo.prfnt->lMinWidthD << 4);
            }

            bResult = TRUE;
         }
      }
      #if DBG
      else
      {
         WARNING("gdisrv!GreGetCharWidthInfo(): could not lock HRFONT\n");
      }
      #endif

   }
   #if DBG
   else
   {
      WARNING("Invalid DC passed to GreGetCharWidthInfo\n");
   }
   #endif

   return bResult;
}


/******************************Public*Routine******************************\
* vConvertLogFontW                                                         *
*                                                                          *
* Converts a LOGFONTW to an EXTLOGFONTW.                                   *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogFontW(
    ENUMLOGFONTEXDVW *pelfexdvw,
    LOGFONTW    *plfw
    )
{
    ENUMLOGFONTEXW *pelfw = &pelfexdvw->elfEnumLogfontEx;
    pelfw->elfLogFont = *plfw;

    pelfw->elfFullName[0]   = 0;
    pelfw->elfStyle[0]      = 0;
    pelfw->elfScript[0]     = 0;

    pelfexdvw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
    pelfexdvw->elfDesignVector.dvNumAxes  = 0;

}


/******************************Public*Routine******************************\
* GreCreateFontIndirectW                                                   *
*                                                                          *
* Unicode extension of CreateFontIndirect                                  *
*                                                                          *
* History:                                                                 *
*  Mon 19-Aug-1991 07:00:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

HFONT
GreCreateFontIndirectW(
    LOGFONTW* plfw
    )
{
    ENUMLOGFONTEXDVW  elfw;
    vConvertLogFontW(&elfw,plfw);
    return(hfontCreate(&elfw, LF_TYPE_USER, 0, NULL));
}

/******************************Public*Routine******************************\
* BOOL GreGetCharABCWidthsW                                                *
*                                                                          *
* On input, a set of UNICODE codepoints (WCHARS) is specified in one of    *
* two ways:                                                                *
*                                                                          *
*  1) if pwch is NULL, then there is a consecutive set of codepoints       *
*     [wchFirst, wchFirst+cwch-1], inclusive.                              *
*                                                                          *
*  2) if pwch is non-NULL, then pwch points to a buffer containing cwch    *
*     codepoints (no particular order, duplicates allowed, wchFirst is     *
*     ignored).                                                            *
*                                                                          *
* The function will query the realized font for GLYPHDATA for each         *
* codepoint and compute the A, B, and C widths relative to the character   *
* baseline.  If the codepoint lies outside the supported range of the font,*
* the ABC widths of the default character are substituted.                 *
*                                                                          *
* The ABC widths are returned in LOGICAL UNITS via the pabc buffer.        *
*                                                                          *
* Returns:                                                                 *
*   TRUE if successful, FALSE otherwise.                                   *
*                                                                          *
* History:                                                                 *
*  Wed 18-Mar-1992 11:40:55 -by- Charles Whitmer [chuckwh]                 *
* Made it use the very simple transform from device to world.  Added the   *
* FLOAT support.                                                           *
*                                                                          *
*  21-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GreGetCharABCWidthsW
(
    HDC         hdc,            // font realized on this device
    UINT        wchFirst,       // first character (ignored if pwch !NULL)
    COUNT       cwch,           // number of characters
    PWCHAR      pwch,           // pointer to array of WCHAR
    FLONG       fl,             // integer or float version, glyphindex or unicode
    PVOID       pvBuf           // return buffer for ABC widths
)
{

    ABC       *pabc ;           // return buffer for ABC widths
    ABCFLOAT  *pabcf;           // return buffer for ABC widths
    GLYPHDATA *pgd;
    EFLOAT     efDtoW;
    LONG       lA,lAB,lD;
    COUNT      cRet;

    pabc  = (ABC *)      pvBuf;
    pabcf = (ABCFLOAT *) pvBuf;

// Create and validate DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }


// Early out (nothing to do).

    if (cwch == 0)
        return (TRUE);

// Create and validate RFONT user objecct.

    RFONTOBJ rfo(dco, FALSE, (fl & GCABCW_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetCharABCWidthsW(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        if (pwch)
            rfo.vFixUpGlyphIndices((USHORT *)pwch, cwch);
        else
            rfo.vFixUpGlyphIndices((USHORT *)&wchFirst, 1);
    }

    efDtoW = rfo.efDtoWBase_31();          // Cache to reverse transform.

    PDEVOBJ pdo(rfo.hdevProducer());

// Fail if integer case and not TrueType.  In this case, TrueType means
// any font driver that provides the enhanced "TrueType"-like behavior.
// We'll base this on the same criterion as for GetOutlineTextMetrics--i.e.,
// whether or not the DrvQueryTrueTypeOutline function is exported.
//
// We will let any driver provide the FLOAT character ABC widths.

// We will also let GlyphIndex version  of the api work for any fonts

    if (!(fl & GCABCW_GLYPH_INDEX) && (fl & GCABCW_INT) && (!PPFNVALID(pdo, QueryTrueTypeOutline)))
    {
        return (FALSE);
    }

// Use these buffers to process the input set of WCHARs.

    WCHAR awc[BUFFER_MAX];          // UNICODE buffer (use if pwch is NULL)
    GLYPHPOS agp[BUFFER_MAX];       // ptl fields not used

// Process the WCHARs in subsets of BUFFER_MAX number of WCHARs.

    do
    {
        PWCHAR pwchSubset;          // pointer to WCHAR buffer to process
        EGLYPHPOS *pgp = (EGLYPHPOS *) agp;
        EGLYPHPOS *pgpStop;

    // How many to process in this subset?

        COUNT cwchSubset = min(BUFFER_MAX, cwch);

    // Get a buffer full of WCHARs.

        if (pwch != NULL)
        {
        // Use the buffer passed in.

            pwchSubset = pwch;

        // Move pointer to the start of the next subset to process.

            pwch += cwchSubset;
        }

        else
        {
        // Generate our own (contiguous) set of WCHARs in the awc temporary
        // buffer on the stack.

            pwchSubset = awc;
            PWCHAR pwchStop = pwchSubset + cwchSubset;

            while (pwchSubset < pwchStop)
            {
                *pwchSubset = (WCHAR)wchFirst;
                pwchSubset++;
                wchFirst++;
            }
            pwchSubset = awc;
        }


    // Initialize number of elements in agp to process.

        COUNT cpgpSubset = cwchSubset;

    // Compute the ABC widths for each HGLYPH.

        do
        {
        // Grab as many PGLYPHDATA as we can.
        // pwchSubset points to the chars
        // NOTE: This code could be cleaned up some [paulb]

            cRet = cpgpSubset;

            if (!rfo.bGetGlyphMetrics(
                        cpgpSubset, // size of destination buffer
                        pgp,        // pointer to destination buffer
                        pwchSubset,  // chars to xlat
                        &dco
                        ))
            {
                return FALSE;
            }

        // For each PGLYPHDATA returned, compute the ABC widths.

            if (fl & GCABCW_INT)
            {
                for (pgpStop=pgp+cRet; pgp<pgpStop; pgp++)
                {
                    pgd = pgp->pgd();

                    lA  = lCvt(efDtoW,pgd->fxA);
                    lAB = lCvt(efDtoW,pgd->fxAB);
                    lD  = lCvt(efDtoW,pgd->fxD);
                    pabc->abcA = (int)lA;
                    pabc->abcB = (UINT)(lAB - lA);
                    pabc->abcC = (int)(lD - lAB);
                    pabc++;
                }
            }
            else
            {
                EFLOAT efWidth;

                for (pgpStop=pgp+cRet; pgp<pgpStop; pgp++)
                {
                    pgd = pgp->pgd();

                    efWidth = pgd->fxA;
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfA) = efWidth.lEfToF();

                    efWidth = (pgd->fxAB - pgd->fxA);
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfB) = efWidth.lEfToF();

                    efWidth = (pgd->fxD - pgd->fxAB);
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfC) = efWidth.lEfToF();
                    pabcf++;
                }
            }

        // Compute number of elements left in the subset to process.

            cpgpSubset -= cRet;
            pwchSubset += cRet;

        } while (cpgpSubset > 0);

    // Subtract off the number processed.
    // cwch is now the number left to process.

        cwch -= cwchSubset;

    } while (cwch > 0);

    return (TRUE);
}

/******************************Public*Routine******************************\
* bGetNtoWScale                                                            *
*                                                                          *
* Calculates the Notional to World scaling factor for vectors that are     *
* parallel to the baseline direction.                                      *
*                                                                          *
* History:                                                                 *
*  Sat 21-Mar-1992 08:03:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
bGetNtoWScale(
    EFLOAT *pefScale,   // return address of scaling factor
    DCOBJ& dco,         // defines device to world transformation
    RFONTOBJ& rfo,      // defines notional to device transformation
    PFEOBJ& pfeo        // defines baseline direction
    )
{
    MATRIX    mxNtoW, mxNtoD;
    EXFORMOBJ xoNtoW(&mxNtoW, DONT_COMPUTE_FLAGS);
    EXFORMOBJ xoNtoD(&mxNtoD, DONT_COMPUTE_FLAGS);

    xoNtoD.vSetElementsLToFx(
        rfo.pfdx()->eXX,
        rfo.pfdx()->eXY,
        rfo.pfdx()->eYX,
        rfo.pfdx()->eXX
        );
    xoNtoD.vRemoveTranslation();
    xoNtoD.vComputeAccelFlags();
    {
    //
    // The notional to world transformation is the product of the notional
    // to device transformation and the device to world transformation
    //

        EXFORMOBJ xoDtoW(dco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
        {
            WARNING("gdisrv!GreGetKerningPairs -- xoDtoW is not valid\n");
            return(FALSE);
        }
        if (!xoNtoW.bMultiply(xoNtoD,xoDtoW))
        {
            WARNING("gdisrv!GreGetKerningPairs -- xoNtoW.bMultiply failed\n");
            return(FALSE);
        }
        xoNtoW.vComputeAccelFlags();
    }

    IFIOBJ ifio(pfeo.pifi());
    EVECTORFL evflScale(ifio.pptlBaseline()->x,ifio.pptlBaseline()->y);
//
// normalize then trasform the baseline vector
//
    EFLOAT ef;
    ef.eqLength(*(POINTFL *) &evflScale);
    evflScale /= ef;
    if (!xoNtoW.bXform(evflScale))
    {
        WARNING("gdisrv!GreGetKerningPairs -- xoNtoW.bXform(evflScale) failed\n");
        return(FALSE);
    }
//
// The scaling factor is equal to the length of the transformed Notional
// baseline unit vector.
//
    pefScale->eqLength(*(POINTFL *) &evflScale);
//
// [kirko] This last scaling is a very embarrasing hack.
// If things are the way that I thing that they should be,
// then the calculation of the Notional to Device transformation
// should end here. But nooooooo. It just didn't seem to work.
// I put the extra scaling below it,
// because it seems to give the right number.
// The correct thing to do is understand what sort of numbers are
// being put into the Notional to Device transformations contained
// in the CONTEXTINFO structure in the RFONTOBJ.
//
    pefScale->vTimes16();

    return(TRUE);
}

/******************************Public*Routine******************************\
* GreGetKerningPairs                                                       *
*                                                                          *
* Engine side funcition for GetKerningPairs API. Calls to the font         *
* driver to get the information.                                           *
*                                                                          *
* History:                                                                 *
*  Mon 22-Mar-1993 21:38:26 -by- Charles Whitmer [chuckwh]                 *
* Added exception handling to the reading of the font driver data.         *
*                                                                          *
*  29-Oct-1992 Gilman Wong [gilmanw]                                       *
* Moved driver call out of this function and into PFEOBJ (as part of the   *
* IFI/DDI merge).                                                          *
*                                                                          *
*  Thu 20-Feb-1992 09:52:19 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


ULONG
GreGetKerningPairs(
    HDC hdc,
    ULONG cPairs,
    KERNINGPAIR *pkpDst
)
{
    COUNT cPairsRet = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Create and validate RFONT user objecct.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Lock down PFE user object.

            PFEOBJ pfeo(rfo.ppfe());

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!GreGetKerningPairs(): bad HPFE\n" );

        // Is this a request for the count?
        //
        // When using client-server, (cPairs == 0) is the signal from the
        // client side that the return buffer is NULL and this is a request for
        // the count.
        //
        // However, callers that call directly to the server side may still
        // pass in NULL to request count.  Hence the need for both cases below.

            if ((cPairs == 0) || (pkpDst == (KERNINGPAIR *) NULL))
            {
                cPairsRet = ((ULONG) pfeo.pifi()->cKerningPairs);
            }
            else
            {
                // Get pointer to the kerning pairs from PFEOBJ.
                // Clip number of kerning pairs to not exceed capacity of the buffer.

                FD_KERNINGPAIR *pfdkpSrc;
                cPairsRet = min(pfeo.cKernPairs(&pfdkpSrc), cPairs);

                // Get the Notional to World scaling factor in the baseline direction.
                // Kerning values are scalers in the baseline direction.

                EFLOAT efScale;

                if (bGetNtoWScale(&efScale,dco,rfo,pfeo))
                {
                    // Set up to loop through the kerning pairs.

                    KERNINGPAIR *pkp       = pkpDst;
                    KERNINGPAIR *pkpTooFar = pkpDst + cPairsRet;

                    // Never trust a pkp given to us by a font driver!

                    __try
                    {
                        for ( ; pkp < pkpTooFar; pfdkpSrc += 1, pkp += 1 )
                        {
                            pkp->wFirst      = pfdkpSrc->wcFirst;
                            pkp->wSecond     = pfdkpSrc->wcSecond;
                            pkp->iKernAmount = (int) lCvt(efScale,(LONG) pfdkpSrc->fwdKern);
                        }
                    }

                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        cPairsRet = 0;
                    }
                }
                else
                {
                    WARNING("gdisrv!GreGetKerningPairs(): bGetNtoWScale failed\n");
                    cPairsRet = 0;
                }
            }
        }
        else
        {
            WARNING("gdisrv!GreGetKerningPairs(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING("GreGetKerningPairs failed - invalid DC\n");
    }

    return(cPairsRet);
}

//
// A mask of all valid font mapper filtering flags.
//

#define FONTMAP_MASK    ASPECT_FILTERING



/******************************Public*Routine******************************\
* GreGetAspectRatioFilter
*
* Returns the aspect ration filter used by the font mapper for the given
* DC.  If no aspect ratio filtering is used, then a filter size of (0, 0)
* is returned (this is compatible with the Win 3.1 behavior).
*
* Returns:
*   TRUE if sucessful, FALSE otherwise.
*
* History:
*  08-Apr-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetAspectRatioFilter (
    HDC    hdc,
    LPSIZE lpSize
    )
{
    BOOL bRet = FALSE;

// Parameter check.

    if ( lpSize == (LPSIZE) NULL )
    {
        WARNING("gdisrv!GreGetAspectRatioFilter(): illegal parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return bRet;
    }

// Create and validate DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        WARNING("gdisrv!GreGetAspectRatioFilter(): invalid HDC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return bRet;   // return error
    }

// Create and validate PDEV user object.

    PDEVOBJ pdo(dco.hdev());

    ASSERTGDI (
        dco.bValid(),
        "gdisrv!GreGetAspectRatioFilter(): invalid HPDEV\n"
        );

// If mapper flags set, return device resolution.

    if ( dco.pdc->flFontMapper() & ASPECT_FILTERING )
    {
        lpSize->cx = pdo.ulLogPixelsX();
        lpSize->cy = pdo.ulLogPixelsY();
    }

// Otherwise, return (0,0)--this is compatible with Win 3.1.

    else
    {
        lpSize->cx = 0;
        lpSize->cy = 0;
    }

// Return success.

    bRet = TRUE;
    return bRet;
}

/******************************Public*Routine******************************\
* GreMarkUndeletableFont
*
* Mark a font as undeletable.  Private entry point for USERSRV.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Put undeletable support in the handle manager.
*
*  25-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID GreMarkUndeletableFont(HFONT hfnt)
{
    HmgMarkUndeletable((HOBJ)hfnt, LFONT_TYPE);
}

/******************************Public*Routine******************************\
* GreMarkDeletableFont
*
* Mark a font as deletable.  Private entry point for USERSRV.
*
* Note:
*   This can't be used to mark a stock font as deletable.  Only PDEV
*   destruction can mark a stock font as deletable.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Put undeletable support in the handle manager.
*
*  25-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID GreMarkDeletableFont(HFONT hfnt)
{
// We won't mark it deletable if it's a stock font.

    LFONTOBJ lfo((HLFONT) hfnt);

// Check that hfnt is good, nothing gurantees it's good.  We assert because
// it is a malicious situation if it is bad, but we must check.

    ASSERTGDI(lfo.bValid(), "ERROR user passed invalid hfont");

    if (lfo.bValid())
    {
    // Make sure it's not a stock font, User can't mark those as deletable.

        if (!(lfo.fl() & LF_FLAG_STOCK))
        {
            HmgMarkDeletable((HOBJ)hfnt, LFONT_TYPE);
        }
    }
}


/******************************Public*Routine******************************\
* GetCharSet()
*
* Fast routine to get the char set of the font currently in the DC.
*
* History:
*  23-Aug-1993 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


DWORD GreGetCharSet
(
    HDC          hdc
)
{
    FLONG    flSim;
    POINTL   ptlSim;
    FLONG    flAboutMatch;
    PFE     *ppfe;

    DCOBJ dco (hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (DEFAULT_CHARSET << 16); // correct error code
    }

    if (dco.ulDirty() & DIRTY_CHARSET)
    {
    // force mapping

        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "gdisrv!GetCharSet: bad pdev in dc\n");

        if (!pdo.bGotFonts())
            pdo.bGetDeviceFonts();

        LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

        if (!lfo.bValid())
        {
            WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
            return(DEFAULT_CHARSET << 16);
        }
        {
        // Stabilize the public PFT for mapping.

            SEMOBJ  so(ghsemPublicPFT);

        // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
        // a simulation type (ist)
        // also store charset to the DC

            ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch);

            ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
                      "NtGdiGetCharSet, charset is dirty\n");

        }
    }

    return dco.pdc->iCS_CP();
}

extern "C" DWORD NtGdiGetCharSet
(
    HDC          hdc
)
{
    return(GreGetCharSet(hdc));
}



/******************************Public*Routine******************************\
*
* int GreGetTextCharsetInfo
*
*
* Effects: stub to be filled
*
* Warnings:
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0
// this is win95 code inserted here as a comment:

int WINGDIAPI GetTextCharsetInfo( HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags )
{
    UINT charset;
    PFF hff ;
    sfnt_OS2Ptr pOS2;
    int i;

    if (!lpSig)
        return GetTextCharset( hdc );

    if( IsBadWritePtr(lpSig,sizeof(FONTSIGNATURE)) )
    {
    //
    // cant return 0 - thats ANSI_CHARSET!
    //
        return DEFAULT_CHARSET;
    }

    charset = GetTextCharsetAndHff(hdc, &hff);
    if (hff)
    {
        pOS2 = ReadTable( hff, tag_OS2 );
        if (pOS2)
        {
            if (pOS2->Version)
            {
            //
            // 1.0 or higher is TT open
            //
                for (i=0; i<4; i++)
                {
                    lpSig->fsUsb[i] = SWAPL(pOS2->ulCharRange[i]);
                }
                for (i=0; i<2; i++)
                {
                    lpSig->fsCsb[i] = SWAPL(pOS2->ulCodePageRange[i]);
                }
                return charset;
            }
        }
    }

    //
    // raster font/tt but not open/whatever, zero out the field.
    //
    lpSig->fsUsb[0] =
    lpSig->fsUsb[1] =
    lpSig->fsUsb[2] =
    lpSig->fsUsb[3] =
    lpSig->fsCsb[0] =
    lpSig->fsCsb[1] = 0;    // all zero - this font has no hff

    return charset;

}

#endif


/******************************Public*Routine******************************\
*
* int APIENTRY GreGetTextCharsetInfo(
*
* Effects: One of the new win95 multilingual api's
*
* Warnings:
*
* History:
*  17-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GreGetTextCharsetInfo(
    HDC hdc,
    LPFONTSIGNATURE lpSig,
    DWORD dwFlags)
{
    dwFlags;      // not used

    DWORD  uiCharset = NtGdiGetCharSet(hdc) >> 16;
    if (!lpSig)
        return uiCharset;

// on to get the signature

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Get RFONT user object.  Need this to realize font.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Get PFE user object.

            PFEOBJ pfeo(rfo.ppfe());
            if (pfeo.bValid())
            {
                PTRDIFF dpFontSig = 0;

                if (pfeo.pifi()->cjIfiExtra > offsetof(IFIEXTRA, dpFontSig))
                {
                    dpFontSig = ((IFIEXTRA *)(pfeo.pifi() + 1))->dpFontSig;
                }

                if (dpFontSig)
                {
                    *lpSig = *((FONTSIGNATURE *)
                               ((BYTE *)pfeo.pifi() + dpFontSig));
                }
                else
                {
                    lpSig->fsUsb[0] = 0;
                    lpSig->fsUsb[1] = 0;
                    lpSig->fsUsb[2] = 0;
                    lpSig->fsUsb[3] = 0;
                    lpSig->fsCsb[0] = 0;
                    lpSig->fsCsb[1] = 0;
                }
            }
            else
            {
                WARNING("GetFontData(): could not lock HPFE\n");
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);

            // this is what win95 returns on errors

                uiCharset = DEFAULT_CHARSET;
            }
        }
        else
        {
            WARNING("GetFontData(): could not lock HRFONT\n");

        // this is what win95 returns on errors

            uiCharset = DEFAULT_CHARSET;
        }
    }
    else
    {
        WARNING("GreGetTextCharsetInfo: bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);

    // this is what win95 returns on errors

        uiCharset = DEFAULT_CHARSET;
    }

    return (int)uiCharset;
}


/******************************Public*Routine******************************\
*
* DWORD GreGetFontLanguageInfo(HDC hdc)
*
*
* Effects: This function returns some font information which, for the most part,
*          is not very interesting for most common fonts. I guess it would be
*          little bit more interesting in case of fonts that require
*          lpk processing, which NT does not support as of version 4.0,
*          or in case of tt 2.0.
*
* History:
*  01-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD dwGetFontLanguageInfo(XDCOBJ& dco)
{
    DWORD dwRet = GCP_ERROR;

// Get PDEV user object.  We also need to make
// sure that we have loaded device fonts before we go off to the font mapper.
// This must be done before the semaphore is locked.

    PDEVOBJ pdo(dco.hdev());

    if (!pdo.bValid())
        return dwRet;

    if (!pdo.bGotFonts())
        pdo.bGetDeviceFonts();

// Lock down the LFONT.

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

    if (lfo.bValid())
    {
    // Stabilize font table (grab semaphore for public PFT).

        SEMOBJ  so(ghsemPublicPFT);

    // Lock down PFE user object.

        FLONG flSim;
        FLONG flAboutMatch;
        POINTL ptlSim;

        PFEOBJ pfeo(lfo.ppfeMapFont(dco,&flSim,&ptlSim, &flAboutMatch));

        ASSERTGDI (
            pfeo.bValid(),
            "gdisrv!GreGetTextFaceW(): bad HPFE\n"
            );

    // no failing any more, can set it to zero

        dwRet = 0;

        if (pfeo.pifi()->cKerningPairs)
            dwRet |= GCP_USEKERNING;

    // Also, FLI_MASK bit is "OR"-ed in, don't ask me why.
    // now we have win95 compatible result, whatever it may mean.

        if (pfeo.pifi()->flInfo & (FM_INFO_TECH_TRUETYPE | FM_INFO_TECH_TYPE1))
        {
        // only tt or otf fonts may contain glyphs that are not accessed
        // throught cmap table

            dwRet |= FLI_GLYPHS;
        }
    }
    else
    {
        WARNING("gdisrv!GreGetTextFaceW(): could not lock HLFONT\n");
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
*
* DWORD GreGetFontUnicodeRanges(HDC, LPGLYPHSET);
*
* Effects: expose font's unicode content to the applications
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD GreGetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgset)
{

    DWORD dwRet = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Create and validate RFONT user objecct.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Lock down PFE user object.

            PFEOBJ pfeo(rfo.ppfe());

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!GreGetFontUnicodeRanges(): bad HPFE\n");

            FD_GLYPHSET * pfdg = pfeo.pfdg();

            if (!pfdg)
            {
                WARNING("gdisrv!GreGetFontUnicodeRanges(): pfdg invalid\n");
                return dwRet;
            }

        // Is this a request for the size of the buffer?

            dwRet = offsetof(GLYPHSET,ranges) + pfdg->cRuns * sizeof(WCRANGE);
            if (pgset)
            {
                pgset->cbThis           = dwRet;
                pgset->cGlyphsSupported = pfdg->cGlyphsSupported;
                pgset->cRanges          = pfdg->cRuns;

                pgset->flAccel          = 0;
                if (pfdg->flAccel & GS_8BIT_HANDLES)
                    pgset->flAccel |= GS_8BIT_INDICES;

                for (DWORD iRun = 0; iRun < pfdg->cRuns; iRun++)
                {
                    pgset->ranges[iRun].wcLow   = pfdg->awcrun[iRun].wcLow;
                    pgset->ranges[iRun].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                }
            }

            pfeo.vFreepfdg();
        }
        else
        {
            WARNING("gdisrv!GreGetFontUnicodeRanges(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING("GreGetFontUnicodeRanges failed - invalid DC\n");
    }

    return(dwRet);
}


#ifdef LANGPACK
BOOL GreGetRealizationInfo( HDC hdc, PREALIZATION_INFO pri )
{
    BOOL bRet = FALSE;
    XDCOBJ dco(hdc);

    if(dco.bValid())
    {
        RFONTOBJ rfo(dco,FALSE);

        if(rfo.bValid())
        {
            bRet = rfo.GetRealizationInfo(pri);
        }
        else
        {
            WARNING("GreRealizationInfo: Invalid DC");
        }

        dco.vUnlockFast();
    }
    else
    {
        WARNING("GreGetRealizationInfo: Invalid DC");
    }

    return(bRet);

}

extern "C" BOOL EngLpkInstalled()
{
    return( gpGdiSharedMemory->dwLpkShapingDLLs != 0 );
}

#endif


/**************************Public*Routine***************************\
*
* BOOL  GreRemoveFontMemResourceEx()
*
* History:
*   09-Jun-1997  Xudong Wu [TessieW]
*  Wrote it.
*
\*******************************************************************/
BOOL  GreRemoveFontMemResourceEx(HANDLE hMMFont)
{
    BOOL    bRet = FALSE;
    PFF     *pPFF, **ppPFF;

    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (pfto.bValid())
    {
        // Sundown safe truncation,  hMMFont is not a real handle
        if (pPFF = pfto.pPFFGetMM((ULONG)(ULONG_PTR)hMMFont, &ppPFF))
        {
            // remove the pPFF from the font table
            // bUnloadWorkhorse should release ghsemPublicPFT

            if (!(bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, FR_PRIVATE | FR_NOT_ENUM)))
            {
                WARNING("GreRemoveFontMemResourceEx() failed on bUnloadWorkhorse()\n");
            }
        }
        else
        {
            WARNING("GreRemoveFontMemResourceEx(): can't find the PFF\n");
            GreReleaseSemaphoreEx(ghsemPublicPFT);
        }
    }
    else
    {
        WARNING("GreRemoveFontMemResourceEx(): invalid private PFT table\n");
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontsub.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontsub.cxx
*
* Support for the [FontSubstitutes] section of WIN.INI (new functionality
* from Windows 3.1).
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

// In Windows 3.1, there is a [FontSubstitutes] section that allows
// face names in LOGFONTs to match other facenames.
//
// For example,
//
//  [FontSubstitutes]
//      Helv=MS Sans Serif
//
// means that a LOGFONT with a lfFacename of "Helv" will match a physical
// font with a facename of either "Helv" or "MS Sans Serif".  That is,
// "Helv" has an alternate match (or substitute match) of "MS Sans Serif".
//
// In Win 3.1, the standard "Helv" and "Tms Rmn" faces have been replaced
// with "MS Sans Serif" and "MS Serif", respectively.  This substitution
// capability provides Win 3.1 with Win 3.0 compatibility for apps that
// use the old name convention.

#include "precomp.hxx"
#include "winuserp.h"

extern "C" VOID vInitFontSubTable();
extern "C" NTSTATUS QueryRegistryFontSubstituteListRoutine(
                                     PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID);

#pragma alloc_text(INIT, vInitFontSubTable)
#pragma alloc_text(INIT, QueryRegistryFontSubstituteListRoutine)

// #define DBG 1

#if DBG
VOID DbgPrintFontSubstitutes();
#endif

// This is a global reference to the font substitution table.  If the table
// is not initialized properly, then this is NULL and should not be
// dereferenced.

PFONTSUB gpfsTable = NULL;;

// Set the initial as 1 for we need to hack for Notes R5

COUNT    gcfsTable = 0;

// count of valid entries of the form face1,ch1=face2,ch2

COUNT    gcfsCharSetTable = 0;
BOOL     gbShellFontCompatible = FALSE;


LONG cCapString(WCHAR *pwcDst,WCHAR *pwcSrc,INT cMax);

/******************************Public*Routine******************************\
*
* PWSTR pwszFindComma(PWSTR pwszInput)
*
*
* Effects:   return the pointer to the charset string which is
*            starting immediately after the comma or if no comma is found,
*            return NULL
*
* History:
*  27-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PWSTR pwszFindComma(PWSTR pwszInput)
{
    PWSTR pwszEnd = pwszInput + LF_FACESIZE;

    for (; (*pwszInput != L'\0') && (pwszInput < pwszEnd); pwszInput++)
    {
        if (*pwszInput == L',')
            return (++pwszInput);
    }
    return NULL;
}



extern "C"

VOID vCheckCharSet(FACE_CHARSET *pfcs, WCHAR * pwsz); // in mapfile.c


/******************************Public*Routine******************************\
*
* VOID vProcessEntry
*
*
* Effects:  given value name string (or value data string)
*           produce face name string and charset
*
* History:
*  28-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vProcessEntry(PWSZ pwszIn, FACE_CHARSET *pfcs, PWSZ pwszOriginal)
{
    PWSZ     pwszCharSet;
    INT      cwc;

// now is the time to see if this is one of the entries of the form
// Face1=Face2 (old format), or if this is one of the new entries of the form:
// Face1,charset1=Face2,charset2.

    if (pwszCharSet = pwszFindComma(pwszIn))
    {
        //Sundown: cwc is within range of LF_FASESIZE which is 32
        // safe to truncate
        cwc = (INT)(pwszCharSet - pwszIn);

    // now need to produce and validate charset number from the string
    // that follows the comma

        vCheckCharSet(pfcs, pwszCharSet);
    }
    else
    {
    // mark the field as being left unspecified. In mapping this means
    // do not replace lfCharSet in the logfont when trying the alternate
    // name. In enumeration this means that this field should not be
    // taken into account

        cwc = LF_FACESIZE;
        pfcs->jCharSet = DEFAULT_CHARSET;
        pfcs->fjFlags  = FJ_NOTSPECIFIED;
    }

// now write the string

    cCapString(pfcs->awch, pwszIn, cwc);

// finally save the original facename which is not necessarrily capitalized

    if (pwszOriginal)
    {
        if (pwszCharSet)
        {
            cwc--;
            RtlMoveMemory(pwszOriginal, pwszIn, cwc * sizeof(WCHAR));
            pwszOriginal[cwc] = L'\0';
        }
        else
        {
            wcscpy(pwszOriginal, pwszIn);
        }
    }
}

extern "C"
NTSTATUS
QueryRegistryFontSubstituteListRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{

    PBYTE pjBuffer;
    FONTSUB fs;

    vProcessEntry((PWSZ) ValueData, &fs.fcsAltFace, NULL);
    vProcessEntry((PWSZ) ValueName, &fs.fcsFace, (PWSZ)fs.awchOriginal);

// the following check eliminates the garbage entries that may have possibly
// been entered in win.ini in the font substitution section

    if
    (
       (fs.fcsFace.fjFlags == fs.fcsAltFace.fjFlags)
       &&
       (fs.fcsFace.fjFlags != FJ_GARBAGECHARSET)
    )
    {
        pjBuffer = (PBYTE) PALLOCMEM((gcfsTable+1) * sizeof(FONTSUB),'bsfG');

        if (pjBuffer)
        {
            if (gpfsTable)
            {
                RtlMoveMemory(pjBuffer,
                              gpfsTable,
                              gcfsTable * sizeof(FONTSUB));

                VFREEMEM(gpfsTable);
            }

            gpfsTable = (PFONTSUB) pjBuffer;

        // copy new data that we have verified to be valid

            gpfsTable[gcfsTable] = fs;
            gcfsTable++;
            if (!fs.fcsFace.fjFlags) // if charset is specified
                gcfsCharSetTable++;

            if (!gbShellFontCompatible &&
                ! _wcsicmp((PWSZ)fs.fcsFace.awch, L"MS Shell Dlg") && 
                ! _wcsicmp((PWSZ)fs.fcsAltFace.awch, L"Microsoft Sans Serif")
            )
                gbShellFontCompatible = TRUE;
        }
        else
        {
        // we do not have enough memory - return failiure

            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;

}
/******************************Public*Routine******************************\
* vInitFontSubTable
*
* Initializes the font substitutes table from data in the [FontSubstitutes]
* section of the WIN.INI file.  No error return code is provided since, if
* this is not successful, then the table simply will not exist and the
* global pointer to the table will remain NULL.
*
\**************************************************************************/

extern "C" VOID vInitFontSubTable()
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    QueryTable[0].QueryRoutine = QueryRegistryFontSubstituteListRoutine;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    //
    // Initialize to an empty table
    //

    gpfsTable = (PFONTSUB) NULL;
    gcfsTable = 1;
    gcfsCharSetTable = 0;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontSubstitutes",
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status))
    {
        WARNING("Failiure to get font list\n");
    }

    // by now, the substitution table should exist already, if not because there is nothing in the
    // registry for instance, then we allocate it now and fill the first entry.

    if (!gpfsTable)
    {
        gpfsTable = (PFONTSUB) PALLOCMEM(gcfsTable * sizeof(FONTSUB),'bsfG');
    }

    if (gpfsTable)
    {
        wcscpy(gpfsTable->awchOriginal, L"Default Sans Serif");
        wcscpy(gpfsTable->fcsFace.awch, L"DEFAULT SANS SERIF");
        wcscpy(gpfsTable->fcsAltFace.awch, L"MS SANS SERIF");
        gpfsTable->fcsFace.jCharSet = DEFAULT_CHARSET;
        gpfsTable->fcsFace.fjFlags  = FJ_NOTSPECIFIED;
        gpfsTable->fcsAltFace.jCharSet = DEFAULT_CHARSET;
        gpfsTable->fcsAltFace.fjFlags  = FJ_NOTSPECIFIED;
    }
    else
    {
        gcfsTable = 0;
    }

#if 0 // don't want to do this any more
    DbgPrintFontSubstitutes();
#endif

}


/******************************Public*Routine******************************\
* pfsubAlternateFacename
*
* Search the font substitutes table for an alternative facename for the
* given facename.
*
* Return:
*   Pointer to alt facename, NULL if not found.
*
* History:
*  28-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFONTSUB pfsubAlternateFacename (
    PWCHAR  pwchFacename
    )
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;
    WCHAR    awchCapName[LF_FACESIZE];

// Want case insensitive search, so capitalize the name.

    cCapString(awchCapName, pwchFacename, LF_FACESIZE);

// Scan through the font substitution table for the key string.

    for (; pfs < pfsEnd; pfs++)
    {
        if
        (
            !wcscmp(awchCapName,pfs->fcsFace.awch) &&
            ((pfs->fcsFace.fjFlags & FJ_NOTSPECIFIED) || (pfs->fcsFace.jCharSet == pfs->fcsAltFace.jCharSet))
        )
        {
        // This routine is only used in font enumeration when facename of
        // the fonts that are wished to be enumerated is specified as input.
        // We only want to enumerate the correct charsets, that is those that
        // are specified on the right hand side (if they are specified at all)

            if (pfs == gpfsTable)
            {
                // check the compatibility flag.
                if (GetAppCompatFlags2(VER40) & GACF2_FONTSUB)
                    return pfs;
            }
            else
                return pfs;
        }
    }

// Nothing found, so return NULL.

    return NULL;
}

/******************************Public*Routine******************************\
*
* pfsubGetFontSub
*
* Effects:
*
* Warnings:
*
* History:
*  05-Feb-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



FONTSUB * pfsubGetFontSub (
    PWCHAR  pwchFacename,   // face name specified in logfont
    BYTE    lfCharset       // charset specified in logfont
    )
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;
    WCHAR    awchCapName[LF_FACESIZE];

// We will set pfsNameOnly to point to a pfsub entry if for this entry
// the charset is NOT specified and the facename maches the facename
// from the logfont. That is pfsNameOnly can only point to an old style
// substitution of the form facename1=facename2.

    PFONTSUB pfsNameOnly = NULL;

// We will set pfsNameAndCharset to point to a pfsub entry if for this entry
// the charset IS specified and both facename and charset match.
// If both pfsNameAndCharset and pfsNameOnly are nonzero after going through
// the font substitution list, we will return pfsNameAndCharset from
// the function. For example, font substitution table for the Russian locale
// on win95 may have all three of the following entries:
//
// Times=Times New Roman    // old style value
// Times,204=Times New Roman,204
// Times,0=Times New Roman,204
//
// Thus if the application specifies Times,0 or Times,204 in the logfont,
// Times New Roman,204 will be used. If the application asks for Times,161
// it will get Times New Roman,161.


    PFONTSUB pfsNameAndCharset = NULL;

// Want case insensitive search, so capitalize the name.

    cCapString(awchCapName, pwchFacename, LF_FACESIZE);

// Scan through the font substitution table for the key string.

    for (; pfs < pfsEnd; pfs++)
    {
    // Do wcscmp inline for speed:

        if (!wcscmp(awchCapName,pfs->fcsFace.awch))
        {
        // we found a facename match, check if we should match charset
            if (pfs == gpfsTable)
            {
                // check the compatibility flag.
                if (GetAppCompatFlags2(VER40) & GACF2_FONTSUB)
                {
                    pfsNameOnly = pfs;
                    break;
                }
            }
            else
            {
                if (pfs->fcsFace.fjFlags & FJ_NOTSPECIFIED)
                {
                    pfsNameOnly = pfs;
                }
                else // charset is specified, now see if it matches the logfont
                {
                    if (lfCharset == pfs->fcsFace.jCharSet)
                        pfsNameAndCharset = pfs;
                }
            }
        }
    }

    return (pfsNameAndCharset ? pfsNameAndCharset : pfsNameOnly);
}




#if DBG
VOID DbgPrintFontSubstitutes()
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;

    //
    // Scan through the font substitution table for the key string.
    //

    KdPrint(("[FontSubstitutes]\n"));

    for (; pfs < pfsEnd; pfs++)
        KdPrint(("\t%ws: %ws, %d, fj=0x%x = %ws, %d, fj=0x%x \n",
                  pfs->awchOriginal,
                  pfs->fcsFace.awch,
                  (USHORT)pfs->fcsFace.jCharSet,
                  (USHORT)pfs->fcsFace.fjFlags,
                  pfs->fcsAltFace.awch,
                  (USHORT)pfs->fcsAltFace.jCharSet,
                  (USHORT)pfs->fcsAltFace.fjFlags
                  ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\guids.c ===
/******************************Module*Header*******************************\
* Module Name: guids.c
*
* This file contains the actual data declarations for all GUIDs used by
* GDI and device drivers.
*
* Created: 15-Feb-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#define GUID_DEFS_ONLY
#define INITGUID
#include <guiddef.h>
#include <ddrawint.h>
#include <dxmini.h>
#include <dvp.h>
#include <agp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\gradfill.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

/**************************************************************************\
*   gulDither32 - 4-4 dither matrix
*
*
* History:
*
*    1/31/1997 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG gulDither32[] =
{
    0x00000000,
    0x00008000,
    0x00002000,
    0x0000a000,

    0x0000c000,
    0x00004000,
    0x0000e000,
    0x00006000,

    0x00003000,
    0x0000b000,
    0x00001000,
    0x00009000,

    0x0000f000,
    0x00007000,
    0x0000d000,
    0x00005000
};


/**************************************************************************\
*
*   Dither information for 8bpp. This is customized for dithering to
*   the halftone palette [6,6,6] color cube.
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define DITHER_8_MASK_Y 0x0F
#define DITHER_8_MASK_X 0x0F

BYTE gDitherMatrix16x16Halftone[256] = {
  3, 28,  9, 35,  4, 30, 11, 36,  3, 29, 10, 35,  5, 30, 11, 37,
 41, 16, 48, 22, 43, 17, 49, 24, 42, 16, 48, 22, 43, 18, 50, 24,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 32,  0, 26,  8, 34,  2, 27,
 44, 19, 38, 12, 46, 20, 40, 14, 45, 19, 38, 13, 46, 21, 40, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  6, 31, 12, 38,  4, 30, 10, 36,
 44, 18, 50, 24, 42, 16, 48, 23, 44, 18, 50, 25, 42, 17, 49, 23,
  8, 34,  2, 28,  7, 32,  0, 26,  9, 34,  2, 28,  7, 33,  1, 26,
 47, 21, 40, 15, 45, 20, 39, 13, 47, 22, 41, 15, 46, 20, 39, 14,
  3, 29,  9, 35,  5, 30, 11, 37,  3, 28,  9, 35,  4, 30, 11, 36,
 41, 16, 48, 22, 43, 17, 49, 24, 41, 15, 47, 22, 43, 17, 49, 23,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 31,  0, 25,  7, 33,  1, 27,
 45, 19, 38, 13, 46, 21, 40, 14, 44, 19, 38, 12, 46, 20, 39, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  5, 31, 11, 37,  3, 29, 10, 35,
 44, 18, 50, 25, 42, 17, 49, 23, 43, 18, 50, 24, 42, 16, 48, 23,
  9, 34,  2, 28,  7, 33,  1, 26,  8, 34,  2, 27,  7, 32,  0, 26,
 47, 21, 41, 15, 45, 20, 39, 13, 47, 21, 40, 15, 45, 19, 39, 13
 };

BYTE gDitherMatrix16x16Default[256] = {
    8, 72, 24, 88, 12, 76, 28, 92,  9, 73, 25, 89, 13, 77, 29, 93,
  104, 40,120, 56,108, 44,124, 60,105, 41,121, 57,109, 45,125, 61,
   16, 80,  0, 64, 20, 84,  4, 68, 17, 81,  1, 65, 21, 85,  5, 69,
  112, 48, 96, 32,116, 52,100, 36,113, 49, 97, 33,117, 53,101, 37,
   14, 78, 30, 94, 10, 74, 26, 90, 15, 79, 31, 95, 11, 75, 27, 91,
  110, 46,126, 62,106, 42,122, 58,111, 47,126, 63,107, 43,123, 59,
   22, 86,  6, 70, 18, 82,  2, 66, 23, 87,  7, 71, 19, 83,  3, 67,
  118, 54,102, 38,114, 50, 98, 34,119, 55,103, 39,115, 51, 99, 35,
    9, 73, 25, 89, 13, 77, 29, 93,  8, 72, 24, 88, 12, 76, 28, 92,
  105, 41,121, 57,109, 45,125, 61,104, 40,120, 56,108, 44,124, 60,
   17, 81,  1, 65, 21, 85,  5, 69, 16, 80,  0, 64, 20, 84,  4, 68,
  113, 49, 97, 33,117, 53,101, 37,112, 48, 96, 32,116, 52,100, 36,
   15, 79, 31, 95, 11, 75, 27, 91, 14, 78, 30, 94, 10, 74, 26, 90,
  111, 47,126, 63,107, 43,123, 59,110, 46,126, 62,106, 42,122, 58,
   23, 87,  7, 71, 19, 83,  3, 67, 22, 86,  6, 70, 18, 82,  2, 66,
  119, 55,103, 39,115, 51, 99, 35,118, 54,102, 38,114, 50, 98, 34
  };

//
// identity translate vector for use in non palmanaged 8bpp surfaces
//

/**************************************************************************\
* vTranslateIdentity
*
*   identity translate vector for use in non-palmanaged 8bpp surfaces
*
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE vTranslateIdentity[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
    };

/**************************************************************************\
* HalftoneSaturationTable
*
*   This table maps a 8 bit pixel plus a dither error term in the range
*   of 0 to 51 onto a 8 bit pixel. Overflow of up to 31 is considered
*   saturated (255+51 = 255). The level 51 (0x33) is used to map pixels
*   and error values to the halftone palette
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE HalftoneSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE DefaultSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE Saturation16_5[64] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

BYTE Saturation16_6[128] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

/******************************Public*Routine******************************\
* vGradientFill32BGRA
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32BGRA(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;
    LONGLONG lldAdX = ptData->lldAdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue,clrAlpha;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;
        clrAlpha.ullColor = pEdge->llAlpha;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX         = (PULONG)pDst + xScanLeft;
            pulDstScanRight = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
                clrAlpha.ullColor += lldAdX * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = (clrAlpha.b[7] << 24) |
                           (clrRed.b[7]   << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrBlue.b[7]);

                pulDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
                clrAlpha.ullColor += lldAdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill32RGB
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32RGB(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX =
                           (clrBlue.b[7]  << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrRed.b[7]);

                pulDstX++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill32Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pulDstX < pulDstScanRight)
            {
                ULONG ulTemp =
                           (clrRed.b[7]       )   |
                           (clrGreen.b[7] <<  8)  |
                           (clrBlue.b[7]  << 16);

                *pulDstX = ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                pulDstX++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* vGradientFill24BGR
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill24BGR(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     yScanBottom;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = clrBlue.b[7];
                *(pDstX+1) = clrGreen.b[7];
                *(pDstX+2) = clrRed.b[7];

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* vGradientFill24RGB
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vGradientFill24BGR
*
\**************************************************************************/

VOID
vGradientFill24RGB(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     yScanBottom;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = clrRed.b[7];
                *(pDstX+1) = clrGreen.b[7];
                *(pDstX+2) = clrBlue.b[7];

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill24Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vGradientFill32Bitfields
*
\**************************************************************************/

VOID
vGradientFill24Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pbDstX;
        PBYTE pbDstScanRight,pbDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pbDstX           = (PBYTE)pDst + xScanLeft*3;
            pbDstScanRight   = (PBYTE)pDst + xScanRight*3;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pbDstX < pbDstScanRight)
            {
                ULONG ulTemp =
                           (clrRed.b[7]       )   |
                           (clrGreen.b[7] <<  8)  |
                           (clrBlue.b[7]  << 16);

                ulTemp = ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                *pbDstX      = ((PBYTE)&ulTemp)[0];
                *(pbDstX+1)  = ((PBYTE)&ulTemp)[1];
                *(pbDstX+2)  = ((PBYTE)&ulTemp)[2];

                pbDstX += 3;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}
/******************************Public*Routine******************************\
* vGradientFill16_565
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16_565(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG       lDelta = pSurfDst->lDelta();
    LONG       yScan  = ptData->y0;
    LONG       yScanBottom;
    PBYTE      pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE   pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;
        PULONG pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_6[((clrGreen.ul[1] >> (8+2)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                *pusDstX = rgb565(iRed,iGreen,iBlue);

                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* vGradientFill16_555
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16_555(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;

        PULONG  pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_5[((clrGreen.ul[1] >> (8+3)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                *pusDstX = rgb555(iRed,iGreen,iBlue);

                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill16Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;
    PULONG   pulDither;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_5[((clrGreen.ul[1] >> (8+3)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                ULONG ulTemp = (iRed   << (    3)) |
                               (iGreen << (8  +3)) |
                               (iBlue  << (8+8+3));

                *pusDstX = (USHORT)ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                xScanLeft++;
                pusDstX++;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* GRAD_PALETTE_MATCH
*
*
* Arguments:
*
*   palIndex  - return surface palette index
*   pjVector  - translation from DC to surface palette. Identity for non
*               palette managed
*   pxlate555 - rgb555 to palette index table
*   r,g,b     - byte colors
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define GRAD_PALETTE_MATCH(palIndex,pjVector,pxlate555,r,g,b)             \
                                                                          \
palIndex = pxlate555[((r & 0xf8) << 7) |                                  \
                     ((g & 0xf8) << 2) |                                  \
                     ((b & 0xf8) >> 3)];                                  \
                                                                          \
palIndex = pjVector[palIndex];

/******************************Public*Routine******************************\
* vGradientFill8
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill8(
   SURFACE *pSurfDst,
   PTRIANGLEDATA ptData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // either use default palette or halftone palette dither
    //

    if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).bIsHalftone())
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vGradientFill8:Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // scan from top to bottom of triangle scan lines
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX,pjDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + xScanLeft;
            pjDstScanRight    = pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // gradient fill scan with dither
            //

            while (pjDstX < pjDstScanRight)
            {
                BYTE  jIndex;

                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG iRed   = pSaturationTable[clrRed.b[7]   + jDitherMatrix];
                ULONG iGreen = pSaturationTable[clrGreen.b[7] + jDitherMatrix];
                ULONG iBlue  = pSaturationTable[clrBlue.b[7]  + jDitherMatrix];

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                *pjDstX = jIndex;

                xScanLeft++;
                pjDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill4
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill4(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + (xScanLeft/2);
            iDstX             = xScanLeft & 1;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // fill scan line with dither
            //

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG iRed   = pSaturationTable[clrRed.b[7]   + jDitherMatrix];
                ULONG iGreen = pSaturationTable[clrGreen.b[7] + jDitherMatrix];
                ULONG iBlue  = pSaturationTable[clrBlue.b[7]  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write nibble
                //

                if (iDstX)
                {
                    iDstX = 0;
                    *pjDstX = (*pjDstX & 0xf0) | jIndex;
                    pjDstX++;
                }
                else
                {
                    *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
                    iDstX = 1;
                }

                xScanLeft++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill1
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill1(
   SURFACE *pSurfDst,
   PTRIANGLEDATA ptData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector         = vTranslateIdentity;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // must have palette xlate
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        LONG    ScanRight;
        LONG    ScanLeft;
        LONG    xScan;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX         = pDst + (xScanLeft/8);
            iDstX          = xScanLeft & 7;

            //
            // skip clipped out portion of scan line whille
            // running color gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

                ULONG iRed   = clrRed.b[7];
                ULONG iGreen = clrGreen.b[7];
                ULONG iBlue  = clrBlue.b[7];

                //
                // add dither and saturate. 1bpp non-optimized (overflow will not be noticable in a dither
                // case it would at higher color depth
                //

                iRed   = iRed   + jDitherMatrix;

                if (iRed >= 255)
                {
                    iRed = 255;
                }
                else
                {
                    iRed = 0;
                }

                iGreen = iGreen + jDitherMatrix;

                if (iGreen >= 255)
                {
                    iGreen = 255;
                }
                else
                {
                    iGreen = 0;
                }

                iBlue  = iBlue  + jDitherMatrix;

                if (iBlue >= 255)
                {
                    iBlue = 255;
                }
                else
                {
                    iBlue = 0;
                }


                BYTE  jIndex;

                //
                // pjVector is known to be identity, so could make new macro for
                // palette_match_1 if perf ever an issue
                //

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                LONG iShift = 7 - iDstX;
                BYTE OrMask = 1 << iShift;
                BYTE AndMask  = ~OrMask;

                jIndex = jIndex << iShift;

                *pjDstX = (*pjDstX & AndMask) | jIndex;

                iDstX++;

                if (iDstX == 8)
                {
                    iDstX = 0;
                    pjDstX++;
                }

                xScanLeft++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

//
//  Gradient fill rectangle routines
//
//
//  Gradient Rectangles us 8.48 fixed point color
//  as oppesed to triangles that use 8.56
//
//
//
//
//
//
//
//
//
//
//
//
//

/******************************Public*Routine******************************\
* vFillGRectDIB32BGRA
*
*   Fill gradient rect from structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32BGRA(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst     = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)AllocFreeTmpBuffer(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            clrR.ullColor = pgData->llRed;
            clrG.ullColor = pgData->llGreen;
            clrB.ullColor = pgData->llBlue;
            clrA.ullColor = pgData->llAlpha;

            LONGLONG lldRdX   = pgData->lldRdX;
            LONGLONG lldGdX   = pgData->lldGdX;
            LONGLONG lldBdX   = pgData->lldBdX;
            LONGLONG lldAdX   = pgData->lldAdX;

            //
            // adjust gradient fill for clipped portion
            //

            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRdX * (pgData->xScanAdjust);
                clrG.ullColor += lldGdX * (pgData->xScanAdjust);
                clrB.ullColor += lldBdX * (pgData->xScanAdjust);
                clrA.ullColor += lldAdX * (pgData->xScanAdjust);
            }

            //
            // draw 1 scan line
            //

            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;

            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(((clrA.b[6]) << 24) |
                                   ((clrR.b[6]) << 16) |
                                   ((clrG.b[6]) << 8)  |
                                   ((clrB.b[6])));

                clrR.ullColor += lldRdX;
                clrG.ullColor += lldGdX;
                clrB.ullColor += lldBdX;
                clrA.ullColor += lldAdX;

                pulDstX++;
            }

            //
            // replicate
            //

            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);

            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }

            FreeTmpBuffer(pulBuffer);
        }
    }
    else
    {
        clrR.ullColor = pgData->llRed;
        clrG.ullColor = pgData->llGreen;
        clrB.ullColor = pgData->llBlue;
        clrA.ullColor = pgData->llAlpha;

        LONGLONG lldRdY = pgData->lldRdY;
        LONGLONG lldGdY = pgData->lldGdY;
        LONGLONG lldBdY = pgData->lldBdY;
        LONGLONG lldAdY = pgData->lldAdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor += lldRdY * (pgData->yScanAdjust);
            clrG.ullColor += lldGdY * (pgData->yScanAdjust);
            clrB.ullColor += lldBdY * (pgData->yScanAdjust);
            clrA.ullColor += lldAdY * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(((clrA.b[6]) << 24) |
                               ((clrR.b[6]) << 16) |
                               ((clrG.b[6]) << 8)  |
                               ((clrB.b[6])));

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRdY;
            clrG.ullColor += lldGdY;
            clrB.ullColor += lldBdY;
            clrA.ullColor += lldAdY;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32RGB
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32RGB(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst     = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)AllocFreeTmpBuffer(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            LONGLONG lldRed   = pgData->lldRdX;
            LONGLONG lldGreen = pgData->lldGdX;
            LONGLONG lldBlue  = pgData->lldBdX;

            //
            // adjust gradient fill for clipped portion
            //

            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRed   * (pgData->xScanAdjust);
                clrG.ullColor += lldGreen * (pgData->xScanAdjust);
                clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
            }

            //
            // draw 1 scan line to temp buffer
            //

            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;

            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(
                           ((clrR.b[6]))        |
                           ((clrG.b[6]) << 8) |
                           ((clrB.b[6]) << 16));

                clrR.ullColor += lldRed;
                clrG.ullColor += lldGreen;
                clrB.ullColor += lldBlue;

                pulDstX++;
            }

            //
            // replicate
            //

            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);

            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }

            FreeTmpBuffer(pulBuffer);
        }
    }
    else
    {
        LONGLONG     lldRed   = pgData->lldRdY;
        LONGLONG     lldGreen = pgData->lldGdY;
        LONGLONG     lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(
                       ((clrR.b[6])      ) |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6]) << 16));

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}

/**************************************************************************\
* vFillGRectDIB32Bitfields
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    2/18/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vFillGRectDIB32Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG      lDelta = pSurfDst->lDelta();
    LONG      cyClip = pgData->szDraw.cy;
    XEPALOBJ *ppalDstSurf   = pgData->ppalDstSurf;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            ULONG ulPix = (ULONG)(
                       ((clrR.b[6]  ))      |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6] ) << 16));

            *pulDstX = ppalDstSurf->ulGetMatchFromPalentry(ulPix);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(
                       ((clrR.b[6]))      |
                       ((clrG.b[6]) << 8) |
                       ((clrB.b[6]) << 16));

            ul = ppalDstSurf->ulGetMatchFromPalentry(ul);

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}


/**************************************************************************\
* vFillGRectDIB24Bitfields
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vFillGRectDIB32Bitfields
*
\**************************************************************************/
VOID
vFillGRectDIB24Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG      lDelta = pSurfDst->lDelta();
    LONG      cyClip = pgData->szDraw.cy;
    XEPALOBJ *ppalDstSurf   = pgData->ppalDstSurf;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PBYTE pbDstX  =  pDst + pgData->ptDraw.x*3;
        PBYTE pbEndX  =  pbDstX + pgData->szDraw.cx*3;
        PBYTE pbScanX =  pbDstX;
        PBYTE  pScan    = pbDstX;

        while (pbDstX != pbEndX)
        {
            ULONG ulPix = (ULONG)(
                       ((clrR.b[6]  ))      |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6] ) << 16));

            ulPix = ppalDstSurf->ulGetMatchFromPalentry(ulPix);

            *pbDstX     = ((PBYTE)&ulPix)[0];
            *(pbDstX+1) = ((PBYTE)&ulPix)[1];
            *(pbDstX+2) = ((PBYTE)&ulPix)[2];

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pbDstX += 3;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pbScanX,3*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            PBYTE pTemp = pDst;
            PBYTE pEnd  = pDst + 3 * pgData->szDraw.cx;

            ULONG ul = (ULONG)(
                       ((clrR.b[6]))      |
                       ((clrG.b[6]) << 8) |
                       ((clrB.b[6]) << 16));

            ul = ppalDstSurf->ulGetMatchFromPalentry(ul);

            while(pTemp != pEnd) 
            {
                *pTemp     = ((PBYTE)&ul)[0];
                *(pTemp+1) = ((PBYTE)&ul)[1];
                *(pTemp+2) = ((PBYTE)&ul)[2];

                pTemp += 3;
            }

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}
/******************************Public*Routine******************************\
* vFillGRectDIB24BGR
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB24BGR(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)AllocFreeTmpBuffer(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            if (pBuffer)
            {
                PBYTE  pDstX  =  pBuffer;
                PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

                while (pDstX != pLast)
                {
                    *pDstX     =  (clrB.b[6]);
                    *(pDstX+1) =  (clrG.b[6]);
                    *(pDstX+2) =  (clrR.b[6]);

                    clrR.ullColor += lldRed;
                    clrG.ullColor += lldGreen;
                    clrB.ullColor += lldBlue;

                    pDstX+=3;
                }

                //
                // Replicate the scan line. It would be much better to write the scan line
                // out to a memory buffer for drawing to a device surface
                //

                PBYTE  pDst   = (PBYTE)pSurfDst->pvScan0() +
                                            lDelta * pgData->ptDraw.y +
                                            3 * pgData->ptDraw.x;

                while (cyClip--)
                {
                    memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                    pDst += lDelta;
                }

                FreeTmpBuffer(pBuffer);
            }
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;

            while (pTemp != pEnd)
            {
                *pTemp     = clrB.b[6];
                *(pTemp+1) = clrG.b[6];
                *(pTemp+2) = clrR.b[6];
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB24RGB
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vFillGrectDIB24BGR
*
\**************************************************************************/

VOID
vFillGRectDIB24RGB(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)AllocFreeTmpBuffer(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            if (pBuffer)
            {
                PBYTE  pDstX  =  pBuffer;
                PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

                while (pDstX != pLast)
                {
                    *pDstX     =  (clrR.b[6]);
                    *(pDstX+1) =  (clrG.b[6]);
                    *(pDstX+2) =  (clrB.b[6]);

                    clrR.ullColor += lldRed;
                    clrG.ullColor += lldGreen;
                    clrB.ullColor += lldBlue;

                    pDstX+=3;
                }

                //
                // Replicate the scan line. It would be much better to write the scan line
                // out to a memory buffer for drawing to a device surface
                //

                PBYTE  pDst   = (PBYTE)pSurfDst->pvScan0() +
                                            lDelta * pgData->ptDraw.y +
                                            3 * pgData->ptDraw.x;

                while (cyClip--)
                {
                    memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                    pDst += lDelta;
                }

                FreeTmpBuffer(pBuffer);
            }
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;

            while (pTemp != pEnd)
            {
                *pTemp     = clrR.b[6];
                *(pTemp+1) = clrG.b[6];
                *(pTemp+2) = clrB.b[6];
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}
/******************************Public*Routine******************************\
* vFillGRectDIB16_565
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_565(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG lldxRed   = pgData->lldRdX;
    LONGLONG lldxGreen = pgData->lldGdX;
    LONGLONG lldxBlue  = pgData->lldBdX;

    LONGLONG lldyRed   = pgData->lldRdY;
    LONGLONG lldyGreen = pgData->lldGdY;
    LONGLONG lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScan;
        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);


        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + xDitherOrg;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_6[((clrG.ul[1] >> (2)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb565(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan++;

        pDst += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_555
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vFillGRectDIB16_555(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;

    while(yScan < yScanBottom)
    {
        PUSHORT   pusDstX;
        PUSHORT   pusDstScanRight,pusDstScanLeft;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        LONG      xScan;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + pgData->ptDitherOrg.x;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {

            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_5[((clrG.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb555(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan  ++;
        pDst   += lDelta;
    }
}

/**************************************************************************\
* vFillGRectDIB16Bitfields
*
*   Run gradient at 16bpp and use 555 dither
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    2/18/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG  lldxRed   = pgData->lldRdX;
    LONGLONG  lldxGreen = pgData->lldGdX;
    LONGLONG  lldxBlue  = pgData->lldBdX;

    LONGLONG  lldyRed   = pgData->lldRdY;
    LONGLONG  lldyGreen = pgData->lldGdY;
    LONGLONG  lldyBlue  = pgData->lldBdY;

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    PULONG   pulDither;

    XEPALOBJ *ppalDstSurf = pgData->ppalDstSurf;

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScan;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + pgData->ptDitherOrg.x;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_5[((clrG.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            //
            // convert to 8 bit RGB for translation to bitfields
            //

            ULONG ulTemp = (iRed   << (    3)) |
                           (iGreen << (8  +3)) |
                           (iBlue  << (8+8+3));

            *pusDstX = (USHORT)ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB8
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB8(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    XLATEOBJ *pxlo = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    //
    // either use default palette or halftone palette dither
    //

    if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).bIsHalftone())
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
            pDitherMatrix    = gDitherMatrix16x16Default;
            pSaturationTable = DefaultSaturationTable;
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    xDitherOrg = pgData->ptDitherOrg.x;
    LONG    yDitherOrg = pgData->ptDitherOrg.y;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX   = pDst + pgData->ptDraw.x;

        LONG     xScan       = pgData->ptDraw.x;
        LONG     xScanRight  = xScan + pgData->szDraw.cx;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        while (xScan < xScanRight)
        {
            //
            // calculate x component of dither
            //

            BYTE jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

            ULONG  iRed   = pSaturationTable[clrR.b[6] + jDitherMatrix];
            ULONG  iGreen = pSaturationTable[clrG.b[6] + jDitherMatrix];
            ULONG  iBlue  = pSaturationTable[clrB.b[6] + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            *pjDstX = jIndex;

            pjDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB4
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB4(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG lldxRed   = pgData->lldRdX;
    LONGLONG lldxGreen = pgData->lldGdX;
    LONGLONG lldxBlue  = pgData->lldBdX;

    LONGLONG lldyRed   = pgData->lldRdY;
    LONGLONG lldyGreen = pgData->lldGdY;
    LONGLONG lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    XLATEOBJ *pxlo = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/2;

        LONG     xScan       = pgData->ptDraw.x;
        LONG     xScanRight  = xScan + pgData->szDraw.cx;

        while (xScan < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix;


            jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

            ULONG iRed   = pSaturationTable[clrR.b[6] + jDitherMatrix];
            ULONG iGreen = pSaturationTable[clrG.b[6] + jDitherMatrix];
            ULONG iBlue  = pSaturationTable[clrB.b[6] + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            if (xScan & 1)
            {
                *pjDstX = (*pjDstX & 0xf0) | jIndex;
                pjDstX++;
            }
            else
            {
                *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
            }

            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB1
*
*   Fill gradient rect
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB1(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG     lDelta = pSurfDst->lDelta();

    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan  = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    XLATEOBJ *pxlo  = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector         = vTranslateIdentity;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanLeft  = pgData->ptDraw.x;
        LONG    xScanRight = xScanLeft + cx;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX = pDst + pgData->ptDraw.x/8;
        ixDst  = pgData->ptDraw.x & 7;

        while (xScanLeft < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft + xDitherOrg) & DITHER_8_MASK_X)));

            ULONG   iRed   = (ULONG)(clrR.b[6]);
            ULONG   iGreen = (ULONG)(clrG.b[6]);
            ULONG   iBlue  = (ULONG)(clrB.b[6]);

            //
            // add dither and saturate. 1bpp non-optimized
            //

            iRed   = iRed   + jDitherMatrix;

            if (iRed >= 255)
            {
                iRed = 255;
            }
            else
            {
                iRed = 0;
            }

            iGreen = iGreen + jDitherMatrix;

            if (iGreen >= 255)
            {
                iGreen = 255;
            }
            else
            {
                iGreen = 0;
            }

            iBlue  = iBlue  + jDitherMatrix;

            if (iBlue >= 255)
            {
                iBlue = 255;
            }
            else
            {
                iBlue = 0;
            }

            BYTE  jIndex;

            //
            // pjVector is known to be identity, so could make new macro for
            // palette_match_1 if perf ever an issue
            //

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            LONG iShift  = 7 - ixDst;
            BYTE OrMask = 1 << iShift;
            BYTE AndMask  = ~OrMask;

            jIndex = jIndex << iShift;

            *pjDstX = (*pjDstX & AndMask) | jIndex;

            ixDst++;

            if (ixDst == 8)
            {
                ixDst = 0;
                pjDstX++;
            }

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;

            xScanLeft++;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\grerc.h ===
/*********************************************************************************
 * grerc.h
 *
 * This file contains definitions for the font script names stored in the grerc
 * resource file.
 *
 * History:0
 *  3-6-95 22:30:00 Gerrit van Wingerden [gerritv]
 * Wrote it. 
 *
 * Copyright (c) 1995-1999 Microsoft Corporation
 ********************************************************************************/

#define SCRIPT_WESTERN           0 
#define SCRIPT_SYMBOL            1
#define SCRIPT_MAC               2 
#define SCRIPT_JAPANESE          3 
#define SCRIPT_HANGEUL           4 
#define SCRIPT_HANGEUL_JOHAB     5 
#define SCRIPT_CHINESE_GB2312    6 
#define SCRIPT_CHINESE_BIG5      7 
#define SCRIPT_GREEK             8 
#define SCRIPT_TURKISH           9 
#define SCRIPT_VIETNAMESE        10
#define SCRIPT_HEBREW            11
#define SCRIPT_ARABIC            12
#define SCRIPT_BALTIC            13
#define SCRIPT_CYRILLIC          14
#define SCRIPT_THAI              15
#define SCRIPT_CENTRAL_EUROPE    16
#define SCRIPT_OEM_DOS           17
#define SCRIPT_UNKNOWN           18

#define NUMBER_OF_SCRIPTS        SCRIPT_UNKNOWN + 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\globals.c ===
/******************************Module*Header*******************************\
* Module Name: globals.c
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
* This module contains all the global variables used in the graphics engine.
* The extern declarations for all of these variables are in engine.h
*
* One should try to minimize the use of globals since most operations are
* based of a PDEV, and different PDEVs have different characteristics.
*
* Globals should basically be limited to globals locks and other permanent
* data structures that never change during the life of the system.
*
* Created: 20-Jun-1995
* Author: Andre Vachon [andreva]
*
\**************************************************************************/


#include "engine.h"

/**************************************************************************\
*
* SEMAPHORES
*
\**************************************************************************/

//
// Define the Driver Management Semaphore.  This semaphore must be held
// whenever a reference count for an LDEV or PDEV is being modified.  In
// addition, it must be held whenever you don't know for sure that a
// reference count of the LDEV or PDEV you are using is non-zero.
//
// The ghsemDriverMgmt semaphore is used to protect the list of drivers.
// When traversing the list, ghsemDriverMgmt must be held, unless you
// can guarentee that 1) no drivers will be removed and 2) new drivers are
// always inserted at the head of the list.  If these two conditions are met,
// then other processes can grab (make a local copy of) the list head under
// semaphore protection.  This list can be parsed without regard to any new
// drivers that may be pre-pended to the list.  One way to ensure that no
// drivers will be removed is to increment the reference count for each driver
// in the list and then unreference the drivers as they are no longer needed.
// An alternative method to safely parse the list and still allow dirvers to
// be added or removed is as follows:
//      1. grab ghsemDriverMgmt
//      2. obtain pointer to first driver
//      3. reference driver
//      4. release ghsemDriverMgmt
//      5. do some processing
//      6. grab ghsemDriverMgmt
//      7. obtain pointer to next driver
//      8. unreference previous driver
//      9. repeat 2 to 8 until reaching the end of the list
//     10. release ghsemDriverMgmt
//

HSEMAPHORE ghsemDriverMgmt;
HSEMAPHORE ghsemCLISERV;
HSEMAPHORE ghsemRFONTList;
HSEMAPHORE ghsemAtmfdInit;

//
// ghsemPalette synchronizes selecting a palette in and out of DC's and the
// use of a palette without the protection of a exclusive DC lock.
// ResizePalette forces us to protect ourselves because the pointer can
// change under our feet.  So we need to be able to synchronize use of
// the ppal by ghsemPalette and exclusive lock of DC.
//

HSEMAPHORE ghsemPalette;

//
// Define the global PFT semaphore.  This must be held to access any of the
// physical font information.
//

HSEMAPHORE ghsemPublicPFT;
//
// Global semaphore used for spooling
//

HSEMAPHORE ghsemGdiSpool;

// WNDOBJ operations semaphore
HSEMAPHORE ghsemWndobj;

// glyphset of PFE  operations semaphore
HSEMAPHORE ghsemGlyphSet;

#if DBG_CORE
HSEMAPHORE ghsemDEBUG;
#endif

//
// shared devive lock semaphore
//
// ghsemShareDevLock may be acquired for shared access at any time
//
// A thread must be careful when acquiring exclusive accesss.  It must not
// hold exclusive access to dev lock otherwise it may cause deadlock to
// occur.
//

HSEMAPHORE ghsemShareDevLock;

//
// The gAssociationListMutex is used to synchronize access to the
// watchdog's association lists.
//

HFASTMUTEX gAssociationListMutex;

/**************************************************************************\
*
* LIST POINTERS
*
\**************************************************************************/



/**************************************************************************\
*
* Drawing stuff
*
\**************************************************************************/

//
// This is to convert BMF constants into # bits per pel
//

ULONG gaulConvert[7] =
{
    0,
    1,
    4,
    8,
    16,
    24,
    32
};




/**************************************************************************\
*
* Font stuff
*
\**************************************************************************/

//
// initialize to some value that's not equal to a Type1 Rasterizer ID
//
UNIVERSAL_FONT_ID gufiLocalType1Rasterizer = { A_VALID_ENGINE_CHECKSUM, 0 };

//
// System default language ID.
//

USHORT gusLanguageID;

//
// Is the system code page DBCS?
//

BOOL gbDBCSCodePage;

//
// Number of TrueType font files loaded.
//

ULONG gcTrueTypeFonts;

//
// The global font enumeration filter type.  It can be set to:
//  FE_FILTER_NONE      normal operation, no extra filtering applied
//  FE_FILTER_TRUETYPE  only TrueType fonts are enumerated
//

ULONG gulFontInformation;

// for system default charset

BYTE  gjCurCharset;
DWORD gfsCurSignature;

// gbGUISetup is set to TRUE during the system GUI setup
// otherwise FALSE

BOOL gbGUISetup = FALSE;

// Globals used for GDI tracing
#if DBG_TRACE
GDITraceClassMask   gGDITraceClassMask[GDITRACE_TOTAL_CLASS_MASKS] = { 0 };
GDITraceKeyMask     gGDITraceKeyMask[GDITRACE_TOTAL_KEY_MASKS] = { 0 };
GDITraceKeyMask     gGDITraceInternalMask[GDITRACE_TOTAL_KEY_MASKS] = { 0 };
HANDLE              gGDITraceHandle1 = NULL;
HANDLE              gGDITraceHandle2 = NULL;
BOOL                gGDITraceHandleBreak = FALSE;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\hmgr.h ===
/******************************Module*Header*******************************\
* Module Name: hmgr.h
*
* This file contains all the prototypes for the handle mangager.
*
* Added nifty header: 29-Jun-1991 16:31:46
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

//#include "hmgshare.h"

//          <-fulltype->
//   <---full unique--->
// +-+------+-+--+-----+----------------+
// |u|unique|s|al|type |     index      |
// +-+------+-+--+-----+----------------+
//  ^        ^ ^^
//  +user    | ||
//           | ||
//           | ++alternate type for client (pen, metafile, dibsection)
//           |
//           +stock object
//
// USER       - bit(s) reserved for USER, not used for comparing identical handles
//
// TYPE       - types used by GRE
// ALTTYPE    - extra type bits used by client
// STOCK      - bit indicating stockobject
// FULLTYPE   - all bits related to type that are per object (includes STOCK bit)
//
// UNIQUE     - bits that are incremented for each instance of the handle
// FULLUNIQUE - bits used for comparing identical handles.  This includes FULLTYPE
//
// INDEX      - index into server side handle table
//
// The handle index points into a big array of entries.  This index is
// broken down into 'page' and 'entry' fields.
// This is to prevent having to have the entire handle table created at
// once.  If all the handles in a page are in use and no free handles are
// available, a new page is faulted in for use.

// all the commented defines below live in ntgdistr.h.

#define LOTYPE_BITS         (TYPE_BITS + ALTTYPE_BITS)
#define FULLTYPE_BITS       (TYPE_BITS + ALTTYPE_BITS + STOCK_BITS)
#define FULLUNIQUE_BITS     (TYPE_BITS + ALTTYPE_BITS + STOCK_BITS + UNIQUE_BITS)
#define NONINDEX_BITS       (32 - INDEX_BITS)

#define INDEX_SHIFT         0
#define UNIQUE_SHIFT        (STOCK_SHIFT + STOCK_BITS)
#define LOTYPE_SHIFT        (TYPE_SHIFT)
#define FULLTYPE_SHIFT      (TYPE_SHIFT)
#define FULLUNIQUE_SHIFT    (TYPE_SHIFT)

//MASKS contain the bits of the handle used for the paricular field

#define NONINDEX_MASK(shift,cbits)  ( ((1 << (cbits)) - 1)  << (shift) )

#define INDEX_MASK          ((1 << INDEX_BITS) - 1)
#define TYPE_MASK           (NONINDEX_MASK(TYPE_SHIFT,      TYPE_BITS))
#define ALTTYPE_MASK        (NONINDEX_MASK(ALTTYPE_SHIFT,   ALTTYPE_BITS))
#define STOCK_MASK          (NONINDEX_MASK(STOCK_SHIFT,     STOCK_BITS))
#define UNIQUE_MASK         (NONINDEX_MASK(UNIQUE_SHIFT,    UNIQUE_BITS))
#define LOTYPE_MASK         (NONINDEX_MASK(LOTYPE_SHIFT,    LOTYPE_BITS))
#define FULLTYPE_MASK       (NONINDEX_MASK(FULLTYPE_SHIFT,  FULLTYPE_BITS))

// NOTE that UNIQUE_INCREMENT is based on the uniqueness beeing a short, not a full handle

#define UNIQUE_INCREMENT    (1 << (UNIQUE_SHIFT - INDEX_BITS))

#define MODIFY_HMGR_TYPE(h,t)          ((HANDLE)((ULONG_PTR)(h) | (t)))

#define HmgIfromH(h)          (ULONG)((ULONG_PTR)(h) & INDEX_MASK)
#define HmgUfromH(h)          ((USHORT) (((ULONG_PTR)(h) & FULLUNIQUE_MASK) >> TYPE_SHIFT))
#define HmgObjtype(h)         ((OBJTYPE)(((ULONG_PTR)(h) & TYPE_MASK)       >> TYPE_SHIFT))
#define HmgStockObj(hobj)     ((ULONG_PTR)(hobj) & STOCK_MASK)

// given a usUnique and a type, modify it to contain a new type

#define USUNIQUE(u,t) (USHORT)((u & (UNIQUE_MASK >> INDEX_BITS)) | \
                               (t << (TYPE_SHIFT - INDEX_BITS)))

//
// WOW has a dependency on the index portion of returned 32-bit GDI
// handles being greater than (COLOR_ENDCOLORS >> 2)
// (COLOR_ENDCOLORS is defined in winuserp.h).
//
// This dependency allows WOW to distinguish between a 16-bit HBRUSH
// and a COLOR_* constant.
//
// Therefore, we will will reserve the first few entries of the handle
// table, disallowing the use of any index less than HMGR_HANDLE_BASE.
//
//                                        hideyukn, 1997.Oct.27
//

#define HMGR_HANDLE_BASE  0x000a

ULONG       FASTCALL HmgQueryLock(HOBJ hobj);
BOOL        FASTCALL HmgSetLock(HOBJ hobj, ULONG cLock);
ULONG       FASTCALL HmgQueryAltLock(HOBJ hobj);
BOOL                 HmgCreate();
HOBJ                 HmgAlloc(ULONGSIZE_T,OBJTYPE,USHORT);
POBJ                 HmgReplace(HOBJ,POBJ,FLONG,LONG,OBJTYPE);
VOID                 HmgFree(HOBJ);

POBJ        FASTCALL HmgLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgLockAllOwners(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareCheckLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareLockIgnoreStockBit(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareCheckLockIgnoreStockBit(HOBJ,OBJTYPE);

BOOL                 HmgSetOwner(HOBJ,W32PID,OBJTYPE);
BOOL                 HmgSwapHandleContents(HOBJ,ULONG,HOBJ,ULONG,OBJTYPE);
BOOL                 HmgSwapLockedHandleContents(HOBJ,ULONG,HOBJ,ULONG,OBJTYPE);
POBJ        FASTCALL HmgReferenceCheckLock(HOBJ h,OBJTYPE ot, BOOL bDebugPrint);
HOBJ        FASTCALL HmgNextOwned(HOBJ,W32PID);
POBJ        FASTCALL HmgSafeNextObjt(HOBJ hobj, OBJTYPE objt);
BOOL                 HmgValidHandle(HOBJ, OBJTYPE);
HOBJ        FASTCALL HmgSafeNextOwned(HOBJ,W32PID);
BOOL        FASTCALL HmgMarkUndeletable(HOBJ,OBJTYPE);
BOOL        FASTCALL HmgMarkDeletable(HOBJ,OBJTYPE);
HOBJ                 HmgInsertObject(PVOID,FLONG,OBJTYPE);
PVOID                HmgRemoveObject(HOBJ,LONG,LONG,BOOL,OBJTYPE);
OBJTYPE *            HmgSetNULLType(HOBJ,LONG,LONG,OBJTYPE);
HOBJ                 HmgModifyHandleType(HOBJ  h);
BOOL                 HmgLockAndModifyHandleType(HOBJ h);

PVOID                HmgAllocateSecureUserMemory();
PDC_ATTR             HmgAllocateDcAttr();
POBJECTATTR          HmgAllocateObjectAttr();
VOID                 HmgFreeDcAttr(PDC_ATTR);
VOID                 HmgFreeObjectAttr(POBJECTATTR);
BOOL                 bPEBCacheHandle(HANDLE,HANDLECACHETYPE,POBJECTATTR,PENTRY);
BOOL                 bLoadProcessHandleQuota();



HOBJ                 HmgIncUniqueness(HOBJ  hobj, OBJTYPE objt);
VOID        FASTCALL HmgIncrementShareReferenceCount(POBJ);
ULONG       FASTCALL HmgDecrementShareReferenceCount(POBJ);
VOID                 HmgShareUnlock(POBJ pobj);
BOOL        FASTCALL HmgInterlockedCompareAndSwap(PULONG,ULONG,ULONG);

PVOID                HmgForceRemoveObject(HOBJ hobj,BOOL bIgnoreUndeletable, OBJTYPE objt);

BOOL                 HmgIncProcessHandleCount(W32PID,OBJTYPE);
VOID                 HmgDecProcessHandleCount(W32PID);

#define HMGR_ALLOC_LOCK         0x0001
#define HMGR_ALLOC_ALT_LOCK     0x0002
#define HMGR_NO_ZERO_INIT       0x0004
#define HMGR_MAKE_PUBLIC        0x0008

#define MAXIMUM_POOL_ALLOC (PAGE_SIZE * 10000)

// Global Handle Manager data.

extern HSEMAPHORE ghsemHmgr;
extern ENTRY     *gpentHmgr;
extern HOBJ       ghFreeHmgr;
extern ULONG      gcMaxHmgr;
extern PLARGE_INTEGER gpLockShortDelay;
extern ULONG gCacheHandleEntries[GDI_CACHED_HADNLE_TYPES];
extern LONG  gProcessHandleQuota;

// DirectDraw Handle Manager data: externed here for debugger extensions

extern ULONG      gcSizeDdHmgr;
extern ENTRY     *gpentDdHmgr;
extern HOBJ       ghFreeDdHmgr;
extern ULONG      gcMaxDdHmgr;

//
// SAMEHANDLE and DIFFHANDLE have moved to wingdip.h so other server-side
// components can safely compare engine handles.  They validate all but USER bits
//

#define SAMEINDEX(H,K) (((((ULONG_PTR) (H)) ^ ((ULONG_PTR) (K))) & INDEX_MASK) == 0)

/*********************************MACRO************************************\
*  INC_EXCLUSIVE_REF_CNT - increment object's exclusive reference count
*  DEC_EXCLUSIVE_REF_CNT - decrement object's exclusive reference count
*
*  Note that the InterlockedIncrement/Decrement treats the cExclusiveLock
*  as a ULONG. cExclusiveLock is declared as a USHORT and the increment 
*  overlaps with the BASEOBJECT::BaseFlags. If the BaseFlags were ever changed,
*  this code may have to be changed to use an InterlockedCompareExchange loop.
*  See BASEOBJECT declaration.
*
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/

#define INC_EXCLUSIVE_REF_CNT(pObj) InterlockedIncrement((LONG *)& (((POBJ) pObj)->cExclusiveLock))
#define DEC_EXCLUSIVE_REF_CNT(pObj) InterlockedDecrement((LONG *)& (((POBJ) pObj)->cExclusiveLock))

/********************************MACRO*************************************\
* INC_SHARE_REF_CNT - do an interlocked increment of the
*   shared reference count of the given object.
*
* DEC_SHARE_REF_CNT - do an interlocked decrement of the
*   shared reference count of the given object.
*
* Arguments:
*
*   pObj - pointer to OBJECT
*
* Return Value:
*
*   HmgIncrementShareReferenceCount : None
*   HmgDecrementShareReferenceCount : Original shared reference count
*
\**************************************************************************/

#define PENTRY_FROM_POBJ(pObj)                                          \
    (&gpentHmgr[(UINT)HmgIfromH(((POBJ)(pObj))->hHmgr)])


#define INC_SHARE_REF_CNT(pObj)                                         \
    HmgIncrementShareReferenceCount((POBJ) (pObj))


#define DEC_SHARE_REF_CNT(pObj)                                         \
    HmgDecrementShareReferenceCount((POBJ) (pObj))



/*********************************MACRO************************************\
*
* DEC_SHARE_REF_CNT_LAZY0 - Interlocked decrement the shared reference
*   count of the given object. If the original count was 1, and the
*   object's TO_BE_DELETED flag is set, then call the object deletion
*   routine
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/

#define DEC_SHARE_REF_CNT_LAZY0(pObj)                              \
{                                                                  \
    PBRUSHATTR pBrushattr = ((PBRUSH)pObj)->pBrushattr();          \
                                                                   \
    if (1 == (DEC_SHARE_REF_CNT(pObj) & 0xffff))                   \
    {                                                              \
        if ((pBrushattr->AttrFlags) & ATTR_TO_BE_DELETED)          \
        {                                                          \
            bDeleteBrush ((HBRUSH) pObj->hHmgr,FALSE);             \
        }                                                          \
    }                                                              \
}

/*********************************MACRO************************************\
*
* DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT
*   count of the given object. If the original count was 1, and the
*   object's TO_BE_DELETED flag is set, then call the object deletion
*   routine
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/


#define DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(pObj)                          \
{                                                                         \
  if (1 == (DEC_SHARE_REF_CNT(pObj) & 0xffff))                            \
  {                                                                       \
    if (PENTRY_FROM_POBJ(pObj)->Flags & HMGR_ENTRY_LAZY_DEL)  \
    {                                                                     \
      bDeleteFont ((HLFONT) pObj->hHmgr,FALSE);                           \
    }                                                                     \
  }                                                                       \
}


#define DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(pObj)                       \
{                                                                         \
  DEC_SHARE_REF_CNT(pObj);                                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\fontsup.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontsup.cxx
*
* Supplementary services needed by fonts.
*
* Currently consists mostly of UNICODE<->ASCII routines stolen from BodinD's
* Windows bitmap font driver.
*
* Created: 21-Jan-1991 10:14:53
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.hxx"
#include "grerc.h"

VOID vArctan(EFLOAT, EFLOAT,EFLOAT&, LONG&);

// typedef struct tagTHREADINFO        *PTHREADINFO;

extern "C" DWORD GetAppCompatFlags(PVOID);
extern "C" BOOL InitializeScripts();

#pragma alloc_text(INIT, InitializeScripts)

VOID vIFIMetricsToEnumLogFontW (
    ENUMLOGFONTW  *pelfw,
    IFIMETRICS    *pifi
    )
{

    IFIOBJ ifio(pifi);

    pelfw->elfLogFont.lfHeight         = ifio.lfHeight();
    pelfw->elfLogFont.lfWidth          = ifio.lfWidth();
    pelfw->elfLogFont.lfWeight         = ifio.lfWeight();
    pelfw->elfLogFont.lfItalic         = ifio.lfItalic();
    pelfw->elfLogFont.lfUnderline      = ifio.lfUnderline();
    pelfw->elfLogFont.lfStrikeOut      = ifio.lfStrikeOut();
    pelfw->elfLogFont.lfCharSet        = ifio.lfCharSet();
    pelfw->elfLogFont.lfEscapement     = ifio.lfEscapement();
    pelfw->elfLogFont.lfOrientation    = ifio.lfOrientation();
    pelfw->elfLogFont.lfPitchAndFamily = ifio.lfPitchAndFamily();

// These are special IFIOBJ methods that return Win 3.1 compatible
// enumeration values.

    pelfw->elfLogFont.lfOutPrecision   = ifio.lfOutPrecisionEnum();
    pelfw->elfLogFont.lfClipPrecision  = ifio.lfClipPrecisionEnum();
    pelfw->elfLogFont.lfQuality        = ifio.lfQualityEnum();

//
// Copy the name strings making sure that they are zero terminated
//
    wcsncpy(pelfw->elfLogFont.lfFaceName,ifio.pwszFamilyName(),LF_FACESIZE);
    pelfw->elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
    wcsncpy(pelfw->elfFullName,ifio.pwszFaceName(),LF_FULLFACESIZE);
    pelfw->elfFullName[LF_FULLFACESIZE-1]       = 0;
    wcsncpy(pelfw->elfStyle,ifio.pwszStyleName(),LF_FACESIZE);
    pelfw->elfStyle[LF_FACESIZE-1]          = 0;

}

VOID vLookupScript(ULONG lfCharSet, WCHAR *pwszScript);


/******************************Public*Routine******************************\
*
*
* Units are in NOTIONAL units since font is not realized.
*
* History:
*  Fri 16-Aug-1991 22:01:17 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vIFIMetricsToEnumLogFontExDvW (
    ENUMLOGFONTEXDVW * plfw,
    IFIMETRICS    *pifi
    )
{

    vIFIMetricsToEnumLogFontW ((ENUMLOGFONTW *)plfw,pifi);

// lookup script, not ENUMLOGFONTW but is in ENUMLOGFONTEX

    vLookupScript((ULONG)pifi->jWinCharSet, (WCHAR *)plfw->elfEnumLogfontEx.elfScript);

// pick the design vector

    ULONG   cAxes = 0;
    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)pifi + dpDesVec);
            cAxes  = pdvSrc->dvNumAxes;

            if (cAxes > MM_MAX_NUMAXES)
                cAxes = MM_MAX_NUMAXES;
                
            RtlCopyMemory(&plfw->elfDesignVector, pdvSrc, (SIZE_T)SIZEOFDV(cAxes));
            plfw->elfDesignVector.dvNumAxes = cAxes;
        }
        else
        {
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
            plfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
            plfw->elfDesignVector.dvNumAxes = 0;
        }
    }
    else
    {
        plfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
        plfw->elfDesignVector.dvNumAxes = 0;
    }
}


/******************************Public*Routine******************************\
* BOOL bIFIMetricsToLogFontW2                                              *
*                                                                          *
* Used during font enumeration.                                            *
*                                                                          *
* Fill a LOGFONT structure using the information in a IFIMETRICS           *
* structure.                                                               *
*                                                                          *
* The following fields need to be transformed by the Device to World       *
* transform:                                                               *
*                                                                          *
*       lfHeight    (from pifi->fwdMaxBaselineExt)                         *
*       lfWidth     (from pifi->fwdAveCharWidth)                           *
*                                                                          *
* In the case of scalable fonts, these quantities are first prescaled      *
* into                                                                     *
* device units to be the equivalent of a 24 point font.                    *
* This is for Win 3.1                                                      *
* compatibility with EnumFonts.                                            *
*                                                                          *
* Return:                                                                  *
*   TRUE if successful, FALSE if an error occurs.                          *
*                                                                          *
* History:                                                                 *
*  9-Oct-1991 by Gilman Wong [gilmanw]                                     *
* Added scalable font support.                                             *
*  Wed 14-Aug-1991 13:42:22 by Kirk Olynyk [kirko]                         *
* Changed the LOGFONTA to a LOGFONTW.                                      *
*  02-May-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bIFIMetricsToLogFontW2 (
    DCOBJ       &dco,
    ENUMLOGFONTEXW   *pelfw,
    PIFIMETRICS pifi,
    EFLOATEXT        efScale
    )
{
    IFIOBJ ifio(pifi);

// do all the conversions except for the height and width

    vIFIMetricsToEnumLogFontW((ENUMLOGFONTW *)pelfw,pifi);

    if (ifio.bContinuousScaling())
    {
        pelfw->elfLogFont.lfWidth  = lCvt(efScale, ifio.lfWidth());
        pelfw->elfLogFont.lfHeight = lCvt(efScale, ifio.lfHeight());
    }

//
// At this point the height and width of the logical font are in pixel units
// in device space. We must still transform these to world coordiantes
//
    EXFORMOBJ xoToWorld(dco, DEVICE_TO_WORLD);

    if (!xoToWorld.bValid())
    {
        WARNING("gdisrv!bIFIMetricsToLogFontW2(): EXFORMOBJ constructor failed\n");
        return (FALSE);
    }

// Only if not identity transform do we need to do anything more.

    if (!xoToWorld.bTranslationsOnly())
    {
        EFLOATEXT efA, efB;

        {
        //
        // efB == baseline scaling factor
        //
            EVECTORFL evflB;

            EVECTORFL evflA(ifio.pptlBaseline()->x,ifio.pptlBaseline()->y);
            efB.eqLength(evflA);
            evflB.eqDiv(evflA,efB);

            if (!xoToWorld.bXform(evflB))
            {
                WARNING("gdisrv!bIFIMetricsToLogFontW2(): transform failed\n");
                return (FALSE);
            }
            efB.eqLength(evflB);
        }
        pelfw->elfLogFont.lfWidth = lCvt(efB, pelfw->elfLogFont.lfWidth);

        {
        //
        // efA == ascender scaling factor
        //
            EVECTORFL evflB;

            EVECTORFL evflA(-ifio.pptlBaseline()->y,ifio.pptlBaseline()->x);
            efA.eqLength(evflA);
            evflB.eqDiv(evflA,efA);

            if (!xoToWorld.bXform(evflB))
            {
                WARNING("gdisrv!bIFIMetricsToLogFontW2(): transform failed\n");
                return (FALSE);
            }
            efA.eqLength(evflB);
        }
        pelfw->elfLogFont.lfHeight = lCvt(efA, pelfw->elfLogFont.lfHeight);
    }

    return(TRUE);
}


#ifndef FE_SB  //moved to ifiobjr.hxx
/*********************************Class************************************\
* class IFIOBJR: public IFIOBJ
*
* History:
*  Tue 22-Dec-1992 14:05:24 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class IFIOBJR : public IFIOBJ
{
public:

    FONTDIFF fd;

    LONG lMaxCharWidth;
    LONG lAveCharWidth;
    LONG lInternalLeading;
    LONG lExternalLeading;
    LONG lDigitizedAspectX;
    LONG lDigitizedAspectY;

    IFIOBJR(const IFIMETRICS *pifi_, RFONTOBJ& rfo_, DCOBJ& dco);

    BYTE tmItalic()
    {
        return((BYTE) ((FM_SEL_ITALIC & fd.fsSelection)?255:0));
    }

    LONG tmMaxCharWidth()
    {
        return(lMaxCharWidth);
    }

    LONG tmAveCharWidth()
    {
        return(lAveCharWidth);
    }

    LONG tmInternalLeading()
    {
        return(lInternalLeading);
    }

    LONG tmExternalLeading()
    {
        return(lExternalLeading);
    }
    LONG tmWeight()
    {
        return((LONG) (fd.usWinWeight));
    }

    FSHORT fsSimSelection()
    {
        return(fd.fsSelection);
    }
    LONG tmDigitizedAspectX()
    {
        return lDigitizedAspectX;
    }
    LONG tmDigitizedAspectY()
    {
        return lDigitizedAspectY;
    }

};


/******************************Member*Function*****************************\
* IFIOBJR::IFIOBJR                                                         *
*                                                                          *
* This is where I place all of the knowlege of how to get the metrics      *
* for simulated for simulated fonts.                                       *
*                                                                          *
* History:                                                                 *
*  Wed 24-Mar-1993 23:32:23 -by- Charles Whitmer [chuckwh]                 *
* Made it respect the proper conventions when copying the FONTDIFF.  A     *
* bold simulation on an italic font is a BoldItalic simulation, etc.       *
*                                                                          *
*  Tue 22-Dec-1992 14:18:11 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

IFIOBJR::IFIOBJR(const IFIMETRICS *pifi_, RFONTOBJ& rfo_, DCOBJ& dco) : IFIOBJ(pifi_)
{
    FONTSIM *pfs = (FONTSIM*) (((BYTE*) pifi) + pifi->dpFontSim);

    switch (rfo_.pfo()->flFontType & (FO_SIM_BOLD+FO_SIM_ITALIC))
    {
    case 0:

        fd.bWeight         = pifi->panose.bWeight  ;
        fd.usWinWeight     = pifi->usWinWeight     ;
        fd.fsSelection     = pifi->fsSelection     ;
        fd.fwdAveCharWidth = pifi->fwdAveCharWidth ;
        fd.fwdMaxCharInc   = pifi->fwdMaxCharInc   ;
        fd.ptlCaret        = pifi->ptlCaret        ;
        break;

    case FO_SIM_BOLD:

    // If base (physical) font is already italic, emboldening yields
    // a bold-italic simulation.

        if (pifi->fsSelection & FM_SEL_ITALIC)
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        else
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBold));
        break;

    case FO_SIM_ITALIC:

    // If base (physical) font is already bold, italicization yields
    // a bold-italic simulation.

        if (pifi->fsSelection & FM_SEL_BOLD)
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        else
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpItalic));
        break;

    case FO_SIM_BOLD+FO_SIM_ITALIC:

        fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        break;
    }

    lAveCharWidth     = (LONG) fd.fwdAveCharWidth;
    lMaxCharWidth     = (LONG) fd.fwdMaxCharInc;
    lExternalLeading  = (LONG) fwdExternalLeading();
    lInternalLeading  = (LONG) fwdInternalLeading();

    if (!bContinuousScaling())
    {
        {
            const LONG lx = rfo_.pptlSim()->x;
            if (lx > 1)
            {
                lAveCharWidth *= lx;
                lMaxCharWidth *= lx;
            }
        }


        {
            const LONG ly = rfo_.pptlSim()->y;
            if (ly > 1)
            {
                lExternalLeading *= ly;
                lInternalLeading *= ly;
            }
        }
    }

// [Windows 3.1 compatibility]
// If TrueType font, then we need to substitute the device resolution for
// the aspect ratio.

    if (bTrueType())
    {
        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "ctIFIOBJR(): bad HDEV in DC\n");

    // [Windows 3.1 compatibility]
    // Win 3.1 has these swapped.  It puts VertRes in tmDigitizedAspectX
    // and HorzRes in tmDigitizedAspectY.

        lDigitizedAspectX = (LONG) pdo.ulLogPixelsY();
        lDigitizedAspectY = (LONG) pdo.ulLogPixelsX();
    }
    else
    {
    // [Windows 3.1 compatibility]
    // Win 3.1 has these swapped.  It puts VertRes in tmDigitizedAspectX
    // and HorzRes in tmDigitizedAspectY.

        lDigitizedAspectX = pptlAspect()->y * rfo_.pptlSim()->y;
        lDigitizedAspectY = pptlAspect()->x * rfo_.pptlSim()->x;
    }

}

#endif

/******************************Public*Routine******************************\
* BOOL bIFIMetricsToTextMetricW (
*         RFONTOBJ &rfo,
*         DCOBJ &dco,
*        PTEXTMETRICW ptmw,
*         PIFIMETRICS pifi
*     )
*
* Fill a TEXTMETRIC structure based on information from an IFIMETRICS
* structure.
*
* Everything returned in World (or Logical) coordinates.  To that end,
* the following fields must be transformed by either the Notional to
* World transform (for scalable fonts) or the Device to World transform
* (for bitmap fonts):
*
*       tmHeight            (from pifi->fwdMaxBaselineExt)
*       tmMaxCharWidth      (from pifi->fwdMaxCharInc)
*       tmAveCharWidth      (from pifi->fwdAveCharWidth)
*       tmAscent            (from pifi->fwdMaxAscender)
*       tmInternalLeading   (from pifi->fwdInternalLeading)
*       tmExternalLeading   (from pifi->fwdExternalLeading)
*
* Return:
*   TRUE if successful, FALSE if an error occurs.
*
*   totaly stolen from GilmanW
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bIFIMetricsToTextMetricWStrict(  // strict means unicode values only [bodind]
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TEXTMETRICW *ptmw,
    IFIMETRICS  *pifi
    )
{

    IFIOBJR ifio(pifi,rfo,dco);

//
// At low pixels per Em, the Height and ascender do not scaler linearly
// so we take the results directly from the realization
//
    if (dco.pdc->bWorldToDeviceIdentity())
    {
        ptmw->tmHeight = LONG_FLOOR_OF_FIX(rfo.fxMaxExtent() + FIX_HALF);
        ptmw->tmAscent = LONG_FLOOR_OF_FIX(rfo.fxMaxAscent() + FIX_HALF);
        ptmw->tmOverhang = rfo.lOverhang();

    }
    else
    {
        ptmw->tmHeight = lCvt(rfo.efDtoWAscent_31(),(LONG)rfo.fxMaxExtent());
        ptmw->tmAscent = lCvt(rfo.efDtoWAscent_31(),(LONG)rfo.fxMaxAscent());
        ptmw->tmOverhang = lCvt(rfo.efDtoWBase_31(), rfo.lOverhang() << 4);
    }

    if (!ifio.bContinuousScaling())
    {
        if (dco.pdc->bWorldToDeviceIdentity())
        {
            ptmw->tmMaxCharWidth    = ifio.tmMaxCharWidth();
            ptmw->tmAveCharWidth    = ifio.tmAveCharWidth();
            ptmw->tmInternalLeading = ifio.tmInternalLeading();
            ptmw->tmExternalLeading = ifio.tmExternalLeading();
        }
        else
        {
            ptmw->tmMaxCharWidth
              = lCvt(rfo.efDtoWBase_31(),((LONG) ifio.tmMaxCharWidth()) << 4);
            ptmw->tmAveCharWidth
              = lCvt(rfo.efDtoWBase_31(),((LONG) ifio.tmAveCharWidth()) << 4);
            ptmw->tmInternalLeading
              = lCvt(rfo.efDtoWAscent_31(),((LONG) ifio.tmInternalLeading()) << 4);
            ptmw->tmExternalLeading
              = lCvt(rfo.efDtoWAscent_31(),((LONG) ifio.tmExternalLeading()) << 4);
        }
    }
    else
    {
        if (rfo.lNonLinearIntLeading() == MINLONG)
        {
        // Rather than scaling the notional internal leading, try
        // to get closer to HINTED internal leading by computing it
        // as the difference between the HINTED height and UNHINTED
        // EmHeight.

            ptmw->tmInternalLeading =
                ptmw->tmHeight
                - lCvt(rfo.efNtoWScaleAscender(),ifio.fwdUnitsPerEm());
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            ptmw->tmInternalLeading =
                lCvt(rfo.efDtoWAscent_31(),rfo.lNonLinearIntLeading());
        }

    // Either scale the external leading linearly from N to W, or back
    // transform the device units version returned from the font provider.

        if (rfo.lNonLinearExtLeading() == MINLONG)
        {
            ptmw->tmExternalLeading =
                lCvt(rfo.efNtoWScaleAscender(),ifio.fwdExternalLeading());
        }
        else
        {
            ptmw->tmExternalLeading =
                lCvt(rfo.efDtoWAscent_31(),rfo.lNonLinearExtLeading());
        }

        if (rfo.lNonLinearMaxCharWidth() == MINLONG)
        {
            ptmw->tmMaxCharWidth =
                lCvt(rfo.efNtoWScaleBaseline(), ifio.tmMaxCharWidth());
        }
        else
        {
        // But if the font provider has given us a hinted value, we use it

            ptmw->tmMaxCharWidth =
                lCvt(rfo.efDtoWBase_31(),rfo.lNonLinearMaxCharWidth());
        }

        if (rfo.lNonLinearAvgCharWidth() == MINLONG)
        {
            ptmw->tmAveCharWidth =
                lCvt(rfo.efNtoWScaleBaseline(), ifio.tmAveCharWidth());
        }
        else
        {
        // But if the font provider has given us a hinted value, we use it

            ptmw->tmAveCharWidth =
                lCvt(rfo.efDtoWBase_31(),rfo.lNonLinearAvgCharWidth());
        }
    }

//
// height = ascender + descender, by definition
//
    ptmw->tmDescent = ptmw->tmHeight - ptmw->tmAscent;

//
// The rest of these are not transform dependent.
//
    ptmw->tmWeight     = ifio.tmWeight();
    ptmw->tmItalic     = ifio.tmItalic();
    ptmw->tmUnderlined = ifio.lfUnderline();
    ptmw->tmStruckOut  = ifio.lfStrikeOut();

// Better check the simulation flags for underline and strikeout.

    {
        FLONG flSim = dco.pdc->flSimulationFlags();

    // If simulated, set underline and strike out flags.

        ptmw->tmUnderlined = (flSim & TSIM_UNDERLINE1) ? 0xff : FALSE;
        ptmw->tmStruckOut  = (flSim & TSIM_STRIKEOUT)  ? 0xff : FALSE;
    }

    ptmw->tmFirstChar        =  ifio.wcFirstChar()  ;
    ptmw->tmLastChar         =  ifio.wcLastChar()   ;
    ptmw->tmDefaultChar      =  ifio.wcDefaultChar();
    ptmw->tmBreakChar        =  ifio.wcBreakChar()  ;

// New in win95: depending on charset in the logfont and charsets
// available in the font we return the tmCharset that the mapper has decided
// is the best. At this stage the claim is that mapping has already
// occured and that the charset stored in the dc must not be dirty.

    //ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
    //          "bIFIMetricsToTextMetricW, charset is dirty\n");
    ptmw->tmCharSet = (BYTE)(dco.pdc->iCS_CP() >> 16);

// [Windows 3.1 compatibility]
// TMPF_DEVICE really means whether the device realized this font or
// GDI realized it.  Under Win 3.1 printer drivers can realize True Type
// fonts.  When the TC_RA_ABLE flag isn't set the driver's realization will
// be chosen and TMPF_DEVICE flag should be set.

// Word97-J has problem to print vertically,
// So we need to get rid of TMPF_DEVICE to make print correctly

    if (ifio.bTrueType())
    {
        PDEVOBJ pdo(dco.hdev());

        ASSERTGDI(pdo.bValid(), "PDEVOBJ constructor failed\n");

        BOOL bWin31Device = (!pdo.bDisplayPDEV() &&
                            !(pdo.flTextCaps() & TC_RA_ABLE ) &&
                            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                            !(gbDBCSCodePage && (GetAppCompatFlags(NULL) & GACF_TTIGNOREDDEVICE)));

    // Note that we check the PDEV directly rather than the DC because
    // DCOBJ::bDisplay() is not TRUE for display ICs (just display DCs
    // which are DCTYPE_DIRECT).

       ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                             | ( (bWin31Device) ? TMPF_DEVICE : 0);
    }
    else
    {
        ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                                 | (rfo.bDeviceFont() ? TMPF_DEVICE : 0)
                                 | (((pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE) && !(gbDBCSCodePage && (GetAppCompatFlags(NULL) & GACF_TTIGNOREDDEVICE))) ? (TMPF_VECTOR|TMPF_DEVICE): 0);
    }

    ptmw->tmDigitizedAspectX = ifio.tmDigitizedAspectX();
    ptmw->tmDigitizedAspectY = ifio.tmDigitizedAspectY();

    return(TRUE);
}

/******************************Public*Routine******************************\
* bGetTextMetrics
*
*
* History:
*  5-5-2000 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL bGetTextMetrics(
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TMW_INTERNAL *ptmi
)
{
    BOOL    bRet = FALSE;
    
    // Get cached TextMetrics if available.

    if (rfo.bValid())
    {
        if( rfo.ptmw() != NULL )
        {
            *ptmi = *(rfo.ptmw());

        // time to fix underscore, strikeout and charset. The point is that
        // bFindRFONT may have found an old realization that corresponded
        // to different values of these parameters in the logfont.

            FLONG flSim = dco.pdc->flSimulationFlags();

            ptmi->tmw.tmUnderlined = (flSim & TSIM_UNDERLINE1) ? 0xff : FALSE;
            ptmi->tmw.tmStruckOut  = (flSim & TSIM_STRIKEOUT)  ? 0xff : FALSE;

        // New in win95: depending on charset in the logfont and charsets
        // available in the font we return the tmCharset
        // that the mapper has decided is the best.
        // At this stage the claim is that mapping has already
        // occured and that the charset stored in the dc must not be dirty.

             ptmi->tmw.tmCharSet = (BYTE)(dco.pdc->iCS_CP() >> 16);
             bRet = TRUE;
        }
        else
        {
        // Get PFE user object from RFONT

             PFEOBJ      pfeo (rfo.ppfe());

             ASSERTGDI(pfeo.bValid(), "ERROR invalid ppfe in valid rfo");
             bRet = (BOOL) bIFIMetricsToTextMetricW(rfo, dco, ptmi, pfeo.pifi());
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bIFIMetricsToTextMetricW(
*
* tacks on ansi values
*
* History:
*  27-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bIFIMetricsToTextMetricW(
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TMW_INTERNAL *ptmi,
    IFIMETRICS  *pifi
    )
{

    ASSERTGDI(rfo.ptmw() == NULL, "bIFIFMetricToTextMetricsW TEXTMETRIC already cached\n");

    BOOL bRet = bIFIMetricsToTextMetricWStrict(rfo,dco,&ptmi->tmw,pifi);

    ptmi->tmdTmw.chFirst    = pifi->chFirstChar  ;
    ptmi->tmdTmw.chLast     = pifi->chLastChar   ;
    ptmi->tmdTmw.chDefault  = pifi->chDefaultChar;
    ptmi->tmdTmw.chBreak    = pifi->chBreakChar  ;

    if( bRet )
    {
        TMW_INTERNAL *ptmw = (TMW_INTERNAL*) PALLOCMEM(sizeof(TMW_INTERNAL),'wmtG');

        if( ptmw == NULL )
        {
            WARNING("bIFIMetricsToTextMetricW unable to alloc mem for cached TEXTMETRICS\n");
        }
        else
        {
            rfo.ptmwSet( ptmw );
            *ptmw = *ptmi;
        }
    }

    return (bRet);
}



/******************************Public*Routine******************************\
* bIFIMetricsToTextMetricW2
*
* Used during font enumeration.
*
* Fill a NEWTEXTMETRICW structure based on information from an IFIMETRICS
* structure.
*
* The following fields need to be transformed by the Device to World
* transform:
*
*       tmHeight            (from pifi->fwdMaxBaselineExt)
*       tmMaxCharWidth      (from pifi->fwdMaxCharInc)
*       tmAveCharWidth      (from pifi->fwdAveCharWidth)
*       tmAscent            (from pifi->fwdMaxAscender)
*       tmInternalLeading   (from pifi->fwdInternalLeading)
*       tmExternalLeading   (from pifi->fwdExternalLeading)
*
* In the case of scalable fonts, these quantities are first prescaled into
* device units to be the equivalent of a 24 point font.  This is for Win 3.1
* compatibility with EnumFonts.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
*   totaly stolen from GilmanW
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bIFIMetricsToTextMetricW2 (
    DCOBJ           &dco,
    NTMW_INTERNAL * pntmi,
    PFEOBJ         &pfeo,
    BOOL            bDeviceFont,
    ULONG           iEnumType,
    EFLOATEXT       efScale,
    LONG            tmDigitizedAspectX,
    LONG            tmDigitizedAspectY
    )
{
    PIFIMETRICS     pifi = pfeo.pifi();
    PNEWTEXTMETRICW ptmw = &pntmi->entmw.etmNewTextMetricEx.ntmTm;
    IFIOBJ ifio(pifi);

// If scalable font, then return following metrics as if font were realized at
// 24 points.

    if (ifio.bContinuousScaling())
    {
        ptmw->tmHeight = lCvt(efScale, ifio.lfHeight());

    // Now we need to adjust the scale factor due to roundoff in the height.
    // This will more closely approximate the NtoW scale computed if ever this
    // font gets selected.

        efScale  = (LONG) ptmw->tmHeight;
        efScale /= (LONG) ifio.lfHeight();

    // Use scaling factor to convert from IFIMETRICS to TEXTMETRIC fields.

        ptmw->tmAscent          = lCvt(efScale, (LONG) ifio.fwdWinAscender());
        ptmw->tmInternalLeading = lCvt(efScale, (LONG) ifio.fwdInternalLeading());
        ptmw->tmExternalLeading = lCvt(efScale, (LONG) ifio.fwdExternalLeading());

        ptmw->tmAveCharWidth    = lCvt(efScale, (LONG) ifio.fwdAveCharWidth());
        ptmw->tmMaxCharWidth    = lCvt(efScale, (LONG) ifio.fwdMaxCharInc());

    } /* if */

// Its a bitmap font, so no prescaling to 24 point needed.

    else
    {
        ptmw->tmHeight           = ifio.lfHeight();
        ptmw->tmAscent           = ifio.fwdWinAscender();
        ptmw->tmInternalLeading  = ifio.fwdInternalLeading();
        ptmw->tmExternalLeading  = ifio.fwdExternalLeading();
        ptmw->tmAveCharWidth     = ifio.fwdAveCharWidth();
        ptmw->tmMaxCharWidth     = ifio.fwdMaxCharInc();

    } /* else */

// Now that all fonts are:
//
//      Bitmap fonts -- in device units
//      Scalable fonts -- artificially scaled to 24 point device
//                        units (a 'la Win 3.1)
//
// put them through the Device to World transform.

    EXFORMOBJ   xoToWorld(dco, DEVICE_TO_WORLD);
    if (!xoToWorld.bValid())
    {
        WARNING("gdisrv!bIFIMetricsToTextMetricW2(): EXFORMOBJ constructor failed\n");
        return (FALSE);
    }

// Only if not identity transform do we need to do anything more.

    if (!xoToWorld.bTranslationsOnly())
    {
        EFLOATEXT efX, efY;

    // efX == horizontal scaling factor (Device to World)

        EVECTORFL evflH(1,0);          // device space unit vector (x-axis)

        if (!xoToWorld.bXform(evflH))
        {
            WARNING("gdisrv!bIFIMetricsToTextMetricW2(): transform failed\n");
            return (FALSE);
        }
        efX.eqLength(evflH);

    // efY == vertical scaling factor (Device to World)

        EVECTORFL evflV(0,1);          // device space unit vector (y-axis)

        if (!xoToWorld.bXform(evflV))
        {
            WARNING("gdisrv!bIFIMetricsToTextMetricW2(): transform failed\n");
            return (FALSE);
        }
        efY.eqLength(evflV);

    // Convert from device to world using scaling factors.

        ptmw->tmHeight = lCvt(efY, (LONG) ptmw->tmHeight);
        ptmw->tmAscent = lCvt(efY, (LONG) ptmw->tmAscent);


        ptmw->tmAveCharWidth = lCvt(efX, (LONG) ptmw->tmAveCharWidth);
        ptmw->tmMaxCharWidth = lCvt(efX, (LONG) ptmw->tmMaxCharWidth);


        ptmw->tmInternalLeading = lCvt(efY, (LONG) ptmw->tmInternalLeading);
        ptmw->tmExternalLeading = lCvt(efY, (LONG) ptmw->tmExternalLeading);

    } /* if */

// these are now passed in, computed in the calling routine

    ptmw->tmDigitizedAspectX = tmDigitizedAspectX;
    ptmw->tmDigitizedAspectY = tmDigitizedAspectY;

// The rest are pretty easy (no transformation of IFIMETRICS needed)

    ptmw->tmDescent          = ptmw->tmHeight - ptmw->tmAscent;
    ptmw->tmWeight           = ifio.lfWeight();
    ptmw->tmItalic           = ifio.lfItalic();
    ptmw->tmUnderlined       = ifio.lfUnderline();
    ptmw->tmStruckOut        = ifio.lfStrikeOut();

    ptmw->tmFirstChar        = ifio.wcFirstChar();
    ptmw->tmLastChar         = ifio.wcLastChar();
    ptmw->tmDefaultChar      = ifio.wcDefaultChar();
    ptmw->tmBreakChar        = ifio.wcBreakChar();

    ptmw->tmCharSet        = ifio.lfCharSet();

// [Windows 3.1 compatibility]
//
// Note that the tmPitchAndFamily is computed slightly differently than
// in bIFIMetricsToTextMetricWStrict.  That's because the enumeration
// does not hack the tmPitchAndFamily to make TrueType fonts look like
// device fonts.  Enumeration does this in the flFontType flags passed
// back to the callback function.  On the other hand, GetTextMetrics, which
// bIFIMetricsToTextMetricWStrict services, does the hack in tmPitchAndFamily.

    ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                             | ((bDeviceFont) ? TMPF_DEVICE : 0)
                             | ((pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE) ? (TMPF_VECTOR|TMPF_DEVICE): 0);

// The simulated faces are not enumerated, so this is 0.

    ptmw->tmOverhang       = 0;

// If TrueType, then fill in the new NEWTEXTMETRICW fields.
// Comment wrong: we shall do it for every font

    ptmw->ntmFlags = 0;

    if (!ifio.bBold() && !ifio.bItalic())
        ptmw->ntmFlags |= NTM_REGULAR;
    else
    {
        if (ifio.bItalic())
            ptmw->ntmFlags |= NTM_ITALIC;
        if (ifio.bBold())
            ptmw->ntmFlags |= NTM_BOLD;
    }

    if (pifi->flInfo & FM_INFO_NONNEGATIVE_AC)
        ptmw->ntmFlags |= NTM_NONNEGATIVE_AC;

    if (pifi->flInfo & FM_INFO_TECH_TYPE1)
    {
        if (pifi->flInfo & FM_INFO_TECH_MM)
            ptmw->ntmFlags |= NTM_MULTIPLEMASTER;

        if (pifi->flInfo & FM_INFO_TECH_CFF)
            ptmw->ntmFlags |= NTM_PS_OPENTYPE; // proper, not true type
        else
            ptmw->ntmFlags |= NTM_TYPE1;  // old fashioned t1 screen font
    }

    if (pifi->flInfo & FM_INFO_DSIG)
    {
        ptmw->ntmFlags |= NTM_DSIG;
        if (pifi->flInfo & FM_INFO_TECH_TRUETYPE)
            ptmw->ntmFlags |= NTM_TT_OPENTYPE;
    }

    ptmw->ntmSizeEM     = ifio.fwdUnitsPerEm();
    ptmw->ntmCellHeight = (UINT) ifio.lfHeight();;
    ptmw->ntmAvgWidth   = ifio.fwdAveCharWidth();

    pntmi->tmdNtmw.chFirst    = pifi->chFirstChar  ;
    pntmi->tmdNtmw.chLast     = pifi->chLastChar   ;
    pntmi->tmdNtmw.chDefault  = pifi->chDefaultChar;
    pntmi->tmdNtmw.chBreak    = pifi->chBreakChar  ;

    PTRDIFF dpFontSig = 0;

    if (pfeo.pifi()->cjIfiExtra > offsetof(IFIEXTRA, dpFontSig))
    {
        dpFontSig = ((IFIEXTRA *)(pfeo.pifi() + 1))->dpFontSig;
    }

    if (dpFontSig)
    {
    // this is only going to work in the next release of win95 (win96?)
    // according to DavidMS, and we have right now in SUR

        pntmi->entmw.etmNewTextMetricEx.ntmFontSig = *((FONTSIGNATURE *)
                                  ((BYTE *)pifi + dpFontSig));
    }
    else // do not bother and waste time, will not be used anyway
    {
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[0] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[1] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[2] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[3] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsCsb[0] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsCsb[1] = 0;
    }

    return (TRUE);
}


INT
LOADSTRING(
    HANDLE  hinst,
    UINT    id,
    PWSTR   pwstr,
    INT     bufsize
    )

/*++

Routine Description:

    Loads a string resource from the resource file associated with a
    specified module, copies the string into a buffer, and appends a
    terminating null character.

Arguments:

    hinst   handle to the module containing the string resource
    id      ID of the string to be loaded
    pwstr   points to the buffer to receive the string
    bufsize size of the buffer, in characters.

Return Value:

    Return value is the number of characters copied into the buffer, not
    including the null-terminating character.  If pwst is NULL then it
    just returns the size of the string.


I stole this from the pscript driver [gerritv]


--*/

#define WINRT_STRING    6       // string resource type

{
    PWSTR   pwstrBuffer;
    ULONG   size;

    // String Tables are broken up into 16 string segments.
    // Find the segment containing the string we are interested in.

    pwstrBuffer = (PWSTR) EngFindResource(hinst, (id>>4)+1, WINRT_STRING, &size);

    if (pwstrBuffer == NULL ) {

        WARNING("Gre:LOADSTRING failed.\n");
        bufsize = 0;
    } else {

        PWSTR   pwstrEnd = pwstrBuffer + size / sizeof(WCHAR);
        INT     length;

        // Move past the other strings in this segment.

        id &= 0x0F;

        while (pwstrBuffer < pwstrEnd) {

            // PASCAL style string - first char is length

            length = *pwstrBuffer++;

            if(id-- == 0 ) {
                break;
            }

            pwstrBuffer += length;
        }

        if(!pwstr)
        {
            return(length);
        }

        if (pwstrBuffer < pwstrEnd) {

            // Truncate the string if it's longer than max buffer size

            if (--bufsize > length)
                bufsize = length;
            memcpy(pwstr, pwstrBuffer, bufsize*sizeof(WCHAR));
        } else {

            WARNING("Gre:LOADSTRING Bad string resource.\n");
            bufsize = 0;
        }

    }

    if (pwstr)
    {
        pwstr[bufsize] = L'\0';
    }

    return bufsize;
}

#ifdef _HYDRA_
    DWORD gdwOffset;
#endif

typedef struct _CHSET_SCRIPT
{
    ULONG ulCharSet;
    WCHAR *pwszScript;
} CHSET_SCRIPT;


CHSET_SCRIPT aScripts[NUMBER_OF_SCRIPTS];


/********************************************************************************
 * BOOL InitializeScripts()
 *
 * Initialize script names from resource strings in win32k.sys
 *
 * This function intializes the script names from the string resources compiled
 * into win32k.sys.  The string should be in the following format: xxx:string
 * where xxx is an ascii decimal respresentation of a charset value and string
 * the script that is associated with that charset.
 *
 * History
 *  3-5-95 16:00:54 by Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ********************************************************************************/

extern "C" BOOL InitializeScripts()
{
    HANDLE h;
    BOOL ReturnValue = FALSE;

    if(h = EngLoadModule(L"win32k.sys"))
    {
        UINT u;
        DWORD TotalSizeInWChars = 0;
        PWCHAR pStringBuffer = NULL;

    // first compute the total size of all the strings

        for(u = 0; u < NUMBER_OF_SCRIPTS; u++)
        {
            INT StringSize;

            StringSize = LOADSTRING(h, u, NULL, 0);

            if(!StringSize)
            {
                WARNING("InitializeScripts unable to LOADSTRING\n");
                break;
            }

            TotalSizeInWChars += StringSize + 1;
        }

    // allocate buffer if computation above is successful

        if(u == NUMBER_OF_SCRIPTS)
        {
            pStringBuffer =
              (PWCHAR) PALLOCMEM(TotalSizeInWChars * sizeof(WCHAR),'lscG');
        }

        aScripts[0].pwszScript = NULL;  // don't leave this unitialized

    // if buffer allocated, read each string into buffer

        if(pStringBuffer)
        {
        // next read in each string

            for(u = 0; u < NUMBER_OF_SCRIPTS; u++)
            {
                INT StringSize;

                aScripts[u].pwszScript = pStringBuffer;

                StringSize = LOADSTRING(h, u, pStringBuffer, TotalSizeInWChars) + 1;
                pStringBuffer += StringSize;
                TotalSizeInWChars -= StringSize;

                aScripts[u].ulCharSet = 0;

            // Once we've read in the string, parse the charset component.
            // The string will be in the form "xxx:script", where xxx
            // is the ascii decimal representation of the string

                while(*(aScripts[u].pwszScript) &&
                      *(aScripts[u].pwszScript) != (WCHAR) ':')
                {
                    aScripts[u].ulCharSet *= 10;
                    aScripts[u].ulCharSet +=
                      *(aScripts[u].pwszScript) - (WCHAR) '0';
                    aScripts[u].pwszScript += 1;
#ifdef _HYDRA_
                    if (u == 0)
                        gdwOffset++;
#endif
                }

            // add 1000 to the charset value to be compatible with other code

                aScripts[u].ulCharSet += 1000;

                ASSERTGDI(*aScripts[u].pwszScript == (WCHAR) ':',
                          "InitializeScript missing colon\n");

           // move past the colon

                aScripts[u].pwszScript += 1;
#ifdef _HYDRA_
                if (u == 0)
                    gdwOffset++;
#endif

            }

            ASSERTGDI((TotalSizeInWChars == 0), "InitializeScripts: TotalSize != 0\n");

            ReturnValue = TRUE;
        }

        EngFreeModule(h);

    }
    return(ReturnValue);
}

#ifdef _HYDRA_
/******************************Public*Routine******************************\
* MultiUserGreDeleteScripts
*
* For MultiUserGreCleanup (Hydra) cleanup.
*
* History:
*  09-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID MultiUserGreDeleteScripts()
{
    WCHAR* pszBuffer;

    if (aScripts[0].pwszScript) {

        pszBuffer = aScripts[0].pwszScript;

        pszBuffer -= gdwOffset;

        VFREEMEM(pszBuffer);
    }
}
#endif

/******************************Public*Routine******************************\
* vLookupScript
*
* Copy the script name corresponding to the specified character set.
* Copy the SCRIPT_UNKNOWN string if character set not found in the table.
*
\**************************************************************************/

VOID vLookupScript(ULONG lfCharSet, WCHAR *pwszScript)
{
//MAYBE replace linear search by binary search

    UINT i;
    ULONG ulStrlen;
    lfCharSet += 1000;
    for (i = 0; i < NUMBER_OF_SCRIPTS; i++)
        if (aScripts[i].ulCharSet == lfCharSet)
            break;

    wcscpy(pwszScript, (i<NUMBER_OF_SCRIPTS) ? aScripts[i].pwszScript :
           aScripts[SCRIPT_UNKNOWN].pwszScript);
}


/******************************Public*Routine******************************\
* SIZE_T cjCopyFontDataW
*
* Copies data needed for EnumFonts callback function from the IFIMETRICS
* data of the given font.
*
* Because the font is not realized (notice: no RFONTOBJ& passed in), all
* units remain in NOTIONAL.
*
* Two parameters may influence the family name passed back.  If
* efsty is EFSTYLE_OTHER, then the face name should be substituted for
* the family name.  If pwszFamilyOverride is !NULL, then it should
* replace the family name.  pwszFamilyOverride has precedence over efsty.
* Both of these behaviors are for Win3.1 compatibility.
*
* Note: pefdw is user memory, which might be asynchronously changed
*   at any time.  So, we cannot trust any values read from that buffer.
*
* Returns:
*   The number of bytes copied, 0 if error occurs.
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  03-Sep-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

SIZE_T cjCopyFontDataW (
    DCOBJ          &dco,
    PENUMFONTDATAW pefdw,
    PFEOBJ         &pfeo,
    ULONG          efsty,              // based on style, may need to change family name to facename
    PWSZ           pwszFamilyOverride, // if this is !NULL, this is used as family name
    ULONG          lfCharSetOverride,
    BOOL           bCharSetOverride,   // tell us if overrides should be used
    ULONG          iEnumType           // enumeration type, tells how to fill the data
    )
{
    PIFIMETRICS    pifi    = pfeo.pifi();
    BOOL           bDevice = pfeo.bDeviceFont();
    EFLOATEXT      efScale;
    ULONG          cjEfdw;
    ULONG          dpNtmi;

    IFIOBJ ifio(pifi);

    LONG tmDigitizedAspectX = ifio.pptlAspect()->y;
    LONG tmDigitizedAspectY = ifio.pptlAspect()->x;


    PDEVOBJ pdo(dco.hdev());

    if (!pdo.bValid())
    {
        WARNING("gdisrv!cjCopyFontDataW(): PDEVOBJ constructor failed\n");
        return ((SIZE_T)0);
    }

    if (bDevice && !ifio.bContinuousScaling())
    {
        tmDigitizedAspectX = pdo.ulLogPixelsX();
        tmDigitizedAspectY = pdo.ulLogPixelsY();
    }

// Calculate the scale factor

    if (ifio.bContinuousScaling())
    {
    // According to the bizzare convention of Win 3.1, scalable fonts are
    // reported at a default physical height
    // notice the inversion in x,y for win31 compat.

        if (ifio.lfOutPrecision() == OUT_OUTLINE_PRECIS)
        {
            tmDigitizedAspectX = pdo.ulLogPixelsY();
            tmDigitizedAspectY = pdo.ulLogPixelsX();
        }

        if (bDevice)
        {
        // on win95 pcl does not scale at all, ie we could use
        // efScale = (LONG)1; for pcl and we would win95 compat.
        // but,since this does not seem to be reasonable, we shall
        // use the same strategy for ps and pcl unless we find an app
        // which is broken because of this incompatibility. [bodind]

            HLFONT     hlfntDef;
            hlfntDef = pdo.hlfntDefault();

            if (!hlfntDef)
            {
                WARNING("gdisrv!cjCopyFontDataW(): PDEVOBJ.hlfntDefault failed\n");
                return ((SIZE_T)0);
            }

            LFONTOBJ lfo(hlfntDef);
            if (!lfo.bValid())
            {
                WARNING("gdisrv!cjCopyFontDataW(): LFONTOBJ constructor failed\n");
                return ((SIZE_T)0);
            }

            if (lfo.plfw()->lfHeight < 0)
            {
            // already in pixels

                efScale = (-lfo.plfw()->lfHeight);
                efScale /= ifio.fwdUnitsPerEm();
            }
            else
            {
                efScale = (LONG)lfo.plfw()->lfHeight;
                efScale /= (LONG) ifio.lfHeight();
            }
        }
        else // screen fonts
        {
        // efScale = Em-Height (pixels) / Em-Height (font units)

            efScale  = (LONG) DEFAULT_SCALABLE_FONT_HEIGHT_IN_POINTS;
            efScale /= (LONG) POINTS_PER_INCH;
            efScale *= (LONG) pdo.ulLogPixelsY();
            efScale /= (LONG) ifio.fwdUnitsPerEm();
        }
    }

// Convert IFIMETRICS into EXTLOGFONTW.

    if (!bIFIMetricsToLogFontW2(dco, &pefdw->elfexw.elfEnumLogfontEx, pifi, (EFLOATEXT)efScale))
        return ((SIZE_T) 0);

// compute the offset to ntmi
// use kernel memory (cjEfdw and dpNtmi) to store these values

    pefdw->cjEfdw = cjEfdw = pfeo.cjEfdwPFE();
    pefdw->dpNtmi = dpNtmi = pfeo.dpNtmi();

// copy out mm info, if any

    NTMW_INTERNAL *pntmi = (NTMW_INTERNAL *)((BYTE *)pefdw + dpNtmi);

    ULONG         cAxes = 0;
    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)pifi + dpDesVec);
            cAxes  = pdvSrc->dvNumAxes;

            if (cAxes > MM_MAX_NUMAXES)
                cAxes = MM_MAX_NUMAXES;
                
            RtlCopyMemory(&pefdw->elfexw.elfDesignVector, pdvSrc, (SIZE_T)SIZEOFDV(cAxes));
            pefdw->elfexw.elfDesignVector.dvNumAxes = cAxes;
        }
        else
        {
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
            pefdw->elfexw.elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
            pefdw->elfexw.elfDesignVector.dvNumAxes = 0;
        }
    }
    else
    {
        pefdw->elfexw.elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
        pefdw->elfexw.elfDesignVector.dvNumAxes = 0;
    }



// base font:

    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF    dpAXIW = 0;
        AXESLISTW *paxlSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpAxesInfoW))
        {
            dpAXIW = ((IFIEXTRA *)(pifi + 1))->dpAxesInfoW;
            paxlSrc = (AXESLISTW *)((BYTE*)pifi + dpAXIW);
            RtlCopyMemory(&pntmi->entmw.etmAxesList, paxlSrc, SIZEOFAXIW(cAxes));
        }
        else
        {
            ASSERTGDI(dpAXIW, "AxesInfoW needed for base MM font\n");
            pntmi->entmw.etmAxesList.axlReserved = STAMP_AXESLIST;
            pntmi->entmw.etmAxesList.axlNumAxes  = 0;
        }
    }
    else
    {
        pntmi->entmw.etmAxesList.axlReserved = STAMP_AXESLIST;
        pntmi->entmw.etmAxesList.axlNumAxes  = 0;
    }

// Convert IFIMETRICS into TEXTMETRICSW.

    if (!bIFIMetricsToTextMetricW2(dco,
                                   pntmi,
                                   pfeo,
                                   (BOOL) bDevice,
                                   iEnumType,
                                   (EFLOATEXT)efScale,
                                   tmDigitizedAspectX,
                                   tmDigitizedAspectY))
        return ((SIZE_T) 0);

// let us see if charset override should be used:

    if (bCharSetOverride)
    {
        pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE)lfCharSetOverride;
        pntmi->entmw.etmNewTextMetricEx.ntmTm.tmCharSet = (BYTE)lfCharSetOverride;
    }

// we used to do this only if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
// but there is no reason to make this distinction, for EnumFonts and
// EnumFontFamilies, the apps will simply not rely on this information
// being there and correct.

    if(bCharSetOverride)
    {
        vLookupScript(lfCharSetOverride, (WCHAR *)pefdw->elfexw.elfEnumLogfontEx.elfScript);
    }
    else
    {
        pefdw->elfexw.elfEnumLogfontEx.elfScript[0] = L'\0'; // empty string
    }

// If pwszFamilyOverride is valid, then use it as the lfFaceName in LOGFONT.

    if ( pwszFamilyOverride != (PWSZ) NULL )
    {
        wcsncpy(
            pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName,
            pwszFamilyOverride,
            LF_FACESIZE
            );
        pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
    }
    else
    {
    // Otherwise, if efsty is EFSTYLE_OTHER, replace family name (lfFaceName)
    // with face name (elfFullName).

        if ( efsty == EFSTYLE_OTHER )
        {
            wcsncpy(
                pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName,
                pefdw->elfexw.elfEnumLogfontEx.elfFullName,
                LF_FACESIZE
                );
            pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
        }
    }

// Compute the FontType flags.

    pefdw->flType = 0;

    if (ifio.bTrueType())
    {
        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "cjCopyFontDataW(): invalid ppdev\n");

    //
    // [Windows 3.1 compatibility]
    // Win 3.1 hacks TrueType to look like device fonts on printers if the
    // text caps for the DC are not TC_RA_ABLE
    //
    // Note that we check the PDEV directly rather than the DC because
    // DCOBJ::bDisplay() is not TRUE for display ICs (just display DCs
    // which are DCTYPE_DIRECT).
    //

        BOOL bWin31Device = (!pdo.bDisplayPDEV() &&
                            !(pdo.flTextCaps() & TC_RA_ABLE ) &&
                            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE));

        pefdw->flType |= (TRUETYPE_FONTTYPE | (bWin31Device ? DEVICE_FONTTYPE : 0));


    }
    else if (ifio.bBitmap())
    {
        pefdw->flType |= RASTER_FONTTYPE;
    }
    else if (pifi->flInfo & FM_INFO_TECH_TYPE1)
    {
    // See if this is an old fashioned pfm,pfb Type1 installation.
    // ATM for Win95 enumerates such fonts as device, and many apps that
    // expect ATM to be installed on the system also expect Type1 fonts to
    // be enumerated as DEVICE_FONTTYPE. These apps often do not show Type1
    // fonts in their menus unless we change flType to DEVICE_FONTTTYPE,
    // even though, strictly speaking, these are screen fonts.

    // for the same reason we set this bit for ps open type fonts

        pefdw->flType |= DEVICE_FONTTYPE;
    }

    if (bDevice)
    {
        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "cjCopyFontDataW(): invalid ppdev\n");

    // If scalable device font, then ONLY the DEVICE_FONTTYPE bit is set.

        if ( ifio.bContinuousScaling() )
            pefdw->flType = DEVICE_FONTTYPE;

    // Otherwise, the DEVICE_FONTTYPE bit is added to the others.

        else
            pefdw->flType |= DEVICE_FONTTYPE;

    // If scalable printer font AND printer does not set any of the
    // scalability flags in TEXTCAPS, then set the ENUMFONT_SCALE_HACK
    // flag.  Client-side code will enumerate the font back in several
    // different sizes (see Win95 code, drivers\printer\universa\unidrv\
    // enumobj.c, function UniEnumDFonts() for more details).
    //
    // Note that (according to ZhanW in PSD) on Win95, device fonts that
    // support integral scaling are not reported as such.  Instead, each
    // size is returned as if it were a non-scalable font.

        if ( (pdo.ulTechnology() == DT_RASPRINTER) &&
             !(pdo.flTextCaps() & TC_SA_CONTIN) &&
             ifio.bContinuousScaling() )
        {
            pefdw->flType |= ENUMFONT_SCALE_HACK;
        }
    }

    return cjEfdw;
}

/******************************Public*Routine******************************\
*
* SIZE_T cjOTMASize
*
* Similar to cjOTMW, except that 0 is returned if any of the
* bAnsiSize calls fail to compute the length of the hypothetic ansi string.
* pcjowmw is always returned valid
*
* This routine is very general and it should also work for DBCS case.
* Possible optmization:
*  verify that bAnsiSize checks for DBCS and if not DBCS, immediately
*  returns cjUni/2 [bodind]
*
* History:
*  20-Feb-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define bAnsiSize(a,b,c) (NT_SUCCESS(RtlUnicodeToMultiByteSize((a),(b),(c))))


UINT   cjOTMAWSize (
    PIFIMETRICS  pifi,        // compute size of OTM produced by this buffer
    UINT        *pcjotmw
    )
{
    IFIOBJ ifio(pifi);
    ULONG  cjUni, cjAnsi, cjotma;

    BOOL bTmp = TRUE;

// + 4 for terminating zeros

    cjotma   =  sizeof(OUTLINETEXTMETRICA) + 4;
    *pcjotmw = ALIGN4(sizeof(OUTLINETEXTMETRICW)) + 4*sizeof(WCHAR);

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszFamilyName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszFamilyName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszFaceName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszFaceName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszStyleName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszStyleName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszUniqueName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszUniqueName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

// if any of bAnsiSize calls failed, return zero

    if (!bTmp)
    {
        cjotma = 0;
    }
    return (UINT)cjotma;
}





/******************************Public*Routine******************************\
* cjIFIMetricsToOTM
*
* Converts an IFIMETRICS structure into an OUTLINETEXTMETRICW structure.
* If input buffer size is greater than the offset of the first string
* pointer, it is assumed that ALL the strings are to be copied and that
* the buffer is big enough.
*
* While the OUTLINETEXTMETRICW structure is supposed to contain pointers
* to the strings, this function treats those fields as PTRDIFFs.  The caller
* is responsible for fixing up the structure to contain pointers.  This
* is intended to support copying this structure directly across the client-
* server interface.
*
* Size (including strings) can be computed by calling cjOTMSize.
*
* Note: the beginning of the first string is DWORD aligned immediately
*       following the OUTLINETEXTMETRICW structure in the buffer, but
*       subsequent strings are only WORD aligned.
*
* Warning: this function does not check to see if the buffer size is
*          big enough.  It is ASSUMED, so must be guaranteed by the
*          calling function.
*
* Returns:
*   Size of data copied (in bytes), 0 if an error occurred.
*
*  Wed 27-Jan-1993 -by- Bodin Dresevic [BodinD]
* update: added tmd.ch ... stuff
*
* History:
*  21-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONGSIZE_T cjIFIMetricsToOTMW(
    TMDIFF                  *ptmd,
    OUTLINETEXTMETRICW      *potmw,
    RFONTOBJ                 &rfo,       // need to convert TEXTMETRICS
    DCOBJ                    &dco,       // need to convert TEXTMETRICS
    PIFIMETRICS              pifi,       // input buffer
    BOOL                     bStrings    // copy strings too
    )
{
    ULONGSIZE_T cjRet = 0;
    IFIOBJR ifio(pifi, rfo, dco);

// Do conversion to fill in TEXTMETRICW field.

    if (!bIFIMetricsToTextMetricWStrict(rfo,dco,&potmw->otmTextMetrics,pifi))
    {
        WARNING("gdisrv!cjIFIMetricsToOTM(): error converting to TEXTMETRIC\n");
        return (cjRet);
    }

    ptmd->chFirst    = pifi->chFirstChar  ;
    ptmd->chLast     = pifi->chLastChar   ;
    ptmd->chDefault  = pifi->chDefaultChar;
    ptmd->chBreak    = pifi->chBreakChar  ;

// If not identity transform, do the transform.

    if ( !rfo.bNtoWIdentity() )
    {
        EFLOAT efBaseline;
        EFLOAT efAscender;

        efBaseline = rfo.efNtoWScaleBaseline(); // cache locally
        efAscender = rfo.efNtoWScaleAscender(); // cache locally

    //
    // CharSlopeRise & CharSlopeRun
    //
        if (efBaseline == efAscender)
        {
        //
        // if the scaling is isotropic then we can use the notional
        // space values of the rise and run
        //
            potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
            potmw->otmsCharSlopeRun  = (int) ifio.pptlCaret()->x;
        }
        else
        {
            if (efAscender.bIsZero())
            {
                RIP("GDI32!cjIFIMetricsToOTMW -- zero efAscender");
                potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
                potmw->otmsCharSlopeRun  = (int) ifio.pptlCaret()->x;
            }
            else
            {
                EFLOAT efTemp = efBaseline;
                efTemp.eqDiv(efBaseline,efAscender);
                potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
                potmw->otmsCharSlopeRun  = (int) lCvt(efTemp, ifio.pptlCaret()->x);

            }
        }

        potmw->otmEMSquare = (UINT) ifio.fwdUnitsPerEm();

        potmw->otmAscent  = (int) lCvt(efAscender, (LONG) ifio.fwdTypoAscender());
        potmw->otmDescent = (int)  lCvt(efAscender, (LONG) ifio.fwdTypoDescender());
        potmw->otmLineGap = (UINT)  lCvt(efAscender, (LONG) ifio.fwdTypoLineGap());

        potmw->otmrcFontBox.top    = (int)lCvt(efAscender, ifio.prclFontBox()->top);
        potmw->otmrcFontBox.left   = (int)lCvt(efBaseline, ifio.prclFontBox()->left);
        potmw->otmrcFontBox.bottom = (int)lCvt(efAscender, ifio.prclFontBox()->bottom);
        potmw->otmrcFontBox.right  = (int)lCvt(efBaseline, ifio.prclFontBox()->right);

        potmw->otmMacAscent = (UINT) lCvt(efAscender, (LONG) ifio.fwdMacAscender());
        potmw->otmMacDescent = (int) lCvt(efAscender, (LONG) ifio.fwdMacDescender());
        potmw->otmMacLineGap = (int) lCvt(efAscender, (LONG) ifio.fwdMacLineGap());

        potmw->otmptSubscriptSize.x   = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXSize());
        potmw->otmptSubscriptSize.y   = lCvt(efAscender, (LONG) ifio.fwdSubscriptYSize());
        potmw->otmptSubscriptOffset.x = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXOffset());
        potmw->otmptSubscriptOffset.y = lCvt(efAscender, (LONG) ifio.fwdSubscriptYOffset());

        potmw->otmptSuperscriptSize.x   = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXSize());
        potmw->otmptSuperscriptSize.y   = lCvt(efAscender, (LONG) ifio.fwdSubscriptYSize());
        potmw->otmptSuperscriptOffset.x = lCvt(efBaseline, (LONG) ifio.fwdSuperscriptXOffset());
        potmw->otmptSuperscriptOffset.y = lCvt(efAscender, (LONG) ifio.fwdSuperscriptYOffset());

        potmw->otmsStrikeoutSize     = (UINT) lCvt(efAscender, (LONG) ifio.fwdStrikeoutSize());
        potmw->otmsStrikeoutPosition = (int) lCvt(efAscender, (LONG) ifio.fwdStrikeoutPosition());

        potmw->otmsUnderscoreSize    = (UINT) lCvt(efAscender, (LONG) ifio.fwdUnderscoreSize());
        potmw->otmsUnderscorePosition = (int) lCvt(efAscender, (LONG) ifio.fwdUnderscorePosition());

        potmw->otmsXHeight     = (UINT) lCvt(efAscender, (LONG) ifio.fwdXHeight());
        potmw->otmsCapEmHeight = (UINT) lCvt(efAscender, (LONG) ifio.fwdCapHeight());
    } /* if */

// Otherwise, copy straight out of the IFIMETRICS

    else
    {
        potmw->otmsCharSlopeRise   = (int) ifio.pptlCaret()->y;
        potmw->otmsCharSlopeRun    = (int) ifio.pptlCaret()->x;

        potmw->otmEMSquare = ifio.fwdUnitsPerEm();

        potmw->otmAscent  = ifio.fwdTypoAscender();
        potmw->otmDescent = ifio.fwdTypoDescender();
        potmw->otmLineGap = (UINT)ifio.fwdTypoLineGap();

        potmw->otmrcFontBox.left    = ifio.prclFontBox()->left;
        potmw->otmrcFontBox.top     = ifio.prclFontBox()->top;
        potmw->otmrcFontBox.right   = ifio.prclFontBox()->right;
        potmw->otmrcFontBox.bottom  = ifio.prclFontBox()->bottom;

        potmw->otmMacAscent  = ifio.fwdMacAscender();
        potmw->otmMacDescent = ifio.fwdMacDescender();
        potmw->otmMacLineGap = ifio.fwdMacLineGap();

        potmw->otmptSubscriptSize.x   = ifio.fwdSubscriptXSize();
        potmw->otmptSubscriptSize.y   = ifio.fwdSubscriptYSize();
        potmw->otmptSubscriptOffset.x = ifio.fwdSubscriptXOffset();
        potmw->otmptSubscriptOffset.y = ifio.fwdSubscriptYOffset();

        potmw->otmptSuperscriptSize.x   = ifio.fwdSuperscriptXSize();
        potmw->otmptSuperscriptSize.y   = ifio.fwdSuperscriptYSize();
        potmw->otmptSuperscriptOffset.x = ifio.fwdSuperscriptXOffset();
        potmw->otmptSuperscriptOffset.y = ifio.fwdSuperscriptYOffset();

        potmw->otmsStrikeoutSize     = ifio.fwdStrikeoutSize();
        potmw->otmsStrikeoutPosition = ifio.fwdStrikeoutPosition();

        potmw->otmsUnderscoreSize     = ifio.fwdUnderscoreSize();
        potmw->otmsUnderscorePosition = ifio.fwdUnderscorePosition();

        potmw->otmsXHeight     = ifio.fwdXHeight();
        potmw->otmsCapEmHeight = ifio.fwdCapHeight();

    } /* else */

// Set the italic angle.  This is in tenths of a degree.

    potmw->otmItalicAngle = ifio.lItalicAngle();

// Calculate the Italics angle.  This is measured CCW from "vertical up"
// in tenths of degrees.  It can be determined from the otmCharSlopeRise
// and the otmCharSlopeRun.

    if
    (
        potmw->otmItalicAngle==0 &&
        !(ifio.pptlCaret()->y > 0 && ifio.pptlCaret()->x == 0)
    )
    {

        EFLOAT efltTheta;
        LONG lDummy;
        EFLOATEXT efX(ifio.pptlCaret()->y);
        EFLOATEXT efY(-ifio.pptlCaret()->x);
        vArctan(efX,efY,efltTheta,lDummy);

    // this way of rounding is less precise than first multiplying efltTheta
    // by 10 and then doing conversion to LONG, but this is win31 precission.
    // They could have as well returned this in degrees rather than in
    // tenths of degrees [bodind]

        potmw->otmItalicAngle = (LONG)lCvt(efltTheta,(LONG)10);

    // convert [0,360) angles to (-180,180] to be consistent with win31

        if (potmw->otmItalicAngle > 1800)
            potmw->otmItalicAngle -= 3600;
    }


// The rest of these do not require transformation of IFIMETRICS info.

    UINT cjotma = cjOTMAWSize(pifi,&potmw->otmSize);

    potmw->otmPanoseNumber  = *ifio.pPanose();
    potmw->otmfsSelection   = ifio.fsSimSelection();
    potmw->otmfsType        = ifio.fsType();

    potmw->otmusMinimumPPEM = ifio.fwdLowestPPEm();

// set offsets to stings to zero if string are not needed

    if (!bStrings)
    {
        potmw->otmpFamilyName = (PSTR) NULL;
        potmw->otmpFaceName   = (PSTR) NULL;
        potmw->otmpStyleName  = (PSTR) NULL;
        potmw->otmpFullName   = (PSTR) NULL;
    }
    else // strings are required
    {
    // This pointer is where we will write the strings.

        PWSZ pwsz = (PWSZ) ((PBYTE) potmw + ALIGN4(sizeof(OUTLINETEXTMETRICW)));

    // Set up pointer as a PTRDIFF, copy the family name.

        potmw->otmpFamilyName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszFamilyName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the face name.

        potmw->otmpFaceName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszFaceName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the style name.

        potmw->otmpStyleName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszStyleName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the full name.

        potmw->otmpFullName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszUniqueName());

    // Return length (with strings) This was conveniently cached
    // away in otmSize.

        return(potmw->otmSize);
    }

// Return length (with or without strings) This was conveniently cached
// away in otmSize.

    return sizeof(OUTLINETEXTMETRICW);

}





/******************************Public*Routine******************************\
* BOOL bIFIMetricsToLogFont (
*     PLOGFONT        plf,
*     PIFIMETRICS     pifi
*     )
*
* Fill a LOGFONT structure using the information in a IFIMETRICS structure.
* Units are in NOTIONAL units since font is not realized.
* Called only by control panel private api's.
*
* History:
*  02-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vIFIMetricsToLogFontW (
    PLOGFONTW       plf,
    PIFIMETRICS     pifi
    )
{
    IFIOBJ ifio(pifi);

//     We will override this with a hack here so that all heights are fixed
//     at 24 pels.  This will work because this is the routine that builds
//     the LOGFONTs for GetFontResourceInfo.
//
//     No function other than GetFontResourceInfo should call this function
//     or this hack will screw them over.

// If scalable font, set the em height to 24 pel.

    if (ifio.bContinuousScaling())
    {
        plf->lfHeight = -24;
        plf->lfWidth  = 0;  // don't care, it will be automatically set proportionally
    }

// Its a bitmap font, so Notional units are OK.

    else
    {
        plf->lfHeight = ifio.lfHeight();
        plf->lfWidth  = ifio.lfWidth();
    }

    plf->lfWeight         = ifio.lfWeight();
    plf->lfItalic         = ifio.lfItalic();
    plf->lfUnderline      = ifio.lfUnderline();
    plf->lfStrikeOut      = ifio.lfStrikeOut();
    plf->lfEscapement     = ifio.lfEscapement();
    plf->lfOrientation    = ifio.lfOrientation();

// to ensure round trip:
//  font file name ->
//  logfont returned by GetFontResourceInfoW ->
//     back to the font that lives in this font file

    if (pifi->dpCharSets)
    {
    BYTE *ajCharsets = (BYTE *)pifi + pifi->dpCharSets;
    plf->lfCharSet  = ajCharsets[0]; // guarantees round trip
    }
    else
    {
    plf->lfCharSet  = pifi->jWinCharSet;
    }

    plf->lfOutPrecision   = ifio.lfOutPrecision();
    plf->lfClipPrecision  = ifio.lfClipPrecision();
    plf->lfQuality        = ifio.lfQuality();
    plf->lfPitchAndFamily = ifio.lfPitchAndFamily();

    memcpy( (VOID*) plf->lfFaceName,
            (VOID*) ifio.pwszFamilyName(), LF_FACESIZE * sizeof(WCHAR) );

}



/******************************Public*Routine******************************\
*
* cjIFIMetricsToETM
*
* History:
*  19-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vIFIMetricsToETM(
    EXTTEXTMETRIC    *petm,
    RFONTOBJ&         rfo,
    DCOBJ&            dco,
    IFIMETRICS       *pifi
    )
{

    LONG   lHeight;

    IFIOBJR ifio(pifi, rfo, dco);
    // IFIOBJ  ifio(pifi);

    petm->etmSize = sizeof(EXTTEXTMETRIC);

// Windows returns everything in notional units except for etmPointSize
// which is the size in points of the realization in the DC at the time
// Aldus Escap is called so we do that here.

// First get the Em height in device units

    lHeight = LONG_FLOOR_OF_FIX(rfo.fxMaxExtent() + FIX_HALF);

// now get internal leading:

    if (!ifio.bContinuousScaling())
    {
        lHeight -= (LONG)ifio.tmInternalLeading();
    }
    else
    {
        if (rfo.lNonLinearIntLeading() == MINLONG)
        {
        // Set up transform.

            MATRIX      mx;
            EXFORMOBJ   xo(&mx, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX);
            ASSERTGDI(xo.bValid(), "GreGetETM, xform\n");

            rfo.vSetNotionalToDevice(xo);

            POINTL  ptlHt;
            ptlHt.x = 0;
            ptlHt.y = ifio.fwdUnitsPerEm();
            EVECTORFL evtflHt(ptlHt.x,ptlHt.y);

            xo.bXform(evtflHt);
            EFLOAT  ef;
            ef.eqLength(*(POINTFL *) &evtflHt);

            lHeight = lCvt(ef,1);
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            lHeight -= rfo.lNonLinearIntLeading();
        }
    }

    PDEVOBJ po(dco.hdev());
    ASSERTGDI(po.bValid(), "Invalid PDEV");

    //
    // Next convert to points
    //

    {
        LONG lDenom = (LONG) po.ulLogPixelsY();
        LONGLONG ll = (LONGLONG) lHeight;

        ll = ll * 72 + (LONGLONG) (lDenom / 2);
        if (ll > LONG_MAX)
        {
            lHeight = (LONG) (ll / (LONGLONG) lDenom);
        }
        else
        {
            lHeight = ((LONG) ll) / lDenom;
        }
    }

    //
    // The following line of code is forced upon us by the
    // principle that it is better to be Win 3.1 compatible
    // that it is to be correct
    //

    petm->etmPointSize            = 20 *  (SHORT) lHeight;  // convert to twips
    petm->etmOrientation          = 0  ;
    petm->etmMasterHeight         = ifio.fwdUnitsPerEm();
    petm->etmMinScale             = ifio.fwdLowestPPEm();
    petm->etmMaxScale             = 0x4000;
    petm->etmMasterUnits          = ifio.fwdUnitsPerEm();
    petm->etmCapHeight            = ifio.fwdTypoAscender();
    petm->etmXHeight              = ifio.fwdXHeight();
    petm->etmLowerCaseAscent      = ifio.fwdTypoAscender();
    petm->etmLowerCaseDescent     = - ifio.fwdTypoDescender();
    petm->etmSlant                = (UINT)(- (INT) ifio.lItalicAngle());
    petm->etmSuperScript          = (SHORT) ifio.fwdSuperscriptYOffset();
    petm->etmSubScript            = (SHORT) ifio.fwdSubscriptYOffset();
    petm->etmSuperScriptSize      = (SHORT) ifio.fwdSuperscriptYSize();
    petm->etmSubScriptSize        = (SHORT) ifio.fwdSubscriptYSize();
    petm->etmUnderlineOffset      = (SHORT) ifio.fwdUnderscorePosition();
    petm->etmUnderlineWidth       = (SHORT) ifio.fwdUnderscoreSize();
    petm->etmDoubleUpperUnderlineOffset =
                                  ifio.fwdUnderscorePosition() >> 1;
    petm->etmDoubleLowerUnderlineOffset =
                                  (SHORT)(ifio.fwdUnderscorePosition());
    petm->etmDoubleUpperUnderlineWidth =
        petm->etmDoubleLowerUnderlineWidth =
                                  ifio.fwdUnderscoreSize() >> 1;
    petm->etmStrikeOutOffset      = (SHORT)(ifio.fwdStrikeoutPosition());
    petm->etmStrikeOutWidth       = (SHORT)(ifio.fwdStrikeoutSize());
    petm->etmNKernPairs           = (WORD) pifi->cKerningPairs;
    petm->etmNKernTracks          = 0;

}


/********************************************************************************
 * GreNameEscape(LPWSTR, int, int, LPSTR, int, LPSTR)
 *
 * Named escape functionality for installable font drivers.
 *
 * This function allows an escape to be sent to a font driver.
 *
 * History
 *  3-5-95 16:00:54 by Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ********************************************************************************/

INT
GreNamedEscape(
    LPWSTR pDriver, //  Identifies the file name of the font driver
    int iEscape,    //  Specifies the escape function to be performed.
    int cjIn,       //  Number of bytes of data pointed to by pvIn.
    LPSTR pvIn,     //  Points to the input data.
    int cjOut,      //  Number of bytes of data pointed to by pvOut.
    LPSTR pvOut     //  Points to the structure to receive output.
)
{
    GDIFunctionID(GreNamedEscape);

    WCHAR PathBuffer[MAX_PATH];

    UNICODE_STRING usDriverPath;

    usDriverPath.Length = 0;
    usDriverPath.MaximumLength = MAX_PATH * sizeof(WCHAR);
    usDriverPath.Buffer = PathBuffer;

    RtlAppendUnicodeToString(&usDriverPath,L"\\SystemRoot\\System32\\");
    RtlAppendUnicodeToString(&usDriverPath,pDriver);

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    PPDEV ppDevList = gppdevList;

    do
    {
        PDEVOBJ pdo((HDEV)ppDevList);

    // first find the driver, make sure the paths match and the
    // driver is really a font driver (that way no one can make
    // a DrvEscape call with a NULL surface to printer driver)

        if (pdo.ppdev->fl & PDEV_FONTDRIVER)
        {
            if ((ppDevList == gppdevATMFD && !_wcsicmp(pDriver, L"atmfd.dll")) ||
                pdo.MatchingLDEVImage(usDriverPath))
            {
                if (PPFNVALID(pdo, Escape))
                {
                // dont make the call while holding the semaphore
        
                    GreReleaseSemaphoreEx(ghsemDriverMgmt);
        
                    return( pdo.Escape)( NULL, (ULONG)iEscape, (ULONG)cjIn, pvIn, (ULONG)cjOut, pvOut );
                }
            }
        }

    } while(ppDevList = ppDevList->ppdevNext);

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\greold.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-1999 Microsoft Corporation

Module Name:

    wingdi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/

#define CBM_CREATEDIB   0x02L   /* create DIB bitmap */
#define DMDUP_LAST      DMDUP_HORIZONTAL
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE
#define DMMEDIA_LAST          DMMEDIA_GLOSSY
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

typedef ULONG   COUNT;

// Old fields that Chicago won't support that we can't publically
// support anymore

#define HS_SOLIDCLR         6
#define HS_DITHEREDCLR      7
#define HS_SOLIDTEXTCLR     8
#define HS_DITHEREDTEXTCLR  9
#define HS_SOLIDBKCLR       10
#define HS_DITHEREDBKCLR    11
#define HS_API_MAX          12

#define DIB_PAL_INDICES     2 /* No color table indices into surf palette */

// End of stuff we yanked for Chicago compatability

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

#define ERROR_BOOL  (BOOL) -1L

#include <winddi.h>


/*********************************Struct***********************************\
* struct ENUMFONTDATA
*
* Information for the callback function used by EnumFonts.
*
*   lf      LOGFONT structure corresponding to one of the enumerated fonts.
*
*   tm      The corresponding TEXTMETRIC structure for the LOGFONT above.
*
*   flType  Flags are set as follows:
*
*               DEVICE_FONTTYPE is set if font is device-based (as
*               opposed to IFI-based).
*
*               RASTER_FONTTYPE is set if font is bitmap type.
*
* History:
*  21-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


#if defined(JAPAN)
#define NATIVE_CHARSET        SHIFTJIS_CHARSET
#define NATIVE_CODEPAGE       932
#define NATIVE_LANGUAGE_ID    411
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(KOREA)
#define NATIVE_CHARSET        HANGEUL_CHARSET
#define NATIVE_CODEPAGE       949
#define NATIVE_LANGUAGE_ID    412
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(TAIWAN)
#define NATIVE_CHARSET        CHINESEBIG5_CHARSET
#define NATIVE_CODEPAGE       950
#define NATIVE_LANGUAGE_ID    404
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(PRC)
#define NATIVE_CHARSET        GB2312_CHARSET
#define NATIVE_CODEPAGE       936
#define NATIVE_LANGUAGE_ID    804
#define DBCS_CHARSET          NATIVE_CHARSET
#endif

#if defined(DBCS)
#define IS_DBCS_CHARSET( CharSet )     ( ((CharSet) == DBCS_CHARSET) ? TRUE : FALSE )
#define IS_ANY_DBCS_CHARSET( CharSet ) ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                                         ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                                         ((CharSet) == JOHAB_CHARSET)       ? TRUE :    \
                                         ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                                         ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )

#define IS_DBCS_CODEPAGE( CodePage )     (((CodePage) == NATIVE_CODEPAGE) ? TRUE : FALSE )
#define IS_ANY_DBCS_CODEPAGE( CodePage ) (((CodePage) == 932) ? TRUE :    \
                                          ((CodePage) == 949) ? TRUE :    \
                                          ((CodePage) == 1361) ? TRUE :    \
                                          ((CodePage) == 950) ? TRUE :    \
                                          ((CodePage) == 936) ? TRUE : FALSE )
#endif // DBCS



/*********************************Struct***********************************\
* struct ENUMFONTDATAW
*
* Information for the callback function used by EnumFontsW
*
*   lfw     LOGFONTW structure corresponding to one of the enumerated fonts.
*
*   tmw     The corresponding TEXTMETRICW structure for the LOGFONTW above.
*
*   flType  Flags are set as follows:
*
*               DEVICE_FONTTYPE is set if font is device-based (as
*               opposed to IFI-based).
*
*               RASTER_FONTTYPE is set if font is bitmap type.
*
* History:
*  Wed 04-Sep-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



//
// Function prototypes
//

BOOL  bDeleteSurface(HSURF hsurf);
BOOL  bSetBitmapOwner(HBITMAP hbm,LONG lPid);
BOOL  bSetBrushOwner(HBRUSH hbr,LONG lPid);
BOOL  bSetPaletteOwner(HPALETTE hpal, LONG lPid);
BOOL  bSetLFONTOwner(HFONT hlfnt, LONG pid);

BOOL  bDeleteRegion(HRGN hrgn);
BOOL  bSetRegionOwner(HRGN hrgn,LONG lPid);
LONG iCombineRectRgn(HRGN hrgnTrg,HRGN hrgnSrc,PRECTL prcl,LONG iMode);

BOOL bGetFontPathName
(
LPWSTR *ppwszPathName,     // place to store the result, full path of the font file
PWCHAR awcPathName,         // ptr to the buffer on the stack, must be MAX_PATH in length
LPWSTR pwszFileName         // file name, possibly  bare name that has to be tacked onto the path
);

BOOL UserGetHwnd(HDC hdc, HWND *phwnd, PVOID *ppwo, BOOL bCheckStyle);
VOID UserAssociateHwnd(HWND hwnd, PVOID pwo);



// private flags in low bits of hdc returned from GreCreateDCW

#define GRE_DISPLAYDC   1
#define GRE_PRINTERDC   2
#define GRE_OWNDC 1


HDC hdcCloneDC(HDC hdc,ULONG iType);

BOOL  bSetDCOwner(HDC hdc,LONG lPid);
DWORD sidGetObjectOwner(HDC hdc, DWORD objType);
BOOL  bSetupDC(HDC hdc,FLONG fl);

#define SETUPDC_CLEANDC         0x00000040
#define SETUPDC_RESERVE         0x00000080

BOOL APIENTRY GreConsoleTextOut
(
  HDC        hdc,
  POLYTEXTW *lpto,
  UINT       nStrings,
  RECTL     *prclBounds
);

#define UTO_NOCLIP 0x0001

// Server entry point for font enumeration.

// Sundown: change from ULONG to ULONG_PTR in places used as handles/pointers
ULONG_PTR APIENTRY ulEnumFontOpen(
    HDC hdc,                    // device to enumerate on
    BOOL bEnumFonts,            // flag indicates old style EnumFonts()
    FLONG flWin31Compat,        // Win3.1 compatibility flags
    COUNT cwchMax,              // maximum name length (for paranoid CSR code)
    LPWSTR pwszName);           // font name to enumerate

BOOL APIENTRY bEnumFontChunk(
    HDC             hdc,        // device to enumerate on
    ULONG_PTR        idEnum,
    COUNT           cefdw,      // (in) capacity of buffer
    COUNT           *pcefdw,    // (out) number of ENUMFONTDATAs returned
    PENUMFONTDATAW  pefdw);     // return buffer

BOOL APIENTRY bEnumFontClose(
    ULONG_PTR   idEnum);            // enumeration id

// Server entry points for adding/removing font resources.

BOOL APIENTRY bUnloadFont(
    LPWSTR   pwszPathname,
    ULONG    iResource);


// Private Control Panel entry point to configure font enumeration.

BOOL  APIENTRY GreArc(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreArcTo(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreChord(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreEllipse(HDC,int,int,int,int);
ULONG APIENTRY GreEnumObjects(HDC, int, ULONG, PVOID);
BOOL  APIENTRY GreExtFloodFill(HDC,int,int,COLORREF,UINT);
BOOL  APIENTRY GreFillRgn(HDC,HRGN,HBRUSH);
BOOL  APIENTRY GreFloodFill(HDC,int,int,COLORREF);
BOOL  APIENTRY GreFrameRgn(HDC,HRGN,HBRUSH,int,int);
BOOL  APIENTRY GreMaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD,DWORD);
BOOL  APIENTRY GrePlgBlt(HDC,LPPOINT,HDC,int,int,int,int,HBITMAP,int,int,DWORD);
BOOL  APIENTRY GrePie(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GrePaintRgn(HDC,HRGN);
BOOL  APIENTRY GreRectangle(HDC,int,int,int,int);
BOOL  APIENTRY GreRoundRect(HDC,int,int,int,int,int,int);
BOOL  APIENTRY GreAngleArc(HDC,int,int,DWORD,FLOATL,FLOATL);
BOOL  APIENTRY GrePlayJournal(HDC,LPWSTR,ULONG,ULONG);
BOOL  APIENTRY GrePolyPolygon(HDC,LPPOINT,LPINT,int);
BOOL  APIENTRY GrePolyPolyline(HDC, CONST POINT *,LPDWORD,DWORD);

BOOL  APIENTRY GrePolyPatBlt(HDC,DWORD,PPOLYPATBLT,DWORD,DWORD);

BOOL  APIENTRY GrePolyBezierTo(HDC,LPPOINT,DWORD);
BOOL  APIENTRY GrePolylineTo(HDC,LPPOINT,DWORD);
BOOL  APIENTRY GreGetTextExtentExW (HDC, LPWSTR, COUNT, ULONG, COUNT *, PULONG, LPSIZE, FLONG);


int   APIENTRY GreGetTextFaceW(HDC,int,LPWSTR, BOOL);

#define ETO_MASKPUBLIC  ( ETO_OPAQUE | ETO_CLIPPED )    // public (wingdi.h) flag mask

BOOL  APIENTRY GrePolyTextOutW(HDC, POLYTEXTW *, UINT, DWORD);

BOOL  APIENTRY GreSetAttrs(HDC hdc);
BOOL  APIENTRY GreSetFontXform(HDC,FLOATL,FLOATL);

BOOL  APIENTRY GreBeginPath(HDC);
BOOL  APIENTRY GreCloseFigure(HDC);
BOOL  APIENTRY GreEndPath(HDC);
BOOL  APIENTRY GreAbortPath(HDC);
BOOL  APIENTRY GreFillPath(HDC);
BOOL  APIENTRY GreFlattenPath(HDC);
HRGN  APIENTRY GrePathToRegion(HDC);
BOOL  APIENTRY GrePolyDraw(HDC,LPPOINT,LPBYTE,ULONG);
BOOL  APIENTRY GreSelectClipPath(HDC,int);
int   APIENTRY GreSetArcDirection(HDC,int);
int   APIENTRY GreGetArcDirection(HDC);
BOOL  APIENTRY GreSetMiterLimit(HDC,FLOATL,FLOATL *);
BOOL  APIENTRY GreGetMiterLimit(HDC,FLOATL *);
BOOL  APIENTRY GreStrokeAndFillPath(HDC);
BOOL  APIENTRY GreStrokePath(HDC);
BOOL  APIENTRY GreWidenPath(HDC);

BOOL     APIENTRY GreAnimatePalette(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
BOOL     APIENTRY GreAspectRatioFilter(HDC, LPSIZE);
BOOL     APIENTRY GreCancelDC(HDC);
int      APIENTRY GreChoosePixelFormat(HDC, UINT, CONST PIXELFORMATDESCRIPTOR *);
BOOL     APIENTRY GreCombineTransform(XFORML *, XFORML *, XFORML *);

HDC      APIENTRY GreCreateDCW(LPWSTR, LPWSTR, LPWSTR, LPDEVMODEW, BOOL);
HBRUSH   APIENTRY GreCreateDIBPatternBrush(HGLOBAL, DWORD);
HBRUSH   APIENTRY GreCreateDIBPatternBrushPt(LPVOID, DWORD);
HBITMAP  APIENTRY GreCreateDIBitmap(HDC, LPBITMAPINFOHEADER, DWORD, LPBYTE, LPBITMAPINFO, DWORD);
HRGN     APIENTRY GreCreateEllipticRgn(int, int, int, int);


HBRUSH   APIENTRY GreCreateHatchBrush(ULONG, COLORREF);
HPEN     APIENTRY GreCreatePen(int, int, COLORREF,HBRUSH);
HPEN     APIENTRY GreExtCreatePen(ULONG, ULONG, ULONG, ULONG, ULONG_PTR, ULONG_PTR, ULONG, PULONG, ULONG, BOOL, HBRUSH);
HPEN     APIENTRY GreCreatePenIndirect(LPLOGPEN);
HRGN     APIENTRY GreCreatePolyPolygonRgn(CONST POINT *, CONST INT *, int, int);
HRGN     APIENTRY GreCreatePolygonRgn(CONST POINT *, int, int);
HRGN     APIENTRY GreCreateRoundRectRgn(int, int, int, int, int, int);
BOOL     APIENTRY GreCreateScalableFontResourceW(FLONG, LPWSTR, LPWSTR, LPWSTR);

int      APIENTRY GreDescribePixelFormat(HDC hdc,int ipfd,UINT cjpfd,PPIXELFORMATDESCRIPTOR ppfd);

int      APIENTRY GreDeviceCapabilities(LPSTR, LPSTR, LPSTR, int, LPSTR, LPDEVMODE);
int      APIENTRY GreDrawEscape(HDC,int,int,LPSTR);
BOOL     APIENTRY GreEqualRgn(HRGN, HRGN);
int      APIENTRY GreExtEscape(HDC,int,int,LPSTR,int,LPSTR);
BOOL     APIENTRY GreGetAspectRatioFilter(HDC, LPSIZE);
BOOL     APIENTRY GreGetBitmapDimension(HBITMAP, LPSIZE);
int      APIENTRY GreGetBkMode(HDC);
DWORD    APIENTRY GreGetBoundsRect(HDC, LPRECT, DWORD);
BOOL     APIENTRY GreGetCharWidthW(HDC hdc, UINT wcFirstChar, UINT cwc, PWCHAR pwc, FLONG fl, PVOID lpBuffer);
BOOL     APIENTRY GreFontIsLinked(HDC hdc);

BOOL     APIENTRY GreGetCharABCWidthsW(
            HDC,           // hdc
            UINT,          // wcFirst
            COUNT,         // cwc
            PWCHAR,        // pwc to buffer with chars to convert
            FLONG,         //
            PVOID);        // abc or abcf

BOOL     APIENTRY GreGetCharWidthInfo(HDC hdc,  PCHWIDTHINFO pChWidthInfo);

int      APIENTRY GreGetAppClipBox(HDC, LPRECT);
BOOL     APIENTRY GreGetCurrentPosition(HDC, LPPOINT);
int      APIENTRY GreGetGraphicsMode(HDC hdc);
COLORREF APIENTRY GreGetNearestColor(HDC, COLORREF);
UINT     APIENTRY GreGetNearestPaletteIndex(HPALETTE, COLORREF);


UINT     APIENTRY GreGetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY);
DWORD    APIENTRY GreGetPixel(HDC, int, int);
int      APIENTRY GreGetPixelFormat(HDC);
UINT     APIENTRY GreGetTextAlign(HDC);
BOOL     APIENTRY GreGetWorldTransform(HDC, XFORML *);
BOOL     APIENTRY GreGetTransform(HDC, DWORD, XFORML *);
BOOL     APIENTRY GreSetVirtualResolution(HDC, int, int, int, int);
HRGN     APIENTRY GreInquireRgn(HDC hdc);
BOOL     APIENTRY GreInvertRgn(HDC, HRGN);
BOOL     APIENTRY GreModifyWorldTransform(HDC ,XFORML *, DWORD);
BOOL     APIENTRY GreMoveTo(HDC, int, int, LPPOINT);
int      APIENTRY GreOffsetClipRgn(HDC, int, int);
BOOL     APIENTRY GreOffsetViewportOrg(HDC, int, int, LPPOINT);
BOOL     APIENTRY GreOffsetWindowOrg(HDC, int, int, LPPOINT);
BOOL     APIENTRY GrePolyBezier (HDC, LPPOINT, ULONG);
BOOL     APIENTRY GrePtVisible(HDC, int, int);
BOOL     APIENTRY GreRectVisible(HDC, LPRECT);

BOOL     APIENTRY GreResetDC(HDC, LPDEVMODEW);
BOOL     APIENTRY GreResizePalette(HPALETTE, UINT);
BOOL     APIENTRY GreScaleViewportExt(HDC, int, int, int, int, LPSIZE);
BOOL     APIENTRY GreScaleWindowExt(HDC, int, int, int, int, LPSIZE);
HPALETTE APIENTRY LockCSSelectPalette(HDC, HPALETTE, BOOL);

HPEN     APIENTRY GreSelectPen(HDC,HPEN);
LONG     APIENTRY GreSetBitmapBits(HBITMAP, ULONG, PBYTE, PLONG);
BOOL     APIENTRY GreSetBitmapDimension(HBITMAP, int, int, LPSIZE);
DWORD    APIENTRY GreSetBoundsRect(HDC, LPRECT, DWORD);
UINT     APIENTRY GreSetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
int      APIENTRY GreSetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int, int, DWORD, DWORD, LPBYTE, LPBITMAPINFO, DWORD);
int      APIENTRY GreSetGraphicsMode(HDC hdc, int iMode);
int      APIENTRY GreSetMapMode(HDC, int);
DWORD    APIENTRY GreSetMapperFlags(HDC, DWORD);
UINT     APIENTRY GreSetPaletteEntries(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
COLORREF APIENTRY GreSetPixel(HDC, int, int, COLORREF);
BOOL     APIENTRY GreSetPixelV(HDC, int, int, COLORREF);
BOOL     APIENTRY GreSetPixelFormat(HDC, int);
BOOL     APIENTRY GreSetRectRgn(HRGN, int, int, int, int);
UINT     APIENTRY GreSetSystemPaletteUse(HDC, UINT);
UINT     APIENTRY GreSetTextAlign(HDC, UINT);
HPALETTE APIENTRY GreCreateHalftonePalette(HDC hdc);
HPALETTE APIENTRY GreCreateCompatibleHalftonePalette(HDC hdc);
BOOL     APIENTRY GreSetTextJustification(HDC, int, int);
BOOL     APIENTRY GreSetViewportExt(HDC, int, int, LPSIZE);
BOOL     APIENTRY GreSetWindowExt(HDC, int, int, LPSIZE);
BOOL     APIENTRY GreSetWorldTransform(HDC, XFORML *);
int      APIENTRY GreStretchDIBits(HDC, int, int, int, int, int, int, int, int, LPBYTE, LPBITMAPINFO, DWORD, DWORD);
BOOL     APIENTRY GreSystemFontSelected(HDC, BOOL);
BOOL     APIENTRY GreSwapBuffers(HDC hdc);
BOOL     APIENTRY GreUnrealizeObject(HANDLE);
BOOL     APIENTRY GreUpdateColors(HDC);

// Prototypes for wgl and OpenGL calls

HGLRC    APIENTRY GreCreateRC(HDC);
BOOL     APIENTRY GreMakeCurrent(HDC, HGLRC);
BOOL     APIENTRY GreDeleteRC(HGLRC);
BOOL     APIENTRY GreSwapBuffers(HDC);
BOOL     APIENTRY GreGlAttention(VOID);
BOOL     APIENTRY GreShareLists(HGLRC, HGLRC);
BOOL     APIENTRY glsrvDuplicateSection(ULONG, HANDLE);
void     APIENTRY glsrvThreadExit(void);
BOOL     bSetRCOwner(HGLRC hglrc,LONG lPid);


// these should disappear as should all other functions that contain references
// to ansi strings

BOOL  APIENTRY GreGetTextExtent(HDC,LPSTR,int,LPSIZE,UINT);
BOOL  APIENTRY GreExtTextOut(HDC,int,int,UINT,LPRECT,LPSTR,int,LPINT);
BOOL  APIENTRY GreTextOut(HDC,int,int,LPSTR,int);

// these stay

VOID vGetFontList(VOID *pvBuffer, COUNT *pNumFonts, UINT *pSize);
BOOL  GreMatchFont(LPWSTR pwszBareName, LPWSTR pwszFontPathName);

// used in clean up at log-off time




// these are for font linking

ULONG GreEudcQuerySystemLinkW(LPWSTR,COUNT);
BOOL  GreEudcUnloadLinkW(LPWSTR,COUNT,LPWSTR,COUNT);
BOOL  GreEudcLoadLinkW(LPWSTR,COUNT,LPWSTR,COUNT,INT,INT);
BOOL  GreEnableEUDC(BOOL);

// this is for font association

UINT GreGetFontAssocStatus();

BOOL     APIENTRY GreStartPage(HDC);
BOOL     APIENTRY GreEndPage(HDC);
int      APIENTRY GreStartDoc(HDC, DOCINFOW *);
BOOL     APIENTRY GreEndDoc(HDC);
BOOL     APIENTRY GreAbortDoc(HDC);

// Prototypes for GDI local helper functions.  These are only available on
// the client side.

HPALETTE    GdiConvertPalette(HPALETTE hpal);
HFONT       GdiConvertFont(HFONT hfnt);
HBRUSH      GdiConvertBrush(HBRUSH hbrush);
HDC         GdiGetLocalDC(HDC hdcRemote);
HDC         GdiCreateLocalDC(HDC hdcRemote);
BOOL        GdiReleaseLocalDC(HDC hdcLocal);
HBITMAP     GdiCreateLocalBitmap();
HBRUSH      GdiCreateLocalBrush(HBRUSH hbrushRemote);
HRGN        GdiCreateLocalRegion(HRGN hrgnRemote);
HFONT       GdiCreateLocalFont(HFONT hfntRemote);
HPALETTE    GdiCreateLocalPalette(HPALETTE hpalRemote);
ULONG       GdiAssociateObject(ULONG hLocal,ULONG hRemote);
VOID        GdiDeleteLocalObject(ULONG h);
BOOL        GdiSetAttrs(HDC);
HANDLE      SelectFontLocal(HDC, HANDLE);
HANDLE      SelectBrushLocal(HDC, HANDLE);
HFONT       GdiGetLocalFont(HFONT);
HBRUSH      GdiGetLocalBrush(HBRUSH);
HBITMAP     GdiGetLocalBitmap(HBITMAP);
HDC         GdiCloneDC(HDC hdc, UINT iType);
BOOL        GdiPlayScript(PULONG pulScript,ULONG cjScript,PULONG pulEnv,ULONG cjEnv,PULONG pulOutput,ULONG cjOutput,ULONG cLimit);
BOOL        GdiPlayDCScript(HDC hdc,PULONG pulScript,ULONG cjScript,PULONG pulOutput,ULONG cjOutput,ULONG cLimit);
BOOL        GdiIsMetaFileDC(HDC hdc);

// Return codes from server-side ResetDC

#define RESETDC_ERROR   0
#define RESETDC_FAILED  1
#define RESETDC_SUCCESS 2

// Private calls for USER

int  APIENTRY GreGetClipRgn(HDC, HRGN);
BOOL APIENTRY GreSrcBlt(HDC, int, int, int, int, int, int);
BOOL APIENTRY GreCopyBits(HDC,int,int,int,int,HDC,int,int);
VOID APIENTRY GreSetClientRgn(PVOID, HRGN, LPRECT);
ULONG APIENTRY GreSetROP2(HDC hdc,int iROP);

// Private calls for metafiling

DWORD   APIENTRY GreGetRegionData(HRGN, DWORD, LPRGNDATA);
HRGN    APIENTRY GreExtCreateRegion(XFORML *, DWORD, LPRGNDATA);
int     APIENTRY GreExtSelectMetaRgn(HDC, HRGN, int);
BOOL    APIENTRY GreMonoBitmap(HBITMAP);
HBITMAP APIENTRY GreGetObjectBitmapHandle(HBRUSH, UINT *);


typedef struct _DDALIST
{
   LONG yTop;
   LONG yBottom;
   LONG axPairs[2];
} DDALIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\helpers.cxx ===
/******************************Module*Header*******************************\
* Module Name: HELPERS.CXX                                                *
*                                                                         *
* Hydra routines                                                          *
* For Display drivers                                                     *
*                                                                         *
* Copyright (c) 1997-1999 Microsoft                                            *
\**************************************************************************/

#include "precomp.hxx"
extern "C" {

#include "pw32kevt.h"

#include <ctxdd.h>

}

#include <winDDIts.h>

#if !defined(_GDIPLUS_)

/******************************Public*Routine******************************\
* EngGetTickCount
*
* Return the system tick count
*
\**************************************************************************/


DWORD APIENTRY
EngGetTickCount()
{
    return( NtGetTickCount());
}



/******************************Public*Routine******************************\
* EngFileWrite
*
* Write to File Object
*
\**************************************************************************/

VOID APIENTRY
EngFileWrite( HANDLE hFileObject, PVOID Buffer, ULONG BufferSize, PULONG pBytesWritten )
{
    NTSTATUS Status;

    Status = CtxWriteFile( (PFILE_OBJECT)hFileObject, Buffer, BufferSize, NULL, NULL, NULL );

    if ( !NT_SUCCESS(Status) )
        *pBytesWritten = 0;
    else
        *pBytesWritten = BufferSize;
}

/******************************Public*Routine******************************\
* EngFileIoControl
*
* IoControl to File Object
*
\**************************************************************************/
DWORD
APIENTRY
EngFileIoControl(
    HANDLE hFileObject,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    Status = CtxDeviceIoControlFile(
                                     (PFILE_OBJECT)hFileObject,
                                     dwIoControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     lpOutBuffer,
                                     nOutBufferSize,
                                     FALSE,
                                     NULL,
                                     &Iosb,
                                     NULL );
    *lpBytesReturned = (DWORD) Iosb.Information;

    return Status;
}

#endif // !defined(_GDIPLUS_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\htblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: htblt.cxx
*
* Contains routine to halftone a bitmap.  This path is used when a
* StretchBlt or PlgBlt is called with StretchBltMode == HALFTONE.
*
* Created: 18-Nov-1991 16:06:47
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if ((PRIMARY_ORDER_ABC != PRIMARY_ORDER_123)             || \
     (PRIMARY_ORDER_ACB != PRIMARY_ORDER_132)             || \
     (PRIMARY_ORDER_BAC != PRIMARY_ORDER_213)             || \
     (PRIMARY_ORDER_BCA != PRIMARY_ORDER_231)             || \
     (PRIMARY_ORDER_CAB != PRIMARY_ORDER_312)             || \
     (PRIMARY_ORDER_CBA != PRIMARY_ORDER_321))
#error * PRIMARY_ORDER different in winddi.h and ht.h *
#endif

/*****************************Private*Function*****************************\
* bSetHTSrcSurfInfo
*
* Initialise the HTSURFACEINFO structure.  The structure is alloacted
* elsewhere,  we simply fill it in given the nature of the surface
* required for drawing.  Used by source surface only.
*
* History:
*  18-Nov-1991 -by- Wendy Wu [wendywu]
* Stole from gdi\printers\rasdd\stretch.c.
\**************************************************************************/

BOOL bSetHTSrcSurfInfo(
SURFOBJ         *pSurfObj,
XEPALOBJ         palSrc,
HTSURFACEINFO   *pHTSurfInfo,
XLATEOBJ        *pxlo
)
{
    COUNT cMaxPalEntries;
    BYTE  cBytesPerEntry;
    BOOL  bBitFields;

    ASSERTGDI(palSrc.bValid(),"bhtBlt: invalid src pal\n");
    bBitFields = palSrc.bIsBitfields();

    switch (pSurfObj->iBitmapFormat)
    {
    case BMF_1BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 2;
        break;

    case BMF_4BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 16;
        break;

    case BMF_8BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 256;
        break;

    case BMF_16BPP:
        cBytesPerEntry = 2;
        cMaxPalEntries = 3;
        bBitFields = TRUE;
        break;

    case BMF_24BPP:
        cBytesPerEntry = 3;
        cMaxPalEntries = 0;
        break;

    case BMF_32BPP:
        cBytesPerEntry = 4;
        cMaxPalEntries = 3;
        bBitFields = TRUE;
        break;

    default:
        WARNING("This bitmap format is not implemented");
        return(FALSE);
    }

    //
    // The halftone now taking ScanLineDelta rather than compute the scanline
    // delta by itself, because many driver fake the pvBits, pvScan0 and
    // scanline delta for creating smaller surface and that sometime cause
    // halftone to break, to do this we passed to halftone ScanLineDelta and
    // (from lDelta in SURFOBJ) and pvScan0.
    //

    HTSURFACEINFO   HTSurfInfo;

    HTSurfInfo.hSurface               = (ULONG_PTR)pSurfObj;
    HTSurfInfo.SurfaceFormat          = (BYTE)pSurfObj->iBitmapFormat;
    HTSurfInfo.ScanLineAlignBytes     = BMF_ALIGN_DWORD;
    HTSurfInfo.Width                  = pSurfObj->sizlBitmap.cx;
    HTSurfInfo.Height                 = pSurfObj->sizlBitmap.cy;
    HTSurfInfo.ScanLineDelta          = pSurfObj->lDelta;
    HTSurfInfo.pPlane                 = (LPBYTE)pSurfObj->pvScan0;

    HTSurfInfo.Flags = (USHORT)((pSurfObj->fjBitmap & BMF_TOPDOWN) ?
                                                HTSIF_SCANLINES_TOPDOWN : 0);

    COUNT cPalEntries = bBitFields ? 3 : palSrc.cEntries();

    if (cPalEntries > cMaxPalEntries)
        cPalEntries = cMaxPalEntries;

    if (HTSurfInfo.pColorTriad = (PCOLORTRIAD)PALLOCNOZ(
                    cPalEntries * sizeof(ULONG) + sizeof(COLORTRIAD),'cthG'))
    {
        PCOLORTRIAD pColorTriad = HTSurfInfo.pColorTriad;

        pColorTriad->Type = COLOR_TYPE_RGB;
        pColorTriad->pColorTable = (LPBYTE)pColorTriad + sizeof(COLORTRIAD);
        pColorTriad->PrimaryOrder = PRIMARY_ORDER_RGB;
        // May not be needed by halftoning code, but just to be sure
        pColorTriad->PrimaryValueMax = 0;

        if (palSrc.bIsBGR())
            pColorTriad->PrimaryOrder = PRIMARY_ORDER_BGR;

        if (bBitFields)
        {
        // 16 or 32BPP.

            pColorTriad->BytesPerPrimary = 0;
            pColorTriad->BytesPerEntry = cBytesPerEntry;
            pColorTriad->ColorTableEntries = 3;

            ULONG *pulColors = (ULONG *)pColorTriad->pColorTable;
            if (palSrc.bIsBitfields())
            {
                pulColors[0] = palSrc.flRed();
                pulColors[1] = palSrc.flGre();
                pulColors[2] = palSrc.flBlu();
            }
            else
            {
            // BMF_32BPP, it's not BITFIELD so default to 888

                pulColors[1] = 0x00ff00;
                if (palSrc.bIsBGR())
                {
                    pulColors[0] = 0xff0000;
                    pulColors[2] = 0x0000ff;
                }
                else
                {
                    pulColors[0] = 0x0000ff;
                    pulColors[2] = 0xff0000;
                }
            }
        }
        else
        {
            pColorTriad->BytesPerPrimary = 1;
            pColorTriad->BytesPerEntry = cBytesPerEntry;
            pColorTriad->ColorTableEntries = cPalEntries;
            pColorTriad->PrimaryValueMax = 255;

            if (cPalEntries != 0)
            {
            // Not 24BPP or 32BPP
                // Bug #418345
                // If the source palette is monochrome, then we need to
                // use the foreground and background colors of the DC
                // which have been previously stored for us in the
                // translation object.
                XLATE* pxlate = (XLATE*) pxlo;

                if(palSrc.bIsMonochrome() &&
                   (pxlate->flPrivate & XLATE_FROM_MONO))
                {

                    ULONG *pulColors = (ULONG *)pColorTriad->pColorTable;

                    // WINBUG #235687 bhouse 1-19-2000 DIBINDEX values not handled properly by halftone
                    // When given a monochrome palette with a monochrome translate
                    // we need to be sure to also translate DIBINDEX values appropriately

                    pulColors[0] = ulColorRefToRGB(pxlate->ppalDst, pxlate->ppalDstDC, pxlate->iForeDst);
                    pulColors[1] = ulColorRefToRGB(pxlate->ppalDst, pxlate->ppalDstDC, pxlate->iBackDst);

                }
                else
                {
                    palSrc.ulGetEntries(0, cPalEntries,
                        (PPALETTEENTRY)pColorTriad->pColorTable,FALSE);
                }
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    *pHTSurfInfo = HTSurfInfo;

    return(TRUE);
}

/*****************************Private*Function*****************************\
* bSetHTSurfInfo
*
* Initialise the HTSURFACEINFO structure for destination and mask.
*
* History:
*  14-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bSetHTSurfInfo(
SURFOBJ         *pSurfObj,
HTSURFACEINFO   *pHTSurfInfo,   // Where data is placed
LONG            iFormatHT)
{
    HTSURFACEINFO   HTSurfInfo;

    //
    // The halftone now taking ScanLineDelta rather than compute the scanline
    // delta by itself, because many driver fake the pvBits, pvScan0 and
    // scanline delta for creating smaller surface and that sometime cause
    // halftone to break, to do this we passed to halftone ScanLineDelta and
    // (from lDelta in SURFOBJ) and pvScan0.
    //

    HTSurfInfo.hSurface               = (ULONG_PTR)pSurfObj;
    HTSurfInfo.SurfaceFormat          = (BYTE)iFormatHT;
    HTSurfInfo.ScanLineAlignBytes     = BMF_ALIGN_DWORD;
    HTSurfInfo.Width                  = pSurfObj->sizlBitmap.cx;
    HTSurfInfo.Height                 = pSurfObj->sizlBitmap.cy;
    HTSurfInfo.ScanLineDelta          = pSurfObj->lDelta;
    HTSurfInfo.pPlane                 = (LPBYTE)pSurfObj->pvScan0;
    HTSurfInfo.Flags = (USHORT)((pSurfObj->fjBitmap & BMF_TOPDOWN) ?
                                                HTSIF_SCANLINES_TOPDOWN : 0);
    HTSurfInfo.pColorTriad = NULL;
    *pHTSurfInfo = HTSurfInfo;

    return(TRUE);
}

/******************************Public*Routine******************************\
* ppalGetFromXlate
*
* The halftoning algorithm needs to know the source palette.  Unfortunately
* the system wasn't designed to preserve that information, but with some
* work we can do it.  This routine starts the process of finding the source
* palette in more of the cases.  This routine will probably be modified
* greatly to get 100% accuracy.  We would need to construct a palette from
* the table of indices given based on the DST palette or DST DC palette (if
* pal managed) and return it.  If this routine starts manufacturing palettes
* it would need to inc the ref count on ones it doesn't create and then when
* done dec the count and delete if 0.  However this would require the rest
* of palette world to use this convention and it all would take a week of
* work.
*
* History:
*  18-Feb-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PPALETTE ppalGetFromXlate(SURFACE *pSurfSrc, SURFACE *pSurfDst,
                          XLATE *pxlo, UINT iPal, BOOL bFirstTime)
{
    ASSERTGDI((iPal == XO_SRCPALETTE) || (iPal == XO_DESTPALETTE), "ERROR invalid type requested");

    //
    // See if the source palette is lying in the source surface like
    // it usually is.
    //

    PPALETTE ppalReturn;

    if (iPal == XO_SRCPALETTE)
    {
        ppalReturn = pSurfSrc->ppal();
    }
    else
    {
        ppalReturn = pSurfDst->ppal();
    }

    if (ppalReturn == NULL)
    {
        //
        // Check xlate is passed in is not NULL and it's really valid.
        // Global ident xlate is not valid, it's just a shell with the
        // accelerators filled in.
        //

        if (pxlo != NULL)
        {
            if (iPal == XO_SRCPALETTE)
            {
                ppalReturn = pxlo->ppalSrc;
            }
            else
            {
                ppalReturn = pxlo->ppalDst;
            }
        }

        if (ppalReturn == NULL)
        {
            //
            // Let's try and grab it out of the PDEV now.
            //

            if (iPal == XO_SRCPALETTE)
            {
                PDEVOBJ po(pSurfSrc->hdev());

                if (po.bValid() && po.bIsPalManaged())
                {
                    if (pSurfSrc->iFormat() == po.iDitherFormat())
                    {
                        ppalReturn = po.ppalSurf();
                    }
                }
            }
            else
            {
                PDEVOBJ po(pSurfDst->hdev());

                if (po.bValid() && !po.bIsPalManaged())
                {
                    if (pSurfDst->iFormat() == po.iDitherFormat())
                    {
                        ppalReturn = po.ppalSurf();
                    }
                }
            }

            if (ppalReturn == NULL)
            {
                if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                {
                    //
                    // Well if we can't figure it out from the source
                    // and it's identity just get it from the destination
                    //

                    if (bFirstTime)
                        ppalReturn = ppalGetFromXlate(pSurfSrc, pSurfDst, pxlo, iPal == XO_SRCPALETTE ? XO_DESTPALETTE : XO_SRCPALETTE, FALSE);
                }
            }
        }
    }

    return(ppalReturn);
}

/******************************Public*Function*****************************\
* EngHTBlt
*
* Stretch/PlgBlt with halftone mode.
*
* History:
*  19-Nov-1991 -by- Wendy Wu [wendywu]
* Adapted from gdi\printers\rasdd\stretch.c.
\**************************************************************************/

int EngHTBlt
(
IN  SURFOBJ         *psoDst,
IN  SURFOBJ         *psoSrc,
IN  SURFOBJ         *psoMask,
IN  CLIPOBJ         *pco,
IN  XLATEOBJ        *pxlo,
IN  COLORADJUSTMENT *pca,
IN  PPOINTL          pptlBrushOrg,
IN  PRECTL           prclDest,
IN  PRECTL           prclSrc,
IN  PPOINTL          pptlMask,
IN  ULONG            uFlags,
IN  BLENDOBJ        *pBlendObj)
{
    PSURFACE pSurfDst  = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMask = SURFOBJ_TO_SURFACE(psoMask);

    HTSURFACEINFO   HTDest;
    HTSURFACEINFO   HTSrc;
    HTSURFACEINFO   HTMask;
    COLORTRIAD      clrtri;
    BYTE            aclr[256];
    LONG            cjDstWidth;

    PDEVOBJ poDst(pSurfDst->hdev());

    if (!poDst.bValid())
        return(HTBLT_NOTSUPPORTED);

// Halftoning will relay on driver's halftone palette and output format,
// even the target surface is not device surface. so that during halftoning,
// we need to prevent happen dynamic mode chage, if the device is display.
// thus we hold devlock here.

    DEVLOCKOBJ dlo;

    if (poDst.bDisplayPDEV())
        dlo.vLock(poDst);
    else
        dlo.vInit();

// iFormatDst:   The format of the destination bitmap.  This is also used for
//               shadow bitmap creation if destination is not an engine bitmap.
// iFormatHT:    The halftone format that we'll pass to HT_HalftoneBitmap.
// iFormatHTPal: The halftone format that we'll use to determine what kind
//               of halftone palette to create.

    ULONG iFormatDst, iFormatHT, iFormatHTPal;

// Determine the halftone and destination bitmap formats.
// If the destination is a DIB, we'll write directly to it unless the halftone
// palette is different from the dest palette.  So the halftone format has
// to be the same as the destination format.
// If the destination is not a DIB, we'll halftone to a shadow bitmap.
// The format of this bitmap can be different from the device format and
// is depending on the halftone format in GDIINFO.

    if (psoDst->iType == STYPE_BITMAP)
    {
        switch(pSurfDst->iFormat())
        {
        case BMF_1BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 31) & ~31) >> 3;
            iFormatHT = iFormatDst = BMF_1BPP;
            iFormatHTPal = HT_FORMAT_1BPP;
            break;
        case BMF_4BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 7) & ~7) >> 1;
            iFormatDst = BMF_4BPP;
            if (poDst.GdiInfo()->ulHTOutputFormat == HT_FORMAT_4BPP)
            {
                iFormatHT = BMF_4BPP;
                iFormatHTPal = HT_FORMAT_4BPP;
            }
            else
            {
                iFormatHT = BMF_4BPP_VGA16;
                iFormatHTPal = HT_FORMAT_4BPP_IRGB;
            }
            break;
        case BMF_8BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 3) & ~3);
            iFormatHT = BMF_8BPP_VGA256;
            iFormatDst = BMF_8BPP;
            iFormatHTPal = HT_FORMAT_8BPP;
            break;
        case BMF_16BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 1) & ~1) << 1;
            iFormatHT = BMF_16BPP_555;
            iFormatDst = BMF_16BPP;
            iFormatHTPal = HT_FORMAT_16BPP;
            break;
        case BMF_24BPP:
            cjDstWidth = (((psoDst->sizlBitmap.cx * 3) + 3) & ~3);
            iFormatHT = BMF_24BPP;
            iFormatDst = BMF_24BPP;
            iFormatHTPal = HT_FORMAT_24BPP;
            break;
        case BMF_32BPP:
            cjDstWidth = (((psoDst->sizlBitmap.cx << 2) + 3) & ~3);
            iFormatHT = BMF_32BPP;
            iFormatDst = BMF_32BPP;
            iFormatHTPal = HT_FORMAT_32BPP;
            break;
        default:
            return(HTBLT_NOTSUPPORTED);
        }
    }
    else
    {
        iFormatHTPal = poDst.GdiInfo()->ulHTOutputFormat;
        switch(iFormatHTPal)
        {
        case HT_FORMAT_1BPP:
            iFormatHT = iFormatDst = BMF_1BPP;
            break;
        case HT_FORMAT_4BPP:
            iFormatHT = iFormatDst = BMF_4BPP;
            break;
        case HT_FORMAT_4BPP_IRGB:
            iFormatHT = BMF_4BPP_VGA16;
            iFormatDst = BMF_4BPP;
            break;
        case HT_FORMAT_8BPP:
            iFormatHT = BMF_8BPP_VGA256;
            iFormatDst = BMF_8BPP;
            break;
        case HT_FORMAT_16BPP:
            iFormatHT = BMF_16BPP_555;
            iFormatDst = BMF_16BPP;
            break;
        case HT_FORMAT_24BPP:
            iFormatHT = BMF_24BPP;
            iFormatDst = BMF_24BPP;
            break;
        case HT_FORMAT_32BPP:
            iFormatHT = BMF_32BPP;
            iFormatDst = BMF_32BPP;
            break;
        default:
            return(HTBLT_NOTSUPPORTED);
        }
    }

    ERECTL  erclTrim(0, 0, psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy);
    erclTrim *= *prclSrc;
    if (erclTrim.bEmpty())
        return(HTBLT_SUCCESS);

    //
    // Initialize halftone structure and get ready.
    //

    if ((poDst.pDevHTInfo() == NULL) && !poDst.bEnableHalftone(pca))
        return(HTBLT_ERROR);

    SURFACE  *pSurfTempSrc;
    SURFMEM  dimoSrc;

    //
    // Synchronize with the source device driver.
    //

    if ( pSurfSrc->flags() & HOOK_SYNCHRONIZE)
    {
        PDEVOBJ po( pSurfSrc->hdev());
        po.vSync(psoSrc,NULL,0);
    }

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoSrc->iBitmapFormat != BMF_4RLE) &&
        (psoSrc->iBitmapFormat != BMF_8RLE))
    {
        pSurfTempSrc = pSurfSrc;
    }
    else
    {

        // Get the bits from the device.
        // Find out the format to use by looking at the preferred format in
        // the surface's pdev devinfo structure.  We want to keep the original
        // color as much as possible since the halftone routine does a better
        // job in converting colors.

        DEVBITMAPINFO dbmiSrc;

        dbmiSrc.cxBitmap = psoSrc->sizlBitmap.cx;
        dbmiSrc.cyBitmap = psoSrc->sizlBitmap.cy;
        dbmiSrc.hpal     = (HPALETTE) 0;
        dbmiSrc.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
        switch (psoSrc->iBitmapFormat)
        {
        case BMF_4RLE:
            dbmiSrc.iFormat = BMF_4BPP;
            break;
        case BMF_8RLE:
            dbmiSrc.iFormat = BMF_8BPP;
            break;
        default:
            dbmiSrc.iFormat  = psoSrc->iBitmapFormat;
            break;
        }

        if (!dimoSrc.bCreateDIB(&dbmiSrc, (PVOID) NULL))
        {
            WARNING("dimoSrc.bCreateDIB failed in EngHTBlt\n");
            return(HTBLT_ERROR);
        }

        // Copy the bits, dispatch off dst's ldev which is the engine.

        if (!EngCopyBits(dimoSrc.pSurfobj(),
                         psoSrc,
                         (CLIPOBJ *) NULL,
                         &xloIdent,
                         &erclTrim,
                         (POINTL *)&erclTrim))
        {
            WARNING("EngHTBlt:CopyBits failes\n");
            return(HTBLT_ERROR);
        }

        pSurfTempSrc = dimoSrc.ps;
    }

    //
    // Get the source palette.
    //

    PPALETTE ppalS = ppalGetFromXlate(pSurfSrc, pSurfDst, (XLATE *) pxlo, XO_SRCPALETTE, TRUE);

    if (ppalS == NULL)
    {
        WARNING("EngHTBlt could not find Source palette to use\n");
        return(HTBLT_NOTSUPPORTED);
    }

    XEPALOBJ palSrc(ppalS);

    //
    // Dest surface palette will be invalid only if it's a 256 color bitmap.
    //

    XEPALOBJ palDstSurf(ppalGetFromXlate( pSurfSrc, pSurfDst, (XLATE *) pxlo, XO_DESTPALETTE, TRUE));

//  Let's see if halftone palette is the same as the destination palette.

    BOOL bNoXlate;
    PALMEMOBJ palHTDst;
    XEPALOBJ *ppalHT = (XEPALOBJ *)NULL;

    if (iFormatHTPal != poDst.GdiInfo()->ulHTOutputFormat)
    {
        if (!palHTDst.bCreateHTPalette(iFormatHTPal, poDst.GdiInfo()))
        {
            return(HTBLT_ERROR);
        }
        ppalHT = (XEPALOBJ *)&palHTDst;
        bNoXlate = palHTDst.bEqualEntries(palDstSurf);
    }
    else
    {
        bNoXlate = poDst.bHTPalIsDevPal();
    }

// Prepare for HT_HalftoneBitmap call.

    BITBLTPARAMS    BitbltParams;
    ABINFO          AbInfo;

    if(uFlags == BBPF_DO_ALPHA_BLEND)
    {
        BLENDFUNCTION BlendFunction = pBlendObj->BlendFunction;
        if(BlendFunction.BlendOp == AC_SRC_OVER)
        {
            AbInfo.Flags = 0;
            AbInfo.pDstPal = 0;
            AbInfo.cDstPal = 0;

            AbInfo.ConstAlphaValue = BlendFunction.SourceConstantAlpha;

            if(BlendFunction.AlphaFormat == AC_SRC_ALPHA &&
               BlendFunction.SourceConstantAlpha == 255)
            {
                // Per pixel Alpha : Need palette info.
                if(!bIsSourceBGRA(pSurfSrc))
                    return HTBLT_ERROR;
                AbInfo.Flags |= ABIF_SRC_ALPHA_IS_PREMUL;
                //if(iFormatDst == BMF_32BPP)
                //    AbInfo.Flags |= ABIF_BLEND_DEST_ALPHA;
            }
            else
            {
                AbInfo.Flags |= ABIF_USE_CONST_ALPHA_VALUE;
            }

            // Set Destination palette values for Halftone.
            if(palDstSurf.bValid())
            {
                AbInfo.pDstPal = (LPPALETTEENTRY)palDstSurf.apalColorGet();
                AbInfo.cDstPal = (WORD)palDstSurf.cEntries();
                if(palDstSurf.bIsBGR() ||
                   ((palDstSurf.bIsBitfields())      &&
                    (palDstSurf.flRed() == 0xff0000) &&
                    (palDstSurf.flGre() == 0xff00)   &&
                    (palDstSurf.flBlu() == 0xff)))
                    AbInfo.Flags |= ABIF_DSTPAL_IS_RGBQUAD;
            }

            BitbltParams.pABInfo = &AbInfo;
        }
        else
            uFlags = 0;
    }
    //
    // Remove pAbort, since it never used and delete by ht.h
    //

    BitbltParams.rclSrc = *prclSrc;
    BitbltParams.rclDest = *prclDest;
    BitbltParams.Flags = (USHORT)uFlags;
    BitbltParams.ptlBrushOrg = *pptlBrushOrg;
    BitbltParams.DestPrimaryOrder = (BYTE)poDst.GdiInfo()->ulPrimaryOrder;

// Set ICM flags for halftoning

    ULONG lIcmMode = pxlo ? ((XLATE *) pxlo)->lIcmMode : DC_ICM_OFF;

    // 1) IF application ICM, BBPF_ICM_ON is ON.
    // 2) IF other ICM and not device caribrate, BBPF_ICM_ON is ON.

    if((IS_ICM_OUTSIDEDC(lIcmMode)) ||
       (!IS_ICM_DEVICE_CALIBRATE(lIcmMode) && (IS_ICM_HOST(lIcmMode) || (IS_ICM_DEVICE(lIcmMode)))))
    {
        ICMDUMP(("EngHTBlt(): ICM with Halftone (Dynamic Bit On)\n"));

        // Some kind of ICM (ICM on Application, Graphics Engine or Device)
        // is enabled, so tell halftoning code to disable thier color adjustment.

        BitbltParams.Flags |= BBPF_ICM_ON;
    }
    else
    {
        ICMDUMP(("EngHTBlt(): ICM with Halftone (Dynamic Bit Off)\n"));
    }


// Get the relevant information about the destination bitmap.

    SURFACE *pSurfTempDst = pSurfDst;
    SURFMEM dimoDst;

// Create a temporary bitmap if
// 1) the destination bitmap is not an engine bitmap. or
// 2) the bitmap width is not equal to the stride, because the halftone
//    code assumes they are equivalent, or
// 3) the destination is not 8bpp (we have special case for this) and
//    the halftone palette is different from the destination palette, or
// 4) the surfaces are overlapping

    BOOL bCreateShadowBitmap = FALSE;
    BYTE iDComplexity = (pco == (CLIPOBJ *) NULL) ? DC_TRIVIAL
                                                  : pco->iDComplexity;

// After the following "if" block, pcoNew should be used for clipping instead
// of pco.  We implement single rect clipping through banding in halftone.

// if DC_COMPLEX, create a shadow bitmap to avoid calling HT_Bitmap many times

    CLIPOBJ *pcoNew = pco;

    if ((psoDst->iType != STYPE_BITMAP) ||
        (psoDst->lDelta != cjDstWidth)  ||
        ((iFormatDst != BMF_8BPP) && !bNoXlate) ||
        (iDComplexity == DC_COMPLEX)||
        ((psoDst == psoSrc) && bIntersect(prclSrc, prclDest)))
    {
        bCreateShadowBitmap = TRUE;

        PRECTL prcl = prclDest;
        if (iDComplexity != DC_TRIVIAL)
        {
        // Clipping is not DC_TRIVIAL, use rclBounds as dest rect.

            prcl = &pco->rclBounds;

        // Clipping is done through banding if DC_RECT, do not clip
        // in CopyBits.

            if (iDComplexity == DC_RECT)
                pcoNew = NULL;

        // Do not enumerate clipping when calling halftone by marking
        // complexity to DC_TRIVIAL.

            iDComplexity = DC_TRIVIAL;
        }

    // Banding rect has to be well ordered and confined in the surface area.

        LONG lDxDst, lDyDst;
        SIZEL sizlDst = pSurfDst->sizl();
        LONG lLeft, lRight, lTop, lBottom;

    // Do the x part.

        if (prcl->right > prcl->left)
        {
            lLeft = prcl->left;
            lRight = prcl->right;
        }
        else
        {
            lLeft = prcl->right;
            lRight = prcl->left;
        }

        if (lLeft < 0L)
            lLeft = 0L;

        if (lRight > sizlDst.cx)
            lRight = sizlDst.cx;

        if ((lDxDst = (lRight - lLeft)) <= 0L)
            return(HTBLT_SUCCESS);

        BitbltParams.rclBand.left = lLeft;
        BitbltParams.rclBand.right = lRight;

    // Do the y part.

        if (prcl->bottom > prcl->top)
        {
            lTop = prcl->top;
            lBottom = prcl->bottom;
        }
        else
        {
            lTop = prcl->bottom;
            lBottom = prcl->top;
        }

        if (lTop < 0)
            lTop = 0;

        if (lBottom > sizlDst.cy)
            lBottom = sizlDst.cy;

        if ((lDyDst = (lBottom - lTop)) <= 0L)
            return(HTBLT_SUCCESS);

        BitbltParams.rclBand.top = lTop;
        BitbltParams.rclBand.bottom = lBottom;
        BitbltParams.Flags |= BBPF_HAS_BANDRECT;

    // Create the shadow bitmap.

        DEVBITMAPINFO dbmiDst;

        dbmiDst.cxBitmap = lDxDst;
        dbmiDst.cyBitmap = lDyDst;
        dbmiDst.hpal = 0;
        dbmiDst.fl = pSurfDst->bUMPD() ? UMPD_SURFACE : 0;
        dbmiDst.iFormat = iFormatDst;

        if (!dimoDst.bCreateDIB(&dbmiDst, (PVOID) NULL))
        {
            WARNING("dimoDst.bCreateDIB failed in EngHTBlt\n");
            return(HTBLT_ERROR);
        }

        pSurfTempDst = dimoDst.ps;
    }

    //
    // We need to xlate from halftone palette to dest surface palette if
    // the halftone palette is different from the destination palette.
    //

    EXLATEOBJ xloHTToDst, xloDstToHT;
    XLATEOBJ  *pxloHTToDst = &xloIdent, *pxloDstToHT = &xloIdent;

    DEVICEHALFTONEINFO *pDevHTInfo = (DEVICEHALFTONEINFO *)poDst.pDevHTInfo();

    if (!bNoXlate)
    {
        XEPALOBJ palDstDC;
        EPALOBJ  palHT((HPALETTE)pDevHTInfo->DeviceOwnData);
        ASSERTGDI(palHT.bValid(),"EngHTBlt: invalid HT pal\n");

        if (ppalHT == (XEPALOBJ *)NULL)
        {
            ppalHT = &palHT;
        }

        if ((pxlo == NULL) ||
            (((XLATE *) pxlo)->ppalDstDC == NULL))
        {
            palDstDC.ppalSet(ppalDefault);
        }
        else
        {
            palDstDC.ppalSet(((XLATE *) pxlo)->ppalDstDC);
        }

        if (!xloHTToDst.bInitXlateObj(
                            NULL,
                            DC_ICM_OFF,
                            *ppalHT,
                            palDstSurf,
                            palDstDC,
                            palDstDC,
                            0,
                            0x00FFFFFF,
                            0x00FFFFFF
                            ))
        {
            WARNING("EngHTBlt: bInitXlateObj HT to Dst failed\n");
            return(HTBLT_ERROR);
        }

        pxloHTToDst = xloHTToDst.pxlo();

    // Init the Dst pal to HT pal xlateobj so we can do CopyBits from
    // the destination surface to the halftone buffer.

        if ((pSurfMask || uFlags == BBPF_DO_ALPHA_BLEND) && bCreateShadowBitmap)
        {
            if (!xloDstToHT.bInitXlateObj(
                                    NULL,
                                    DC_ICM_OFF,
                                    palDstSurf,
                                    *ppalHT,
                                    palDstDC,
                                    palDstDC,
                                    0,
                                    0x00FFFFFF,
                                    0x00FFFFFF
                                    ))
            {
                WARNING("EngHTBlt: bInitXlateObj Dst to HT failed\n");
                return(HTBLT_ERROR);
            }

            pxloDstToHT = xloDstToHT.pxlo();
        }
    }

// If there is a source mask, copy the destination bits to the buffer
// so we can do CopyBits later on.  This is fater than creating a
// stretched mask and BitBlt with the created masks.

// Synchronize with the destination device driver.

    poDst.vSync(psoDst,NULL,0);

    if ((pSurfMask || uFlags == BBPF_DO_ALPHA_BLEND) && bCreateShadowBitmap)
    {
        ERECTL  ercl(0, 0, pSurfTempDst->sizl().cx, pSurfTempDst->sizl().cy);

    // Inc target surface uniqueness

        INC_SURF_UNIQ(pSurfTempDst);

        if (!(*PPFNGET(poDst,CopyBits, pSurfDst->flags()))
                      (
                      pSurfTempDst->pSurfobj(),         // Target surf
                      psoDst,                           // Source surf
                      (CLIPOBJ *)NULL,                  // ClipObj
                      pxloDstToHT,                      // XlateObj
                      (RECTL *)&ercl,                   // Dest rect
                      (POINTL *)&BitbltParams.rclBand   // Src offset
                      ))
        {
        // CopyBits failed.  We'll paint the background white.

            if (!EngBitBlt(pSurfTempDst->pSurfobj(),    // Target surf
                           (SURFOBJ *)NULL,             // Source surf
                           (SURFOBJ *)NULL,             // Mask surf
                           (CLIPOBJ *)NULL,             // ClipObj
                           NULL,                        // XlateObj
                           (RECTL *)&ercl,              // Dest rect
                           (POINTL *)NULL,              // Src offset
                           (POINTL *)NULL,              // Mask offset
                           (BRUSHOBJ *)NULL,            // BrushObj
                           (POINTL *)NULL,              // Brush origin
                           0xFFFF))                     // Rop
            {
                return(HTBLT_ERROR);
            }
        }
    }

    HTSrc.pColorTriad = (PCOLORTRIAD)NULL;      // assume not allocate
    BOOL bRet = FALSE;

    if (bSetHTSrcSurfInfo(pSurfTempSrc->pSurfobj(), palSrc, &HTSrc, pxlo) &&
        bSetHTSurfInfo(pSurfTempDst->pSurfobj(), &HTDest, iFormatHT) &&
        (!pSurfMask || bSetHTSurfInfo(pSurfMask->pSurfobj(), &HTMask, psoMask->iBitmapFormat)))
    {
        PHTSURFACEINFO pMask = (PHTSURFACEINFO)NULL;
        if (pSurfMask)
        {
            BitbltParams.ptlSrcMask = *pptlMask;
            pMask = &HTMask;
        }

        if (!(poDst.GdiInfo()->flHTFlags & HT_FLAG_OUTPUT_CMY))
            BitbltParams.Flags |= BBPF_USE_ADDITIVE_PRIMS;

    // 8BPP halftone does color translations.  So pass the xlate along.

        if (iFormatDst == BMF_8BPP)
        {
            HTDest.pColorTriad = &clrtri;
            clrtri.Type = COLOR_TYPE_RGB;
            clrtri.BytesPerPrimary = 1;
            clrtri.BytesPerEntry = 1;
            clrtri.PrimaryOrder = COLOR_TYPE_RGB;
            clrtri.PrimaryValueMax = 255;
            clrtri.ColorTableEntries = 256;;
            clrtri.pColorTable = aclr;

            for(COUNT i = 0; i < pxloHTToDst->cEntries; i++)
            {
                aclr[i] = (BYTE)(*(pxloHTToDst->pulXlate + i));
            }
            pxloHTToDst = &xloIdent;
        }

    // HT_HalftoneBitmap will return number of scans being drawn.

        switch (iDComplexity)
        {
        case DC_RECT:
            BitbltParams.Flags |= BBPF_HAS_DEST_CLIPRECT;
            BitbltParams.rclClip = pcoNew->rclBounds;

        case DC_TRIVIAL:
            bRet = (HT_HalftoneBitmap(pDevHTInfo,
                                      (PHTCOLORADJUSTMENT)pca,
                                      (PHTSURFACEINFO)&HTSrc,
                                      pMask,
                                      (PHTSURFACEINFO)&HTDest,
                                      (PBITBLTPARAMS)&BitbltParams) >= 0L);

            break;

        default:        // DC_COMPLEX
            BitbltParams.Flags |= BBPF_HAS_DEST_CLIPRECT;
            ((ECLIPOBJ *) pcoNew)->cEnumStart(FALSE,CT_RECTANGLES,
                                              CD_ANY,CLIPOBJ_ENUM_LIMIT);
            bRet = TRUE;

            BOOL bMore;
            CLIPENUMRECT clenr;
            do {
                bMore = ((ECLIPOBJ *) pcoNew)->bEnum(sizeof(clenr),
                                                     (PVOID) &clenr);

                for (ULONG iRT = 0; iRT < clenr.c; iRT++)
                {
                    BitbltParams.rclClip = clenr.arcl[iRT];

                    bRet &= (HT_HalftoneBitmap(pDevHTInfo,
                                               (PHTCOLORADJUSTMENT)pca,
                                               (PHTSURFACEINFO)&HTSrc,
                                               pMask,
                                               (PHTSURFACEINFO)&HTDest,
                                               (PBITBLTPARAMS)&BitbltParams) >= 0L);
                }
            } while (bMore && bRet);
            break;
        }

        if (bCreateShadowBitmap && bRet)
        {
            // Dispatch the call.  Give it no mask.

            EPOINTL eptl(0,0);

            // Inc target surface uniqueness

            INC_SURF_UNIQ(pSurfDst);

            if (psoDst->iType != STYPE_BITMAP)
            {
                bRet = (*PPFNGET(poDst,CopyBits, pSurfDst->flags())) (
                            psoDst,
                            pSurfTempDst->pSurfobj(),
                            pcoNew,
                            pxloHTToDst,
                            &BitbltParams.rclBand,
                            (POINTL *)&eptl);
            }
            else
            {
                bRet = EngCopyBits(
                            psoDst,
                            pSurfTempDst->pSurfobj(),
                            pcoNew,
                            pxloHTToDst,
                            &BitbltParams.rclBand,
                            (POINTL *)&eptl);


            }
        }
    }

    if (HTSrc.pColorTriad)
        VFREEMEM((LPSTR)HTSrc.pColorTriad);

    return(bRet ? HTBLT_SUCCESS : HTBLT_ERROR);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\icmapi.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*   icmapi.cxx
*
* Abstract
*
*   This module implements Integrated Color match API support
*
* Author:
*
*   Mark Enstrom    (marke) 9-27-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
    ULONG GreGetBitmapBitsSize(CONST BITMAPINFO *pbmi); // in ntgdi.c
    BOOL  bInitICM();
}

#pragma alloc_text(INIT, bInitICM)

PCOLORSPACE  gpStockColorSpace;
HCOLORSPACE  ghStockColorSpace;

UINT         giIcmGammaRange;

#if DBG_ICM

ULONG        IcmDebugLevel = 0;

#endif

#define sRGB_PROFILENAME        L"sRGB Color Space Profile.icm"

LOGCOLORSPACEW gcsStockColorSpace = {
                           LCS_SIGNATURE,
                           0x400,
                           sizeof(LOGCOLORSPACEW),
                           LCS_CALIBRATED_RGB,
                           LCS_GM_IMAGES,
                           {
                            {0x000006b91,0x000003db8,0x00000070e},
                            {0x000005793,0x00000a9ba,0x000001bf4},
                            {0x0000038aa,0x00000188e,0x000012888}
                           },
                           0x23333,  // 2.2
                           0x23333,  // 2.2
                           0x23333,  // 2.2
                           0};

#define MAX_COLORTABLE     256

//
// iIcmControlFlags
//
#define ICM_CONTROL_WIN95_COLORSPACE 0x00010000 // Win95 compatible colorspace

//
// Misc. macros
//
#define ALIGN_DWORD(nBytes)   (((nBytes) + 3) & ~3)

//
// ICM supports output color mode (originally come from ICM.H)
//
#define BM_RGBTRIPLETS   0x0002
#define BM_xRGBQUADS     0x0008
#define BM_xBGRQUADS     0x0010
#define BM_CMYKQUADS     0x0020
#define BM_KYMCQUADS     0x0305

//
// ICM modes list
//
// if (IS_HOST_ICM(pdca->lIcmMode))
// {
//     if (pdca->hcmXform)
//     {
//         if (IS_CMYK_COLOR(pdca->lIcmMode))
//         {
//             Host ICM ON, CMYK color mode.
//             With CMYK color mode, we should have valid color transform.
//         }
//         else
//         {
//             Host ICM ON, RGB color mode.
//         }
//     }
//     else
//     {
//         Host ICM ON, RGB color mode,
//         But no color translation because src == dst color space.
//     }
// }
// else if (IS_DEVICE_ICM(pdca->lIcmMode))
// {
//     Device ICM ON.
// }
// else if (IS_OUTSIDEDC_ICM(pdca->lIcmMode))
// {
//     Application ICM ON.
// }
//

/******************************Public*Routine******************************\
* GreCreateColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE
GreCreateColorSpace(
    PLOGCOLORSPACEEXW pLogColorSpaceEx
    )
{
    ICMAPI(("GreCreateColorSpace\n"));

    HCOLORSPACE hRet = NULL;
    PCOLORSPACE pColorSpace;

    //
    // Check the validation of this color space.
    //
    if ((pLogColorSpaceEx->lcsColorSpace.lcsSignature != LCS_SIGNATURE)    ||
        (pLogColorSpaceEx->lcsColorSpace.lcsVersion   != 0x400)            ||
        (pLogColorSpaceEx->lcsColorSpace.lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    //
    // Allocate COLORSPACE object.
    //
    pColorSpace = (PCOLORSPACE) ALLOCOBJ(sizeof(COLORSPACE), ICMLCS_TYPE, FALSE);

    if (pColorSpace == (PCOLORSPACE)NULL)
    {
        WARNING("bCreateColorSpace failed memory allocation\n");
    }
    else
    {
        //
        // Register LOGCOLORSPACE handle.
        //
        hRet = (HCOLORSPACE)HmgInsertObject(
                                    pColorSpace,
                                    HMGR_ALLOC_ALT_LOCK,
                                    ICMLCS_TYPE);

        if (hRet)
        {
            //
            // Copy LOGCOLORSPACE into COLORSPACE object.
            //
            pColorSpace->lcsSignature(pLogColorSpaceEx->lcsColorSpace.lcsSignature);
            pColorSpace->lcsVersion(pLogColorSpaceEx->lcsColorSpace.lcsVersion);
            pColorSpace->lcsSize(pLogColorSpaceEx->lcsColorSpace.lcsSize);
            pColorSpace->lcsCSType(pLogColorSpaceEx->lcsColorSpace.lcsCSType);
            pColorSpace->lcsIntent(pLogColorSpaceEx->lcsColorSpace.lcsIntent);
            pColorSpace->vSETlcsEndpoints(&(pLogColorSpaceEx->lcsColorSpace.lcsEndpoints));
            pColorSpace->lcsGammaRed(pLogColorSpaceEx->lcsColorSpace.lcsGammaRed);
            pColorSpace->lcsGammaGreen(pLogColorSpaceEx->lcsColorSpace.lcsGammaGreen);
            pColorSpace->lcsGammaBlue(pLogColorSpaceEx->lcsColorSpace.lcsGammaBlue);
            pColorSpace->vSETlcsFilename((PWCHAR)&(pLogColorSpaceEx->lcsColorSpace.lcsFilename[0]),MAX_PATH);

            pColorSpace->lcsExFlags(pLogColorSpaceEx->dwFlags);

            //
            // Decrement color space handle which increment at creation time.
            //
            DEC_SHARE_REF_CNT(pColorSpace);

            ICMMSG(("GreCreateColorSpace():Object %x: ref. count = %d\n",
                                                hRet,HmgQueryAltLock((HOBJ)hRet)));
        }
        else
        {
            FREEOBJ(pColorSpace,ICMLCS_TYPE);
        }
    }

    return(hRet);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   NtGdiCreateColorSpace
*
* Routine Description:
*
*   Create a color space object - stub
*
* Arguments:
*
*   pLogColorSpace - Logical Color space passed in. This will be used as the
*   user-mode visible protion of this object
*
* Return Value:
*
*   Handle to ColorSpace object or NULL on failure
*
\**************************************************************************/

HANDLE
APIENTRY
NtGdiCreateColorSpace(
    PLOGCOLORSPACEEXW pLogColorSpaceEx
    )
{
    ICMAPI(("NtGdiCreateColorSpace\n"));

    HANDLE hRet = NULL;
    BOOL   bStatus = TRUE;

    LOGCOLORSPACEEXW tmpLcsEx;

    __try
    {
        ProbeForRead(pLogColorSpaceEx,sizeof(LOGCOLORSPACEEXW),sizeof(ULONG));
        RtlCopyMemory(&tmpLcsEx,pLogColorSpaceEx,sizeof(LOGCOLORSPACEEXW));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bStatus = FALSE;
    }

    if (bStatus)
    {
        hRet = (HANDLE)GreCreateColorSpace(&tmpLcsEx);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* bDeleteColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDeleteColorSpace(
    HCOLORSPACE hColorSpace
    )
{
    ICMAPI(("bDeleteColorSpace\n"));

    BOOL        bRet = FALSE;

    PCOLORSPACE pColorSpace;

    if (DIFFHANDLE(hColorSpace,ghStockColorSpace))
    {
        ICMMSG(("bDeleteColorSpace():Object %x: ref. count = %d\n",
                                   hColorSpace,HmgQueryAltLock((HOBJ)hColorSpace)));

        //
        // Try to remove handle from hmgr. This will fail if the color space
        // is locked down on any threads or if it has been marked global or
        // un-deleteable.
        //
        pColorSpace = (PCOLORSPACE)HmgRemoveObject(
                                    (HOBJ)hColorSpace,
                                     0,
                                     0,
                                     TRUE,
                                     ICMLCS_TYPE);

        if (pColorSpace != (PCOLORSPACE)NULL)
        {
            FREEOBJ(pColorSpace,ICMLCS_TYPE);
            bRet = TRUE;
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            WARNING("Couldn't remove COLORSPACE object");
        }
    }
    else
    {
        //
        // Under Win31 deleting stock objects returns True.
        //
        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiDeleteColorSpace
*
* Routine Description:
*
*   Delete a color space object
*
* Arguments:
*
*   hColorSpace - Handle of Logical Color Space to delete
*
* Return Value:
*
*   BOOL status
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteColorSpace(
    HANDLE hColorSpace
    )
{
    ICMAPI(("NtGdiDeleteColorSpace\n"));

    //
    // Delete ColorSpace
    //
    return(bDeleteColorSpace((HCOLORSPACE)hColorSpace));
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   NtGdiSetColorSpace
*
* Routine Description:
*
*   Set Color Space for DC
*
* Arguments:
*
*   hdc         - handle of dc
*   hColorSpace - handle of color space
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetColorSpace(
    HDC         hdc,
    HCOLORSPACE hColorSpace
    )
{
    BOOL bReturn = FALSE;

    ICMAPI(("NtGdiSetColorSpace\n"));

    //
    // validate the DC
    //
    XDCOBJ   dco(hdc);

    if (dco.bValid())
    {
        //
        // is it a different colorspace
        //
        if (DIFFHANDLE(hColorSpace,dco.pdc->hColorSpace()))
        {
            //
            // now validate HColorSpace
            //
            COLORSPACEREF ColorSpaceSel(hColorSpace);

            if (ColorSpaceSel.bValid())
            {
                //
                // dec ref count of old color space.
                //
                DEC_SHARE_REF_CNT((PCOLORSPACE)dco.pdc->pColorSpace());

                ICMMSG(("NtGdiSetColorSpace():Old Object %x: ref. count = %d\n",
                         dco.pdc->hColorSpace(),HmgQueryAltLock((HOBJ)dco.pdc->hColorSpace())));

                //
                // set color space handle in dc
                //
                dco.pdc->hColorSpace(hColorSpace);
                dco.pdc->pColorSpace(ColorSpaceSel.pColorSpace());

                //
                // up the ref count of the selected color space.
                //
                INC_SHARE_REF_CNT(ColorSpaceSel.pColorSpace());

                ICMMSG(("NtGdiSetColorSpace():New Object %x: ref. count = %d\n",
                         dco.pdc->hColorSpace(),HmgQueryAltLock((HOBJ)dco.pdc->hColorSpace())-1));
                         /* -1: because of COLORSPACEREF locks this, then actuall number is N-1 */

                //
                // We are succeed to select.
                //
                bReturn = TRUE;
            }
            else
            {
                //
                // keep color space as same as current.
                //
            }
        }
        else
        {
            //
            // Same handle has been selected.
            //
            bReturn = TRUE;
        }

        dco.vUnlockFast();
    }

    return(bReturn);
}

#ifdef _IA64_

//
// There is a compiler bug that shows up in this function. 
// Disable optimization until it is fixed.
//

#pragma optimize( "", off )
#endif

/******************************Public*Routine******************************\
* GreSetICMMode()
*
* History:
*
* Write it:
*    27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreSetICMMode(
    HDC   hdc,
    ULONG nCommand,
    ULONG iReqData
    )
{
    ICMMSG(("GreSetICMMode\n"));

    BOOL bRet = TRUE;

    XDCOBJ dco(hdc);

    if(!dco.bValid())
    {
        WARNING("GreSetICMMode(): Invalid DC\n");
        return (FALSE);
    }

    DEVLOCKOBJ dlo;

    if (dlo.bLock(dco))
    {
        ULONG NewReqMode, OldReqMode;
        ULONG NewMode,OldMode;
        ULONG NewColorType, OldColorType;
        PDEVOBJ po(dco.hdev());

        //
        // Check target surface
        //
        SURFACE *pSurface = dco.pSurface();

        //
        // Get current ICM destination color type
        //
        NewColorType = OldColorType = GET_COLORTYPE(dco.pdc->lIcmMode());

        //
        // Get current ICM mode.
        //
        NewMode = OldMode = ICM_MODE(dco.pdc->lIcmMode());

        //
        // Get previous requested mode.
        //
        NewReqMode = OldReqMode = REQ_ICM_MODE(dco.pdc->lIcmMode());

        switch (nCommand)
        {
            case ICM_SET_MODE:

                ICMMSG(("GreSetICMMode():Update ICM mode -> %x\n",iReqData));

                //
                // iReqData should be one of these.
                //
                switch (iReqData)
                {
                case REQ_ICM_OFF:

                    //
                    // Turn off ICM.
                    //
                    // (should preserve alt mode)
                    //
                    NewReqMode = REQ_ICM_OFF;
                    NewMode    = (ICM_ALT_MODE(dco.pdc->lIcmMode()) | DC_ICM_OFF);
                    break;

                case REQ_ICM_HOST:
                case REQ_ICM_DEVICE:
                case REQ_ICM_OUTSIDEDC:

                    //
                    // Update new requested mode.
                    //
                    NewReqMode = iReqData;

                    //
                    // Figure out ICM mode from requested mode.
                    //
                    NewMode = ICM_REQ_TO_MODE(NewReqMode);

                    //
                    // We don't allow "ICM on Device" with non-DDB surface.
                    //
                    if (IS_ICM_DEVICE_REQUESTED(NewReqMode))
                    {
                        if (po.bValid())
                        {
                            //
                            // ICM on Device is requested, check driver's capacity.
                            //
                            if (po.flGraphicsCaps() & GCAPS_ICM)
                            {
                                //
                                // DC is device DC. (not, info or memory)
                                //
                                if (dco.dctp() != DCTYPE_MEMORY)
                                {
                                    //
                                    // OK, we can enable device ICM.
                                    //
                                }
                                else
                                {
                                    ICMMSG(("NtGdiSetIcmMode():DC is memory DC, but device icm requested\n"));

                                    //
                                    // Enable host ICM instead.
                                    //
                                    NewMode = DC_ICM_HOST;
                                }
                            }
                            else
                            {
                                WARNING("GreSetICMMode(): ICM on Device is requested, but driver could not.\n");

                                //
                                // Oh!, device driver does *not* support ICM on device or driver.
                                // Turn on ICM on HOST.
                                //
                                NewMode = DC_ICM_HOST;
                            }
                        }
                        else
                        {
                            //
                            // we will keep current mode. and return false.
                            //
                            bRet = FALSE;
                        }
                    }

                    if (bRet)
                    {
                       //
                       // Should preserve alt mode through ICM mode change.
                       //
                       NewMode |= ICM_ALT_MODE(dco.pdc->lIcmMode());
                    }

                    break;

                default:

                    //
                    // Unknown request mode.
                    //
                    bRet = FALSE;
                }

                break;

            case ICM_SET_CALIBRATE_MODE:

                ICMMSG(("GreSetICMMode():Update ICM device calibrate -> %x\n",iReqData));

                if (iReqData)
                {
                    NewMode |= DC_ICM_DEVICE_CALIBRATE;
                }
                else
                {
                    NewMode &= ~DC_ICM_DEVICE_CALIBRATE;
                }

                break;

            case ICM_SET_COLOR_MODE:
            case ICM_CHECK_COLOR_MODE:

                ICMMSG(("GreSetICMMode():Update ICM colortype -> %x\n",iReqData));

                //
                // iReqData should be one of these.
                //
                switch (iReqData)
                {
                case BM_xRGBQUADS:
                case BM_xBGRQUADS:

                    // Clear lazy color correction.
                    //
                    // NewMode &= ~DC_ICM_LAZY_CORRECTION;
                    //
                    // Note: bitmap might have color which expected to corrected later.

                    //
                    // Set color type as RGB.
                    //
                    NewColorType = DC_ICM_RGB_COLOR;

                    break;

                case BM_CMYKQUADS:
                case BM_KYMCQUADS:

                    if (po.bValid())
                    {
                        //
                        // Set color type as CMYK.
                        //
                        NewColorType = DC_ICM_CMYK_COLOR;

                        //
                        // Check device driver could handle CMYK color or not
                        //
                        if (po.flGraphicsCaps() & GCAPS_CMYKCOLOR)
                        {
                            //
                            // We don't allow "CMYK color" with non-DDB surface.
                            //
                            if (dco.dctp() != DCTYPE_MEMORY)
                            {
                                //
                                // We can go with CMYK color.
                                //
                            }
                            else
                            {
                                ICMMSG(("NtGdiSetIcmMode():Enable lazy color correction\n"));

                                //
                                // Memory DC can only hold RGB based color,
                                // so RGB to CMYK color translation will happen when
                                // apps does BitBlt onto real device surface from this
                                // compatible surface.
                                //
                                NewMode |= DC_ICM_LAZY_CORRECTION;
                                NewColorType = DC_ICM_RGB_COLOR;
                            }
                        }
                        else
                        {
                            //
                            // Driver could not handle, ICM could not turn on.
                            //
                            WARNING("GreSetICMMode(): Device driver could not handle CMYK color\n");

                            //
                            // we will keep current code. and return false.
                            //
                            bRet = FALSE;
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }

                    break;

                default:

                    ICMMSG(("GreSetICMMode():Unknown color type\n"));

                    //
                    // Unknown color mode.
                    //
                    bRet = FALSE;
                }

                break;

            default :

                ICMMSG(("GreSetICMMode():Unknown command\n"));
                bRet = FALSE;
                break;
        }

        if (bRet && (nCommand != ICM_CHECK_COLOR_MODE))
        {
            if ((OldMode != NewMode) || (OldReqMode != NewReqMode) || (OldColorType != NewColorType))
            {
                //
                // Update ICM mode. (we will keep original request mode and colortype).
                //
                // kernel side.
                //
                dco.pdc->lIcmMode(NewColorType|NewReqMode|NewMode);

                // and, client side (need to preserve usermode only flags).
                //
                ULONG UserModeFlag = (dco.pdc->lIcmModeClient() & DC_ICM_USERMODE_FLAG);

                dco.pdc->lIcmModeClient(NewColorType|NewReqMode|NewMode|UserModeFlag);

                if (OldMode != NewMode)
                {
                    SURFACE  *pSurfDest = dco.pSurface();
                    XEPALOBJ  palDestDC(dco.ppal());

                    if (palDestDC.bValid())
                    {
                        //
                        // update all drawing state
                        //
                        palDestDC.vUpdateTime();

                        if (pSurfDest != NULL)
                        {
                            XEPALOBJ palDestSurf(pSurfDest->ppal());

                            if (palDestSurf.bValid())
                            {
                                //
                                // update palette.
                                //
                                palDestSurf.vUpdateTime();
                            }
                        }
                    }
                }

                ICMMSG(("NtGdiSetIcmMode():ICM mode were changed to %x\n",dco.pdc->lIcmMode()));
            }
            else
            {
                ICMMSG(("NtGdiSetIcmMode():ICM mode were NOT changed!\n"));
            }
        }
    }
    else
    {
        //
        // Fail to enable ICM for fullscreen DC.
        //
    }

    dco.vUnlockFast();

    return(bRet);
}

#ifdef _IA64_
#pragma optimize( "", on )
#endif

/******************************Public*Routine******************************\
* NtGdiSetIcmMode
*
* ICM mode changed, update all times
*
* History:
*
* Write it:
*    27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
NtGdiSetIcmMode(
    HDC   hdc,
    ULONG nCommand,
    ULONG ulMode
    )
{
    ICMMSG(("NtGdiSetIcmMode\n"));

    return(GreSetICMMode(hdc,nCommand,ulMode));
}

/******************************Public*Routine******************************\
* GreCreateColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE
GreCreateColorTransform(
    HDC              hdc,
    LPLOGCOLORSPACEW pLogColorSpaceW,
    PVOID            pvSrcProfile,
    ULONG            cjSrcProfile,
    PVOID            pvDstProfile,
    ULONG            cjDstProfile,
    PVOID            pvTrgProfile,
    ULONG            cjTrgProfile
    )
{
    HANDLE hRet = NULL;

    ICMAPI(("GreCreateColorTransform\n"));

    //
    // Check the validation of this color space.
    //
    if ((pLogColorSpaceW->lcsSignature != LCS_SIGNATURE)    ||
        (pLogColorSpaceW->lcsVersion   != 0x400)            ||
        (pLogColorSpaceW->lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    XDCOBJ dcoDst(hdc);

    if (dcoDst.bValid())
    {
        if (!dcoDst.pdc->bInFullScreen())
        {
            COLORTRANSFORMOBJ CXFormObj;

            //
            // Create new color transform object.
            //
            hRet = CXFormObj.hCreate(dcoDst,
                                     pLogColorSpaceW,
                                     pvSrcProfile,
                                     cjSrcProfile,
                                     pvDstProfile,
                                     cjDstProfile,
                                     pvTrgProfile,
                                     cjTrgProfile);

            if (!hRet)
            {
                WARNING("GreCreateColorTransform fail to allocate object\n");
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        else
        {
            WARNING("GreCreateColorTransform(): hdc is full screen\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreCreateColorTransform(): hdc is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* NtGdiCreateColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE WINAPI
NtGdiCreateColorTransform(
    HDC              hdc,
    LPLOGCOLORSPACEW pLogColorSpaceW,
    PVOID            pvSrcProfile,
    ULONG            cjSrcProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile
    )
{
    HANDLE           hColorTransform = NULL;

    LOGCOLORSPACEW   KmLogColorSpaceW;

    HANDLE           hSecureSource = NULL;
    HANDLE           hSecureDestination = NULL;
    HANDLE           hSecureTarget = NULL;

    PVOID            pKmSrcProfile = NULL;
    PVOID            pKmDstProfile = NULL;
    PVOID            pKmTrgProfile = NULL;

    BOOL             bError = FALSE;

    ICMAPI(("NtGdiCreateColorTransform\n"));

    __try
    {
        if (pLogColorSpaceW)
        {
            //
            // Copy LOGCOLORSPACE
            //
            ProbeForRead(pLogColorSpaceW,sizeof(LOGCOLORSPACEW),sizeof(ULONG));
            RtlCopyMemory(&KmLogColorSpaceW,pLogColorSpaceW,sizeof(LOGCOLORSPACEW));
        }
        else
        {
            //
            // We need LOGCOLORSPACE, at least.
            //
            return (NULL);
        }

        //
        // Lock down client side mapped files.
        //
        if (pvSrcProfile && cjSrcProfile)
        {
            ProbeForRead(pvSrcProfile,cjSrcProfile,sizeof(BYTE));

            hSecureSource = MmSecureVirtualMemory(pvSrcProfile,cjSrcProfile,PAGE_READONLY);

            if (hSecureSource)
            {
                pKmSrcProfile = pvSrcProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock source profile\n");
                bError = TRUE;
            }
        }

        if (pvDestProfile && cjDestProfile)
        {
            ProbeForRead(pvDestProfile,cjDestProfile,sizeof(BYTE));

            hSecureDestination = MmSecureVirtualMemory(pvDestProfile,cjDestProfile,PAGE_READONLY);

            if (hSecureDestination)
            {
                pKmDstProfile = pvDestProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock destination profile\n");
                bError = TRUE;
            }
        }

        if (pvTargetProfile && cjTargetProfile)
        {
            ProbeForRead(pvTargetProfile,cjTargetProfile,sizeof(BYTE));

            hSecureTarget = MmSecureVirtualMemory(pvTargetProfile,cjTargetProfile,PAGE_READONLY);

            if (hSecureTarget)
            {
                pKmTrgProfile = pvTargetProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock target profile\n");
                bError = TRUE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiCreateColorTransform(): Fail to lock usermode parameters\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        bError = TRUE;
    }

    if (!bError)
    {
        //
        // Create Color Transform.
        //
        hColorTransform = GreCreateColorTransform(hdc,
                                                  &KmLogColorSpaceW,
                                                  pKmSrcProfile,
                                                  cjSrcProfile,
                                                  pKmDstProfile,
                                                  cjDestProfile,
                                                  pKmTrgProfile,
                                                  cjTargetProfile);

        if (!hColorTransform)
        {
            WARNING("GreCreateColorTransform() failed\n");
        }
    }

    if (hSecureSource)
    {
        MmUnsecureVirtualMemory(hSecureSource);
    }

    if (hSecureDestination)
    {
        MmUnsecureVirtualMemory(hSecureDestination);
    }

    if (hSecureTarget)
    {
        MmUnsecureVirtualMemory(hSecureTarget);
    }

    return (hColorTransform);
}

/******************************Public*Routine******************************\
* GreDeleteColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
*  Feb.21.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreDeleteColorTransform(
    HDC    hdc,
    HANDLE hColorTransform
    )
{
    ICMAPI(("GreDeleteColorTransform\n"));

    BOOL bRet = FALSE;

    //
    // Lock DC, call driver to delete color transform.
    // if the driver doesn't support this call, this is an
    // error
    //
    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //
    if (dcoDst.bValid())
    {
        if (dcoDst.pdc->bInFullScreen())
        {
            WARNING("GreCreateColorTransform(): hdc is full screen\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }
        else
        {
            COLORTRANSFORMOBJ CXFormObj(hColorTransform);

            if (CXFormObj.bValid())
            {
                //
                // Delete it
                //
                bRet = CXFormObj.bDelete(dcoDst);
            }
        }

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("ERORR GreGdiDeleteColorTransform called on invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiDeleteColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
*    5-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiDeleteColorTransform(
    HDC     hdc,
    HANDLE  hColorTransform
    )
{
    ICMAPI(("NtGdiDeleteColorTransform\n"));

    return (GreDeleteColorTransform(hdc,hColorTransform));
}

/******************************Public*Routine******************************\
* GreCheckBitmapBits
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreCheckBitmapBits(
    HDC            hdc,
    HANDLE         hColorTransform,
    DEVBITMAPINFO *pdbmi,
    PVOID          pvBits,
    PBYTE          paResults)
{
    ICMAPI(("GreCheckBitmapBits\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dco))
        {
            PDEVOBJ po(dco.hdev());

            if (po.bValid())
            {
                if (PPFNVALID(po, IcmCheckBitmapBits))
                {
                    //
                    // We need to pass driver's transform handle to driver.
                    //
                    COLORTRANSFORMOBJ CXFormObj(hColorTransform);

                    if (CXFormObj.bValid())
                    {
                        SURFMEM   SurfDimoTemp;

                        SurfDimoTemp.bCreateDIB(pdbmi,pvBits);

                        if (SurfDimoTemp.bValid())
                        {
                            //
                            // Call device driver.
                            //
                            bRet = (*PPFNDRV(po, IcmCheckBitmapBits))(
                                             po.dhpdev(),
                                             CXFormObj.hGetDeviceColorTransform(),
                                             SurfDimoTemp.pSurfobj(),
                                             paResults);
                        }
                    }
                }
                else
                {
                    WARNING("GreCheckBitmapBits called on device that does not support call\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                }
            }
        }

        dco.vUnlockFast();
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiCheckBitmapBits
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
NtGdiCheckBitmapBits(
    HDC       hdc,
    HANDLE    hColorTransform,
    PVOID     pvBits,
    ULONG     bmFormat,
    DWORD     dwWidth,
    DWORD     dwHeight,
    DWORD     dwStride,
    PBYTE     paResults)
{
    ICMAPI(("NtGdiCheckBitmapBits\n"));

    ULONG  ulBytesPerPixel;
    ULONG  ulSizeInByte;
    ULONG  ulSizeForResult;

    HANDLE hSecureBits = NULL;
    HANDLE hSecureRets = NULL;

    DEVBITMAPINFO dbmi;

    BOOL   bRet = TRUE;

    //
    // limitted support.
    //
    if (
        (bmFormat != BM_RGBTRIPLETS) || (dwHeight != 1)
       )
    {
        WARNING("NtGdiCheckBitmapBits(): Format is not supported, yet\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // So, far, we only support RGBTRIPLE format, and n x 1 bitmap.
    //
    ulBytesPerPixel = sizeof(RGBTRIPLE);
    ulSizeInByte    = ALIGN_DWORD(dwWidth * ulBytesPerPixel);
    ulSizeForResult = dwWidth;

    //
    // dwStride should be equal to ulSizeInByte,
    // because we should only has 1 height bitmap.
    //
    if (dwStride != ulSizeInByte)
    {
        WARNING("NtGdiCheckBitmapBits(): Format is not supported, yet\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // Fill up DEVBITMAPINFO
    //
    dbmi.iFormat  = BMF_24BPP;
    dbmi.cxBitmap = dwWidth;
    dbmi.cyBitmap = dwHeight;
    dbmi.cjBits   = ulSizeInByte;
    dbmi.hpal     = NULL;
    dbmi.fl       = 0;

    //
    // Lock down user mode memory for bitmap and result buffer
    //
    __try
    {
        ProbeForRead(pvBits,ulSizeInByte,sizeof(DWORD));
        ProbeForRead(paResults,ulSizeForResult,sizeof(BYTE));

        hSecureBits = MmSecureVirtualMemory(pvBits, ulSizeInByte, PAGE_READONLY);
        hSecureRets = MmSecureVirtualMemory(paResults, ulSizeForResult, PAGE_READWRITE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiCheckBitmapBits():Error in capture usermode memory\n");

        bRet = FALSE;
    }

    if (bRet && hSecureBits && hSecureRets)
    {
        bRet = GreCheckBitmapBits(hdc,hColorTransform,
                                  &dbmi,pvBits,
                                  (PBYTE)paResults);
    }

    if (hSecureBits)
    {
        MmUnsecureVirtualMemory(hSecureBits);
    }

    if (hSecureRets)
    {
        MmUnsecureVirtualMemory(hSecureRets);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiColorCorrectPalette
*
*   If this is a query operation then:
*       If the DC has ICM enabled NON_DEVICE and
*       the palette is not already color corrected then
*           Get the logical palette entries and return to app in array provided
*
*
*   If this is a set operation and the DC has ICM_NON_DEVICE and the palette
*   is ok then set the palette entries.
*
*   If this is a set operation and the DC is DEVICE then do nothing
*       --Maybe call device driver if it exports ICM calls
*
*
*  NOTE: if hpalette is moved to dcattr, then this routine can be
*      eliminated and done byt get/set palette entries from user mode
*
* Arguments:
*
* Return Value:
*
* History:
*
*    15-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiColorCorrectPalette(
    HDC             hdc,
    HPALETTE        hpal,
    ULONG           FirstEntry,
    ULONG           NumberOfEntries,
    PALETTEENTRY   *ppalEntry,
    ULONG           Command)
{
    ICMAPI(("NtGdiColorCorrectPalette\n"));

    DCOBJ   dcoDst(hdc);
    EPALOBJ pal((HPALETTE) hpal);

    ULONG ulRet = 0;

    if (dcoDst.bValid() && pal.bValid())
    {
        if ((NumberOfEntries == 0) ||
            (NumberOfEntries > pal.cEntries()) ||
            (FirstEntry > pal.cEntries()) ||
            ((FirstEntry + NumberOfEntries) > pal.cEntries()))
        {
            WARNING("NtGdiColorCorrectPalette(): Invalid parameter\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(ulRet);
        }

        if (IS_ICM_HOST(dcoDst.pdc->lIcmMode()))
        {
            if (Command == ColorPaletteQuery)
            {
                //
                // check palette for already colorcorrected flag
                //
                __try
                {
                    ProbeForWrite(ppalEntry,sizeof(PALETTEENTRY) * NumberOfEntries,sizeof(PALETTEENTRY));

                    //
                    // Get palette entries.
                    //
                    ulRet = pal.ulGetEntries(FirstEntry, NumberOfEntries, ppalEntry, FALSE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiColorCorrectPalette():Error in GetEntries\n");
                    ulRet = 0;
                }
            }
            else if (Command == ColorPaletteSet)
            {
                __try
                {
                    ProbeForRead(ppalEntry,sizeof(PALETTEENTRY) * NumberOfEntries,sizeof(PALETTEENTRY));

                    //
                    // Set palette entries.
                    //
                    ulRet = pal.ulSetEntries(FirstEntry, NumberOfEntries, ppalEntry);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiColorCorrectPalette():Error in SetEntries\n");
                    ulRet = 0;
                }
            }
        }
        else
        {
            WARNING("NtGdiColorCorrectPalette(): Invalid ICM mode\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        WARNING("NtGdiColorCorrectPalette(): Invalid hdc or hpal\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreGetDeviceGammaRampInternal
*
* History:
*
* Wrote it:
*  28.Jun.2000 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreGetDeviceGammaRampInternal(
    HDEV   hdev,
    LPVOID lpGammaRamp
    )
{
    BOOL bRet = FALSE;
    PDEVOBJ po(hdev);

    //
    // GetDeviceGammaRamp is only for display device.
    //
    if (po.bValid() && po.bDisplayPDEV())
    {
        //
        // Check color depth is not less than 8 bpp (need 256 color at least)
        //
        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            //
            // Check this PDEV has thier own GammaTable or not.
            //
            if (po.bHasGammaRampTable())
            {
                ICMMSG(("GreGetDeviceGammaRamp(): Use PDEV's GammaRamp Table\n"));

                //
                // Copy from PDEV's GammaRamp buffer.
                //
                RtlCopyMemory(lpGammaRamp,po.pvGammaRampTable(),MAX_COLORTABLE * sizeof(WORD) * 3);
            }
            else
            {
                ICMMSG(("GreGetDeviceGammaRamp(): Use default GammaRamp Table\n"));

                //
                // Fill up with ident. GammaRamp
                //
                LPWORD lpRed   = (LPWORD)lpGammaRamp;
                LPWORD lpGreen = (LPWORD)lpGammaRamp + MAX_COLORTABLE;
                LPWORD lpBlue  = (LPWORD)lpGammaRamp + MAX_COLORTABLE + MAX_COLORTABLE;

                //
                // Indent. GammaRamp is 0x0000 -> 0xFF00 for each R,G and B.
                // And LOBYTE is 0, only HIBYTE has value from 0 to 0xFF.
                //
                for (UINT i = 0; i < MAX_COLORTABLE; i++)
                {
                    lpRed[i] = lpGreen[i] = lpBlue[i] = (WORD)(i << 8);
                }
            }

            //
            // Filled up the buffer, return TRUE.
            //
            bRet = TRUE;
        }
        else
        {
            ICMMSG(("GreGetDeviceGammaRamp(): Surface is less than 8 bpp\n"));
        }
    }
    else
    {
        ICMMSG(("GreGetDeviceGammaRamp(): DC might not be display\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GreGetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreGetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("GreGetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // DC should not be info or meta DC.
        //
        if (dco.dctp() == DCTYPE_DIRECT)
        {
            DEVLOCKOBJ dlo;

            if (dlo.bLock(dco))
            {
                bRet = GreGetDeviceGammaRampInternal(dco.hdev(),lpGammaRamp);
            }
        }

        dco.vUnlockFast();
    }

    if (!bRet)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiGetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("NtGdiGetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    if (lpGammaRamp)
    {
        HANDLE hSecure = NULL;
        BOOL   bError  = FALSE;

        __try
        {
            ProbeForWrite(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(BYTE));
            hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READWRITE);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiGetDeviceGammaRamp: Fail to capture usermode buffer\n");
            bError = TRUE;
        }

        if ((bError == FALSE) && hSecure)
        {
            bRet = GreGetDeviceGammaRamp(hdc,lpGammaRamp);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreSetDeviceGammaRampInternal
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
*   2.Nov.1998 -by- Scott MacDonald [smac] Split it into two functions
\**************************************************************************/

BOOL
GreSetDeviceGammaRampInternal(
    HDEV    hdev,
    LPVOID  lpGammaRamp,
    BOOL    bDoRangeCheck
    )
{
    ICMAPI(("GreSetDeviceGammaRampInternal\n"));

    BOOL bRet = FALSE;
    PDEVOBJ po(hdev);

    //
    // GetDeviceGammaRamp is only for display device.
    //
    if (po.bValid() && po.bDisplayPDEV())
    {
        BOOL bUsePalette = FALSE;
        BOOL bValidBPP = FALSE;

        //
        // Check color depth is not less than 8 bpp (need 256 color at least)
        //
        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            if ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
                (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
            {
                //
                // Driver supports DrvSetDeviceGammaRamp()
                //
                bValidBPP = TRUE;
            }
            else
            {
                //
                // Driver does not suppprt it, but we can sinulate it
                // with palette only for 8 bpp case.
                //
                if ((po.iDitherFormat() == BMF_8BPP) && po.bIsPalManaged())
                {
                    //
                    // For 8 bpp surface, we can adjust color via
                    // palette on device if palettalized device.
                    //
                    bUsePalette = TRUE;
                    bValidBPP = TRUE;
                }
            }
        }
        else
        {
            //
            // Can not set GammaRamp for 1/4 bpp surface
            //
        }

        //
        // PDEV's bpp is suite for set GammaRamp ?
        //
        if (bValidBPP)
        {
            BOOL bNeedCallDriver = TRUE;
            BOOL bDefaultGammaRamp = !bDoRangeCheck;
            BOOL bSameGammaRamp = FALSE;

            if (po.bHasGammaRampTable())
            {
                //
                // If this PDEV is already has GammaRamp table, we will check
                // this is same as the table what we are going to set.
                //
                if (RtlCompareMemory(po.pvGammaRampTable(),
                                     lpGammaRamp,
                                     MAX_COLORTABLE * sizeof(WORD) * 3)
                    == (MAX_COLORTABLE * sizeof(WORD) * 3))
                {
                    //
                    // Same
                    //
                    bSameGammaRamp = TRUE;
                }
            }

            if (bSameGammaRamp)
            {
                ICMMSG(("GreSetDeviceGammaRamp(): Same GammaRamp is already selected\n"));

                //
                // Same GammaRamp is already selected, nothing need to do.
                //
                bRet = TRUE;
            }
            else
            {
                //
                // Scan the input GammaRamp to check within the range.
                //
                LPWORD lpRed   = (LPWORD)lpGammaRamp;
                LPWORD lpGreen = (LPWORD)lpGammaRamp + MAX_COLORTABLE;
                LPWORD lpBlue  = (LPWORD)lpGammaRamp + MAX_COLORTABLE + MAX_COLORTABLE;

                INT    iRange = (INT)(giIcmGammaRange);

                //
                // if we encounter any Gamma outside range, break!
                //
                for (UINT i = 0; ((i < MAX_COLORTABLE) && (bNeedCallDriver == TRUE)); i++)
                {
                    UINT iAveGamma = i;

                    UINT iRed   = (UINT)(lpRed[i]   >> 8);
                    UINT iGreen = (UINT)(lpGreen[i] >> 8);
                    UINT iBlue  = (UINT)(lpBlue[i]  >> 8);

                    INT iRangeMax = (INT)(iAveGamma + iRange);
                    INT iRangeMin = (INT)(iAveGamma - iRange);

                    ICMMSG(("iRangeMax = %x:iRangeMix = %x:iRed = %x:iGreen = %x:iBlue = %x\n",
                             iRangeMax,     iRangeMin,(INT)iRed,(INT)iGreen,(INT)iBlue));

                    if ((((INT)iRed   < iRangeMin) || ((INT)iRed   > iRangeMax) ||
                        ((INT)iGreen < iRangeMin) || ((INT)iGreen > iRangeMax) ||
                        ((INT)iBlue  < iRangeMin) || ((INT)iBlue  > iRangeMax)) &&
                        bDoRangeCheck)
                    {
                        //
                        // The Gamma is out of range, don't need call driver
                        //
                        bNeedCallDriver = FALSE;
                    }

                    //
                    // Check if the GammaRamp is ident. or not.
                    //
                    if (bDefaultGammaRamp &&
                        ((lpRed[i]   != (iAveGamma << 8)) ||
                         (lpGreen[i] != (iAveGamma << 8)) ||
                         (lpBlue[i]  != (iAveGamma << 8))))
                    {
                        ICMMSG(("GreSetDeviceGammaRamp():Not ident. GammaRamp\n"));

                        bDefaultGammaRamp = FALSE;
                    }
                }

                if (bNeedCallDriver)
                {
                    if (bUsePalette && bDefaultGammaRamp)
                    {
                        //
                        // If we will use palette, and GammaRamp are going to changed to
                        // default, we don't need to have GammaRamp table.
                        //
                        if (po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp (need update palette)\n"));

                            //
                            // The specified GammaRamp is ident., don't need to keep it.
                            //
                            po.bHasGammaRampTable(FALSE);
                            VFREEMEM(po.pvGammaRampTable());
                            po.pvGammaRampTable(NULL);
                        }
                        else
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp (no palette call)\n"));

                            //
                            // If we don't have GammaRamp table in PDEV, it means
                            // we are in defult already. So don't need to call driver
                            // (= don't need to update palette.)
                            //
                            bNeedCallDriver = FALSE;
                        }
                    }
                    else
                    {
                        //
                        // Check this PDEV has thier own GammaTable or not.
                        //
                        if (!po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp(): Allocate GammaRamp Table\n"));

                            //
                            // Allocate GammaRamp table for this PDEV
                            //
                            LPVOID pv = (LPVOID) PALLOCNOZ(MAX_COLORTABLE * sizeof(WORD) * 3,'mciG');

                            if (pv)
                            {
                                //
                                // Mark this PDEV has GammaTable.
                                //
                                po.pvGammaRampTable(pv);
                                po.bHasGammaRampTable(TRUE);
                            }
                            else
                            {
                                WARNING("GreSetDeviceGammaRamp():Fail to allocate GammaRamp table\n");

                                //
                                // Error, we don't need to call driver.
                                //
                                bNeedCallDriver = FALSE;
                            }
                        }
                    }

                    if (bNeedCallDriver)
                    {
                        if (po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Updating GammaRamp Table in PDEV...\n"));

                            //
                            // Save new GammaRamp into PDEV.
                            //
                            RtlCopyMemory(po.pvGammaRampTable(),lpGammaRamp,
                                          MAX_COLORTABLE * sizeof(WORD) * 3);
                        }

                        //
                        // Update GammaRamp on device using PDEV's GammaRamp Table.
                        //
                        bRet = UpdateGammaRampOnDevice(po.hdev(),TRUE);

                        if (bDefaultGammaRamp && po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp is setted (non-palette)\n"));

                            //
                            // The specified GammaRamp is ident., don't need to keep it.
                            //
                            po.bHasGammaRampTable(FALSE);
                            VFREEMEM(po.pvGammaRampTable());
                            po.pvGammaRampTable(NULL);
                        }
                    }
                    else
                    {
                        //
                        // Fail... couldn't call driver and return false.
                        //
                        bRet = FALSE;
                    }
                }
                else
                {
                    ICMMSG(("GreSetDeviceGammaRamp(): GammaRamp is out of range\n"));
                }
            }
        }
        else
        {
            ICMMSG(("GreSetDeviceGammaRamp(): Surface/Driver does not support loadable GammaRamp\n"));
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GreSetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreSetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp,
    BOOL    bDoRangeCheck
    )
{
    ICMAPI(("GreSetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // DC should not be info or meta DC.
        //
        if (dco.dctp() == DCTYPE_DIRECT)
        {
            DEVLOCKOBJ dlo;

            if (dlo.bLock(dco))
            {
                bRet = GreSetDeviceGammaRampInternal(dco.hdev(),
                                                     lpGammaRamp,
                                                     bDoRangeCheck);
            }
        }

        dco.vUnlockFast();
    }

    if (!bRet)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiSetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("NtGdiSetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    if (lpGammaRamp)
    {
        HANDLE hSecure = NULL;
        BOOL   bError  = FALSE;

        __try
        {
            ProbeForRead(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(BYTE));
            hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READONLY);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetDeviceGammaRamp: Fail to capture usermode buffer\n");
            bError = TRUE;
        }

        if ((bError == FALSE) && hSecure)
        {
            bRet = GreSetDeviceGammaRamp(hdc,lpGammaRamp,TRUE);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* cjGetLogicalColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

INT
cjGetLogicalColorSpace(
    HANDLE hColorSpace,
    INT    cjBuffer,
    LPVOID lpvBuffer
    )
{
    ICMAPI(("cjGetLogicalColorSpace\n"));

    INT cRet = 0;

    if (cjBuffer >= sizeof(LOGCOLORSPACEW) && (lpvBuffer != NULL))
    {
        COLORSPACEREF ColorSpace((HCOLORSPACE)hColorSpace);

        if (ColorSpace.bValid())
        {
            LPLOGCOLORSPACEW lpLogColorSpace = (LPLOGCOLORSPACEW)lpvBuffer;

            lpLogColorSpace->lcsSignature = ColorSpace.pColorSpace()->lcsSignature();
            lpLogColorSpace->lcsVersion   = ColorSpace.pColorSpace()->lcsVersion();
            lpLogColorSpace->lcsSize      = ColorSpace.pColorSpace()->lcsSize();
            lpLogColorSpace->lcsCSType    = ColorSpace.pColorSpace()->lcsCSType();
            lpLogColorSpace->lcsIntent    = ColorSpace.pColorSpace()->lcsIntent();

            ColorSpace.pColorSpace()->vGETlcsEndpoints(&lpLogColorSpace->lcsEndpoints);

            lpLogColorSpace->lcsGammaRed  = ColorSpace.pColorSpace()->lcsGammaRed();
            lpLogColorSpace->lcsGammaGreen= ColorSpace.pColorSpace()->lcsGammaGreen();
            lpLogColorSpace->lcsGammaBlue = ColorSpace.pColorSpace()->lcsGammaBlue();

            ColorSpace.pColorSpace()->vGETlcsFilename((PWCHAR)&lpLogColorSpace->lcsFilename[0],MAX_PATH);

            if (cjBuffer >= sizeof(LOGCOLORSPACEEXW))
            {
                PLOGCOLORSPACEEXW lpLogColorSpaceEx = (PLOGCOLORSPACEEXW)lpvBuffer;

                lpLogColorSpaceEx->dwFlags = ColorSpace.pColorSpace()->lcsExFlags();

                cRet = sizeof(LOGCOLORSPACEEXW);
            }
            else
            {
                cRet = sizeof(LOGCOLORSPACEW);
            }
        }
    }

    return cRet;
}

/******************************Public*Routine******************************\
* GreIcmQueryBrushBitmap
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreIcmQueryBrushBitmap(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits,
    ULONG       *pulBits,
    DWORD       *piUsage,
    BOOL        *pbAlreadyTran
)
{
    BOOL    bRet = FALSE;

    DWORD   iUsage = DIB_RGB_COLORS;
    BOOL    bAlreadyTran = FALSE;
    PBYTE   pDIBits = NULL;

    ULONG   ulSizeInfo = sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD));

    ICMAPI(("GreIcmQueryBrushBitmap\n"));

    if ((pbmiDIB == NULL) || (piUsage == NULL) || (pbAlreadyTran == NULL) || (pulBits == NULL))
    {
        return FALSE;
    }

    XDCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // ICM must be on, non-device mode only
        //
        if (dcoDst.pdc->bIsHostICM())
        {
            BRUSHSELOBJ bro((HBRUSH) hbrush);

            if (bro.bValid())
            {
                //
                // must be a DIB brush
                //
                if (bro.flAttrs() & BR_IS_DIB)
                {
                    //
                    // if brush was created with DIB_PAL_COLORS then
                    // ICM translation is not needed.
                    //
                    if ((iUsage = bro.iUsage()) == DIB_RGB_COLORS)
                    {
                        //
                        // see if translated DIB already exists
                        //
                        PBRUSH pbr = bro.pbrush();

                        if (pbr->hFindIcmDIB(dcoDst.pdc->hcmXform()) != NULL)
                        {
                            ICMMSG(("GreIcmQueryBrushBitmap() Find !\n"));

                            bAlreadyTran = TRUE;
                        }
                        else
                        {
                            ICMMSG(("GreIcmQueryBrushBitmap() Not Find, then create it!\n"));

                            bAlreadyTran = FALSE;

                            //
                            // Initialize BITMAPINFO header.
                            //
                            RtlZeroMemory(pbmiDIB,ulSizeInfo);
                            pbmiDIB->bmiHeader.biSize = sizeof(BITMAPINFO);

                            //
                            // get bits per pixel, could use this to determine if color table is needed
                            //
                            bRet = GreGetDIBitsInternal(hdc,
                                                        bro.hbmPattern(),
                                                        0,0,NULL,
                                                        pbmiDIB,
                                                        DIB_RGB_COLORS,
                                                        0,ulSizeInfo);

                            if (bRet)
                            {
                                ULONG cjBits = GreGetBitmapBitsSize(pbmiDIB);

                                if (cjBits == 0)
                                {
                                    //
                                    // Empty or overflow..
                                    //
                                    bRet = FALSE;
                                }
                                else if (pvBits == NULL)
                                {
                                    //
                                    // Caller want to know the size of bitmap.
                                    //
                                    *pulBits = cjBits;

                                    bRet = TRUE;
                                }
                                else if (cjBits <= *pulBits)
                                {
                                    //
                                    // We have enough memory to get bitmap bits.
                                    //
                                    bRet = GreGetDIBitsInternal(hdc,
                                                                bro.hbmPattern(),
                                                                0,
                                                                ABS(pbmiDIB->bmiHeader.biHeight),
                                                                (LPBYTE) pvBits,
                                                                pbmiDIB,
                                                                DIB_RGB_COLORS,
                                                                cjBits,
                                                                ulSizeInfo);

                                    //
                                    // Put used size.
                                    //
                                    *pulBits = cjBits;
                                }
                                else
                                {
                                    WARNING("GreIcmQueryBrushBitmap: the buffer is not enough\n");
                                }
                            }
                            else
                            {
                                WARNING("GreIcmQueryBrushBitmap: failed to GetDIBits\n");
                            }
                        }
                    }
                    else
                    {
                        ICMMSG(("GreIcmQueryBrushBitmap: brush is not DIB_RGB_COLORS\n"));
                    }
                }
                else
                {
                    ICMMSG(("GreIcmQueryBrushBitmap: brush is not DIBPATTERN\n"));
                }
            }
            else
            {
                WARNING("GreIcmQueryBrushBitmap: invalid brush\n");
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreIcmQueryBrushBitmap: invalid DC\n");
    }

    *piUsage = iUsage;
    *pbAlreadyTran = bAlreadyTran;

    return (bRet);
}

/******************************Public*Routine******************************\
* GreIcmSetBrushBitmap
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreIcmSetBrushBitmap(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits
)
{
    BOOL bRet = FALSE;

    ULONG ulSizeInfo = sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD));

    ICMAPI(("GreIcmSetBrushBitmap\n"));

    XDCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // ICM must be on, non-device mode only
        //
        if (dcoDst.pdc->bIsHostICM())
        {
            BRUSHSELOBJ bro((HBRUSH) hbrush);

            if (bro.bValid())
            {
                //
                // must be a DIB brush
                //
                if (bro.flAttrs() & BR_IS_DIB)
                {
                    //
                    // Create a new DIB for this brush based on
                    // the DC's hcmXform. The client must already
                    // have translated this DIB
                    //
                    PBRUSH pbr = bro.pbrush();

                    //
                    // try to create a new DIB
                    //
                    HBITMAP hDIB = GreCreateDIBitmapReal(
                                                  hdc,
                                                  CBM_INIT | CBM_CREATEDIB,
                                                  (PBYTE)pvBits,
                                                  pbmiDIB,
                                                  DIB_RGB_COLORS,
                                                  ulSizeInfo,
                                                  0x007fffff,
                                                  NULL,
                                                  0,
                                                  NULL,
                                                  CDBI_INTERNAL,
                                                  0,
                                                  NULL);

                    if (hDIB)
                    {
                        //
                        // Keep translate DIB in cache.
                        //
                        bRet = pbr->bAddIcmDIB(dcoDst.pdc->hcmXform(),hDIB);
                    }
                }
                else
                {
                    ICMMSG(("GreIcmSetBrushBitmap: brush is not DIBPATTERN\n"));
                }
            }
            else
            {
                WARNING("GreIcmSetBrushBitmap: invalid brush\n");
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreIcmSetBrushBitmap: invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiIcmBrushInfo
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiIcmBrushInfo(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits,
    ULONG       *pulBits,
    DWORD       *piUsage,
    BOOL        *pbAlreadyTran,
    ULONG        Command
    )
{
    BOOL   bRet = TRUE;

    HANDLE hSecureHeader = NULL;
    HANDLE hSecureBits = NULL;

    ULONG  cjHeader = (sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD)));
    ULONG  cjBits = 0;

    switch (Command)
    {
    case IcmQueryBrush:
    {
        BOOL   bAlreadyTran = FALSE;
        DWORD  iUsage = DIB_RGB_COLORS;

        __try
        {
            //
            // Capture user mode memories.
            //
            ProbeForWrite(pbmiDIB,cjHeader,sizeof(DWORD));
            hSecureHeader = MmSecureVirtualMemory(pbmiDIB,cjHeader,PAGE_READWRITE);

            if ((pvBits != NULL) && hSecureHeader)
            {
                //
                // Caller needs bitmap bits
                //
                ProbeForRead(pulBits,sizeof(ULONG),sizeof(ULONG));
                cjBits = *pulBits;

                ProbeForWrite(pvBits,cjBits,sizeof(DWORD));
                hSecureBits = MmSecureVirtualMemory(pvBits,cjBits,PAGE_READWRITE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiIcmBrushInfo - IcmQueryBrush failed copy usermode parameter\n");
            bRet = FALSE;
        }

        if (bRet && hSecureHeader && ((pvBits == NULL) || hSecureBits))
        {
            //
            // Get DIB brush bits.
            //
            bRet = GreIcmQueryBrushBitmap(hdc,
                                          hbrush,
                                          pbmiDIB,
                                          pvBits,
                                          &cjBits,
                                          &iUsage,
                                          &bAlreadyTran);
        }

        if (bRet)
        {
            __try
            {
                ProbeForWrite(pulBits,sizeof(ULONG),sizeof(ULONG));
                *pulBits = cjBits;

                if (pbAlreadyTran)
                {
                    ProbeForWrite(pbAlreadyTran,sizeof(BOOL), sizeof(BOOL));
                    *pbAlreadyTran = bAlreadyTran;
                }

                if (piUsage)
                {
                    ProbeForWrite(piUsage,sizeof(DWORD), sizeof(DWORD));
                    *piUsage = iUsage;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                 WARNING("NtGdiIcmBrushInfo failed copy usermode parameter\n");
                 bRet = FALSE;
            }
        }

        break;
    }

    case IcmSetBrush:
    {
        __try
        {
            //
            // Lock down header memory.
            //
            ProbeForRead(pbmiDIB,cjHeader,sizeof(DWORD));
            hSecureHeader = MmSecureVirtualMemory(pbmiDIB,cjHeader,PAGE_READWRITE);

            ProbeForRead(pulBits,sizeof(ULONG),sizeof(ULONG));
            cjBits = *pulBits;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiIcmBrushInfo - IcmSetBrush failed copy usermode parameter\n");
            bRet = FALSE;
        }

        if (bRet && hSecureHeader)
        {
            //
            // Compute bitmap size.
            //
            ULONG cjBitsNeeded = GreGetBitmapBitsSize(pbmiDIB);

            if ((cjBitsNeeded == 0) || (cjBitsNeeded > cjBits))
            {
                WARNING1("NtGdiIcmBrushInfo - IcmSetBrush bitmap size is wrong\n");
                bRet = FALSE;
            }
            else
            {
                __try
                {
                    //
                    // Lock Bits.
                    //
                    ProbeForRead(pvBits,cjBitsNeeded,sizeof(DWORD));
                    hSecureBits = MmSecureVirtualMemory(pvBits,cjBitsNeeded,PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiIcmBrushInfo - IcmSetBrush failed lock pvBits\n");
                    bRet = FALSE;
                }

                if (bRet && hSecureBits)
                {
                    //
                    // Set brush DIB bits.
                    //
                    bRet = GreIcmSetBrushBitmap(hdc,
                                                hbrush,
                                                pbmiDIB,
                                                pvBits);
                }
            }
        }

        break;
    }

    default:

        WARNING("NtGdiIcmBrushInfo(): unknown command\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }

    //
    // Unlock user mode memory if locked.
    //
    if (hSecureHeader)
    {
        MmUnsecureVirtualMemory(hSecureHeader);
    }

    if (hSecureBits)
    {
        MmUnsecureVirtualMemory(hSecureBits);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* bInitIcm
*
*   Init ICM information
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    9/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL bInitICM()
{
    ICMAPI(("bInitIcm\n"));

    BOOL bRet = TRUE;

    //
    // Read ICM configuration.
    //
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS NtStatus;

    ULONG iIcmControlFlag = 0;

    //
    // read icm global configuration.
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = (RTL_QUERY_REGISTRY_DIRECT |
                           RTL_QUERY_REGISTRY_REQUIRED);
    QueryTable[0].Name = (PWSTR)L"GdiIcmControl";
    QueryTable[0].EntryContext = (PVOID) &iIcmControlFlag;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = (PWSTR)NULL;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"ICM",
                                      QueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("Error reading GdiIcmControl (Optional, Not Error)\n");
        iIcmControlFlag = 0L;
    }

    //
    // NOTE: After sRGB.icm become really default.
    //
    if (!(iIcmControlFlag & ICM_CONTROL_WIN95_COLORSPACE))
    {
        //
        // Configure default colorspace to sRGB.
        //
        gcsStockColorSpace.lcsCSType = LCS_sRGB;

        //
        // Set sRGB color profile name.
        //
        wcscpy(gcsStockColorSpace.lcsFilename,sRGB_PROFILENAME);
    }

    //
    // Next, try to read GammaRange
    //

    //
    // Initialize with default value.
    //
    giIcmGammaRange = 0x80; // Plus/Minus 128 is allowable by default.

    QueryTable[0].Name = (PWSTR)L"GdiIcmGammaRange";
    QueryTable[0].EntryContext = (PVOID) &giIcmGammaRange;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"ICM",
                                      QueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("Error reading GdiIcmGammaRange (Optional, Not Error)\n");
        giIcmGammaRange = 0x80; // Plus/Minus 128 is allowable by default.
    }

    //
    // Validate the value
    //
    if (giIcmGammaRange > 256)
    {
        giIcmGammaRange = 256;
    }

    #if HIDEYUKN_DBG
    DbgPrint("GDI:IcmControlFlag = %x\n",iIcmControlFlag);
    DbgPrint("GDI:IcmGammaRange  = %x\n",giIcmGammaRange);
    #endif

    //
    // Create Logical Color Space StockObject.
    //
    LOGCOLORSPACEEXW LogColorSpaceExW;

    LogColorSpaceExW.lcsColorSpace = gcsStockColorSpace;
    LogColorSpaceExW.dwFlags       = 0;

    HCOLORSPACE hColorSpace = GreCreateColorSpace(&LogColorSpaceExW);

    if (hColorSpace)
    {
        //
        // Set Owner of color space.
        //
        HmgSetOwner((HOBJ)hColorSpace, OBJECT_OWNER_PUBLIC, ICMLCS_TYPE);

        //
        // Mark the object is undeletable
        //
        HmgMarkUndeletable((HOBJ)hColorSpace,ICMLCS_TYPE);

        //
        // Set this colorspace to stock object.
        //
        bSetStockObject(hColorSpace,PRIV_STOCK_COLORSPACE);

        //
        // Keep stcok object to global
        //
        ghStockColorSpace = (HCOLORSPACE)GreGetStockObject(PRIV_STOCK_COLORSPACE);

        //
        // Lock color space to increment ref. count. (never become zero !)
        //
        gpStockColorSpace = (PCOLORSPACE)HmgShareLock((HOBJ)ghStockColorSpace,ICMLCS_TYPE);

        //
        // Initialize default DC_ATTR and DCLEVEL.
        //
        DcAttrDefault.hColorSpace  = ghStockColorSpace;
        dclevelDefault.pColorSpace = gpStockColorSpace;

        if (gpStockColorSpace == NULL)
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\lfntobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: lfntobj.cxx
*
* Non-inline methods for logical font objects.
*
* Created: 30-Oct-1990 09:32:48
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "winsta.h"

extern PW32PROCESS gpidSpool;

extern "C" USHORT gProtocolType;
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)

/******************************Public*Routine******************************\
* GreSetLFONTOwner
*
* Set the owner of the LFONT
*
\**************************************************************************/

BOOL
GreSetLFONTOwner(
    HLFONT hlfnt,
    W32PID  lPid)
{
    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return(HmgSetOwner((HOBJ)hlfnt, lPid, LFONT_TYPE));
}

/******************************Public*Routine******************************\
* LFONTOBJ::LFONTOBJ (HLFONT hlfnt, PDEVOBJ * ppdo)
*
* Constructor for a logical font user object.
*
* This constructor is a little trickier than most because the handle coming
* in may reference one of the "aliased" stock fonts.  These stock fonts, rather
* than representing a single "wish list" of attributes, represent a set of
* such lists.  Which member of the set is being referenced is determined by
* the calling application's default display or PDEV (i.e., we ask the PDEV
* for the real HLFONT handle).
*
* The strategy is the constructor locks the handle passed in and checks the
* type.  If its not an aliased LFONT, then we're done.  If it is an aliased
* font, the aliased HLFONT handle is released and a PDEVOBJ is queried for
* the appropriate HFLONT handle to lock.
*
* History:
*  Thu 23-Sep-1993 -by- Patrick Haluptzok [patrickh]
* SSS
*
*  30-Oct-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LFONTOBJ::LFONTOBJ (HLFONT hlfnt, PDEVOBJ* ppdo)
{
    plfnt = (PLFONT) HmgShareLock((HOBJ)hlfnt, LFONT_TYPE);

    //
    // Check for aliased LFONT.
    //

    if ((plfnt != NULL) && (plfnt->fl & LF_FLAG_ALIASED))
    {
        HDEV hDev = UserGetHDEV();

        //
        // This is an aliased font.  Save type.
        //

        LFTYPE lftSave = plfnt->lft;

        // Release the aliased LFONT.

        DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(plfnt);

        plfnt = NULL;

        PDEVOBJ pdo(hDev);

        if (!ppdo)
        {
            ppdo = &pdo;
        }

        if (ppdo->bValid())
        {
            //
            // Grab appropriate HLFONT from the PDEV.
            //

            switch (lftSave)
            {

            case LF_TYPE_DEVICE_DEFAULT:
                hlfnt = ppdo->hlfntDefault();
                break;

            case LF_TYPE_ANSI_FIXED:
                hlfnt = ppdo->hlfntAnsiFixed();
                break;

            case LF_TYPE_ANSI_VARIABLE:
                hlfnt = ppdo->hlfntAnsiVariable();
                break;

            default:
                RIP("LFONTOBJ has invalid type for aliased font");
            }

            plfnt = (PLFONT) HmgShareLock((HOBJ)hlfnt, LFONT_TYPE);
        }
    }
}

/******************************Public*Routine******************************\
* LFONTOBJ::ppfeMapFont
*
* Note:
*   RFONTOBJ constructor, which is the only function (so far) to call
*   this, grabs the ghsemPublicPFT semaphore prior to calling this to
*   make PFT tree stable before scanning it during mapping.
*
* Returns:
*   Handle to a realized font (HRFONT) that is a close or exact match to
*   this logical font.  HRFONT_INVALID returned if an error occurs.
*
* History:
*  24-Sept-1996  -by-  Xudong Wu  [TessieW]
* If a suitable pfe found in map cache, we still need to check whether the
* current process has the right to map the font.
*
*  11-Dec-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFE *LFONTOBJ::ppfeMapFont (
    XDCOBJ& dco,
    FLONG  *pflSim,
    POINTL *pptlSim,
    FLONG  *pflAboutMatch,
    BOOL    bIndexFont
    )
{
    int i; // index into mapcache array
    MAPCACHE*  mapcache = plfnt->mapcache;
    PFE*           ppfe = PPFENULL;  // return value
    MATRIX&        matrix = dco.pdc->mxWorldToDevice();
    HDEV           hdev = dco.hdev();
    ULONG iBitmapFormat = 0;    // important in anti-aliased case
    FLONG        flGray = 0;

    #if DBG
    if (gflFontDebug & DEBUG_PPFEMAPFONT)
    {
        KdPrint(("Font Mapping: \"%ws\" hlfnt = %p hdc = %p\n",plfnt->wcCapFacename, hlfnt(),dco.hdc()));
        KdBreakPoint();
    }
    #endif


// If we are in a path bracket, we never look in the map cache (the mapping
// is also never put in the cache).  We'll just run the font mapper.  We
// could cache path bracketed font mappings, but we would have to add a flag
// or type to the MAPCACHE structure and add an extra comparison inside the
// mapcache scanning loop.  Since we currently consider text in paths to be
// the exception rather than the rule, we have decided not eat the cost of
// of the extra compare in the pathological case rather than in the common
// case.

    if (!dco.pdc->bActive())
    {
        // If anitaliasing is requested and possible then set FO_GRAY16 in flGray

        BYTE jQual = plfw()->lfQuality;
        if (dco.bDisplay() || dco.dctp() == DCTYPE_MEMORY)
        {
            if
            (
                ((gulFontInformation & FE_AA_ON) && jQual != NONANTIALIASED_QUALITY) ||
                (jQual == ANTIALIASED_QUALITY) || (jQual == CLEARTYPE_QUALITY) || (jQual == CLEARTYPE_NATURAL_QUALITY)
            )
            {
		// WINBUG 152724 07/31/2000 claudebe
		// Terminal server now allow more than 256 colors. Text antialiazing rendered on the server is very slow.
		// We decided for Whistler to turn off text antialiazing under terminal client session.
		// For Blackcomb we will provide the terminal server team with a text antialiazing library that they can use on the 				// client to generate text antialiazing on the client.
 
                if  (!IsRemoteConnection() && (dco.pdc->bHasSurface()))
                {
                    // Acquire the handle manager lock while we look at the
                    // surface to protect against dynamic mode changing.

                    MLOCKFAST mo;

                    switch ( iBitmapFormat = dco.pdc->pSurface()->so.iBitmapFormat )
                    {
                    case BMF_16BPP:
                    case BMF_24BPP:
                    case BMF_32BPP:

                        flGray = FO_GRAY16; // request antialiased font
                        if ( jQual == CLEARTYPE_NATURAL_QUALITY )
                            flGray |= FO_CLEARTYPENATURAL_X | FO_CLEARTYPE_X;
                        else if ((jQual == CLEARTYPE_QUALITY) || (gulFontInformation & FE_CT_ON))
                            flGray |= FO_CLEARTYPE_X;

                        break;

                    default:

                        break;
                    }
                }
            }
        }

        // Scan the map cache for a suitable mapping.
        // Skip the cache if it is glyph index.

        if (!bIndexFont)
        {
            for ( i = 0; i < plfnt->cMapsInCache; i += 1)
            {
            // For a mapping to be suitable, the device must match AND
            // the transforms (neglecting translation) must match.
            // There are more restrictions for antialiased text (see below)

                if ( (hdev == mapcache[i].hdev)          &&
                     (mapcache[i].efM11 == matrix.efM11) &&
                     (mapcache[i].efM12 == matrix.efM12) &&
                     (mapcache[i].efM21 == matrix.efM21) &&
                     (mapcache[i].efM22 == matrix.efM22)
                   )
                {
                   // We found it.  Check that it's still valid.

                    HPFECOBJ pfecobj(mapcache[i].hpfec);
                    PFEOBJ pfeo(pfecobj.GetPFE(mapcache[i].iFont));
                    if ( !pfeo.bValid() )
                    {
                        WARNING1("Invalid ppfe in mapping cache\n");
                    }
                    else
                    {
                        // The cached notional to device transform is unchanged.
                        // The cached mapping is good if:
                        //
                        //
                        // A. the application is requesting antialiased text and
                        // the cached text was also requested to be antialiased
                        // Moreover, in the antialiased case, the bitmap format
                        // must be the same.

                        //                       or
                        //
                        // B. the application is not requesting antialiasing
                        // and the cached text was not requested to be antialiased

                        // Need to check whether the current process has the right
                        // to mapping the font.

                        if (pfeo.bEmbPvtOk() || (gpidSpool == (PW32PROCESS)W32GetCurrentProcess()))
                        {
                            if ( flGray )   // requesting antialiased text?
                            {   // yes
                                if ((mapcache[i].flSim & (FO_GRAY16 | FO_CLEARTYPE_X)) == flGray)
                                {   // yes
                                    if (iBitmapFormat == mapcache[i].iBitmapFormat) // same format?
                                    {   // yes
                                        ppfe = pfeo.ppfeGet();      // cached mapping is good
                                    }
                                }
                            }
                            else if ( !(mapcache[i].flSim & FO_GRAY16) )
                            {
                                ppfe = pfeo.ppfeGet();
                            }
                        }
                    }
                    if ( ppfe ) // cached mapping good?
                    {   // yes -- update simulation flags
                        *pflSim        = mapcache[i].flSim;
                        pptlSim->x     = mapcache[i].ptlSim.x;
                        pptlSim->y     = mapcache[i].ptlSim.y;
                        *pflAboutMatch = mapcache[i].flAboutMatch;
                        break;
                    }
                    else
                    {   // cached mapping is not good
                        // Remove the mapping so we don't run into it again.

                        if ( (i+1) < plfnt->cMapsInCache )
                        {
                            RtlMoveMemory
                            (
                                (PVOID) &mapcache[i],
                                (PVOID) &mapcache[i+1],
                                (UINT) (((PBYTE) &mapcache[plfnt->cMapsInCache]) - ((PBYTE) &mapcache[i+1]))
                            );
                        }

                        plfnt->cMapsInCache -= 1;   // correct the map count

                        // current position is no longer a rejected candidate,
                        // so go back one index

                        i -= 1;
                    }
                }
            }
        }
    }
    if ( !ppfe )
    {
        // Call the font mapper with the Win 3.1 compatible weighting and max
        // penalties.  If the LOGFONT is a stock object, transforms are ignored
        // (i.e., the LOGFONT is implied to be in pixel coordinates (MM_TEXT)).
        //
        // The result is stuffed into the map cache if we are not in a
        // path bracket.
        //
        // Note. ppfeGetAMatch() modifies sets FO_SIM_BOLD and FO_SIM_ITALIC
        //       in *pflSim as is necessary -- it does not set FO_GRAY16
        //       which is set in this routine after this call.

        ppfe = ppfeGetAMatch(
                   dco,
                   pelfw(),
                   plfnt->wcCapFacename,
                   ULONG_MAX-1,
                   (plfnt->fl & LF_FLAG_STOCK) ? FM_BIT_PIXEL_COORD : 0,
                   pflSim,
                   pptlSim,
                   pflAboutMatch,
                   bIndexFont
               );
        PFEOBJ pfeo(ppfe);
        if ( !pfeo.bValid() )
        {
            RIP("Bad return value from ppfeGetAMatch\n");
        }
        else if (!dco.pdc->bActive())
        {
            ASSERTGDI( !(*pflSim & FO_GRAY16), "ppfeGetAMatch erroneously set FO_GRAY16\n");

            // If the application is requesting antialiased text and the font is
            // capable then we set the FO_GRAY16 bit in *pflSim. Note that this
            // does not guarantee that the font driver will antialiase the text
            // only that GDI will suggest to the font driver that the font
            // be antialiased.

            if (flGray && (pfeo.pifi()->flInfo & FM_INFO_4BPP))
            {
                *pflSim |= FO_GRAY16;

                if
                (
                //  (dco.flGraphicsCaps2() & GCAPS2_CLEARTYPE_X) && // commented out only for now
                    (dco.bDisplay() || (dco.dctp() == DCTYPE_MEMORY)) &&
                    dco.pdc->bHasSurface()                            &&
                    (pfeo.pifi()->flInfo & FM_INFO_TECH_TRUETYPE)     && // to be removed if ps fonts start supporting ClearType
                    (pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality != ANTIALIASED_QUALITY) &&
                    ((pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_QUALITY) || 
                     (pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_NATURAL_QUALITY) || 
					 ((gulFontInformation & FE_CT_ON) && (gulFontInformation & FE_AA_ON)))
                )
                {
                	if(pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_NATURAL_QUALITY)
                    	*pflSim |= FO_CLEARTYPENATURAL_X | FO_CLEARTYPE_X;
                	else
                    	*pflSim |= FO_CLEARTYPE_X;
                }
            }

            // Not in cache, so do the map and put it in the cache
            // if it is not glyph index.

            if (!bIndexFont)
            {
                // Check to see if we are past the max. number of cached mappings.
                // If the limit is exceeded, flush the cache by resetting the
                // the count.

                if (i >= MAXCACHEENTRIES)
                {
                    i = plfnt->cMapsInCache = 0;
                }

                // Update cache information for the new mapping.

                mapcache[i].hpfec         = pfeo.hpfecGet();
                mapcache[i].iFont         = pfeo.iFont();
                mapcache[i].hdev          = hdev;
                mapcache[i].flSim         = *pflSim;
                mapcache[i].ptlSim.x      = pptlSim->x;
                mapcache[i].ptlSim.y      = pptlSim->y;
                mapcache[i].efM11         = matrix.efM11;
                mapcache[i].efM12         = matrix.efM12;
                mapcache[i].efM21         = matrix.efM21;
                mapcache[i].efM22         = matrix.efM22;
                mapcache[i].flAboutMatch  = *pflAboutMatch;
                mapcache[i].iBitmapFormat = iBitmapFormat;
                plfnt->cMapsInCache      += 1;
            }
        }
    }

// if successfull, update the charset and code page info in the dc:

    if (ppfe)
    {
    // new font mapping may have occurred as a result of w->d xform change,
    // GraphicsMode change. Also when this routine is called from
    // RFONTOBJ::bInit, the new mapping may have occured as a result of
    // asking for pathobj instead of bitmap realization. In other words
    // It is not necessary at this point to have DIRTY_CHARSET bit set,
    // (which only happens when a new logfont is selected in the DC).
    // Any of these factors could cause the change of the font selected
    // in the dc and therefore also of the corresponding CodePage i.e. CharSet.

    #if 0
        if (!(dco.ulDirty() & DIRTY_CHARSET))
        {
            if (dco.pdc->iCS_CP() != (*pflAboutMatch >> 8))
            {
                DbgPrint("ppfe: 0x%p, iCS_CP: 0x%lx, flAboutMatch: 0x%p\n",
                          ppfe, dco.pdc->iCS_CP(), *pflAboutMatch);
                RIP("ppfeMapFont, dco.pdc->iCS_CP is bogus\n");
            }
        }
    #endif

#ifdef FE_SB

    // If font association is turned on for this character set then we need
    // to force the code page to ANSI so that ANSI apps can get a the DBCS
    // in the font via ANSI api's.  We do this unless the user has set the
    // override bit in the LOGFONT.

        if(fFontAssocStatus &&
           !(plfw()->lfClipPrecision & CLIP_DFA_OVERRIDE))
        {
            UINT Charset = (*pflAboutMatch >> 24) & 0xFF;

            if((Charset == ANSI_CHARSET && fFontAssocStatus & ANSI_ASSOC) ||
               (Charset == OEM_CHARSET && fFontAssocStatus & OEM_ASSOC))

            //   (Charset == OEM_CHARSET && fFontAssocStatus & OEM_ASSOC)   ||
            //  we might want to keep the codepage as CP_SYMBOL??????
            //  (Charset == SYMBOL_CHARSET && fFontAssocStatus & SYMBOL_ASSOC))

            {
                USHORT AnsiCodePage, OemCodePage;
                RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

                *pflAboutMatch = (*pflAboutMatch & 0xFF0000FF) | (AnsiCodePage << 8);

            }
        }
#endif

        dco.pdc->iCS_CP(*pflAboutMatch >> 8);

    // clean the DIRTY_CHARSET bit

        dco.ulDirtySub(DIRTY_CHARSET);
    }

    return (ppfe);
}

#if DBG
/******************************Public*Routine******************************\
* VOID LFONTOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID LFONTOBJ::vDump ()
{
    DbgPrint("\nContents of LFONT, HLFONT = 0x%lx\n", hlfnt());

    if (hlfnt() == STOCKOBJ_SYSFONT)
        DbgPrint("S Y S T E M   F O N T \n");
    if (hlfnt() == STOCKOBJ_SYSFIXEDFONT)
        DbgPrint("S Y S T E M   F I X E D   F O  N T \n");
    if (hlfnt() == STOCKOBJ_OEMFIXEDFONT)
        DbgPrint("O E M   F I X E D   F O N T \n");
    if (hlfnt() == STOCKOBJ_DEFAULTDEVFONT)
        DbgPrint("D E V I C E   D E F A U L T   F O N T \n");
    if (hlfnt() == STOCKOBJ_ANSIFIXEDFONT)
        DbgPrint("A N S I   F I X E D   F O N T \n");
    if (hlfnt() == STOCKOBJ_ANSIVARFONT)
        DbgPrint("A N S I   V A R I A B L E   F O N T \n");
    if (hlfnt() == STOCKOBJ_DEFAULTGUIFONT)
        DbgPrint("D E F A U L T   G U I   F O N T \n");

    DbgPrint("LOGFONT \n");
    DbgPrint("    lfHeight   = %d\n", plfnt->elfw.elfLogFont.lfHeight);
    DbgPrint("    lfWidth    = %d\n", plfnt->elfw.elfLogFont.lfWidth);
    DbgPrint("    lfFaceName = %ws\n", plfnt->elfw.elfLogFont.lfFaceName);
    DbgPrint("\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


SRCBASE=ntos\w32

PUBLICINCS=

TARGET_H_DIRECTORY=$(TARGET_DIRECTORY)

PRIVATEINCS= $(NTGDI_PATH)\gre\hmgr.h                \
             $(NTGDI_PATH)\gre\patblt.hxx            \
             $(NTGDI_PATH)\gre\xformobj.hxx          \
             $(NTGDI_PATH)\gre\engine.hxx            \
             $(NTGDI_PATH)\gre\epointfl.hxx          \
             $(NTGDI_PATH)\gre\rfntobj.hxx

$(O)\geninc.cxx:                                                            \
		       ..\$(TARGET_DIRECTORY)\geninc.m4                     \
		       ..\$(TARGET_H_DIRECTORY)\geninc.m4
    set PASS0ONLY=
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) -DNTGDI_PATH=$(NTGDI_PATH) < ..\$(TARGET_DIRECTORY)\geninc.m4              \
                            > $@


$(O)\gdi$(TARGET_DIRECTORY).$(ASM_INCLUDE_SUFFIX):			     \
		       $(O)\geninc.cxx                                       \
		       $(PUBLICINCS)					     \
		       $(PRIVATEINCS)					     \
		       $(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
# Create the destination if it doesn't exit.
# Possible if compiling for axp64.
    if not exist $(O) mkdir $(O)
    nmake $(O)\geninc.obj USE_MSVCRT=1 NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx $(O)\geninc.obj -s$(ASM_INCLUDE_SUFFIX) -o$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\hmgrapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: hmgrapi.cxx
*
* Handle manager API entry points
*
* Created: 08-Dec-1989 23:03:03
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// Synchronization of the handle manager
//

HSEMAPHORE ghsemHmgr;


PDEVCAPS gpGdiDevCaps = NULL;

//
// Points to shared memory including handle table and cfont cache
//

PGDI_SHARED_MEMORY gpGdiSharedMemory;

//
// Points to handle array
//

ENTRY      *gpentHmgr=NULL;

//
// Free List of handles
//

HOBJ       ghFreeHmgr;

//
// Max handle alloced so far
//

ULONG      gcMaxHmgr;

//
// Look aside list headers and maximum allowed entry-size array

PPAGED_LOOKASIDE_LIST pHmgLookAsideList[MAX_TYPE + 1];
ULONG laSize[MAX_TYPE + 1];
#define HMG_LAL_TAG '0alG'

//
//
//

extern "C"
{
    HFASTMUTEX ghfmMemory;
}


PVOID  gpHmgrSharedHandleSection;

//
// 10 millisecond wait value
//
// We only have a pointer to it since it must be allocated out of Non-paged
// pool
//

PLARGE_INTEGER gpLockShortDelay;

//
// Hydra session flag
//
// Note that this only has bearing on whether process is a hydra session
// or not.  It is possible to not be a hydra session, but still be a
// a hydra server (check gIsTerminalServer for that information).
//
// Value is TRUE if not a hydra session.
// Value is FALSE if a hydra session.
//

extern BOOL G_fConsole;

//
// Short term temporary buffer that can be used to put large
// objects for which we have no place in the stack.
//
// The value should only be used through the Alloc\FreeTmpBuffer functions
//

#define TMP_GLOBAL_BUFFER_SIZE 0x1000


PVOID *gpTmpGlobalFree;
PVOID  gpTmpGlobal = NULL;

//
// Prototype for a handy debugging routine.
//

#if DBG

    extern "C"
    VOID
    HmgPrintBadHandle(
        HOBJ    hobj,
        OBJTYPE objt
        );

#else

    #define HmgPrintBadHandle(hobj, objt)

#endif

//
// During initialization, some things which are really really bad
// (like not being able to allocate the handle manager table) and
// we RIP because we cannot proceed and its completely unexpected.
//
// However, on a Hydra system, some of these are things we need
// to expect.  So what would be a RIP on a non-Hydra system can
// be treated as a WARNING on a Hydra system
//

#if DBG
    #define NONHYDRA_RIP(a) \
    {                       \
        if (G_fConsole)     \
            RIP(a);         \
        else                \
            WARNING(a);     \
    }
#else
    #define NONHYDRA_RIP(a)
#endif

/**************************************************************************\
 *
 * Fast tempporary memory allocator
 *
\**************************************************************************/


PVOID
AllocFreeTmpBuffer(
    ULONG size)
{
    PVOID tmpPtr = NULL;

    if (size <= TMP_GLOBAL_BUFFER_SIZE)
    {
        tmpPtr = (PVOID) InterlockedExchangePointer((PVOID *)gpTmpGlobalFree, 0);
    }

    if (!tmpPtr)
    {
        WARNING1("GRE : Fast Memory allocator failed\n");
        tmpPtr = PALLOCNOZ(size, 'pmTG');
    }

    return tmpPtr;
}

VOID
FreeTmpBuffer(
    PVOID pv)
{
    if (pv == gpTmpGlobal)
    {
         ASSERTGDI(*gpTmpGlobalFree == NULL, "GRE: gpTmpGlobalFree is inconsistent\n");
         *gpTmpGlobalFree = pv;
    }
    else
    {
        VFREEMEM(pv);
    }
}


/**************************************************************************\
 *
 * Performance, hit rate, memory size statistics
 *
\**************************************************************************/

#if DBG
#define GDI_PERF 1
#endif

#if GDI_PERF

extern "C"
{
// these must be extern "C" so the debugger extensions can see them

    ULONG HmgCurrentNumberOfObjects[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfObjects[MAX_TYPE + 1];
    ULONG HmgCurrentNumberOfLookAsideObjects[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfLookAsideObjects[MAX_TYPE + 1];
    ULONG HmgNumberOfObjectsAllocated[MAX_TYPE + 1];
    ULONG HmgNumberOfLookAsideHits[MAX_TYPE + 1];

    ULONG HmgCurrentNumberOfHandles[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfHandles[MAX_TYPE + 1];
    ULONG HmgNumberOfHandlesAllocated[MAX_TYPE + 1];
};

#endif

/*****************************Exported*Routine*****************************\
* HmgCreate()
*
* Initializes a new handle manager.
*
* History:
*
*  Mon 14-Apr-1997 -by- Dan Almosnino [danalm]
* Modified Lookaside initialization to use DaveC S-Lists
* and set the allowable object size on the list based on memory model
*
*  Wed 29-Apr-1992 -by- Patrick Haluptzok [patrickh]
* Change to mutex for exclusion, init event here.
*
*  Mon 21-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Reserve memory for the handle table so unlock doesn't need semaphore.
*
*  Mon 08-Jul-1991 -by- Patrick Haluptzok [patrickh]
* make 0 an invalid handle
*
*  Sun 20-Jun-1991 -by- Patrick Haluptzok [patrickh]
* The hheap has gone away, the correct error codes are logged.
*
*  30-Nov-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL HmgCreate()
{

    ULONG ulType;
    ULONG Size;
    BOOL  LargeSystemSize = FALSE;

#if 0

    KdPrint(("                MASK      CBITS  SHIFT\n"));
    KdPrint(("INDEX      = 0x%8.8lx, %3d   %3d \n",INDEX_MASK     ,INDEX_BITS     ,INDEX_SHIFT));
    KdPrint(("TYPE       = 0x%8.8lx, %3d   %3d \n",TYPE_MASK      ,TYPE_BITS      ,TYPE_SHIFT ));
    KdPrint(("ALTTYPE    = 0x%8.8lx, %3d   %3d \n",ALTTYPE_MASK   ,ALTTYPE_BITS   ,ALTTYPE_SHIFT ));
    KdPrint(("STOCK      = 0x%8.8lx, %3d   %3d \n",STOCK_MASK     ,STOCK_BITS     ,STOCK_SHIFT ));
    KdPrint(("UNIQUE     = 0x%8.8lx, %3d   %3d \n",UNIQUE_MASK    ,UNIQUE_BITS    ,UNIQUE_SHIFT ));
    KdPrint(("LOTYPE     = 0x%8.8lx, %3d   %3d \n",LOTYPE_MASK    ,LOTYPE_BITS    ,LOTYPE_SHIFT ));
    KdPrint(("FULLTYPE   = 0x%8.8lx, %3d   %3d \n",FULLTYPE_MASK  ,FULLTYPE_BITS  ,FULLTYPE_SHIFT ));
    KdPrint(("FULLUNIQUE = 0x%8.8lx, %3d   %3d \n",FULLUNIQUE_MASK,FULLUNIQUE_BITS,FULLUNIQUE_SHIFT ));
    KdPrint(("\n"));

#endif

    //
    // Initialize exclusion stuff.
    //

    if ((ghsemHmgr = GreCreateSemaphore()) == NULL)
        return FALSE;

    //
    // Initialize the handle manager allocation database.
    //

    ghFreeHmgr  = 0;                // No free handles
    gcMaxHmgr   = HMGR_HANDLE_BASE; // Initialize with handle index base

    //
    // Initialize the allocation of lookaside lists for selected objects.
    //
    // Initialize the maximum allowed entry-size for each object to zero

    if (MmMediumSystem <= MmQuerySystemSize())
            LargeSystemSize = TRUE;

    for (ulType = 0; ulType < MAX_TYPE + 1; ulType++)
    {
        laSize[ulType] = 0;
    }

    // Now Initialize the Lookaside lists

    Size = (LargeSystemSize == TRUE)? HMG_DC_MAX : HMG_DC_SIZE;
    if (HmgInitializeLookAsideList(DC_TYPE, Size, HMG_LAL_TAG, HMG_DC_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_RGN_MAX : HMG_RGN_SIZE);
    if (HmgInitializeLookAsideList(RGN_TYPE, Size, HMG_LAL_TAG, HMG_RGN_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_SURF_MAX : HMG_SURF_SIZE);
    if (HmgInitializeLookAsideList(SURF_TYPE, Size, HMG_LAL_TAG, HMG_SURF_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_PAL_MAX : HMG_PAL_SIZE);
    if (HmgInitializeLookAsideList(PAL_TYPE, Size, HMG_LAL_TAG, HMG_PAL_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_BRUSH_MAX : HMG_BRUSH_SIZE);
    if (HmgInitializeLookAsideList(BRUSH_TYPE, Size, HMG_LAL_TAG, HMG_BRUSH_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_LFONT_MAX : HMG_LFONT_SIZE);
    if (HmgInitializeLookAsideList(LFONT_TYPE, Size, HMG_LAL_TAG, HMG_LFONT_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_RFONT_MAX : HMG_RFONT_SIZE);
    if (HmgInitializeLookAsideList(RFONT_TYPE, Size, HMG_LAL_TAG, HMG_RFONT_OBJECTS) == FALSE)
           return FALSE;

    //
    //
    // Init mutex
    //
    // allocate and initialize memory fast mutex from non-paged pool
    //

    ghfmMemory = GreCreateFastMutex();

    if (ghfmMemory == NULL)
    {
        NONHYDRA_RIP("HmgCreate failed to create ghfmMemory");
        return(FALSE);
    }

    //
    // Create section for shared GDI handle table
    //

#if defined(_GDIPLUS_)
    {
        //
        // NOTE: _GDIPLUS_ is some work in progress code.
        //
        //
        // This should probably be a reserve-and-commit
        // We ceed to fix clean-up case, too
        //

        gpGdiSharedMemory = (GDI_SHARED_MEMORY*)
                            PALLOCMEM(sizeof(GDI_SHARED_MEMORY), ' thG');

        if (gpGdiSharedMemory == NULL)
        {
            RIP("Invalid handle table.");
        }
    }
#else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        LARGE_INTEGER MaximumSize;
        HANDLE hHmgrSharedHandleTable;

        ACCESS_MASK DesiredAccess =  SECTION_MAP_READ |
                                     SECTION_MAP_WRITE;

        ULONG SectionPageProtection = PAGE_READWRITE;

        ULONG AllocationAttributes = SEC_COMMIT |
                                     SEC_NO_CHANGE;


        MaximumSize.HighPart = 0;
        MaximumSize.LowPart  = sizeof(GDI_SHARED_MEMORY);

        ASSERTGDI((gpHmgrSharedHandleSection == NULL),
                  "gpHmgrSharedHandleSection MUST be NULL");

        Status = Win32CreateSection(&gpHmgrSharedHandleSection,
                                    DesiredAccess,
                                    NULL,
                                    &MaximumSize,
                                    SectionPageProtection,
                                    AllocationAttributes,
                                    NULL,
                                    NULL,
                                    TAG_SECTION_HMGR);

        if (!NT_SUCCESS(Status))
        {
            KdPrint(("Error in HmgCreate: Win32CreateSection returns %lx\n",Status));
            NONHYDRA_RIP("Can't continue without shared handle section");
            return(FALSE);
        }
        else
        {
            SIZE_T ViewSize = 0;

#ifdef _HYDRA_
            //
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.
            //
            // Win32MapViewInSessionSpace is included for tracking
            // Section objects. It's promoted to MmMapViewInSessionSpace
            // after the tracking code.
            //
            Status = Win32MapViewInSessionSpace(
                        gpHmgrSharedHandleSection,
                        (PVOID*)&gpGdiSharedMemory,
                        &ViewSize);
#else
            Status = MmMapViewInSystemSpace(
                        gpHmgrSharedHandleSection,
                        (PVOID*)&gpGdiSharedMemory,
                        &ViewSize);
#endif



            if (!NT_SUCCESS(Status))
            {
                KdPrint(("Error in HmgCreate: MmMapViewInSystemSpace returns %lx\n",Status));
                NONHYDRA_RIP("Can't continue without shared handle section");
                return(FALSE);
            }
        }
    }
#endif

    gpentHmgr = gpGdiSharedMemory->aentryHmgr;
    gpGdiDevCaps = &(gpGdiSharedMemory->DevCaps);

    //
    // Allocate the handle table and commit the initial allocation.
    //
    // N.B. Committed memory is demand zero.
    //
    //

    if (gpentHmgr == NULL) {
        NONHYDRA_RIP("Hmgr-bInit failed to reserve the handle table memory\n");
        return(FALSE);
    }

    //
    // allocate and initialize the timeout lock for the handle manager.
    //

    gpLockShortDelay = (PLARGE_INTEGER) GdiAllocPoolNonPaged(sizeof(LARGE_INTEGER),
                                                              'iniG');

    if (gpLockShortDelay == NULL) {
        NONHYDRA_RIP("Hmgr-could not allocate memory for delay lock\n");
        return(FALSE);
    }

    gpLockShortDelay->LowPart = (ULONG) -100000;
    gpLockShortDelay->HighPart = -1;

    //
    // Create a short term temporary buffer that can be used to put large
    // objects for which we have no place in the stack.
    //
    // We actually have to allocate the pointer to the buffer in non-paged
    // pool so that we can do an Interlocked exchange safely on it
    //

    gpTmpGlobal     = (PVOID)PALLOCNOZ(TMP_GLOBAL_BUFFER_SIZE, 'blgG');
    gpTmpGlobalFree = (PVOID *)GdiAllocPoolNonPaged(sizeof(PVOID),
                                                     'iniG');

    if ((gpTmpGlobal == NULL) ||
        (gpTmpGlobalFree == NULL))
    {
        NONHYDRA_RIP("Can't allocate process list entry");
        return(FALSE);
    }

    *gpTmpGlobalFree = gpTmpGlobal;

    return(TRUE);
}


/******************************Public*Routine******************************\
* InitializeLookAsideList
*
* Initializes a LookAside List for a selected object
* Uses DaveC's S-Lists
*
* History:
*  14-Apr-1997 -by- Dan Almosnino danalm
*  Wrote it
\**************************************************************************/

PVOID StubGdiAlloc(
    POOL_TYPE PoolType,
    SIZE_T uBytes,
    ULONG iTag)
{
    return GdiAllocPool((ULONG)uBytes, iTag);

    UNREFERENCED_PARAMETER(PoolType);
}

// Does anyone want to change this to #define ? if so please do so after win2000.
//
// #define StubGdiFree(p)   GdiFreePool((p))

VOID StubGdiFree(
    PVOID p)
{
    GdiFreePool(p);
}

BOOL
HmgInitializeLookAsideList(
    ULONG ulType,
    ULONG Size,
    ULONG dwTag,
    USHORT Number
    )
{

#if !defined(_GDIPLUS_)

    ULONG Flags = 0;

    // Modify tag using type.

    dwTag += ulType << 24;

    // Set the maximum allowed entry-size for this object

    laSize[ulType] = Size;

    // Allocate space for the List headers from Non-Paged pool (Otherwise bugcheck occurs
    // if Kernel tries to access them for modification of list-depth if they are paged out)

    pHmgLookAsideList[ulType] = (PPAGED_LOOKASIDE_LIST)GdiAllocPoolNonPagedNS(
                                                        sizeof(PAGED_LOOKASIDE_LIST),
                                                        dwTag);

    if (pHmgLookAsideList[ulType] == (PPAGED_LOOKASIDE_LIST)NULL)
    {
        WARNING1("HmgCreate failed to allocate memory for pHmgLookAsideList\n");
        return(FALSE);
    }

    // Now Initialize the Lookaside list

#ifdef _HYDRA_
    if (gIsTerminalServer) {
       Flags |= gSessionPoolMask;
    }
#endif

    ExInitializePagedLookasideList(pHmgLookAsideList[ulType],
                                   StubGdiAlloc,
                                   StubGdiFree,
                                   Flags,
                                   Size,
                                   dwTag,
                                   Number);

#endif

    return (TRUE);
}


/******************************Public*Routine******************************\
* IncProcessHandleCount - inc process handle count if under limit or
*   flag specifies no check.
*
* Arguments:
*
*   bCheckQuota - whether or no to check quota before increment
*
* Return Value:
*
*   TRUE if count is incremented.
*
* History:
*
*    30-Apr-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgIncProcessHandleCount(
    W32PID  w32pid,
    OBJTYPE objt
    )
{
    BOOL bRet = TRUE;

#if !defined(_GDIPLUS_)

    //
    // maintain handle count but don't limit quota
    // for DCs
    // --> changed it to limit quota for DCs.  The fact that
    // USER create DCs for menu's and borders on behalf of the
    // app should not be that bad to prevent us from limiting DCs
    // end user can always use 'close' or task manager to kill a bad app.
    // If we don't limit DCs, the whole system will be affected.
    // [lingyunw]
    //

    BOOL bCheckQuota = TRUE;

    if ((w32pid != OBJECT_OWNER_PUBLIC) && (w32pid != OBJECT_OWNER_NONE))
    {
        //
        // is the PID the current PID
        //

        if (w32pid == W32GetCurrentPID())
        {
            PW32PROCESS pw32Current = W32GetCurrentProcess();

            //
            // if the w32 process is not NULL then use
            // the current value, otherwise the process
            // has no W32PROCESS, so don't track handle quota
            //

            if (pw32Current)
            {
                //
                // increment handle count unless call specifies check quota and
                // process is already at or above limit.
                //

                if ((bCheckQuota) &&
                    (pw32Current->GDIHandleCount >= gProcessHandleQuota)
                   )
                {
                    WARNING1("GDI Handle Limit reached\n");
                    bRet = FALSE;
                }
                else
                {
                    InterlockedIncrement((PLONG)(&pw32Current->GDIHandleCount));
                }
            }
        }
        else
        {
            PW32PROCESS pw32;
            PEPROCESS Process;
            NTSTATUS Status;

            Status = PsLookupProcessByProcessId((HANDLE)LongToHandle( w32pid ), &Process);
            if (NT_SUCCESS(Status)) {
                if (pw32 = (PW32PROCESS)(PsGetProcessWin32Process(Process))) {
                    if ((bCheckQuota) &&
                        (pw32->GDIHandleCount >= gProcessHandleQuota))
                    {
                        WARNING1("GDI Handle Limit reached\n");
                        bRet = FALSE;
                    }
                    else
                    {
                        InterlockedIncrement((PLONG)(&pw32->GDIHandleCount));
                    }
                }
                ObDereferenceObject(Process);
            }
            else
            {
                WARNING1("HmgIncProcessGDIHandleCount: Couldn't find PID owner\n");
            }
        }
    }

#endif

    return(bRet);
}


/******************************Public*Routine******************************\
* HmgDecProcessHandleCount - dec process handle count
*
* Arguments:
*
*   none
*
* Return Value:
*
*   nont
*
* History:
*
*    6-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgDecProcessHandleCount(
    W32PID w32pid
)
{

#if !defined(_GDIPLUS_)

    if ((w32pid != OBJECT_OWNER_PUBLIC) && (w32pid != OBJECT_OWNER_NONE))
    {
        if (w32pid == W32GetCurrentPID())
        {
            PW32PROCESS pw32Current = W32GetCurrentProcess();

            if (pw32Current) {
                //
               // use current process
                //

                InterlockedDecrement((PLONG)(&pw32Current->GDIHandleCount));

                if (pw32Current->GDIHandleCount < 0)
                {
                    WARNING("GDI process handle count: decremented below zero");
                }
            }
        }
        else
        {
            PW32PROCESS pw32;
            PEPROCESS Process;
            NTSTATUS Status;

            Status = PsLookupProcessByProcessId((HANDLE)LongToHandle( w32pid ), &Process);
            if (NT_SUCCESS(Status)) {
                if (pw32 = (PW32PROCESS)(PsGetProcessWin32Process(Process))) {

                    InterlockedDecrement((PLONG)(&pw32->GDIHandleCount));
                    if (pw32->GDIHandleCount < 0)
                    {
                        WARNING("GDI process handle count: decremented below zero");
                    }
                }
                ObDereferenceObject(Process);
            }
            else
            {
                WARNING1("HmgDeccProcessGDIHandleCount: Couldn't find PID owner\n");
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* HmgValidHandle
*
* Returns TRUE if the handle is valid, FALSE if not.
*
* Note we don't need to lock the semaphore, we aren't changing anything,
* we are just peeking in.
*
* History:
*  08-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
HmgValidHandle(
    HOBJ hobj,
    OBJTYPE objt)
{
    PENTRY  pentTmp;
    UINT uiIndex = (UINT) (UINT) HmgIfromH(hobj);

    if ((uiIndex < gcMaxHmgr) &&
        ((pentTmp = &gpentHmgr[uiIndex])->Objt == objt) &&
        (pentTmp->FullUnique == HmgUfromH(hobj)))
    {
        ASSERTGDI(pentTmp->einfo.pobj != (POBJ) NULL, "ERROR how can it be NULL");
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* HmgInsertObject
*
* This inserts an object into the handle table, returning the handle
* associated with the pointer.
*
* History:
*  13-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HOBJ
HmgInsertObject(
    PVOID pv,
    FLONG flags,    // flags can be a combination of the following :
                    //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                    //                        any process
                    //  HMGR_ALLOC_LOCK     - Do an HmgLock on the object and
                    //                        return a pointer instead of handle
                    //  HMGR_ALLOC_ALT_LOCK - Do an HmgShareLock on the object
                    //                        and return a pointer instead of
                    //                        handle
    OBJTYPE objt)
{
    ASSERTGDI(pv != (PVOID) NULL, "Invalid address");
    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "objt is bad");

    HOBJ h = 0;

    BOOL bHandleQuota = TRUE;

    //
    // need the HMGR lock held while getting the handle
    //

    {
        MLOCKFAST mo;

        if (!(flags & HMGR_MAKE_PUBLIC))
        {
            //
            // Inc handle count for non-public objects. DC objects
            // can be allocated above process limit
            //


            bHandleQuota = HmgIncProcessHandleCount(W32GetCurrentPID(),objt);
        }

        if (bHandleQuota)
        {
            h = hGetFreeHandle((OBJTYPE) objt);

            if (h == 0)
            {
                WARNING1("HmgInsert failed hGetFreeHandle\n");

                //
                // decrement handle count in case of failure
                //

                if (!(flags & HMGR_MAKE_PUBLIC))
                {
                    HmgDecProcessHandleCount(W32GetCurrentPID());
                }
            }
            else
            {
                // WINBUG #345863 3-17-2001 jasonha Hold ghsemHmgr thru out insert
                ((ENTRYOBJ *) &(gpentHmgr[HmgIfromH(h)]))->vSetup((POBJ) pv, objt, (FSHORT) flags);
                ((OBJECT *) pv)->hHmgr = (HANDLE) h;
            }
        }
        else
        {
            WARNING1("HmgInsertObject failed due to handle quota\n");
        }
    }

    return(h);
}

/******************************Public*Routine******************************\
* HmgRemoveObject
*
* Removes an object from the handle table if certain conditions are met.
*
* History:
*  13-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PVOID
HmgRemoveObject(
    HOBJ hobj,
    LONG cExclusiveLock,
    LONG cShareLock,
    BOOL bIgnoreUndeletable,
    OBJTYPE objt)
{
    POBJ pobj;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        //
        // Must acquire hmgr lock before handle lock
        //

        GreAcquireHmgrSemaphore();

        //
        // lock handle
        //

        PENTRY pentTmp = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentTmp,TRUE);

        if (HandleLock.bValid())
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) &&
                (pentTmp->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentTmp->einfo.pobj;

                if ((pobj->cExclusiveLock == (USHORT)cExclusiveLock) &&
                    (pobj->ulShareCount   == (ULONG)cShareLock))
                {
                    if (bIgnoreUndeletable || (!(pentTmp->Flags & HMGR_ENTRY_UNDELETABLE)))
                    {
                        //
                        // The undeletable flag is not set or else we are ignoring it.
                        //

                        #if GDI_PERF
                        HmgCurrentNumberOfHandles[objt]--;
                        #endif

                        //
                        // set the handle in the object to NULL
                        // to prevent/catch accidental decrement of the
                        // shared reference count
                        //

                        pobj->hHmgr = NULL;

                        //
                        // free the handle
                        //

                        ((ENTRYOBJ *) pentTmp)->vFree(uiIndex);

                    }
                    else
                    {
                        WARNING1("HmgRemove failed object is undeletable\n");
                        pobj = NULL;
                    }
                }
                else
                {
                    //
                    // object is busy
                    //

//                     WARNING1("HmgRemove failed - object busy elsewhere\n");
                     pobj = NULL;
                }
            }
            else
            {
                WARNING1("HmgRemove: bad objt or unique\n");
                pobj = NULL;
            }

            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgRemove: failed to lock handle\n");
            pobj = NULL;
        }

        //
        // free hmgr lock
        //

        GreReleaseHmgrSemaphore();
    }
    else
    {
        WARNING1("HmgRemove failed invalid index\n");
        pobj = NULL;
    }

    return((PVOID)pobj);
}

/******************************Public*Routine******************************\
* HmgReplace
*
* Change the object pointer.  Note this is callable only under very precise
* circumstances:
*
* 1> When the object is exclusively locked.
*
* History:
*  Tue 14-Dec-1993 -by- Patrick Haluptzok [patrickh]
* Seperate out lock counts from object structure.
*
*  18-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

POBJ HmgReplace(
    HOBJ    hobj,
    POBJ    pobjNew,
    FLONG   flags,
    LONG    cLock,
    OBJTYPE objt)
{
    //
    // We assume everything is valid, that the handle being replaced is exclusively
    // locked and valid.
    //
    // Note that currently "exclusively locked" can mean that we call this under
    // OBJLOCK control which doesn't set the cExclusiveLock
    //

    POBJ pobj = NULL;

    UINT uiIndex = (UINT) HmgIfromH(hobj);

    ASSERTGDI(uiIndex != 0, "HmgReplace invalid handle 0");
    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgReplace invalid handle");

    PENTRY pentTmp = &gpentHmgr[uiIndex];

    ASSERTGDI(pentTmp->Objt == objt, "HmgReplace invalid object type");
    ASSERTGDI(pentTmp->FullUnique == HmgUfromH(hobj), "HmgReplace invalid uniqueness");
    ASSERTGDI((OBJECTOWNER_PID(pentTmp->ObjectOwner) == OBJECT_OWNER_PUBLIC) ||
              (OBJECTOWNER_PID(pentTmp->ObjectOwner) == W32GetCurrentPID()), "HmgReplace invalid PID owner");
    HANDLELOCK  HandleLock(pentTmp,TRUE);

    if (HandleLock.bValid())
    {
        //
        // Return the old value.  We have to be under the mutex here since the
        // counts live in the objects and if we do the switch while someone is
        // looking at the old object and the old object gets deleted after this
        // call before the original thread gets to run again he may fault or
        // wrongly succeed to lock it down.
        //

        pobj = pentTmp->einfo.pobj;
        pentTmp->einfo.pobj = pobjNew;

        HandleLock.vUnlock();
    }

    return((POBJ) pobj);
}

/******************************Public*Routine******************************\
* AllocateObject
*
* Allocates an object through a look a side buffer if possible else just
* allocates out of the heap.
*
* History:
*  14-Apr-1997 -by- Dan Almosnino danalm
* Modify to use DaveC's S-Lists mechanism for Lookaside Lists
*  12-Oct-1993 -by- Patrick Haluptzok patrickh
* Based on DaveC's HmgAlloc look-aside code
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//
struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};


PVOID
AllocateObject(
    ULONG cBytes,
    ULONG ulType,
    BOOL bZero)
{

    PVOID pvReturn = NULL;

    ASSERTGDI(ulType != DEF_TYPE, "AllocateObject ulType is bad");
    ASSERTGDI(cBytes >= sizeof(BASEOBJECT), "AllocateObject cBytes is bad");

    //
    // Debug check to avoid assert in ExAllocatePool
    //

    #if DBG

        if (cBytes >= (PAGE_SIZE * 10000))
        {
            WARNING("AllocateObject: cBytes >= 10000 pages");
            return(NULL);
        }

    #endif


    //
    // If the object type has a lookaside list and the list contains a
    // free entry and the requested size is less than or equal to the
    // lookaside list size, then attempt to allocate memory from the
    // lookaside list.
    //

#if !defined(_GDIPLUS_)

    if (laSize[ulType] >= (ULONG)cBytes)
    {

        if((pvReturn = ExAllocateFromPagedLookasideList(pHmgLookAsideList[ulType])) != NULL)
        {

            if (bZero)
            {
                RtlZeroMemory(pvReturn, (UINT) cBytes);
            }
            else
            {
                //
                // At least the BASEOBJECT should be initialized.
                //

                RtlZeroMemory(pvReturn, (UINT) sizeof(BASEOBJECT));
            }

            //
            // This code is really hideous.
            // This is one of a very few places where it is necessary to know
            // that the BaseFlags entry in BASEOBJECT is actually the upper
            // 16 bits of the DWORD containing the cExclusiveLock.
            // If the layout of BASEOBJECT ever changes separating the cExclusiveLock
            // and the BaseFlags then this code _WILL_ break.
            //
            // The InterlockedExchange is required because it inserts appropriate
            // memory barriers on Alpha preventing other processors from seeing
            // the write delayed.
            //
            // Using the InterlockedExchange here is probably not necessary
            // Before anyone else can access this data it has to be put in the
            // Handle table and the code that does that should have the appropriate
            // mb instruction. However, just to be safe...
            //

            SplitOrCombinedLockAndFlags M;
            M.S.c_cExclusiveLock = ((BASEOBJECT *)pvReturn)->cExclusiveLock;
            M.S.c_BaseFlags = ((BASEOBJECT *)pvReturn)->BaseFlags | HMGR_LOOKASIDE_ALLOC_FLAG;
            InterlockedExchange( (LONG *)& (((BASEOBJECT *)pvReturn)->cExclusiveLock), M.W );

            //
            // This is the code without the InterlockedExchange.
            // If BaseFlags is removed from the DWORD containing the cExclusiveLock, the code
            // can be restored to this (provided all code that puts the object
            // in the handle table uses the HANDLELOCK):
            //
            //((BASEOBJECT *)pvReturn)->BaseFlags |= HMGR_LOOKASIDE_ALLOC_FLAG; //Set Base Object Lookaside Flag
            //

#if GDI_PERF
            HmgNumberOfLookAsideHits[ulType] += 1;
            HmgCurrentNumberOfLookAsideObjects[ulType] += 1;

            if (HmgCurrentNumberOfLookAsideObjects[ulType] > HmgMaximumNumberOfLookAsideObjects[ulType])
            {
                HmgMaximumNumberOfLookAsideObjects[ulType] = HmgCurrentNumberOfLookAsideObjects[ulType];
            }
#endif

        }

    }

#endif

    if (pvReturn == NULL)
    {
        //
        // The attempted allocation from Look-Aside failed
        // (or the object is too big for the lookaside).
        // Attempt to allocate the object from the heap.
        //

        ULONG ulTag = '00hG';
        ulTag += ulType << 24;

        // Inject the Session Id into the tag
        //  Sessions with Id's from 0 to 78 will use an ascii character
        //  from '0' to '~', respectively.  Sessions with higher Id's will
        //  all have a ' '.
        ULONG ulSessionId = PsGetCurrentProcessSessionId();
        if (ulSessionId > '~' - '0')
        {
            ulSessionId = ' ' - '0';
        }
        ulTag += ulSessionId << 16;

        //
        // Note: not necessary to clear the HMGR_LOOKASIDE_ALLOC_FLAG
        // in BaseFlags since the BASEOBJECT is always zero-initialized.
        //

        if (bZero)
        {
            pvReturn = PALLOCMEM(cBytes, ulTag);
        }
        else
        {
            pvReturn = PALLOCNOZ(cBytes, ulTag);

            //
            // At least the BASEOBJECT should be initialized.
            //

            if (pvReturn)
            {
                RtlZeroMemory(pvReturn, (UINT) sizeof(BASEOBJECT));
            }
        }

        //
        // If the allocation failed again, then set the extended
        // error status and return an invalid handle.
        //

        if (!pvReturn)
        {
            KdPrint(("GDISRV:AllocateObject failed alloc of %lu bytes\n", (cBytes)));
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

    }

#if GDI_PERF

    //
    // Increment the object performance counters.
    //

    HmgCurrentNumberOfObjects[ulType] += 1;
    HmgNumberOfObjectsAllocated[ulType] += 1;

    if (HmgCurrentNumberOfObjects[ulType] > HmgMaximumNumberOfObjects[ulType])
    {
        HmgMaximumNumberOfObjects[ulType] = HmgCurrentNumberOfObjects[ulType];
    }

#endif

    return(pvReturn);
}

/******************************Public*Routine******************************\
* HmgAlloc
*
* Allocate an object from Handle Manager.
*
* WARNING:
* --------
*
* If the object is share-lockable via an API, you MUST use HmgInsertObject
* instead.  If the object is only exclusive-lockable via an API, you MUST
* either use HmgInsertObject or specify HMGR_ALLOC_LOCK.
*
* (This is because if you use HmgAlloc, a malicious multi-threaded
* application could guess the handle and cause it to be dereferenced
* before you've finished initializing it, possibly causing an access
* violation.)
*
* History:
*  23-Sep-1991 -by- Patrick Haluptzok patrickh
* Rewrite to be flat, no memory management under semaphore.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
HmgAlloc(
    ULONGSIZE_T cb,
    OBJTYPE objt,
    FSHORT  fs) // fs can be a combination of the following:
                //  HMGR_NO_ZERO_INIT   - Don't zero initialize
                //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                //                        any process
                //  HMGR_ALLOC_LOCK     - Do an HmgLock on the object and
                //                        return a pointer instead of handle
                //  HMGR_ALLOC_ALT_LOCK - Do an HmgShareLock on the object
                //                        and return a pointer instead of
                //                        handle
{
    HOBJ Handle;
    PVOID pv;

    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "HmgAlloc objt is bad");
    ASSERTGDI(cb >= 8, "ERROR hmgr writes in first 8 bytes");

    //
    // Allocate a pointer.
    //

    pv = AllocateObject(cb, (ULONG) objt, ((fs & HMGR_NO_ZERO_INIT) == 0));

    if (pv != (PVOID) NULL)
    {
        BOOL bHandleQuota = TRUE;

        //
        // Allocate a handle.  We need the mutex to access the free list
        //

        GreAcquireHmgrSemaphore();

        if (!(fs & HMGR_MAKE_PUBLIC))
        {
            //
            // increment handle quota on non public objects. DC objects
            // can be allocated over a process quota limit.
            //

            bHandleQuota = HmgIncProcessHandleCount(W32GetCurrentPID(),objt);
        }

        if (bHandleQuota)
        {
            Handle = hGetFreeHandle(objt);

            if (Handle != (HOBJ) 0)
            {
                //
                // Store a pointer to the object in the entry corresponding to the
                // allocated handle and initialize the handle data.
                //

                ((ENTRYOBJ *) &(gpentHmgr[HmgIfromH(Handle)]))->vSetup((POBJ) pv, objt, fs);

                //
                // Store the object handle at the beginning of the object memory.
                //

                ((OBJECT *)pv)->hHmgr = (HANDLE)Handle;

                GreReleaseHmgrSemaphore();

                return ((fs & (HMGR_ALLOC_ALT_LOCK | HMGR_ALLOC_LOCK))
                            ? (HOBJ)pv
                            : Handle);
            }
            else
            {
                //
                // decrement process handle count if not public
                // (while lock is still held)
                //

                if (!(fs & HMGR_MAKE_PUBLIC))
                {
                    HmgDecProcessHandleCount(W32GetCurrentPID());
                }

                //
                // We just failed a handle allocation.  Release the memory.
                //

                GreReleaseHmgrSemaphore();
                FreeObject(pv,(ULONG) objt);

            }
        }
        else
        {
            WARNING("Failed HmgAlloc due to handle quota\n");
            GreReleaseHmgrSemaphore();
            FreeObject(pv,(ULONG) objt);
        }
    }

    return((HOBJ) 0);
}

/******************************Public*Routine******************************\
* FreeObject
*
* Frees the object from where it was allocated.
*
* History:
*
*  14-Apr-1997 -by- Dan Almosnino danalm
* Modified to use DaveC's S-List mechanism for Lookaside lists
*
*  12-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID FreeObject(PVOID pvFree, ULONG ulType)
{

#if GDI_PERF

    HmgCurrentNumberOfObjects[ulType] -= 1;

#endif

// Find if the object originates from a lookaside allocation,
// if so, return it to the free list.

    if( ((BASEOBJECT *)pvFree)->BaseFlags & HMGR_LOOKASIDE_ALLOC_FLAG )
    {

#if !defined(_GDIPLUS_)

        ExFreeToPagedLookasideList(pHmgLookAsideList[ulType],pvFree);

#endif

#if GDI_PERF

        HmgCurrentNumberOfLookAsideObjects[ulType] -= 1;

#endif

    }
    else
    {
        // If the object memory was allocated from the general heap, then
        // release the memory to the heap.

        VFREEMEM(pvFree);
    }

}

/******************************Public*Routine******************************\
* HmgFree
*
* Free an object from the handle manager.
*
* History:
*  23-Sep-1991 -by- Patrick Haluptzok patrickh
* Rewrite to be flat, no memory management under semaphore.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID HmgFree(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    POBJ pobjTmp;
    OBJTYPE objtTmp;

    ASSERTGDI(uiIndex != 0, "ERROR HmgFree invalid 0 handle");

    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentTmp = &gpentHmgr[uiIndex];

        //
        // Acquire the handle manager lock and decrement the count of objects of
        // the specfied type.
        //

        GreAcquireHmgrSemaphore();

        //
        // lock handle
        //

        HANDLELOCK HandleLock(pentTmp,FALSE);

        if (HandleLock.bValid())
        {
            #if GDI_PERF
                HmgCurrentNumberOfHandles[pentTmp->Objt]--;
            #endif

            pobjTmp = pentTmp->einfo.pobj;
            objtTmp = pentTmp->Objt;

            //
            // Free the object handle
            //

            ((ENTRYOBJ *) pentTmp)->vFree(uiIndex);

            HandleLock.vUnlock();
        }

        GreReleaseHmgrSemaphore();

        if (pobjTmp)
        {
            FreeObject((PVOID)pobjTmp, (ULONG) objtTmp);
        }
    }
    else
    {
        WARNING1("HmgFree: bad handle index");
    }
}


/******************************Public*Routine******************************\
* HmgSetOwner - set new object owner
*
* Arguments:
*   hobj        - handle of object
*   objt        - type of object
*   usCurrent   - OBJECT_OWNER flag for current owner
*   pw32Current - PW32PROCESS of current owner if not current w32process
*   usNew       - OBJECT_OWNER flag for new owner
*   pw32New     - PW32PROCESS of new owner if not current w32process
*
* Return Value:
*
*   Status
*
* History:
*
*    15-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
HmgSetOwner(
    HOBJ        hobj,
    W32PID      W32PidNew,
    OBJTYPE     objt
    )
{
    PENTRY pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;
    W32PID W32PidCurrent;
#if defined(_WIN64)
    KERNEL_PVOID  pclientID;
    PW32THREAD pW32thread;
    BOOL bWOW64 = FALSE;
#endif
    if (W32PidNew == OBJECT_OWNER_CURRENT)
    {
        W32PidNew = W32GetCurrentPID();
    }

    if (uiIndex < gcMaxHmgr)
    {
        pentTmp = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentTmp,FALSE);

        if (HandleLock.bValid())
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) && (pentTmp->FullUnique == HmgUfromH(hobj)))
            {

                POBJ pobj = pentTmp->einfo.pobj;
#if defined(_WIN64)
                pW32thread = W32GetCurrentThread();

                //
                // Set the handle owner pid to the wow64 print client pid if
                // the the PRINTCLIENTID pointer in W32TREAD is non zero.
                // In this case, we are doing WOW64 printing via LPC.
                //

                pclientID = pW32thread ? pW32thread->pClientID : 0;
                if(pclientID)
                    bWOW64 = TRUE;
#endif
                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == (PW32THREAD)PsGetCurrentThread())
#if defined(_WIN64)
                    ||
                    (bWOW64)
#endif
                   )
                {

                    bStatus = TRUE;

                    //
                    // determine current W32PID
                    //

                    W32PidCurrent =  HandleLock.Pid();
#if defined(_WIN64)
                    if (bWOW64)
                    {
                        W32PidNew = ((PRINTCLIENTID*)pclientID)->clientPid;
                    }
#endif
                    if (W32PidCurrent != W32PidNew)
                    {
                        bStatus = HmgIncProcessHandleCount(W32PidNew,objt);

                        if (bStatus)
                        {
                            HmgDecProcessHandleCount(W32PidCurrent);

                            //
                            // set new owner
                            //

                            HandleLock.Pid(W32PidNew);
                        }
                        else
                        {
                            WARNING1("HmgSetOwner: Failed to set owner due to handle quota\n");
                        }
                    }
                }
                else
                {
                    WARNING1("HmgSetOwner, Object is exclusively locked\n");
                }
            }
            else
            {
                WARNING1("HmgSetOwner, object type or unique mismach\n");
            }

            HandleLock.vUnlock();
        }
    }
    else
    {
        WARNING1("HmgSetOwner: bad index\n");
    }

    return(bStatus);
}

/*****************************Exported*Routine*****************************\
* GreGetObjectOwner
*
*   Get the owner of an object
*
* Arguments:
*
*   hobj    - handle to object
*   objt    - handle type for verification
*
* History:
*
* 27-Apr-1994 -by- Johnc
* Dupped from SetOwner.
\**************************************************************************/

W32PID
GreGetObjectOwner(
    HOBJ hobj,
    DWORD objt)
{
    W32PID pid = OBJECT_OWNER_ERROR;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentTmp = &gpentHmgr[uiIndex];

        if ((pentTmp->Objt == objt) && (pentTmp->FullUnique == HmgUfromH(hobj)))
        {
            pid = OBJECTOWNER_PID(pentTmp->ObjectOwner);
        }
        else
        {
            WARNING1("GreGetObjectOwner failed - object type of unique mismatch\n");
        }

    }
    else
    {
        WARNING1("GreGetObjectOwner failed - invalid handle index\n");
    }

    return(pid);
}

/******************************Public*Routine******************************\
*
* HmgSwapHandleContents locks both handles and verifies lock counts.
* The handle contents for each element are then swapped.
*
* Arguments:
*
*   hobj1   - handle to object 1
*   cShare1 - share count object 1 must have after handle is locked
*   hobj2   - handle to object 2
*   cShare1 - share count object 2 must have after handle is locked
*   objt    - type that both handles must be
*
* Return Value:
*
*   BOOL status
*
* History:
*
*    24-Jul-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgSwapHandleContents(
    HOBJ    hobj1,
    ULONG   cShare1,
    HOBJ    hobj2,
    ULONG   cShare2,
    OBJTYPE objt)
{
    //
    // acquire hmgr resource for this operation to
    // make sure we don't deadlock with two threads
    // trying to swap the same handles in reverse
    // order
    //

    MLOCKFAST mo;

    return(
             HmgSwapLockedHandleContents(
                        hobj1,
                        cShare1,
                        hobj2,
                        cShare2,
                        objt)
          );

}

/******************************Public*Routine******************************\
*
* HmgSwapLockedHandleContents locks both handles and verifies lock counts.
* The handle contents for each element are then swapped. HmgrResource must
* be owned to prevent deadlock.
*
* Arguments:
*
*   hobj1   - handle to object 1
*   cShare1 - share count object 1 must have after handle is locked
*   hobj2   - handle to object 2
*   cShare1 - share count object 2 must have after handle is locked
*   objt    - type that both handles must be
*
* Return Value:
*
*   BOOL status
*
* History:
*
*    24-Jul-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgSwapLockedHandleContents(
    HOBJ    hobj1,
    ULONG   cShare1,
    HOBJ    hobj2,
    ULONG   cShare2,
    OBJTYPE objt)
{

    UINT uiIndex1 = (UINT) HmgIfromH(hobj1);
    UINT uiIndex2 = (UINT) HmgIfromH(hobj2);
    BOOL bResult = FALSE;

    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "Bad type");

    //
    // Acquire handle lock on both objects
    //

    PENTRY pentry1 = &gpentHmgr[uiIndex1];

    PENTRY pentry2 = &gpentHmgr[uiIndex2];

    HANDLELOCK HandleLock1(pentry1,FALSE);

    if (HandleLock1.bValid())
    {
        HANDLELOCK HandleLock2(pentry2,FALSE);
        if (HandleLock2.bValid())
        {
            //
            // Verify share lock counts and object types
            //

            if ((HandleLock1.ShareCount() == (USHORT)cShare1) && (pentry1->Objt == objt))
            {
                if ((HandleLock2.ShareCount() == (USHORT)cShare2) && (pentry2->Objt == objt))
                {
                    POBJ pobjTemp;
                    PVOID   pvTmp;

                    //
                    // swap pobj in handle table
                    //

                    pobjTemp            = pentry1->einfo.pobj;
                    pentry1->einfo.pobj = pentry2->einfo.pobj;
                    pentry2->einfo.pobj = pobjTemp;

                    //
                    // swap puser in handle table
                    //

                    pvTmp          = pentry1->pUser;
                    pentry1->pUser = pentry2->pUser;
                    pentry2->pUser = pvTmp;

                    //
                    // swap BASEOBJECTS
                    //

                    BASEOBJECT obj;

                    obj = *pentry1->einfo.pobj;
                    *pentry1->einfo.pobj = *pentry2->einfo.pobj;
                    *pentry2->einfo.pobj = obj;

                    //
                    // unswap the BASEOBJECT.BaseFlags
                    //
                    // The BaseFlags field contains information about how
                    // the object was allocated (and therefore, how it must
                    // be deallocated).  Thus, it represents state associated
                    // with the actual memory, not the object, and should not
                    // be swapped.
                    //
                    // See comments regarding BASEOBJECT in inc\hmgshare.h
                    // for more details.  Also, there is swapping code in
                    // RGNOBJ::bSwap (rgnobj.cxx).
                    //

                    USHORT usTemp;

                    usTemp = pentry1->einfo.pobj->BaseFlags;
                    pentry1->einfo.pobj->BaseFlags = pentry2->einfo.pobj->BaseFlags;
                    pentry2->einfo.pobj->BaseFlags = usTemp;

                    bResult = TRUE;
                }
                else
                {
                    WARNING1("HmgSwapHandleContents: wrong share count or objt for hobj2");
                }
            }
            else
            {
                WARNING1("HmgSwapHandleContents: wrong share count or objt for hobj1");
            }

            HandleLock2.vUnlock();
        }

        HandleLock1.vUnlock();
    }

    return(bResult);
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgNextOwned(hmgr, hobj, pid)
*
* Report the next object owned by specified process
*
* History:
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
FASTCALL
HmgNextOwned(
    HOBJ hobj,
    W32PID pid)
{
    MLOCKFAST mo;

    return(HmgSafeNextOwned(hobj, pid));
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgSafeNextOwned
*
* Report the next object owned by specified process
*
* History:
*  Sat 11-Dec-1993 -by- Patrick Haluptzok [patrickh]
* Remove function wrapper.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
FASTCALL
HmgSafeNextOwned(
    HOBJ hobj,
    W32PID pid)
{

    PENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxHmgr)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (pentTmp->bOwnedBy(pid))
        {
            return((HOBJ) MAKE_HMGR_HANDLE(uiIndex, pentTmp->FullUnique));
        }

        //
        // Advance to next object
        //

        uiIndex++;

    }

    //
    // No objects found
    //

    return((HOBJ) 0);
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgSafeNextObjt
*
* Report the next object of a certain type.
*
* History:
*  Tue 19-Apr-1994 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

POBJ
FASTCALL
HmgSafeNextObjt(
    HOBJ hobj,
    OBJTYPE objt)
{

    PENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxHmgr)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (pentTmp->Objt == objt)
        {
            return(pentTmp->einfo.pobj);
        }

        //
        // Advance to next object
        //

        uiIndex++;
    }

    //
    // no objects found
    //

    return((POBJ) 0);
}

/*******************************Routine************************************\
* HmgLockAllOwners
*
* Description:
*
*   Acquire an exclusive lock on an object.  Note that this routine is
*   different than HmgLock in that the PID owner doesn't need to match the
*   current PID.  This is useful in GreRestoreDC where we need to get a lock
*   on the saved DC in order to to copy its information to the primary DC, but
*   don't want to fail if the process has already reached its handle quota
*   because this saved DC is about to be deleted anyway.  See bug #223129
*   for details.
*
*   WARNING:  Do not call this routine outside of the above scenario unless
*       there's a very good reason!
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgLockAllOwners(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ pobj = (POBJ)NULL;
    UINT uiIndex = (UINT)HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        //
        // Passing FALSE as the second argument to the HANDLELOCK constructor
        // allows us to obtain a lock regardless of the PID owner of the object.
        //
        HANDLELOCK HandleLock(pentry,FALSE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt != objt) || (pentry->FullUnique != HmgUfromH(hobj)))
            {
                HmgPrintBadHandle(hobj, objt);
            }
            else
            {
                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) || (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    pobj->cExclusiveLock++;
                    pobj->Tid = (PW32THREAD)PsGetCurrentThread();
                }
                else
                {
                    WARNING1("HmgLock: object already locked by another thread");
                    pobj = (POBJ)NULL;
                }
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}



#if !defined(_X86_) || defined(_GDIPLUS_)
/*******************************Routine************************************\
* HmgLock
*
* Description:
*
*   Acquire an exclusive lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ pobj = (POBJ)NULL;
    UINT uiIndex = (UINT)HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt != objt) || (pentry->FullUnique != HmgUfromH(hobj)))
            {
                HmgPrintBadHandle(hobj, objt);
            }
            else
            {
                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) || (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    pobj->cExclusiveLock++;
                    pobj->Tid = (PW32THREAD)PsGetCurrentThread();
                }
                else
                {
                    WARNING1("HmgLock: object already locked by another thread");
                    pobj = (POBJ)NULL;
                }
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareCheckLock
*
* Description:
*
*   Acquire a share lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgShareCheckLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];
        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareLock
*
* Description:
*
*   Acquire a share lock on an object, don't check PID owner
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ FASTCALL
HmgShareLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

#endif

/*******************************Routine************************************\
* HmgShareCheckLockIgnoreStockBit
*
* Description:
*
*   Acquire a share lock on an object, PID owner must match current PID
*   or be a public. We ignore the stock bit.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgShareCheckLockIgnoreStockBit(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];
        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) &&
                ((pentry->FullUnique & ~FULLUNIQUE_STOCK_MASK) ==
                 (HmgUfromH(hobj) & ~FULLUNIQUE_STOCK_MASK)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareLockIgnoreStockBit
*
* Description:
*
*   Acquire a share lock on an object, don't check PID owner. Ignore stock
*   bit.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ FASTCALL
HmgShareLockIgnoreStockBit(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) &&
                ((pentry->FullUnique & ~FULLUNIQUE_STOCK_MASK) ==
                 (HmgUfromH(hobj) & ~FULLUNIQUE_STOCK_MASK)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/******************************Public*Routine******************************\
* HmgShareUnlock
*
*   Make this a macro once it is debugged
*
* Arguments:
*
*   pobj - pointer to share-locked object
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
HmgShareUnlock(
    POBJ pobj
    )
{
    PENTRY pentry;

    //
    // decrement shared reference count to object, Handle checks
    // are not done.
    //

    UINT uiIndex = (UINT) HmgIfromH(pobj->hHmgr);

    pentry = &gpentHmgr[uiIndex];

    HANDLELOCK HandleLock(pentry,FALSE);

    if (HandleLock.bValid())
    {
        //
        // decrement use count
        //

        pobj->ulShareCount--;

        HandleLock.vUnlock();
    }
}

/*******************************Routine************************************\
* HmgReferenceCheckLock
*
* Description:
*
*   The routine validates the hanlde passed in and returns a pointer to
*   the object. This routine must only be called when the HmgrReource is
*   held and the pointer to the object is only valid while the Resource
*   is held. No unlock is neccessary since the object is not reference-
*   counted.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgReferenceCheckLock(
    HOBJ hobj,
    OBJTYPE objt,
    BOOL bDebugPrint
    )
{
    PENTRY pentry;
    POBJ   pobj = (POBJ)NULL;

    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
        {
            pobj = pentry->einfo.pobj;
        }
        else
        {
            if (bDebugPrint)
            {
                HmgPrintBadHandle(hobj, objt);
            }
        }
    }
    else
    {
        if (bDebugPrint)
        {
           HmgPrintBadHandle(hobj, objt);
        }
    }
    return(pobj);
}

#if !defined(_X86_) || defined(_GDIPLUS_)

/******************************Public*Routine******************************\
* HmgIncrementShareReferenceCount
*
*   interlocked increment shared reference count
*
* Arguments:
*
*   pObj    - pointer to valid object
*
* Return Value:
*
*   none
*
* History:
*
*    6-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
FASTCALL
HmgIncrementShareReferenceCount(
    POBJ pObj
    )
{
    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pObj), FALSE);

    if (HandleLock.bValid())
    {
        pObj->ulShareCount++;
        HandleLock.vUnlock();
    }
    else
    {
        HmgPrintBadHandle((HOBJ)pObj->hHmgr, PENTRY_FROM_POBJ(pObj)->Objt);
    }
}

/******************************Public*Routine******************************\
* HmgDecrementShareReferenceCount
*
*   interlocked increment shared reference count
*
* Arguments:
*
*   pObj    - pointer to valid object
*
* Return Value:
*
*   previous lock count
*
* History:
*
*    6-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
FASTCALL
HmgDecrementShareReferenceCount(
    POBJ pObj
    )
{
    ULONG ulOrigShareCount=0;
    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pObj), FALSE);

    if (HandleLock.bValid())
    {
        ulOrigShareCount = pObj->ulShareCount;
        pObj->ulShareCount--;
        HandleLock.vUnlock();
    }
    else
    {
        HmgPrintBadHandle((HOBJ)pObj->hHmgr, PENTRY_FROM_POBJ(pObj)->Objt);
    }

    return ulOrigShareCount;
}

#endif

/******************************Public*Routine******************************\
* HmgMarkDeletable
*
* Mark an object as deletable.
*
* History:
*  11-Jun-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
FASTCALL
HmgMarkDeletable(
    HOBJ hobj,
    OBJTYPE objt)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {

            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pentry->Flags &= ~HMGR_ENTRY_UNDELETABLE;
                bStatus = TRUE;
            }
            else
            {
                WARNING1("HmgMarkDeletable: bad objt or unique");
            }
            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgMarkDeletable failed: not object owner\n");
        }
    }
    else
    {
      WARNING1("HmgMarkDeletable failed: index out of range\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* HmgMarkUndeletable
*
* Mark an object as undeletable.
*
* History:
*  11-Jun-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
FASTCALL
HmgMarkUndeletable(HOBJ hobj, OBJTYPE objt)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,TRUE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pentry->Flags |= HMGR_ENTRY_UNDELETABLE;
                bStatus = TRUE;
            }
            else
            {
                WARNING1("HmgMarkUndeletable: bad objt or unique");
            }
            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgMarkUndeletable failed: not object owner\n");
        }
    }
    else
    {
        WARNING1("HmgMarkUndeletable failed: index out of range\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* BOOL HmgSetLock
*
* Set the lock count of the object.
* This is currently used by process cleanup code to reset object lock count.
*
* History:
*  Wed May 25 15:24:33 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/




BOOL FASTCALL HmgSetLock(HOBJ hobj, ULONG cLock)
{
    PENTRY pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
      pentTmp = &gpentHmgr[uiIndex];
      if (pentTmp->FullUnique == HmgUfromH(hobj))
      {
        POBJ pobj = pentTmp->einfo.pobj;

        //
        // This code is really hideous.
        // This is one of a very few places where it is necessary to know
        // that the BaseFlags entry in BASEOBJECT is actually the upper
        // 16 bits of the DWORD containing the cExclusiveLock.
        // If the layout of BASEOBJECT ever changes separating the cExclusiveLock
        // and the BaseFlags then this code _WILL_ break.
        //
        // Also this code only works because nobody actually sets BaseFlags after
        // object allocation. If this fact ever changes then this code needs to
        // be changed to an InterlockedCompareExchange loop and should probably be
        // protected by the HandleLock. Also the BaseFlags modification code
        // would then also require an InterlockedCompareExchange too.
        //
        // The only reason we actually entertain this mess is because this code
        // is only ever used in cleanup. It's bad enough that the code stomps the
        // lock without checking it anyway.
        //
        // The InterlockedExchange is required because it inserts appropriate
        // memory barriers on Alpha preventing other processors from seeing
        // the write delayed.
        //

        SplitOrCombinedLockAndFlags M;

        //
        // get a pointer to the cExclusiveLock, make it a ULONG * and then
        // dereference it getting 32bits from the beginning of the 16bit
        // cExclusiveLock. This will include the BaseFlags which we know won't
        // change (see above and BASEOBJECT).
        //

        M.W = *(ULONG *)&(pobj->cExclusiveLock);
        M.S.c_cExclusiveLock = (USHORT)cLock;
        InterlockedExchange((LONG *)&(pobj->cExclusiveLock), M.W);

      }
      else
      {
        pentTmp = (PENTRY) NULL;
        WARNING1("HmgSetLock failed - Uniqueness does not match\n");
      }
    }
    else
    {
      pentTmp = (PENTRY) NULL;
      WARNING1("HmgSetLock failed - invalid handle index or object type\n");
    }

    return((BOOL) (ULONG_PTR)pentTmp);
}

/******************************Public*Routine******************************\
* HmgQueryLock
*
* This returns the number of times an object has been Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this.
*
* Returns: The number of times the object has been locked.
*
* History:
*  28-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL HmgQueryLock(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);

// Note we don't need to grab the semaphore because this call assumes the
// handle has already been locked down and we are just reading memory.

    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgQueryLock invalid handle");

    return(gpentHmgr[uiIndex].einfo.pobj->cExclusiveLock);
}

/******************************Public*Routine******************************\
* HmgQueryAltLock
*
* This returns the number of times an object has been Alt-Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this.
*
* Returns: The number of times the object has been locked.
*
* History:
*  28-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL HmgQueryAltLock(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);

// Note we don't need to grab the semaphore because this call assumes the
// handle has already been locked down and we are just reading memory.

    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgQueryAltLock invalid handle");

    return((ULONG) gpentHmgr[uiIndex].einfo.pobj->ulShareCount);
}

/******************************Public*Routine******************************\
* HOBJ hGetFreeHandle()
*
* Get the next available handle.
*
* History:
*  Mon 21-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make pent commit memory as needed, add logging of error codes.
*
*  Sun 20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* add uniqueness to the handle when getting it.
*
*  12-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ hGetFreeHandle(
    OBJTYPE objt
    )
{

#if GDI_PERF
    HmgCurrentNumberOfHandles[objt]++;
    HmgNumberOfHandlesAllocated[objt]++;

    if (HmgCurrentNumberOfHandles[objt] > HmgMaximumNumberOfHandles[objt])
        HmgMaximumNumberOfHandles[objt]++;
#endif

    LONG_PTR uiIndex;

    if (ghFreeHmgr != (HOBJ) 0)
    {
        PENTRYOBJ  pentTmp;

        uiIndex = HmgIfromH(ghFreeHmgr);
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];
        ghFreeHmgr = pentTmp->einfo.hFree;

        pentTmp->FullUnique = USUNIQUE(pentTmp->FullUnique,objt);

        uiIndex = (LONG_PTR)MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);
        return((HOBJ) uiIndex);
    }

    if (gcMaxHmgr >= MAX_HANDLE_COUNT)
    {
        WARNING("Hmgr hGetFreeHandle failed to grow\n");
        return ((HOBJ) 0);
    }

    //
    // Allocate a new handle table entry and set the uniqueness value.
    //
    // N.B. All newly committed memory is zeroed.
    //

    uiIndex = USUNIQUE(UNIQUE_INCREMENT,objt);
    gpentHmgr[gcMaxHmgr].FullUnique = (USHORT) uiIndex;
    uiIndex = (LONG_PTR)MAKE_HMGR_HANDLE(gcMaxHmgr,uiIndex);
    gcMaxHmgr++;
    return((HOBJ) uiIndex);
}

/******************************Public*Routine******************************\
* HmgModifyHandleUniqueness()
*
* The handle passed in has already been updated to the new handle.
*
* This routine adds bits to the uniquess, updating both the handle entry
* and and the handle in the object it self.  This routine assumes that it is
* safe to be playing with the handle.  This means that the handle is locked
* or it is during initialization and setting the stock bit.
*
*
* History:
*  18-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HOBJ HmgModifyHandleType(
    HOBJ  h
    )
{
    PENTRY pent    = &gpentHmgr[HmgIfromH(h)];
    USHORT usUnique = HmgUfromH(h);

    ASSERTGDI((((ULONG_PTR)pent->einfo.pobj->hHmgr ^ (ULONG_PTR)h) & (UNIQUE_MASK | TYPE_MASK)) == 0,
                                           "HmgModifyHandleType bad handle\n");

    ASSERTGDI((pent->einfo.pobj->cExclusiveLock > 0) ||
              (pent->einfo.pobj->ulShareCount > 0) ||
              HmgStockObj(h),
              "HmgModifyHandleType not safe\n");

    pent->FullUnique = usUnique;
    pent->einfo.pobj->hHmgr = h;
    return(h);
}


/******************************Public*Routine******************************\
* HmgLockAndModifyHandleType()
*
* The handle passed in has already been updated to the new handle.
*
* The Handle is locked assuming owned by OBJECT_OWNER_CURRENT
* or ObJECT_OWNER_PUBLIC.
*
* Then this routine adds bits to the uniquess, updating both the handle entry
* and and the handle in the object it self.
*
* History:
*  31-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

BOOL HmgLockAndModifyHandleType(
    HOBJ  h
    )
{
    PENTRY pent    = &gpentHmgr[HmgIfromH(h)];

    HANDLELOCK HandleLock(pent,TRUE);

    if (HandleLock.bValid())
    {
        HmgModifyHandleType(h);

        HandleLock.vUnlock();

        return(TRUE);
    }
    return(FALSE);
}
/******************************Public*Routine******************************\
* HmgIncUniqueness()
*
* Modify the handle uniqueness
*
* This is implemented for the brush/pen caching and lazy deletion to make sure:
*
*  a)a handle will not be cached twice (changing the handle uniqueness gurantees this)
*
*  b)a handle will not be cached if it is a lazy deletion (cShareLock == 0)
*
* History:
*  8-May-1995 -by-  Lingyun Wang [lingyunw]
*
\**************************************************************************/

HOBJ
HmgIncUniqueness(
    HOBJ  hobj,
    OBJTYPE objt
    )
{
    PENTRY pentry;
    USHORT usUnique = HmgUfromH(hobj);
    POBJ   pobj;
    UINT   uiIndex= (UINT) HmgIfromH(hobj);
    HOBJ   hNew = NULL;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);

        if (HandleLock.bValid())
        {
            //
            // validate objt and uniqueness, increment unique if correct
            //

            if (
                 (pentry->FullUnique == usUnique) &&
                 (OBJECTOWNER_PID(pentry->ObjectOwner) == W32GetCurrentPID()) &&
                 ((pentry = &gpentHmgr[uiIndex])->Objt == objt)
               )
            {
                pentry->FullUnique += UNIQUE_INCREMENT;

                hNew = (HOBJ)MAKE_HMGR_HANDLE(uiIndex, pentry->FullUnique);

                pentry->einfo.pobj->hHmgr = hNew;
            }
            HandleLock.vUnlock();
        }
    }

    return(hNew);
}

/******************************Public*Routine******************************\
* int NtGdiGetStats(HANDLE,int,int,PVOID,UINT)
*
* This function returns information from the handle manager about
* the gdi objects that are existing.
*
* Parameters:
*    hProcess - handle to the process to query for information about
*    iIndex   - type of information to return
*    iPidType - whether to query for just the process pointed
*               to by hProcess, or ALL gdi objects or PUBLIC gdi objects
*    pResults - Pointer to the buffer to fill the data into
*    cjResultSize - Size of the buffer to fill
*
* The user buffer is expected to be zero'd. Memory trashing
* may occur if the size parameter is incorrect.
*
* returns: Success state
*
* History:
*  Wed 7-Jun-1995 -by- Andrew Skowronski [t-andsko]
* Wrote it.
\**************************************************************************/

#define OBJECT_OWNER_IGNORE (0x0001)

NTSTATUS APIENTRY
NtGdiGetStats(
    HANDLE  hProcess,
    int     iIndex,
    int     iPidType,
    PVOID   pResults,
    UINT    cjResultSize
    )
{
    DWORD   *   pdwRes = (DWORD *) pResults;    //Pointer to the result buffer
    W32PID      pid;
    PENTRY      pHmgEntry;                      //Pointer to current entry in the handle manager table
    ULONG       ulLoop;
    NTSTATUS    iRet   = STATUS_SUCCESS;

    //
    // Check permissions flag
    //

#if !defined(_GDIPLUS_)

    if (!( RtlGetNtGlobalFlags() & FLG_POOL_ENABLE_TAGGING))
    {
          iRet = STATUS_ACCESS_DENIED;
    }

#endif

    //
    // Validate buffer size
    //

    switch(iIndex)
    {
        case (GS_NUM_OBJS_ALL) :
            if (cjResultSize < ((MAX_TYPE+1)*sizeof(ULONG)))
                iRet = STATUS_BUFFER_TOO_SMALL;
            break;

#if DBG
        case (GS_HANDOBJ_CURRENT) :
        case (GS_HANDOBJ_MAX)     :
        case (GS_HANDOBJ_ALLOC)   :
        case (GS_LOOKASIDE_INFO)  :
            if (cjResultSize < ((MAX_TYPE+1)*sizeof(ULONG)*2))
                iRet = STATUS_BUFFER_TOO_SMALL;
            break;
#else
        // This info is not available in non-checked builds
        case (GS_HANDOBJ_CURRENT) :
        case (GS_HANDOBJ_MAX)     :
        case (GS_HANDOBJ_ALLOC)   :
        case (GS_LOOKASIDE_INFO)  :
            break;
#endif

        default :
            iRet = STATUS_NOT_IMPLEMENTED;
            break;
    }

    if (NT_SUCCESS(iRet))
    {
        __try
        {
            ProbeForWrite(pResults, cjResultSize, sizeof(UCHAR));

            switch(iIndex)
            {
                case (GS_NUM_OBJS_ALL) :

                    //
                    // Determine the search key.
                    //

                    if (iPidType == (int) OBJECT_OWNER_CURRENT)
                    {
                        pid = (W32PID) ((ULONG) ((ULONG_PTR)hProcess & PID_BITS));
                    }
                    else
                    {
                        //
                        // This takes care of OBJECT_OWNER_PUBLIC
                        // and OBJECT_OWNER_IGNORE
                        //

                        pid = (W32PID) iPidType;
                    }

                    //
                    // Scan through the handle manager table and
                    // pick out the relevant objects
                    //

                    for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
                    {
                        pHmgEntry = &(gpentHmgr[ulLoop]);

                        if ((pid == OBJECT_OWNER_IGNORE) ||
                            (pid == OBJECTOWNER_PID(pHmgEntry->ObjectOwner)))
                        {
                            //
                            // Now, depending on the iIndex value we
                            // analyse the results
                            //

                            switch (iIndex)
                            {
                                case (GS_NUM_OBJS_ALL) :
                                    pdwRes[pHmgEntry->Objt]++;
                                    break;
                                default :
                                    iRet = STATUS_NOT_IMPLEMENTED;
                                    break;
                            }
                        }
                    }
                    break;

#if DBG
                case (GS_HANDOBJ_CURRENT) :
                    RtlCopyMemory(pdwRes,
                                  HmgCurrentNumberOfHandles,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgCurrentNumberOfObjects,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_HANDOBJ_MAX)     :
                    RtlCopyMemory(pdwRes,
                                  HmgMaximumNumberOfHandles,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgMaximumNumberOfObjects,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_HANDOBJ_ALLOC)   :
                    RtlCopyMemory(pdwRes,
                                  HmgNumberOfHandlesAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgNumberOfObjectsAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_LOOKASIDE_INFO)  :
                    RtlCopyMemory(pdwRes,
                                  HmgNumberOfLookAsideHits,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgNumberOfObjectsAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

#else
                // This info is not available in non-checked builds
                case (GS_HANDOBJ_CURRENT) :
                case (GS_HANDOBJ_MAX)     :
                case (GS_HANDOBJ_ALLOC)   :
                case (GS_LOOKASIDE_INFO)  :
                    break;
#endif
                default :
                    iRet = STATUS_NOT_IMPLEMENTED;
                    break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            iRet = STATUS_ACCESS_VIOLATION;
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* HmgAllocateSecureUserMemory
*
*   Allocate and lock 1 page, add as free DC_ATTRs
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    15-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PVOID
HmgAllocateSecureUserMemory()
{
    PVOID pvRet = NULL;
    NTSTATUS NtStatus;

    //
    // allocate 1 page of user mode memory
    //

    SIZE_T ViewSize = PAGE_SIZE;

    NtStatus = ZwAllocateVirtualMemory(
                            NtCurrentProcess(),
                            &pvRet,
                            0L,
                            &ViewSize,
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE
                            );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // secure virtual memory
        //

        HANDLE hSecure = MmSecureVirtualMemory(pvRet, ViewSize, PAGE_READWRITE);

        if (hSecure != NULL)
        {
            RtlZeroMemory((PVOID)pvRet,ViewSize);
        }
        else
        {
            //
            // free memory
            //

            ZwFreeVirtualMemory(
                        NtCurrentProcess(),
                        (PVOID*)&pvRet,
                        &ViewSize,
                        MEM_RELEASE);

            pvRet = NULL;
        }
    }

    return(pvRet);
}


/******************************Public*Routine******************************\
* HmgAllocateDcAttr
*
*   Look first for free DC_ATTR block on thread, else look on process
*   free list. If none is available, try to allocate user-mode memory.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   pDC_ATTR or NULL
*
* History:
*
*    24-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PDC_ATTR
HmgAllocateDcAttr()
{
    PW32THREAD  pThread = W32GetCurrentThread();
    PDC_ATTR    pDCAttr = NULL;

#if defined(_GDIPLUS_)

    pDCAttr = (DC_ATTR*) PALLOCMEM(sizeof(DC_ATTR), 'zzzG');

#else

    //
    // look on thread for free dcattr
    //

    if (pThread->pgdiDcattr)
    {
        pDCAttr = (PDC_ATTR)pThread->pgdiDcattr;
        pThread->pgdiDcattr = NULL;
    }
    else
    {
        PW32PROCESS Process = W32GetCurrentProcess();

        GreAcquireHmgrSemaphore();

        //
        // look on process list for free dcattr, if none are
        // available then allocate 1 page of memory and add
        // to list.
        //

        if (Process->pDCAttrList == NULL)
        {

            PDC_ATTR pdca = (PDC_ATTR)HmgAllocateSecureUserMemory();

            if (pdca != (PDC_ATTR)NULL)
            {
                ULONG ulIndex;

                //
                // calculate number of DCATTR blocks in 1 page
                //

                ULONG ulNumDC = PAGE_SIZE/sizeof(DC_ATTR);

                //
                // init process list, then create a linked list of all
                // the new dcattrs on the process list
                //

                Process->pDCAttrList = (PVOID)pdca;

                for (ulIndex=0;ulIndex<ulNumDC-1;ulIndex++)
                {
                    ((PSINGLE_LIST_ENTRY)(&pdca[ulIndex]))->Next = (PSINGLE_LIST_ENTRY)&pdca[ulIndex+1];
                }

                //
                // init last list element
                //

                ((PSINGLE_LIST_ENTRY)(&pdca[ulIndex]))->Next = NULL;
            }
        }

        if (Process->pDCAttrList != NULL)
        {
            //
            // get dcattr and remove from list
            //

            pDCAttr = (PDC_ATTR)Process->pDCAttrList;

            Process->pDCAttrList = ((PSINGLE_LIST_ENTRY)pDCAttr)->Next;
        }

        GreReleaseHmgrSemaphore();
    }

#endif

    return(pDCAttr);
}

/******************************Public*Routine******************************\
* HmgAllocateBrushAttr
*
*   Look on thread for free brushattr, else look on process free
*   list. If none is available, allocate a dcattr and divide it
*   up.
*
* Arguments:
*
*   none
*
* Return Value:
*
*   pbrushattr or NULL
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

POBJECTATTR
HmgAllocateObjectAttr()
{
    PW32THREAD    pThread = W32GetCurrentThread();
    POBJECTATTR   pobjattr = NULL;

#if defined(_GDIPLUS_)

    pobjattr = (OBJECTATTR*) PALLOCMEM(sizeof(OBJECTATTR), 'zzzG');

#else

    //
    // quick check on thread for free OBJECTATTR
    //

    if (pThread->pgdiBrushAttr)
    {
        pobjattr = (POBJECTATTR)pThread->pgdiBrushAttr;
        pThread->pgdiBrushAttr = NULL;
    }
    else
    {
        PW32PROCESS Process = W32GetCurrentProcess();

        GreAcquireHmgrSemaphore();

        //
        // look on process list for free dcattr, if none are
        // available then allocate 1 page of memory and add
        // to list.
        //

        if (Process->pBrushAttrList == NULL)
        {

            POBJECTATTR psbr = (POBJECTATTR)HmgAllocateSecureUserMemory();

            if (psbr != (POBJECTATTR)NULL)
            {
                ULONG ulIndex;

                //
                // calculate number of DCATTR blocks in 1 page
                //

                ULONG ulNumBrush = PAGE_SIZE/sizeof(OBJECTATTR);

                //
                // init process list, then create a linked list of all
                // the new dcattrs on the process list
                //

                Process->pBrushAttrList = (PVOID)psbr;

                for (ulIndex=0;ulIndex<ulNumBrush-1;ulIndex++)
                {
                    psbr[ulIndex].List.Next = &psbr[ulIndex+1].List;
                }

                //
                // init last list element
                //

                psbr[ulIndex].List.Next = NULL;
            }
        }

        if (Process->pBrushAttrList != NULL)
        {
            //
            // get dcattr and remove from list
            //

            pobjattr = (POBJECTATTR)Process->pBrushAttrList;

            Process->pBrushAttrList = pobjattr->List.Next;
        }

        GreReleaseHmgrSemaphore();
    }

#endif

    return(pobjattr);
}

/******************************Public*Routine******************************\
* HmgFreeDcAttr
*
*   Free the dcattr, try to put it on w32thread, if no space then push onto
*   w32process
*
* Arguments:
*
*   pdcattr
*
* Return Value:
*
*   none
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgFreeDcAttr(
    PDC_ATTR pdca
    )
{
    PW32THREAD  pThread = W32GetCurrentThread();

#if defined(_GDIPLUS_)

    VFREEMEM(pdca);

#else

    if ((pdca != NULL) && (pThread != NULL))
    {

        //
        // try to place on thread
        //

        if (pThread->pgdiDcattr == NULL)
        {
             pThread->pgdiDcattr = pdca;
        }
        else
        {
            PW32PROCESS Process = W32GetCurrentProcess();

            //
            // Need to check if W32 process pointer is valid.  There are
            // circumstances in which the process can die without setting
            // the W32 process.
            //

            if (Process != NULL)
            {
                GreAcquireHmgrSemaphore();

                //
                // place on process single linked list
                //

                ((PSINGLE_LIST_ENTRY)pdca)->Next = (PSINGLE_LIST_ENTRY)Process->pDCAttrList;
                Process->pDCAttrList = pdca;

                GreReleaseHmgrSemaphore();
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* HmgFreeObjectAttr
*
*   Free the objattr, try to put it on w32thread, if no space then
*   check other part(s) of block that make up a dcattr. If they are
*   free then place whole dcattr back on dcattr list.
*
* Arguments:
*
*   pobjattr
*
* Return Value:
*
*   none
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgFreeObjectAttr(
    POBJECTATTR pobjattr
    )
{
    PW32THREAD  pThread = W32GetCurrentThread();

#if defined(_GDIPLUS_)

    VFREEMEM(pobjattr);

#else

    if ((pobjattr != NULL) && (pThread != NULL))
    {
        //
        // try to place on thread
        //

        if (pThread->pgdiBrushAttr == NULL)
        {
             pThread->pgdiBrushAttr = pobjattr;
        }
        else
        {
            PW32PROCESS Process = W32GetCurrentProcess();

            //
            // Need to check if W32 process pointer is valid.  There are
            // circumstances in which the process can die without setting
            // the W32 process.
            //

            if (Process != NULL)
            {
                GreAcquireHmgrSemaphore();

                //
                // place on process single linked list
                //

                pobjattr->List.Next = (PSINGLE_LIST_ENTRY)Process->pBrushAttrList;
                Process->pBrushAttrList = pobjattr;

                GreReleaseHmgrSemaphore();
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* GreIncQuotaCount GreDecQuotaCount
*
* This is called by user Inc or Dec cursor bitmaps against the creating process
*
* Notice that cursor bitmaps are marked as PUBLIC by USER but charged against
* the creating process's handle quota
*
* History:
* 2/10/98 - by Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID GreIncQuotaCount(PW32PROCESS pW32)
{
    InterlockedIncrement((PLONG)(&pW32->GDIHandleCount));
    return;
}

VOID GreDecQuotaCount(PW32PROCESS pW32)
{
    InterlockedDecrement((PLONG)(&pW32->GDIHandleCount));
    return;
}


/******************************Public*Routine******************************\
* HmgPrintBadHandle
*
*   Simple routine that prints out a warning when a handle manager
*   lock fails due to a bad handle.
*
\**************************************************************************/

#if DBG

CONST CHAR* aszType[] = {
    "hdef",         // DEF_TYPE
    "HDC",          // DC_TYPE
    "hunused",      // DD_DIRECTDRAW_TYPE
    "hunused",      // DD_SURFACE_TYPE
    "HRGN",         // RGN_TYPE
    "HBITMAP",      // SURF_TYPE
    "HCLIENT",      // CLIENTOBJ_TYPE
    "hpath",        // PATH_TYPE
    "HPALETTE",     // PAL_TYPE
    "HCOLORSPACE",  // ICMLCS_TYPE
    "HFONT",        // LFONT_TYPE
    "hrfont",       // RFONT_TYPE
    "hpfe",         // PFE_TYPE
    "hpft",         // PFT_TYPE
    "hicmcxf",      // ICMCXF_TYPE
    "HSPRITE",      // SPRITE_TYPE
    "HBRUSH",       // BRUSH_TYPE
    "hunused",      // D3D_HANDLE_TYPE
    "hunused",      // DD_VIDEOPORT_TYPE
    "hspace",       // SPACE_TYPE
    "hunused",      // DD_MOTIONCOMP_TYPE
    "HENHMETAFILE", // META_TYPE
    "hefstate",     // EFSTATE_TYPE
    "hunused",      // BMFD_TYPE
    "hunused",      // VTFD_TYPE
    "hunused",      // TTFD_TYPE
    "hunused",      // RC_TYPE
    "hunused",      // TEMP_TYPE
    "HDRVOBJ",      // DRVOBJ_TYPE
    "hunused",      // DCIOBJ_TYPE
    "hspool",       // SPOOL_TYPE
    "hunused",      //
};

VOID
HmgPrintBadHandle(
    HOBJ    hobj,
    OBJTYPE objt
    )
{
    static CHAR *szSystem = "System";
    static CHAR *szUnknown = "???";
    CHAR        *pszImage;

    {
        PETHREAD    pet;
        PEPROCESS   pep;

        if (pep = PsGetCurrentProcess())
        {
            pszImage = (CHAR *)PsGetProcessImageFileName(pep);
            if (*pszImage == '\0')
            {
                pszImage = szSystem;
            }
        }
        else
        {
            pszImage = szUnknown;
        }
    }

    KdPrint(("GDI: %s or DLL gave bad handle 0x%p as an %s.\n",
        pszImage, hobj, aszType[objt]));

    // Private debug code to catch invalid hpath handle in DC
    // 6/24/98 - davidx

    if (hobj != NULL && objt == PATH_TYPE)
    {
        RIP("Private debug breakpoint. Please contact ntgdi.");
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\icmobj.cxx ===
/*******************************Module*Header*******************************\
* Module Name:
*
*   icmobj.cxx
*
* Abstract
*
*   This module contains object support for COLORTRANSFORM objects and ICM
*   Objects
*
* Author:
*
*  Feb.23.1997 -by- Hideyuki Nagase [hideyukn]
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* COLORTRANSFORMOBJ::hCreate()
*
* History:
*
* Write it:
*    23-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE
COLORTRANSFORMOBJ::hCreate(
    XDCOBJ&         dco,
    LOGCOLORSPACEW *pLogColorSpaceW,
    PVOID           pvSource,
    ULONG           cjSource,
    PVOID           pvDestination,
    ULONG           cjDestination,
    PVOID           pvTarget,
    ULONG           cjTarget
    )
{
    HANDLE hObject = NULL;

    PCOLORTRANSFORM pNewCXform = NULL;

    ICMAPI(("COLORTRANSFORM::hCreate()\n"));

    HDEV hdev = dco.hdev();

    //
    // This object should not have any existing realization.
    //
    ASSERTGDI(_pColorTransform == NULL,"COLORTRANSFORMOBJ::hCreate() object is exist\n");

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        //
        // Allocate ColorTransform object.
        //
        pNewCXform = (PCOLORTRANSFORM) ALLOCOBJ(sizeof(COLORTRANSFORM),ICMCXF_TYPE, FALSE);

        if (pNewCXform)
        {
            //
            // Register COLORTRANSFORM handle.
            //
            hObject = (HCOLORSPACE)HmgInsertObject(
                                        pNewCXform,
                                        HMGR_ALLOC_ALT_LOCK,
                                        ICMCXF_TYPE);

            if (hObject)
            {
                HANDLE hDeviceColorTransform = NULL;

                //
                // Set new object to this COLORTRANSFORMNOBJ
                //
                _pColorTransform = pNewCXform;

                //
                // Lock device
                //
                DEVLOCKOBJ devLock(po);

                //
                // Create driver's transform.
                //
                if (PPFNVALID(po,IcmCreateColorTransform))
                {
                    //
                    // Call device driver to obtain handle of device driver.
                    //
                    hDeviceColorTransform = (*PPFNDRV(po, IcmCreateColorTransform)) (
                                                          po.dhpdev(),
                                                          pLogColorSpaceW,
                                                          pvSource, cjSource,
                                                          pvDestination, cjDestination,
                                                          pvTarget, cjTarget,
                                                          0 /* dwReserved */);
                }
                else
                {
                    WARNING("CreateColorTransform called on device that does not support call\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                }

                if (hDeviceColorTransform)
                {
                    ICMMSG(("CreateColorTransform(): Succeed to get handle from driver\n"));

                    //
                    // Set the handle to COLORTRANSFORM object.
                    //
                    vSetDeviceColorTransform(hDeviceColorTransform);

                    //
                    // Insert this pColorTransform to this DC.
                    //
                    dco.bAddColorTransform(hObject);
                }
                else
                {
                    ICMMSG(("CreateColorTransform(): Fail to get handle from driver\n"));

                    //
                    // Mark this object does not have driver's realization.
                    //
                    vSetDeviceColorTransform(NULL);

                    //
                    // We are fail to get driver's handle, delete this.
                    //
                    bDelete(dco);

                    //
                    // Invalidate hObject and pColorTransform.
                    //  (these are deleted in above bDelete())
                    //
                    hObject = NULL;
                    pNewCXform = NULL;
                }
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        }

        if ((hObject == NULL) && (pNewCXform != NULL))
        {
            FREEOBJ(pNewCXform,ICMCXF_TYPE);
        }
    }

    return (hObject);
}

/******************************Public*Routine******************************\
* COLORTRANSFORMOBJ::bDelete()
*
* History:
*
* Write it:
*    23-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
COLORTRANSFORMOBJ::bDelete(XDCOBJ& dco,BOOL bProcessCleanup)
{
    BOOL bRet = FALSE;

    PCOLORTRANSFORM pDeleteXCForm;

    ICMAPI(("COLORTRANSFORM::bDelete()\n"));

    if (bValid())
    {
        BOOL bCanBeRemoved;

        //
        // Get colortransform object handle.
        //
        HANDLE hObject = _pColorTransform->hColorTransform();

        //
        // Unlock it. (this was locked in constructor).
        //
        DEC_SHARE_REF_CNT(_pColorTransform);

        //
        // Remote from object table.
        //
        bCanBeRemoved = (BOOL)(ULONG_PTR)HmgRemoveObject((HOBJ)(hObject),0,0,TRUE,ICMCXF_TYPE);

        if (bCanBeRemoved)
        {
            HANDLE hDeviceColorTransform;

            //
            // Yes, we can remove object from object table, try to delete driver's realization.
            //
            ICMMSG(("DeleteColorTransform(): Succeed to remove object from table\n"));

            //
            // Get device driver's handle.
            //
            hDeviceColorTransform = hGetDeviceColorTransform();

            if (hDeviceColorTransform)
            {
                //
                // Initialize PDEV object with owner.
                //
                PDEVOBJ po(dco.hdev());

                if (po.bValid())
                {
                    if (po.bUMPD() && bProcessCleanup)
                    {
                        ICMMSG(("DeleteColorTransform():Will not callout to user mode since UMPD.\n"));

                        //
                        // Overwrite driver transform as NULL.
                        //
                        vSetDeviceColorTransform(NULL);
                    }
                    else
                {
                    DEVLOCKOBJ devLock(po);

                    //
                    // Delete driver's realization.
                    //
                    if (PPFNVALID(po,IcmDeleteColorTransform))
                    {
                        //
                        // Call device driver to free driver's handle
                        //
                        if ((*PPFNDRV(po, IcmDeleteColorTransform))(
                                               po.dhpdev(),
                                               hDeviceColorTransform))
                        {
                            ICMMSG(("DeleteColorTransform():Succeed to IcmDeleteColorTransform()\n"));

                            //
                            // This object does not have driver realization anymore.
                            //
                            vSetDeviceColorTransform(NULL);
                        }
                        else
                        {
                            WARNING("DeleteColorTransform():Fail to IcmDeleteColorTransform()\n");
                        }
                    }
                    else
                    {
                        WARNING("DeleteColorTransform called on device that does not support call\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    }
                }
            }
            }
            else
            {
                ICMMSG(("DeleteColorTransform(): There is no driver handle\n"));
            }

            //
            // We could delete object allocation if there is no driver's realization.
            //
            if (hGetDeviceColorTransform() == NULL)
            {
                //
                // Remove this pColorTransform from DC.
                //
                dco.bRemoveColorTransform(hObject);

                //
                // Free it.
                //
                FREEOBJ(_pColorTransform,ICMCXF_TYPE);

                //
                // Invalidate pointer.
                //
                _pColorTransform = NULL;

                //
                // Yes, everything fine!
                //
                bRet = TRUE;
            }
        }
        else
        {
            ICMMSG(("DeleteColorTransform(): Fail to remove object from table\n"));
        }

        //
        // If we could not remove this object from object table, or could not
        // delete object (including driver's realization)
        //
        if ((!bCanBeRemoved) || (!bRet))
        {
            //
            // can not delete now. somebody will using...
            //
            WARNING("COLORTRANSFORMOBJ::vDelete(): Fail to Delete object, lazy deletion may happen\n");

            //
            // Back reference counter (deconstuctor will decrement this).
            //
            INC_SHARE_REF_CNT(_pColorTransform);

            //
            // Anyway, we will delete later at cleanup.
            //
            bRet = TRUE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* XDCOBJ::bAddColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL XDCOBJ::bAddColorTransform(HANDLE hCXform)
{
    CXFLIST *pCXFListThis;

    //
    // Allocate new cell of CXFLIST
    //
    pCXFListThis = (CXFLIST *) PALLOCMEM(sizeof(CXFLIST),'ddaG');

    if (pCXFListThis)
    {
        //
        // Fill up CXFLIST structure
        //
        pCXFListThis->hCXform = hCXform;
        pCXFListThis->pNext   = pdc->pCXFList;

        //
        // Insert this into top of list.
        //
        pdc->pCXFList = pCXFListThis;

        return (TRUE);
    }
    else
    {
        ICMMSG(("XDCOBJ::bAddColorTransform() Failed\n"));
        return (FALSE);
    }
}

/******************************Public*Routine******************************\
* XDCOBJ::bRemoveColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL XDCOBJ::bRemoveColorTransform(HANDLE hCXform)
{
    if (pdc->pCXFList)
    {
        PCXFLIST pPrev, pThis;

        pPrev = pThis = pdc->pCXFList;

        while (pThis)
        {
            if (pThis->hCXform == hCXform)
            {
                //
                // This is the cell, we need to remove.
                //
                if (pPrev == pThis)
                {
                    //
                    // We are going to remove first cell. then need to
                    // update root.
                    //
                    pdc->pCXFList = pThis->pNext;
                }
                else
                {
                    //
                    // Remove this from list.
                    //
                    pPrev->pNext = pThis->pNext;
                }

                //
                // Invalidate root.
                //
                VFREEMEM(pThis);

                return (TRUE);
            }

            //
            // Move to next cell
            //
            pPrev = pThis;
            pThis = pThis->pNext;
        }
    }
    else
    {
        ICMMSG(("bRemoveColorTransform():There is no colortransform()\n"));
    }

    return (FALSE);
}

/******************************Public*Routine******************************\
* XDCOBJ::vCleanupColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID XDCOBJ::vCleanupColorTransform(BOOL bProcessCleanup)
{
    if (pdc->pCXFList)
    {
        PCXFLIST pLast, pThis;

        pThis = pdc->pCXFList;

        while (pThis)
        {
            COLORTRANSFORMOBJ CXformObj(pThis->hCXform);

            pLast = pThis;

            if (CXformObj.bValid())
            {
                //
                // Delete this color transform
                //
                if (CXformObj.bDelete(*this,bProcessCleanup))
                {
                    ICMMSG(("vCleanupColorTransform():Delete colortransform in this DC\n"));
                }
                else
                {
                    ICMMSG(("vCleanupColorTransform():Fail to delete colortransform in this DC\n"));
                }
            }

            //
            // we don't need to walk through the list, because above COLORTRANSFORMOBJ.bDelete()
            // will re-chain this list, then we just pick up the cell on the top of list everytime.
            //
            pThis = pdc->pCXFList;

            //
            // But if still new pThis is eqaul to pLast, this means we might fail to
            // delete object or un-chain list, then just un-chain this forcely.
            //
            if (pThis == pLast)
            {
                //
                // Skip pThis.
                //
                pThis = pThis->pNext;

                //
                // Update root too,
                //
                pdc->pCXFList = pThis;
            }
        }
    }
    else
    {
        // ICMMSG(("vCleanupColorTransform():There is no color transform in this DC\n"));
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::CorrectColors()
*
* History:
*
* Write it:
*    29-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID XEPALOBJ::CorrectColors(PPALETTEENTRY ppalentry, ULONG cEntries)
{
    ICMMSG(("XEPALOBJ::CorrectColors\n"));

    PDEVOBJ po(hdevOwner());

    if (po.bValid())
    {
        if (po.bHasGammaRampTable())
        {
            ICMMSG(("XEPALOBJ::CorrectColors(): Do Gamma Correction\n"));
            ICMMSG(("XEPALOBJ::CorrectColors(): GammaRamp Owner HDEV = %x\n",po.hdev()));

            PGAMMARAMP_ARRAY pGammaRampArray = (PGAMMARAMP_ARRAY)(po.pvGammaRampTable());

            for (ULONG i = 0; i < cEntries; i++)
            {
                //
                // Adjust colors based on GammaRamp table.
                //
                ppalentry->peRed   = (pGammaRampArray->Red[ppalentry->peRed])     >> 8;
                ppalentry->peGreen = (pGammaRampArray->Green[ppalentry->peGreen]) >> 8;
                ppalentry->peBlue  = (pGammaRampArray->Blue[ppalentry->peBlue])   >> 8;

                //
                // next palette entry
                //
                ppalentry++;
            }
        }
        else
        {
            ICMMSG(("XEPALOBJ::CorrectColors(): PDEV does not have Gamma Table\n"));
        }
    }
    else
    {
        ICMMSG(("XEPALOBJ::CorrectColors(): PDEV is invalid\n"));
    }
}

/******************************Public*Routine******************************\
* UpdateGammaRampOnDevice()
*
* History:
*
* Write it:
*    29-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL UpdateGammaRampOnDevice(HDEV hdev,BOOL bForceUpdate)
{
    BOOL bRet = FALSE;

    ICMMSG(("UpdateGammaRampOnDevice()\n"));

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        ICMMSG(("UpdateGammaRampOnDevice():Set GammaRamp to HDEV = %x\n",po.hdev()));

        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            //
            // Driver might provide the entry point.
            //
            if ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
                (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
            {
                //
                // PDEV should have GammaRampTable
                //
                if (po.bHasGammaRampTable())
                {
                    ICMMSG(("UpdateGammaRampOnDevice():Call SetDeviceGammaRamp()\n"));

                    //
                    // Call device driver to set new GammaRamp.
                    //
                    bRet = (*PPFNDRV(po, IcmSetDeviceGammaRamp))(po.dhpdev(),
                                                                 IGRF_RGB_256WORDS,
                                                                 po.pvGammaRampTable());
                }
            }
            else
            {
                //
                // if the drive does not support, we will simulate it only for 8bpp case.
                //
                if ((po.iDitherFormat() == BMF_8BPP) && (po.bIsPalManaged()))
                {
                    ICMMSG(("UpdateGammaRampOnDevice(): Call SetPalette()\n"));

                    //
                    // Check:
                    // 1) Are we going to reset pallete forcely ? (ex. back to default GammaRamp)
                    // 2) Or, Adjust Palette based on GammaRamp in PDEV.
                    //
                    if (bForceUpdate || po.bHasGammaRampTable())
                    {
                        //
                        // Get palette on device surface.
                        //
                        XEPALOBJ palSurf(po.ppalSurf());

                        ASSERTGDI(palSurf.bIsIndexed(),"UpdateGammaRampOnDevice(): Palette is not indexed\n");

                        //
                        // Mark this palette need to Gamma correction
                        // (if this is not default GammaRamp, default GammaRamp case
                        //  PDEV does not have table.)
                        //
                        palSurf.bNeedGammaCorrection(po.bHasGammaRampTable());

                        //
                        // And put owner of PDEV which has GammaRamp table.
                        // (if they already has some value in there, we will
                        //  overwrite it, but actually it should be same or
                        //  uninitialized.)
                        //
                        palSurf.hdevOwner(po.hdev());

                        ICMMSG(("UpdateGammaRampOnDevice():Set GammaRamp to HDEV = %x\n",po.hdev()));

                        //
                        // Update palettes based on new GammaRamp.
                        //
                        // (Color will be adjusted in PALOBJ_cGetColors())
                        //
                        GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
                        GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);
                        {
                            SEMOBJ so(po.hsemPointer());

                            if (!po.bDisabled())
                            {
                                ASSERTGDI(PPFNVALID(po,SetPalette),"ERROR palette is not managed");

                                bRet = (*PPFNDRV(po, SetPalette))(po.dhpdev(),
                                                                  (PALOBJ *) &palSurf,
                                                                  0, 0, palSurf.cEntries());
                            }
                        }
                        GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
                        GreReleaseSemaphoreEx(po.hsemDevLock());
                    }
                }
                else
                {
                    ICMMSG(("UpdateGammaRampOnDevice():Driver doesn't have DrvSetDeviceGammaRamp()\n"));
                }
            }
        }
        else
        {
            //
            // Can not set GammaRamp for 1/4 bpp surface
            //
            ICMMSG(("UpdateGammaRampOnDevice():GammaRamp does not support on 1/4 bpp\n"));
        }

        if (!bRet)
        {
            ICMMSG(("UpdateGammaRampOnDevice(): device driver returns error\n"));
        }
    }
    else
    {
        ICMMSG(("UpdateGammaRampOnDevice(): HDEV is invalid\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GetColorManagementCaps()
*
* History:
*
* Write it:
*    24-Feb-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

ULONG GetColorManagementCaps(PDEVOBJ& po)
{
    ULONG fl = CM_NONE;

    PDEVINFO pDevInfo = po.pdevinfoNotDynamic();

    //
    // Check CM_GAMMA_RAMP - it will be enabled when
    //
    //  0) Only for display device.
    //  1) DitherFormat is 8bpp. (GDI simulate regardless driver capabilities)
    //  2) Driver can do it.
    //
    if (po.bDisplayPDEV())
    {
        if ((pDevInfo->iDitherFormat == BMF_8BPP) ||
            (po.flGraphicsCaps2NotDynamic() & GCAPS2_CHANGEGAMMARAMP))
        {
            fl |= CM_GAMMA_RAMP;
        }
    }

    //
    // Check CM_CMYK_COLOR when driver can understand.
    //
    if (po.flGraphicsCapsNotDynamic() & GCAPS_CMYKCOLOR)
    {
        fl |= CM_CMYK_COLOR;
    }

    //
    // Check CM_DEVICE_ICM when driver can do.
    //
    if (po.flGraphicsCapsNotDynamic() & GCAPS_ICM)
    {
        fl |= CM_DEVICE_ICM;
    }

    return fl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\init.cxx ===
/******************************Module*Header*******************************\
* Module Name: init.cxx
*
* Engine initialization
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "verifier.hxx"
#include "winsta.h"

extern "C" USHORT gProtocolType;


BOOLEAN gIsTerminalServer;

extern BOOL         G_fConsole;
extern BOOL         G_fDoubleDpi;


extern "C" BOOL bInitPALOBJ();         // palobj.cxx
extern "C" VOID vInitXLATE();          // ylateobj.cxx
extern "C" BOOL bInitBMOBJ();          // surfeng.cxx
extern "C" BOOL InitializeScripts();   // fontsup.cxx
extern "C" BOOL bInitICM();            // icmapi.cxx
extern "C" BOOL bInitFontTables();     // pftobj.cxx
extern "C" BOOL bInitStockFonts(VOID); // stockfnt.cxx
extern "C" VOID vInitFontSubTable();   // fontsub.cxx
extern "C" BOOL bInitBRUSHOBJ();       // brushobj.cxx
extern "C" VOID vInitMapper();         // fontmap.cxx

extern USHORT GetLanguageID();


// Prototypes from font drivers.

extern "C" BOOL BmfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL ttfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL vtfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL atmfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" NTSTATUS FontDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

extern "C" BOOL bRegisterFontServer(VOID);
extern "C" BOOL bUserModeFontDrivers(VOID);

#ifdef LANGPACK
extern "C" NTSTATUS LpkShapeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);
#endif

//
// Prototypes from halftone
//

extern "C" BOOL PASCAL EnableHalftone(VOID);
extern "C" VOID PASCAL DisableHalftone(VOID);

//
// Hydra prototypes
//
extern "C" BOOL MultiUserGreCleanupInit();
extern "C" BOOL GreEngLoadModuleTrackInit();

//
// Functions are located in INIT segment
//
#pragma alloc_text(INIT, InitializeGre)
#pragma alloc_text(INIT, FontDriverQueryRoutine)
#ifdef LANGPACK
#pragma alloc_text(INIT, LpkShapeQueryRoutine)
#endif
#pragma alloc_text(INIT, bLoadProcessHandleQuota)
#pragma alloc_text(INIT, bRegisterFontServer)

/**************************************************************************\
 *
\**************************************************************************/

#if defined(i386) && !defined(_GDIPLUS_)
extern "C" PVOID GDIpLockPrefixTable;

//
// Specify address of kernel32 lock prefixes
//
extern "C" IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    0,                          // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    (ULONG) &GDIpLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0         // Reserved
    };
#endif

LONG      gProcessHandleQuota = INITIAL_HANDLE_QUOTA;

#if defined (_X86_)
    BOOL gbMMXProcessor = FALSE;
#endif

extern "C" VOID vConvertCodePageToCharSet(WORD src, DWORD *pfsRet, BYTE *pjRet);

VOID vGetJpn98FixPitch();

/******************************Public*Routine******************************\
* bEnableFontDriver
*
* Enables an internal, statically-linked font driver.
*
\**************************************************************************/

BOOL bEnableFontDriver(PFN pfnFdEnable, ULONG fl)
{
    //
    // Load driver.
    //

    PLDEV pldev;

    pldev = ldevLoadInternal(pfnFdEnable, LDEV_FONT);

    //
    // Validate the new LDEV
    //

    if (pldev)
    {
        //
        // Create the PDEV for this (the PDEV won't have anything in it
        // except the dispatch table.
        //

        PDEVOBJ po(pldev,
                   NULL,                // PDEVMODEW pdriv,
                   NULL,                // PWSZ pwszLogAddr,
                   NULL,                // PWSZ pwszDataFile,
                   NULL,                // PWSZ pwszDeviceName,
                   NULL,                // HANDLE hSpool,
                   NULL                 // PREMOTETYPEONENODE pRemoteTypeOne,
                   );

        if (po.bValid())
        {
            //
            // Was it the TrueType driver?  We need to keep a global handle to
            // it to support the Win 3.1 TrueType-specific calls.
            //

            if (fl & FNT_TT_DRV )
            {
                gppdevTrueType = (PPDEV) po.hdev();
            }

            if (fl & FNT_OT_DRV)
            {
                gppdevATMFD = (PPDEV) po.hdev();
                gufiLocalType1Rasterizer.CheckSum = TYPE1_RASTERIZER;
                gufiLocalType1Rasterizer.Index = 0x1;
            }

            FntCacheHDEV((PPDEV) po.hdev(), fl);

            po.ppdev->fl |= PDEV_FONTDRIVER;
            
            return(TRUE);
        }
    }

    WARNING("bLoadFontDriver failed\n");
    return(FALSE);
}

/******************************Public*Routine******************************\
* bDoubleDpi
*
* Read the registry to determine if we should implement our double-the-DPI
* hack.  This functionality was intended as a simple mechanism for the
* release of Windows 2000 for applications developers to test their 
* applications for conformance with upcoming high-DPI (200 DPI) displays.
* The problem is that currently only 75 to 100 DPI displays are available,
* but we know the high DPI displays are coming soon.
*
* So we implement this little hack that doubles the effective resolution
* of the monitor, and down-samples to the display.  So if your monitor does
* 1024x768, we make the system think it's really 2048x1536.
*
* Hopefully, this hacky functionality can be removed for the release after
* Windows 2000, as it's fairly unusable for anything other than simple
* test purposes.
*
\**************************************************************************/

BOOL bDoubleDpi(BOOL fConsole)
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    DWORD                       dwDoubleDpi;

    dwDoubleDpi = 0;

    ///For this to success, it must be console session(session 0)
    ///Connected locally to physical console.
    
    if (fConsole && (gProtocolType == PROTOCOL_CONSOLE))
    {
        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                             L"Control\\GraphicsDrivers");
    
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
    
        status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);
    
        if (NT_SUCCESS(status))
        {
            RtlInitUnicodeString(&UnicodeString, L"DoubleDpi");
    
            Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"DoubleDpi") +
                     sizeof(DWORD);
    
            Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');
    
            if (Information)
            {
                status = ZwQueryValueKey(hkRegistry,
                                           &UnicodeString,
                                           KeyValueFullInformation,
                                           Information,
                                           Length,
                                           &Length);
    
                if (NT_SUCCESS(status))
                {
                    dwDoubleDpi = *(LPDWORD) ((((PUCHAR)Information) +
                                    Information->DataOffset));
                }
    
                VFREEMEM(Information);
            }
    
            ZwCloseKey(hkRegistry);
        }
    }

    return(dwDoubleDpi == 1);
}

void vCheckTimeZoneBias()
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\TimeZoneInformation");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"ActiveTimeBias");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"ActiveTimeBias") +
                 sizeof(DWORD);

        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, 'pmtG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (!NT_SUCCESS(status))
            {
                gbGUISetup = TRUE;
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }
    else
    {
        gbGUISetup = TRUE;
    }
}

/******************************Public*Routine******************************\
* InitializeGreCSRSS
*
* Initialize the client-server subsystem portion of GDI. 
*
\**************************************************************************/

extern "C" BOOL InitializeGreCSRSS()
{

    // Init DirectX graphics driver

    if (!NT_SUCCESS(DxDdStartupDxGraphics(0,NULL,0,NULL,NULL,gpepCSRSS)))
    {
        WARNING("GRE: could not enable DirectDraw\n");
        return(FALSE);
    }

    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    USHORT AnsiCodePage, OemCodePage;

    // Init the font drivers

    gppdevTrueType = NULL;
    gppdevATMFD = NULL;
    gcTrueTypeFonts = 0;
    gulFontInformation = 0;
    gusLanguageID = GetLanguageID();

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    vConvertCodePageToCharSet(
        AnsiCodePage,
        &gfsCurSignature,
        &gjCurCharset);

    gbDBCSCodePage = (IS_ANY_DBCS_CODEPAGE(AnsiCodePage)) ? TRUE : FALSE;

    InitFNTCache();

    vCheckTimeZoneBias();

    //
    // NOTE: we are disabling ATM and vector font drivers for _GDIPLUS_ work
    //

    #ifndef _GDIPLUS_

    QueryTable[0].QueryRoutine = FontDriverQueryRoutine;
    QueryTable[0].Flags = 0; // RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    // Enumerate and initialize all the font drivers.

    RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT | RTL_REGISTRY_OPTIONAL,
                           (PWSTR)L"Font Drivers",
                           &QueryTable[0],
                           NULL,
                           NULL);

    if (!bEnableFontDriver((PFN) atmfdEnableDriver, FNT_OT_DRV))
    {
        WARNING("GDISRV.DLL could not enable ATMFD stub\n");
    	return(FALSE);
    }
    
    if (!bEnableFontDriver((PFN) vtfdEnableDriver, FNT_VT_DRV))
    {
        WARNING("GDISRV.DLL could not enable VTFD\n");
        return(FALSE);
    }

    #endif // !_GDIPLUS_

    // We need to get the fix pitch registry first
    // This is only JPN platform
    vGetJpn98FixPitch();

    if (!bEnableFontDriver((PFN) BmfdEnableDriver, FNT_BMP_DRV))
    {
        WARNING("GDISRV failed to enable BMFD\n");
        return(FALSE);
    }

    if (!bEnableFontDriver((PFN) ttfdEnableDriver, FNT_TT_DRV))
    {
        WARNING("GDISRV.DLL could not enable TTFD\n");
        return(FALSE);
    }
    //
    // Init global public PFT
    //

    if (!bInitFontTables())
    {
        WARNING("Could not start the global font tables\n");
        return(FALSE);
    }

    //
    // Initialize LFONT
    //

    TRACE_FONT(("GRE: Initializing Stock Fonts\n"));

    if (!bInitStockFonts())
    {
        WARNING("Stock font initialization failed\n");
        return(FALSE);
    }

    TRACE_FONT(("GRE: Initializing Font Substitution\n"));

    // Init font substitution table

    vInitFontSubTable();

    // Load default face names for the mapper from the registry

    vInitMapper();

    if (!bInitializeEUDC())
    {
        WARNING("EUDC initialization failed\n");
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* InitializeGre
*
* Initialize the Graphics Engine.  This call is made once by USER.
*
* History:
*  Thu 29-Oct-1992 -by- Patrick Haluptzok [patrickh]
* Remove wrappers, unnecesary semaphore use, bogus variables, cleanup.
*
*  10-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG CountInit = 1;

extern "C" BOOL gbRemoteSession; // as in ntuser\kernel\globals.c

extern "C" BOOLEAN InitializeGre(
    VOID)
{
#ifdef LANGPACK
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
#endif

    G_fConsole = (BOOL)!gbRemoteSession;

    G_fDoubleDpi = bDoubleDpi(G_fConsole);

    //
    // We only want to initialize once.  We can detect transition to 0.
    //

    if (InterlockedDecrement(&CountInit) != 0)
    {
        return(TRUE);
    }

#if defined(_GDIPLUS_)
    gIsTerminalServer = FALSE;
#else
    gIsTerminalServer = !!(SharedUserData->SuiteMask & (1 << TerminalServer));
#endif

    if (!MultiUserGreCleanupInit())
        {
            WARNING("InitializeGre: failed to initialize cleanup support\n");
            return(FALSE);
        }

    //
    // Initialize the GRE DriverVerifier support (see verifier.cxx).
    //

    VerifierInitialization();

    //
    // Note that GreEngLoadModuleTrackInit must be called AFTER gIsTerminalServer is set
    // (though it's called regardless of its value), so that the memory allocations will
    // be placed on the hydra tracking list if necessary.

    if (!GreEngLoadModuleTrackInit())
    {
        WARNING("InitializeGre: failed to initialize EngLoadModule tracking\n");
        return(FALSE);
    }

#ifdef ANDREVA_DBG
    GreTraceDisplayDriverLoad = 1;
#endif

#if TRACE_SURFACE_ALLOCS
    //
    // Initialize SURFACE tracing if requested in registry
    //

    TRACED_SURFACE::vInit();
#endif

    //
    // load registry process quota information
    //


    bLoadProcessHandleQuota();

    //
    // Initialize lots of random stuff including the handle manager.
    //

    if (!HmgCreate())
    {
        WARNING("HMGR failed to initialize\n");
        return(FALSE);
    }

    //
    // Initialize REGION time stamp
    //

    REGION::ulUniqueREGION = 1;

    #if DBG_CORE
        if ((ghsemDEBUG = GreCreateSemaphore())==NULL)
        {
            WARNING("win32k: unable to initialize ghsemDEBUG\n");
            return(FALSE);
        }
    #endif

    #if defined(USE_NINEGRID_STATIC)
        if ((gNineGridSem = GreCreateSemaphore())==NULL)
        {
            WARNING("Win32k: unable to initialize gNineGridSem\n");
            return(FALSE);
        }
    #endif
    
    //
    // Create the LDEV\PDEV semaphore.
    //



    if ((ghsemDriverMgmt = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create driver mgmt semaphore\n");
        return(FALSE);
    }

    //
    // Init the font drivers
    //

    if (!bInitPathAlloc())
    {
        WARNING("Pathalloc Initialization failed\n");
        return(FALSE);
    }

    // Create the RFONT list semaphore.

    ghsemRFONTList = GreCreateSemaphore();
    if (ghsemRFONTList == NULL)
    {
        WARNING("win32k: unable to create ghsemRFONTList\n");
        return FALSE;
    }

    ghsemCLISERV = GreCreateSemaphore();
    if (ghsemCLISERV == NULL)
    {
        WARNING("win32k: unabel to create ghsemCLISERV\n");
        return( FALSE );
    }

    if ((ghsemAtmfdInit = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create driver mgmt semaphore\n");
        return(FALSE);
    }

    // Create the WNDOBJ semaphore.

    ghsemWndobj = GreCreateSemaphore();
    if (ghsemWndobj == NULL)
    {
        WARNING("win32k: unable to create ghsemWndobj\n");
        return FALSE;
    }

    // Create the RFONT list semaphore.

    ghsemGdiSpool = GreCreateSemaphore();
    if(ghsemGdiSpool == NULL)
    {
      WARNING("win32k: unable to create ghsemGdiSpool\n");
      return FALSE;
    }

    // Create the mode change semaphore.

    if ((ghsemShareDevLock = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create mode change semaphore\n");
        return(FALSE);
    }

    // Create the association list fast mutex.

    if ((gAssociationListMutex = GreCreateFastMutex()) == NULL) {

	WARNING("win32k: unable to create association list mutex\n");
	return(FALSE);
    }

    // Create a null region as the default region


    hrgnDefault = GreCreateRectRgn(0, 0, 0, 0);
    if (hrgnDefault == (HRGN) 0)
    {
        WARNING("hrgnDefault failed to initialize\n");
        return(FALSE);
    }

    {
        RGNOBJAPI ro(hrgnDefault,TRUE);
        if(!ro.bValid()) {
          WARNING("invalid hrgnDefault\n");
          return FALSE;
        }

        prgnDefault = ro.prgnGet();
    }

    // Create a monochrome 1x1 bitmap as the default bitmap


    if (!bInitPALOBJ())
    {
        WARNING("bInitPALOBJ failed !\n");
        return(FALSE);
    }

    vInitXLATE();

    if (!bInitBMOBJ())
    {
        WARNING("bInitBMOBJ failed !\n");
        return(FALSE);
    }

    // initialize the script names

    if(!InitializeScripts())
    {
        WARNING("Could not initialize the script names\n");
        return(FALSE);
    }

    //
    // Start up the brush component
    //

    if (!bInitBRUSHOBJ())
    {
        WARNING("Could not init the brushes\n");
        return(FALSE);
    }

    if (!bInitICM())
    {
        WARNING("Could not init ICM\n");
        return(FALSE);
    }

    //
    // Enable statically linked halftone library
    //

    if (!EnableHalftone())
    {
        WARNING("GRE: could not enable halftone\n");
        return(FALSE);
    }

    //
    // determine if processor supports MMX
    //

    #if defined (_X86_)

        gbMMXProcessor = bIsMMXProcessor();

    #endif

    TRACE_INIT(("GRE: Completed Initialization\n"));

    #ifdef _GDIPLUS_

    gpepCSRSS = PsGetCurrentProcess();
    InitializeGreCSRSS();

    #endif

#ifdef LANGPACK
    QueryTable[0].QueryRoutine = LpkShapeQueryRoutine;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    
    gpGdiSharedMemory->dwLpkShapingDLLs = 0;

    RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT | RTL_REGISTRY_OPTIONAL,
                           (PWSTR)L"LanguagePack",
                           &QueryTable[0],
                           NULL,
                           NULL);
#endif

    gpGdiSharedMemory->timeStamp = 1;

    return(TRUE);
}

extern "C" BOOL TellGdiToGetReady()
{
    ASSERTGDI(gpepCSRSS, "gpepCSRSS\n");

    return InitializeGreCSRSS();
}

#ifdef LANGPACK
extern "C"
NTSTATUS
LpkShapeQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    if( ValueType == REG_DWORD ) {
        gpGdiSharedMemory->dwLpkShapingDLLs |= (1<<(*((DWORD*)ValueData)));
    }

    return( STATUS_SUCCESS );
}
#endif


extern "C"
NTSTATUS
FontDriverQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PLDEV pldev;
    WCHAR FontDriverPath[MAX_PATH+1];

    wcscpy(FontDriverPath, L"\\SystemRoot\\System32\\");

// guard against some malicious person putting a huge value in here to hose us

    if((ValueLength / sizeof(WCHAR) <
        MAX_PATH - (sizeof(L"\\SystemRoot\\System32\\") / sizeof(WCHAR))) &&
       (ValueType == REG_SZ))
    {
        wcscat(FontDriverPath, (PWSTR) ValueData);

        if (_wcsicmp(L"\\SystemRoot\\System32\\atmdrvr.dll", FontDriverPath) == 0 ||
            _wcsicmp(L"\\SystemRoot\\System32\\atmfd.dll", FontDriverPath) == 0)
        {
            //skip old atm font driver (4.0) or (5.0) because it is loaded through stub
            //WARNING("FontDriverQueryRoutine: system has a old version of ATM driver\n");
        }
        else
        {
            pldev = ldevLoadDriver(FontDriverPath, LDEV_FONT);

            if (pldev)
            {
                // Create the PDEV for this (the PDEV won't have anything in it
                // except the dispatch table.


                PDEVOBJ po(pldev,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL);

                if (po.bValid())
                {
                    po.ppdev->fl |= PDEV_FONTDRIVER;

                    FntCacheHDEV((PPDEV) po.hdev(), FNT_DUMMY_DRV);

                    return(TRUE);

                }
                else
                {
                    WARNING("win32k.sys could not initialize installable driver\n");
                }
            }
            else
            {
                WARNING("win32k.sys could not initialize installable driver\n");
            }
        }
    }

    return( STATUS_SUCCESS );
}


/******************************Public*Routine******************************\
* Read process handle quota
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status
*
* History:
*
*    3-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bLoadProcessHandleQuota()
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;
    NTSTATUS          NtStatus;
    HANDLE            hKey;
    BOOL              bRet = FALSE;

    RtlInitUnicodeString(&UnicodeString,
                    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");

    //
    //  Open a registry key
    //

    InitializeObjectAttributes(&ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL);

    NtStatus = ZwOpenKey(&hKey,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes);

    if (NT_SUCCESS(NtStatus))
    {
        UNICODE_STRING  UnicodeValue;
        ULONG           ReturnedLength;
        UCHAR           DataArray[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
        PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DataArray;

        RtlInitUnicodeString(&UnicodeValue,
                              L"GDIProcessHandleQuota");

        NtStatus = ZwQueryValueKey(hKey,
                                   &UnicodeValue,
                                   KeyValuePartialInformation,
                                   pKeyInfo,
                                   sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                   &ReturnedLength);

        if (NT_SUCCESS(NtStatus))
        {
            LONG lHandleQuota = *(PLONG)(&pKeyInfo->Data[0]);

            if ((lHandleQuota > MIN_HANDLE_QUOTA) &&
                (lHandleQuota <= (MAX_HANDLE_COUNT)))
            {
                gProcessHandleQuota = lHandleQuota;
                bRet = TRUE;
            }
        }
        ZwCloseKey(hKey);
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\invcmap.cxx ===
/*****************************************************************************
 *
 *  Inverse color map code, from Graphics Gems II.
 *
 *  this code builds a inverse map table, used for color mapping a
 *  hi color (bpp > 8) image down to 4bpp or 8bpp
 *
 *  a inverse table is a 32K table that mapps a RGB 555 value (a WORD) to
 *  a palette index (a BYTE)
 *
 *  public functions:
 *      MakeITable      - makes a inverse table to any palette
 *
 *  non-public functions:
 *      inv_cmap        - work horse for MakeITable
 *      MakeITableVGA   - makes a inverse table to the VGA colors
 *      MakeITable256   - makes a inverse table to a uniform 6 level palette
 *
 *  Created: Feb 20 1994, ToddLa
 *
 * Copyright (c) 1994-1999 Microsoft Corporation
 *****************************************************************************/

#include "precomp.hxx"

#ifdef WIN32
    #define _huge
    #undef GlobalAllocPtr
    #undef GlobalFreePtr
    #define GlobalAllocPtr(f, cb)   (LPVOID)GlobalAlloc(((f) & ~GMEM_MOVEABLE) | GMEM_FIXED, cb)
    #define GlobalFreePtr(p)        GlobalFree((HGLOBAL)(p))
#endif

typedef DWORD _huge *PDIST;
typedef BYTE  FAR  *PIMAP;

typedef struct {BYTE r,g,b,x;} RGBX;

void inv_cmap( int colors, RGBX FAR *colormap, int bits,
        PDIST dist_buf, PIMAP rgbmap );

BOOL MakeITableMono(PIMAP lpITable);
BOOL MakeITable256(PIMAP lpITable);
BOOL MakeITableVGA(PIMAP lpITable);
BOOL MakeITableDEF(PIMAP lpITable);

PBYTE gpDefITable = NULL;

/*****************************************************************************
 *
 *  MakeITable
 *
 *      build a 32k color inverse table to a palette
 *
 *  lpITable points to a 32K table to hold inverse table
 *  prgb     points to the palette RGBs to build table from.
 *  nColors  number of RGBs
 *
 *  if prgb is NULL build a special inverse table, to a fixed color table
 *
 *      nColors = 2  build to mono colors (black,white)
 *      nColors = 16 build to VGA colors.
 *      nColors = 20 build to GDI DEFAULT_PALETTE
 *      nColors = 216 build to 6*6*6 colors.
 *
 *****************************************************************************/

BOOL MakeITable(PIMAP lpITable, RGBX FAR *prgb, int nColors)
{
    PDIST   lpDistBuf;
    PIMAP   iTable = lpITable;

    //
    //  handle special color tables.
    //
    if (prgb == NULL)
    {
        switch (nColors)
        {
            case 2:
                return MakeITableMono(lpITable);
            case 16:
                return MakeITableVGA(lpITable);
            case 20:
                return MakeITableDEF(lpITable);
            case 256:
                return MakeITable256(lpITable);
            default:
                return FALSE;
        }
    }

    //
    // We need to grab the global palette semaphore here
    // because inv_cmap is not thread-safe (it uses all
    // kinds of global variables)
    //

    BOOL    result = FALSE;
    SEMOBJ semo(ghsemPalette);

    //
    // Check if palette is default palette.  If it is, use the
    // cached default palette iTable.  Create cache as appropriate.
    //

    if(nColors >= 20)
    {
        int         i;
        ULONG *     pulDef = (ULONG *) logDefaultPal.palPalEntry;
        ULONG *     pulSrc = (ULONG *) prgb;

        for(i = 0; i < nColors; i++)
            if(pulSrc[i] != pulDef[i%20])
                break;

        if(i == nColors)
        {
            if(gpDefITable != NULL)
            {
                RtlCopyMemory(lpITable, gpDefITable, 32768);
                return TRUE;
            }
            
            iTable = (PBYTE)PALLOCNOZ(32768,'tidG');

            if(iTable == NULL)
                iTable = lpITable;

            nColors = 20;
        }
    
    }
    
    //
    // not a special table
    //
    lpDistBuf = (PDIST)PALLOCNOZ(32768l * sizeof(DWORD),'pmtG');

    if (lpDistBuf != NULL)
    {
        inv_cmap(nColors,prgb,5,lpDistBuf, iTable);
        VFREEMEM(lpDistBuf);
        result = TRUE;

        if(iTable != lpITable)
        {
            RtlCopyMemory(lpITable, iTable, 32768);
            gpDefITable = iTable;
        }
    }
    else
    {
        if(iTable != lpITable)
            VFREEMEM(iTable);
    }

    return result;
}

/*****************************************************************************
 *
 *  MakeITable256
 *
 *      build a 32k color inverse table to a 3-3-2 palette
 *
 *****************************************************************************/

BOOL MakeITable256(PIMAP lpITable)
{
    PIMAP pb;
    int   r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (((r & 0x1c) << 3)| (g & 0x1c) | ((b & 0x18) >> 3));

    return TRUE;
}

//;-----------------------------------------------------------------------------
//; vga_map
//;                                                                            ;
//; Subdividing the RGB color cube twice along each axis yields 64 smaller     ;
//; cubes.  A maximum of three VGA colors, and often only one VGA color,       ;
//; match (Euclidean distance) into each of the subdivided cubes.  Therefore,  ;
//; this adaptive Eudclidean match is must faster than the traditional         ;
//; Euclidean match.                                                           ;
//;                                                                            ;
//; Note:  This table was built according to the VGA palette.  The             ;
//; indices it returns will not be appropriate for all devices.  Use a         ;
//; VgaTranslateMap to produce the final physical color index.                 ;
//; (Example: GDI has indices 7 and 8 reversed.  To use this code in GDI,      ;
//; enable the VgaTranslateMap and swap indices 7 and 8.)                      ;
//;                                                                            ;
//; The index to this map is computed as follows given a 24-bit RGB.           ;
//;                                                                            ;
//;       index = ((Red & 0xC0) >> 2)     |                                    ;
//;               ((Green & 0xC0) >> 4)   |                                    ;
//;               ((Blue & 0xC0) >> 6);                                        ;
//;                                                                            ;
//; Each entry is a word made up of four nibbles.  The first nibble always     ;
//; contains a valid GDI VGA color index.  The second and third nibbles        ;
//; contain valid GDI VGA color indices if they are non-zero.                  ;
//; The fourth nibble is an optimization for sub-cubes 42 and 63.              ;
//;                                                                            ;
//; History:                                                                   ;
//; 23-February-1994      -by-    Raymond E. Endres [rayen]                    ;
//; Wrote it.                                                                  ;
//;-----------------------------------------------------------------------------

static WORD vga_map[] = {

        0x0000,             // Index 0      r=0 g=0 b=0
        0x0004,             //              r=1 g=0 b=0
        0x0004,             //              r=2 g=0 b=0
        0x000C,             //              r=3 g=0 b=0
        0x0002,             //              r=0 g=1 b=0
        0x0006,             //              r=1 g=1 b=0
        0x0006,             //              r=2 g=1 b=0
        0x00C6,             //              r=3 g=1 b=0

        0x0002,             // Index 8      r=0 g=2 b=0
        0x0006,             //              r=1 g=2 b=0
        0x0006,             //              r=2 g=2 b=0
        0x00E6,             //              r=3 g=2 b=0
        0x000A,             //              r=0 g=3 b=0
        0x00A6,             //              r=1 g=3 b=0
        0x00E6,             //              r=2 g=3 b=0
        0x000E,             //              r=3 g=3 b=0

        0x0001,             // Index 16     r=0 g=0 b=1
        0x0005,             //              r=1 g=0 b=1
        0x0005,             //              r=2 g=0 b=1
        0x00C5,             //              r=3 g=0 b=1
        0x0003,             //              r=0 g=1 b=1
        0x0008,             //              r=1 g=1 b=1
        0x0008,             //              r=2 g=1 b=1
        0x0C78,             //              r=3 g=1 b=1

        0x0003,             // Index 24     r=0 g=2 b=1
        0x0008,             //              r=1 g=2 b=1
        0x0078,             //              r=2 g=2 b=1
        0x0E78,             //              r=3 g=2 b=1
        0x00A3,             //              r=0 g=3 b=1
        0x0A78,             //              r=1 g=3 b=1
        0x0E78,             //              r=2 g=3 b=1
        0x0E78,             //              r=3 g=3 b=1

        0x0001,             // Index 32     r=0 g=0 b=2
        0x0005,             //              r=1 g=0 b=2
        0x0005,             //              r=2 g=0 b=2
        0x00D5,             //              r=3 g=0 b=2
        0x0003,             //              r=0 g=1 b=2
        0x0008,             //              r=1 g=1 b=2
        0x0078,             //              r=2 g=1 b=2
        0x0D78,             //              r=3 g=1 b=2

        0x0003,             // Index 40     r=0 g=2 b=2
        0x0078,             //              r=1 g=2 b=2
        0x0078,             //              r=2 g=2 b=2     1
        0x0078,             //              r=3 g=2 b=2
        0x00B3,             //              r=0 g=3 b=2
        0x0B78,             //              r=1 g=3 b=2
        0x0078,             //              r=2 g=3 b=2
        0x00F7,             //              r=3 g=3 b=2

        0x0009,             // Index 48     r=0 g=0 b=3
        0x0095,             //              r=1 g=0 b=3
        0x00D5,             //              r=2 g=0 b=3
        0x000D,             //              r=3 g=0 b=3
        0x0093,             //              r=0 g=1 b=3
        0x0978,             //              r=1 g=1 b=3
        0x0D78,             //              r=2 g=1 b=3
        0x0D78,             //              r=3 g=1 b=3

        0x00B3,             // Index 56     r=0 g=2 b=3
        0x0B78,             //              r=1 g=2 b=3
        0x0078,             //              r=2 g=2 b=3
        0x00F7,             //              r=3 g=2 b=3
        0x000B,             //              r=0 g=3 b=3
        0x0B78,             //              r=1 g=3 b=3
        0x00F7,             //              r=2 g=3 b=3
        0x00F7              //              r=3 g=3 b=3     1
};

static RGBX VGAColors[] = {
    00, 00, 00, 00,
    16, 00, 00, 00,
    00, 16, 00, 00,
    16, 16, 00, 00,
    00, 00, 16, 00,
    16, 00, 16, 00,
    00, 16, 16, 00,
    24, 24, 24, 00,
    16, 16, 16, 00,
    31, 00, 00, 00,
    00, 31, 00, 00,
    31, 31, 00, 00,
    00, 00, 31, 00,
    31, 00, 31, 00,
    00, 31, 31, 00,
    31, 31, 31, 00
};

/*****************************************************************************
 *
 *  MapVGA
 *
 *****************************************************************************/

__inline BYTE MapVGA(BYTE r, BYTE g, BYTE b)
{
    int i;

    //
    // build index into vga_map (r,g,b in range of 0-31)
    //
    i = ((b & 0x18) >> 3) | ((g & 0x18) >> 1) | ((r & 0x18) << 1);

    //
    // lookup in our "quick map" table
    //
    i = (int)vga_map[i];

    if (i & 0xFFF0)
    {
        //
        // more than one color is close, do a eclidian search of
        // at most three colors.
        //
        int e1,e,n,n1;

        e1 = 0x7fffffff;

        while (i)
        {
            n = i & 0x000F;

            e = ((int)VGAColors[n].r - r) * ((int)VGAColors[n].r - r) +
                ((int)VGAColors[n].g - g) * ((int)VGAColors[n].g - g) +
                ((int)VGAColors[n].b - b) * ((int)VGAColors[n].b - b) ;

            if (e < e1)
            {
                n1 = n;
                e1 = e;
            }

            i = i >> 4;
        }

        return (BYTE)n1;
    }
    else
    {
        //
        // one one color matchs, we are done
        //
        return (BYTE)(i & 0x000F);
    }
}

/*****************************************************************************
 *
 *  MakeITableVGA
 *
 *      build a 32k color inverse table to the VGA colors
 *
 *****************************************************************************/

BOOL MakeITableVGA(PIMAP lpITable)
{
    PIMAP pb;
    BYTE  r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (BYTE)MapVGA(r,g,b);

    return TRUE;
}

/*****************************************************************************
 *
 *  MakeITableDEF
 *
 *      build a 32k color inverse table to the DEFAULT_PALETTE
 *      just builds a VGA ITable then bumps up values above 7
 *
 *****************************************************************************/

BOOL MakeITableDEF(PIMAP pb)
{
    int i;

    MakeITableVGA(pb);

    for (i=0;i<0x8000;i++)
        if (pb[i] >= 8)
            pb[i] += 240;

    return TRUE;
}

/*****************************************************************************
 *
 *  MakeITableMono
 *
 *      build a 32k color inverse table to black/white
 *
 *****************************************************************************/

BOOL MakeITableMono(PIMAP lpITable)
{
    PIMAP pb;
    BYTE  r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (g/2 + (r+b)/4) > 15;

    return TRUE;
}


/*****************************************************************
 * TAG( inv_cmap )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:
 *  colors:     Number of colors in the forward colormap.
 *  colormap:   The forward colormap.
 *  bits:       Number of quantization bits.  The inverse
 *          colormap will have (2^bits)^3 entries.
 *  dist_buf:   An array of (2^bits)^3 long integers to be
 *          used as scratch space.
 * Outputs:
 *  rgbmap:     The output inverse colormap.  The entry
 *          rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 *          is the colormap entry that is closest to the
 *          (quantized) color (r,g,b).
 * Assumptions:
 *  Quantization is performed by right shift (low order bits are
 *  truncated).  Thus, the distance to a quantized color is
 *  actually measured to the color at the center of the cell
 *  (i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 *  Uses a "distance buffer" algorithm:
 *  The distance from each representative in the forward color map
 *  to each point in the rgb space is computed.  If it is less
 *  than the distance currently stored in dist_buf, then the
 *  corresponding entry in rgbmap is replaced with the current
 *  representative (and the dist_buf entry is replaced with the
 *  new distance).
 *
 *  The distance computation uses an efficient incremental formulation.
 *
 *  Distances are computed "outward" from each color.  If the
 *  colors are evenly distributed in color space, the expected
 *  number of cells visited for color I is N^3/I.
 *  Thus, the complexity of the algorithm is O(log(K) N^3),
 *  where K = colors, and N = 2^bits.
 */

/*
 * Here's the idea:  scan from the "center" of each cell "out"
 * until we hit the "edge" of the cell -- that is, the point
 * at which some other color is closer -- and stop.  In 1-D,
 * this is simple:
 *  for i := here to max do
 *      if closer then buffer[i] = this color
 *      else break
 *  repeat above loop with i := here-1 to min by -1
 *
 * In 2-D, it's trickier, because along a "scan-line", the
 * region might start "after" the "center" point.  A picture
 * might clarify:
 *       |    ...
 *               | ...  .
 *              ...     .
 *           ... |      .
 *          .    +      .
 *           .          .
 *            .         .
 *             .........
 *
 * The + marks the "center" of the above region.  On the top 2
 * lines, the region "begins" to the right of the "center".
 *
 * Thus, we need a loop like this:
 *  detect := false
 *  for i := here to max do
 *      if closer then
 *          buffer[..., i] := this color
 *          if !detect then
 *              here = i
 *              detect = true
 *      else
 *          if detect then
 *              break
 *              
 * Repeat the above loop with i := here-1 to min by -1.  Note that
 * the "detect" value should not be reinitialized.  If it was
 * "true", and center is not inside the cell, then none of the
 * cell lies to the left and this loop should exit
 * immediately.
 *
 * The outer loops are similar, except that the "closer" test
 * is replaced by a call to the "next in" loop; its "detect"
 * value serves as the test.  (No assignment to the buffer is
 * done, either.)
 *
 * Each time an outer loop starts, the "here", "min", and
 * "max" values of the next inner loop should be
 * re-initialized to the center of the cell, 0, and cube size,
 * respectively.  Otherwise, these values will carry over from
 * one "call" to the inner loop to the next.  This tracks the
 * edges of the cell and minimizes the number of
 * "unproductive" comparisons that must be made.
 *
 * Finally, the inner-most loop can have the "if !detect"
 * optimized out of it by splitting it into two loops: one
 * that finds the first color value on the scan line that is
 * in this cell, and a second that fills the cell until
 * another one is closer:
 *      if !detect then     {needed for "down" loop}
 *      for i := here to max do
 *      if closer then
 *          buffer[..., i] := this color
 *          detect := true
 *          break
 *  for i := i+1 to max do
 *      if closer then
 *          buffer[..., i] := this color
 *      else
 *          break
 *
 * In this implementation, each level will require the
 * following variables.  Variables labelled (l) are local to each
 * procedure.  The ? should be replaced with r, g, or b:
 *      cdist:          The distance at the starting point.
 *  ?center:    The value of this component of the color
 *      c?inc:          The initial increment at the ?center position.
 *  ?stride:    The amount to add to the buffer
 *          pointers (dp and rgbp) to get to the
 *          "next row".
 *  min(l):     The "low edge" of the cell, init to 0
 *  max(l):     The "high edge" of the cell, init to
 *          colormax-1
 *  detect(l):      True if this row has changed some
 *                  buffer entries.
 *      i(l):           The index for this row.
 *      ?xx:            The accumulated increment value.
 *      
 *      here(l):        The starting index for this color.  The
 *                      following variables are associated with here,
 *                      in the sense that they must be updated if here
 *                      is changed.
 *      ?dist:          The current distance for this level.  The
 *                      value of dist from the previous level (g or r,
 *                      for level b or g) initializes dist on this
 *                      level.  Thus gdist is associated with here(b)).
 *      ?inc:           The initial increment for the row.
 *
 *      ?dp:            Pointer into the distance buffer.  The value
 *                      from the previous level initializes this level.
 *      ?rgbp:          Pointer into the rgb buffer.  The value
 *                      from the previous level initializes this level.
 *
 * The blue and green levels modify 'here-associated' variables (dp,
 * rgbp, dist) on the green and red levels, respectively, when here is
 * changed.
 */

static int bcenter, gcenter, rcenter;
static long gdist, rdist, cdist;
static long cbinc, cginc, crinc;
static PDIST gdp;
static PDIST rdp;
static PDIST cdp;
static PIMAP grgbp;
static PIMAP rrgbp;
static PIMAP crgbp;
static int gstride, rstride;
static long x, xsqr, colormax;
static int cindex;

int redloop(void);
int greenloop( int restart );
int blueloop( int restart );
void maxfill( PDIST buffer, long side);

/* Track minimum and maximum. */
#define MINMAX_TRACK

void
inv_cmap(int colors, RGBX FAR *colormap, int bits,
        PDIST dist_buf, PIMAP rgbmap )
{
    int nbits = 8 - bits;

    colormax = 1 << bits;
    x = 1 << nbits;
    xsqr = 1 << (2 * nbits);

    /* Compute "strides" for accessing the arrays. */
    gstride = (int) colormax;
    rstride = (int) (colormax * colormax);

    maxfill( dist_buf, colormax );

    for ( cindex = 0; cindex < colors; cindex++ )
    {
    /*
     * Distance formula is
     * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
     *
     * Because of quantization, we will measure from the center of
     * each quantized "cube", so blue distance is
     *  (blue + x/2 - map[2])^2,
     * where x = 2^(8 - bits).
     * The step size is x, so the blue increment is
     *  2*x*blue - 2*x*map[2] + 2*x^2
     *
     * Now, b in the code below is actually blue/x, so our
     * increment will be 2*(b*x^2 + x^2 - x*map[2]).  For
     * efficiency, we will maintain this quantity in a separate variable
     * that will be updated incrementally by adding 2*x^2 each time.
     */
    /* The initial position is the cell containing the colormap
     * entry.  We get this by quantizing the colormap values.
     */
        rcenter = colormap[cindex].r >> nbits;
        gcenter = colormap[cindex].g >> nbits;
        bcenter = colormap[cindex].b >> nbits;

        rdist = colormap[cindex].r - (rcenter * x + x/2);
        gdist = colormap[cindex].g - (gcenter * x + x/2);
        cdist = colormap[cindex].b - (bcenter * x + x/2);
    cdist = rdist*rdist + gdist*gdist + cdist*cdist;

        crinc = 2 * ((rcenter + 1) * xsqr - (colormap[cindex].r * x));
        cginc = 2 * ((gcenter + 1) * xsqr - (colormap[cindex].g * x));
        cbinc = 2 * ((bcenter + 1) * xsqr - (colormap[cindex].b * x));

    /* Array starting points. */
    cdp = dist_buf + rcenter * rstride + gcenter * gstride + bcenter;
    crgbp = rgbmap + rcenter * rstride + gcenter * gstride + bcenter;

    (void)redloop();
    }
}

/* redloop -- loop up and down from red center. */
int
redloop()
{
    int detect;
    int r, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static long rxx;

    detect = 0;

    /* Basic loop up. */
    for ( r = rcenter, rdist = cdist, rxx = crinc,
      rdp = cdp, rrgbp = crgbp, first = 1;
      r < (int) colormax;
      r++, rdp += rstride, rrgbp += rstride,
      rdist += rxx, rxx += txsqr, first = 0 )
    {
    if ( greenloop( first ) )
        detect = 1;
    else if ( detect )
        break;
    }

    /* Basic loop down. */
    for ( r = rcenter - 1, rxx = crinc - txsqr, rdist = cdist - rxx,
      rdp = cdp - rstride, rrgbp = crgbp - rstride, first = 1;
      r >= 0;
      r--, rdp -= rstride, rrgbp -= rstride,
      rxx -= txsqr, rdist -= rxx, first = 0 )
    {
    if ( greenloop( first ) )
        detect = 1;
    else if ( detect )
        break;
    }

    return detect;
}

/* greenloop -- loop up and down from green center. */
int
greenloop( int restart )
{
    int detect;
    int g, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmax, prevmin;
    int thismax, thismin;
#endif
    static long ginc, gxx, gcdist;     /* "gc" variables maintain correct */
    static PDIST gcdp;                 /*  values for bcenter position, */
    static PIMAP gcrgbp;               /*  despite modifications by blueloop */
                                       /*  to gdist, gdp, grgbp. */
    if ( restart )
    {
    here = gcenter;
    min = 0;
    max = (int) colormax - 1;
    ginc = cginc;
#ifdef MINMAX_TRACK
    prevmax = 0;
    prevmin = (int) colormax;
#endif
    }

#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif
    detect = 0;

    /* Basic loop up. */
    for ( g = here, gcdist = gdist = rdist, gxx = ginc,
      gcdp = gdp = rdp, gcrgbp = grgbp = rrgbp, first = 1;
      g <= max;
      g++, gdp += gstride, gcdp += gstride, grgbp += gstride, gcrgbp += gstride,
      gdist += gxx, gcdist += gxx, gxx += txsqr, first = 0 )
    {
    if ( blueloop( first ) )
    {
        if ( !detect )
        {
        /* Remember here and associated data! */
        if ( g > here )
        {
            here = g;
            rdp = gcdp;
            rrgbp = gcrgbp;
            rdist = gcdist;
            ginc = gxx;
#ifdef MINMAX_TRACK
            thismin = here;
#endif
        }
        detect = 1;
        }
    }
    else if ( detect )
    {
#ifdef MINMAX_TRACK
        thismax = g - 1;
#endif
        break;
    }
    }

    /* Basic loop down. */
    for ( g = here - 1, gxx = ginc - txsqr, gcdist = gdist = rdist - gxx,
      gcdp = gdp = rdp - gstride, gcrgbp = grgbp = rrgbp - gstride,
      first = 1;
      g >= min;
      g--, gdp -= gstride, gcdp -= gstride, grgbp -= gstride, gcrgbp -= gstride,
      gxx -= txsqr, gdist -= gxx, gcdist -= gxx, first = 0 )
    {
    if ( blueloop( first ) )
    {
        if ( !detect )
        {
        /* Remember here! */
        here = g;
        rdp = gcdp;
        rrgbp = gcrgbp;
        rdist = gcdist;
        ginc = gxx;
#ifdef MINMAX_TRACK
        thismax = here;
#endif
        detect = 1;
        }
    }
    else if ( detect )
    {
#ifdef MINMAX_TRACK
        thismin = g + 1;
#endif
        break;
    }
    }

#ifdef MINMAX_TRACK
    /* If we saw something, update the edge trackers.  For now, only
     * tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( detect )
    {
    if ( thismax < prevmax )
        max = thismax;

    prevmax = thismax;

    if ( thismin > prevmin )
        min = thismin;

    prevmin = thismin;
    }
#endif

    return detect;
}

/* blueloop -- loop up and down from blue center. */
int
blueloop( int restart )
{
    int detect;
    register PDIST dp;
    register PIMAP rgbp;
    register long bdist, bxx;
    register int b, i = cindex;
    register long txsqr = xsqr + xsqr;
    register int lim;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmin, prevmax;
    int thismin, thismax;
#endif /* MINMAX_TRACK */
    static long binc;

    if ( restart )
    {
    here = bcenter;
    min = 0;
    max = (int) colormax - 1;
    binc = cbinc;
#ifdef MINMAX_TRACK
    prevmin = (int) colormax;
    prevmax = 0;
#endif /* MINMAX_TRACK */
    }

    detect = 0;
#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif

    /* Basic loop up. */
    /* First loop just finds first applicable cell. */
    for ( b = here, bdist = gdist, bxx = binc, dp = gdp, rgbp = grgbp, lim = max;
      b <= lim;
      b++, dp++, rgbp++,
      bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
    {
        /* Remember new 'here' and associated data! */
        if ( b > here )
        {
        here = b;
        gdp = dp;
        grgbp = rgbp;
        gdist = bdist;
        binc = bxx;
#ifdef MINMAX_TRACK
        thismin = here;
#endif
        }
        detect = 1;
        break;
    }
    }
    /* Second loop fills in a run of closer cells. */
    for ( ;
      b <= lim;
      b++, dp++, rgbp++,
      bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
    {
        *dp = bdist;
        *rgbp = (BYTE) i;
    }
    else
    {
#ifdef MINMAX_TRACK
        thismax = b - 1;
#endif
        break;
    }
    }

    /* Basic loop down. */
    /* Do initializations here, since the 'find' loop might not get
     * executed.
     */
    lim = min;
    b = here - 1;
    bxx = binc - txsqr;
    bdist = gdist - bxx;
    dp = gdp - 1;
    rgbp = grgbp - 1;
    /* The 'find' loop is executed only if we didn't already find
     * something.
     */
    if ( !detect )
    for ( ;
          b >= lim;
          b--, dp--, rgbp--,
          bxx -= txsqr, bdist -= bxx )
    {
            if ( *dp > (DWORD)bdist )
        {
        /* Remember here! */
        /* No test for b against here necessary because b <
         * here by definition.
         */
        here = b;
        gdp = dp;
        grgbp = rgbp;
        gdist = bdist;
        binc = bxx;
#ifdef MINMAX_TRACK
        thismax = here;
#endif
        detect = 1;
        break;
        }
    }
    /* The 'update' loop. */
    for ( ;
      b >= lim;
      b--, dp--, rgbp--,
      bxx -= txsqr, bdist -= bxx )
    {
        if ( *dp > (DWORD)bdist )
    {
        *dp = bdist;
        *rgbp = (BYTE) i;
    }
    else
    {
#ifdef MINMAX_TRACK
        thismin = b + 1;
#endif
        break;
    }
    }


    /* If we saw something, update the edge trackers. */
#ifdef MINMAX_TRACK
    if ( detect )
    {
    /* Only tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( thismax < prevmax )
        max = thismax;

    if ( thismin > prevmin )
        min = thismin;

    /* Remember the min and max values. */
    prevmax = thismax;
    prevmin = thismin;
    }
#endif /* MINMAX_TRACK */

    return detect;
}

void maxfill(PDIST buffer, long side)
{
    register unsigned long maxv = (unsigned long)~0L;
    register long i;
    register PDIST bp;

    for ( i = colormax * colormax * colormax, bp = buffer;
      i > 0;
      i--, bp++ )
    *bp = maxv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\meta.cxx ===
/******************************Module*Header*******************************\
* Module Name: meta.cxx
*
* This contains the code to create metafiles in the kernel
*
* Created: 26-Mar-1997
* Author: Andre Vachon [andreva]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


#if DBG
LONG cSrvMetaFile = 0;
LONG cMaxSrvMetaFile = 0;
#endif

class META : public OBJECT
{
public:
    DWORD iType;    // MFPICT_IDENTIFIER or MFEN_IDENTIFIER
    DWORD mm;       // used by MFPICT_IDENTIFIER only
    DWORD xExt;     // used by MFPICT_IDENTIFIER only
    DWORD yExt;     // used by MFPICT_IDENTIFIER only
    ULONG cbData;   // Number of bytes in abData[]
    BYTE  abData[1];    // Metafile bits
};

typedef META *PMETA;

/******************************Public*Routine******************************\
* NtGdiCreateServerMetaFile()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
NtGdiCreateServerMetaFile(
    DWORD  iType,
    ULONG  cjData,
    LPBYTE pjData,
    DWORD  mm,
    DWORD  xExt,
    DWORD  yExt
    )
{
    PMETA pMeta;
    HANDLE hRet = NULL;

    if ((iType != MFEN_IDENTIFIER) && (iType != MFPICT_IDENTIFIER))
    {
        ASSERTGDI(FALSE, "GreCreateServerMetaFile: unknown type\n");
        return NULL;
    }

    if (pjData == NULL)
    {
        WARNING("GreCreateServerMetaFile: No metafile bits\n");
        return NULL;
    }

    if (cjData > (MAXULONG - sizeof(META)))
    {
        WARNING("GreCreateServerMetaFile: overflow\n");
        return NULL;
    }

    pMeta = (PMETA) HmgAlloc(cjData + sizeof(META),
                             META_TYPE,
                             HMGR_ALLOC_LOCK | HMGR_MAKE_PUBLIC);

    if (pMeta)
    {
        hRet = pMeta->hGet();

        pMeta->iType  = iType;
        pMeta->mm     = mm;
        pMeta->xExt   = xExt;
        pMeta->yExt   = yExt;
        pMeta->cbData = cjData;

        if (cjData)
        {
            __try
            {
                //
                // Probe and Read the structure
                //

                ProbeForRead(pjData, cjData, sizeof(DWORD));

                RtlCopyMemory((PVOID) pMeta->abData,
                              (PVOID) pjData,
                              cjData);

#if DBG
                InterlockedIncrement(&cSrvMetaFile);
                if (cMaxSrvMetaFile < cSrvMetaFile)
                {
                    cMaxSrvMetaFile = cSrvMetaFile;
                }

                if (cSrvMetaFile >= 100)
                {
                    DbgPrint("GreCreateServerMetaFile: Number of server metafiles is %ld\n", cSrvMetaFile);
                }
#endif
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(14);
                hRet = 0;
            }

        }

        if (hRet == 0)
        {
            HmgFree((HOBJ) pMeta->hGet());
        }
        else
        {
            DEC_EXCLUSIVE_REF_CNT(pMeta);
        }
    }

    if (hRet == 0)
    {
        WARNING("NtGdiCreateServerMetaFile: unable to create metafile\n");
    }

    return (hRet);
}


/******************************Public*Routine******************************\
* NtGdiGetServerMetaFileBits()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetServerMetaFileBits(
    HANDLE hmo,
    ULONG  cjData,
    LPBYTE pjData,
    PDWORD piType,
    PDWORD pmm,
    PDWORD pxExt,
    PDWORD pyExt
    )
{
    ULONG  ulRet = 0;

    PMETA pMeta = (PMETA) HmgLock((HOBJ)hmo, META_TYPE);

    if (pMeta)
    {
        if (pMeta->iType == MFPICT_IDENTIFIER ||
            pMeta->iType == MFEN_IDENTIFIER)
        {
            //
            // How much data is (or should be) returned.
            //

            ulRet = pMeta->cbData;

            if (cjData)
            {
                if (cjData != pMeta->cbData)
                {
                    ASSERTGDI(FALSE, "GreGetServerMetaFileBits: sizes do no match");
                    ulRet = 0;
                }
                else
                {
                    __try
                    {
                        ProbeAndWriteUlong(pxExt,pMeta->xExt);
                        ProbeAndWriteUlong(pyExt,pMeta->yExt);
                        ProbeAndWriteUlong(piType,pMeta->iType);
                        ProbeAndWriteUlong(pmm,pMeta->mm);

                        ProbeForWrite(pjData, cjData, sizeof(DWORD));

                        RtlCopyMemory(pjData,
                                      (PVOID) pMeta->abData,
                                      pMeta->cbData);

                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(20);
                        ulRet = 0;
                    }
                }
            }
        }

        DEC_EXCLUSIVE_REF_CNT(pMeta);
    }

    return (ulRet);
}


/******************************Public*Routine******************************\
* GreDeleteServerMetaFile()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/


BOOL
GreDeleteServerMetaFile(
    HANDLE hmo
    )
{
    PMETA pMeta = (PMETA) HmgLock((HOBJ)hmo, META_TYPE);

    if (pMeta)
    {
        if (pMeta->iType == MFPICT_IDENTIFIER ||
            pMeta->iType == MFEN_IDENTIFIER)
        {
            HmgFree((HOBJ) pMeta->hGet());
#if DBG
            InterlockedDecrement(&cSrvMetaFile);
            if (cSrvMetaFile < 0)
            {
                ASSERTGDI(FALSE, "GreDeleteServerMetaFile: cSrvMetaFile < 0");
            }
#endif
            return TRUE;
        }
        else
        {
            DEC_EXCLUSIVE_REF_CNT(pMeta);
        }
    }

    WARNING("GreDeleteServerMetaFile: bad metafile handle");

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\maskblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: maskblt.cxx
*
* This contains the blting API functions.
*
* Created: 25-Apr-1991 11:35:16
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
* History:
*  07-Sep-1991 -by- Patrick Haluptzok patrickh
* Added it as a global table for the Engine.
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE - This is so you can do: Rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};

/******************************Public*Data*********************************\
* ROP3 translation table
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
* History:
*  Wed 22-Aug-1990 16:51:16 -by- Charles Whitmer [chuckwh]
* Added it as a global table for the Engine.
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

/******************************Public*Routine******************************\
* GrePatBltLockedDC
*
*   This routine is called by PatBlt,PolyPatBlt, and queued PatBlt once the
*   dc is locked, the devlock is owned and all parameters are captured.
*
* Arguments:
*
*   dcoDst   - reference to locked DC object
*   prclDst  - destination rect in screen coords
*   xoDst    - reference to xlate object
*   rop4     - raster op
*   pSurfDst - pointer to dst surface
*
* Return Value:
*
*   bool status
*
* History:
*
*    21-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
GrePatBltLockedDC(
    XDCOBJ    &dcoDst,
    EXFORMOBJ &xoDst,
    ERECTL    *prclDst,
    DWORD      rop4,
    SURFACE   *pSurfDst,
    COLORREF  crTextColor,
    COLORREF  crBackColor,
    ULONG     ulTextColor,
    ULONG     ulBackColor
    )
{

    BOOL bReturn  = TRUE;   // return true if it is just clipped
    ECLIPOBJ *pco = NULL;

    if (dcoDst.bDisplay() && !dcoDst.bRedirection() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return (FALSE);
    }

    //
    // Same as GreMaskblt, bail out
    // if the dest DC has a stock bitmap
    //
    
    ASSERTGDI(!dcoDst.bStockBitmap(), "GrePatBltLockedDC dst stock bitmap\n");

    if (dcoDst.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // This is a expression to save a return in here.
    // Basically pco can be NULL if the rect is completely in the
    // cached rect in the DC or if we set up a clip object that isn't empty.
    //
    // it is possible for the coordinates to wrap after adding in the origin
    // so we need to check that the rectangle is still well ordered.  If not,
    // we just fail since the result would be a blt going the opposite direction
    // as intended.
    //

    *prclDst += dcoDst.eptlOrigin();

    if (
         (
           (prclDst->left < prclDst->right) &&
           (prclDst->top  < prclDst->bottom)

         ) &&
         (
           (
             (prclDst->left   >= dcoDst.prclClip()->left) &&
             (prclDst->right  <= dcoDst.prclClip()->right) &&
             (prclDst->top    >= dcoDst.prclClip()->top) &&
             (prclDst->bottom <= dcoDst.prclClip()->bottom)
           ) ||
           (
             pco = dcoDst.pco(),
             pco->vSetup(dcoDst.prgnEffRao(), *prclDst,CLIP_NOFORCETRIV),
             *prclDst = pco->erclExclude(),
             (!prclDst->bEmpty())
           )
         )
       )

    {
        EBRUSHOBJ *pboFill;

        if ((((rop4 << 4) ^ rop4) & 0x00F0) != 0)
        {
            pboFill = dcoDst.peboFill();

            if (
                  (dcoDst.ulDirty() & DIRTY_FILL) ||
                  (dcoDst.pdc->flbrush() & DIRTY_FILL) ||
                  (pboFill->bCareAboutFg() && (pboFill->crCurrentText() != crTextColor)) ||
                  (pboFill->bCareAboutBg() && (pboFill->crCurrentBack() != crBackColor))
               )
            {
                COLORREF crTextColorOld = dcoDst.pdc->crTextClr();
                COLORREF crBackColorOld = dcoDst.pdc->crBackClr();
                ULONG    ulTextColorOld = dcoDst.pdc->ulTextClr();
                ULONG    ulBackColorOld = dcoDst.pdc->ulBackClr();

                dcoDst.ulDirtySub(DIRTY_FILL);
                dcoDst.pdc->flbrushSub(DIRTY_FILL);
                XEPALOBJ palDst(pSurfDst->ppal());
                XEPALOBJ palDstDC(dcoDst.ppal());

                // batched Textcolor and Bkcolor, need to be restored

                dcoDst.pdc->crTextClr(crTextColor);
                dcoDst.pdc->crBackClr(crBackColor);
                dcoDst.pdc->ulTextClr(ulTextColor);
                dcoDst.pdc->ulBackClr(ulBackColor);

                pboFill->vInitBrush(dcoDst.pdc,
                                    dcoDst.pdc->pbrushFill(),
                                    palDstDC,
                                    palDst,
                                    pSurfDst);

                dcoDst.pdc->crTextClr(crTextColorOld);
                dcoDst.pdc->crBackClr(crBackColorOld);
                dcoDst.pdc->ulTextClr(ulTextColorOld);
                dcoDst.pdc->ulBackClr(ulBackColorOld);
            }
        }
        else
        {
            pboFill = NULL;
        }

        DEVEXCLUDEOBJ dxo(dcoDst,prclDst,pco);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfDst);

        //
        // Dispatch the call.
        //

        bReturn = (*(pSurfDst->pfnBitBlt()))
                  (
                      pSurfDst->pSurfobj(),
                      (SURFOBJ *) NULL,
                      (SURFOBJ *) NULL,
                      pco,
                      NULL,
                      prclDst,
                      (POINTL *)  NULL,
                      (POINTL *)  NULL,
                      pboFill,
                      &dcoDst.pdc->ptlFillOrigin(),
                      rop4
                  );

    }
    return(bReturn);
}

/******************************Public*Routine******************************\
* NtGdiPatBlt
*
*   Pattern Blting Output API.
*
* Arguments:
*
*   hdcDst - Destination DC
*   x      - Destination x position
*   y      - Destination y position
*   cx     - Destination width
*   cy     - Destination height
*   rop4   - Destination raster operation
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
NtGdiPatBlt(
    HDC hdcDst,
    int x,
    int y,
    int cx,
    int cy,
    DWORD rop4
    )
{
    GDITraceHandle(NtGdiPatBlt, "(%X, %d, %d, %d, %d, %X)\n", (va_list)&hdcDst,
                   hdcDst);

    BOOL bReturn = FALSE;
    BOOL bLock = FALSE;
    PDC  pdc;

    XDCOBJ dcoDst(hdcDst);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        //
        // Process the rop for DDI, check for no source required.
        //

        rop4 = (rop4 >> 16) & 0x000000FF;
        rop4 = (rop4 << 8) | rop4;

        if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
        {
            EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

            if (!xoDst.bRotation())
            {
                ERECTL erclDst(x,y,x+cx,y+cy);
                xoDst.bXform(erclDst);
                erclDst.vOrder();

                if (!erclDst.bEmpty())
                {
                    //
                    // Accumulate bounds.  We can do this before knowing if the operation is
                    // successful because bounds can be loose.
                    //

                    if (dcoDst.fjAccum())
                    {
                        dcoDst.vAccumulate(erclDst);
                    }

                    //
                    // Lock the device and surface.
                    //

                    DEVLOCKOBJ dloTrg;

                    if (dloTrg.bLock(dcoDst))
                    {
                        //
                        // Check surface is included in DC.
                        //

                        SURFACE *pSurfDst = dcoDst.pSurface();

                        if (pSurfDst != NULL)
                        {
                            ULONG ulDirty = dcoDst.pdc->ulDirty();

                            if (ulDirty & DC_BRUSH_DIRTY)
                            {
                               GreDCSelectBrush (dcoDst.pdc, dcoDst.pdc->hbrush());
                            }

                            bReturn = GrePatBltLockedDC(dcoDst,
                                                        xoDst,
                                                        &erclDst,
                                                        rop4,
                                                        pSurfDst,
                                                        dcoDst.pdc->crTextClr(),
                                                        dcoDst.pdc->crBackClr(),
                                                        dcoDst.pdc->ulTextClr(),
                                                        dcoDst.pdc->ulBackClr()
                                                        );
                        }
                        else
                        {
                            bReturn = TRUE;
                        }
                    }
                    else
                    {
                        bReturn = dcoDst.bFullScreen();
                    }
                }
                else
                {
                    bReturn = TRUE;
                }
            }
            else
            {
                //
                // There is rotation involved - send it off to MaskBlt to handle it.
                //

                bReturn = GreMaskBlt(hdcDst, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);
            }
        }
        else
        {
            WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
        }

        //
        // Unlock DC
        //

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("ERORR PatBlt called on invalid DC\n");
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GrePolyPatBltInternal
*
* Arguments:
*
*   dcoDst    - Destination DC (locked)
*   rop4      - Destination raster op
*   pPolyPat  - POLYPATBLT structure
*   Count     - number of POLYPATBLTs
*   crTextClr - rext color
*   crBackClr - background color
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GrePolyPatBltInternal(
    XDCOBJ    &dcoDst,
    DWORD       rop4,
    PPOLYPATBLT pPolyPat,
    DWORD       Count,
    DWORD       Mode,
    COLORREF    crTextClr,
    COLORREF    crBackClr,
    ULONG       ulTextClr,
    ULONG       ulBackClr
)
{
    GDITraceHandle(GrePolyPatBltInternal, "(dcoDst, %X, %p, %u, %X, %X, %X)\n",
                   (va_list)&rop4, dcoDst.bValid() ? dcoDst.hdc() : NULL);

    BOOL bReturn = TRUE;

    //
    // validate input params
    //

    if ((Count != 0) && (pPolyPat != NULL) && (Mode == PPB_BRUSH))
    {
        //
        // Process the rop for DDI, check for no source required.
        //

        rop4 = (rop4 >> 16) & 0x000000FF;
        rop4 = (rop4 << 8) | rop4;

        if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
        {
            //
            // Validate the destination DC
            //

            if (dcoDst.bValid())
            {
                HBRUSH hbrSave = dcoDst.pdc->hbrush();

                //
                // make sure brush is in sync in DC
                //

                if (dcoDst.pdc->ulDirty() & DC_BRUSH_DIRTY)
                {
                    GreDCSelectBrush(dcoDst.pdc,hbrSave);
                }

                //
                // lock the device 1 time for all calls
                //

                DEVLOCKOBJ dloTrg;

                if (dloTrg.bLock(dcoDst))
                {
                    EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

                    SURFACE *pSurfDst = dcoDst.pSurface();

                    while (Count--)
                    {
                        int    x;
                        int    y;
                        int    cx;
                        int    cy;
                        HBRUSH hbr;

                        __try
                        {
                            x      = pPolyPat->x;
                            y      = pPolyPat->y;
                            cx     = pPolyPat->cx;
                            cy     = pPolyPat->cy;
                            hbr    = pPolyPat->BrClr.hbr;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            bReturn = FALSE;

                            //
                            // must break out of while loop but restore brush
                            //

                            break;
                        }

                        GDITraceHandle(GrePolyPatBltInternal,
                                       "  pPolyPat = { (%d, %d) - (%d, %d) }\n",
                                       (va_list)pPolyPat, dcoDst.hdc());

                        //
                        // select in brush for this patblt, remember old
                        // brush for restore if needed
                        //

                        if (hbr != (HBRUSH)NULL)
                        {
                            GreDCSelectBrush(dcoDst.pdc, hbr);
                        }

                        if (!xoDst.bRotation())
                        {
                            ERECTL erclDst(x,y,x+cx,y+cy);
                            xoDst.bXform(erclDst);
                            erclDst.vOrder();

                            if (!erclDst.bEmpty())
                            {
                                //
                                // Accumulate bounds.  We can do this before knowing if the operation is
                                // successful because bounds can be loose.
                                //

                                if (dcoDst.fjAccum())
                                {
                                    dcoDst.vAccumulate(erclDst);
                                }

                                //
                                // Check surface is included in DC.
                                //

                                if (pSurfDst != NULL)
                                {
                                    bReturn = GrePatBltLockedDC(dcoDst,
                                                                xoDst,
                                                                &erclDst,
                                                                rop4,
                                                                pSurfDst,
                                                                crTextClr,
                                                                crBackClr,
                                                                ulTextClr,
                                                                ulBackClr
                                                                );
                                }
                            }
                        }
                        else
                        {
                            //
                            // There is rotation involved - send it off to MaskBlt to handle it.
                            //

                            bReturn = GreMaskBlt((HDC)dcoDst.pdc->hHmgr, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);
                        }

                        pPolyPat++;
                    }
                }
                else
                {
                    bReturn = dcoDst.bFullScreen();
                }

                //
                // make sure dc brush is restored
                //

                if (dcoDst.pdc->hbrush() != hbrSave)
                {
                    dcoDst.pdc->hbrush(hbrSave);
                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);
                }
            }
            else
            {
                WARNING1("ERORR PatBlt called on invalid DC\n");
                bReturn = FALSE;
            }
        }
        else
        {
            WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
            bReturn = FALSE;
        }
    }
    else
    {
        if (Count != 0)
        {
            WARNING1("ERORR PolyPatBlt called with NULL pPolyPat\n");
            bReturn = FALSE;
        }
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* NtGdiPolyPatBlt
*
* Arguments:
*
*   hdcDst   - Destination DC
*   rop4     - Destination raster op
*   pPolyPat - POLYPATBLT structure
*   Count    - number of POLYPATBLTs
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyPatBlt(
    HDC         hdc,
    DWORD       rop4,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    GDITraceHandle(NtGdiPolyPatBlt, "(%X, %X, %p, %u, %X)\n", (va_list)&hdc,
                   hdc);

    BOOL bRet = TRUE;

    if (Count != 0)
    {
        if (pPoly != NULL)
        {
            XDCOBJ dcoDst(hdc);

            if (dcoDst.bValid())
            {
                //
                // Make sure length do not overflow.
                //
                // Note: using MAXULONG instead of MAXIMUM_POOL_ALLOC (or the
                //       BALLOC_ macros) because we are not allocating memory.
                //

                if (Count <= (MAXULONG / sizeof(POLYPATBLT)))
                {
                    __try
                    {
                        ProbeForRead(pPoly,sizeof(POLYPATBLT)*Count,sizeof(DWORD));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(46);
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                    bRet = GrePolyPatBltInternal(dcoDst,
                                                 rop4,
                                                 pPoly,
                                                 Count,
                                                 Mode,
                                                 dcoDst.pdc->crTextClr(),
                                                 dcoDst.pdc->crBackClr(),
                                                 dcoDst.pdc->ulTextClr(),
                                                 dcoDst.pdc->ulBackClr());
                }

                dcoDst.vUnlockFast();
            }
            else
            {
                bRet = FALSE;
                EngSetLastError(ERROR_INVALID_HANDLE);
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GrePolyPatBlt
*
* Arguments:
*
*   hdcDst    - Destination DC
*   rop4      - Destination raster op
*   pPolyPat  - POLYPATBLT structure
*   Count     - number of POLYPATBLTs
*   Mode      - color mode
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
GrePolyPatBlt(
    HDC         hdc,
    DWORD       rop4,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    GDITraceHandle(GrePolyPatBlt, "(%X, %X, %p, %u, %X)\n", (va_list)&hdc, hdc);

    XDCOBJ dcoDst(hdc);
    BOOL bRet = FALSE;

    if (dcoDst.bValid())
    {

        bRet = GrePolyPatBltInternal(dcoDst,
                                     rop4,
                                     pPoly,
                                     Count,
                                     Mode,
                                     dcoDst.pdc->crTextClr(),
                                     dcoDst.pdc->crBackClr(),
                                     dcoDst.pdc->ulTextClr(),
                                     dcoDst.pdc->ulBackClr());

        dcoDst.vUnlockFast();
    }
    else
    {
        EngSetLastError(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* NtGdiFlushUserBatch
*
*   Unbatch drawing calls (all to same DC so DC lock and
*   DEVLOCK and XFORMOBJ are same.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if DBG_GDI_BATCH

ULONG GdiBatchCounts[32];
ULONG GdiBatchTypeCounts[8];
ULONG SystemTable[4096];
ULONG gClearTable = 1;

#endif

VOID
NtGdiFlushUserBatch()
{

    //
    // DBG_GDI_BATCH is never tuyrned on in a debug or free build, it
    // is a private measuring tool.
    //

    #if DBG_GDI_BATCH

        _asm
        {
            ;eax is the system service
            lea ebx, SystemTable
            and eax, 4096-1
            inc DWORD PTR[ebx + 4*eax]
        }

    #endif
    GDITrace(NtGdiFlushUserBatch, "", NULL);

    PTEB pteb = NtCurrentTeb();

    ULONG GdiBatchCount;
    PBYTE pGdiBatch;

    //
    // Non dc commands must be executed from batch
    // whether dc/dev locks succeed or not
    //

    BOOL  bExecNonDCOnly = TRUE;
    
    #if DBG_GDI_BATCH

       if (gClearTable)
       {
           RtlZeroMemory(&SystemTable[0],4*4096);
           RtlZeroMemory(&GdiBatchCounts[0],4*32);
           RtlZeroMemory(&GdiBatchTypeCounts[0],4*8);
           gClearTable = 0;
       }

    #endif

    //
    // clear batch control
    //

    __try
    {
        GdiBatchCount = pteb->GdiBatchCount;
        pGdiBatch = (PBYTE)&pteb->GdiTebBatch.Buffer[0];
        pteb->GdiBatchCount      = 0;
        pteb->GdiTebBatch.Offset = 0;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    PBYTE pGdiBatchEnd = pGdiBatch + GDI_BATCH_SIZE;
    //
    // read batch once at start
    //

    if ( 
         (GdiBatchCount > 0)  &&
         (GdiBatchCount < (GDI_BATCH_SIZE/4))
       )
    {
        HDC    hdcDst = 0;
       
        __try
        {
            hdcDst = (HDC)pteb->GdiTebBatch.HDC;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        if (hdcDst != NULL)
        {
            XDCOBJ dcoDst(hdcDst);

            //
            // Validate the destination DC.
            //

            if (dcoDst.bValid())
            {
                //
                // Stats
                //

                #if DBG_GDI_BATCH

                    if (GdiBatchCount < 32)
                    {
                        GdiBatchCounts[GdiBatchCount]++;
                    }

                #endif

                //
                // Lock the device.
                //

                DEVLOCKOBJ dloTrg;

                if (dloTrg.bLock(dcoDst))
                {
                    //
                    // execute all batch commands from DC loop
                    //

                    bExecNonDCOnly = FALSE;

                    //
                    // remember DC_ATTR hbr
                    //

                    HBRUSH hbrDCA = dcoDst.pdc->hbrush();

                    do
                    {
                        //
                        // Pull patblt off teb and execute. TEB is not safe
                        // so all offsets must be checked to make sure no
                        // corruption has occured.
                        //

                        ULONG GdiBatchType;
                        ULONG GdiBatchLength;
                        ULONG GdiBatchIncrement;
                        BOOL  bRead = TRUE;

                        __try
                        {
                            GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                            GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            break;
                        }

                        if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
                        {
                            //
                            // exit while loop
                            //

                            WARNING("Error in GDI TEB batch address");
                            break;
                        }


                        //
                        // performance measure
                        //

                        #if DBG_GDI_BATCH

                        if (GdiBatchType <8)
                        {
                            GdiBatchTypeCounts[GdiBatchType]++;
                        }

                        #endif

                        //
                        // Check command type
                        //

                        switch (GdiBatchType)
                        {

                        //
                        // execute ExtTextOut and ExtTextOutRect
                        //

                        case BatchTypeTextOut:
                        case BatchTypeTextOutRect:
                        {

                            GreBatchTextOut(
                                        dcoDst,
                                        (PBATCHTEXTOUT)pGdiBatch,
                                        GdiBatchLength
                                        );

                        }
                        break;

                        //
                        // execute SelectClip
                        //

                        case BatchTypeSelectClip:
                        {
                            RECTL rclClip;
                            int iMode;

                            __try
                            {
                                rclClip = ((PBATCHSELECTCLIP)pGdiBatch)->rclClip;
                                iMode = ((PBATCHSELECTCLIP)pGdiBatch)->iMode;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }

                            if (bRead)
                            {
                                GreExtSelectClipRgnLocked(
                                                dcoDst,
                                                &rclClip,
                                                iMode);
                            }
                        }
                        break;

                        //
                        // delete brush
                        //

                        case BatchTypeDeleteBrush:
                        {
                            HOBJ hObj;

                            __try
                            {
                                hObj = (HOBJ)((PBATCHDELETEBRUSH)pGdiBatch)->hbrush;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                bDeleteBrush((HBRUSH)hObj,FALSE);
                        }
                        break;

                        //
                        // delete region
                        //

                        case BatchTypeDeleteRegion:
                        {
                            HOBJ hObj;

                            __try
                            {
                                hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                bDeleteRegion((HRGN)hObj);
                        }
                        break;

                        //
                        // set brush origin
                        //

                        case BatchTypeSetBrushOrg:
                        {
                            int x, y;

                            __try
                            {
                                x = ((PBATCHSETBRUSHORG)pGdiBatch)->x;
                                y = ((PBATCHSETBRUSHORG)pGdiBatch)->y;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                dcoDst.pdc->ptlBrushOrigin(
                                               x,
                                               y
                                               );
                        }
                        break;

                        case BatchTypeSelectFont:
                        {
                            HFONT hFont;

                            __try
                            {
                                hFont = (HFONT)((PBATCHSELECTFONT)pGdiBatch)->hFont;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                GreSelectFont(hdcDst,
                                              hFont
                                              );
                        }
                        break;


                        //
                        // batched PolyPatBlt
                        //

                        case BatchTypePolyPatBlt:
                        {
                            PBATCHPOLYPATBLT pBatch;
                            COLORREF         crSaveDCBrushColor;
                            COLORREF         crBatchDCBrushColor;
                            POINTL           ptlViewportOrgSave;
                            POINTL           ptlBatchViewportOrg;
                            ULONG            ulSaveDCBrushColor;
                            ULONG            ulBatchDCBrushColor;
                            ULONG            Mode;
                            ULONG            TextColor, BackColor;
                            ULONG            ulTextColor, ulBackColor;

                            pBatch = (PBATCHPOLYPATBLT)pGdiBatch;

                            //
                            // Pull count off the TEB, the data could be
                            // overwritten so do all checking against the copy.
                            //
                            COUNT Count;
                            COUNT cjBuffer = GdiBatchLength - offsetof(BATCHPOLYPATBLT, ulBuffer);
                            __try
                            {
                                Count = pBatch->Count;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                break;
                            }

                            //
                            // Validate pBatch->Count and size of
                            // ulBuffer
                            //
                            if ((Count < (MAXULONG / sizeof(POLYPATBLT))) &&
                                ((Count * sizeof(POLYPATBLT)) <= cjBuffer))
                            {
                                //
                                // Set the DCBrush Color
                                //
                                crSaveDCBrushColor = dcoDst.pdc->crDCBrushClr();
                                ulSaveDCBrushColor = dcoDst.pdc->ulDCBrushClr();

                                __try
                                {
                                    Mode                = pBatch->Mode;
                                    TextColor           = pBatch->TextColor;
                                    BackColor           = pBatch->BackColor;
                                    ulTextColor         = pBatch->ulTextColor;
                                    ulBackColor         = pBatch->ulBackColor;
                                    crBatchDCBrushColor = pBatch->DCBrushColor;
                                    ulBatchDCBrushColor = pBatch->ulDCBrushColor;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if (crSaveDCBrushColor != crBatchDCBrushColor)
                                {
                                    dcoDst.pdc->crDCBrushClr(crBatchDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulBatchDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

                                __try
                                {
                                    ptlBatchViewportOrg.x = pBatch->ptlViewportOrg.x;
                                    ptlBatchViewportOrg.y = pBatch->ptlViewportOrg.y;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if ((ptlViewportOrgSave.x != ptlBatchViewportOrg.x) ||
                                    (ptlViewportOrgSave.y != ptlBatchViewportOrg.y))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlBatchViewportOrg.x);
                                    dcoDst.pdc->lViewportOrgY(ptlBatchViewportOrg.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);

                                }

                                GrePolyPatBltInternal(
                                            dcoDst,
                                            pBatch->rop4,
                                            (PPOLYPATBLT)&pBatch->ulBuffer[0],
                                            Count,
                                            Mode,
                                            TextColor,
                                            BackColor,
                                            ulTextColor,
                                            ulBackColor
                                            );

                                //
                                // Restore the original DCBrush color
                                //
                                if (crSaveDCBrushColor != dcoDst.pdc->crDCBrushClr())
                                {
                                    dcoDst.pdc->crDCBrushClr(crSaveDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulSaveDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
                                    (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
                                    dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);

                                }

                            }
                            else
                            {
                                WARNING1("ERROR PolyPatBlt batch overflow\n");
                            }
                        }
                        break;

                        //
                        // common path for PatBlt and BitBlt
                        //

                        case BatchTypePatBlt:
                        {
                            PBATCHPATBLT pBatchPpb = (PBATCHPATBLT)pGdiBatch;

                            GDITraceHandle2(NtGdiPatBlt, "-BATCH %8lX: (%ld, %ld), %ldx%ld, HBR %lX, rop %lX...\n", (va_list)pBatchPpb, hdcDst, pBatchPpb->hbr);

                            int      x;
                            int      y;
                            int      cx;
                            int      cy;

                            DWORD    rop4;

                            ULONG    TextColor, ulTextColor;
                            ULONG    BackColor, ulBackColor;

                            __try
                            {
                                x           = pBatchPpb->x;
                                y           = pBatchPpb->y;
                                cx          = pBatchPpb->cx;
                                cy          = pBatchPpb->cy;
                                rop4        = pBatchPpb->rop4;
                                TextColor   = pBatchPpb->TextColor;
                                BackColor   = pBatchPpb->BackColor;
                                ulTextColor = pBatchPpb->ulTextColor;
                                ulBackColor = pBatchPpb->ulBackColor;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                break;
                            }
                            //
                            // Process the rop for DDI, check for no source required.
                            //

                            rop4 = (rop4 >> 16) & 0x000000FF;
                            rop4 = (rop4 << 8) | rop4;

                            //
                            // make sure command is a BitBlt or PatBlt with rop
                            // specifying no source required.
                            //

                            if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
                            {
                                //
                                // get color information
                                //

                                HBRUSH   hbrBatch,
                                         hbrSave  = dcoDst.pdc->hbrush();
                                COLORREF crSaveDCBrushColor,
                                         crSaveIcmBrushColor,
                                         crBatchDCBrushColor,
                                         crBatchIcmBrushColor;
                                BOOL     bIcmBrush = FALSE;
                                POINTL   ptlViewportOrgSave;
                                POINTL   ptlBatchViewportOrg;
                                ULONG    ulSaveDCBrushColor;
                                ULONG    ulBatchDCBrushColor;

                                __try
                                {
                                    hbrBatch = pBatchPpb->hbr;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                //
                                // Select the brush from batch record
                                //
                                GreDCSelectBrush(dcoDst.pdc,hbrBatch);

                                //
                                // Set the DCBrush Color from batch record
                                //
                                crSaveDCBrushColor = dcoDst.pdc->crDCBrushClr();
                                ulSaveDCBrushColor = dcoDst.pdc->ulDCBrushClr();

                                __try
                                {
                                    crBatchDCBrushColor = pBatchPpb->DCBrushColor;
                                    ulBatchDCBrushColor = pBatchPpb->ulDCBrushColor;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if (crSaveDCBrushColor != crBatchDCBrushColor)
                                {
                                    dcoDst.pdc->crDCBrushClr(crBatchDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulBatchDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                //
                                // Set the ICM-ed color from batch record
                                //  (only effective when ICM is turned-on)
                                //
                                if (dcoDst.pdc->bIsHostICM() &&
                                    dcoDst.pdc->hcmXform())
                                {
                                    //
                                    // Save the current ICM brush state.
                                    //
                                    bIcmBrush = dcoDst.pdc->bValidIcmBrushColor();

                                    //
                                    // if the ICM is enabled, we believe batch
                                    // record contains valid ICMed color.
                                    //
                                    dcoDst.pdc->ulDirtyAdd(ICM_BRUSH_TRANSLATED);

                                    crSaveIcmBrushColor = dcoDst.pdc->crIcmBrushColor();
                                    __try
                                    {
                                        crBatchIcmBrushColor = pBatchPpb->IcmBrushColor;
                                    }
                                    __except(EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        break;
                                    }

                                    if (crSaveIcmBrushColor != crBatchIcmBrushColor)
                                    {
                                        dcoDst.pdc->crIcmBrushColor(crBatchIcmBrushColor);
                                        dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                    }
                                }

                                ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();
                                __try
                                {
                                    ptlBatchViewportOrg.x = pBatchPpb->ptlViewportOrg.x;
                                    ptlBatchViewportOrg.y = pBatchPpb->ptlViewportOrg.y;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if ((ptlViewportOrgSave.x != ptlBatchViewportOrg.x) ||
                                    (ptlViewportOrgSave.y != ptlBatchViewportOrg.y))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlBatchViewportOrg.x);
                                    dcoDst.pdc->lViewportOrgY(ptlBatchViewportOrg.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);
                                }

                                //
                                // Execute PatBlt
                                //

                                EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

                                if (!xoDst.bRotation())
                                {
                                    ERECTL erclDst(x,y,x+cx,y+cy);
                                    xoDst.bXform(erclDst);
                                    erclDst.vOrder();

                                    if (!erclDst.bEmpty())
                                    {
                                        //
                                        // Accumulate bounds.  We can do this before knowing if the operation is
                                        // successful because bounds can be loose.
                                        //

                                        if (dcoDst.fjAccum())
                                        {
                                            dcoDst.vAccumulate(erclDst);
                                        }

                                        //
                                        // metafile patblt will have NULL surface but must still
                                        // accumulate bounds
                                        //

                                        SURFACE *pSurfDst = dcoDst.pSurface();

                                        if (pSurfDst != NULL)
                                        {
                                            GrePatBltLockedDC(
                                                           dcoDst,
                                                           xoDst,
                                                           &erclDst,
                                                           rop4,
                                                           pSurfDst,
                                                           TextColor,
                                                           BackColor,
                                                           ulTextColor,
                                                           ulBackColor
                                                           );
                                        }
                                    }
                                }
                                else
                                {
                                    //
                                    // There is rotation involved - send it off to MaskBlt to handle it.
                                    //
                                    COLORREF crTextColorOld = dcoDst.pdc->crTextClr();
                                    COLORREF crBackColorOld = dcoDst.pdc->crBackClr();
                                    COLORREF ulTextColorOld = dcoDst.pdc->ulTextClr();
                                    COLORREF ulBackColorOld = dcoDst.pdc->ulBackClr();

                                    dcoDst.pdc->crTextClr(TextColor);
                                    dcoDst.pdc->crBackClr(BackColor);
                                    dcoDst.pdc->ulTextClr(ulTextColor);
                                    dcoDst.pdc->ulBackClr(ulBackColor);

                                    GreMaskBlt(hdcDst, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);

                                    dcoDst.pdc->crTextClr(crTextColorOld);
                                    dcoDst.pdc->crBackClr(crBackColorOld);
                                    dcoDst.pdc->ulTextClr(ulTextColorOld);
                                    dcoDst.pdc->ulBackClr(ulBackColorOld);
                                }

                                //
                                // make sure dc brush is restored
                                //
                                if (dcoDst.pdc->hbrush() != hbrSave)
                                {
                                    dcoDst.pdc->hbrush(hbrSave);
                                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);
                                }

                                //
                                // Restore the original.
                                //
                                if (crSaveDCBrushColor != dcoDst.pdc->crDCBrushClr())
                                {
                                    dcoDst.pdc->crDCBrushClr(crSaveDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulSaveDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                if (dcoDst.pdc->bIsHostICM() &&
                                    dcoDst.pdc->hcmXform())
                                {
                                    if (crSaveIcmBrushColor != dcoDst.pdc->crIcmBrushColor())
                                    {
                                        dcoDst.pdc->crIcmBrushColor(crSaveIcmBrushColor);
                                        dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                    }

                                    if (!bIcmBrush)
                                        dcoDst.pdc->ulDirtySub(ICM_BRUSH_TRANSLATED);
                                }

                                if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
                                    (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
                                    dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);
                                }

                            }
                            else
                            {
                                WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
                            }
                        }
                        break;

                        default:

                            //
                            // unknown command on TEB
                            //

                            WARNING("ERROR in GDI batch command code");
                        }

                        //
                        // Decrement the batch command count and increment the batch
                        // pointer to the next batch command
                        //

                        GdiBatchCount--;

                        GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                            & ~(sizeof(PVOID)-1);

                        pGdiBatch += GdiBatchIncrement;

                    } while (
                              (GdiBatchCount > 0) &&
                              ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                            );

                    //
                    // clear batch control
                    //

                    __try
                    {
                        pteb->GdiBatchCount      = 0;
                        pteb->GdiTebBatch.Offset = 0;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }

                    //
                    // restore DC_ATTR brush and set dirty flag
                    //

                    dcoDst.pdc->hbrush(hbrDCA);
                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);

                }

                //
                // Unlock DC
                //

                dcoDst.vUnlock();
            }
            else
            {
                WARNING("GDI Batch routine: invalid hdc");
            }
        }

        //
        // non dc based commands must be executed whether there
        // was a dc or devlock failure or not. If the batch was
        // not flushed above, it must be flushed here.
        //

        if (bExecNonDCOnly)
        {
            //
            // can only be non-dc based batched commands
            //

            do
            {
                //
                // Pull patblt off teb and execute. TEB is not safe
                // so all offsets must be checked to make sure no
                // corruption has occured.
                //

                ULONG GdiBatchType;
                ULONG GdiBatchLength;
                ULONG GdiBatchIncrement;
                BOOL bRead = TRUE;

                __try
                {
                    GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                    GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    break;
                }

                if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
                {
                    //
                    // exit while loop
                    //

                    WARNING("Error in GDI TEB batch address");
                    break;
                }

                //
                // performance measure
                //

                #if DBG_GDI_BATCH

                if (GdiBatchType <8)
                {
                    GdiBatchTypeCounts[GdiBatchType]++;
                }

                #endif

                //
                // Check command type
                //

                switch (GdiBatchType)
                {

                //
                // execute ExtTextOut and ExtTextOutRect
                //

                case BatchTypeTextOut:
                case BatchTypeTextOutRect:
                case BatchTypeSelectClip:
                case BatchTypeSelectFont:
                case BatchTypePolyPatBlt:
                case BatchTypePatBlt:
                case BatchTypeSetBrushOrg:
                break;

                //
                // delete brush
                //

                case BatchTypeDeleteBrush:
                {
                    HOBJ hObj;
                    __try
                    {
                        hObj = (HOBJ)((PBATCHDELETEBRUSH)pGdiBatch)->hbrush;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        bRead = FALSE;
                    }
                    if (bRead)
                        bDeleteBrush((HBRUSH)hObj,FALSE);
                }
                break;

                //
                // delete region
                //

                case BatchTypeDeleteRegion:
                {
                    HOBJ hObj;

                    __try
                    {
                        hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        bRead = FALSE;
                    }
                    if (bRead)
                        bDeleteRegion((HRGN)hObj);
                }
                break;

                default:

                    //
                    // unknown command on TEB
                    //

                    WARNING("ERROR in GDI batch command code");
                }

               //
               // Decrement the batch command count and increment the batch
               // pointer to the next batch command
               //

               GdiBatchCount--;

               GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                            & ~(sizeof(PVOID)-1);

               pGdiBatch += GdiBatchIncrement;


            } while (
                      (GdiBatchCount > 0) &&
                      ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                    );

            __try
            {
                pteb->GdiBatchCount      = 0;
                pteb->GdiTebBatch.Offset = 0;
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
    }

    //
    // reset hDC
    //
    __try
    {
        pteb->GdiTebBatch.HDC = 0;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

/******************************Public*Routine******************************\
* GdiThreadCalloutFlushUserBatch
*
*   Processes all delete region calls that are part of the batch queue,
*   called only when a thread terminates and we want to recover the resources
*   allocated to a region. 
*   WINBUG We need a better solution to process the whole batch list when
*   thread terminates.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
\**************************************************************************/

VOID
GdiThreadCalloutFlushUserBatch()
{
    PTEB pteb = NtCurrentTeb();

    ULONG GdiBatchCount;
    PBYTE pGdiBatch;

    //
    // clear batch control
    //

    __try
    {
        GdiBatchCount = pteb->GdiBatchCount;
        pGdiBatch = (PBYTE)&pteb->GdiTebBatch.Buffer[0];
        pteb->GdiBatchCount      = 0;
        pteb->GdiTebBatch.Offset = 0;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    PBYTE pGdiBatchEnd = pGdiBatch + GDI_BATCH_SIZE;
    //
    // read batch once at start
    //

    if ( 
         (GdiBatchCount > 0)  &&
         (GdiBatchCount < (GDI_BATCH_SIZE/4))
       )
    {
        do
        {
            ULONG GdiBatchType;
            ULONG GdiBatchLength;
            ULONG GdiBatchIncrement;
            BOOL bRead = TRUE;

            __try
            {
                GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // Exit while loop.
                //
                break;
            }

            if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
            {
                //
                // exit while loop
                //

                WARNING("Error in GDI TEB batch address");
                break;
            }

            //
            // Check command type
            //

            switch (GdiBatchType)
            {

            //
            // execute ExtTextOut and ExtTextOutRect
            //

            case BatchTypeTextOut:
            case BatchTypeTextOutRect:
            case BatchTypeSelectClip:
            case BatchTypeSelectFont:
            case BatchTypePolyPatBlt:
            case BatchTypePatBlt:
            case BatchTypeSetBrushOrg:
            case BatchTypeDeleteBrush:
            break;

            //
            // delete region
            //

            case BatchTypeDeleteRegion:
            {
                HOBJ hObj;

                __try
                {
                    hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    bRead = FALSE;
                }

                if (bRead)
                    bDeleteRegion((HRGN)hObj);
            }
            break;

            default:

                //
                // unknown command on TEB
                //

                WARNING("ERROR in GDI batch command code");
            }

           //
           // Decrement the batch command count and increment the batch
           // pointer to the next batch command
           //

           GdiBatchCount--;

           GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                        & ~(sizeof(PVOID)-1);

           pGdiBatch += GdiBatchIncrement;


        } while (
                  (GdiBatchCount > 0) &&
                  ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                );
    }
}

/******************************Public*Routine******************************\
* NtGdiBitBlt
*
* API entry point for doing a BitBlt.
*
* returns: TRUE for success, FALSE for failure.
*
* History:
*  Wed 03-Nov-1993 -by- Patrick Haluptzok [patrickh]
* optimize for size, we make sure at dispatch level not to send functions
* that don't need a SRC to PatBlt.
*
*  Sun 30-Aug-1992 -by- Patrick Haluptzok [patrickh]
* optimize for performance
*
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Accumulate bounds, region pointer change.
*
*  Sun 20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make ATTRCACHE the default.
*
*  23-Apr-1991 -by- Patrick Haluptzok patrickh
* Expanded on ChuckWh's BitBlt code.
*
*  Wed 22-Aug-1990 15:22:39 -by- Charles Whitmer [chuckwh]
* BitBlt: Wrote it.  This is a first pass.
\**************************************************************************/

BOOL
NtGdiBitBlt(
    HDC    hdcDst,
    int    x,
    int    y,
    int    cx,
    int    cy,
    HDC    hdcSrc,
    int    xSrc,
    int    ySrc,
    DWORD  rop4,
#ifdef _WINDOWBLT_NOTIFICATION_
    DWORD  crBackColor,
    FLONG  fl
#else
    DWORD  crBackColor
#endif
)
{
#ifdef _WINDOWBLT_NOTIFICATION_
  GDITraceHandle2(NtGdiBitBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %X, %X)\n",
                  (va_list)&hdcDst, hdcDst, hdcSrc);
#else
  GDITraceHandle2(NtGdiBitBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %X)\n",
                  (va_list)&hdcDst, hdcDst, hdcSrc);
#endif

  BOOL bReturn = FALSE;

  //
  // Check for CAPTUREBLT rop flag; if it's set, let StretchBlt handle
  // it. [Bug #278291]
  //

  if (rop4 & CAPTUREBLT)
  {
      return GreStretchBlt(hdcDst,x,y,cx,cy,hdcSrc,xSrc,ySrc,cx,cy,rop4,crBackColor);
  }

  POINTL ptOrgDst;
  DWORD  OrgRop4 = rop4, dwOldLayout;

  rop4 = rop4 & ~NOMIRRORBITMAP;

#if DBG
  if ((((rop4 << 2) ^ rop4) & 0x00CC0000) == 0)
  {
      WARNING("NtGdiBitBlt() called with no source required\n");
  }
#endif

  // Lock down the DC

  XDCOBJ  dcoDst(hdcDst);

  if (dcoDst.bValid() && !dcoDst.bStockBitmap())
  {
    XDCOBJ  dcoSrc(hdcSrc);

    if (dcoSrc.bValid())
    {

      if ( ((dcoDst.pdc->dwLayout() & LAYOUT_ORIENTATIONMASK) != (dcoSrc.pdc->dwLayout() & LAYOUT_ORIENTATIONMASK)) &&
           (((OrgRop4 & NOMIRRORBITMAP) && MIRRORED_DC(dcoDst.pdc)) || MIRRORED_DC_NO_BITMAP_FLIP(dcoDst.pdc))
         ) {
        dcoDst.pdc->vGet_ptlWindowOrg( &ptOrgDst );
        dwOldLayout = dcoDst.pdc->dwSetLayout(-1, 0);
        x = ptOrgDst.x - x - cx;

        // Restore the DC if the flag is in the DC and not part
        // of the Rops. [samera]
        //
        OrgRop4 = NOMIRRORBITMAP;
      } else {
        OrgRop4 = 0;
      }

      EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
      EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);


      if ((!xoDst.bRotation()) && (xoDst.bEqualExceptTranslations(xoSrc)))
      {
        //
        // Return null operations.  Don't need to check source for
        // empty because the xforms are the same except translation.
        //

        ERECTL erclSrc(xSrc,ySrc,xSrc+cx,ySrc+cy);
        xoSrc.bXform(erclSrc);
        erclSrc.vOrder();

        ERECTL erclDst(x,y,x+cx,y+cy);
        xoDst.bXform(erclDst);
        erclDst.vOrder();

        if (!erclDst.bEmpty())
        {
          //
          // Accumulate bounds.  We can do this outside the DEVLOCK
          //

          if (dcoDst.fjAccum())
            dcoDst.vAccumulate(erclDst);

          //
          // Lock the Rao region and the surface if we are drawing on a
          // display surface.  Bail out if we are in full screen mode.
          //

          DEVLOCKBLTOBJ dlo;
          BOOL bLocked;

          bLocked = dlo.bLock(dcoDst, dcoSrc);

          if (bLocked)
          {
            //
            // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
            //

            SURFACE *pSurfDst;

            if ((pSurfDst = dcoDst.pSurface()) != NULL)
            {
              //
              // Set up the brush if necessary.
              //

              XEPALOBJ   palDst(pSurfDst->ppal());
              XEPALOBJ   palDstDC(dcoDst.ppal());
              EBRUSHOBJ *pbo;

              //
              // Finish rop to pass over ddi to driver.
              //

              rop4 = (rop4 >> 16) & 0x000000FF;
              rop4 = (rop4 << 8) | rop4;

              //
              // Check if we need a brush.
              //

              if ((((rop4 << 4) ^ rop4) & 0x00F0) != 0)
              {
                pbo = dcoDst.peboFill();

                ULONG ulDirty = dcoDst.pdc->ulDirty();

                if ( ulDirty & DC_BRUSH_DIRTY)
                {
                    GreDCSelectBrush(dcoDst.pdc,dcoDst.pdc->hbrush());
                }

                if ((dcoDst.ulDirty() & DIRTY_FILL) || (dcoDst.pdc->flbrush() & DIRTY_FILL))
                {
                  dcoDst.ulDirtySub(DIRTY_FILL);
                  dcoDst.pdc->flbrushSub(DIRTY_FILL);

                  pbo->vInitBrush(
                          dcoDst.pdc,
                          dcoDst.pdc->pbrushFill(),
                          palDstDC,
                          palDst,
                          pSurfDst);
                }
              }
              else
              {
                  pbo = NULL;
              }

              //
              // With a fixed DC origin we can change the destination to SCREEN coordinates.
              //

              erclDst += dcoDst.eptlOrigin();

              EPOINTL eptlOffset;
              SURFACE *pSurfSrc = dcoSrc.pSurface();

              //
              // Basically we check that pSurfSrc is not NULL which
              // happens for memory bitmaps with the default bitmap
              // and for info DC's.  Otherwise we continue if
              // the source is readable or if it isn't we continue
              // if we are blting display to display or if User says
              // we have ScreenAccess on this display DC.  Note
              // that if pSurfSrc is not readable the only way we
              // can continue the blt is if the src is a display.
              //

              if (pSurfSrc != NULL)
              {
                  if ((pSurfSrc->bReadable() && ((dcoDst.bDisplay() && !dcoDst.bRedirection()) ? UserScreenAccessCheck() : TRUE)) ||
                     ( (dcoSrc.bDisplay())  &&
                       ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                  {
                    //
                    // Lock the source surface.
                    //

                    XEPALOBJ palSrc(pSurfSrc->ppal());

                    //
                    // Compute the offset between source and dest, in screen coordinates.
                    //

                    eptlOffset.x = erclDst.left - erclSrc.left - dcoSrc.eptlOrigin().x;
                    eptlOffset.y = erclDst.top - erclSrc.top - dcoSrc.eptlOrigin().y;

                    //
                    // Compute the source surface origin, taking into account multi-mon
                    // and negative offsets:
                    //

                    LONG xOrigin = 0;
                    LONG yOrigin = 0;

                    PDEVOBJ pdoSrc(pSurfSrc->hdev());
                    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc)) && (pdoSrc.bMetaDriver()))
                    {
                        xOrigin = pdoSrc.pptlOrigin()->x;
                        yOrigin = pdoSrc.pptlOrigin()->y;
                    }

                    //
                    // Take care of the source rectangle.  We may have to reduce it. We do this
                    // so a driver can always assume that neither the source nor the destination
                    // rectangles hang over the edge of a surface.
                    //
                    // Intersect the dest with the source surface extents.
                    //

                    erclDst.left    = MAX(xOrigin + eptlOffset.x, erclDst.left);
                    erclDst.top     = MAX(yOrigin + eptlOffset.y, erclDst.top);
                    erclDst.right   = MIN((xOrigin + pSurfSrc->sizl().cx + eptlOffset.x), erclDst.right);
                    erclDst.bottom  = MIN((yOrigin + pSurfSrc->sizl().cy + eptlOffset.y), erclDst.bottom);

                    if ((erclDst.left < erclDst.right) && (erclDst.top < erclDst.bottom))
                    {
                      //
                      // This is a pretty gnarly expression to save a return in here.
                      // Basically pco can be NULL if the rect is completely in the
                      // cached rect in the DC or if we set up a clip object that isn't empty.
                      //

                      ECLIPOBJ *pco = NULL;

                      if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                           (erclDst.right  <= dcoDst.prclClip()->right) &&
                           (erclDst.top    >= dcoDst.prclClip()->top) &&
                           (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                          (pco = dcoDst.pco(),
                           pco->vSetup(dcoDst.prgnEffRao(), erclDst, CLIP_NOFORCETRIV),
                           erclDst = pco->erclExclude(),
                           (!erclDst.bEmpty())))
                      {
                        //
                        // Compute the (reduced) origin.
                        //

                        erclSrc.left = erclDst.left - eptlOffset.x;
                        erclSrc.top = erclDst.top - eptlOffset.y;

                        DEVEXCLUDEOBJ dxo;
                        EXLATEOBJ xlo;
                        XLATEOBJ *pxlo;

                        //
                        // C++ would generate alot of code to exit here to have
                        // a return so we set bReturn to TRUE if we succeed to
                        // init a valid xlate.  We avoid a return this way.
                        //

                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                        {
                          pxlo = NULL;
                          bReturn = TRUE;

                          //
                          // To Call vExclude directly you must check it's a Display PDEV
                          // and that cursor exclusion needs to be done.
                          //

                          if (dcoDst.bDisplay() && dcoDst.bNeedsSomeExcluding())
                          {
                            //
                            // Compute the exclusion rectangle.  (It's expanded to include the source.)
                            //

                            ERECTL erclReduced = erclDst;

                            if (erclSrc.left < erclReduced.left)
                                erclReduced.left = erclSrc.left;
                            else
                                erclReduced.right += (erclSrc.left - erclReduced.left);

                            if (erclSrc.top < erclReduced.top)
                                erclReduced.top  = erclSrc.top;
                            else
                                erclReduced.bottom += (erclSrc.top - erclReduced.top);

                            dxo.vExclude2(dcoDst.hdev(), &erclReduced, pco, &eptlOffset);
                          }
                        }
                        else
                        {
                          //
                          // Get a translate object.
                          //

                          XEPALOBJ   palSrcDC(dcoSrc.ppal());

                          if (crBackColor == (COLORREF)-1)
                              crBackColor = dcoSrc.pdc->ulBackClr();

                          //
                          // No ICM with BitBlt(), so pass NULL color transform to XLATEOBJ
                          //

                          bReturn = xlo.bInitXlateObj(NULL,                   // hColorTransform
                                                      dcoDst.pdc->lIcmMode(), // ICM mode
                                                      palSrc,
                                                      palDst,
                                                      palSrcDC,
                                                      palDstDC,
                                                      dcoDst.pdc->crTextClr(),
                                                      dcoDst.pdc->crBackClr(),
                                                      crBackColor);

                          pxlo = xlo.pxlo();

                          //
                          // WARNING: When we support multiple displays that support cursors
                          // the following exclude logic will need to be redone.  Right now
                          // we assume that there can only be 1 display surface around that
                          // needs cursor exclusion.
                          //

                          if (dcoDst.bDisplay())
                          {
                            if (dcoDst.bNeedsSomeExcluding())
                            {
                              //
                              // To Call vExclude directly you must check it's a Display PDEV
                              // and that cursor exclusion needs to be done.
                              //

                              dxo.vExclude(dcoDst.hdev(),&erclDst,pco);
                            }
                          }
                          else
                          {
                            //
                            // The left top of erclSrc is correctly computed
                            // we just need the bottom,right updated now.
                            //

                            erclSrc.right = erclDst.right - eptlOffset.x,
                            erclSrc.bottom = erclDst.bottom - eptlOffset.y,
                            dxo.vExcludeDC(dcoSrc,&erclSrc);
                          }
                        }

                        if (bReturn)
                        {
                          //
                          // Inc the target surface uniqueness
                          //

                          INC_SURF_UNIQ(pSurfDst);

                          //
                          // Check if we're on the same PDEV, we can't blt between
                          // different PDEV's.  Well, actually we can so long as the
                          // source is an engine-exclusive surface, which we check
                          // by looking at iType() and dhsurf().
                          //

                          if ((dcoDst.hdev() == dcoSrc.hdev()) ||
                              ((pSurfSrc->iType() == STYPE_BITMAP) &&
                               (pSurfSrc->dhsurf() == NULL) && !dcoDst.bPrinter()))
                          {
                            if (rop4 == 0xCCCC)
                            {
                              PDEVOBJ pdo(pSurfDst->hdev());

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// To enable, need to add these to winddi.h:
//
//      #define GCAPS2_WINDOW_BLT       0x00000004
//      #define BMF_WINDOW_BLT          0x0040
//
// In addition, w32\kmode\services.tab needs to be modified to add a
// parameter to BitBlt.
//
// See also:
//      w32\w32inc\gre.h
//      ntgdi\inc\ntgdi.h
//      ntgdi\client\output.c
//      ntgdi\gre\maskblt.cxx
//      ntuser\kernel\swp.c         zzzBltValidBits is where BitBlt
//                                  is called to move the window
//
#ifdef _WINDOWBLT_NOTIFICATION_
                              //
                              // If window blt notification needed, add
                              // the bit to dst surface flags.
                              //

                              if (fl & GBB_WINDOWBLT)
                                pSurfDst->fjBitmap(pSurfDst->fjBitmap() | BMF_WINDOW_BLT);
#endif

                              bReturn = (*PPFNGET(pdo, CopyBits, pSurfDst->flags())) (
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc);

#ifdef _WINDOWBLT_NOTIFICATION_
                              //
                              // Clear the window blt notification flag.  Not
                              // valid anywhere else, so don't bother checking
                              // if we actually set it.
                              //

                              pSurfDst->fjBitmap(pSurfDst->fjBitmap() & ~BMF_WINDOW_BLT);
#endif
                            }
                            else
                            {
                              bReturn = (*(pSurfDst->pfnBitBlt())) (
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           (SURFOBJ *) NULL,
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc,
                                           (POINTL *)  NULL,
                                           pbo,
                                           &dcoDst.pdc->ptlFillOrigin(),
                                           rop4);
                            }
                          }
                          else
                          {
                            //
                            // we need to carry dlo down since we may need
                            // to free the DEVLOCK of the source surf if
                            // we are going out to user mode printer drivers
                            //

                            PDEVOBJ pdoDst(pSurfDst->hdev());

                            bReturn = SimBitBlt(
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           (SURFOBJ *) NULL,
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc,
                                           (POINTL *)  NULL,
                                           pbo,
                                           &dcoDst.pdc->ptlFillOrigin(),
                                           rop4,
                                           pdoDst.bPrinter() ? &dlo : NULL);
                          }
                        }
                        else
                        {
                          WARNING1("bInitXlateObj failed in GreBitBlt\n");
                        }
                      }
                      else
                      {
                          bReturn = TRUE;
                      }
                  }
                  else
                  {
                    bReturn = TRUE;
                  }
                }
                else
                {
                    WARNING1("GreBitBlt failed - trying to read from unreadable surface\n");
                    EngSetLastError(ERROR_INVALID_HANDLE);
                }
              }
              else
              {
                  bReturn = TRUE;
              }
            }
            else
            {
              bReturn = TRUE;
            }
          }
          else
          {
            // Return True if we are in full screen mode.

            bReturn = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
          }
        }
        else
        {
          bReturn = TRUE;
        }
      }
      else
      {
        bReturn = GreStretchBlt(hdcDst,x,y,cx,cy,hdcSrc,xSrc,ySrc,cx,cy,rop4,crBackColor);
      }
      if (OrgRop4 & NOMIRRORBITMAP) {
        dcoDst.pdc->dwSetLayout(-1, dwOldLayout);
      }
      dcoSrc.vUnlockFast();
    }
    else
    {
      WARNING1("GreBitBlt failed invalid SrcDC\n");
    }
    dcoDst.vUnlockFast();

  }
  else
  {
    WARNING1("GreBitBlt failed invalid DstDC\n");
  }

  return(bReturn);
}
/******************************Public*Routine******************************\
* GreRectBlt
*
* Internal entry point for faster Rectangle drawing.  The rectangle is
* specified in device pixel coordinates.
*
* NOTE: The caller must have already taken care of the brush dirty bits!
*
* History:
*  6-May-1992 -by- J. Andrew Goossen [andrewgo]
* Cloned some code.
\**************************************************************************/

BOOL GreRectBlt(
DCOBJ&     dcoTrg,
ERECTL*    percl       // Device pixel coordinates
)
{
    ASSERTGDI(dcoTrg.bValid(), "Invalid DC");

    BLTRECORD   blt;

// Initialize the blt record

    ROP4 rop4 = gaMix[dcoTrg.pdc->jROP2() & 0x0F];
    ULONG ulAvec = (ULONG) gajRop3[rop4];
    ASSERTGDI(!(ulAvec & AVEC_NEED_SOURCE), "Invalid rop");

// Accumulate bounds.  We can do this outside the DEVLOCK

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*percl);


// Lock the target surface

    DEVLOCKBLTOBJ dlo(dcoTrg);

// This check also verifies that there's a surface

    if (dcoTrg.bFullScreen())
    {
        return(TRUE);
    }

    if (!dlo.bValid())
    {
        return(FALSE);
    }

    blt.pSurfTrg(dcoTrg.pSurface());
    ASSERTGDI(blt.pSurfTrg() != NULL, "ERROR no good");
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

// Set up the brush if necessary.

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        blt.pbo(dcoTrg.peboFill());

        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
            GreDCSelectBrush(dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg()
                                );
        }

    // We have to check for a NULL brush because the dirty bits might be
    // wrong, and the 'realized' brush is a NULL one:

        if (blt.pbo()->bIsNull())
            return(FALSE);

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());

        if ((blt.pbo()->bIsMasking()) &&
            (dcoTrg.pdc->jBkMode() == TRANSPARENT))
        {
            rop4 = rop4 | (0xAA00);
        }
        else
        {
            rop4 = (rop4 << 8) | rop4;
        }
    }
    else
    {
    // No masking being done, simple rop.

        blt.pbo(NULL);

        rop4 = (rop4 << 8) | rop4;
    }

    blt.rop(rop4);

// Initialize some stuff for DDI.

    blt.pSurfMsk((SURFACE *) NULL);

// Set the target rectangle and blt the bits.

    *blt.perclTrg() = *percl;

    return(blt.bBitBlt(dcoTrg, dcoTrg, ulAvec));
}

/******************************Public*Routine******************************\
* GreMaskBlt
*
* API entry point for doing a BitBlt with a Mask.
*
* History:
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Complete rewrite.
*
*  20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make ATTRCACHE the default.
*
*  23-Apr-1991 -by- Patrick Haluptzok patrickh
* Expanded on ChuckWh's BitBlt code.
*
*  Wed 22-Aug-1990 15:22:39 -by- Charles Whitmer [chuckwh]
* BitBlt: Wrote it.  This is a first pass.
\**************************************************************************/

BOOL
GreMaskBlt(
    HDC        hdcTrg,
    int        x,
    int        y,
    int        cx,
    int        cy,
    HDC        hdcSrc,
    int        xSrc,
    int        ySrc,
    HBITMAP    hbmMask,
    int        xMask,
    int        yMask,
    DWORD      rop4,
    DWORD      crBackColor
    )
{
    GDITraceHandle3(GreMaskBlt,
                    "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %d, %d, %X, %X)\n",
                    (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    ULONG ulAvec;
    BLTRECORD   blt;

    //
    // Lock the target DC and surface
    //

    DCOBJ   dcoTrg(hdcTrg);
    BOOL    bReturn = FALSE;

    if (!dcoTrg.bValidSurf())
    {
        if (dcoTrg.bValid() && !dcoTrg.bStockBitmap())
        {
            if (dcoTrg.fjAccum())
            {
                EXFORMOBJ exo(dcoTrg, WORLD_TO_DEVICE);
                ERECTL    ercl(x, y, x + cx, y + cy);

                if (exo.bXform(ercl))
                {
                    //
                    // Make the rectangle well ordered.
                    //

                    ercl.vOrder();
                    dcoTrg.vAccumulate(ercl);
                    bReturn = TRUE;
                }
            }
            else
                bReturn = TRUE;
        }
        else
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

        return(bReturn);
    }

    if (dcoTrg.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return bReturn;
    }

// Initialize the blt record

// Deal with the mask if needed

    rop4 >>= 16;

    if ((hbmMask == 0) || ((rop4 & 0x00FF) == ((rop4 >> 8) & 0x00FF)))
    {
        rop4 &= 0x00FF;
        ulAvec = gajRop3[rop4];
        rop4 = rop4 | (rop4 << 8);
        blt.rop(rop4);
        blt.pSurfMsk((SURFACE *) NULL);
    }
    else
    {
        SURFREF soMsk((HSURF)hbmMask);

        if (!soMsk.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        blt.pSurfMsk((SURFACE *) soMsk.ps);

        if ((blt.pSurfMsk()->iType() != STYPE_BITMAP) ||
            (blt.pSurfMsk()->iFormat() != BMF_1BPP))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        soMsk.vKeepIt();

        blt.flSet(BLTREC_MASK_NEEDED | BLTREC_MASK_LOCKED);

        blt.rop(rop4);
        ulAvec  = ((ULONG) gajRop3[blt.ropFore()]) |
                  ((ULONG) gajRop3[blt.ropBack()]);

        ulAvec |= AVEC_NEED_MASK;
    }

// Lock the source DC if necessary

    DCOBJ     dcoSrc;

// Lock the relevant surfaces

    DEVLOCKBLTOBJ dlo;

    if (ulAvec & AVEC_NEED_SOURCE)
    {
        dcoSrc.vLock(hdcSrc);
    }

    if ((ulAvec & AVEC_NEED_SOURCE) && (dcoSrc.bValid()))
    {
        dlo.bLock(dcoTrg, dcoSrc);
    }
    else
    {
        dlo.bLock(dcoTrg);
    }

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen());
    }

    blt.pSurfTrg(dcoTrg.pSurface());
    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    if (ulAvec & AVEC_NEED_SOURCE)
    {
        if (!dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
        {
            if (!dcoSrc.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            if (!dcoSrc.pSurfaceEff()->bReadable())
            {
                if (dcoTrg.dctp() == DCTYPE_INFO)
                {
                    if (dcoTrg.fjAccum())
                    {
                        EXFORMOBJ exo(dcoTrg, WORLD_TO_DEVICE);
                        ERECTL    ercl(x, y, x + cx, y + cy);

                        if (exo.bXform(ercl))
                        {
                        // Make the rectangle well ordered.

                            ercl.vOrder();
                            dcoTrg.vAccumulate(ercl);
                        }

                        return(TRUE);
                    }
                }

            // Do the security test on SCREEN to MEMORY blits.

                if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
                {
                    if (!UserScreenAccessCheck())
                    {
                        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                        return(FALSE);
                    }
                }
            }

        // If the source isn't a DISPLAY we should exit

            if (!dcoSrc.bDisplay())
                return(FALSE);
        }

        blt.pSurfSrc(dcoSrc.pSurfaceEff());
        blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
        blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());
        blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);

    // Now set the source rectangle

        if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cx, cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    // If there is a mask, set the mask rectangle

        if (ulAvec & AVEC_NEED_MASK)
            blt.Msk(xMask, yMask);

    // Create the color translation object
    //
    // No ICM with MaskBlt(), so pass NULL color transform to XLATEOBJ

        if (!blt.pexlo()->bInitXlateObj(NULL,                   // hColorTransform
                                        dcoTrg.pdc->lIcmMode(), // ICM mode
                                       *blt.ppoSrc(),
                                       *blt.ppoTrg(),
                                       *blt.ppoSrcDC(),
                                       *blt.ppoTrgDC(),
                                        dcoTrg.pdc->crTextClr(),
                                        dcoTrg.pdc->crBackClr(),
                                        crBackColor))
        {
            WARNING("bInitXlateObj failed in MaskBlt\n");
            return(FALSE);
        }

        blt.flSet(BLTREC_PXLO);
    }
    else
    {
        blt.pSurfSrc((SURFACE *) NULL);

    // We need to lock the source DC if a mask is required.  We need
    // this to get the transform for the mask rectangle.

        if (ulAvec & AVEC_NEED_MASK)
        {
            //
            // if hdcSrc is NULL, assign to hdcTrg
            //

            if (hdcSrc == (HDC)NULL) {
                hdcSrc = hdcTrg;
            }

            dcoSrc.vLock(hdcSrc);

            if (!dcoSrc.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                return(FALSE);
            }

            blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);

        // Use the target extents (we need something) to specify the
        // size of the mask.  The extent is actually saved in the SOURCE
        // rectangle, since this is the only meaningful place for it.

            if (blt.pxoSrc()->bRotation() || !blt.Msk(xMask, yMask, cx, cy))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

// Set up the brush if necesary.

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        blt.pbo(dcoTrg.peboFill());

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
            GreDCSelectBrush(dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg());
        }

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());

    } else {

        //
        // NULL the pebo
        //

        blt.pbo((EBRUSHOBJ *)NULL);
    }

// Now all the essential information has been collected.  We now
// need to check for promotion and call the appropriate method to
// finish the blt.  If we rotate we must send the call away.

    if (dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay())
    {
        if (!UserScreenAccessCheck())
        {
            SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
            return (FALSE);
        }
    }

    if (blt.pxoTrg()->bRotation())
    {
        if (!blt.TrgPlg(x, y, cx, cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        return(blt.bRotate(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

// We can now set the target rectangle

    if (!blt.Trg(x, y, cx, cy))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// If there is a source and we scale, send the call away.  Note that
// since the mask extent is cleverly placed in aptlSrc if there is no
// source, maskblts that scale will get sent to bStretch().

    if ((ulAvec & AVEC_NEED_SOURCE) && !blt.bEqualExtents())
        return(blt.bStretch(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));

    return(blt.bBitBlt(dcoTrg, dcoSrc, ulAvec));
}

/******************************Public*Routine******************************\
* BLTRECORD::bBitBlt(dcoTrg, dcoSrc, ulAvec)
*
* Do a bitblt from the blt record
*
* History:
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bBitBlt(
DCOBJ&      dcoTrg,
DCOBJ&      dcoSrc,
ULONG       ulAvec)
{
    //
    // Make the target rectangle well ordered.
    //

    perclTrg()->vOrder();

    //
    // Compute the new Rao region if it's dirty.  This can happen if
    // we need clipping due to a rotation (the DEVLOCKBLTOBJ is obtained
    // before we compute the clipping in the prgnAPI)
    //

    if (dcoTrg.pdc->bDirtyRao())
    {
        if (!dcoTrg.pdc->bCompute())
        {
            return(FALSE);
        }
    }

    //
    // Accumulate bounds.  We can do this before knowing if the operation is
    // successful because bounds can be loose.
    //

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*perclTrg());

    //
    // With a fixed DC origin we can change the target to SCREEN coordinates.
    //

    *perclTrg() += dcoTrg.eptlOrigin();

    //
    // Handle BitBlts without source
    //

    //
    // Get an PDEV for dispatching
    //

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());


    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        ECLIPOBJ eco(dcoTrg.prgnEffRao(), *perclTrg());

        //
        // Check the target which is reduced by clipping.
        //

        if (eco.erclExclude().bEmpty())
        {
            return(TRUE);
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.  Rememeber, the source extent equals the
        // required size for the mask in cases with no source needed!
        //
        // The mask offsets must not be negative.
        //
        // cx and cy, which are stored in perclSrc, may be negative
        //
        // if cx is negative then the mask x points must be swapped
        // if cy is negative then the mask y points must be swapped
        //

        if (perclSrc()->right < 0) {
            LONG lTmp;
            lTmp          = aptlMask[0].x;
            aptlMask[0].x = aptlMask[1].x;
            aptlMask[1].x = lTmp;
        }

        if (perclSrc()->bottom < 0) {
            LONG lTmp;
            lTmp          = aptlMask[0].y;
            aptlMask[0].y = aptlMask[1].y;
            aptlMask[1].y = lTmp;
        }

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (pSurfMsk()->sizl().cx - aptlMask[0].x < ABS(perclSrc()->right)) ||
                (pSurfMsk()->sizl().cy - aptlMask[0].y < ABS(perclSrc()->bottom)))
            {

                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            //
            // Adjust the mask origin for clipping
            //

            aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
            aptlMask[0].y += eco.erclExclude().top  - perclTrg()->top;
        }

        //
        // Exclude the pointer.
        //

        DEVEXCLUDEOBJ dxo(dcoTrg,&eco.erclExclude(),&eco);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfTrg());

        //
        // Dispatch the call.
        //

        return((*(pSurfTrg()->pfnBitBlt()))
                (pSurfTrg()->pSurfobj(),
                 (SURFOBJ *) NULL,
                 pSurfMskOut()->pSurfobj(),
                 &eco,
                 NULL,
                 perclTrg(),
                 (POINTL *) NULL,
                 aptlMask,
                 pbo(),
                 aptlBrush,
                 rop4));
    }

    //
    // Now compute the source rectangle
    //

    EPOINTL *peptlOff = (EPOINTL *) &aptlSrc[0];
    EPOINTL *peptlSrc = (EPOINTL *) &aptlSrc[1];

    peptlSrc->x = MIN(peptlSrc->x, peptlOff->x);
    peptlSrc->y = MIN(peptlSrc->y, peptlOff->y);

    ERECTL erclReduced;

    //
    // if cx or cy was negative then hte corosponding mask extents
    // must be swapped
    //

    if (aptlSrc[0].x > aptlSrc[1].x) {
        LONG lTmp;
        lTmp          = aptlMask[0].x;
        aptlMask[0].x = aptlMask[1].x;
        aptlMask[1].x = lTmp;
    }

    if (aptlSrc[0].y > aptlSrc[1].y) {
        LONG lTmp;
        lTmp          = aptlMask[0].y;
        aptlMask[0].y = aptlMask[1].y;
        aptlMask[1].y = lTmp;
    }

    //
    // If the source and target are the same surface, we won't have
    // to DEVLOCK the source and other fun stuff.
    //

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        //
        // Compute the source surface origin, taking into account multi-mon
        // and negative offsets:
        //

        LONG xOrigin = 0;
        LONG yOrigin = 0;

        PDEVOBJ pdoSrc(pSurfSrc()->hdev());
        if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc())) && (pdoSrc.bMetaDriver()))
        {
            xOrigin = pdoSrc.pptlOrigin()->x;
            yOrigin = pdoSrc.pptlOrigin()->y;
        }

        //
        // Compute the offset between source and target, in screen coordinates.
        //

        peptlOff->x = perclTrg()->left - peptlSrc->x - dcoSrc.eptlOrigin().x;
        peptlOff->y = perclTrg()->top  - peptlSrc->y - dcoSrc.eptlOrigin().y;

        //
        // Take care of the source rectangle.  We may have to reduce it.  This is
        // not good enough for a secure system, we are doing it so that the device
        // driver can always assume that neither the source nor the target
        // rectangles hang over the edge of a surface.
        //
        // Intersect the target with the source clipping window.
        //

        erclReduced.left   = peptlOff->x + xOrigin;
        erclReduced.top    = peptlOff->y + yOrigin;
        erclReduced.right  = peptlOff->x + xOrigin + pSurfTrg()->sizl().cx;
        erclReduced.bottom = peptlOff->y + yOrigin + pSurfTrg()->sizl().cy;
        erclReduced *= *perclTrg();

        ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclReduced);

        erclReduced = eco.erclExclude();

        //
        // Check the target which is reduced by clipping.
        //

        if (erclReduced.bEmpty())
        {
            return(TRUE);
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.
        //
        //  aptlMask must not be negative.
        //
        //  Blt Trg extents have already been ordered
        //

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                ((pSurfMsk()->sizl().cx - aptlMask[0].x) < (perclTrg()->right - perclTrg()->left)) ||
                ((pSurfMsk()->sizl().cy - aptlMask[0].y) < (perclTrg()->bottom - perclTrg()->top)))
            {

                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            //
            // Adjust the mask origin for clipping
            //

            aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
            aptlMask[0].y += eco.erclExclude().top  - perclTrg()->top;
        }

        //
        // Compute the (reduced) origin.
        //

        peptlSrc->x = erclReduced.left - peptlOff->x;
        peptlSrc->y = erclReduced.top - peptlOff->y;

        //
        // Compute the exclusion rectangle.  (It's expanded to include the source.)
        //

        if (peptlSrc->x < erclReduced.left)
            erclReduced.left    = peptlSrc->x;
        else
            erclReduced.right  += peptlSrc->x - erclReduced.left;

        if (peptlSrc->y < erclReduced.top)
            erclReduced.top    = peptlSrc->y;
        else
            erclReduced.bottom += peptlSrc->y - erclReduced.top;

        //
        // Exclude the pointer from the output region and offset region.
        //

        DEVEXCLUDEOBJ dxo(dcoTrg,&erclReduced,&eco,peptlOff);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfTrg());

        //
        // Dispatch the call.
        //

        if (rop4 == 0xCCCC) {

            //
            // call copy bits if rop specifies srccopy
            //

            return((*PPFNGET(pdoTrg,CopyBits,pSurfTrg()->flags())) (
                pSurfTrg()->pSurfobj(),
                pSurfSrc()->pSurfobj(),
                &eco,
                NULL,
                &eco.erclExclude(),
                peptlSrc));

        } else {

            return((*(pSurfTrg()->pfnBitBlt())) (
                 pSurfTrg()->pSurfobj(),
                 pSurfSrc()->pSurfobj(),
                 pSurfMskOut()->pSurfobj(),
                 &eco,
                 NULL,
                 &eco.erclExclude(),
                 peptlSrc,
                 aptlMask,
                 pbo(),
                 aptlBrush,
                 rop4));
        }
    }

    //
    // If the devices are on different PDEV's and we are not targeting a meta driver
    // then we can only succeed if the Engine
    // manages one or both of the surfaces.  Check for this.
    //
    // WINBUG #298689 4-4-2001 jasonha  Handle any device stretch to Meta

    BOOL bTrgMetaDriver = (dcoTrg.bSynchronizeAccess() && pdoTrg.bValid() && pdoTrg.bMetaDriver());
    
    if (dcoTrg.hdev() != dcoSrc.hdev())
    {
       if (!bTrgMetaDriver)
       {
            if(((dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP)
               || (dcoTrg.pSurfaceEff()->dhsurf() != NULL)) &&
              ((dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
               || (dcoSrc.pSurfaceEff()->dhsurf() != NULL)))
            {
              SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
              return(FALSE);
            }
       }
    }

    //
    // Compute the source surface origin, taking into account multi-mon
    // and negative offsets:
    //

    LONG xOrigin = 0;
    LONG yOrigin = 0;

    PDEVOBJ pdoSrc(pSurfSrc()->hdev());
    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc())) && (pdoSrc.bMetaDriver()))
    {
        xOrigin = pdoSrc.pptlOrigin()->x;
        yOrigin = pdoSrc.pptlOrigin()->y;
    }

    //
    // Compute the offset between source and dest, in screen coordinates.
    //

    peptlOff->x = perclTrg()->left - peptlSrc->x - dcoSrc.eptlOrigin().x;
    peptlOff->y = perclTrg()->top - peptlSrc->y - dcoSrc.eptlOrigin().y;

    //
    // Take care of the source rectangle.  We may have to reduce it.  This is
    // not good enough for a secure system, we are doing it so that the device
    // driver can always assume that neither the source nor the destination
    // rectangles hang over the edge of a surface.
    // Intersect the dest with the source surface extents.
    //

    erclReduced.left   = peptlOff->x + xOrigin;
    erclReduced.top    = peptlOff->y + yOrigin;
    erclReduced.right  = peptlOff->x + xOrigin + pSurfSrc()->sizl().cx;
    erclReduced.bottom = peptlOff->y + yOrigin + pSurfSrc()->sizl().cy;
    erclReduced *= *perclTrg();

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclReduced);

    erclReduced = eco.erclExclude();

    //
    // Check the destination which is reduced by clipping.
    //

    if (erclReduced.bEmpty())
    {
        return(TRUE);
    }

    //
    // Before we call to the driver, validate that the mask will actually
    // cover the entire source/target.
    //

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if ((aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            ((pSurfMsk()->sizl().cx - aptlMask[0].x) < (perclTrg()->right - perclTrg()->left)) ||
            ((pSurfMsk()->sizl().cy - aptlMask[0].y) < (perclTrg()->bottom - perclTrg()->top)))
        {

            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        // Adjust the mask origin for clipping

        aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
        aptlMask[0].y += eco.erclExclude().top    - perclTrg()->top;
    }

    //
    // Compute the (reduced) origin.
    //

    peptlSrc->x = erclReduced.left - peptlOff->x;
    peptlSrc->y = erclReduced.top  - peptlOff->y;

    //
    // Get ready to exclude the cursor
    //

    DEVEXCLUDEOBJ dxo;

    //
    // They can't both be display so if the source is do the special stuff.
    // The following code assumes there is only 1 display in the system.
    //

    if (dcoSrc.bDisplay())
    {
        erclReduced -= *peptlOff;
        dxo.vExclude(dcoSrc.hdev(),&erclReduced,NULL);
    }
    else if (dcoTrg.bDisplay())
    {
        dxo.vExclude(dcoTrg.hdev(),&erclReduced,&eco);
    }

    //
    // Inc the target surface uniqueness
    //

    INC_SURF_UNIQ(pSurfTrg());

    //
    // Dispatch the call.
    //

    if (rop4 == 0xCCCC) {

        //
        // call copy bits if rop specifies srccopy
        //

        return((*PPFNGET(pdoTrg,CopyBits,pSurfTrg()->flags())) (
            pSurfTrg()->pSurfobj(),
            pSurfSrc()->pSurfobj(),
            &eco,
            pexlo()->pxlo(),
            &eco.erclExclude(),
            peptlSrc));

    } else {

        return((*(pSurfTrg()->pfnBitBlt()))
            (pSurfTrg()->pSurfobj(),
             pSurfSrc()->pSurfobj(),
             pSurfMskOut()->pSurfobj(),
             &eco,
             pexlo()->pxlo(),
             &eco.erclExclude(),
             peptlSrc,
             aptlMask,
             pbo(),
             aptlBrush,
             rop4));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\mapfile.c ===
/******************************Module*Header*******************************\
* Module Name: mapfile.c
*
* Created: 25-Jun-1992 14:33:45
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"
#include "ntnls.h"
#include "stdlib.h"

#include "ugdiport.h"

extern HFASTMUTEX ghfmMemory;

ULONG LastCodePageTranslated = 0;  // I'm assuming 0 is not a valid codepage
PVOID LastNlsTableBuffer = NULL;
CPTABLEINFO LastCPTableInfo;
UINT NlsTableUseCount = 0;

ULONG ulCharsetToCodePage(UINT);

/******************************Public*Routine******************************\
*
* vSort, N^2 alg, might want to replace by qsort
*
* Effects:
*
* Warnings:
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vSort(
    WCHAR *pwc,  // input buffer with a sorted array of cChar supported WCHAR's
     BYTE *pj,   // input buffer with original ansi values
      INT  cChar
    )
{
    INT i;

    for (i = 1; i < cChar; i++)
    {
    // upon every entry to this loop the array 0,1,..., (i-1) will be sorted

        INT j;
        WCHAR wcTmp = pwc[i];
        BYTE  jTmp  = pj[i];

        for (j = i - 1; (j >= 0) && (pwc[j] > wcTmp); j--)
        {
            pwc[j+1] = pwc[j];
            pj[j+1] = pj[j];
        }
        pwc[j+1] = wcTmp;
        pj[j+1]  = jTmp;
    }
}

/******************************Public*Routine******************************\
*
* cComputeGlyphSet
*
*   computes the number of contiguous ranges supported in a font.
*
*   Input is a sorted array (which may contain duplicates)
*   such as 1 1 1 2 3 4 5 7 8 9 10 10 11 12 etc
*   of cChar unicode code points that are
*   supported in a font
*
*   fills the FD_GLYPSET structure if the pgset buffer is provided
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

INT cComputeGlyphSet(
    WCHAR         *pwc,       // input buffer with a sorted array of cChar supported WCHAR's
    BYTE          *pj,        // input buffer with original ansi values
    INT           cChar,
    INT           cRuns,     // if nonzero, the same as return value
    FD_GLYPHSET  *pgset      // output buffer to be filled with cRanges runs
    )
{
    INT     iRun, iFirst, iFirstNext;
    HGLYPH  *phg, *phgEnd = NULL;
    BYTE    *pjTmp;

    if (pgset != NULL)
    {
        pgset->cjThis  = SZ_GLYPHSET(cRuns,cChar);

    // BUG, BUG

    // this line may seem confusing because 256 characters still fit in a byte
    // with values [0, 255]. The reason is that tt and ps fonts, who otherwise
    // would qualify as an 8 bit report bogus last and first char
    // (win31 compatibility) which confuses our engine.
    // tt and ps drivers therefore, for the purpose of computing glyphsets
    // of tt symbol fonts and ps fonts set firstChar to 0 and LastChar to 255.
    // For now we force such fonts through more general 16bit handle case
    // which does not rely on the fact that chFirst and chLast are correct

        pgset->flAccel = (cChar != 256) ? GS_8BIT_HANDLES : GS_16BIT_HANDLES;
        pgset->cRuns   = cRuns;

    // init the sum before entering the loop

        pgset->cGlyphsSupported = 0;

    // glyph handles are stored at the bottom, below runs:

        phg = (HGLYPH *) ((BYTE *)pgset + (offsetof(FD_GLYPHSET,awcrun) + cRuns * sizeof(WCRUN)));
    }

// now compute cRuns if pgset == 0 and fill the glyphset if pgset != 0

    for (iFirst = 0, iRun = 0; iFirst < cChar; iRun++, iFirst = iFirstNext)
    {
    // find iFirst corresponding to the next range.

        for (iFirstNext = iFirst + 1; iFirstNext < cChar; iFirstNext++)
        {
            if ((pwc[iFirstNext] - pwc[iFirstNext - 1]) > 1)
                break;
        }

        if (pgset != NULL)
        {
            pgset->awcrun[iRun].wcLow    = pwc[iFirst];

            pgset->awcrun[iRun].cGlyphs  =
                (USHORT)(pwc[iFirstNext-1] - pwc[iFirst] + 1);

            pgset->awcrun[iRun].phg      = phg;

        // now store the handles, i.e. the original ansi values

            phgEnd = phg + pgset->awcrun[iRun].cGlyphs;

            for (pjTmp = &pj[iFirst]; phg < phgEnd; phg++,pjTmp++)
            {
                *phg = (HGLYPH)*pjTmp;
            }

            pgset->cGlyphsSupported += pgset->awcrun[iRun].cGlyphs;
        }
    }

#if DBG
    if (pgset != NULL)
        ASSERTGDI(iRun == cRuns, "gdisrv! iRun != cRun\n");
#endif

    return iRun;
}

/******************************Public*Routine******************************\
*
* cUnicodeRangesSupported
*
* Effects:
*
* Warnings:
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

INT cUnicodeRangesSupported (
      INT  cp,         // code page, not used for now, the default system code page is used
      INT  iFirstChar, // first ansi char supported
      INT  cChar,      // # of ansi chars supported, cChar = iLastChar + 1 - iFirstChar
    WCHAR *pwc,        // input buffer with a sorted array of cChar supported WCHAR's
    BYTE  *pj
    )
{
    BYTE jFirst = (BYTE)iFirstChar;
    INT i;

    USHORT AnsiCodePage, OemCodePage;

    INT Result;

    ASSERTGDI((iFirstChar < 256) && (cChar <= 256),
              "gdisrvl! iFirst or cChar\n");

    //
    // fill the array with cCharConsecutive ansi values
    //

    for (i = 0; i < cChar; i++)
    {
        pj[i] = (BYTE)iFirstChar++;
    }

    // If the default code page is DBCS then use 1252, otherwise use
    // use the default code page
    //

    if (IS_ANY_DBCS_CODEPAGE(cp))
    {
    // Suppose we have a system without correspoding DBCS codepage installed.
    // We would still like to load this font.  But we will do so as CP 1252.
    // To do that try to translate one character using DBCS codepage and see if it
    // suceeds.

        if(EngMultiByteToWideChar(cp,&pwc[0],2,&pj[0],1) == -1)
        {
            WARNING("DBCS Codepage not installed using 1252\n");
            cp = 1252;
        }

        for(i = 0; i < cChar; i++)
        {
        // this is a shift-jis charset so we need special handling

            INT Result = EngMultiByteToWideChar(cp,&pwc[i],2,&pj[i],1);
#if DBG
            if (Result == -1) WARNING("gdisrvl! EngMultiByteToWideChar failed\n");
#endif

            if ((Result == -1) || (pwc[i] == 0 && pj[i] != 0))
            {
            // this must have been a DBCS lead byte so just return 0xFFFF or a failure
            // failure of EngMultiByteToWideChar could be cause by low memory condition

                pwc[i] = 0xFFFF;
            }
        }
    }
    else
    {
        if ((cp == CP_ACP) || (cp == CP_OEMCP))
        {
            RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

            if(IS_ANY_DBCS_CODEPAGE(AnsiCodePage))
            {
                AnsiCodePage = 1252;
            }
        }
        else
        {
            AnsiCodePage = (USHORT)cp;
        }

        Result = EngMultiByteToWideChar(AnsiCodePage,
                                        pwc,
                                        (ULONG)(cChar * sizeof(WCHAR)),
                                        (PCH) pj,
                                        (ULONG) cChar);

        ASSERTGDI(Result != -1, "gdisrvl! EngMultiByteToWideChar failed\n");
    }

    // now subtract the first char from all ansi values so that the
    // glyph handle is equal to glyph index, rather than to the ansi value

    for (i = 0; i < cChar; i++)
    {
        pj[i] -= (BYTE)jFirst;
    }

    // now sort out pwc array and permute pj array accordingly

    vSort(pwc,pj, cChar);

    //
    // compute the number of ranges
    //

    return cComputeGlyphSet (pwc,pj, cChar, 0, NULL);
}

/******************************Private*Routine******************************\
* pcpComputeGlyphset,
*
* Computes the FD_GLYPHSET struct based on chFirst and chLast.  If such a
* FD_GLYPHSET already exists in our global list of FD structs it updates
* the ref count for this FD_GLYPHSET in the global list points pcrd->pcp->pgset
* to it.  Otherwise it makes a new FD_GLYPHSET entry in the global list
* and points pcrd->pcp->pgset to it.
*
*  Thu 03-Dec-1992 -by- Bodin Dresevic [BodinD]
* update: redid them to make them usable in vtfd
*
* History:
*  24-July-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
*
\**************************************************************************/


CP_GLYPHSET *pcpComputeGlyphset(
    CP_GLYPHSET **pcpHead,  // head of the list
           UINT   uiFirst,
           UINT   uiLast,
           BYTE   jCharset
    )
{
    CP_GLYPHSET *pcpTmp;
    CP_GLYPHSET *pcpRet = NULL;

// First we need to see if a FD_GLYPHSET already exists for this first and
// last range.

    for( pcpTmp = *pcpHead;
         pcpTmp != NULL;
         pcpTmp = pcpTmp->pcpNext )
    {
        if((pcpTmp->uiFirstChar == uiFirst) &&
           (pcpTmp->jCharset == jCharset) &&
           (pcpTmp->uiLastChar == uiLast))
            break;
    }
    if( pcpTmp != NULL )
    {
    //
    // We found a match.
    //
        pcpTmp->uiRefCount +=1;

    //
    // We should never have so many references as to wrap around but if we ever
    // do we must fail the call.
    //
        if( pcpTmp->uiRefCount == 0 )
        {
            WARNING("BMFD!Too many references to glyphset\n");
            pcpRet = NULL;
        }
        else
        {
            pcpRet = pcpTmp;
        }
    }
    else
    {
    //
    // We need to allocate a new CP_GLYPHSET
    // For SYMBOL_CHARSET, it also needs to cover xf020 to xf0ff unicode range

        BYTE  aj[2*256-32];
        WCHAR awc[2*256-32];
        INT   cNumRuns;
        BOOL  isSymbol = FALSE;
        UINT  i,j;

        UINT  uiCodePage = (UINT)ulCharsetToCodePage(jCharset);
        UINT  cGlyphs = uiLast - uiFirst + 1;

    // use CP_ACP for SYMBOL_CHARSET

        if (uiCodePage == 42)
        {
            uiCodePage = CP_ACP;
            isSymbol = TRUE;
        }

        cNumRuns = cUnicodeRangesSupported(
            uiCodePage,
            uiFirst,
            cGlyphs,
            awc,aj);

        if (isSymbol)
        {
        // add range subset of a range [f020, f0ff]

            for (i = uiFirst, j = cGlyphs; i< (uiFirst+cGlyphs); i++)
            {
            // if i < 0x20, we do not report the glyph in f020-f0ff range, it has been reported already in the current code page range

                if (i >= 0x20)
                {
                    awc[j] = 0xf000 + i;
                    aj[j] = i - uiFirst;
                    j++;
                }
            }

        // make sure we resort if needed

            if (awc[cGlyphs-1] > 0xf020)
                vSort(awc,aj,j);

            if (cGlyphs != j)
            {
                cNumRuns++;
                cGlyphs = j;
            }
        }

        if ( (pcpTmp =  (CP_GLYPHSET*)
                (PALLOCNOZ((SZ_GLYPHSET(cNumRuns,cGlyphs) +
                               offsetof(CP_GLYPHSET,gset)),
                           'slgG'))
            ) == (CP_GLYPHSET*) NULL)
        {
            WARNING("BMFD!pcpComputeGlyphset memory allocation error.\n");
            pcpRet = NULL;
        }
        else
        {
            pcpTmp->uiRefCount = 1;
            pcpTmp->uiFirstChar = uiFirst;
            pcpTmp->uiLastChar = uiLast;
            pcpTmp->jCharset = jCharset;

        // Fill in the Glyphset structure

            cComputeGlyphSet(awc,aj, cGlyphs, cNumRuns, &pcpTmp->gset);

        // Insert at beginning of list

            pcpTmp->pcpNext = *pcpHead;
            *pcpHead = pcpTmp;

        // point CVTRESDATA to new CP_GLYPHSET

            pcpRet = pcpTmp;
        }
    }

    return pcpRet;
}

/***************************************************************************
 * vUnloadGlyphset( PCP pcpTarget )
 *
 * Decrements the ref count of a CP_GLYPHSET and unloads it from the global
 * list of CP_GLYPHSETS if the ref count is zero.
 *
 * IN
 *  PCP pcpTarget pointer to CP_GLYPHSET to be unloaded or decremented
 *
 *  History
 *
 *  Thu 03-Dec-1992 -by- Bodin Dresevic [BodinD]
 * update: redid them to make them usable in vtfd
 *
 *  7-25-92 Gerrit van Wingerden [gerritv]
 *  Wrote it.
 *
 ***************************************************************************/

VOID vUnloadGlyphset(
    CP_GLYPHSET **pcpHead,
    CP_GLYPHSET *pcpTarget
    )
{
    CP_GLYPHSET *pcpLast, *pcpCurrent;

    pcpCurrent = *pcpHead;
    pcpLast = NULL;

//
// Find the right CP_GLYPSHET
//
    while( 1 )
    {
        ASSERTGDI( pcpCurrent != NULL, "CP_GLYPHSET list problem.\n" );
        if(  pcpCurrent == pcpTarget )
            break;
        pcpLast = pcpCurrent;
        pcpCurrent = pcpCurrent->pcpNext;
    }

    if( --pcpCurrent->uiRefCount == 0 )
    {
    //
    // We need to deallocate and remove from list
    //
        if( pcpLast == NULL )
            *pcpHead = pcpCurrent->pcpNext;
        else
            pcpLast->pcpNext = pcpCurrent->pcpNext;

        VFREEMEM(pcpCurrent);
    }
}


PVOID __nw(unsigned int ui)
{
    DONTUSE(ui);
    RIP("Bogus __nw call");
    return(NULL);
}

VOID __dl(PVOID pv)
{
    DONTUSE(pv);
    RIP("Bogus __dl call");
}

// the definition of this variable is in ntgdi\inc\hmgshare.h

CHARSET_ARRAYS

/******************************Public*Routine******************************\
*
* ULONG ulCharsetToCodePage(UINT uiCharSet)
*
*
* Effects: figure out which code page to unicode translation table
*          should be used for this realization
*
* History:
*  31-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG ulCharsetToCodePage(UINT uiCharSet)
{
    int i;

    if (uiCharSet != OEM_CHARSET)
    {
        for (i = 0; i < NCHARSETS; i++)
        {
            if (charsets[i] == uiCharSet)
                return codepages[i];
        }

    // in case of some random charset
    // (this is likely an old bm or vecrot font) we will just use the current
    // global code page translation table. This is enough to ensure
    // the correct round trip: ansi->unicode->ansi

    // if CP_ACP is a DBCS code page then we better use 1252 to ensure
    // proper rountrip conversion

        return( gbDBCSCodePage ? 1252 : CP_ACP);

    }
    else // to make merced compiler happy
    {
        return CP_OEMCP;
    }

}

// inverse function

VOID vConvertCodePageToCharSet(WORD src, DWORD *pfsRet, BYTE *pjRet)
{
    UINT i;


    *pjRet = ANSI_CHARSET;
    *pfsRet = FS_LATIN1;

    for (i = 0; i < nCharsets; i++)
    {
        if ( codepages[i] == src )
        {
           // cs.ciACP      = src ;
           // cs.ciCharset  = charsets[i] ;

           *pfsRet = fs[i];
           *pjRet = (BYTE)charsets[i] ;

            break;
        }
    }
}

/****************************************************************************
 * LONG EngParseFontResources
 *
 * This routine takes a handle to a mapped image and returns an array of
 * pointers to the base of all the font resources in that image.
 *
 * Parameters
 *
 * HANDLE hFontFile -- Handle (really a pointer) to a FONTFILEVIEW
 *        image in which the fonts are to be found.
 * ULONG BufferSize -- Number of entries that ppvResourceBases can hold.
 * PVOID *ppvResourceBases -- Buffer to hold the array of pointers to font
 *        resources.  If NULL then only the number of resources is returned,
 *        and this value is ignored.
 *
 * Returns
 *
 * Number of font resources in the image or 0 if error or none.
 *
 * History
 *   7-3-95 Gerrit van Wingerden [gerritv]
 *   Wrote it.
 *
 ****************************************************************************/

PVOID EngFindResourceFD(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize);


ULONG cParseFontResources(
    HANDLE  hFontFile,
    PVOID  **ppvResourceBases)
{
    PIMAGE_DOS_HEADER pDosHeader;
    NTSTATUS Status;
    ULONG_PTR IdPath[ 1 ];
    INT i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PVOID pvImageBase;
    INT cEntries = 0;

    // Fail call if this is a bogus DOS image without an NE header.

    pDosHeader = (PIMAGE_DOS_HEADER)((PFONTFILEVIEW)hFontFile)->fv.pvViewFD;
    if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE &&
        (ULONG)(pDosHeader->e_lfanew) > ((PFONTFILEVIEW)hFontFile)->fv.cjView) {
        TRACE_FONT(("cParseFontResources: Cant map bogus DOS image files for fonts\n"));
        return 0;
    }

    // the LDR routines expect a one or'd in if this file mas mapped as an
    // image

    pvImageBase = (PVOID) (((ULONG_PTR) ((PFONTFILEVIEW) hFontFile)->fv.pvViewFD)|1);

    // Later on we'll call EngFindResource which expects a handle to FILEVIEW
    // struct.  It really just grabs the pvView field from the structure so
    // make sure that pvView field is the same place in both FILEVIEW and
    // FONTFILEVIEW structs


    IdPath[0] = 8;  // 8 is RT_FONT

    Status = LdrFindResourceDirectory_U(pvImageBase,
                                        IdPath,
                                        1,
                                        &ResourceDirectory);

    if (NT_SUCCESS( Status ))
    {
        // For now we'll assume that the only types of FONT entries will be Id
        // entries.  If for some reason this turns out not to be the case we'll
        // have to add more code (see windows\base\module.c) under the FindResource
        // function to get an idea how to do this.

        ASSERTGDI(ResourceDirectory->NumberOfNamedEntries == 0,
                  "EngParseFontResources: NamedEntries in font file.\n");

        *ppvResourceBases = (PVOID *) EngAllocMem(FL_ZERO_MEMORY,ResourceDirectory->NumberOfIdEntries * sizeof(PVOID *),'dfmB');

        if (*ppvResourceBases)
        {

            PVOID *ppvResource = *ppvResourceBases;

            cEntries = ResourceDirectory->NumberOfIdEntries;

            try
            {
                ResourceDirectoryEntry =
                  (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);

                for (i=0; i < cEntries ; ResourceDirectoryEntry++, i++ )
                {

                    DWORD dwSize;

                    *ppvResource = EngFindResourceFD(hFontFile,
                                                   ResourceDirectoryEntry->Id,
                                                   8, // RT_FONT
                                                   &dwSize );

                    if( *ppvResource++ == NULL )
                    {
                        WARNING("EngParseFontResources: EngFindResourceFailed\n");
                        cEntries = -1;
                        break;
                    }
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                cEntries = 0;
            }
        }
    }

    return(cEntries);

}

/*****************************************************************************\
* MakeSystemRelativePath
*
* Takes a path in X:\...\system32\.... format and makes it into
* \SystemRoot\System32 format so that KernelMode API's can recognize it.
*
* This will ensure security by forcing any image being loaded to come from
* the system32 directory.
*
* The AppendDLL flag indicates if the name should get .dll appended at the end
* (for display drivers coming from USER) if it's not already there.
*
\*****************************************************************************/

BOOL MakeSystemRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    )
{
    LPWSTR pOriginalEnd;
    ULONG OriginalLength = wcslen(pOriginalPath);
    ULONG cbLength = OriginalLength * sizeof(WCHAR) +
                     sizeof(L"\\SystemRoot\\System32\\");
    ULONG tmp;

    tmp = (sizeof(L".DLL") / sizeof (WCHAR) - 1);

    //
    // Given append = TRUE, we check if we really need to append.
    // (printer drivers with .dll come through LDEVREF which specifies TRUE)
    //

    if (bAppendDLL)
    {
        if ((OriginalLength >= tmp) &&
            (!_wcsnicmp(pOriginalPath + OriginalLength - tmp,
                       L".DLL",
                       tmp)))
        {
            bAppendDLL = FALSE;
        }
        else
        {
            cbLength += tmp * sizeof(WCHAR);
        }
    }

    pUnicode->Length = 0;
    pUnicode->MaximumLength = (USHORT) cbLength;

    if (pUnicode->Buffer = PALLOCNOZ(cbLength, 'liFG'))
    {
        //
        // First parse the input string for \System32\.  We parse from the end
        // of the string because some weirdo could have \System32\Nt\System32
        // as his/her root directory and this would throw us off if we scanned
        // from the front.
        //
        // It should only (and always) be printer drivers that pass down
        // fully qualified path names.
        //

        tmp = (sizeof(L"\\system32\\") / sizeof(WCHAR) - 1);


        for (pOriginalEnd = pOriginalPath + OriginalLength - tmp;
             pOriginalEnd >= pOriginalPath;
             pOriginalEnd --)
        {
            if (!_wcsnicmp(pOriginalEnd ,
                          L"\\system32\\",
                          tmp))
            {
                //
                // We found the system32 in the string.
                // Lets update the location of the string.
                //

                pOriginalPath = pOriginalEnd + tmp;

                break;
            }
        }

        //
        // Now put \SystemRoot\System32\ at the front of the name and append
        // the rest at the end
        //

        RtlAppendUnicodeToString(pUnicode, L"\\SystemRoot\\System32\\");
        RtlAppendUnicodeToString(pUnicode, pOriginalPath);

        if (bAppendDLL)
        {
            RtlAppendUnicodeToString(pUnicode, L".dll");
        }

        return (TRUE);
    }

    return (FALSE);
}

/*****************************************************************************\
* MakeSystemDriversRelativePath
*
* Takes a path in X:\...\system32\.... format and makes it into
* \SystemRoot\System32\Drivers format so that KernelMode API's can recognize it.
*
* This will ensure security by forcing any image being loaded to come from
* the system32 directory.
*
* The AppendDLL flag indicates if the name should get .dll appended at the end
* (for display drivers coming from USER) if it's not already there.
*
\*****************************************************************************/

BOOL MakeSystemDriversRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    )
{
    LPWSTR pOriginalEnd;
    ULONG OriginalLength = wcslen(pOriginalPath);
    ULONG cbLength = OriginalLength * sizeof(WCHAR) +
                     sizeof(L"\\SystemRoot\\System32\\Drivers");
    ULONG tmp;

    tmp = (sizeof(L".DLL") / sizeof (WCHAR) - 1);

    //
    // Given append = TRUE, we check if we really need to append.
    // (printer drivers with .dll come through LDEVREF which specifies TRUE)
    //

    if (bAppendDLL)
    {
        if ((OriginalLength >= tmp) &&
            (!_wcsnicmp(pOriginalPath + OriginalLength - tmp,
                       L".DLL",
                       tmp)))
        {
            bAppendDLL = FALSE;
        }
        else
        {
            cbLength += tmp * sizeof(WCHAR);
        }
    }

    pUnicode->Length = 0;
    pUnicode->MaximumLength = (USHORT) cbLength;

    if (pUnicode->Buffer = PALLOCNOZ(cbLength, 'liFG'))
    {
        //
        // First parse the input string for \System32\Drivers. We parse from the end
        // of the string because some weirdo could have \System32\Nt\System32
        // as his/her root directory and this would throw us off if we scanned
        // from the front.
        //
        // It should only (and always) be printer drivers that pass down
        // fully qualified path names.
        //

        tmp = (sizeof(L"\\system32\\Drivers") / sizeof(WCHAR) - 1);


        for (pOriginalEnd = pOriginalPath + OriginalLength - tmp;
             pOriginalEnd >= pOriginalPath;
             pOriginalEnd --)
        {
            if (!_wcsnicmp(pOriginalEnd ,
                          L"\\system32\\Drivers",
                          tmp))
            {
                //
                // We found the system32 in the string.
                // Lets update the location of the string.
                //

                pOriginalPath = pOriginalEnd + tmp;

                break;
            }
        }

        //
        // Now put \SystemRoot\System32\Drivers\ at the front of the name and append
        // the rest at the end
        //

        RtlAppendUnicodeToString(pUnicode, L"\\SystemRoot\\System32\\Drivers\\");
        RtlAppendUnicodeToString(pUnicode, pOriginalPath);

        if (bAppendDLL)
        {
            RtlAppendUnicodeToString(pUnicode, L".dll");
        }

        return (TRUE);
    }

    return (FALSE);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetFilePath
*
\**************************************************************************/

BOOL EngGetFilePath(HANDLE h, WCHAR (*pDest)[MAX_PATH+1])
{
    wchar_t *pSrc = ((PFONTFILEVIEW) h)->pwszPath;

    if ( pSrc )
    {
        wcscpy((wchar_t*) pDest, pSrc );
    }
    return( pSrc != 0 );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetFileChangeTime
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

BOOL EngGetFileChangeTime(
    HANDLE          h,
    LARGE_INTEGER   *pChangeTime)
{

    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_BASIC_INFORMATION fileBasicInfo;
    PVOID sectionObject = NULL;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) h;
    ULONG viewSize;

    if(pffv->pwszPath)
    {
        if (pffv->fv.bLastUpdated)
        {
            *pChangeTime = pffv->fv.LastWriteTime;
            bResult = TRUE;
        }
        else
        {
            RtlInitUnicodeString(&unicodeString,
                                 pffv->pwszPath
                                 );


            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       (HANDLE) NULL,
                                       (PSECURITY_DESCRIPTOR) NULL);

            ntStatus = ZwCreateFile(&fileHandle,
                                    FILE_READ_ATTRIBUTES,
                                    &objectAttributes,
                                    &ioStatusBlock,
                                    0,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0,
                                    FILE_OPEN_IF,
                                    FILE_SYNCHRONOUS_IO_ALERT,
                                    0,
                                    0);


            if(NT_SUCCESS(ntStatus))
            {
                ntStatus = ZwQueryInformationFile(fileHandle,
                                                  &ioStatusBlock,
                                                  &fileBasicInfo,
                                                  sizeof(FILE_BASIC_INFORMATION),
                                                  FileBasicInformation);

                if (NT_SUCCESS(ntStatus))
                {
                    *pChangeTime = fileBasicInfo.LastWriteTime;
                    bResult = TRUE;
                }
                else
                {
                    WARNING("EngGetFileTime:QueryInformationFile failed\n");
                }

                ZwClose(fileHandle);

            }
            else
            {
                WARNING("EngGetFileTime:Create/Open file failed\n");
            }
        }
    }
    else
    {
    // This is a remote font.  In order for ATM to work we must always return
    // the same time for a remote font.  One way to do this is to return a zero
    // time for all remote fonts.

        pChangeTime->HighPart = pChangeTime->LowPart = 0;
        bResult = TRUE;
    }

    return(bResult);
}

/*******************************************************************************
*  EngFindResource
*
*   This function returns a size and ptr to a resource in a module.
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

PVOID pvFindResource(
    PVOID  pView,
    PVOID  pViewEnd,
    int    iName,
    int    iType,
    PULONG pulSize)
{
    NTSTATUS Status;
    PVOID p,pRet;
    ULONG_PTR IdPath[ 3 ];

    IdPath[0] = (ULONG_PTR) iType;
    IdPath[1] = (ULONG_PTR) iName;
    IdPath[2] = (ULONG_PTR) 0;

// add one to pvView to let LdrFindResource know that this has been mapped as a
// datafile

    Status = LdrFindResource_U( pView,
                                IdPath,
                                3,
                                (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                              );

    if( !NT_SUCCESS( Status ) )
    {

        WARNING("EngFindResource: LdrFindResource_U failed.\n");
        return(NULL);
    }

    pRet = NULL;

    Status = LdrAccessResource( pView,
                                (PIMAGE_RESOURCE_DATA_ENTRY) p,
                                &pRet,
                                pulSize );

    if( !NT_SUCCESS( Status ) )
    {
        WARNING("EngFindResource: LdrAccessResource failed.\n" );
    }

    return( pRet < pViewEnd ? pRet : NULL );

}


PVOID EngFindResource(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize)
{

    PVOID pView,pViewEnd;

    pView = (PVOID) (((ULONG_PTR) ((PFILEVIEW) h)->pvKView)+1);
    pViewEnd = (PVOID) ((PBYTE)((PFILEVIEW) h)->pvKView + ((PFILEVIEW) h)->cjView);

    return pvFindResource(pView, pViewEnd, iName, iType, pulSize);
}

PVOID EngFindResourceFD(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize)
{

    PVOID pView,pViewEnd;

    pView = (PVOID) (((ULONG_PTR) ((PFILEVIEW) h)->pvViewFD)+1);
    pViewEnd = (PVOID) ((PBYTE)((PFILEVIEW) h)->pvViewFD + ((PFILEVIEW) h)->cjView);

    return pvFindResource(pView, pViewEnd, iName, iType, pulSize);
}


/******************************Public*Routine******************************\
*
* VOID vCheckCharSet(USHORT * pusCharSet)
*
*
* Effects: validate charset in font sub section of the registry
*
* History:
*  27-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCheckCharSet(FACE_CHARSET *pfcs, WCHAR * pwsz)
{
    UINT           i;
    UNICODE_STRING String;
    ULONG          ulCharSet = DEFAULT_CHARSET;

    pfcs->jCharSet = DEFAULT_CHARSET;
    pfcs->fjFlags  = 0;

    String.Buffer = pwsz;
    String.MaximumLength = String.Length = wcslen(pwsz) * sizeof(WCHAR);

// read the value and compare it against the allowed set of values, if
// not found to be correct return default

    if (RtlUnicodeStringToInteger(&String, 10, &ulCharSet) == STATUS_SUCCESS)
    {
        if (ulCharSet <= 255)
        {
            pfcs->jCharSet = (BYTE)ulCharSet;

            for (i = 0; i < nCharsets; i++)
            {
                if (ulCharSet == charsets[i])
                {
                // both jCharSet and fjFlags are set correctly, can exit

                    return;
                }
            }
        }
    }

// If somebody entered the garbage in the Font Substitution section of "win.ini"
// we will mark this as a "garbage charset" by setting the upper byte in the
// usCharSet field. I believe that it is Ok to have garbage charset in the
// value name, that is on the left hand side of the substitution entry.
// This may be whatever garbage the application is passing to the
// system. But the value on the right hand side, that is in value data, has to
// be meaningfull, for we need to know which code page translation table
// we should use with this font.

    pfcs->fjFlags |= FJ_GARBAGECHARSET;
}

/******************************Public*Routine******************************\
*
*   EngComputeGlyphSet
*
\**************************************************************************/

FD_GLYPHSET *EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )
{
           BYTE *cbuf;
            INT  cRuns;
          ULONG  ByteCount;
          WCHAR *wcbuf;
    FD_GLYPHSET *pGlyphSet = 0;

    if ( 0 <= cChars && cChars < 65536 )
    {
        wcbuf = (WCHAR *) PALLOCMEM(cChars * (sizeof(WCHAR) + sizeof(BYTE)),'slgG');
        if ( wcbuf )
        {
            cbuf = (BYTE *) &wcbuf[cChars];

            cRuns = cUnicodeRangesSupported(
                        nCodePage,
                        nFirstChar,
                        cChars,
                        wcbuf,
                        cbuf);

            ByteCount = SZ_GLYPHSET(cRuns, cChars);

        // Allocate via EngAllocMem instead of PALLOCMEM because driver
        // will free via EngAllocFree.

            pGlyphSet = (FD_GLYPHSET*) EngAllocMem(0, ByteCount,'slgG');

            if ( pGlyphSet )
            {
                cComputeGlyphSet(
                    wcbuf,
                    cbuf,
                    cChars,
                    cRuns,
                    pGlyphSet
                    );
            }
            VFREEMEM( wcbuf );
        }
    }

    return( pGlyphSet );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vMoveFD_GLYPHSET
*
* Routine Description:
*
*   Copies an FD_GLYPHSET from one location to another. The pointers
*   in the destination are fixed up.
*
* Arguments:
*
*   pgsDst  pointer to destination FD_GLYPHSET
*
*   pgsSrc  pointer to source FD_GLYPHSET
*
* Called by:
*
*   bComputeGlyphSet
*
* Return Value:
*
*   none
*
\**************************************************************************/

void vMoveFD_GLYPHSET(FD_GLYPHSET *pgsDst, FD_GLYPHSET *pgsSrc)
{
    char *pSrc, *pSrcLast, *pDst;
    ULONG_PTR dp;

    //
    // move the structure
    //

    RtlCopyMemory(pgsDst, pgsSrc, pgsSrc->cjThis);

    //
    // if necessary, fix up the pointers
    //

    if (!(pgsSrc->flAccel & GS_UNICODE_HANDLES ))
    {
        pSrc     = (char*) &pgsSrc->awcrun[0].phg;
        pDst     = (char*) &pgsDst->awcrun[0].phg;
        pSrcLast = pSrc + sizeof(WCRUN) * pgsSrc->cRuns;
        dp = pDst - pSrc;
        for ( ; pSrc < pSrcLast; pSrc += sizeof(WCRUN), pDst += sizeof(WCRUN))
        {
            *(char**)pDst = *(char**)pSrc + dp;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bComputeGlyphSet
*
* Routine Description:
*
*   This procedure provides safe access to GreComputeGlyphSet from user
*   mode. All addresses supplied by the caller, except for pCall, are
*   probed and access is surrounded by try/except pairs.
*
* Arguments:
*
*   pCall       a pointer to a GDICALL structure in kernel mode. This is
*               a copy of the user mode structure passed to NtGdiCall.
*
* Called by:
*
*   NtGdiCall
*
* Return Value:
*
\**************************************************************************/

BOOL bComputeGlyphSet(GDICALL *pCall)
{
    extern VOID vMoveFD_GLYPHSET( FD_GLYPHSET *pDst, FD_GLYPHSET *pSrc);
    static FD_GLYPHSET *pGlyphSet;

    ASSERTGDI(pCall->Id == ComputeGlyphSet_,"pCall->Id == ComputeGlyphSet_\n");

    pCall->ComputeGlyphSetArgs.ReturnValue = FALSE;

    if ( pCall->ComputeGlyphSetArgs.ppGlyphSet == 0 )
    {
        if ( pCall->ComputeGlyphSetArgs.ByteCount == 0 )
        {
            if ( pGlyphSet == 0 )
            {
                pGlyphSet =
                    EngComputeGlyphSet(
                        pCall->ComputeGlyphSetArgs.nCodePage,
                        pCall->ComputeGlyphSetArgs.nFirstChar,
                        pCall->ComputeGlyphSetArgs.cChars
                        );
                if ( pGlyphSet )
                {
                    pCall->ComputeGlyphSetArgs.ppGlyphSet  = &pGlyphSet;
                    pCall->ComputeGlyphSetArgs.ByteCount   = pGlyphSet->cjThis;
                    pCall->ComputeGlyphSetArgs.ReturnValue = TRUE;
                }
            }
            else
            {
                VFREEMEM( pGlyphSet );
                pGlyphSet = 0;
            }
        }
    }
    else if (pCall->ComputeGlyphSetArgs.ppGlyphSet == &pGlyphSet && pGlyphSet != 0)
    {
        pCall->ComputeGlyphSetArgs.ReturnValue = TRUE;
        try
        {
            ProbeForWrite(
                pCall->ComputeGlyphSetArgs.pGlyphSet
              , pGlyphSet->cjThis
              , 8
              );
            vMoveFD_GLYPHSET(
                pCall->ComputeGlyphSetArgs.pGlyphSet
              , pGlyphSet
                );
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            pCall->ComputeGlyphSetArgs.ReturnValue = FALSE;
        }
        VFREEMEM( pGlyphSet );
        pGlyphSet = 0;
    }

    return( pCall->ComputeGlyphSetArgs.ReturnValue );
}


#define NLS_TABLE_KEY \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage"

BOOL GetNlsTablePath(
    UINT CodePage,
    PWCHAR PathBuffer
)
/*++

Routine Description:

  This routine takes a code page identifier, queries the registry to find the
  appropriate NLS table for that code page, and then returns a path to the
  table.

Arguments;

  CodePage - specifies the code page to look for

  PathBuffer - Specifies a buffer into which to copy the path of the NLS
    file.  This routine assumes that the size is at least MAX_PATH

Return Value:

  TRUE if successful, FALSE otherwise.

Gerrit van Wingerden [gerritv] 1/22/96

--*/
{
    NTSTATUS NtStatus;
    BOOL Result = FALSE;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        WCHAR *ResultBuffer;
        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH +
          sizeof(KEY_VALUE_FULL_INFORMATION);

        ResultBuffer = PALLOCMEM(BufferSize,'slnG');

        if(ResultBuffer)
        {
            ULONG ValueReturnedLength;
            WCHAR CodePageStringBuffer[20];
            swprintf(CodePageStringBuffer, L"%d", CodePage);

            RtlInitUnicodeString(&UnicodeString,CodePageStringBuffer);

            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) ResultBuffer;

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {

                swprintf(PathBuffer,L"\\SystemRoot\\System32\\%ws",
                         &(KeyValueInformation->Data[0]));
                Result = TRUE;
            }
            else
            {
                WARNING("GetNlsTablePath failed to get NLS table\n");
            }
            VFREEMEM(ResultBuffer);
        }
        else
        {
            WARNING("GetNlsTablePath out of memory\n");
        }

        ZwCloseKey(RegistryKeyHandle);
    }
    else
    {
        WARNING("GetNlsTablePath failed to open NLS key\n");
    }

    return(Result);
}


INT ConvertToAndFromWideCharSymCP(
    IN LPWSTR WideCharString,
    IN INT BytesInWideCharString,
    IN LPSTR MultiByteString,
    IN INT BytesInMultiByteString,
    IN BOOL ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a SB character string to or from a wide char string
  assuming the CP_SYMBOL code page. We simply using the following rules to map
  the single byte char to Unicode:
    0x00->0x1f map to 0x0000->0x001f
    0x20->0xff map to 0xf020->0xf0ff

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Tessiew [Xudong Wu]  Sept/25/97

-- */
{
    INT  cSB, cMaxSB, cWC, cMaxWC;

    if ((BytesInWideCharString && (WideCharString == NULL)) ||
        (BytesInMultiByteString && (MultiByteString == NULL)))
    {
        return 0;
    }

    if (ConvertToWideChar)
    {
        cMaxSB = MIN(BytesInMultiByteString, BytesInWideCharString / (INT)sizeof(WCHAR));

        for (cSB = 0; cSB < cMaxSB; cSB++)
        {
            WideCharString[cSB] = ((BYTE)MultiByteString[cSB] < 0x20) ?
                                    (WCHAR)MultiByteString[cSB] :
                                    (WCHAR)((BYTE)MultiByteString[cSB] | ((WCHAR)(0xf0) << 8));
        }
        return (cMaxSB * sizeof(WCHAR));
    }
    else
    {
        cMaxWC = MIN(BytesInWideCharString / (INT)sizeof(WCHAR), BytesInMultiByteString);

        for (cWC = 0; cWC < cMaxWC; cWC++)
        {
            // there is some error wchar in the string
            // but we still return however many we finished

            if ((WideCharString[cWC] >= 0x0020) &&
                ((WideCharString[cWC] < 0xf020) ||
                 (WideCharString[cWC] > 0xf0ff)))
            {
                return (cWC);
            }

            MultiByteString[cWC] = (BYTE)WideCharString[cWC];
        }

        return (cMaxWC);
    }
}


INT ConvertToAndFromWideChar(
    IN UINT CodePage,
    IN LPWSTR WideCharString,
    IN INT BytesInWideCharString,
    IN LPSTR MultiByteString,
    IN INT BytesInMultiByteString,
    IN BOOL ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a character string to or from a wide char string
  assuming a specified code page.  Most of the actual work is done inside
  RtlCustomCPToUnicodeN, but this routine still needs to manage the loading
  of the NLS files before passing them to the RtlRoutine.  We will cache
  the mapped NLS file for the most recently used code page which ought to
  suffice for out purposes.

Arguments:
  CodePage - the code page to use for doing the translation.

  WideCharString - buffer the string is to be translated into.

  BytesInWideCharString - number of bytes in the WideCharString buffer
    if converting to wide char and the buffer isn't large enough then the
    string in truncated and no error results.

  MultiByteString - the multibyte string to be translated to Unicode.

  BytesInMultiByteString - number of bytes in the multibyte string if
    converting to multibyte and the buffer isn't large enough the string
    is truncated and no error results

  ConvertToWideChar - if TRUE then convert from multibyte to widechar
    otherwise convert from wide char to multibyte

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Gerrit van Wingerden [gerritv] 1/22/96

--*/
{
    NTSTATUS NtStatus;
    USHORT OemCodePage, AnsiCodePage;
    CPTABLEINFO LocalTableInfo;
    PCPTABLEINFO TableInfo = NULL;
    PVOID LocalTableBase = NULL;
    INT BytesConverted = 0;

    ASSERTGDI(CodePage != 0, "EngMultiByteToWideChar invalid code page\n");

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    // see if we can use the default translation routinte

    if(AnsiCodePage == CodePage)
    {
        if(ConvertToWideChar)
        {
            NtStatus = RtlMultiByteToUnicodeN(WideCharString,
                                              BytesInWideCharString,
                                              &BytesConverted,
                                              MultiByteString,
                                              BytesInMultiByteString);
        }
        else
        {
            NtStatus = RtlUnicodeToMultiByteN(MultiByteString,
                                              BytesInMultiByteString,
                                              &BytesConverted,
                                              WideCharString,
                                              BytesInWideCharString);
        }


        if(NT_SUCCESS(NtStatus))
        {
            return(BytesConverted);
        }
        else
        {
            return(-1);
        }
    }

    if (CodePage == CP_SYMBOL)
    {
        return (ConvertToAndFromWideCharSymCP(WideCharString, BytesInWideCharString,
                    MultiByteString, BytesInMultiByteString, ConvertToWideChar));
    }

    TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 006\n")); GreAcquireFastMutex(ghfmMemory);

    if(CodePage == LastCodePageTranslated)
    {
        // we can use the cached code page information
        TableInfo = &LastCPTableInfo;
        NlsTableUseCount += 1;
    }

    GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 006\n"));

    if(TableInfo == NULL)
    {
        // get a pointer to the path of the NLS table

        WCHAR NlsTablePath[MAX_PATH];

        if(GetNlsTablePath(CodePage,NlsTablePath))
        {
            UNICODE_STRING UnicodeString;
            IO_STATUS_BLOCK IoStatus;
            HANDLE NtFileHandle;
            OBJECT_ATTRIBUTES ObjectAttributes;

            RtlInitUnicodeString(&UnicodeString,NlsTablePath);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            NtStatus = ZwCreateFile(&NtFileHandle,
                                    SYNCHRONIZE | FILE_READ_DATA,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0);

            if(NT_SUCCESS(NtStatus))
            {
                FILE_STANDARD_INFORMATION StandardInfo;

                // Query the object to determine its length.

                NtStatus = ZwQueryInformationFile(NtFileHandle,
                                                  &IoStatus,
                                                  &StandardInfo,
                                                  sizeof(FILE_STANDARD_INFORMATION),
                                                  FileStandardInformation);

                if(NT_SUCCESS(NtStatus) && StandardInfo.EndOfFile.LowPart)
                {
                    UINT LengthOfFile = StandardInfo.EndOfFile.LowPart;

                    LocalTableBase = PALLOCMEM(LengthOfFile,'cwcG');

                    if(LocalTableBase)
                    {
                        // Read the file into our buffer.

                        NtStatus = ZwReadFile(NtFileHandle,
                                              NULL,
                                              NULL,
                                              NULL,
                                              &IoStatus,
                                              LocalTableBase,
                                              LengthOfFile,
                                              NULL,
                                              NULL);

                        if(!NT_SUCCESS(NtStatus))
                        {
                            WARNING("EngMultiByteToWideChar unable to read file\n");
                            VFREEMEM(LocalTableBase);
                            LocalTableBase = NULL;
                        }
                    }
                    else
                    {
                        WARNING("EngMultiByteToWideChar out of memory\n");
                    }
                }
                else
                {
                    WARNING("EngMultiByteToWideChar unable query NLS file\n");
                }

                ZwClose(NtFileHandle);
            }
            else
            {
                WARNING("EngMultiByteToWideChar unable to open NLS file\n");
            }
        }
        else
        {
            WARNING("EngMultiByteToWideChar get registry entry for NLS file failed\n");
        }

        if(LocalTableBase == NULL)
        {
            return(-1);
        }

        // now that we've got the table use it to initialize the CodePage table

        RtlInitCodePageTable(LocalTableBase,&LocalTableInfo);
        TableInfo = &LocalTableInfo;
    }

    // Once we are here TableInfo points to the the CPTABLEINFO struct we want


    if(ConvertToWideChar)
    {
        NtStatus = RtlCustomCPToUnicodeN(TableInfo,
                                         WideCharString,
                                         BytesInWideCharString,
                                         &BytesConverted,
                                         MultiByteString,
                                         BytesInMultiByteString);
    }
    else
    {
        NtStatus = RtlUnicodeToCustomCPN(TableInfo,
                                         MultiByteString,
                                         BytesInMultiByteString,
                                         &BytesConverted,
                                         WideCharString,
                                         BytesInWideCharString);
    }


    if(!NT_SUCCESS(NtStatus))
    {
        // signal failure

        BytesConverted = -1;
    }


    // see if we need to update the cached CPTABLEINFO information

    if(TableInfo != &LocalTableInfo)
    {
        // we must have used the cached CPTABLEINFO data for the conversion
        // simple decrement the reference count

        TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 007\n")); GreAcquireFastMutex(ghfmMemory);
        NlsTableUseCount -= 1;
        GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 007\n"));
    }
    else
    {
        PVOID FreeTable;

        // we must have just allocated a new CPTABLE structure so cache it
        // unless another thread is using current cached entry

        TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 008\n")); GreAcquireFastMutex(ghfmMemory);
        if(!NlsTableUseCount)
        {
            LastCodePageTranslated = CodePage;
            RtlMoveMemory(&LastCPTableInfo, TableInfo, sizeof(CPTABLEINFO));
            FreeTable = LastNlsTableBuffer;
            LastNlsTableBuffer = LocalTableBase;
        }
        else
        {
            FreeTable = LocalTableBase;
        }
        GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 008\n"));

        // Now free the memory for either the old table or the one we allocated
        // depending on whether we update the cache.  Note that if this is
        // the first time we are adding a cached value to the local table, then
        // FreeTable will be NULL since LastNlsTableBuffer will be NULL

        if(FreeTable)
        {
            VFREEMEM(FreeTable);
        }
    }

    // we are done

    return(BytesConverted);
}

VOID EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    )
{
    RtlGetDefaultCodePage(AnsiCodePage,OemCodePage);
}

INT EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return(ConvertToAndFromWideChar(CodePage,
                                    WideCharString,
                                    BytesInWideCharString,
                                    MultiByteString,
                                    BytesInMultiByteString,
                                    TRUE));
}

INT APIENTRY EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return(ConvertToAndFromWideChar(CodePage,
                                    WideCharString,
                                    BytesInWideCharString,
                                    MultiByteString,
                                    BytesInMultiByteString,
                                    FALSE));
}

/******************************Public*Routine******************************\
* BOOL EngDeleteFile
*
* Delete a file.
*
* Parameters
*     IN pwszFileName - Name of the file to be deleted
*
* Return Value
*     TRUE - sucess
*     FALSE - fail
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

BOOL EngDeleteFile (
    PWSZ  pwszFileName
)
{
    UNICODE_STRING    unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS          ntStatus;
    BOOL              bRet = TRUE;

    RtlInitUnicodeString(&unicodeString,
                         pwszFileName);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwDeleteFile (&objectAttributes);

    if (ntStatus != STATUS_SUCCESS)
    {
        WARNING ("EngDeleteFile failed \n");
        bRet = FALSE;
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL EngQueryFileTimeStamp
*
* Query a file timetimep.
*
* Parameters
*     IN pwsz - Name of the file
*
* Return Value
*     Timestamp
*
* History:
*  22-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

LARGE_INTEGER EngQueryFileTimeStamp (
    PWSZ  pwsz
)
{
    HANDLE FileHandle;
    UNICODE_STRING    unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK  IoStatusBlock;
    NTSTATUS   ntStatus;
    LARGE_INTEGER SystemTime, LocalTime;
    FILE_BASIC_INFORMATION File_Info;

    SystemTime.QuadPart = 0;
    LocalTime.QuadPart = 0;

    RtlInitUnicodeString(&unicodeString,
                         pwsz
                         );


    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenFile(&FileHandle,
                          FILE_GENERIC_READ,
                          &objectAttributes,
                          &IoStatusBlock,
                          FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                          FILE_SYNCHRONOUS_IO_ALERT);

    if(!NT_SUCCESS(ntStatus))
    {
        WARNING("fail to get handle of file file\n");
    }

    ntStatus = ZwQueryInformationFile (FileHandle,
                              &IoStatusBlock,
                              &File_Info,
                              sizeof(FILE_BASIC_INFORMATION),
                              FileBasicInformation
                              );

    if (ntStatus != STATUS_SUCCESS)
    {
         WARNING("failed queryinformationfile\n");
         return (LocalTime);
    }

    ZwClose (FileHandle);

    SystemTime = File_Info.LastWriteTime;

    GreSystemTimeToLocalTime(&SystemTime, &LocalTime);

    return(LocalTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\misc.cxx ===
/******************************Module*Header*******************************\
* Module Name: MISC.CXX                                                   *
*                                                                         *
* _HYDRA_  routines                                                         *
*                                                                         *
* Copyright (c) 1997-1999 Microsoft                                            *
\**************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

BOOL G_fDoubleDpi = FALSE;
BOOL G_fConsole = TRUE;
PFILE_OBJECT G_RemoteVideoFileObject = NULL;
PFILE_OBJECT G_RemoteConnectionFileObject = NULL;
HANDLE G_RemoteConnectionChannel = NULL;
PBYTE G_PerformanceStatistics = NULL;
LPWSTR G_DisplayDriverNames = L"vgastub\0";



PFILE_OBJECT G_SaveRemoteVideoFileObject = NULL;
PFILE_OBJECT G_SaveRemoteConnectionFileObject = NULL;
HANDLE G_SaveRemoteConnectionChannel = NULL;
PBYTE G_SavePerformanceStatistics = NULL;


/******************************Exported*Routine****************************\
*
* GreConsoleShadowStart( )
*
*
* Saves remote channel handles and swicth to channel handles for Console Shadow
*
\**************************************************************************/

BOOL GreConsoleShadowStart( HANDLE hRemoteConnectionChannel,
                           PBYTE pPerformanceStatistics,
                           PFILE_OBJECT pVideoFile,
                           PFILE_OBJECT pRemoteConnectionFileObject
                            )
{

    G_SaveRemoteVideoFileObject = G_RemoteVideoFileObject;
    G_SaveRemoteConnectionFileObject = G_RemoteConnectionFileObject;
    G_SavePerformanceStatistics = G_PerformanceStatistics;
    G_SaveRemoteConnectionChannel = G_RemoteConnectionChannel;

    
    G_RemoteVideoFileObject = pVideoFile;
    G_RemoteConnectionFileObject = pRemoteConnectionFileObject;
    G_PerformanceStatistics = pPerformanceStatistics;
    G_RemoteConnectionChannel = hRemoteConnectionChannel;

    return TRUE;
}


/******************************Exported*Routine****************************\
*
* GreConsoleShadowStop( )
*
*
* Restores remote channel handles after Console Shadow
*
\**************************************************************************/

BOOL GreConsoleShadowStop( VOID )
{

    
    G_RemoteVideoFileObject = G_SaveRemoteVideoFileObject;
    G_RemoteConnectionFileObject = G_SaveRemoteConnectionFileObject;
    G_PerformanceStatistics = G_SavePerformanceStatistics;
    G_RemoteConnectionChannel = G_SaveRemoteConnectionChannel;

    return TRUE;
}





/******************************Exported*Routine****************************\
*
* GreMultiUserInitSession( )
*
*
* Initialize the multi-user session gre library
*
\**************************************************************************/

BOOL GreMultiUserInitSession( HANDLE hRemoteConnectionChannel,
                           PBYTE pPerformanceStatistics,
                           PFILE_OBJECT pVideoFile,
                           PFILE_OBJECT pRemoteConnectionFileObject,
                           ULONG DisplayDriverNameLength,
                           PWCHAR DisplayDriverName
                            )
{
    BOOL bRet = FALSE;

    G_RemoteVideoFileObject = pVideoFile;
    G_RemoteConnectionFileObject = pRemoteConnectionFileObject;
    G_PerformanceStatistics = pPerformanceStatistics;
    G_RemoteConnectionChannel = hRemoteConnectionChannel;

    G_DisplayDriverNames = (LPWSTR)GdiAllocPool(
                            (DisplayDriverNameLength + 1) * sizeof(WCHAR),
                            'yssU');

    if (G_DisplayDriverNames)
    {
        wcsncpy(G_DisplayDriverNames, DisplayDriverName, DisplayDriverNameLength + 1);
        bRet = TRUE;
    }

    return bRet;
}

/******************************Exported*Routine****************************\
* HDXDrvEscape( hdev, iEsc, pInbuffer, cbInbuffer )
*
* Tell the TShare display driver to perform the specified operation.
*
* hdev (input)
*   Identifies the device
*
* iEsc (input)
*   Specifies the Operation to be performed
*
*       ESC_FLUSH_FRAME_BUFFER      Flush the frame buffer
*       ESC_SET_WD_TIMEROBJ         Pass the timer object to the WD
*
* pInbuffer (input)
*   Data buffer
*
* cbInbuffer (input)
*   Data buffer length
*
\**************************************************************************/

BOOL HDXDrvEscape( HDEV hdev, ULONG iEsc, PVOID pInbuffer, ULONG cbInbuffer )
{
    BOOL Result;
    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver to perform the specified operation
        //
        if ( PPFNVALID(po,Escape) )
        Result = (*PPFNDRV(po,Escape))(&po.pSurface()->so, iEsc, cbInbuffer, pInbuffer, 0, NULL );
        else
            Result = TRUE;
    }
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(Result);
}

/******************************Exported*Routine****************************\
*
* bDrvReconnect( hDev, RemoteConnectionChannel )
*
* This is done for reconnects.
*
* Notify the display driver of a new connection (not a shadow connection)
*
* hdev (input)
*   Identifies device to be connected
* RemoteConnectionChannel (input)
*   Remote channel handle
* pRemoteConnectionFileObject (input)
*   Remote connection channel file object
*
\**************************************************************************/

BOOL bDrvReconnect( HDEV hdev,
                    HANDLE RemoteConnectionChannel,
                    PFILE_OBJECT pRemoteConnectionFileObject,
                    BOOL bSetPalette )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver connect function (if defined)
        //

        if ( PPFNVALID(po,Reconnect) )
            Result = (*PPFNDRV(po,Reconnect))( RemoteConnectionChannel, pRemoteConnectionFileObject );
        else
            Result = TRUE;

        if ( bSetPalette == TRUE ) {

            //
            // Set the palette
            //

            XEPALOBJ pal(po.ppalSurf());
            ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

            if ((Result == TRUE) && pal.bIsPalManaged())
            {
                ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

                (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                          (PALOBJ *) &pal,
                                          0,
                                          0,
                                          pal.cEntries());
            }
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* bDrvDisconnect(hdev)
*
* Notify the display driver that the connection is going away.
* This is the primary connection.
*
* hdev (input)
*   Identifies device to be disabled
*
* RemoteConnectionChannel (input)
*   Channel being disconnected
*
* pRemoteConnectionFileObject (input)
*   File object pointer to Channel being disconnected
*
\**************************************************************************/

BOOL bDrvDisconnect( HDEV hdev, HANDLE RemoteConnectionChannel, PFILE_OBJECT pRemoteConnectionFileObject )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver disconnect function (if defined)
        //

        if ( PPFNVALID(po,Disconnect) )
            Result = (*PPFNDRV(po,Disconnect))( RemoteConnectionChannel, pRemoteConnectionFileObject );
        else
            Result = TRUE;
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}

/******************************Exported*Routine****************************\
*
* bDrvShadowConnect( hDev, RemoteConnectionChannel, pRemoteConnectionFileObject )
*
* This is done for new shadow connections.
*
* hdev (input)
*   Identifies device to be connected
* RemoteConnectionChannel ( input )
*   Remote connection channel of shadow (for modes)
* pRemoteConnectionFileObject ( input )
*   Remote Connection file object pointer of shadow (for modes)
*
\**************************************************************************/

BOOL bDrvShadowConnect( HDEV hdev, PVOID pRemoteConnectionData, ULONG RemoteConnectionDataLength )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver connect function (if defined)
        //

        if ( PPFNVALID(po,ShadowConnect) )
            Result = (*PPFNDRV(po,ShadowConnect))( pRemoteConnectionData, RemoteConnectionDataLength );
        else
            Result = TRUE;

        //
        // Set the palette
        //

        XEPALOBJ pal(po.ppalSurf());
        ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

        if ((Result == TRUE) && pal.bIsPalManaged())
        {
            ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

            (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                      (PALOBJ *) &pal,
                                      0,
                                      0,
                                      pal.cEntries());
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* bDrvShadowDisconnect(hdev, RemoteConnectionChannel, pRemoteConnectionFileObject)
*
* Notify the display driver that the shadow connection is going away.
*
* hdev (input)
*   Identifies device to be disabled
*
* RemoteConnectionChannel (input)
*   Shadow Channel being disconnected
* pRemoteConnectionFileObject (input)
*   Shadow Channel being disconnected
*
\**************************************************************************/

BOOL bDrvShadowDisconnect( HDEV hdev, PVOID pRemoteConnectionData, ULONG RemoteConnectionDataLength )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver disconnect function (if defined)
        //

        if ( PPFNVALID(po,ShadowDisconnect) )
            Result = (*PPFNDRV(po,ShadowDisconnect))( pRemoteConnectionData, RemoteConnectionDataLength );
        else
            Result = TRUE;

        //
        // Reset the palette
        //

        XEPALOBJ pal(po.ppalSurf());
        ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

        if ((Result == TRUE) && pal.bIsPalManaged())
        {
            ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

            (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                      (PALOBJ *) &pal,
                                      0,
                                      0,
                                      pal.cEntries());
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* vDrvInvalidateRect( hdev, prcl )
*
* Tell the display driver to invalidate the specified rect.
*
* hdev (input)
*   Identifies the device
*
* prcl (input)
*   Identifies the rectangle to invalidate
*
\**************************************************************************/

VOID vDrvInvalidateRect( HDEV hdev, PRECT prcl )
{
    GDIFunctionID(vDrvInvalidateRect);

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver invalidate rect function (if defined)
        //
        if ( PPFNVALID(po,InvalidateRect) )
            (*PPFNDRV(po,InvalidateRect))( prcl );
    }

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphore(po.hsemDevLock());
}


/******************************Exported*Routine****************************\
* vDrvDispalyIOCtl( hdev, pbuffer, cbbuffer )
*
* Tell the display driver to invalidate the specified rect.
*
* hdev (input)
*   Identifies the device
*
* pbuffer (input)
*   IOCtl data buffer
*
* cbbuffer (input)
*   IOCtl data buffer length
*
\**************************************************************************/

BOOL bDrvDisplayIOCtl( HDEV hdev, PVOID pbuffer, ULONG cbbuffer )
{
    BOOL Result;
    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver invalidate rect function (if defined)
        //
        if ( PPFNVALID(po,DisplayIOCtl) )
            Result = (*PPFNDRV(po,DisplayIOCtl))( pbuffer, cbbuffer );
        else
            Result = TRUE;
    }

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\mapfile2.cxx ===
/******************************Module*Header*******************************\
* Module Name: mapfile2.c
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

extern BOOL G_fConsole;
extern PW32PROCESS gpidSpool;

typedef enum _MAP_MODE {
    ModeKernel,
    ModeFD
} MAP_MODE;

typedef enum _FONT_IMAGE_TYPE {
    RemoteImage = 1,
    MemoryImage = 2
} FONT_IMAGE_TYPE;

BOOL bCreateSection(IN PWSTR, OUT FILEVIEW*, IN INT, BOOL *pbIsFAT);
VOID vUnmapFileFD(FILEVIEW*);
BOOL bMapRoutine(FONTFILEVIEW *pffv, FILEVIEW *pfv, MAP_MODE Mode, BOOL bIsFAT);
extern "C" HFASTMUTEX ghfmMemory;

#define SZDLHEADER ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[1]))

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cMapRemoteFonts
*
*       This procedure creates a virtual memory section in which we store
*       a copy of the spooler's data buffer. I shall refer to this copy
*       as the "spooler section". The pointer to the associated section
*       object is saved for later use. A view of the spooler section is
*       mapped into the user-mode address space of the calling procedure
*       (the spooler process). All the information about the spooler
*       section and its mappings is stored in a FONTFILEVIEW
*       strucutue supplied by the caller.
*
*   Parameters:
*
*       ppHeader - address of a variable that gives and receives a
*                  pointer to a DOWNLOADFONTHEADER structure.
*                  Upon entry, this is a pointer to a view of the spooler
*                  section that is valid in the context of the calling
*                  process (the spooler process).
*
*                  Upon error the value placed at this address is zero.
*
*       cjBuffer - a 32 bit variable that contains the size of the
*                  spooler image. In the case of MemoryImage fonts
*                  this size is actually larger than the size of the buffer
*                  by SZDLHEADER bytes.
*
*       pFontFileView - a pointer to a FONTFILEVIEW structure that
*                   points to incomming receive the information about
*                   the copy of the spooler image.
*
*                   Upon error this structure consists of all zero's.
*
*                   Upon a successful completion of this procedure,
*                   pFontFileView->gtfv.pvView will point to the first
*                   font in the spooler buffer and
*                   pFontFileView->gtfv.cjView will be equal to the
*                   size of the spooler buffer starting at pvView.
*                   That is, cjView is equal to cjBuffer minus
*                   the size of the spooler header.
*
*                   The fields of the FONTFILEVIEW structure that are
*                   affected are:
*
*           SpoolerBase - points to the base of a view of the spooler
*                         view of the spooler section. pHeader is
*                         valid only in the context of the this process
*                         (the spooler process)
*
*           fv.pvView - points to the first font file in the spooler
*                       view of the spooler section. This view of
*                       the spooler section is valid only in the
*                       context of the calling process.
*
*           fv.cjView - a 32-bit varaible that contains the size of
*                       header information is subtracted off. Another
*                       way to say this is: cjView is the offset of
*                       the end of the spooler section from the start
*                       of the image of the first font file.
*
*           ulRegionSize - equal to the entire size of the spooler
*                          section including the header information.
*
*           fv.pSection - pointer to the section object controling the
*                         spooler section. This is a kernel mode
*                         address and thus is accessable by any process
*                         in kernel mode.
*
*           SpoolerPid - the process id of the calling process. This is
*                        the id of the process that has valid access
*                        to pHeader, and fv.pvView.
*
*       ImageType - One of RemoteImage or MemoryImage. In
*                   the case of a remote font image, the image starts
*                   with a variable length DOWNLOADFONTHEADER structure
*                   followed by a series of file images at offsets
*                   specified in the header. In this case cjBuffer is
*                   equal to the size of the spooler image in bytes. This
*                   includes the size of the header, the files, and all
*                   necessary padding. In the case of a memory font image,
*                   the image is of a single font file; no header, no
*                   padding. In this case cjBuffer is equal to the size
*                   of the image plus SZDLHEADER. Here cjBuffer is equal
*                   to the size of the section to be produced which will
*                   start with a header, generated here, followed by
*                   a single font file image.
*
*   Called by:
*
*       NtGdiAddRemoteFontToDC
*
\**************************************************************************/

extern "C" ULONG cMapRemoteFonts(
   DOWNLOADFONTHEADER **ppHeader,       // IN OUT pointer to spooler buffer
                                        //        mapped into CSRSS address sapce
                COUNT  cjBuffer,        // IN size of spooler buffer in bytes
         FONTFILEVIEW *pFontFileView,   // OUT pointer to mapped file information
      FONT_IMAGE_TYPE  ImageType        // {Remote, Memory}
         )

{
              NTSTATUS  NtStatus;
                 PVOID  pSection, pView;
         LARGE_INTEGER  MaximumSize;
         LARGE_INTEGER  SectionOffset;
                 SIZE_T ViewSize;
                 ULONG  TempSize, NumFiles;
                  BOOL  bRet;
                  BOOL  bSpooledType1 = FALSE;

    DOWNLOADFONTHEADER *pHeader, *pCopy;

    // Copy the address of the spooler data into pHeader for safe keeping

    pHeader = *ppHeader;

    // Set the (return value) of the address of the copy of the spooler
    // data to zero. This indicates error.

    *ppHeader = 0;

#define  MAX_FONTFILE 0x10000000

// claudebe 6/24/99, the new surrogate enabled MungLui is blowing the previous limit of 0x80000000 

    ASSERTGDI(cjBuffer <=  MAX_FONTFILE, "cjBuffer > MAX_FONTFILE");

    // return 0 if cjBuffer is bogus

    if ((cjBuffer > MAX_FONTFILE) || (cjBuffer < sizeof(DOWNLOADFONTHEADER)))
    {
        return 0;
    }

    // Initialize these variables to zero to prevent unintended access
    // in the clean up code at the end of this routine. We also zero
    // out the FONTFILEVIEW structure, not only to indicate error, but
    // this will save us explicitly zeroing fields that we do not touch
    // in this routine.

    pSection  = 0;
    pView     = 0;

    if (pFontFileView == 0)
    {
        return(0);
    }

    RtlZeroMemory(pFontFileView, sizeof(*pFontFileView));

    if (ImageType == RemoteImage)
    {
        __try
        {
            ProbeForRead(pHeader, sizeof(DOWNLOADFONTHEADER), sizeof(ULONG));
            NumFiles = pHeader->NumFiles;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: invalid pointer pHeader\n");
            return (0);
        }

        // do some checks to ensure that these numbers are not entirely bogus.
        // Eg. in reality we never have more than 3 files per font, the total
        // sum of their sizes should not exceed MAX_FONTFILE (32MB for now);
        // ClaudeBe 6/24/99, limit extended to 256 MB 

        ASSERTGDI(NumFiles <= 3, "NumFiles not reasonable\n");

        if (NumFiles > 3)
        {
            return 0;
        }

        // The upper limit on the size of the spooler section is 256Mb

        if (0x10000000 < cjBuffer)
        {
            return(0);
        }

        if (!IS_USER_ADDRESS(pHeader))
        {
            return(0);
        }

        // If this a pfm,pfb image spooled from the NT 4.0 client,
        // NumFiles will be set to zero and Type1ID will be set to
        // ufi hash value. In this case we have to set the NumFiles to 2:

        if (NumFiles == 0)
        {
            bSpooledType1 = TRUE;
            NumFiles = 2;
        }
    }
    else
    {
        // for MemoryImage, NumFiles should be 1

        NumFiles = 1;
    }

    // Set TempSize to be equal to the size of the stuff preceeding
    // the first font file. This is the size of the header information
    // if you wish

    TempSize = ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[NumFiles]));

    // return 0 if the TempSize is bigger than cjBuffer

    if (cjBuffer < TempSize)
    {
        return 0;
    }

    // Create a section where we will store a copy of the spooler data

    MaximumSize.QuadPart = (LONGLONG) cjBuffer;

    NtStatus =
      Win32CreateSection(
            &pSection          , // SectionObject
            SECTION_ALL_ACCESS , // DesiredAccess
            0                  , // ObjectAttributes
            &MaximumSize       , // MaximumSize
            PAGE_READWRITE     , // SectionPageProtection
            SEC_COMMIT         , // AllocationAttributes
            0                  , // FileHandle
            0                  , // FileObject
            TAG_SECTION_REMOTEFONT
            );

    if (!NT_SUCCESS(NtStatus))
    {
        return(0);
    }

    // Map a view of the spooler section into the user mode address space
    // of the current process (this spooler process)

    SectionOffset.QuadPart = 0;
    ViewSize = cjBuffer;

    ASSERTGDI(pView == 0, "pView != 0\n");

    // Temporarily map a view of the section into the user mode address space
    // of the spooler process. This will allow us to copy the data from
    // the spool file to the section. After we are done we will close
    // this mapping and open a mapping into the user mode address space
    // of the CSRSS process.

    NtStatus =
        MmMapViewOfSection(
            pSection             , // SectionToMap,
            PsGetCurrentProcess(), // spooler process
            &pView               , // CapturedBase,
            0                    , // ZeroBits,
            ViewSize             , // CommitSize,
            &SectionOffset       , // SectionOffset,
            &ViewSize            , // CapturedViewSize,
            ViewUnmap            , // InheritDisposition,
            SEC_NO_CHANGE        , // AllocationType,
            PAGE_READWRITE         // Allow writing on this view
            );

    if (!NT_SUCCESS(NtStatus))
    {
        Win32DestroySection(pSection);
        return(0);
    }

    // this operation is a suspect for copying into 0-th page of csrss:

    ASSERTGDI(pView, "pView == 0\n");

    // Change pHeader to point at the copy

    DOWNLOADFONTHEADER  *pTmp = pCopy = (DOWNLOADFONTHEADER*) pView;

    if (ImageType == MemoryImage)
    {
        // pHeader is a buffer of size cjBuffer - SZDLHEADER
        // advance the pointer to the right position

        cjBuffer -= SZDLHEADER;
        pView = (PBYTE)pView + SZDLHEADER;

        // fill out the fields in DOWNLOADFONTHEADER for memory fonts

        __try
        {
            ProbeAndWriteUlong( &pTmp->Type1ID, 0);
            ProbeAndWriteUlong( &pTmp->NumFiles, NumFiles);
            ProbeAndWriteUlong( &pTmp->FileOffsets[0], cjBuffer);
            bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: exception occured for memory image\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }

        if (bRet == FALSE)
        {
            Win32DestroySection(pSection);
            return(0);
        }
    }

    // Copy the spooler data into this view of the spooler section

    __try
    {
        ProbeForRead(pHeader, cjBuffer, sizeof(BYTE));
        RtlCopyMemory(pView, pHeader, cjBuffer);
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("cMapRemoteFonts: exception occured\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }

    // fix the spooled (from NT 4.0) Type1 font case:

    if (bSpooledType1)
    {
        __try
        {
            ProbeAndWriteUlong( &pTmp->Type1ID, 0);
            ProbeAndWriteUlong( &pTmp->NumFiles, NumFiles);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: exception occured\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    // We have OR have not successfully completed copying the data
    // from the file to the section. In either case we no longer
    // need this view of the section
    // so we will unmap the spooler view at this time

    NtStatus = MmUnmapViewOfSection(PsGetCurrentProcess(), (PVOID)pCopy);

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Could not unmap the current process view of the memory font\n");
        KdPrint(("Could not unmap the current process view of the memory font\n"));

        Win32DestroySection(pSection);
        return(0);
    }

    if (bRet == FALSE)
    {
        Win32DestroySection(pSection);
        return(0);
    }

    // Now we will map a view into the user mode address space
    // of the CSRSS process. Remember that this view cannot
    // be seen by the current process.

    pView = 0;
    ViewSize = 0;
    SectionOffset.QuadPart = 0;

    NtStatus =
        MmMapViewOfSection(
            pSection             , // SectionToMap,
            gpepCSRSS            , // CSRSS process
            &pView               , // CapturedBase,
            0                    , // ZeroBits,
            ViewSize             , // CommitSize,
            &SectionOffset       , // SectionOffset,
            &ViewSize            , // CapturedViewSize,
            ViewUnmap            , // InheritDisposition,
            SEC_NO_CHANGE        , // AllocationType,
            PAGE_READONLY          // No writing on this view
            );

    if (!NT_SUCCESS(NtStatus))
    {
        Win32DestroySection(pSection);
        return(0);
    }

    ASSERTGDI((ULONG_PTR)pView > 0x100000,
                   "cmap remote fonts: csrss view smaller than 1MB \n");

    // Reset pCopy to point to a view of the section in the context
    // of the CSRSS process. CAUTION - you cannot access any data
    // off of pCopy or pView after this point.

    pCopy = (DOWNLOADFONTHEADER*) pView;

    if (ImageType == MemoryImage)
    {
        // reset the size and pointer

        cjBuffer += SZDLHEADER;
        pView = pCopy;
    }

    // Set the FONTFILEVIEW
    //
    //      SpoolerBase points at the base of the copy.
    //      pvView points to the first font image.
    //      cjView is the size of the section with starting
    //      at the first font image.
    //      ulRegionSize is set to the size of the entire view.

    pFontFileView->SpoolerBase  = pCopy;
    pFontFileView->fv.pvViewFD  = (char*) pCopy + TempSize;
    pFontFileView->fv.cjView    = cjBuffer - TempSize;
    pFontFileView->ulRegionSize = ViewSize;

// We have to set FD ref count to 1, KM ref count to zero [bodind]

    pFontFileView->cKRefCount    = 0;
    pFontFileView->cRefCountFD   = 1;

    pFontFileView->fv.pSection  = pSection;
    pFontFileView->SpoolerPid   = W32GetCurrentPID();   // this could be the pid of the spooler
                                                        // or the pid of the current process which is loading a memory font

    *ppHeader = pCopy;          // Valid in CSRSS process only.

    return(NumFiles);
}

/******************************Public*Routine******************************\
*
*   vUnmapRemoteFonts
*
*       This is a remote font so delete the memory for the view.
*
*   CAUTION
*
*       This code is intimately linked with NtGdiAddRemoteFontToDC()
*       so any changes here should be synchronized there.
*
*       The pool memory starts with a DOWNLOADFONTHEADER followed by the
*       file image pointed to by pvView. We must pass the pointer to the
*       beginning of the pool allocation to the free routine.
*
*
*   Spooler data format for Engine fonts
*
*
*    DOWNLOADFONTHEADER         PADDING
*         |                       |
*   |           |- FILE OFFSETS-|   |
*   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
*   |         0 | 1 | 2 | 3 | N | x | font image #0 | font image #1 |...
*   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
*                                   ^
*                                   pvView points to first font image
*
*
*   Parameters:
*
*       pFontFileView - a 32-bit variable that contains a pointer to a
*                       FONTFILEVIEW structure that describes the very
*                       first font file image in the spooler data.
*
*   Return Value:
*
*        none
*
*   Called by:
*
*     NtGdiAddRemoteFontsToDC
*     FreeFileView
*
\**************************************************************************/

extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *pFontFileView)
{
    if (pFontFileView == 0)
    {
        return;
    }

    ASSERTGDI(pFontFileView->SpoolerPid == W32GetCurrentPID() ||
              gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),
        "vUnmapRemoteFonts: wrong process freeing remote font data\n");

    // We initialize the cRefCountFD to 1 in cMapRemoteFonts() function

    if (pFontFileView->cRefCountFD)
    {
        pFontFileView->cRefCountFD -= 1;
    }

    if (pFontFileView->cRefCountFD == 0)
    {
        if (pFontFileView->fv.pSection)
        {
            if (pFontFileView->SpoolerBase)
            {
                MmUnmapViewOfSection(gpepCSRSS, pFontFileView->SpoolerBase);
                pFontFileView->SpoolerBase = NULL;
            }
            Win32DestroySection(pFontFileView->fv.pSection);
            pFontFileView->fv.pSection = 0;
        }
    }
}

/******************************Public*Routine******************************\
*
* bCreateFontFileView
*
\**************************************************************************/

BOOL  bCreateFontFileView(
          FONTFILEVIEW   *pFontFileViewIn,  // kernel mode address
    DOWNLOADFONTHEADER   *pHeader,          // CSRSS address of spool section
                 COUNT    cjBuffer,
          FONTFILEVIEW ***papfv,
                 ULONG    NumFiles
)
{
    FONTFILEVIEW **apfv, *pFontFileView, FontFileView;
    NTSTATUS  NtStatus;
    ULONG  offset;
    COUNT cjHeader;
    BOOL  bRet = TRUE;

    //
    // In order to see the data pointed to by pHeader we must attach
    // to the address space of the CSRSS process
    //

    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

    //
    // engine fonts
    //

    apfv = 0;
    FontFileView = *pFontFileViewIn;

    cjHeader = ALIGN8(offsetof(DOWNLOADFONTHEADER,FileOffsets[NumFiles]));

    if (cjBuffer <= cjHeader)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        KeDetachProcess();
        return FALSE;
    }

    //
    // The lowest part of the block of memory pointed to by apfv
    // will be occupied by NumFiles pointers to FONTFILEVIEW structures.
    // The FONTFILEVIEW structures pointed to by these pointers follow
    // at the first 8-byte aligned address after the array of pointers.
    //
/*********************************************************************************
*                                                                                *
*     Structure of data pointed to by `apfv'                                     *
*                                                                                *
* pointer   data  +----------------------------+                                 *
*                 |                            V                                 *
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+ *
* |apfv ... | p | p | p |   |FONTFILEVIEW|   |FONTFILEVIEW|   |FONTFILEVIEW|   | *
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+ *
*   |       ^ |             ^                                                    *
*   +-------+ +-------------+                                                    *
*                                                                                *
*            |               |                                                   *
*            |<-- offset --->|                                                   *
*                                                                                *
*********************************************************************************/

    //
    // `offset' is the count of bytes from the beginning of the allocated
    // memory to where the array of FONTFILEVIEW structures starts. An array
    // of FONTFILEVIEW pointers preceeds.
    //

    offset = ALIGN8(sizeof(FONTFILEVIEW*) * NumFiles);

    apfv = (FONTFILEVIEW**) PALLOCMEM(sizeof(FONTFILEVIEW) * NumFiles + offset, 'vffG');

    if (apfv == 0)
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        KeDetachProcess();
        return FALSE;
    }

    //
    // Only initiaze these values for one file view in the
    // array.  This file view will be used to free the entire
    // block of memory containing all the files.
    //

    FONTFILEVIEW **ppFontFileView = apfv;

    pFontFileView  = (FONTFILEVIEW*) ((char*) apfv + offset);

    //
    // FileOffset[i] = offset of File[i+1] from begining of first
    //                 font file view
    //
    // Size[i] = FileOffset[i] - FileOffset[i-1];
    //

    //
    // copy the FONTFILEVIEW structure initialized by vMapSpoolerFontFiles
    // into the first positon in the array
    //

    *pFontFileView = FontFileView;

    //
    // Set pchView to point to the first FONTFILEVIEW structure in the
    // array
    //

    char *pchView = (char*) FontFileView.fv.pvViewFD;

    //
    // pchLast points to illegal memory. This step relies on
    // vMapRemotFonts to place in cjView the size of the view as
    // though it were based at the start of the first file.
    //

    char *pchLast = pchView + FontFileView.fv.cjView;

    ULONG Offset       = 0;
    ULONG *pOffset     = &(pHeader->FileOffsets[0]);
    ULONG *pOffsetLast = pOffset + NumFiles;

    for (; pOffset < pOffsetLast; pOffset++)
    {
        ULONG NextOffset = *pOffset;
        ULONG cjView     = NextOffset - Offset;
        Offset = ALIGN4(NextOffset);
        // the offset alignement must correspond to \ntgdi\client\ufi.c WriteFontToSpoolFile()
        // if there is a need for different alignement, then we would need to map each file separately
        ASSERTGDI(Offset == NextOffset, "bCreateFontFileView ALIGN difference between client and server");


        if (pchLast < pchView + cjView)
        {
            bRet = FALSE;
            break;
        }

        pFontFileView->fv.pvViewFD = pchView;
        pFontFileView->fv.cjView   = cjView;

        //
        // move pchView to point at the next font image
        //

        pchView += cjView;

        *ppFontFileView = pFontFileView;

        ppFontFileView++;
        pFontFileView++;

    }

    if (!bRet)
    {
        VFREEMEM(apfv);
    }
    else
    {
        *papfv = apfv;
    }

    KeDetachProcess();

    return (bRet);
}

/******************************Public*Routine******************************\
*
*   NtGdiAddRemoteFontToDC
*
* This routine is called by the spooler process, at playback time, to
* add remote fonts to a printer DC. The font files in question are for
* the use of the associated print job only. No other application can
* have access. In order to prevent mischevious application on the server
* from picking up font to which it has not right, we have chosen to not
* copy the file images contained in the spool file to separate font file
* on the disk. This means that the spooler process cannot use
* AddFontResource to allow the DC access to the fonts.
* Instead, we have introduced this private entry point for the spooler.
*
*     Parameters:
*
*         hdc - handle to DC to which remote font is to be added
*
*         pvBuffer - pointer to a DOWNLOADFONTHEADER that details
*                    the location of the font files contained
*                    withing this buffer.
*
*         cjBuffer - is the size of the buffe, in bytes, pointed
*                    to by pvBuffer
*
*     Return Value:
*
*         TRUE if successful, FALSE if not.
*
*     Remarks:
*
* In the process of loading the fonts to the spooler DC, we create
* an array of FONTFILEVIEW structures. The lowest part of the block
* of memory pointed to by apfv will be occupied by NumFiles pointers
* to FONTFILEVIEW structures. The FONTFILEVIEW structures pointed to
* by these pointers follow at the first 8-byte aligned address after
* the array of pointers.
*
*         Structure of data pointed to by `apfv'
*
* pointer   data  +----------------------------+
*                 |                            V
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+
* |apfv ... | p | p | p |   |FONTFILEVIEW|   |FONTFILEVIEW|   |FONTFILEVIEW|   |
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+
*   |       ^ |             ^
*   +-------+ +-------------+
*
*            |               |
*            |<-- offset --->|
*
\**************************************************************************/

extern "C" BOOL APIENTRY NtGdiAddRemoteFontToDC(
      HDC hdc      , // handle to DC to which remote font is to be added
    PVOID pvBuffer , // pointer to spool font file image
    COUNT cjBuffer , // size of spool font file image
    PUNIVERSAL_FONT_ID pufi     //orignal ufi for subsetted font, used for remote printing only
)
{
          FONTFILEVIEW FontFileView, **apfv, *pFontFileView;
    DOWNLOADFONTHEADER *pHeader;
              NTSTATUS  NtStatus;
                 ULONG  offset;
                 ULONG  NumFiles;
                  BOOL  bRet;
                  BOOL  bMappedSpoolerFont;
     UNIVERSAL_FONT_ID  ufiTmp;
     UNIVERSAL_FONT_ID *pufiTmp = pufi;

    __try
    {
        if (pufiTmp)
        {
            ufiTmp = ProbeAndReadStructure(pufiTmp, UNIVERSAL_FONT_ID);
            pufiTmp = &ufiTmp;
        }
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (!bRet)
        return bRet;

    bRet = FALSE;
    XDCOBJ dco(hdc);

    if (!dco.bValid())
    {
        return bRet;
    }

    apfv = 0;
    pFontFileView = NULL;

    pHeader = (DOWNLOADFONTHEADER*) pvBuffer;

    NumFiles = cMapRemoteFonts(&pHeader, cjBuffer, &FontFileView, RemoteImage);

    if (pHeader == 0)
    {
        goto exit_point;
    }
    bRet = TRUE;
    pFontFileView = &FontFileView;

    if (NumFiles)
    {
    // engine fonts

        if (bRet = bCreateFontFileView(&FontFileView, pHeader, cjBuffer, &apfv, NumFiles))
        {
            PUBLIC_PFTOBJ pfto;

            bRet = pfto.bLoadRemoteFonts(dco, apfv, NumFiles, 0, pufiTmp);
        }
    }

exit_point:

    if (!bRet)
    {
        if (pFontFileView)
        {
            vUnmapRemoteFonts(pFontFileView);
        }
        if (apfv)
        {
            VFREEMEM(apfv);
        }
    }
    dco.vUnlockFast();

    return (bRet);
}

/******************************Public*Routine******************************\
*
* GreAddFontMemResourceEx
*
* This function uses same routines that NtGdiAddRemoteToDC()
* uses to create the file view structrues before it can load
* the font into the system. Memory fonts are always added as
* private to the private font tale.
*
\**************************************************************************/

HANDLE GreAddFontMemResourceEx(
    PVOID   pvBuffer,
    ULONG   cjBuffer,
    DESIGNVECTOR  *pdv,
    DWORD   cjDV,
    DWORD   *pNumFonts
)
{
    FONTFILEVIEW    **apfv, FontFileView;
    DOWNLOADFONTHEADER  *pHeader;
    ULONG NumFiles;

    HANDLE  hMMFont = 0;
    BOOL    bOK = FALSE;

    apfv = 0;
    pHeader = (DOWNLOADFONTHEADER*) pvBuffer;

    // in order to use the same routines used by remote fonts, we need to
    // attach a DOWNLOADFONTHEADER structure in fron of the font image

    cjBuffer += SZDLHEADER;

    NumFiles = cMapRemoteFonts(&pHeader, cjBuffer, &FontFileView, MemoryImage);

    if (pHeader != 0)
    {
        ASSERTGDI(NumFiles == 1, "GreAddFontMemResourceEx() NumFiles != 1\n");

        if (bCreateFontFileView(&FontFileView, pHeader, cjBuffer, &apfv, 1))
        {
            if (gpPFTPrivate || bInitPrivatePFT())
            {
                PUBLIC_PFTOBJ pfto(gpPFTPrivate);
                ULONG   cFonts;

                if (hMMFont = pfto.hLoadMemFonts(apfv, pdv, cjDV, &cFonts))
                {
                    bOK = TRUE;
                    *pNumFonts = cFonts;
                }
            }
        }
        else
        {
            vUnmapRemoteFonts(&FontFileView);
        }
    }

    if (!bOK && apfv)
    {
        VFREEMEM(apfv);
    }

    return hMMFont;
}

/******************************Public*Routine******************************\
*
*   FreeFileView
*
*       This routine is called to free the copy of the spooler data,
*       if it exists.
*
*  Parameters:
*
*       apfv - pointer to an array of FONTFILEVIEW pointers.
*              The number of pointers in the array is given by cFiles.
*
*       cFiles - a 32-bit variable containing the number of pointers in
*                the array pointed to by apfv.
*
* Return Value:
*
*   None.
*
* Called by:
*
*       PFFOBJ::pPFFC_Delete
*
\**************************************************************************/

extern "C" void FreeFileView(PFONTFILEVIEW apfv[], ULONG cFiles)
{
    FONTFILEVIEW *pfv, **ppfv;

    for (ppfv = apfv; ppfv < apfv + cFiles; ppfv++)
    {
        pfv = *ppfv;

        if (pfv->ulRegionSize)
        {
            vUnmapRemoteFonts(pfv);
        }
    }
    VFREEMEM(apfv);
}


/******************************Public*Routine******************************\
*
* BOOL EngMapFontFileInternal
*
*    This is called by font drivers to return a buffer containing the
*    raw bytes for a font file, given a handle passed to DrvLoadFontFile.
*    The handle is really a pointer to the PFF for this file.
*
* Parameters:
*
*       iFile - Supplies a 32-bit identifier of the font file. This is
*               the value supplied in DrvLoadFontFile.
*
*       ppjBuf - Supplies a pointer to a variable that will receive the
*                address of the base of the view of the file.
*
*       pcjBuf - Supplies a pointer to a variable that will receive the
*                size of the view of the file.
*       bFontDrv - if this is called by font driver.
*
* Return Values:
*
*       TRUE if successufl, FALSE if not.
*
* Called by:
*
*       PUBLIC_PFTOBJ::bLoadFonts
*       GreGetUFIBits
*       NtGdiAddRemoteFontToDC
*       GreMakeFontDir
*
* History:
*  20-Jan-1995 -by- Gerrit van Wingerden
*
\**************************************************************************/

BOOL EngMapFontFileInternal(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf,
     BOOL  bFontDrv
)
{
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;
    BOOL bMapIt,bRet;
    FILEVIEW fv;

    RtlZeroMemory(&fv, sizeof(fv));

    bRet   = TRUE;
    bMapIt = TRUE;

    GreAcquireFastMutex(ghfmMemory);
        if (pffv->fv.pvKView)
        {
            bMapIt = FALSE;
            pffv->cKRefCount += 1;
        }
        else if (!pffv->pwszPath)
        {
            RIP("fv.pvKView==0 && pwszPath==0\n");
        }
        else if (pffv->fv.pSection)
        {
            NTSTATUS NtStatus;
            SIZE_T ViewSize;
            LARGE_INTEGER SectionOffset;

            SectionOffset.QuadPart = 0;
            ViewSize = 0;

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(
                            pffv->fv.pSection,
                            &pffv->fv.pvKView,
                            &ViewSize);

#elif defined(_HYDRA_)
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus= Win32MapViewInSessionSpace(
                         pffv->fv.pSection,
                         &pffv->fv.pvKView,
                         &ViewSize);
#else
            NtStatus = MmMapViewInSystemSpace(
                           pffv->fv.pSection,
                           &pffv->fv.pvKView,
                           &ViewSize);
#endif


            if (bRet = NT_SUCCESS(NtStatus))
            {
#ifdef _HYDRA_
#if DBG
                if (!G_fConsole)
                {
                    DebugGreTrackAddMapView(pffv->fv.pvKView);
                }
#endif
#endif

                pffv->cKRefCount = 1;
            }
            bMapIt = FALSE;
        }
    GreReleaseFastMutex(ghfmMemory);

    if (bMapIt)
    {
        BOOL    bMapOK, bIsFAT;

        // If the call is from the font driver, the current thread
        // is attached to the CSRSS process. By attaching it to the
        // CSRSS, the thread loses its user security context which
        // prevents the thread to open a network font file.

        if (bFontDrv)
            KeDetachProcess();

        bMapOK = bMapFile(pffv->pwszPath, &fv, 0, &bIsFAT);

        if (bFontDrv)
            KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

        if (!bMapOK)
        {
            bRet = FALSE;
        }
        else
        {
            BOOL bKeepIt;

            GreAcquireFastMutex(ghfmMemory);
                pffv->cKRefCount += 1;
                if (pffv->fv.pvKView)
                {
                    bKeepIt = FALSE;    // file mapped by another thread
                }
                else
                {
                    bRet = bKeepIt = bMapRoutine(pffv, &fv, ModeKernel, bIsFAT);
                }
            GreReleaseFastMutex(ghfmMemory);

            if (!bKeepIt)
            {
                vUnmapFile(&fv);
            }
        }
    }

    if (bRet)
    {
        //
        // it's okay to access these without grabbing the MUTEX since we've
        // incremented the reference count;
        //

        if (ppjBuf)
        {
            *ppjBuf = (ULONG*) pffv->fv.pvKView;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->fv.cjView;
        }
    }

    return(bRet);

}

/***********************Public*Routine*********************\
*
* BOOL EngMapFontFile
*
* History:
*  20-Jan-1995 -by- Gerrit van Wingerden
*
\**********************************************************/

BOOL EngMapFontFile(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf
)
{
    return (EngMapFontFileInternal(iFile, ppjBuf, pcjBuf, FALSE));
}


/******************************Public*Routine******************************\
*
*  EngUnmapFontFile
*
*   This is called by font drivers to unmap a file mapped by a previous
*   call to EngMapFontFile.
*
*  Parameters:
*
*      iFile - is the font identifier as returned by EngMapFontFile.
*
*  Return Value:
*
*      None.
*
*  Called by:
*
*    PUBLIC_PFTOBJ::bLoadFonts
*    GreGetUFIBits
*    GreMakeFontDir
*
\**************************************************************************/

void EngUnmapFontFile(ULONG_PTR iFile)
{
    FILEVIEW fv;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;

    fv.pvKView = NULL;

    GreAcquireFastMutex(ghfmMemory);

    if (pffv->cKRefCount)
    {
        pffv->cKRefCount -= 1;

        if (pffv->cKRefCount == 0)
        {
            if (pffv->pwszPath)
            {
                fv = pffv->fv; // copy pvKView, pvViewFD and pSection;

                pffv->fv.pvKView = 0;

                if (pffv->fv.pvViewFD == 0)
                {
                    pffv->fv.pSection = 0;
                }
            }
        }
    }

    GreReleaseFastMutex(ghfmMemory);

    if (fv.pvKView)
    {
        vUnmapFile(&fv);
    }
}

/******************************Public*Routine******************************\
* BOOL bMapFile
*
* Similar to PosMapFile except that it takes unicode file name
*
* If iFileSize is -1 then the file is module is mapped for read/write.  If
* iFileSize is > 0 then the file is extended or truncated to be iFileSize
* bytes in size and is mapped for read/write.
*
* History:
*  21-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bMapFile(PWSTR pwszFileName, FILEVIEW  *pfvw, INT iFileSize, BOOL *pbIsFAT)
{
    FILEVIEW fv;
    NTSTATUS NtStatus;
    BOOL ReturnValue;
    SIZE_T ViewSize;

    ReturnValue = FALSE;

    if (bCreateSection(pwszFileName, &fv, iFileSize, pbIsFAT))
    {
        ViewSize = 0;

#if defined(_GDIPLUS_)

        NtStatus = MapViewInProcessSpace(fv.pSection, &fv.pvKView, &ViewSize);

#elif defined(_HYDRA_)
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.

        NtStatus = Win32MapViewInSessionSpace(fv.pSection, &fv.pvKView, &ViewSize);
#else
        NtStatus = MmMapViewInSystemSpace(fv.pSection, &fv.pvKView, &ViewSize);
#endif
        if (NT_SUCCESS(NtStatus))
        {

#ifdef _HYDRA_
#if DBG
                if (!G_fConsole)
                {
                    DebugGreTrackAddMapView (fv.pvKView);
                }
#endif
#endif
            *pfvw = fv;
            ReturnValue = TRUE;
        }
        else
        {
            DEREFERENCE_FONTVIEW_SECTION(fv.pSection);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* vCopyDESIGNVECTOR
*
\**************************************************************************/

extern "C" VOID vCopyDESIGNVECTOR(DESIGNVECTOR *pDst, DESIGNVECTOR *pSrc)
{
    RtlCopyMemory(pDst, pSrc, SIZEOFDV(pSrc->dvNumAxes));
}


/******************************Public*Routine******************************\
*
* EngMapFontFileFDInternal
*
\**************************************************************************/

BOOL EngMapFontFileFDInternal(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf,
     BOOL  bFontDrv
)
{
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;
    BOOL bMapIt,bRet;
    FILEVIEW fv;

    RtlZeroMemory(&fv, sizeof(fv));

    bRet   = TRUE;
    bMapIt = TRUE;

    GreAcquireFastMutex(ghfmMemory);
        if (pffv->fv.pvViewFD)
        {
            bMapIt = FALSE;
            pffv->cRefCountFD += 1;
        }
        else if (!pffv->pwszPath)
        {
            GreReleaseFastMutex(ghfmMemory);
            return(FALSE);
        }
        else if (pffv->fv.pSection)
        {
            NTSTATUS NtStatus;
            SIZE_T ViewSize;
            LARGE_INTEGER SectionOffset;

            SectionOffset.QuadPart = 0;
            ViewSize = 0;

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(pffv->fv.pSection, &pffv->fv.pvViewFD, &ViewSize);
#else

            NtStatus = MmMapViewOfSection(
                           pffv->fv.pSection , // SectionToMap,
                           gpepCSRSS         , // spooler process
                           &pffv->fv.pvViewFD, // CapturedBase,
                           0                 , // ZeroBits,
                           ViewSize          , // CommitSize,
                           &SectionOffset    , // SectionOffset,
                           &ViewSize         , // CapturedViewSize,
                           ViewUnmap         , // InheritDisposition,
                           SEC_NO_CHANGE     , // AllocationType,
                           PAGE_READONLY       // Protect
                           );
#endif

            if (bRet = NT_SUCCESS(NtStatus))
            {
                pffv->cRefCountFD = 1;
            }
            bMapIt = FALSE;
        }
    GreReleaseFastMutex(ghfmMemory);

    if (bMapIt)
    {
        // If the call is from the font driver, the current thread
        // is attached to the CSRSS process. By attaching it to the
        // CSRSS, the thread loses its user security context which
        // prevents the thread to open a network font file.

        BOOL    bCreateOK, bIsFAT;

        if (bFontDrv)
            KeDetachProcess();

        bCreateOK = bCreateSection(pffv->pwszPath, &fv, 0, &bIsFAT);

        if (bFontDrv)
            KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

        if (!bCreateOK)
        {
            bRet = FALSE;
        }
        else
        {
            BOOL bKeepIt;
            NTSTATUS NtStatus;
            SIZE_T ViewSize = 0;
            PVOID pvView, pSection;
            LARGE_INTEGER SectionOffset = {0,0};

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(fv.pSection, &fv.pvViewFD, &ViewSize);

#else

            NtStatus = MmMapViewOfSection(
                           fv.pSection   , // SectionToMap,
                           gpepCSRSS     , // spooler process
                           &fv.pvViewFD  , // CapturedBase,
                           0             , // ZeroBits,
                           ViewSize      , // CommitSize,
                           &SectionOffset, // SectionOffset,
                           &ViewSize     , // CapturedViewSize,
                           ViewUnmap     , // InheritDisposition,
                           SEC_NO_CHANGE , // AllocationType,
                           PAGE_READONLY   // Protect
                           );
#endif

            if (!NT_SUCCESS(NtStatus))
            {
                DEREFERENCE_FONTVIEW_SECTION(fv.pSection);
                return(FALSE);
            }

            GreAcquireFastMutex(ghfmMemory);
                pffv->cRefCountFD += 1;
                if (pffv->fv.pvViewFD)
                {
                    bKeepIt = FALSE;
                }
                else
                {
                    bRet = bKeepIt = bMapRoutine(pffv, &fv, ModeFD, bIsFAT);
                }
            GreReleaseFastMutex(ghfmMemory);

            if (!bKeepIt)
            {
                vUnmapFileFD(&fv);
            }
        }
    }

    if (bRet)
    {

        ASSERTGDI((ULONG_PTR)pffv->fv.pvViewFD > 0x100000,
                   "csrss view smaller than 1MB \n");

        if (ppjBuf)
        {
            *ppjBuf = (ULONG*) pffv->fv.pvViewFD;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->fv.cjView;
        }
    }

    return(bRet);
}


/************************Public*Routine**********************\
*
* EngMapFontFileFD
*
\************************************************************/

BOOL EngMapFontFileFD(
     ULONG_PTR  iFile,
    PULONG *ppjBuf,
     ULONG *pcjBuf
)
{
    return (EngMapFontFileFDInternal(iFile, ppjBuf, pcjBuf, TRUE));
}


/******************************Public*Routine******************************\
*
* vUnmapFileFD
*
\**************************************************************************/

VOID vUnmapFileFD(FILEVIEW *pFileView)
{
#if defined(_GDIPLUS_)
    UnmapViewInProcessSpace(pFileView->pvViewFD);
#else
    MmUnmapViewOfSection(gpepCSRSS, pFileView->pvViewFD);
#endif

    if (pFileView->pvKView == 0)
    {
        DEREFERENCE_FONTVIEW_SECTION(pFileView->pSection);
    }

    pFileView->bLastUpdated = FALSE;
}

/******************************Public*Routine******************************\
*
* EngUnmapFontFileFD
*
\**************************************************************************/

void EngUnmapFontFileFD(ULONG_PTR iFile)
{
    FILEVIEW fv;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;

    fv.pvViewFD = NULL;

    GreAcquireFastMutex(ghfmMemory);

    if (pffv->cRefCountFD)
    {
        pffv->cRefCountFD -= 1;

        if (pffv->cRefCountFD == 0)
        {
            if (pffv->pwszPath)
            {
            // This path is never taken for remote fonts
            // so this routine does not unmap remote fonts

                fv = pffv->fv;  // copy pvKView, pvViewFD and pSection;

                if (pffv->fv.pvViewFD)
                {
                    pffv->fv.pvViewFD = 0;

                    if (pffv->fv.pvKView == 0)
                    {
                        pffv->fv.pSection = 0;
                    }
                }
            }
        }
    }

    GreReleaseFastMutex(ghfmMemory);

    if (fv.pvViewFD)
    {
        vUnmapFileFD(&fv);
    }
}

/******************************Public*Routine******************************\
*
* bCreateSection
*
\**************************************************************************/

BOOL bCreateSection(PWSTR pwszFileName, FILEVIEW *pFileView, INT iFileSize, BOOL *pbIsFAT)
{
    #if defined(_GDIPLUS_)

    return CreateMemoryMappedSection(pwszFileName, pFileView, iFileSize);

    #else // !_GDIPLUS_

    UNICODE_STRING            UnicodeString;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    NTSTATUS                  NtStatus;
    HANDLE                    FileHandle = 0;
    IO_STATUS_BLOCK           IoStatusBlock;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    FILE_BASIC_INFORMATION    FileBasicInfo;
    LARGE_INTEGER             DesiredSize;
    FILEVIEW                  FileView;

    RtlZeroMemory(pFileView, sizeof(FILEVIEW));
    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    RtlInitUnicodeString(&UnicodeString, pwszFileName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        0,
        0);

    if (iFileSize)
    {
        NtStatus = IoCreateFile(
                       &FileHandle,
                       FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       0,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ
                           | FILE_SHARE_WRITE
                           | FILE_SHARE_DELETE,
                       FILE_OPEN_IF,
                       FILE_SYNCHRONOUS_IO_ALERT,
                       0,
                       0,
                       CreateFileTypeNone,
                       NULL,
                       IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                       IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                       IO_CHECK_CREATE_PARAMETERS);
    }
    else
    {
        // Here is the code for reference NtOpenFile 
        // File locates it at ..\ntos\io\open.c
        // 
        NtStatus = IoCreateFile(
                       &FileHandle,
                       FILE_GENERIC_READ 
                        | FILE_GENERIC_EXECUTE
                        | SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       0,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ,
                       FILE_OPEN,       // Flag for file open.
                       FILE_SYNCHRONOUS_IO_ALERT,
                       0,
                       0,
                       CreateFileTypeNone,
                       NULL,
                       IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                       IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                       IO_CHECK_CREATE_PARAMETERS);

    }
    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileStandardInfo,
                   sizeof(FILE_STANDARD_INFORMATION),
                   FileStandardInformation);

    if (!NT_SUCCESS(NtStatus))
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    // Get the time stamp

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileBasicInfo,
                   sizeof(FileBasicInfo),
                   FileBasicInformation);

    if (!NT_SUCCESS(NtStatus))
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    FileView.LastWriteTime = FileBasicInfo.LastWriteTime;
    FileView.bLastUpdated = TRUE;

    if (pbIsFAT)
    {
        struct
        {
            FILE_FS_ATTRIBUTE_INFORMATION Info;
            WCHAR   Buffer[MAX_PATH];
        } FileFsAttrInfoBuffer;

        *pbIsFAT = FALSE;

        NtStatus = ZwQueryVolumeInformationFile(
                       FileHandle,
                       &IoStatusBlock,
                       &FileFsAttrInfoBuffer.Info,
                       sizeof(FileFsAttrInfoBuffer),
                       FileFsAttributeInformation);
    
        if (!NT_SUCCESS(NtStatus))
        {
            ZwClose(FileHandle);
            return(FALSE);
        }
    
        if (!_wcsnicmp((LPWSTR)FileFsAttrInfoBuffer.Info.FileSystemName, L"FAT", 3))
        {
            *pbIsFAT = TRUE;
        }
    }
    
    // Note that we must call ZwSetInformation even in the case where iFileSize
    // is -1.  By doing so we force the file time to change.  It turns out that
    // just mapping a file for write (and writing to the section) is not enough
    // to cause the file time to change.

    if (iFileSize)
    {
        if (iFileSize > 0)
        {
            DesiredSize.LowPart = (ULONG) iFileSize;
        }
        else
        {
            DesiredSize.LowPart = FileStandardInfo.EndOfFile.LowPart;
        }

        DesiredSize.HighPart = 0;

        //
        // set the file length to the requested size
        //

        NtStatus = ZwSetInformationFile(
                       FileHandle,
                       &IoStatusBlock,
                       &DesiredSize,
                       sizeof(DesiredSize),
                       FileEndOfFileInformation);

        if (!NT_SUCCESS(NtStatus))
        {
            ZwClose(FileHandle);
            return(FALSE);
        }

        //
        // set FileStandardInfo and fall through to the case where we called
        // ZwQueryInfo to get the file size
        //

        FileStandardInfo.EndOfFile.LowPart = (ULONG) DesiredSize.LowPart;
        FileStandardInfo.EndOfFile.HighPart = 0;
    }

    if (FileStandardInfo.EndOfFile.HighPart)
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    FileView.cjView = FileStandardInfo.EndOfFile.LowPart;

    NtStatus = Win32CreateSection(
                   &FileView.pSection,
                   SECTION_ALL_ACCESS,
                   0,
                   &FileStandardInfo.EndOfFile,
                   (iFileSize) ? PAGE_READWRITE : PAGE_EXECUTE_READ,
                   SEC_COMMIT,
                   FileHandle,
                   0,
                   TAG_SECTION_CREATESECTION);

    ZwClose(FileHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    RtlCopyMemory(pFileView, &FileView, sizeof(FileView));

    return(TRUE);

    #endif // !_GDIPLUS_
}


/******************************Public*Routine******************************\
* vUnmapFile
*
* Unmaps file whose view is based at pv
*
* Called by:
*
*   EngMapFontFile
*   EngUnmapFontFile
*   GreGetUFIBits
*   GetTypeOneFontList
*
*  14-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vUnmapFile(PFILEVIEW pfv)
{
    NTSTATUS NtStatus;

#if defined(_GDIPLUS_)

    NtStatus = UnmapViewInProcessSpace(pfv->pvKView);

#elif defined(_HYDRA_)
    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.

    NtStatus = Win32UnmapViewInSessionSpace(pfv->pvKView);
#else
    MmUnmapViewInSystemSpace(pfv->pvKView);
#endif

#if DBG && defined(_HYDRA_)
    if ((!G_fConsole) && (NT_SUCCESS(NtStatus)))
    {
        DebugGreTrackRemoveMapView(pfv->pvKView);
    }
#endif

    if (pfv->pvViewFD == 0)
    {
        DEREFERENCE_FONTVIEW_SECTION(pfv->pSection);
    }
    
    pfv->bLastUpdated = FALSE;
}

/******************************Public*Routine******************************\
* GetModuleHandleAndIncrementRefcount
*
*   This function searches through the GreEngLoadModuleAllocList to see
*   if a module has been loaded already, and if so it returns a handle
*   to that module (and increments the reference count).
*
* Arguments:
*
*     pwsz -- The name of the module
*
* Return Value:
*
*     a FILEVIEW pointer if the module has been loaded already, NULL
*     otherwise.
*
* History:
*
*    21-Apr-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

HANDLE
GetModuleHandleAndIncrementRefcount(
    PWSZ pwsz
    )
{
    HANDLE hRet=NULL;

    if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

    PLIST_ENTRY pNextEntry = GreEngLoadModuleAllocList.Flink;

    //
    // Loop through the loaded modules looking for pwsz
    //

    while ((pNextEntry != &GreEngLoadModuleAllocList) && !(hRet))
    {
        PWSZ pwszModuleName = (PWSZ) (((PBYTE) pNextEntry) + sizeof(ENGLOADMODULEHDR) -
            ((PENGLOADMODULEHDR)pNextEntry)->cjSize);

        if (_wcsicmp(pwsz, pwszModuleName) == 0)
        {
            ((PENGLOADMODULEHDR)pNextEntry)->cRef++;
            hRet = (HANDLE) (((PBYTE) pNextEntry) + sizeof(ENGLOADMODULEHDR));
        }

        pNextEntry = pNextEntry->Flink;
    }

    if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);

    return hRet;
}



/******************************Public*Routine******************************\
*
* LoadModuleWorkHorse
*
* Note that all allocations are tracked through a linked list maintained
* via the ENGLOADMODULEHDR fields.  This enables us to do just one allocation
* per file even if called multiple times.  The diagram below shows the layout
* of the data structures in memory.
*
*
*
*                  Buffer
* pBaseAlloc --> +------------------+<-|
*                | Module name      |  |
*    pelmNew --> +------------------+  |-cjSize (length of module name
*                | ENGLOADMODULEHDR |  |         plus ENGLOADMODULE header)
*        pfv --> +------------------+<-|
*                | FILEVIEW         |
*                |                  |
*                +------------------+
*
*
* Note that it is theoretically possible for two modules with the same name
* to be mapped twice (to two different virtual addresses), because we don't
* grab the GreEngLoadModuleAllocListLock until late in the code (so if two
* threads enter this function and both pass the search stage before either
* grabs the lock, both would independently get different entries for this
* module).  There are two possible ways to remedy this:
* 1) Grab the lock before the search -- the problem is that this will force
*    us to keep the lock during the call to bMapFile which can take a while
* 2) Search twice, the second time being after the call to bMapFile (and after
*    we obtain the lock).  This is quite ugly, and would force us to free the
*    memory allocated by bMapFile in the scenario described above.
*
* So because neither solution is particularly attractive, we allow the same
* module to be placed multiple times in the list.  In practice this should
* happen very rarely, and shouldn't lead to any major problems (except
* for a minor waste of resources).
*
*
\**************************************************************************/

HANDLE LoadModuleWorkHorse(PWSZ pwsz, INT iSize)
{
    UNICODE_STRING usPath;
    BYTE *pBaseAlloc;
    FILEVIEW *pfv;
    HANDLE hRet = 0;
    ULONGSIZE_T cj = sizeof(FILEVIEW);
    ULONG cjStringLength;

    //
    // NULL names are bad.
    //

    if (wcslen(pwsz) == 0)
    {
        return NULL;
    }

    //
    // First check if this is mapped into kernel memory already
    //

    if (iSize == 0) // Only share on EngLoadModule calls because iSize may not be the same
    {
        if ((hRet = GetModuleHandleAndIncrementRefcount(pwsz)) != NULL)
        {
            return hRet;
        }
    }

    //
    // Get the name of the module length string.  Round up to a multiple of
    // 8 bytes so that the buffer we return will be 8-byte aligned (ENGLOADMODULEHDR is
    // already 8-byte aligned).
    //

    cjStringLength = (wcslen(pwsz) + 1) * sizeof(WCHAR);
    cjStringLength = ((cjStringLength + 7) & (~7));

    //
    // Increase the size of the allocation by the size of the ENGLOADMODULEHDR header
    // plus the length of the string.
    //

    cj += sizeof(ENGLOADMODULEHDR) + cjStringLength;

    if (MakeSystemRelativePath(pwsz, &usPath, FALSE))
    {
        if (pBaseAlloc = (BYTE *) PALLOCMEM(cj, 'lifG'))
        {
            ENGLOADMODULEHDR *pelmNew = (ENGLOADMODULEHDR *) (pBaseAlloc + cjStringLength);
            pfv = (FILEVIEW *) (pelmNew + 1);

            if (bMapFile(usPath.Buffer, pfv, iSize, NULL))
            {
                hRet = pfv;

                //
                // Copy the filename into the buffer
                //

                if (iSize==0)
                {
                    //
                    // EngLoadModule -- share with other calls
                    //

                    wcscpy((PWSZ)pBaseAlloc, pwsz);
                }
                else
                {
                    //
                    // EngLoadModuleForWrite -- don't share because of possible buffer size mismatches
                    // It is possible to code this so that writeable modules would be shared
                    // as well (store size in the ENGLOADMODULEHDR), but I don't think this case
                    // will happen very frequently so the benefit of doing this is very small.
                    //

                    wcscpy((PWSZ)pBaseAlloc, L"");
                }


                //
                // Setup the ENGLOADMODULEHDR
                //

                pelmNew->cRef = 1;
                pelmNew->cjSize = sizeof(ENGLOADMODULEHDR) + cjStringLength;

                //
                // Now add to the tracking list
                //

                if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

                InsertTailList(&GreEngLoadModuleAllocList, &(pelmNew->list));

                if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);
            }
            else
            {
                VFREEMEM(pBaseAlloc);
            }
        }
        VFREEMEM(usPath.Buffer);
    }

    return(hRet);
}

/*******************************************************************************
*  EngLoadModuleForWrite
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

HANDLE EngLoadModuleForWrite(PWSZ pwsz, ULONG cjSizeOfModule)
{
    return(LoadModuleWorkHorse(pwsz, cjSizeOfModule ? cjSizeOfModule : -1));
}

/*******************************************************************************
*  EngLoadModule
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

HANDLE EngLoadModule(PWSZ pwsz)
{
    return(LoadModuleWorkHorse(pwsz, 0));
}

/****************************************************************************
*  EngFreeModule()
*
*  History:
*   4/27/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

VOID EngFreeModule(HANDLE h)
{
    ULONG cRef;

    if (h)
    {
        ENGLOADMODULEHDR *pelmVictim = (ENGLOADMODULEHDR *) h;
        pelmVictim--;  // Now it points to the real ENGLOADMODULEHDR

        //
        // Enforce synchronization on the linked list
        //

        if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

        pelmVictim->cRef--; // Decrement reference count

        //
        // Remove resource if necessary.  Cache cRef in a local variable in case it gets
        // modified by another thread after we exit the critical section.
        //

        if ((cRef=pelmVictim->cRef) == 0)
        {
            RemoveEntryList(&(pelmVictim->list));
        }

        //
        // Restore IRQL level as soon as possible
        //

        if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);

        //
        // If removing resource still need to unmap file and free headers memory
        //

        if (cRef == 0)
        {
            //
            // Dereference section and unmap the file
            //
                vUnmapFile((FILEVIEW *)h);
            //
            // Free allocated memory
            //

            VFREEMEM (((PBYTE) h) - pelmVictim->cjSize);
        }
    }
}

/****************************************************************************
*  PVOID EngMapModule( HANDLE, PULONG )
*
*  History:
*   5/25/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

PVOID EngMapModule(HANDLE h, PULONG pSize)
{
    *pSize=((PFILEVIEW)h)->cjView;
    return(((PFILEVIEW)h)->pvKView);
}

/******************************Public*Routine******************************\
* BOOL EngMapFile
*
* Create or Open a file and map it into system space.  The file is extended or
* truncated according to the cjSize passed in.  If cjSize == 0, the file size
* is unchanged.  The view is always mapped on the entire file.
*
* Parameters
*     IN pwsz    - Name of the file to be mapped.
*                  Filename has to be fully qualified.  ex. L"\\??\\c:\\test.dat"
*     IN cjSize  - Size of the file.
*     OUT iFile  - identifier of the mapped file
*
* Return Value
*     Pointer to the memory view.
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
*  19-Nov-1998 -by- Lingyun Wang [lingyunw] changed interface
*
* Wrote it.
\**************************************************************************/

PVOID EngMapFile(PWSZ pwsz, ULONG cjSize, ULONG_PTR *piFile)
{
    FILEVIEW *pfv;
    PVOID ReturnValue = 0;

    if (pfv = (FILEVIEW*) PALLOCMEM(sizeof(FILEVIEW), 'lifG'))
    {
        if (bMapFile(pwsz, pfv, cjSize ? cjSize : -1, NULL))
        {
            *piFile = (ULONG_PTR)pfv;
            ReturnValue = pfv->pvKView;
        }
        else
        {
            *piFile = 0;
            VFREEMEM(pfv);
        }
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
* BOOL EngUnmapFile
*
* Unmap a view of file in system space
**
* Return Value
*     TRUE
*     FALSE
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

BOOL EngUnmapFile(ULONG_PTR iFile)
{
    NTSTATUS NtStatus;
    FILEVIEW *pfv = (FILEVIEW *)iFile;

    if (iFile)
    {
         #if defined(_GDIPLUS_)

             NtStatus = UnmapViewInProcessSpace(pfv->pvKView);

         #elif defined(_HYDRA_)
             // MmUnmapViewInSessionSpace is internally promoted to
             // MmUnmapViewInSystemSpace on non-Hydra systems.

             NtStatus = Win32UnmapViewInSessionSpace(pfv->pvKView);
         #else
             MmUnmapViewInSystemSpace(pfv->pvKView);
         #endif

         #if DBG && defined(_HYDRA_)
             if ((!G_fConsole) && (NT_SUCCESS(NtStatus)))
             {
                 DebugGreTrackRemoveMapView(pfv->pvKView);
             }
         #endif

         DEREFERENCE_FONTVIEW_SECTION(pfv->pSection);

         VFREEMEM(pfv);

         return(NT_SUCCESS(NtStatus));

    }
    else
    {
         return (FALSE);
    }

}



/******************************Public*Routine******************************\
* BOOL bIsOneHourDifference()
*
*
* History:
*  15-April-1999 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

// one tick is 100ns, us = 10 tick, s = 10*1000*1000 tick
// 1hr = 10*1000*1000*60*60

#define ONEHOUR   (10i64*1000i64*1000i64*60i64*60i64)

BOOL bIsOneHourDifference(FILEVIEW *pNew, FILEVIEW *pOld)
{
    LONGLONG   llDifference = pNew->LastWriteTime.QuadPart - pOld->LastWriteTime.QuadPart;

    if(llDifference < 0) llDifference = -llDifference;

    return (llDifference == ONEHOUR ? TRUE : FALSE);
}

/******************************Public*Routine******************************\
*
* bShouldMap // the font file
*
\**************************************************************************/

BOOL bShouldMap(FILEVIEW *pNew, FILEVIEW *pOld, BOOL bIsFAT)
{

    BOOL bMapRet = FALSE;

    if (pOld->LastWriteTime.QuadPart != 0) // file had been mapped in the past
    {
        if (pOld->cjView == pNew->cjView)
        {
        // we consider the new and the old times the "same" if they
        // are literally the same or if on the FAT system they differ by
        // 1 hour which we think is likely the result of the daylight
        // time saving change:

            if
            (
              (pOld->LastWriteTime.QuadPart == pNew->LastWriteTime.QuadPart) ||             
              (bIsFAT && bIsOneHourDifference(pNew, pOld))
              || gbGUISetup
            )
            {
                bMapRet = TRUE;
            }
        }
    }
    else // first time we are attempting to map this file
    {
        bMapRet = TRUE;
    }

    return(bMapRet);
}

/******************************Public*Routine******************************\
*
* bMapRoutine
*
\**************************************************************************/

BOOL bMapRoutine(FONTFILEVIEW *pffv, FILEVIEW *pfv, MAP_MODE Mode, BOOL bIsFAT)
{
    BOOL bKeepIt = bShouldMap(pfv, &pffv->fv, bIsFAT);

    if (bKeepIt)
    {
    //
    // This is the first time that this file has been mapped
    // OR  the file has not really changed since it was mapped
    // last time, however, because the time zone changed and
    // because of the bug in the
    // FAT file system, LastWriteTime is now reported different.

        if (Mode == ModeFD)
        {
            pffv->fv.pvViewFD = pfv->pvViewFD;
        }
        else
        {
            pffv->fv.pvKView = pfv->pvKView;
        }

        pffv->fv.cjView        = pfv->cjView;
        pffv->fv.LastWriteTime = pfv->LastWriteTime;
        pffv->fv.pSection      = pfv->pSection;
        pffv->fv.bLastUpdated  = TRUE;
    }
    else
    {
    // if the size or the time of the last write has changed
    // then someone has switched the file or tampered with it
    //  while we had it unlocked. We will fail the call.

        if (Mode == ModeFD)
        {
            pffv->cRefCountFD -= 1;
            pffv->fv.pvViewFD  = 0;
        }
        else
        {
            pffv->cKRefCount -= 1;   // Restore FONTFILEVIEW
            pffv->fv.pvKView  = 0;   // to original state
        }
        
        pffv->fv.bLastUpdated  = FALSE;
    }
    return(bKeepIt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\misceudc.cxx ===
/*********************************************************************************
 * misceudc.cxx
 *
 * This file contains EUDC specific methods for various GRE object.  I am moving
 * them to a separate file to make it easier to modify them after checkin freezes.
 * Once FE_SB ifdefs are removed we will probably want to move these object back
 * to the appropriate xxxobj.cxx files.
 *
 * 5-1-96 Gerrit van Wingerden [gerritv]
 *
 * Copyright (c) 1996-1999 Microsoft Corporation
 ********************************************************************************/

#include "precomp.hxx"

extern HSEMAPHORE ghsemEUDC2;

LONG lNormAngle(LONG lAngle);

/******************************Public*Routine******************************\
* GLYPHDATA *RFONTOBJ::pgdGetEudcMetrics()
*
*  9-29-1993 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::pgdGetEudcMetrics(WCHAR wc, RFONTOBJ* prfoBase)
{
    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache(prfoBase))
        {
            return(NULL);
        }
    }

    if (prfnt->wcgp->cRuns == 0)
    {
        WARNING("EUDC -- pgdGetEudcMetrics - empty glyphset\n");
        return pgdDefault();
    }

    GPRUN *pwcRun = prfnt->wcgp->agpRun; // initialize with guess for loop below

    GLYPHDATA *wpgd;

// Find the correct run, if any.
// Try the current run first.

    UINT swc = (UINT)wc - pwcRun->wcLow;
    if ( swc >= pwcRun->cGlyphs )
    {
        pwcRun = gprunFindRun(wc);

        swc = (UINT)wc - pwcRun->wcLow;

        if ( swc < pwcRun->cGlyphs )
        {
            wpgd = pwcRun->apgd[swc];
        }
        else
        {
            return(NULL);
        }
    }
    else
    {

    // Look up entry in current run
    // This path should go in line

        wpgd = pwcRun->apgd[swc];
    }

// check to make sure in cache, insert if needed

    if ( wpgd == NULL )
    {
    // This path should go out of line

        if ( !bInsertMetrics(&pwcRun->apgd[swc], wc) )
        {

        // when insert fails trying to get just metrics, it is a hard
        // failure.  Get out of here!

            WARNING("EUDC -- bGetGlyphMetrics - bInsertMetrics failed\n");
            return(NULL);
        }

        wpgd = pwcRun->apgd[swc];
    }

    return wpgd;
}

/******************************Public*Routine******************************\
* GLYPHDATA *RFONTOBJ::pgdGetEudcMetricsPlus()
*
*
*  9-29-1993 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::pgdGetEudcMetricsPlus
(
    WCHAR wc,
    RFONTOBJ*  prfoBase
)
{
    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache(prfoBase))
        {
            return(NULL);
        }
    }

    if (prfnt->wcgp->cRuns == 0)
    {
        WARNING("EUDC -- pgdGetEudcMetricsPlus - empty glyphset\n");
        return pgdDefault();
    }

    GPRUN *pwcRun = prfnt->wcgp->agpRun; // initialize with guess for loop below

    GLYPHDATA *wpgd;

// Find the correct run, if any.
// Try the current run first.

    UINT swc = (UINT)wc - pwcRun->wcLow;
    if ( swc >= pwcRun->cGlyphs )
    {
        pwcRun = gprunFindRun(wc);

        swc = (UINT)wc - pwcRun->wcLow;

        if ( swc < pwcRun->cGlyphs )
        {
            wpgd = pwcRun->apgd[swc];
        }
        else
        {
            return(NULL);
        }
    }
    else
    {

    // Look up entry in current run
    // This path should go in line

        wpgd = pwcRun->apgd[swc];
    }


// check to make sure in cache, insert if needed


    if ( wpgd == NULL )
    {

    // This path should go out of line

        if ( !bInsertMetricsPlus(&pwcRun->apgd[swc], wc) )
        {

        // when insert fails trying to get just metrics, it is a hard
        // failure.  Get out of here!

            WARNING("EUDC -- bGetGlyphMetricsPlus - bInsertMetrics failed\n");
            return(NULL);
        }

        wpgd = pwcRun->apgd[swc];
    }


// Don't bother inserting glyphs since we are going to force the driver to
// enum anyway.

    return wpgd;
}

/******************************Public*Routine******************************\
* RFONTOBJ::bCheckEudcFontCaps
*
* History:
*  9-Nov-93 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bCheckEudcFontCaps
(
    IFIOBJ  &ifioEudc
)
{
    // Check FontLink configuration.

    if( ulFontLinkControl & FLINK_DISABLE_LINK_BY_FONTTYPE )
    {

    // Fontlink for Device font is disabled ?

        if( bDeviceFont() )
        {
            if( ulFontLinkControl & FLINK_DISABLE_DEVFONT )
            {
                return(FALSE);
            }
        }
         else
        {

        // Fontlink for TrueType font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_TTFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_TRUETYPE   )    )
            {
                return( FALSE );
            }

        // Fontlink for Vector font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_VECTORFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_STROKE         )    )
            {
                return( FALSE );
            }

        // Fontlink for Bitmap font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_BITMAPFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_BITMAP         )    )
            {
                return( FALSE );
            }
        }
    }

    BOOL bRotIs90Degree;

// Can EUDC font do arbitarary tramsforms ?

    if( ifioEudc.bArbXforms() )
        return( TRUE );

// Can its Orientation degree be divided by 900 ?

    bRotIs90Degree = (prfnt->ulOrientation % 900) == 0;

// if the Orientation is 0, 90, 270, 360... and the EUDC font can be
// rotated by 90 degrees, we accept this link.

    if( ifioEudc.b90DegreeRotations() && bRotIs90Degree )
        return( TRUE );

// if not, we reject this link.

    return( FALSE );
}


/******************************Public*Routine******************************\
* IsSingularEudcGlyph
*
* History:
*
*  25-Jul-95 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

BOOL IsSingularEudcGlyph
(
    GLYPHDATA *wpgd, BOOL bSimulatedBold
)
{
//
// Determine this is really registerd EUDC glyph or not.
//
// [NT 3.51 code for reference]
//
//  if( wpgd->rclInk.left == 0 &&
//      wpgd->rclInk.top  == 0 &&
//      (wpgd->rclInk.right  == 0 || wpgd->rclInk.right  == 1) &&
//      (wpgd->rclInk.bottom == 0 || wpgd->rclInk.bottom == 1)
//    )
//      return( TRUE );
//
// This glyph does not have advance width, it might be non-registered
// character, then return TRUE to let replace this with EUDC default
// character.
//

// dchinn 5/12/99: The code used to use the bSimulatedBold flag.
// If bSimulatedBold were TRUE and if fxD == 0x10, then we return TRUE.
// That code is no longer needed because ClaudeBe made a change elsewhere
// to leave fxD as 0x00 when doing bold simulation.  So, the test below
// is correct whether or not bSimulatedBold is TRUE.

    if( wpgd->fxD == 0 ) return( TRUE );

//
// Otherwise, use this glyph.
//
    return( FALSE );
}

BOOL RFONTOBJ::bInitSystemTT(XDCOBJ &dco)
{
    UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);
    RFONTOBJ rfo;
    EUDCLOGFONT SystemTTLogfont;

    ComputeEUDCLogfont(&SystemTTLogfont, dco);

    PFE *ppfeSystem = (gappfeSystemDBCS[iPfeOffset] == NULL) ?
      gappfeSystemDBCS[PFE_NORMAL] : gappfeSystemDBCS[iPfeOffset];

    rfo.vInit(dco,ppfeSystem,&SystemTTLogfont,FALSE );

    if( rfo.bValid() )
    {
        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "vInitSystemTT() -- linking system DBCS font");

        prfnt->prfntSystemTT = rfo.prfntFont();

    }
    return(prfnt->prfntSystemTT != NULL);
}


GLYPHDATA *RFONTOBJ::FindLinkedGlyphDataPlus
(
    XDCOBJ  *pdco,
    ESTROBJ *pto,
    WCHAR    wc,
    COUNT    index,
    COUNT    c,
    BOOL    *pbAccel,
    BOOL     bSystemTTSearch,
    BOOL     bGetBits
)
{
    GLYPHDATA *wpgd;

    LONG *plPartition = pto ? pto->plPartitionGet() : NULL;

// don't setup system EUDC font if there are remote links

    if(!pdco->uNumberOfLinkedUFIs() && bSystemTTSearch && bIsSystemTTGlyph(wc))
    {
        if(!prfnt->prfntSystemTT)
        {
            WARNING("Error initializing TT system font 2\n");
            return(pgdDefault());
        }
        
        if(pto && !(pto->bSystemPartitionInit()))
        {
        // this call can't fail for the SystemTT case
            pto->bPartitionInit(c,0,FALSE);
        }

    // mark the glyph as coming from a SystemTT font

        RFONTTMPOBJ rfo;

        rfo.vInit(prfnt->prfntSystemTT);

        if(rfo.bValid() &&
           (wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this) : rfo.pgdGetEudcMetrics(wc, this)))
        {

            if (pto)
            {
                ASSERTGDI(pto->bSystemPartitionInit(),
                          "FindLinkedGlyphDataPlus: FontLink partition no initialized\n");

                pto->vTTSysGlyphsInc();
                plPartition[index] = EUDCTYPE_SYSTEM_TT_FONT;

            // turn off accelerator since we're going to mess with the driver

                *pbAccel = FALSE;
            }

            return(wpgd);
        }
         else
        {
            return(pgdDefault());
        }
    }

// next search through all the EUDC fonts in order to see if the glyph is one of them

    for( UINT uiFont = 0;
              uiFont < prfnt->uiNumLinks;
              uiFont ++ )
    {
        RFONTTMPOBJ rfo;

        rfo.vInit( prfnt->paprfntFaceName[uiFont] );

        if(rfo.bValid())
        {
            if( (wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                                : rfo.pgdGetEudcMetrics(wc, this)) != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD) )
                {

                    if (pto)
                    {
                        plPartition[index] = EUDCTYPE_FACENAME + uiFont;
                        pto->vFaceNameInc(uiFont);

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }

                    return( wpgd );
                }
            }
        }
    }

// see if the glyph is in the DEFAULT EUDC font

    if( prfnt->prfntDefEUDC != NULL )
    {
        RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );

        if (rfo.bValid())
        {
            wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                            : rfo.pgdGetEudcMetrics(wc, this);

            if( wpgd != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD) )
                {
                    if (pto)
                    {
                    // mark this character as an EUDC character

                        plPartition[index] = EUDCTYPE_DEFAULT;

                    // increment count of Sys EUDC glyphs

                        pto->vDefGlyphsInc();

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }

                    return( wpgd );
                }
            }
        }
    }

// see if the glyph is in the SYSTEM-WIDE EUDC font

    if( prfnt->prfntSysEUDC != NULL )
    {
        RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );

        if (rfo.bValid())
        {
            wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                            : rfo.pgdGetEudcMetrics(wc, this);

            if( wpgd != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD))
                {
                    if (pto)
                    {
                    // mark this character as an EUDC characte and indicate that there
                    // are EUDC glyphs in the font

                        plPartition[index] = EUDCTYPE_SYSTEM_WIDE;
                        pto->vSysGlyphsInc();

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }
                    return( wpgd );
                }
            }
        }
    }

    return( NULL );
}

/******************************Public*Routine******************************\
* RFONTOBJ::wpgdGetLinkMetricsPlus
*
* If GetGlyphMetricsPlus encounters a default character call off to this
* routine to try and get it from the EUDC and face name linked fonts.
*
* History:
*
*  19-Jan-95 -by- Hideyuki Nagase
* Rewrote it.
*
*  14-Jul-93 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::wpgdGetLinkMetricsPlus
(
    XDCOBJ      *pdco,
    ESTROBJ     *pto,
    WCHAR       *pwc,
    WCHAR       *pwcInit,
    COUNT        c,
    BOOL        *pbAccel,
    BOOL         bGetBits
)
{
    GLYPHDATA *wpgd;
    WCHAR *pwcCurrent = pwc;
    WCHAR *pwcEnd = pwcInit + c;

    // bLinkingTurnedOff forces linking to be turned off.  It will be TRUE
    // when we are printing an EMF file that originated on a machine that
    // had no fontlinking turned on

    if(pdco == NULL ||
       pdco->bLinkingTurnedOff() ||
       (!gbAnyLinkedFonts && !IS_SYSTEM_EUDC_PRESENT() && (pdco->uNumberOfLinkedUFIs() == 0)))
    {
        return(pgdDefault());
    }


    for (; (pwcCurrent < pwcEnd && (*pwcCurrent >= 0x80) && (*pwcCurrent <= 0x9F) ); pwcCurrent+=1)
    {
    }

    if (pwcCurrent == pwcEnd)
    {
        // all the characters are in the range 0x80 to 0x9F
        // we don't want to look through font linking for characters in that range

        // this is a performance issue to avoid calling font linking code on English system with 
        // far east language pack installed

        // client side caching is requesting through iGetPublicWidthTable() the width for ANSI codes
        // 0x00 to 0xFF, those code are converted to Unicode. Some code in the range 0x80->0x9F
        // are not converted and stay in that range causing the linked fonts to be loaded to look for those characters
        // Unicode in that range belong to the C1 controls, it doesn't make sense to look for them through
        // font linking, see Windows bug 157772.

        return(pgdDefault());
    }


    // always initialize the System TT to avoid a deadlock situation

    if (!pdco->uNumberOfLinkedUFIs() && prfnt->bIsSystemFont)
    {
        if((!prfnt->prfntSystemTT) && !bInitSystemTT(*pdco))
        {
            WARNING("Error initializing TT system font 4\n");
        }
        else
        {
            GreAcquireSemaphore(prfnt->hsemEUDC);
            
            if(!(prfnt->flEUDCState & TT_SYSTEM_INITIALIZED))
            {
                INCREMENTEUDCCOUNT;
                RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
                rfo.vGetCache();
    
                prfnt->flEUDCState |= TT_SYSTEM_INITIALIZED;
            }

            GreReleaseSemaphore(prfnt->hsemEUDC);
        }
    }

// if this is an SBCS system font and the glyph exists in the DBCS TT system front
// grab it from there

    if(!pdco->uNumberOfLinkedUFIs() && bIsSystemTTGlyph(*pwc))
    {
        if(!prfnt->prfntSystemTT)
        {
            WARNING("Invalid prfntSystemTT\n");
            return(pgdDefault());
        }

        if(pto && !(pto->bSystemPartitionInit()))
        {
        // this call can't fail for the SystemTT case
            pto->bPartitionInit(c,0,FALSE);
        }

    // mark the glyph as coming from a SystemTT font

        RFONTTMPOBJ rfo;

        rfo.vInit(prfnt->prfntSystemTT);

        if(rfo.bValid() &&
           (wpgd = (bGetBits ? rfo.pgdGetEudcMetricsPlus(*pwc, this)
                                : rfo.pgdGetEudcMetrics(*pwc, this))))
        {
            if (pto)
            {
                ASSERTGDI(pto->bSystemPartitionInit(),
                          "wpgdGetLinkMetricsPlus: FontLink partition no initialized\n");

                LONG *plPartition = pto->plPartitionGet();
                pto->vTTSysGlyphsInc();
                plPartition[pwc-pwcInit] = EUDCTYPE_SYSTEM_TT_FONT;

            // turn off accelerator since we're going to mess with the driver

                *pbAccel = FALSE;
            }

            return(wpgd);
        }
        else
        {
            return(pgdDefault());
        }
    }

// if the codepoint is not in any linked font or the EUDC information is
// being changed just return the default character

    if(!pdco->uNumberOfLinkedUFIs() &&!bIsLinkedGlyph( *pwc ))
    {
        return( pgdDefault() );
    }

    // initialize EUDC fonts if we haven't done so already
    {
        GreAcquireSemaphore(prfnt->hsemEUDC);

        if( !( prfnt->flEUDCState & EUDC_INITIALIZED ) )
        {

        // this value will be decremented in RFONTOBJ::dtHelper()

            INCREMENTEUDCCOUNT;

            FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,
                      "wpgdGetLinkMetricsPlus():No request to change EUDC data %d\n", gcEUDCCount);
    
            vInitEUDC( *pdco );

        // lock the font cache semaphores for any EUDC rfonts linked to this font

            if( prfnt->prfntSysEUDC != NULL )
            {
            // lock the SystemEUDC RFONT cache

                RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );
                rfo.vGetCache();
            }

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );
                rfo.vGetCache();
            }

            for( UINT ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfo( prfnt->paprfntFaceName[ii] );
                    rfo.vGetCache();
                }
            }

            prfnt->flEUDCState |= EUDC_INITIALIZED;

        }

        GreReleaseSemaphore(prfnt->hsemEUDC);
    }
    
    if (pto && !(pto->bPartitionInit()) )
    {
    // Sets up partitioning pointers and glyph counts in the ESTROBJ.

        if( !(pto->bPartitionInit(c,prfnt->uiNumLinks,TRUE)) )
        {
            return( pgdDefault() );
        }
    }

// Find linked font GLYPHDATA

    wpgd = FindLinkedGlyphDataPlus(
               pdco,pto,*pwc,(COUNT)(pwc-pwcInit),c,pbAccel,FALSE, bGetBits);

    if( wpgd == NULL )
    {
    // load EudcDefault Char GlyphData from "Base font".

        wpgd = bGetBits ?
               pgdGetEudcMetricsPlus(EudcDefaultChar, NULL) :
               pgdGetEudcMetrics(EudcDefaultChar, NULL);

        if( wpgd != NULL )
        {
            return( wpgd );
        }

    // load EudcDefault Char GlyphData from "Linked font".

        wpgd = FindLinkedGlyphDataPlus(pdco,pto,EudcDefaultChar,(COUNT)(pwc-pwcInit),c,pbAccel,TRUE, bGetBits);

        if( wpgd != NULL )
        {
            return( wpgd );
        }

    // Otherwise return default char of base font.

        return( pgdDefault() );
    }

    return( wpgd );
}

/******************************Public*Routine******************************\
 * RFONTOBJ::dtHelper()
 *
 *  Thu 12-Jan-1995 15:00:00 -by- Hideyuki Nagase [hideyukn]
 * Rewrote it.
 **************************************************************************/

VOID RFONTOBJ::dtHelper(BOOL bReleaseEUDC2)
{

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"Calling dtHelper()\n");

    GreAcquireSemaphore(prfnt->hsemEUDC);


// if SystemTT RFONTOBJ was used release it

    if((prfnt->flEUDCState & TT_SYSTEM_INITIALIZED) &&
       !(prfnt->flEUDCState & EUDC_NO_CACHE))
    {
        if (prfnt->prfntSystemTT)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
            rfo.vReleaseCache();
            DECREMENTEUDCCOUNT;
        }
    }

// if EUDC was initizlized for this RFONTOBJ, clean up its.

    if( prfnt->flEUDCState & EUDC_INITIALIZED )
    {

        if(!(prfnt->flEUDCState & EUDC_NO_CACHE))
        {
            for( INT ii = prfnt->uiNumLinks - 1; ii >= 0; ii-- )
            {
                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfo( prfnt->paprfntFaceName[ii] );
                    rfo.vReleaseCache();
                }
            }

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );
                rfo.vReleaseCache();
            }

            if( prfnt->prfntSysEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );
                rfo.vReleaseCache();
            }
        }

        if (bReleaseEUDC2)
        {
            ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0\n");
            DECREMENTEUDCCOUNT;
        }
    }

    prfnt->flEUDCState &= ~(EUDC_INITIALIZED|TT_SYSTEM_INITIALIZED|EUDC_NO_CACHE);

    GreReleaseSemaphore(prfnt->hsemEUDC);
    
}


/******************************************************************************
 * void RFONTOBJ::ComputeEUDCLogfont(EUDCLOGFONT*)
 *
 * This function computes an EUDCLOGFONT from a base font.
 *
 *****************************************************************************/


void RFONTOBJ::ComputeEUDCLogfont(EUDCLOGFONT *pEudcLogfont, XDCOBJ& dco)
{
    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    PFEOBJ pfeo(prfnt->ppfe);
    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);
    BOOL        bFixedPitch = FALSE;

    if (!lfo.bValid())
        return;

    pEudcLogfont->fsSelection    = ifio.fsSelection();
    pEudcLogfont->flBaseFontType = pfo()->flFontType;
    pEudcLogfont->lBaseHeight    = lfo.lHeight();
    pEudcLogfont->lBaseWidth     = lfo.lWidth();
    pEudcLogfont->lEscapement    = lfo.lEscapement();
    pEudcLogfont->ulOrientation  = lfo.ulOrientation();

    LONG  lInternalLeading = 0;

    if(ifio.bFixedPitch())
        bFixedPitch = TRUE;

// We have to try to scale linked font as exactly same size as base font.

    if( !(pEudcLogfont->bContinuousScaling = ifio.bContinuousScaling()) )
    {
        if (dco.pdc->bWorldToDeviceIdentity())
        {
        // We only need to get the AveCharWidth for FIX_PITCH

            if (bFixedPitch)
                pEudcLogfont->lBaseWidth  = ifio.fwdAveCharWidth();

        // these are special case hacks to get better linking with Ms San Serif
        // we force a bitmap for size 8 and 10 and also use ascent based
        // mapping for all other size.
        //
        // Old comment:
        //    for NT 5.0 make this more general
        //    and make it configurable in the registry.
        //

            if(!_wcsicmp(ifio.pwszFaceName(), L"Ms Sans Serif"))
            {

                if(fxMaxExtent() > LTOFX(12) && fxMaxExtent() < LTOFX(17))
                {
                    pEudcLogfont->lBaseHeight = 12;
                }
                else
                {
                    pEudcLogfont->lBaseHeight =
                      LONG_FLOOR_OF_FIX(fxMaxAscent() + FIX_HALF);
                }
            }

            else
            if(ulFontLinkControl & FLINK_SCALE_EUDC_BY_HEIGHT)
            {
                pEudcLogfont->lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxExtent() + FIX_HALF);
            }
            else
            {
                pEudcLogfont->lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxAscent() + FIX_HALF);
            }
        }
        else
        {
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efDtoWBase_31(),((LONG) ifio.fwdAveCharWidth()) << 4);

            if (ulFontLinkControl & FLINK_SCALE_EUDC_BY_HEIGHT)
            {
                pEudcLogfont->lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxExtent());
            }
            else
            {
                pEudcLogfont->lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxAscent());
            }
        }

    // Multiply raster interger scaling value.
    // (Only for Width, Height was already scaled value.)

        if (bFixedPitch)
            pEudcLogfont->lBaseWidth *= prfnt->ptlSim.x;

        FLINKMESSAGE(DEBUG_FONTLINK_DUMP,"GDISRV:BaseFont is RASTER font\n");
    }
    else
    {
        LONG    lBaseHeight;

        if (dco.pdc->bWorldToDeviceIdentity())
        {
            lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxExtent() + FIX_HALF);
        }
         else
        {
            lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxExtent());
        }

        if (lNonLinearIntLeading() == MINLONG)
        {
        // Rather than scaling the notional internal leading, try
        // to get closer to HINTED internal leading by computing it
        // as the difference between the HINTED height and UNHINTED
        // EmHeight.

            lInternalLeading = lBaseHeight - lCvt(efNtoWScaleAscender(),ifio.fwdUnitsPerEm());
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efNtoWScaleBaseline(), ifio.tmAveCharWidth());        
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            lInternalLeading =
            lCvt(efDtoWAscent_31(),lNonLinearIntLeading());
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efDtoWBase_31(), lNonLinearAvgCharWidth());        
        }

        // Check we should eliminate the internal leading for EUDC size.

        if( lInternalLeading < 0 )
            pEudcLogfont->lBaseHeight = lBaseHeight + lInternalLeading;
        else
            pEudcLogfont->lBaseHeight = lBaseHeight - lInternalLeading;

        if ((pEudcLogfont->lBaseHeight <= 13))
        {
            if (pEudcLogfont->lBaseHeight == 11 && lBaseHeight >= 12)
                pEudcLogfont->lBaseHeight = 12;
            else if (pEudcLogfont->lBaseHeight == 13 && lBaseHeight >= 15)
                pEudcLogfont->lBaseHeight = 15;
        }
    }


// if the base font is Raster font. we need to adjust escapement/orientation.
// because they can not generate arbitaraty rotated glyphs.

    if(!(ifio.bArbXforms()))
    {
        if( ifio.b90DegreeRotations() )
        {
        // font provider can support per 90 degree rotations.

            if( pEudcLogfont->ulOrientation )
            {
                ULONG ulTemp;
                ulTemp = lNormAngle(pEudcLogfont->ulOrientation);
                pEudcLogfont->ulOrientation =
                    (ulTemp / ORIENTATION_90_DEG) * ORIENTATION_90_DEG;

                if( (dco.pdc->bYisUp()) && (ulTemp % ORIENTATION_90_DEG))
                    pEudcLogfont->ulOrientation =
                        lNormAngle(pEudcLogfont->ulOrientation + ORIENTATION_90_DEG);
            }

            if( pEudcLogfont->lEscapement )
            {
                LONG lTemp;
                lTemp = lNormAngle(pEudcLogfont->lEscapement);
                pEudcLogfont->lEscapement =
                    (lTemp / ORIENTATION_90_DEG) * ORIENTATION_90_DEG;

                if( (dco.pdc->bYisUp()) && (lTemp % ORIENTATION_90_DEG))
                    pEudcLogfont->lEscapement =
                         lNormAngle(pEudcLogfont->lEscapement + ORIENTATION_90_DEG);
            }
        }
         else
        {
        // font provider can generate only horizontal glyph

            pEudcLogfont->ulOrientation = 0L;
            pEudcLogfont->lEscapement   = 0L;
        }
    }

    #if DBG
    if(gflEUDCDebug & DEBUG_FONTLINK_DUMP)
    {
        DbgPrint(" Base font face name %ws \n", ifio.pwszFaceName());
        DbgPrint("GDISRV:lBaseWidth  = %d\n",pEudcLogfont->lBaseWidth);
        DbgPrint("GDISRV:lBaseHeight = %d\n",pEudcLogfont->lBaseHeight);
        DbgPrint("GDISRV:lInternalL  = %d\n",lInternalLeading);
        DbgPrint("GDISRV:lEscapement  = %d\n",pEudcLogfont->lEscapement);
        DbgPrint("GDISRV:lOrientation = %d\n",pEudcLogfont->ulOrientation);
    }
    #endif
}


/******************************************************************************
 * PFE *ppfeFromUFI(PUNIVERSAL_FONT_ID pufi)
 *
 * Given a UFI, returns a corresponding PFE.  This function assume the caller
 * has grabed the ghsemPublicPFT semaphore.
 *
 *****************************************************************************/


PFE *ppfeFromUFI(PUNIVERSAL_FONT_ID pufi)
{
    PUBLIC_PFTOBJ pfto;
    FHOBJ fho(&pfto.pPFT->pfhUFI);
    HASHBUCKET  *pbkt;

    PFE         *ppfeRet = NULL;

    pbkt = fho.pbktSearch( NULL, (UINT*)NULL, pufi );

    if( pbkt != NULL )
    {
        PFELINK  *ppfel;

        for (ppfel = pbkt->ppfelEnumHead ; ppfel; ppfel = ppfel->ppfelNext)
        {
            PFEOBJ pfeo (ppfel->ppfe);

        // if the UFI's match and (in the case of a remote font) the process
        // that created the remote font is the same as the current one then
        // we've got a match

            if(UFI_SAME_FACE(pfeo.pUFI(),pufi) && pfeo.SameProccess())
            {
                if( pfeo.bDead() )
                {
                    WARNING("MAPPER::bFoundForcedMatch mapped to dead PFE\n");
                }
                else
                {
                    ppfeRet = ppfel->ppfe;
                    break;
                }
            }
        }

    #if DBG
        if (!ppfel)
        {
            WARNING1("ppfeFromUFI couldn't map to PFE\n");
        }
    #endif

    }
    else
    {
        WARNING("ppfeFromUFI pbkt is NULL\n");
    }

    return ppfeRet;
}


void RFONTOBJ::vInitEUDCRemote(XDCOBJ& dco)
{

#if DBG
    DbgPrint("calling remote vinit\n");
#endif // DBG

    if((prfnt->paprfntFaceName != NULL) &&
       (prfnt->paprfntFaceName[0] != NULL))
    {
    // If there is at least one facename link then the remote links must be initialized.
    // The set of links for a particular RFONT will never change during a print
    // job and the RFONT can only be used for this print-job (PDEV).  Thus we
    // don't have to check a time stamp or anything else to determine if the links
    // have changed and can simply return.

        return;
    }

// remote UFIs get treated as facename links so first initialize the facename array

    if(prfnt->paprfntFaceName == (PRFONT *)NULL)
    {
        if(dco.uNumberOfLinkedUFIs() > QUICK_FACE_NAME_LINKS)
        {
            if(!(prfnt->paprfntFaceName =
                 (PRFONT *)PALLOCMEM(dco.uNumberOfLinkedUFIs() * sizeof(PRFONT),'flnk')))
            {
                WARNING("vInitEUDCRemote: out of memory\n");
                return;
            }
        }
        else
        {
            prfnt->paprfntFaceName = prfnt->aprfntQuickBuff;
        }
    }

    prfnt->uiNumLinks = 0;

// Lock and Validate the LFONTOBJ user object.

    UINT u;
    PFEOBJ pfeo(prfnt->ppfe);
    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);

// Fill up LogFont for EUDC.

    EUDCLOGFONT EudcLogFont;

    ComputeEUDCLogfont(&EudcLogFont, dco);

    for(u = 0; u < dco.uNumberOfLinkedUFIs(); u++)
    {
        {
         // this set of brackets is to make sure the ppfref descructor gets called
            PFE *ppfe;
            PFFREFOBJ pffref;
            RFONTOBJ rfo;

#if DBG
            DbgPrint("Trying to get pfe %d\n", u);
#endif // DBG

            {
                SEMOBJ  so(ghsemPublicPFT);

                if(ppfe = ppfeFromUFI(&dco.pufiLinkedFonts()[u]))
                {
                    PFEOBJ  pfeo1(ppfe);
                    pffref.vInitRef(pfeo1.pPFF());
#if DBG
                    DbgPrint("Found it\n");
#endif // DBG
                }

            }

            if(ppfe)
            {
                rfo.vInit(dco, ppfe, &EudcLogFont, FALSE);

                if(rfo.bValid())
                {
#if DBG
                    DbgPrint("Got a valid RFONT ENTRY\n");
#endif // DBG
                    prfnt->paprfntFaceName[prfnt->uiNumLinks++] =
                      rfo.prfntFont();
                }
            }
        }
    }

#if DBG
    DbgPrint("done: font has %d remote links\n", prfnt->uiNumLinks);
#endif // DBG
}


/******************************Public*Routine******************************\
* RFONTOBJ::vInitEUDC( XDCOBJ )
*
* This routine is called during text out when the first character that isn't
* in the base font is encountered.  vInitEUDC will then realize any EUDC RFONTS
* (if they haven't already been realized on previous text outs) so that they
* can possibly be used if the character(s) are in the EUDC fonts.
*
*  Thu 12-Jan-1995 15:00:00 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInitEUDC( XDCOBJ& dco )
{

    if(dco.uNumberOfLinkedUFIs())
    {
        vInitEUDCRemote(dco);
        return;
    }

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                 "Calling vInitEUDC()\n");

// If we have already initialized System EUDC font, and NOT have
// any FaceName Linked font, we have nothing to do in this function.

    PFEOBJ pfeo(prfnt->ppfe);

// In most cases, we have the system EUDC font, at least.
// If the system eudc was initizlied, we might short-cut the eudc realization.

    if((prfnt->prfntSysEUDC != NULL) || (!IS_SYSTEM_EUDC_PRESENT()))
    {
    // if default eudc scheme is disabled or is already initizlied. we can
    // short-cut the realization.

        if((!bFinallyInitializeFontAssocDefault && !gbSystemDBCSFontEnabled) ||
           (prfnt->prfntDefEUDC != NULL) )
        {
        // if there is no facename eudc for this font or, is already initizlied
        // we can return here...

            if((pfeo.pGetLinkedFontEntry() == NULL) ||
               ((prfnt->paprfntFaceName != NULL) &&
                (pfeo.pGetLinkedFontEntry() != NULL) &&
                (prfnt->bFilledEudcArray == TRUE) &&
                (prfnt->ulTimeStamp == pfeo.ulGetLinkTimeStamp())))
            {
                return;
            }
        }
    }

// Lock and Validate the LFONTOBJ user object.

    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);

// Fill up LogFont for EUDC.

    EUDCLOGFONT EudcLogFont;

    ComputeEUDCLogfont(&EudcLogFont, dco);

// first handle the system EUDC font

    UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);

    if((prfnt->prfntSysEUDC == NULL) &&
       (gappfeSysEUDC[iPfeOffset] != NULL))
    {
        RFONTOBJ    rfo;
        PFEOBJ      pfeoEudc(gappfeSysEUDC[iPfeOffset]);
        IFIOBJ      ifioEudc(pfeoEudc.pifi());

         FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                      "Connecting System wide EUDC font....\n");

    // check Eudc font capacity

        if(!bCheckEudcFontCaps(ifioEudc))
        {
        // font capacity is not match we won't use system eudc.

            prfnt->prfntSysEUDC = (RFONT *)NULL;
        }
        else
        {
            rfo.vInit( dco,
                       gappfeSysEUDC[iPfeOffset],
                       &EudcLogFont,
                       FALSE );      // prfnt->cache.bSmallMetrics );

            if( rfo.bValid() )
            {
                FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                             "vInitEUDC() -- linking System EUDC\n");

                prfnt->prfntSysEUDC = rfo.prfntFont();
            }
        }
    }

// next handle default links

    if(bFinallyInitializeFontAssocDefault && (prfnt->prfntDefEUDC == NULL))
    {
        BYTE jWinCharSet        = (ifio.lfCharSet());
        BYTE jFamily            = (ifio.lfPitchAndFamily() & 0xF0);
        UINT iIndex             = (jFamily >> 4);
        BOOL bEnableDefaultLink = FALSE;

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "Connecting Default EUDC font....\n");

    // Check default font association is disabled for this charset or not.

        switch (jWinCharSet)
        {
        case ANSI_CHARSET:
        case OEM_CHARSET:
        case SYMBOL_CHARSET:
            //
            // following code is equal to
            //
            // if ((Char == ANSI_CHARSET   && fFontAssocStatus & ANSI_ASSOC)  ||
            //     (Char == OEM_CHARSET    && fFontAssocStatus & OEM_ASSOC)   ||
            //     (Char == SYMBOL_CHARSET && fFontAssocStatus & SYMBOL_ASSOC)  )
            //
            if( ((jWinCharSet + 2) & 0xf) & fFontAssocStatus )
            {
                bEnableDefaultLink = TRUE;
            }
             else
                bEnableDefaultLink = FALSE;
            break;

        default:
            bEnableDefaultLink = FALSE;
            break;
        }

        if( bEnableDefaultLink )
        {
        // Check the value is valid or not.

            if( iIndex < NUMBER_OF_FONTASSOC_DEFAULT )
            {
                ASSERTGDI( (FontAssocDefaultTable[iIndex].DefaultFontType == jFamily),
                            "GDISRV:FONTASSOC DEFAULT:Family index is wrong\n");

            // if the registry data for specified family's default is ivalid
            // use default.....

                if( !FontAssocDefaultTable[iIndex].ValidRegData )
                {
                    iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
                }
            }
             else
            {
            // iIndex is out of range, use default one....

                WARNING("GDISRV:FontAssoc:Family is strange, use default\n");

                iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
            }


        // If vertical font is selected for base font, but the vertical font for
        // default EUDC is not available, but normal font is provided, use normal
        // font.

            if((iPfeOffset == PFE_VERTICAL) &&
               (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] ==
                PPFENULL) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] != PPFENULL))
            {
                iPfeOffset = PFE_NORMAL;
            }

            RFONTOBJ    rfo;
            PFEOBJ pfeoEudc(FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset]);

        // Check the PFE in default table is valid or not.

            if( pfeoEudc.bValid() )
            {
                IFIOBJ      ifioEudc(pfeoEudc.pifi());

                if( !bCheckEudcFontCaps(ifioEudc) )
                {
                    prfnt->prfntDefEUDC = (RFONT *)NULL;
                }
                 else
                {
                    rfo.vInit( dco,
                               FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset],
                               &EudcLogFont,
                               FALSE );      // prfnt->cache.bSmallMetrics );

                    if( rfo.bValid() )
                    {
                        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                                     "vInitEUDC() -- linking default EUDC\n");

                        prfnt->prfntDefEUDC = rfo.prfntFont();
                    }
                }
            }
        }
        else
        {
        // FontAssociation is disabled for this charset.

            prfnt->prfntDefEUDC = (RFONT *)NULL;
        }
    }
    else
    {
        prfnt->prfntDefEUDC = NULL;
    }

// next handle all the face name links

    if(pfeo.pGetLinkedFontEntry() != NULL)
    {
        BOOL bNeedToBeFilled = !(prfnt->bFilledEudcArray);

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"Connecting Face name EUDC font....\n");

        //
        // if this RFONT has linked RFONT array and its linked font information
        // is dated, just update it here..
        //

        if((prfnt->paprfntFaceName != NULL) &&
           (prfnt->ulTimeStamp != pfeo.ulGetLinkTimeStamp()))
        {
            FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                         "vInitEUDC():This RFONT is dated, now updating...\n");

            //
            // Inactivating old linked RFONT.
            //
            // if Eudc font that is linked to this RFONT was removed, the removed
            // RFONT entry contains NULL, and its Eudc RFONT is already killed during
            // EudcUnloadLinkW() function. then we should inactivate all Eudc RFONT that
            // is still Active (Not Killed)..
            //

            for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
            {
                //
                // Check Eudc RFONT is still active..
                //

                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfoTmp( prfnt->paprfntFaceName[ii] );

                    #if DBG
                    if( gflEUDCDebug & DEBUG_FONTLINK_RFONT )
                    {
                        DbgPrint("vInitEUDC() deactivating linked font %x\n",
                                  prfnt->paprfntFaceName[ii]);
                    }
                    #endif

                    rfoTmp.bMakeInactiveHelper((PRFONT *)NULL);

                    prfnt->paprfntFaceName[ii] = NULL;
                }
            }

            //
            // Free this Array if it was allocated..
            //

            if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                VFREEMEM( prfnt->paprfntFaceName );

            //
            // Invalidate the pointer.
            //

            prfnt->paprfntFaceName = (PRFONT *)NULL;
            prfnt->uiNumLinks      = 0;
        }

        if( prfnt->paprfntFaceName == (PRFONT *)NULL )
        {
            if(pfeo.pGetLinkedFontEntry()->uiNumLinks > QUICK_FACE_NAME_LINKS)
            {
                prfnt->paprfntFaceName =
                  (PRFONT *)PALLOCMEM(pfeo.pGetLinkedFontEntry()->uiNumLinks *
                                      sizeof(PRFONT),'flnk');
            }
             else
            {
                prfnt->paprfntFaceName = prfnt->aprfntQuickBuff;
            }

            bNeedToBeFilled = TRUE;
        }

        if( bNeedToBeFilled )
        {
            PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;
            UINT        uiRfont = 0;

            while( p != pfeo.pGetLinkedFontList() )
            {
                #if DBG
                if( gflEUDCDebug & DEBUG_FONTLINK_RFONT )
                {
                    DbgPrint("vInitEUDC() -- linking FaceName %d\n", uiRfont);
                }
                #endif

                PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

                //
                // Check this linked font have Vertical facename or not,
                // if it doesn't have, use normal facename...
                //

                UINT iPfeOffsetLocal;

                if( ppfeData->appfe[iPfeOffset] == NULL )
                    iPfeOffsetLocal = PFE_NORMAL;
                 else
                    iPfeOffsetLocal = iPfeOffset;

                PFEOBJ   pfeoEudc(ppfeData->appfe[iPfeOffsetLocal]);
                IFIOBJ   ifioEudc(pfeoEudc.pifi());

                if( bCheckEudcFontCaps(ifioEudc) )
                {
                    RFONTOBJ rfo;

                    rfo.vInit( dco,
                               ppfeData->appfe[iPfeOffsetLocal],
                               &EudcLogFont,
                               FALSE );        // prfnt->cache.bSmallMetrics );

                    if( rfo.bValid() )
                    {
                        ASSERTGDI(uiRfont < pfeo.pGetLinkedFontEntry()->uiNumLinks ,
                                 "uiRfont >= pfeo.uiNumLinks\n");
                        prfnt->paprfntFaceName[uiRfont] = rfo.prfntFont();

                        //
                        // Increase real linked font number.
                        //

                        uiRfont++;
                    }
                }

                p = p->Flink;
            }


            prfnt->uiNumLinks = uiRfont;

            prfnt->ulTimeStamp = pfeo.ulGetLinkTimeStamp();

            prfnt->bFilledEudcArray = TRUE;
        }
    }
    else
    {
    // if this PFE has no eudc link list..
    // the pointer to linked RFONT array should be NULL.

        ASSERTGDI(prfnt->paprfntFaceName == NULL,
                  "vInitEUDC():The font has not linked font, but has its Array\n");
    }

    #if DBG
    if(gflEUDCDebug & DEBUG_FONTLINK_DUMP) lfo.vDump();
    #endif
}

/******************************Public*Routine******************************\
* RFONTOBJ::vInit (DCOBJ, PFE*, LONG, FIX)
*
* This is a special constructor used for EUDC fonts.  Rather than use the
* LOGFONT currently selected into the DC to map to a PFE, it is passed in
* a PFE.  If lBaseWidth of lBaseHeight is non-zero vInit will try to realize a
* font with width and height as close as possible to those lBaseWidth/Height.
*
*  Tue 24-Oct-1995 12:00:00 -by- Hideyuki Nagase [hideyukn]
* Rewrote it.
*
*  Thu 23-Feb-1995 10:00:00 -by- Hideyuki Nagase [hideyukn]
* SmallMetrics support.
*
*  Fri 25-Mar-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInit(
    XDCOBJ      &dco,
    PFE         *ppfeEUDCFont,
    EUDCLOGFONT *pEudcLogFont,
    BOOL         bSmallMetrics
    )
{
    SEMOBJ  sem(ghsemEUDC2);
        
    BOOL bNeedPaths = dco.pdc->bActive() ? TRUE : FALSE;

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"gdisrv!vInit():Initializing EUDC font.\n");

    ASSERTGDI(bSmallMetrics == FALSE,"gdisrv!bSmallMetrics is 1 for EUDC font\n");

    BOOL bRet = FALSE;

// Get PDEV user object (need for bFindRFONT).
// This must be done before the ghsemPublicPFT is locked down.

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!RFONTOBJ(dco): bad pdev in dc\n");

// Lock and Validate the LFONTOBJ user object.

    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

// Now we're ready to track down this RFONT we want...
// Compute the Notional to Device transform for this realization.

    PFEOBJ  pfeo(ppfeEUDCFont);
    IFIOBJ  ifio(pfeo.pifi());

    ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

// Set bold and italic simulation flags if neccesary

    FLONG flSim = 0;

// if base font is originally italialized or simulated, we
// also generate italic font.

    if ( (pEudcLogFont->flBaseFontType & FO_SIM_ITALIC) ||
         (pEudcLogFont->fsSelection    & FM_SEL_ITALIC)    )
    {
        flSim |= lfo.flEudcFontItalicSimFlags(ifio.bNonSimItalic(),
                                              ifio.bSimItalic());
    }

// If the basefont is BMP font then we only embolden the linked font for Display
// If the basefont is scalable then we embolden linked font at any device.

    if ( (pdo.bDisplayPDEV() || pEudcLogFont->bContinuousScaling) &&
         ((pEudcLogFont->fsSelection & FM_SEL_BOLD) ||
         (pEudcLogFont->flBaseFontType & FO_SIM_BOLD)))
    {
        flSim |= lfo.flEudcFontBoldSimFlags((USHORT)ifio.lfWeight());
    }

//
//
//  We won't set bold simulation flag to font driver.
//  This is for following situation.
// if the base font is FIXED_PITCH font, and enbolden, then
// we need to scale EUDC font as same width of based font.
// but font enbolden simulation is depend on the font driver, we
// might not get exact same witdh of scaled eudc font.
//

//
// this is needed only by ttfd to support win31 hack: VDMX XFORM QUANTIZING
// NOTE: in the case that the requested height is 0 we will pick a default
// value which represent the character height and not the cell height for
// Win 3.1 compatibility.  Thus I have he changed this check to be <= 0
// from just < 0. [gerritv]
//
    if (ifio.bTrueType() && (lfo.plfw()->lfHeight <= 0))
        flSim |= FO_EM_HEIGHT;

// Now we need to check if the base font is going to be antialiased,
// if so we also want to antialias the linked font, if it is capable of it

    if ((pEudcLogFont->flBaseFontType & FO_GRAY16) && (pfeo.pifi()->flInfo & FM_INFO_4BPP))
    {
        flSim |= (pEudcLogFont->flBaseFontType & (FO_GRAY16 | FO_CLEARTYPE_X));
    }

// Hack the width of the logfont to get same width of eudc font as base font.

    LONG lWidthSave         = lfo.lWidth( pEudcLogFont->lBaseWidth );
    LONG lHeightSave        = lfo.lHeight( pEudcLogFont->lBaseHeight );
    ULONG ulOrientationSave = lfo.ulOrientation( pEudcLogFont->ulOrientation );
    ULONG lEscapementSave   = lfo.lEscapement( pEudcLogFont->lEscapement );

    FD_XFORM fdx;           // realize with this notional to device xform
    POINTL   ptlSim;        // for bitmap scaling simulations

    if (!ifio.bContinuousScaling())
    {
        WARNING("EUDC font could not be ContinuousScaling\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }
     else
    {
        ptlSim.x = 1; ptlSim.y = 1; // this will be not used for scalable font...
    }

    bRet = pfeo.bSetFontXform(dco, lfo.plfw(), &fdx,
                              0,
                              flSim,
                              (POINTL* const) &ptlSim,
                              ifio,
                              TRUE  // font is linked
                             );

// if bSetFontXform() was fail, return here....

    if( !bRet )
    {
        lfo.lWidth( lWidthSave );
        lfo.lHeight( lHeightSave );
        lfo.ulOrientation( ulOrientationSave );
        lfo.lEscapement( lEscapementSave );
        WARNING("gdisrv!RFONTOBJ(dco): failed to compute font transform\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

// Tell PFF about this new reference, and then release the global sem.
// Note that vInitRef() must be called while holding the semaphore.

    PFFREFOBJ pffref;
    {
        SEMOBJ  so(ghsemPublicPFT);
        pffref.vInitRef(pfeo.pPFF());
    }

// go find the font

    EXFORMOBJ xoWtoD(dco.pdc->mxWorldToDevice());
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!RFONTOBJ(dco) - \n");

// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if ( bFindRFONT(&fdx,
                    flSim,
                    0, // lfo.pelfw()->elfStyleSize,
                    pdo,
                    &xoWtoD,
                    ppfeEUDCFont,
                    bNeedPaths,
                    dco.pdc->iGraphicsMode(),
                    bSmallMetrics,

                    RFONT_TYPE_UNICODE  // must be unicode for EUDC
                    ) )
    {

        FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,"EUDC RFONT is %x\n",prfnt);

    // now restore the old width

        lfo.lWidth( lWidthSave );
        lfo.lHeight( lHeightSave );
        lfo.ulOrientation( ulOrientationSave );
        lfo.lEscapement( lEscapementSave );

    // Grab cache semaphore.

        vGetCache();
        dco.pdc->vXformChange(FALSE);

        return;
    }

// If we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.

    bRet = bRealizeFont(&dco,
                        &pdo,
                        lfo.pelfw(),
                        ppfeEUDCFont,
                        &fdx,
                        (POINTL* const) &ptlSim,
                        flSim,
                        0, // lfo.pelfw()->elfStyleSize,
                        bNeedPaths,
                        bSmallMetrics,
                        RFONT_TYPE_UNICODE
                       );
// now restore the old width

    lfo.lWidth( lWidthSave );
    lfo.lHeight( lHeightSave );
    lfo.ulOrientation( ulOrientationSave );
    lfo.lEscapement( lEscapementSave );


    if( !bRet )
    {
        WARNING("gdisrv!RFONTOBJ(dco): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

    ASSERTGDI(bValid(), "gdisrv!RFONTOBJ(dco): invalid hrfnt from realization\n");

// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Finally, grab the cache semaphore.

    vGetCache();
    dco.pdc->vXformChange(FALSE);

    FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,"EUDC RFONT is %x\n",prfnt);

    return;
}

/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bIsLinkedGlyph (WCHAR wc)
*
* Does a quick check to see if a character is in either the system EUDC
* font or a font that has been linked to this RFONT.
*
*  Tue 17-Jan-1995 14:00:00 -by- Hideyuki Nagase [hideyukn]
* Rewrote it.
*
*  Wed 11-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#define IS_PRIVATE_EUDC_AREA(wc) \
        (((wc) >= 0xE000) && ((wc) <= 0xF8FF))

BOOL RFONTOBJ::bIsLinkedGlyph( WCHAR wc )
{
    GreAcquireSemaphore( ghsemEUDC1 );

// we don't release ghsemEUDC1 mutex here, we have to guard the current eudc
// link data. All of the API that change eudc data, try to hold this
// mutex, if we hold it, nobody can process the request...
//
// if another thread will change eudc link between this thread is in after
// release the mutex (end of this function) and before we increment gcEUDCCount
// in vInitEUDC(). In the case, this function might return TRUE for non-linked
// char or return FALSE for linked char, but we don't need to worry about this.
// because following line in wpgdGetLinkMetricsPlus() will returns NULL and
// we will return default char. the cost is only time..

    BOOL bRet = FALSE;

// EudcDefaultChar should be displayed for 'Private User Area', when there is no
// font are linked. (font's default character should not be came up).

    if( IS_PRIVATE_EUDC_AREA(wc) )
    {
        bRet = TRUE;
    }

    if( (bRet == FALSE) && IS_SYSTEM_EUDC_PRESENT() && IS_IN_SYSTEM_EUDC(wc) )
    {
        bRet = TRUE;
    }

    if( (bRet == FALSE) && bFinallyInitializeFontAssocDefault )
    {
        //
        // THIS CODEPATH SHOULD BE OPTIMIZED....
        //
        // UNDER_CONSTRUCTION.
        //
        UINT   iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);
        PFEOBJ pfeo(prfnt->ppfe);
        IFIOBJ ifio(pfeo.pifi());
        BYTE   jFamily = (ifio.lfPitchAndFamily() & 0xF0);
        UINT   iIndex  = (jFamily >> 4);

        //
        // Check the value is valid or not.
        //
        if( iIndex < NUMBER_OF_FONTASSOC_DEFAULT )
        {
            ASSERTGDI( (FontAssocDefaultTable[iIndex].DefaultFontType == jFamily),
                        "GDISRV:FONTASSOC DEFAULT:Family index is wrong\n");

            //
            // if the registry data for specified family's default is ivalid
            // use default.....
            //
            if( !FontAssocDefaultTable[iIndex].ValidRegData )
            {
                iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
            }
        }
         else
        {
            //
            // iIndex is out of range, use default..
            //
            WARNING("GDISRV:FontAssoc:Family is strange, use default\n");

            iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
        }

        //
        // If vertical font is selected for base font, but the vertical font for
        // default EUDC is not available, but normal font is provided, use normal
        // font.
        //
        if( (iPfeOffset == PFE_VERTICAL) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] == PPFENULL) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL]   != PPFENULL))
        {
            iPfeOffset = PFE_NORMAL;
        }

        PFEOBJ      pfeoEudc(FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset]);

        //
        // Check the PFE in default table is valid or not.
        //
        if( pfeoEudc.bValid() )
        {
            if( IS_IN_FACENAME_LINK( pfeoEudc.pql(), wc ))
            {
                bRet = TRUE;
            }
        }
    }
    else
    if(gbSystemDBCSFontEnabled)
    {
        PFEOBJ pfeo(prfnt->ppfe);

        if(pfeo.bSBCSSystemFont())
        {
        // we assume that the set of glyphs is the same for the vertical and
        // non vertical PFE's so for simplicity always use the normal pfe.

            PFEOBJ pfeSystemDBCSFont(gappfeSystemDBCS[PFE_NORMAL]);

            ASSERTGDI(pfeSystemDBCSFont.bValid(),
                      "bIsLinkedGlyph: invalid SystemDBCSFont pfe\n");

            if(IS_IN_FACENAME_LINK(pfeSystemDBCSFont.pql(),wc))
            {
                bRet = TRUE;
            }
        }
    }

// Walk through FaceName link list if we haven't found it yet.

    if( bRet == FALSE )
    {
        //
        // Is this a FaceName EUDC character ?
        //
        UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);

        PFEOBJ pfeo(prfnt->ppfe);
        PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;

        //
        // Scan the linked font list for this base font.
        //

        while( p != pfeo.pGetLinkedFontList() )
        {
            PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

            //
            // Check this linked font have Vertical facename or not,
            // if it doesn't have, use normal facename...
            //

            UINT iPfeOffsetLocal;

            if( ppfeData->appfe[iPfeOffset] == NULL )
                iPfeOffsetLocal = PFE_NORMAL;
             else
                iPfeOffsetLocal = iPfeOffset;

            PFEOBJ   pfeoEudc(ppfeData->appfe[iPfeOffsetLocal]);

            ASSERTGDI( pfeoEudc.pql() != NULL ,
                      "bIsLinkedGlyph() pfeoEudc.pql() == NULL\n" );

            if(IS_IN_FACENAME_LINK( pfeoEudc.pql(), wc ))
            {
                bRet = TRUE;
                break;
            }

            p = p->Flink;
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );

    return(bRet);
}






/******************************Public*Routine******************************\
* BOOL STROBJ_bEnumLinked (pstro,pc,ppgpos)
*
* The glyph enumerator.
*
* History:
*  Tue 28-Sep-1993 11:37:00 -by- Gerrit van Wingerden
* Converted to a special helper function to handle linked fonts.
*
*  Tue 17-Mar-1992 10:35:05 -by- Charles Whitmer [chuckwh]
* Simplified it and gave it the quick exit.  Also let drivers call here
* direct.
*
*  02-Oct-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STROBJ_bEnumLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos)
{
// Quick exit.

    if( peso->cgposCopied == 0 )
    {
        for( peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            *(peso->plNext) != peso->lCurrentFont;
            (peso->pgpNext)++, (peso->plNext)++ );
        {
        }
    }
    else
    {
       if( peso->cgposCopied == peso->cGlyphs )
       {
        // no more glyphs so just return
            *pc = 0;
            return(FALSE);
       }
       else
       {
        // find next glyph

            for( (peso->plNext)++, (peso->pgpNext)++;
                 *(peso->plNext) != (peso->lCurrentFont);
                 (peso->pgpNext)++, (peso->plNext)++ );
            {
            }
       }
    }

    if (peso->prfo == NULL)  // check for journaling
    {
        WARNING("ESTROBJ::bEnum(), bitmap font, prfo == NULL\n");
        *pc = 0;
        return(FALSE);
    }

    if( peso->prfo->cGetGlyphData(1,peso->pgpNext) == 0 )
    {
        WARNING("couldn't get glyph for some reason\n");
        *pc = 0;
        return(FALSE);
    }

    peso->cgposCopied += 1;     // update enumeration state
    *pc = 1;
    *ppgpos = peso->pgpNext;

    return(peso->cgposCopied < peso->cGlyphs);  // TRUE => more to come.
}

/******************************Public*Routine******************************\
* VOID ESTROBJ fxBaseLineAdjust( _fxBaseLineAdjust )
*
* History:
*  24-Dec-1993 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::ptlBaseLineAdjustSet( POINTL& _ptlBaseLineAdjust )
{
    INT ii;
    UINT uFound;

    ptlBaseLineAdjust = _ptlBaseLineAdjust;

    if( !(ptlBaseLineAdjust.x || ptlBaseLineAdjust.y) )
        return;

    for( ii = 0,uFound = 0 ; uFound < cGlyphs ; ii++ )
    {
        if( plPartition[ii] == lCurrentFont )
        {
            pgpos[ii].ptl.x += ptlBaseLineAdjust.x;
            pgpos[ii].ptl.y += ptlBaseLineAdjust.y;
            uFound++;
        }
    }
}

/******************************Public*Routine******************************\
* BOOL ESTROBJ bPartitionInit( c, uiNumLinks )
*
* History:
*  29-Nov-1995 -by- Hideyuki Nagase
* Add initialize for FaceNameGlyphs array.
*
*  29-Sep-1993 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bPartitionInit(COUNT c, UINT uiNumLinks, BOOL bEudcInit)
{

// Always initialize at least for the SystemTTEUDC Font.  We can't initialize
// the EUDC specific stuff until we've called RFONTOBJ::vInitEUDC, something
// we won't do when just outputing System DBCS glyphs

// the first thing we should do is clear the SO_ZERO_BEARINGS and
// SO_CHAR_INC_EQUAL_BM_BASE flags in the TEXOBJ since this will turn
// off potentially fatal optimizations in the H3 case.

    flAccel &= ~(SO_CHAR_INC_EQUAL_BM_BASE|SO_ZERO_BEARINGS);

    if(!(flTO & TO_SYS_PARTITION))
    {
        plPartition = (LONG*) &pgpos[c];
        pwcPartition = (WCHAR*) &plPartition[c];
        RtlZeroMemory((VOID*)plPartition, c * sizeof(LONG));
        pacFaceNameGlyphs = NULL;

        cSysGlyphs = 0;
        cDefGlyphs = 0;
        cTTSysGlyphs = 0;

        flTO |= TO_SYS_PARTITION;
    }

    if(bEudcInit)
    {
        if( uiNumLinks >= QUICK_FACE_NAME_LINKS )
        {
            pacFaceNameGlyphs = (ULONG *) PALLOCMEM(uiNumLinks * sizeof(UINT),'flnk');

            if (pacFaceNameGlyphs == (ULONG *) NULL)
            {
            // if we fail allocate memory, we just cancel eudc output.
                return (FALSE);
            }

            flTO |= TO_ALLOC_FACENAME;
        }
        else
        {
            pacFaceNameGlyphs = acFaceNameGlyphs;
            RtlZeroMemory((VOID*) pacFaceNameGlyphs, uiNumLinks * sizeof(UINT));
        }

        flTO |= TO_PARTITION_INIT;
    }

    return (TRUE);
}


/****************************************************************************
* RFONTOBJ::GetLinkedFontUFIs
*
* This routine returns the UFI's for the font(s) that are linked to this
* RFONT.  If pufi is NULL, simply returns the number of UFI's linked to
* this RFONT.
*
*****************************************************************************/

INT RFONTOBJ::GetLinkedFontUFIs(XDCOBJ& dco, PUNIVERSAL_FONT_ID pufi, INT NumUFIs)
{
    UINT u;
    INT UFICount = 0;

// check pui

    if (NumUFIs && pufi == NULL)
    {
        WARNING("RFONTOBJ::GetLinkedFontUFIs() pufi == NULL but NumUFIs != 0\n");
        return (0);
    }

// initialize system TT font if applicable

    if(prfnt->bIsSystemFont)
    {
        if((!prfnt->prfntSystemTT) && !bInitSystemTT(dco))
        {
            WARNING("Error initializing TT system font 5\n");
            return(0);
        }
        prfnt->flEUDCState |= EUDC_NO_CACHE;
    }

// initialize EUDC fonts if we haven't done so already

    {
        GreAcquireSemaphore(prfnt->hsemEUDC);
        
        if( !( prfnt->flEUDCState & EUDC_INITIALIZED ) )
        {
        // this value will be decremented in RFONTOBJ::dtHelper()

            INCREMENTEUDCCOUNT;

            vInitEUDC(dco);
            prfnt->flEUDCState |= (EUDC_INITIALIZED | EUDC_NO_CACHE);
        }

        GreReleaseSemaphore(prfnt->hsemEUDC);
    }
    
    if(prfnt->prfntSystemTT)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    for(u = 0; u < prfnt->uiNumLinks; u++)
    {
        ASSERTGDI(prfnt->paprfntFaceName[u],"GDI:uGetLinkedFonts: null facename font\n");

        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->paprfntFaceName[u]);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    if(prfnt->prfntDefEUDC)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntDefEUDC);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    if(prfnt->prfntSysEUDC)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSysEUDC);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    return(UFICount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\muclean.cxx ===
/******************************Module*Header*******************************\
* Module Name: muclean.cxx
*
* Cleanup module for WIN32K.SYS GRE
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#include "muclean.hxx"
#include "verifier.hxx"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * External variables we must cleanup
 */

// hmgrapi.cxx
extern PLARGE_INTEGER gpLockShortDelay;
extern PVOID *gpTmpGlobalFree;
extern PVOID gpTmpGlobal;
extern "C" HFASTMUTEX ghfmMemory;
extern PVOID  gpHmgrSharedHandleSection;

// drvsup.cxx
extern PLDEV gpldevDrivers;

extern PBYTE gpRGBXlate;

// invcmap.cxx
extern PBYTE gpDefITable;

/*
 * Our global data for tracking lists
 */

LIST_ENTRY MultiUserGreEngAllocList;
HSEMAPHORE MultiUserEngAllocListLock = NULL;
#if DBG
LIST_ENTRY DebugGreMapViewList;
HSEMAPHORE DebugGreMapViewListLock = NULL;
#endif

/*
 * The EngLoadModule tracking list
 */
LIST_ENTRY GreEngLoadModuleAllocList;
HSEMAPHORE GreEngLoadModuleAllocListLock = NULL;

BOOL FASTCALL NtGdiCloseProcess(W32PID,CLEANUPTYPE);

/*
 * Forward references
 */

VOID MultiUserCleanupPathAlloc();
VOID MultiUserGreCleanupEngResources();
VOID MultiUserGreHmgOwnAll(W32PID);
VOID MultiUserGreCleanupDrivers();
VOID MultiUserGreCleanupAllFonts();
VOID MultiUserGreDeleteXLATE();
VOID vCleanUpFntCache(VOID);

// drvsup.cxx
extern VOID MultiUserDrvCleanupGraphicsDeviceList();

// fontsup.cxx
extern VOID MultiUserGreDeleteScripts();

/*
 * Debug only
 */

#if DBG

// Hydra session id (see ntuser\kernel\globals.c).
extern "C" ULONG gSessionId;

VOID DebugGreCleanupMapView();
VOID MultiUserGreHmgDbgScan(BOOL, BOOL);

char *gpszHmgrType[] = {
    "ObjectType        ",       // 0x00
    "DC_TYPE           ",       // 0x01
    "DD_DIRECTDRAW_TYPE",       // 0x02
    "DD_SURFACE_TYPE   ",       // 0x03
    "RGN_TYPE          ",       // 0x04
    "SURF_TYPE         ",       // 0x05
    "CLIENTOBJ_TYPE    ",       // 0x06
    "PATH_TYPE         ",       // 0x07
    "PAL_TYPE          ",       // 0x08
    "ICMLCS_TYPE       ",       // 0x09
    "LFONT_TYPE        ",       // 0x0a
    "RFONT_TYPE        ",       // 0x0b
    "PFE_TYPE          ",       // 0x0c
    "PFT_TYPE          ",       // 0x0d
    "ICMCXF_TYPE       ",       // 0x0e
    "SPRITE_TYPE       ",       // 0x0f
    "BRUSH_TYPE        ",       // 0x10
    "D3D_HANDLE_TYPE   ",       // 0x11
    "DD_VIDEOPORT_TYPE ",       // 0x12
    "SPACE_TYPE        ",       // 0x13
    "DD_MOTIONCOMP_TYPE",       // 0x14
    "META_TYPE         ",       // 0x15
    "EFSTATE_TYPE      ",       // 0x16
    "BMFD_TYPE         ",       // 0x17
    "VTFD_TYPE         ",       // 0x18
    "TTFD_TYPE         ",       // 0x19
    "RC_TYPE           ",       // 0x1a
    "TEMP_TYPE         ",       // 0x1b
    "DRVOBJ_TYPE       ",       // 0x1c
    "DCIOBJ_TYPE       ",       // 0x1d
    "SPOOL_TYPE        "        // 0x1e
};
#endif

/*
 *  Can put these initialization functions in the INIT segment.
 */

extern "C" {
BOOL GreEngLoadModuleTrackInit();
BOOL MultiUserGreCleanupInit();
}

#pragma alloc_text(INIT, MultiUserGreCleanupInit)
#pragma alloc_text(INIT, GreEngLoadModuleTrackInit)

extern "C" CP_GLYPHSET *gpcpGlyphsets;
extern "C" CP_GLYPHSET *gpcpVTFD;

extern void vCleanupPrintKViewList();

/******************************Public*Routine******************************\
* GreEngLoadModuleTrackInit
*
*   Initializes the EngLoadModule tracking list
*
* Arguments:
*
* Return Value:
*
* History:
*
*    21-Apr-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

extern "C"
BOOL
GreEngLoadModuleTrackInit()
{
    InitializeListHead(&GreEngLoadModuleAllocList);

    GreEngLoadModuleAllocListLock = GreCreateSemaphoreNonTracked();

    return (GreEngLoadModuleAllocListLock != NULL);
}


/*****************************************************************************
 *
 *  MultiUserGreCleanupInit
 *
 *   Init the GRE cleanup code
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/



extern "C"
BOOL
MultiUserGreCleanupInit()
{
    InitializeListHead(&MultiUserGreEngAllocList);
#if DBG
    InitializeListHead(&DebugGreMapViewList);
#endif

    MultiUserEngAllocListLock = GreCreateSemaphoreNonTracked();

#if DBG
    DebugGreMapViewListLock = GreCreateSemaphoreNonTracked();
#endif

#if DBG
    return ((MultiUserEngAllocListLock != NULL) &&
            (DebugGreMapViewListLock != NULL));
#else
    return (MultiUserEngAllocListLock != NULL);
#endif
}



/*****************************************************************************
 *
 *  MultiUserNtGreCleanup
 *
 *   This performs the main additional cleanup processing
 *   of kernel mode GRE. This supports the unloading of the
 *   win32k.sys kernel module on WinFrame.
 *
 *   Our concern here is non-paged pool and kernel resource
 *   objects. Paged pool is not a problem since a WINSTATION SPACE
 *   paged pool allocator is used which destroys all pageable memory
 *   allocated by win32k.sys and its video and printer drivers when
 *   the WINSTATION SPACE is deleted.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

extern PPAGED_LOOKASIDE_LIST pHmgLookAsideList[];
extern "C" PVOID LastNlsTableBuffer;

VOID CleanUpEUDC(VOID);

extern "C"
BOOL
MultiUserNtGreCleanup()
{
    NTSTATUS ntstatus;
    W32PID pid = W32GetCurrentPID();

    //
    // Assign ownership of all handle manager objects to cleanup process.
    // Must be done first.
    //

    MultiUserGreHmgOwnAll(pid);

    //
    // Use the process termination code to delete the majority of objects
    // (all except some font related objects).
    //

    if(gpentHmgr!=NULL) {
      NtGdiCloseProcess(pid, CLEANUP_SESSION);
    }


    if (gpfsTable)
    {
        VFREEMEM(gpfsTable);
        gpfsTable = NULL;
    }

    if (MAPPER::SignatureTable)
    {
        VFREEMEM(MAPPER::SignatureTable);
        MAPPER::SignatureTable = NULL;
    }

    // Clean up LastNlsTableBuffer

    if (LastNlsTableBuffer)
    {
        VFREEMEM(LastNlsTableBuffer);
        LastNlsTableBuffer = NULL;
    }

    //
    // Cleanup the scripts (created by InitializeScripts during
    // InitializeGre).
    //
    MultiUserGreDeleteScripts();

    //
    // Cleanup the XLATE cache (created by vInitXLATE during
    // InitializeGre).
    //

    MultiUserGreDeleteXLATE();

    //
    // Cleanup RBRUSH caches.
    //

    if (gpCachedEngbrush)
    {
        //
        // Engine brush cache is just one deep (refer to
        // EngRealizeBrush in engbrush.cxx).
        //

        VFREEMEM(gpCachedEngbrush);
    }

    if (gpCachedDbrush)
    {
        //
        // Device brush cache is just one deep (refer to
        // BRUSHOBJ__pvAllocRbrush in brushddi.cxx).
        //

        VFREEMEM(gpCachedDbrush);
    }

    if (gpRGBXlate)
    {
       VFREEMEM(gpRGBXlate);
       gpRGBXlate = NULL;
    }

    if(gpDefITable)
    {
        VFREEMEM(gpDefITable);
        gpDefITable = NULL;
    }

    //
    // Cleanup driver objects.
    //

    MultiUserGreCleanupDrivers();

#ifdef _PER_SESSION_GDEVLIST_
    //
    // Currently, the graphics device list (see drvsup.cxx) is allocated
    // per-Hydra session.  AndreVa has proposed that they be allocated
    // globally.  He's probably right, but until this changes we need to
    // clean them up during Hydra shutdown.
    //
    // To enable cleanup of the per-Hydra graphics device lists (i.e.,
    // the function MultiUserDrvCleanupGraphicsDeviceList in drvsup.cxx),
    // define _PER_SESSION_GDEVLIST_ in muclean.hxx.
    //

    MultiUserDrvCleanupGraphicsDeviceList();

#endif

    //
    // Handle manager should be empty at this point.
    //

#if DBG
    if (gpentHmgr != NULL) {
        MultiUserGreHmgDbgScan(TRUE, TRUE);
    }
#endif

    //
    // Cleanup random pool allocations.
    //

    if (gpLockShortDelay)
    {
        GdiFreePool(gpLockShortDelay);
        gpLockShortDelay = NULL;
    }

    if (gpTmpGlobal)
    {
        GdiFreePool(gpTmpGlobal);
        gpTmpGlobal = NULL;
    }

    if (gpTmpGlobalFree)
    {
        GdiFreePool(gpTmpGlobalFree);
        gpTmpGlobalFree = NULL;
    }

    //
    // Call the C++ "friend" function for cleanup
    //

    MultiUserCleanupPathAlloc();

    //
    // These must be last since they catch all the
    // leftover NT kernel resource objects that were
    // not released by the above code.
    //
    // The reason this is done is that these objects
    // can be created as the result of embedded classes
    // that stay around.
    //
    // Also every printer driver also can call EngCreateSemaphore
    // and leak it.
    //

    //
    // Cleanup the tracked resources.
    //

    MultiUserGreCleanupEngResources();

#if DBG
    //
    // On free builds, we track and cleanup only the views
    // allocated by drivers (i.e., through the Eng
    // helper functions).
    //
    // However, on debug builds we will track all views
    // to help find engine leaks.  The functions below
    // will cleanup, but they will also assert.
    //

    DebugGreCleanupMapView();
#endif

    //
    // Cleanup watchdog's association list mutex.
    //

    GreDeleteFastMutex(gAssociationListMutex);
    gAssociationListMutex = NULL;

    //
    // Cleanup the HMGR look aside buffer mutex.
    //

    GreDeleteFastMutex(ghfmMemory);
    ghfmMemory = NULL;

    if (gpGdiSharedMemory)
    {
        ntstatus = Win32UnmapViewInSessionSpace(gpGdiSharedMemory);
        gpGdiSharedMemory = NULL;
    }

    if (gpHmgrSharedHandleSection)
    {
        Win32DestroySection(gpHmgrSharedHandleSection);
        gpHmgrSharedHandleSection  = NULL;
    }

    //
    // Free the HMGR lookaside lists.
    //

    for (int i = 0; i <= MAX_TYPE; i++)
    {
        if (pHmgLookAsideList[i] != NULL)
        {
            ExDeletePagedLookasideList(pHmgLookAsideList[i]);
            GdiFreePool(pHmgLookAsideList[i]);
            pHmgLookAsideList[i]=NULL;
        }
    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  MultiUserCleanupPathAlloc
 *
 *   Friend function to cleanup a PATHALLOC object's
 *   class global state.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
MultiUserCleanupPathAlloc()
{
    // pathobj.cxx
    if (PATHALLOC::hsemFreelist)
    {
        GreDeleteSemaphore(PATHALLOC::hsemFreelist);
        PATHALLOC::hsemFreelist = NULL;
    }

    //
    // Release the PATHALLOC freelist.
    //

    while (PATHALLOC::freelist)
    {
        PATHALLOC *ppa = PATHALLOC::freelist;
        PATHALLOC::freelist = ppa->ppanext;

        VFREEMEM(ppa);
    }

    return;
}

/******************************Public*Routine******************************\
* MultiUserGreTrackAddEngResource
*
* Add an entry associated with an EngAllocMem.
*
* WARNING:
*   EngInitializeSafeSemaphore calls GreCreateSemaphore which in turn calls
*   this function.  Since EngInitializeSafeSemaphore does this with the
*   HMGR global lock (MLOCKFAST) held, this function must never call any
*   anything that grabs MLOCKFAST.  If this becomes necessary in the future,
*   EngInitializeSafeSemaphore must be rewritten.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreTrackAddEngResource(
    PENGTRACKHDR peth,
    ULONG ulType
    )
{
    PLIST_ENTRY Entry = (PLIST_ENTRY) peth;

    //setting to 0 would be a waste of time
    //peth->ulReserved = 0;
    peth->ulType     = ulType;

    if(MultiUserEngAllocListLock) GreAcquireSemaphore(MultiUserEngAllocListLock);

    InsertTailList(&MultiUserGreEngAllocList, Entry);

    if(MultiUserEngAllocListLock) GreReleaseSemaphore(MultiUserEngAllocListLock);
}

/******************************Public*Routine******************************\
* MultiUserGreTrackRemoveEngResource
*
* Add an entry associated with an EngAllocMem.
*
* WARNING:
*   EngDeleteSafeSemaphore calls GreDeleteSemaphore which in turn calls
*   this function.  Since EngDeleteSafeSemaphore does this with the
*   HMGR global lock (MLOCKFAST) held, this function must never call any
*   anything that grabs MLOCKFAST.  If this becomes necessary in the future,
*   EngDeleteSafeSemaphore must be rewritten.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreTrackRemoveEngResource(
    PENGTRACKHDR peth
    )
{
    PLIST_ENTRY Entry = (PLIST_ENTRY) peth;

    if(MultiUserEngAllocListLock) GreAcquireSemaphore(MultiUserEngAllocListLock);

    RemoveEntryList(Entry);

    if(MultiUserEngAllocListLock) GreReleaseSemaphore(MultiUserEngAllocListLock);
}

/******************************Public*Routine******************************\
* MultiUserGreCleanupEngResources
*
* Cleanup the tracked EngAlloc objects and tracked (Gre and Eng) semaphores.
*
* WARNING: This must not invoke any code which uses tracked semaphores. If
*          it is inevitable, the semaphores in question must be changed
*          to non-tracked semaphores (and cleaned up explicitly).
*
* WARNING: This function is called late in MultiUserGreCleanupEngResources.
*          Be careful to avoid using structures that have already been
*          cleaned up.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupEngResources()
{
    volatile PLIST_ENTRY pNextEntry;

    if(MultiUserEngAllocListLock)
    {
        pNextEntry = MultiUserGreEngAllocList.Flink;

        while (pNextEntry != &MultiUserGreEngAllocList)
        {
            //
            // Resource starts after the ENGTRACKHDR.
            //

            PVOID pvVictim = (PVOID) (((ENGTRACKHDR *) pNextEntry) + 1);

            //
            // Invoke the appropriate deletion function based on type.
            //

            switch (((ENGTRACKHDR *) pNextEntry)->ulType)
            {
            case ENGTRACK_ALLOCMEM:
                EngFreeMem(pvVictim);
                break;

	    case ENGTRACK_SEMAPHORE:
	    case ENGTRACK_DRIVER_SEMAPHORE:
                GreDeleteSemaphore((HSEMAPHORE)pvVictim);
                break;

            case ENGTRACK_VERIFIERALLOCMEM:
                VerifierEngFreeMem(pvVictim);
                break;

            default:
                #if DBG
                DbgPrint("MultiUserGreCleanupEngResources: "
                         "unrecognized type 0x%08lx\n",
                         ((ENGTRACKHDR *) pNextEntry)->ulType);
                RIP("MultiUserGreCleanupEngResources: possible leak detected\n");
                #endif
                break;
            }

            //
            // Restart at the begining of the list since our
            // entry got deleted.
            //

            pNextEntry = MultiUserGreEngAllocList.Flink;
        }
    }

    //
    // Now delete all objects on the GreEngLoadModuleAllocList.
    //

    if(GreEngLoadModuleAllocListLock)
    {
        while (GreEngLoadModuleAllocList.Flink != &GreEngLoadModuleAllocList)
        {
            //
            // Free the module after setting the reference count to 1 (to eliminate
            // looping cRef times).
            //

            ((PENGLOADMODULEHDR)(GreEngLoadModuleAllocList.Flink))->cRef = 1;
            EngFreeModule ((HANDLE) (((PENGLOADMODULEHDR)(GreEngLoadModuleAllocList.Flink)) + 1));
        }
    }

    //
    // Delete the list locks.
    //

    GreDeleteSemaphoreNonTracked(MultiUserEngAllocListLock);
    MultiUserEngAllocListLock = NULL;

    GreDeleteSemaphoreNonTracked(GreEngLoadModuleAllocListLock);
    GreEngLoadModuleAllocListLock = NULL;
}

/*****************************Exported*Routine*****************************\
* MultiUserGreHmgOwnAll
*
* Set owner of all objects in handle manager to specified process.  Used
* for multi-user (Hydra) shutdown of GRE.
*
* WARNING:
*
*   Caller beware! This is very evil code.  It ignores the current owner
*   and the lock counts.  Acceptable for shutdown code, but definitely
*   unsafe for any other purpose.
*
* History:
*  03-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreHmgOwnAll(
    W32PID pid)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index
    UINT cObj = 0;

    //
    // Don't bother with locks.  We're shutting down, so nobody else
    // is here!
    //
    // MLOCKFAST mo;

    //
    // Scan through the entire handle manager table and set owner for
    // all valid objects.
    //
    if(gpentHmgr==NULL) {
      WARNING("MultiUserGreHmgOwnAll: gpentHmgr is NULL\n");
      return;
    }

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            //
            // Since this is shutdown, don't bother with lock counts and
            // such.
            //

            SET_OBJECTOWNER_PID(pentTmp->ObjectOwner, pid);
            cObj++;
        }
    }

    //
    // Reset handle quota count to number objects now owned
    // (not really that important for shutdown, but it supresses
    // many warnings).
    //

    PW32PROCESS pw32Current = W32GetCurrentProcess();
    if (pw32Current)
    {
        pw32Current->GDIHandleCount = cObj;
    }
}

/******************************Public*Routine******************************\
* MultiUserGreCleanupHmgRemoveAllLocks
*
* For all objects of the specified type, all locks are removed and the
* object is marked as deletable.  If the DEF_TYPE is specified, all valid
* objects are modified.
*
* WARNING:
*
*   Caller beware! This is very evil code.  It ignores the current owner
*   and the lock counts.  Acceptable for shutdown code, but definitely
*   unsafe for any other purpose.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupHmgRemoveAllLocks(OBJTYPE type)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index

    //
    // Don't bother with locks.  We're shutting down, so nobody else
    // is here!
    //
    // MLOCKFAST mo;

    //
    // Scan through the entire handle manager table zap the share count
    // and lock flag for all objects that belong to specified W32PID.
    //

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (
             ((type != DEF_TYPE) && (type == pentTmp->Objt)) ||

             ((type == DEF_TYPE) &&
              (pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
           )
        {
            ASSERTGDI((OBJECTOWNER_PID(pentTmp->ObjectOwner) == W32GetCurrentPID()),
                      "MultiUserGreCleanupHmgRemoveAllLocks: "
                      "found unowned object still in hmgr table\n");

            pentTmp->ObjectOwner.Share.Lock  = 0;
            pentTmp->einfo.pobj->ulShareCount = 0;
            pentTmp->Flags &= ~HMGR_ENTRY_UNDELETABLE;
        }
    }
}

/******************************Public*Routine******************************\
* bCleanupFontHash
* bCleanupFontTable
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Worker functions for MultiUserGreCleanupAllFonts.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  06-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bCleanupFontHash(FONTHASH **ppfh)
{
    BOOL bResult = FALSE;

    FHOBJ fho(ppfh);

    if (fho.bValid())
    {
        fho.vFree();
        bResult = TRUE;
    }

    return bResult;
}

BOOL bCleanupFontTable(PFT **pppft)
{
    BOOL bResult = FALSE;
    PFT *ppft = *pppft;

    PUBLIC_PFTOBJ  pfto(ppft);

    if (pfto.bValid())
    {
        //
        // Unload any fonts still in the table.
        //

        bResult = pfto.bUnloadAllButPermanentFonts(TRUE);

        //
        // Remove the font hash tables if they exist (for device fonts, the
        // font hash tables exist off the PFF rather than the PFT).
        //

        if (ppft->pfhFace)
        {
            bResult &= bCleanupFontHash(&ppft->pfhFace);
        }

        if (ppft->pfhFamily)
        {
            bResult &= bCleanupFontHash(&ppft->pfhFamily);
        }

        if (ppft->pfhUFI)
        {
            bResult &= bCleanupFontHash(&ppft->pfhUFI);
        }

        //
        // Finally, delete the font table.
        //

        bResult &= pfto.bDelete();
        *pppft = NULL;
    }

    return bResult;
}


/******************************Public*Routine******************************\
* MultiUserGreCleanupAllFonts
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Delete the font tables and hash tables.
*
* History:
*  06-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID MultiUserGreCleanupAllFonts()
{
    BOOL bResult;

    //
    // Note: since this should only be called during win32k shutdown,
    // don't bother with grabbing the semaphore.
    //

    //GreAcquireSemaphore(ghsemPublicPFT);
    {
        // Hydra
        // Saw the case where gpPFTPublic was not initialized on Hydra system

        //ASSERTGDI(gpPFTPublic, "MultiUserGreCleanupAllFonts: invalid gpPFTPublic\n");
        //ASSERTGDI(gpPFTPublic, "MultiUserGreCleanupAllFonts: invalid gpPFTDevice\n");

        //
        // Handle private table.  Note that private table can be lazily
        // created, so we have to check gpPFTPrivate.
        //

        if (gpPFTPrivate)
        {
            //
            // Delete the private font table.
            //

            bResult = bCleanupFontTable(&gpPFTPrivate);
        }

        // Hydra
        // Saw the case where gpPFTPublic was not initialized

        if (gpPFTPublic)
        {
            //
            // Delete the public font table.
            //

            bResult = bCleanupFontTable(&gpPFTPublic);
        }

        // Hydra
        // saw the case where gpPFTDevice was not intialized on Hydra system

        if (gpPFTDevice)
        {
            //
            // Delete the device font table.
            //

            bResult = bCleanupFontTable(&gpPFTDevice);
        }

        // Clean up the gpPrintKViewList

        if (gpPrintKViewList)
        {
            vCleanupPrintKViewList();
        }
    }

    // Clean up FD_GLYPHSET for VTFD and BMFD.
    // Here is the cheapest way to do some garbage collection.

    if (gpcpVTFD)
    {
        CP_GLYPHSET *pcpNext, *pcpCurrent;

        pcpCurrent = gpcpVTFD;

        while(pcpCurrent)
        {
            pcpNext = pcpCurrent->pcpNext;
            VFREEMEM(pcpCurrent);
            pcpCurrent =  pcpNext;
        }

        gpcpVTFD = NULL;
    }

    if (gpcpGlyphsets)
    {
        CP_GLYPHSET *pcpNext, *pcpCurrent;

        pcpCurrent = gpcpGlyphsets;

        while(pcpCurrent)
        {
            pcpNext = pcpCurrent->pcpNext;
            VFREEMEM(pcpCurrent);
            pcpCurrent =  pcpNext;
        }

        gpcpGlyphsets = NULL;
    }
    //GreReleaseSemaphore(ghsemPublicPFT);

}

/******************************Public*Routine******************************\
* MultiUserGreCleanupDrivers
*
* Cleanup the ppdev and lpdev driver lists.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupDrivers()
{
    //
    // Note: since this should only be called during win32k shutdown,
    // don't bother with grabbing the semaphore.
    //

    //GreAcquireSemaphore(ghsemDriverMgmt);

    //
    // Remove all PDEVs from the global list.
    //

    volatile PDEV *ppdevCur;

    while (ppdevCur = gppdevList)
    {
        //
        // Force reference count to 1, so PDEV will be deleted.
        //

        ppdevCur->cPdevRefs     = 1;
        ppdevCur->cPdevOpenRefs = 1;

        //
        // Unload the pdev (PDEVOBJ::vUnreferencePdev will update gppdevList).
        //

        PDEVOBJ pdo((HDEV) ppdevCur);
        ASSERTGDI(pdo.bValid(), "MultiUserGreCleanupDrivers: invalid pdev\n");
        pdo.vUnreferencePdev(CLEANUP_SESSION);
    }

    //
    // Cleanup direct draw driver before force unload.
    //

    DxDdCleanupDxGraphics();

    //
    // Remove all LDEVs from the global list.
    //

    volatile PLDEV pldevCur;

    while (pldevCur = gpldevDrivers)
    {
        //
        // Force reference count to 1, so LDEV will be deleted.
        //

        pldevCur->cldevRefs = 1;
        ldevUnloadImage(pldevCur);
    }

    //GreReleaseSemaphore(ghsemDriverMgmt);
}

/******************************Public*Routine******************************\
* MultiUserGreDeleteXLATE
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Delete the XLATE cache.
*
* History:
*  09-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreDeleteXLATE()
{
    ULONG ulEntry;

    for (ulEntry = 0; ulEntry < XLATE_CACHE_SIZE; ulEntry++)
    {
        if (xlateTable[ulEntry].pxlate)
            VFREEMEM(xlateTable[ulEntry].pxlate);
    }
}

VOID
GreFreeSemaphoresForCurrentThread(
    VOID
    )

{
    //
    // Walk the list of tracked semaphores, and release any held by this
    // thread.
    //

    if (MultiUserEngAllocListLock) {

        GreAcquireSemaphore(MultiUserEngAllocListLock);

        PENGTRACKHDR EngTrackHdr;

        EngTrackHdr = (PENGTRACKHDR) MultiUserGreEngAllocList.Flink;

        while (EngTrackHdr->list.Flink != &MultiUserGreEngAllocList) {

            if (EngTrackHdr->ulType == ENGTRACK_DRIVER_SEMAPHORE) {

                HSEMAPHORE hsem = (HSEMAPHORE)(EngTrackHdr + 1);

                if (GreIsSemaphoreOwnedByCurrentThread(hsem)) {

                    //
                    // The current thread was holding a semaphore.  Release
                    // it using the same technique the driver would have used.
                    //

                    EngReleaseSemaphore(hsem);
                }
            }

            EngTrackHdr = (PENGTRACKHDR)EngTrackHdr->list.Flink;
        }

        GreReleaseSemaphore(MultiUserEngAllocListLock);
    }
}

#if DBG
/******************************Public*Routine******************************\
* MultiUserGreHmgDbgScan
*
* Dumps the current handle manager contents.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreHmgDbgScan(BOOL bDumpTable, BOOL bCheckEmpty)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index
    UINT cObj = 0;
    BOOL bTitle = FALSE;

    ASSERTGDI((gpentHmgr != NULL),
              "gpentHmgr MUST be != NULL");

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            cObj++;
        }
    }

    if (bCheckEmpty && cObj)
    {
        DbgPrint("\n"
                 "*****************************************\n");
        DbgPrint("  MultiUserGreHmgDbgScan\n\n");
        DbgPrint("       TERMSRV session id = 0x%08lx\n", gSessionId);
        DbgPrint("      Cleanup process pid = 0x%08lx\n", W32GetCurrentPID());
        DbgPrint("\n"
                 "*****************************************\n");
    }

    //
    // Scan through the entire handle manager table and set owner for
    // all valid objects.
    //

    for (uiIndex = 1; uiIndex < gcMaxHmgr && (bDumpTable && cObj != 0); uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            //
            // Since this is shutdown, don't bother with lock counts and
            // such.
            //

            if (!bTitle)
            {
                DbgPrint("------------------\t------ ------ ----\n");
                DbgPrint(                "%s\tpid    count  lock\n", gpszHmgrType[0]);
                DbgPrint("------------------\t------ ------ ----\n");
                bTitle = TRUE;
            }

            DbgPrint("%s\t0x%04x 0x%04x %ld\n",
                     gpszHmgrType[pentTmp->Objt],
                     OBJECTOWNER_PID(pentTmp->ObjectOwner),
                     pentTmp->einfo.pobj->ulShareCount,
                     pentTmp->ObjectOwner.Share.Lock
                     );

        }
    }

    if (bTitle )
    {
        DbgPrint("------------------\t------ ------ ----\n");
    }

    if (bCheckEmpty && (cObj != 0))
    {
        DbgPrint("MultiUserGreHmgDbgScan: %ld objects in hmgr table\n", cObj);
        RIP("MultiUserGreHmgDbgScan: object leak detected\n");
    }
}

/*****************************************************************************
 *
 *  DebugGreTrackAddMapView
 *
 *   Track GRE's Map View's for cleanup purposes
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreTrackAddMapView(
    PVOID ViewBase
    )
{
    PLIST_ENTRY Entry;
    PVOID Atom;

    if(DebugGreMapViewListLock) GreAcquireSemaphore(DebugGreMapViewListLock);

    Atom = (PVOID) PALLOCNOZ(sizeof(PVOID)+sizeof(LIST_ENTRY), 'mesG');

    if (Atom)
    {
        *(PVOID *)Atom = ViewBase;

        Entry = (PLIST_ENTRY)(((PCHAR)Atom) + sizeof(PVOID));

        InsertTailList(&DebugGreMapViewList, Entry);
    }

    if(DebugGreMapViewListLock) GreReleaseSemaphore(DebugGreMapViewListLock);

    return;
}

/*****************************************************************************
 *
 *  DebugGreTrackRemoveMapView
 *
 *   Remove the GRE Map View from the list
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreTrackRemoveMapView(
    PVOID ViewBase
    )
{
    #if !defined(_GDIPLUS_)

    PLIST_ENTRY NextEntry;
    PVOID Atom;

    if(DebugGreMapViewListLock) GreAcquireSemaphore(DebugGreMapViewListLock);

    NextEntry = DebugGreMapViewList.Flink;

    while (NextEntry != &DebugGreMapViewList)
    {
        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        if (ViewBase == *(PVOID *)Atom)
        {
            RemoveEntryList(NextEntry);

            VFREEMEM(Atom);

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if(DebugGreMapViewListLock) GreReleaseSemaphore(DebugGreMapViewListLock);

    return;

    #endif // !_GDIPLUS_
}

/*****************************************************************************
 *
 *  DebugGreCleanupMapView
 *
 *   Cleanup the tracked Map View's
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreCleanupMapView()
{
    volatile PLIST_ENTRY NextEntry;
    PVOID ViewBase;
    PVOID Atom;

    if(DebugGreMapViewListLock)
    {
        if (!IsListEmpty(&DebugGreMapViewList))
        {
            DbgPrint("DebugGreCleanupMapView: DebugGreMapViewList 0x%08lx not empty\n", &DebugGreMapViewList);
            RIP("DebugGreCleanupMapView: leak detected\n");
        }

        //
        // Cleanup every mapped view tracked in the list.
        //

        NextEntry = DebugGreMapViewList.Flink;

        while (NextEntry != &DebugGreMapViewList)
        {
            // We can not use CONTAINING_RECORD since we are
            // not within a single C structure.

            RemoveEntryList(NextEntry);

            Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

            ViewBase = *(PVOID *)Atom;

            DbgPrint("DebugGreCleanupMapView: cleanup Map View %x\n", ViewBase);

            MmUnmapViewInSessionSpace(ViewBase);

            GdiFreePool(Atom);

            // Restart at the begining of the list since our
            // entry got deleted
            NextEntry = DebugGreMapViewList.Flink;
        }

    }
    //
    // Free the list semaphore.
    //

    GreDeleteSemaphoreNonTracked(DebugGreMapViewListLock);
        DebugGreMapViewListLock = NULL;

    return;
}
#endif

/******************************Public*Routine******************************\
* GdiMultiUserFontCleanup
*
*   Deletes all the fonts from the system font tables.
*
*   This is only called by user when CSRSS goes away on a Hydra terminal.
*
*
* History:
*  29-Sept-1998 -by- Xudong Wu [tessiew]
* Wrote it.
\**************************************************************************/
VOID
GdiMultiUserFontCleanup()
{
	if(!gpPFTPublic)
		return;
		
#ifdef FE_SB
    CleanUpEUDC();
#endif

    //
    // Cleanup the rest of the font stuff (font tables, font hash tables,
    // font files, font substitution table, font mapper).
    //

    MultiUserGreCleanupAllFonts();

    vCleanUpFntCache();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\miscgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: miscgdi.cxx
*
* Misc. GDI routines
*
* Created: 13-Aug-1990 by undead
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER globals
//

LONG gcSynchronizeFlush = -1;
LONG gcSynchronizeTimer = -1;
UINT_PTR gidSynchronizeTimer;

//
// GCAPS2_SYNCTIMER timer interval, in milliseconds
//

#define SYNCTIMER_FREQUENCY 50

/******************************Public*Routine******************************\
* GreSaveScreenBits (hdev,iMode,iIdent,prcl)
*
* Passes the call to the device driver, or returns doing nothing.  This
* call is pretty fast, no locks are done.
*
*  Fri 11-Sep-1992 -by- Patrick Haluptzok [patrickh]
* Add cursor exclusion.
*
*  Thu 27-Aug-1992 16:40:42 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

ULONG_PTR GreSaveScreenBits(HDEV hdev,ULONG iMode,ULONG_PTR iIdent,RECTL *prcl)
{
    ULONG_PTR ulReturn = 0;
    RECTL rcl = {0,0,0,0};

    PDEVOBJ  po(hdev);

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    if (!po.bDisabled())
    {
        PFN_DrvSaveScreenBits pfn = PPFNDRV(po,SaveScreenBits);

        if (pfn != (PFN_DrvSaveScreenBits) NULL)
        {
            DEVEXCLUDEOBJ dxo;

            if (iMode == SS_FREE)
            {
            // Make if a very small rectangle.

                prcl = &rcl;
            }

            ASSERTGDI(po.bDisplayPDEV(), "ERROR");

            ulReturn = (*pfn)(po.pSurface()->pSurfobj(),iMode,iIdent,prcl);
        }
    }
#if DBG
    else
    {
        if (iMode == SS_FREE)
            WARNING("GreSaveScreenBits called to free memory in full screen - memory lost\n");
    }
#endif

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(ulReturn);
}

/******************************Public*Routine******************************\
* GreValidateSurfaceHandle
*
* This allows USER to validate handles passed to it by the client side.
*
* Returns: TRUE if handle is valid and of the correct type,
*          FALSE otherwise.
*
* History:
*  06-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreValidateServerHandle(HANDLE hobj, ULONG ulType)
{
    return(HmgValidHandle((HOBJ)hobj, (OBJTYPE) ulType));
}

/******************************Public*Routine******************************\
* GreSetBrushOrg
*
* Set the application defined brush origin into the DC
*
* Returns: Old brush origin
*
* History:
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreSetBrushOrg(
    HDC hdc,
    int x,
    int y,
    LPPOINT ptl_)
{
    DCOBJ  dco(hdc);
    PPOINTL ptl = (PPOINTL)ptl_;

    if (dco.bValid())
    {
        if (ptl != NULL)
            *ptl = dco.pdc->ptlBrushOrigin();

        //
        // update DCATTR brush org
        //

        dco.pdc->pDCAttr->ptlBrushOrigin.x = x;
        dco.pdc->pDCAttr->ptlBrushOrigin.y = y;

        //
        // update km brush prg
        //

        dco.pdc->ptlBrushOrigin((LONG)x,(LONG)y);
        return(TRUE);
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }
}


/******************************Public*Routine******************************\
* GreGetBrushOrg
*
* Returns: Old application brush origin
*
* History:
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreGetBrushOrg(HDC hdc,PPOINT ptl_)
{
    DCOBJ  dco(hdc);
    PPOINTL ptl = (PPOINTL)ptl_;

    if (dco.bValid())
    {
        *ptl = dco.pdc->ptlBrushOrigin();
        return(TRUE);
    }
    else
        return(FALSE);
}

/******************************Public*Routine******************************\
* vGetDeviceCaps()
*
* Common device capabilities routine.
*
\**************************************************************************/

VOID vGetDeviceCaps(
    PDEVOBJ& po,
    PDEVCAPS pDevCaps
    )
{
    GDIINFO* pGdiInfo;

    pGdiInfo = po.GdiInfoNotDynamic();  // Use of this local removes pointer
                                        //   dereferences

    pDevCaps->ulVersion         = pGdiInfo->ulVersion;
    pDevCaps->ulTechnology      = pGdiInfo->ulTechnology;

    // Note that ul*Size fields are now in micrometers

    pDevCaps->ulHorzSizeM       = (pGdiInfo->ulHorzSize+500)/1000;
    pDevCaps->ulVertSizeM       = (pGdiInfo->ulVertSize+500)/1000;
    pDevCaps->ulHorzSize        = pGdiInfo->ulHorzSize;
    pDevCaps->ulVertSize        = pGdiInfo->ulVertSize;
    pDevCaps->ulHorzRes         = pGdiInfo->ulHorzRes;
    pDevCaps->ulVertRes         = pGdiInfo->ulVertRes;
    pDevCaps->ulBitsPixel       = pGdiInfo->cBitsPixel;
    if (pDevCaps->ulBitsPixel == 15)
        pDevCaps->ulBitsPixel = 16; // Some apps, such as PaintBrush or
                                    //   NetScape, break if we return 15bpp

    pDevCaps->ulPlanes          = pGdiInfo->cPlanes;
    pDevCaps->ulNumPens         = (pGdiInfo->ulNumColors == (ULONG)-1) ?
                             (ULONG)-1 : 5 * pGdiInfo->ulNumColors;
    pDevCaps->ulNumFonts        = po.cFonts();
    pDevCaps->ulNumColors       = pGdiInfo->ulNumColors;
    pDevCaps->ulRasterCaps      = pGdiInfo->flRaster;
    pDevCaps->ulShadeBlendCaps  = pGdiInfo->flShadeBlend;
    pDevCaps->ulAspectX         = pGdiInfo->ulAspectX;
    pDevCaps->ulAspectY         = pGdiInfo->ulAspectY;
    pDevCaps->ulAspectXY        = pGdiInfo->ulAspectXY;
    pDevCaps->ulLogPixelsX      = pGdiInfo->ulLogPixelsX;
    pDevCaps->ulLogPixelsY      = pGdiInfo->ulLogPixelsY;
    pDevCaps->ulSizePalette     = pGdiInfo->ulNumPalReg;
    pDevCaps->ulColorRes        = pGdiInfo->ulDACRed + pGdiInfo->ulDACGreen + pGdiInfo->ulDACBlue;
    pDevCaps->ulPhysicalWidth   = pGdiInfo->szlPhysSize.cx;
    pDevCaps->ulPhysicalHeight  = pGdiInfo->szlPhysSize.cy;
    pDevCaps->ulPhysicalOffsetX = pGdiInfo->ptlPhysOffset.x;
    pDevCaps->ulPhysicalOffsetY = pGdiInfo->ptlPhysOffset.y;

    pDevCaps->ulTextCaps        = pGdiInfo->flTextCaps;
    pDevCaps->ulTextCaps       |= (TC_OP_CHARACTER | TC_OP_STROKE | TC_CP_STROKE |
                                   TC_UA_ABLE | TC_SO_ABLE);

    if (pGdiInfo->ulTechnology != DT_PLOTTER)
        pDevCaps->ulTextCaps |= TC_VA_ABLE;

    pDevCaps->ulVRefresh        = pGdiInfo->ulVRefresh;
    pDevCaps->ulDesktopHorzRes  = pGdiInfo->ulHorzRes;
    pDevCaps->ulDesktopVertRes  = pGdiInfo->ulVertRes;
    pDevCaps->ulBltAlignment    = pGdiInfo->ulBltAlignment;

    pDevCaps->ulColorManagementCaps
                                = GetColorManagementCaps(po);
}

/******************************Public*Routine******************************\
* NtGdiGetDeviceCapsAll()
*
*   Get all the adjustable device caps for the dc.  Allows us to cache this
*   information on the client side.
*
* History:
*  09-Jan-1996 -by-  Lingyun Wang [lingyunw]
* Made it based on GreGetDeviceCapsAll from the old client\server code.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetDeviceCapsAll(
    HDC hdc,
    PDEVCAPS pDevCaps
    )
{
    BOOL bRet = TRUE;
    DEVCAPS devCapsTmp;

    // Lock the destination and its transform.

    DCOBJ dco(hdc);

    // return FALSE if it is a invalid DC

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // Lock down the pdev

    PDEVOBJ po(dco.hdev());

    ASSERTGDI(po.bValid(), "Invalid PDEV");

    __try
    {
        ProbeForWrite(pDevCaps, sizeof(DEVCAPS), sizeof(BYTE));

        vGetDeviceCaps(po, pDevCaps);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING ("try-except failed IN NtGdiGetDeviceCapsAll\n");

        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreUpdateSharedDevCaps()
*
*   Update the device caps in the shared memory
*
* History:
*  09-Jan-1996 -by-  Lingyun Wang [lingyunw]
* Made it based on GreGetDeviceCapsAll from the old client\server code.
\**************************************************************************/

BOOL
GreUpdateSharedDevCaps(
    HDEV hdev
    )
{
    PDEVOBJ po(hdev);
    ASSERTGDI(po.bValid(), "Invalid HDEV");

    vGetDeviceCaps(po, gpGdiDevCaps);

    return(TRUE);
}


/******************************Public*Routine******************************\
* GreGetDeviceCaps
*
* Returns: device driver specific information
*
* NOTE: This function MUST mirror NtGdiGetDeviceCapsAll and that in
*       client\dcquery.c!
*
* History:
*  01-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewritten to corrected GDIINFO structure.
*
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int GreGetDeviceCaps(HDC hdc, int lIndex)
{
// Init return value

    int iRet = 0;

// Lock the destination and its transform.

    DCOBJ dco(hdc);
    if (dco.bValid())
    {
    // Lock down the pdev

        PDEVOBJ po(dco.hdev());
        ASSERTGDI(po.bValid(), "Invalid PDEV");

    // Note that dynamic mode changes may cause the GDIINFO data to change
    // at any time (but not the actual 'pGdiInfo' pointer):

        GDIINFO* pGdiInfo = po.GdiInfoNotDynamic();

        switch (lIndex)
        {
        case DRIVERVERSION:                     //  Version = 0100h for now
           iRet = (pGdiInfo->ulVersion);
           break;

        case TECHNOLOGY:                        //  Device classification
           iRet = (pGdiInfo->ulTechnology);
           break;

        case HORZSIZE:                          //  Horizontal size in millimeters
           iRet =  (pGdiInfo->ulHorzSize+500)/1000;
           break;

        case VERTSIZE:                          //  Vertical size in millimeters
           iRet =  (pGdiInfo->ulVertSize+500)/1000;
           break;

        case HORZRES:                           //  Horizontal width in pixels
           iRet = (pGdiInfo->ulHorzRes);
           break;

        case VERTRES:                           //  Vertical height in pixels
           iRet = (pGdiInfo->ulVertRes);
           break;

        case BITSPIXEL:                         //  Number of bits per pixel
           iRet = (pGdiInfo->cBitsPixel);
           if (iRet == 15)
               iRet = 16;                       //  Some apps, such as PaintBrush or
                                                //  NetScape, break if we return 15bpp
           break;

        case PLANES:                            //  Number of planes
           iRet = (pGdiInfo->cPlanes);
           break;

        case NUMBRUSHES:                        //  Number of brushes the device has
           iRet = (-1);
           break;

        case NUMPENS:                           //  Number of pens the device has
           iRet = (pGdiInfo->ulNumColors == (ULONG)-1) ?
                             (ULONG)-1 : 5 * pGdiInfo->ulNumColors;
           break;

        case NUMMARKERS:                        //  Number of markers the device has
           iRet = (0);
           break;

        case NUMFONTS:                          //  Number of fonts the device has
           iRet = (po.cFonts());
           break;

        case NUMCOLORS:                         //  Number of colors in color table
           iRet = (pGdiInfo->ulNumColors);
           break;

        case PDEVICESIZE:                       //  Size required for the device descriptor
           iRet = (0);
           break;

        case CURVECAPS:                         //  Curves capabilities
           iRet = (CC_CIRCLES   |
                  CC_PIE        |
                  CC_CHORD      |
                  CC_ELLIPSES   |
                  CC_WIDE       |
                  CC_STYLED     |
                  CC_WIDESTYLED |
                  CC_INTERIORS  |
                  CC_ROUNDRECT);
           break;

        case LINECAPS:                          //  Line capabilities
            iRet = (LC_POLYLINE  |
                   LC_MARKER     |
                   LC_POLYMARKER |
                   LC_WIDE       |
                   LC_STYLED     |
                   LC_WIDESTYLED |
                   LC_INTERIORS);
            break;

        case POLYGONALCAPS:                     //  Polygonal capabilities
            iRet = (PC_POLYGON    |
                   PC_RECTANGLE   |
                   PC_WINDPOLYGON |
                   PC_TRAPEZOID   |
                   PC_SCANLINE    |
                   PC_WIDE        |
                   PC_STYLED      |
                   PC_WIDESTYLED  |
                   PC_INTERIORS);
            break;

        case TEXTCAPS:                          //  Text capabilities
        {

            FLONG fl = pGdiInfo->flTextCaps;

        // Engine will simulate vector fonts on raster devices.

            if (pGdiInfo->ulTechnology != DT_PLOTTER)
                fl |= TC_VA_ABLE;

        // Turn underlining, strikeout.  Engine will do it for device if needed.

            fl |= (TC_UA_ABLE | TC_SO_ABLE);

        // Return flag.

            iRet =  fl;
            break;
        }

        case CLIPCAPS:                          //  Clipping capabilities
           iRet = (CP_RECTANGLE);
           break;

        case RASTERCAPS:                        //  Bitblt capabilities
           iRet = (pGdiInfo->flRaster);
           break;

        case SHADEBLENDCAPS:                    //  Shade and blend capabilities
           iRet = (pGdiInfo->flShadeBlend);
           break;

        case ASPECTX:                           //  Length of X leg
           iRet = (pGdiInfo->ulAspectX);
           break;

        case ASPECTY:                           //  Length of Y leg
           iRet = (pGdiInfo->ulAspectY);
           break;

        case ASPECTXY:                          //  Length of hypotenuse
           iRet = (pGdiInfo->ulAspectXY);
           break;

        case LOGPIXELSX:                        //  Logical pixels/inch in X
           iRet = (pGdiInfo->ulLogPixelsX);
           break;

        case LOGPIXELSY:                        //  Logical pixels/inch in Y
           iRet = (pGdiInfo->ulLogPixelsY);
           break;

        case SIZEPALETTE:                       // # entries in physical palette
            iRet = (pGdiInfo->ulNumPalReg);
            break;

        case NUMRESERVED:                       // # reserved entries in palette
            iRet = (20);
            break;

        case COLORRES:
            iRet = (pGdiInfo->ulDACRed + pGdiInfo->ulDACGreen + pGdiInfo->ulDACBlue);
            break;

        case PHYSICALWIDTH:                     // Physical Width in device units
           iRet = (pGdiInfo->szlPhysSize.cx);
           break;

        case PHYSICALHEIGHT:                    // Physical Height in device units
           iRet = (pGdiInfo->szlPhysSize.cy);
           break;

        case PHYSICALOFFSETX:                   // Physical Printable Area x margin
           iRet = (pGdiInfo->ptlPhysOffset.x);
           break;

        case PHYSICALOFFSETY:                   // Physical Printable Area y margin
           iRet = (pGdiInfo->ptlPhysOffset.y);
           break;

        case VREFRESH:                          // Vertical refresh rate of the device
           iRet = (pGdiInfo->ulVRefresh);
           break;

        //
        // NOTE : temporarily disable this feature for the BETA.
        // We will reenable when the engine does it.
        //

        case DESKTOPHORZRES:                    // Width of entire virtual desktop
           iRet = (pGdiInfo->ulHorzRes);
           break;

        case DESKTOPVERTRES:                    // Height of entire virtual desktop
           iRet = (pGdiInfo->ulVertRes);
           break;

        case BLTALIGNMENT:                      // Preferred blt alignment
           iRet = (pGdiInfo->ulBltAlignment);
           break;

        case HORZSIZEM:                         //  Horizontal size in millimeters/1000
           iRet = pGdiInfo->ulHorzSize;
           break;

        case VERTSIZEM:                         //  Vertical size in millimeters/1000
           iRet = pGdiInfo->ulVertSize;
           break;

        case CAPS1:                             //  InternalCaps
           iRet = (po.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                  C1_MIRROR_DEVICE : 0;
           break;

        case COLORMGMTCAPS:                     //  Color management capabilities
           iRet = GetColorManagementCaps(po);

        default:
           iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL GreDeleteObject(HOBJ)
*
* History:
*  Fri 13-Sep-1991 -by- Patrick Haluptzok [patrickh]
* added DC deletion
*
*  Tue 27-Nov-1990 -by- Patrick Haluptzok [patrickh]
* added palette deletion, surface deletion, brush deletion.
*
*  Wed 22-Aug-1990 Greg Veres [w-gregv]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreDeleteObject (HANDLE hobj)
{
    int ii;

// don't allow deletion of stock objects, just succeed

    if (HmgStockObj(hobj))
    {
        return(TRUE);
    }

    switch (HmgObjtype(hobj))
    {
    case RGN_TYPE:
        return(bDeleteRegion((HRGN) hobj));
    case SURF_TYPE:
        return(bDeleteSurface((HSURF)hobj));
    case PAL_TYPE:
        return(bDeletePalette((HPAL) hobj));
    case LFONT_TYPE:
        // see if its in cfont list.

        for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
        {
            if (gpGdiSharedMemory->acfPublic[ii].hf == hobj)
            {
                // just nuke the hfont as this invalidates the whole entry

                gpGdiSharedMemory->acfPublic[ii].hf = 0;
                break;
            }
        }
        return(bDeleteFont((HLFONT) hobj, FALSE));

    case BRUSH_TYPE:
        return(bDeleteBrush((HBRUSH) hobj, FALSE));
    case DC_TYPE:
        return(bDeleteDCInternal((HDC) hobj,TRUE,FALSE));
    default:
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* NtGdiDeleteObjectApp()
*
*   Same as DeleteObject() but doesn't allow public objects to be deleted.
*   This should only be called from server.c coming from the client.  User
*   and console should call the DeleteObject().
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteObjectApp(
    HANDLE hobj
    )
{
    ULONG objt;

    // don't allow deletion of stock objects, just succeed

    if (HmgStockObj(hobj))
    {
        return(TRUE);
    }

    objt = HmgObjtype(hobj);

    // check if it is a public object.  If it is, check if it is a public deletable
    // surface set by user.

    if (GreGetObjectOwner((HOBJ)hobj,objt) == OBJECT_OWNER_PUBLIC)
    {
        if (objt == SURF_TYPE)
        {
            WARNING("Trying to delete public surface!");
        }

    #if 0
        BOOL bMsg = TRUE;

        if (objt == BRUSH_TYPE)
        {
            BRUSHSELOBJ bo(hbrush);

            if (bo.bValid() || bo.bIsGlobal())
                bMsg = FALSE;
        }

        if (bMsg)
        {
            DbgPrint("GDI Warning: app trying to delete public object %lx\n",hobj);
        }
    #endif

        //
        // return FALSE if hobj == NULL
        // otherwise TRUE
        //
        return(hobj != NULL);
    }

    switch (objt)
    {
    case RGN_TYPE:
        return(bDeleteRegion((HRGN) hobj));
    case SURF_TYPE:
        return(bDeleteSurface((HSURF)hobj));
    case PAL_TYPE:
        return(bDeletePalette((HPAL) hobj));
    case LFONT_TYPE:
        return(bDeleteFont((HLFONT) hobj, FALSE));
    case BRUSH_TYPE:
        return(bDeleteBrush((HBRUSH) hobj, FALSE));
    case DC_TYPE:
    // don't allow deletion of DC's by an app if the undeletable flag is set

        return(bDeleteDCInternal((HDC) hobj,FALSE,FALSE));
    default:
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* cjGetBrushOrPen
*
* Gets brush or pen object data.
*
* For extended pens, some information such as the style array are kept
* only on this, the server side.  Most of the brush data is also kept
* on the client side for GetObject.
*
* returns: Number of bytes needed if pvDest == NULL, else bytes copied out.
*          For error it returns 0.
*
* History:
*  Thu 23-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

LONG cjGetBrushOrPen(HANDLE hobj, int iCount, LPVOID pvDest)
{
    LONG lRet = 0;

    BRUSHSELOBJ bro((HBRUSH) hobj);

// NOTE SIZE: Most of this is bunk, since for NT all brush data is kept on the
// client side, and so some of this code path won't even be
// executed. [andrewgo]
//
// And for DOS, we would return some fields as zero, whereas under
// NT we would always return what we were given. [andrewgo]

    if (bro.bValid())
    {
        if (bro.bIsOldStylePen())
        {
        // Old style pen...

            bSyncBrushObj(bro.pbrush());

            if (pvDest == (LPVOID) NULL)
            {
                lRet = sizeof(LOGPEN);
            }
            else if (iCount >= sizeof(LOGPEN))
            {
                if ((iCount == (int) sizeof(EXTLOGPEN)) &&
                    ((UINT) bro.flStylePen() == PS_NULL))
                {
                    //moved the NULL extended pen handling from client
                    //side to server side

                     PEXTLOGPEN pelp = (PEXTLOGPEN) pvDest;

                     pelp->elpPenStyle   = PS_NULL;
                     pelp->elpWidth      = 0;
                     pelp->elpBrushStyle = 0;
                     pelp->elpColor      = 0;
                     pelp->elpHatch      = 0;
                     pelp->elpNumEntries = 0;

                     lRet = sizeof(EXTLOGPEN);
                }
                else
                {
                // Fill in the logical pen.

                    ((LOGPEN *) pvDest)->lopnStyle   = (UINT) bro.flStylePen();
                    ((LOGPEN *) pvDest)->lopnWidth.x = (int) bro.lWidthPen();
                    ((LOGPEN *) pvDest)->lopnWidth.y = 0;
                    ((LOGPEN *) pvDest)->lopnColor   = bro.clrPen();
                    lRet = sizeof(LOGPEN);
                }
            }
        }
        else if (bro.bIsPen())
        {
        // Extended pen...

            ULONG cstyle = (bro.bIsUserStyled()) ? bro.cstyle() : 0;

            int cj = (int) (sizeof(EXTLOGPEN) - sizeof(DWORD) +
                            sizeof(DWORD) * (SIZE_T) cstyle);

            if (pvDest == (LPVOID) NULL)
            {
                lRet = cj;
            }
            else if (iCount >= cj)
            {
                PEXTLOGPEN pelp = (PEXTLOGPEN) pvDest;

                pelp->elpPenStyle   = (UINT) bro.flStylePen();
                pelp->elpWidth      = (UINT) bro.lWidthPen();
                pelp->elpNumEntries = cstyle;

                if (cstyle > 0)
                {
                // We can't just do a RtlCopyMemory for cosmetics, because
                // we don't know how the LONGs are packed in the
                // FLOAT_LONG array:

                    PFLOAT_LONG pelSrc = bro.pstyle();
                    PLONG       plDest = (PLONG) &pelp->elpStyleEntry[0];

                    for (; cstyle > 0; cstyle--)
                    {
                        if (bro.bIsCosmetic())
                            *plDest = pelSrc->l;
                        else
                        {
                            EFLOATEXT efLength(pelSrc->e);
                            BOOL b = efLength.bEfToL(*plDest);

                            ASSERTGDI(b, "Shouldn't have overflowed");
                        }

                        plDest++;
                        pelSrc++;
                    }
                }

            // The client side GetObject will fill in the rest of the
            // EXTLOGPEN struct. i.e. elpBrushStyle, elpColor, and elpHatch.

            // Changed: added these here -30-11-94 -by- Lingyunw
            // added lBrushStyle and lHatch to PEN

               pelp->elpBrushStyle = bro.lBrushStyle();
               pelp->elpColor      = bro.crColor();
               pelp->elpHatch      = bro.lHatch();

               lRet = cj;
            }
        }
        else
        {
         // Brush...

            if (pvDest == (LPVOID) NULL)
            {
                lRet = sizeof(LOGBRUSH);
            }
            else if (iCount >= sizeof(LOGBRUSH))
            {
            // make sure the kernel attributes match

               bSyncBrushObj(bro.pbrush());

            // Fill in logical brush.  Figure out what type it is.

            // Duplicates of this info is kept on the client side,
            // so most calls won't even get here:

                if (bro.flAttrs() & BR_IS_SOLID)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_SOLID;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = 0;
                }
                else if (bro.flAttrs() & BR_IS_BITMAP)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_PATTERN;
                    ((LOGBRUSH *) pvDest)->lbColor   = 0;
                    ((LOGBRUSH *) pvDest)->lbHatch   = (ULONG_PTR)bro.hbmClient();
                }
                else if (bro.flAttrs() & BR_IS_HATCH)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_HATCHED;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = bro.ulStyle();
                }
                else if (bro.flAttrs() & BR_IS_NULL)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_HOLLOW;
                    ((LOGBRUSH *) pvDest)->lbColor   = 0;
                    ((LOGBRUSH *) pvDest)->lbHatch   = 0;
                }
                else if (bro.flAttrs() & BR_IS_DIB)
                {
                // Could be BS_DIBPATTERN or BS_DIBPATTERNPT, but we'll just
                // return BS_DIBPATTERN.

                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_DIBPATTERN;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = (ULONG_PTR)bro.hbmClient();
                }
                else
                    RIP("ERROR GreGetObject invalid brush type");

                lRet = sizeof(LOGBRUSH);
            }
        }
    }
    else
    {
        WARNING1("cjGetBrushOrPen():hobj is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(lRet);
}

/******************************Public*Routine******************************\
* GreGetObject
*
* API function
*
* returns: number of bytes needed if pvDest == NULL, else bytes copied out
*          for error it returns 0
*
* in case a log font object is requested, the function will fill the buffer with
* as many bytes of the EXTLOGFONT structure as requested. If a caller
* wants a LOGFONTW structure in the buffer, he should specify
*        ulCount == sizeof(LOGFONTW)
* The function will copy the first sizeof(LOGFONTW) bytes of the EXTLOGFONTW
* structure to the buffer, which is precisely the LOGFONTW structure. The rest
* of the EXTLOGFONTW structure will be chopped off.
*
* History:
*
*  Thu 12-Dec-1996 -by- Bodin Dresevic [BodinD]
* update: changed EXTLOGFONT to ENUMLOGFONTEXDVW
*
*  Thu 30-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* added extended pen support.
*
*  Wed 21-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to return EXTLOGFONTW
*
*  Fri 24-May-1991 -by- Patrick Haluptzok [patrickh]
* added first pass pen and brush stuff.
*
*  Tue 24-Apr-1991 -by- Patrick Haluptzok [patrickh]
* added surface stuff.
*
*  08-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int APIENTRY GreExtGetObjectW(HANDLE hobj, int  ulCount, LPVOID pvDest)
{
    int cRet = 0;

    switch (HmgObjtype(hobj))
    {
    case PAL_TYPE:
        cRet = 2;

        if (pvDest != NULL)
        {
            if (ulCount < 2)
            {
                cRet = 0;
            }
            else
            {
                SEMOBJ  semo(ghsemPalette);

                {
                    EPALOBJ pal((HPALETTE) hobj);

                    if (!(pal.bValid()))
                        cRet = 0;
                    else
                        *((PUSHORT) pvDest) = (USHORT) (pal.cEntries());
                }
            }
        }
        break;

    case LFONT_TYPE:

    // The output object is assumed to be
    // an ENUMLOGFONTEXDVW structure.
    // client side shall do the translation to LOGFONT if necessary

        {
            LFONTOBJ lfo((HLFONT) hobj);
            if (lfo.bValid())
            {
                if (pvDest != (LPVOID) NULL)
                {
                    SIZE_T cjCopy = MIN((SIZE_T) ulCount, lfo.cjElfw());

                    RtlCopyMemory(pvDest, lfo.pelfw(), (UINT) cjCopy);

                    cRet = (ULONG) cjCopy;
                }
                else
                {
                    cRet = lfo.cjElfw();
                }
            }
            else
            {
                WARNING("GreGetObject(): bad handle\n");
            }
        }
        break;

    case SURF_TYPE:
        if (pvDest != (LPVOID) NULL)
        {
            cRet = 0;

            if (ulCount >= (int)sizeof(BITMAP))
            {
                SURFREF SurfBm((HSURF) hobj);

                if ((SurfBm.bValid()) && 
                    (SurfBm.ps->bApiBitmap() || SurfBm.ps->bDirectDraw()))
                {
                    BITMAP *pbm = (BITMAP *) pvDest;

                    pbm->bmType = 0;
                    pbm->bmWidth = SurfBm.ps->sizl().cx;
                    pbm->bmHeight = SurfBm.ps->sizl().cy;

                    pbm->bmBitsPixel = (WORD) gaulConvert[SurfBm.ps->iFormat()];
                    pbm->bmWidthBytes = ((SurfBm.ps->sizl().cx * pbm->bmBitsPixel + 15) >> 4) << 1;
                    pbm->bmPlanes = 1;
                    pbm->bmBits = (LPSTR) NULL;

                    cRet = sizeof(BITMAP);

                // Get the bitmapinfoheader for the dibsection if the buffer
                // can hold it.

                    if (SurfBm.ps->bDIBSection() || SurfBm.ps->bDirectDraw())
                    {
                        // Win95 compatability.  They fill in the bits even if it
                        // is not big enough for a full DIBSECTION

                        pbm->bmBits = IS_USER_ADDRESS((LPSTR) SurfBm.ps->pvBits()) ? (LPSTR) SurfBm.ps->pvBits() : NULL;

                        // If this is a DIBSection/DirectDraw surface bmWidthBytes must be aligned
                        // on a DWORD boundary.

                        pbm->bmWidthBytes = ((SurfBm.ps->sizl().cx * pbm->bmBitsPixel + 31) & ~31) >> 3;

                        if (ulCount >= sizeof(DIBSECTION))
                        {
                            PBITMAPINFOHEADER pbmih = &((DIBSECTION *)pvDest)->dsBmih;

                            pbmih->biSize = sizeof(BITMAPINFOHEADER);
                            pbmih->biBitCount = 0;

                            if (GreGetDIBitsInternal(0,(HBITMAP)hobj,0,0,NULL,
                                (PBITMAPINFO)pbmih,DIB_RGB_COLORS,0,
                                sizeof(DIBSECTION)))
                            {
                                cRet = sizeof(DIBSECTION);

                            // More Win9x compatibility: for DDraw surfaces, the
                            // following field is always zero.  GDI+ keys off
                            // this Win9x feature to do cheap detection of
                            // DDraw surfaces:

                                if (SurfBm.ps->bDirectDraw())
                                {
                                    pbmih->biSizeImage = 0;
                                }
                            }


                            XEPALOBJ pal(SurfBm.ps->ppal());

                            if (pal.bValid() && pal.bIsBitfields())
                            {
                                ((DIBSECTION *)pvDest)->dsBitfields[0] = pal.flRed();
                                ((DIBSECTION *)pvDest)->dsBitfields[1] = pal.flGre();
                                ((DIBSECTION *)pvDest)->dsBitfields[2] = pal.flBlu();
                            }

                        // to be consistent with win95, Getobject returns BI_RGB for
                        // 24bpp, and 32bpp when BI_RGB is set at creation time

                            else
                            {
                                if (pal.bValid() && pal.bIsBGR())
                                {
                                    pbmih->biCompression = BI_RGB;
                                }

                                ((DIBSECTION *)pvDest)->dsBitfields[0] = 0;
                                ((DIBSECTION *)pvDest)->dsBitfields[1] = 0;
                                ((DIBSECTION *)pvDest)->dsBitfields[2] = 0;
                            }

                            ((DIBSECTION *)pvDest)->dshSection = SurfBm.ps->hDIBSection();
                            ((DIBSECTION *)pvDest)->dsOffset = SurfBm.ps->dwOffset();
                        }
                    }
                }
            }
        }
        else
        {
            cRet = sizeof(BITMAP);
        }

        break;

    case BRUSH_TYPE:
        cRet = (int) cjGetBrushOrPen(hobj, ulCount, pvDest);
        break;

    case ICMLCS_TYPE:
        cRet = cjGetLogicalColorSpace(hobj,ulCount,pvDest);
        break;

    default:
        break;
    }

    return(cRet);
}


/******************************Public*Routine******************************\
* GreGetStockObject
*
* API function
*
* returns the handle to the stock object requested.
*
* History:
*  08-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HANDLE gahStockObjects[PRIV_STOCK_LAST+1] = {0};

HANDLE GreGetStockObject(int ulIndex)
{
    if (((UINT)ulIndex) <= PRIV_STOCK_LAST)
    {
        return(gahStockObjects[ulIndex]);
    }
    else
    {
        return(0);
    }
}

BOOL bSetStockObject(
    HANDLE h,
    int    iObj
    )
{
    if (h)
    {
        gahStockObjects[iObj] = (HANDLE)((ULONG_PTR)h | GDISTOCKOBJ);
        HmgModifyHandleType((HOBJ) gahStockObjects[iObj]);
    }
    return(h != NULL);
}

/******************************Public*Routine******************************\
* BOOL GreGetColorAdjustment
*
*  Get the color adjustment data of the given DC.
*
* History:
*  25-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetColorAdjustment(HDC hdc, COLORADJUSTMENT *pca)
{
    DCOBJ dco(hdc);
    BOOL Status;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        Status = FALSE;

    } else {

        // Retrieve info from the DC.  Mask out the internal flag.

        *pca = *dco.pColorAdjustment();
        pca->caFlags &= (CA_NEGATIVE | CA_LOG_FILTER);
        Status = TRUE;
    }

    return Status;
}

/******************************Public*Routine******************************\
* BOOL GreSetColorAdjustment
*
*  Set the color adjustment data of the given DC.
*
* History:
*  25-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetColorAdjustment(HDC hdc, COLORADJUSTMENT *pcaNew)
{
    DCOBJ dco(hdc);
    BOOL Status;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        Status = FALSE;

    } else {

        // Store info into the DC.  Turn off any flags that we don't support.

        *dco.pColorAdjustment() = *pcaNew;
        dco.pColorAdjustment()->caFlags &= (CA_NEGATIVE | CA_LOG_FILTER);
        Status = TRUE;
    }

    return Status;
}

/******************************Public*Routine******************************\
* HANDLE GreCreateClientObj()
*
*   A ClientObj contains no data.  It is purly to provide a handle to the
*   client for objects such as metafiles that exist only on the client side.
*
*   ulType is a client type.
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE NtGdiCreateClientObj(
    ULONG ulType)
{
    HANDLE h  = NULL;

    if(ulType & INDEX_MASK)
    {
        WARNING("GreCreateClientObj: bad type\n");
        return(h);
    }

    PVOID  pv = ALLOCOBJ(sizeof(OBJECT), CLIENTOBJ_TYPE, FALSE);

    if (pv)
    {
        h = HmgInsertObject(pv, 0, CLIENTOBJ_TYPE);

        if (!h)
        {
            WARNING("GreCreateClientObj: HmgInsertObject failed\n");
            FREEOBJ(pv, CLIENTOBJ_TYPE);
        }
        else
        {
            pv = HmgLock((HOBJ) h,CLIENTOBJ_TYPE);

            if (pv != NULL)
            {
                h = MODIFY_HMGR_TYPE(h,ulType);
                HmgModifyHandleType((HOBJ)h);
                DEC_EXCLUSIVE_REF_CNT(pv);
            }
            else
            {
                RIP("GreCreateClientObj failed lock\n");
            }

        }
    }
    else
    {
        WARNING("GreCreateClientObj(): ALLOCOBJ failed\n");
    }

    return(h);
}

/******************************Public*Routine******************************\
*
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreDeleteClientObj(
    HANDLE h)
{
    PVOID pv = HmgRemoveObject((HOBJ)h, 0, 0, TRUE, CLIENTOBJ_TYPE);

    if (pv != NULL)
    {
        FREEOBJ(pv, CLIENTOBJ_TYPE);
        return(TRUE);
    }
    else
    {
        WARNING("GreDeleteClientObj: HmgRemoveObject failed\n");
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* NtGdiDeleteClientObj()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteClientObj(
    HANDLE h
    )
{
    return(GreDeleteClientObj(h));
}

/******************************Public*Routine******************************\
* GreFreePool
*
* Private USER call to delete memory allocated by GDI.
*
* Only known use is to delete the MDEV structure returned by DrvCreateMDEV
* and cached by USER.
*
* History:
*  24-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID GreFreePool(PVOID pv)
{
    GdiFreePool(pv);
}

/******************************Public*Routine******************************\
* hdevEnumerate
*
* Enumerates all display PDEVs without keeping ghsemDriverMgmt, allowing
* the devlock to be taken on each. This function must be called until it
* returns NULL or proper cleanup will not occur.
*
* History:
*  02-Jul-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

HDEV
hdevEnumerate(
    HDEV    hdevPrevious
    )
{
    PDEV*   ppdev;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    // If we are called with NULL hdevPrevious then create the PDEVOBJ from
    // gppdevList, else create it from hdevPrevious:

    PDEVOBJ po(hdevPrevious ? hdevPrevious : (HDEV) gppdevList);
    ASSERTGDI(po.bValid(), "Invalid HDEV");

    // Search for the next display PDEV. If hdevPrevious is NULL, then
    // we start with po, else start from the next:
    
    for (ppdev = hdevPrevious ? po.ppdev->ppdevNext : po.ppdev;
         ppdev;
         ppdev = ppdev->ppdevNext)
    {
        // We're only interested in display PDEVs:

        if (ppdev->fl & PDEV_DISPLAY)
        {
            // We found the next display PDEV, so take a reference count
            // on it before releasing ghsemDriverMgmt and returning. This
            // reference count will be removed next time through:

            ppdev->cPdevRefs++;
            break;
        }
    }

    // If hdevPrevious is not NULL then we need to remove the reference
    // count we took, and we'll also release ghsemDriverMgmt here in the
    // appropriate place:
        
    if (hdevPrevious)
    {
        // If our reference count is not the last, just decrement, else we
        // need to call vUnreferencePdev so the PDEV will actually be
        // deleted:
        
        ASSERTGDI(po.cPdevRefs() > 0,
            "PDEV reference count is 0 but should be at least 1");
        
        if (po.cPdevRefs() > 1)
        {
            po.ppdev->cPdevRefs--;
            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
        else
        {
            // Release ghsemDriverMgmt before calling vUnreferencePdev
            // because the call may result in the devlock being taken:

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
            po.vUnreferencePdev();
        }
    }
    else
    {
        GreReleaseSemaphoreEx(ghsemDriverMgmt);
    }

    return (HDEV) ppdev;
}

/******************************Public*Routine******************************\
* vSynchronizeDriver
*
* Calls DrvSynchronize if the driver has set either GCAPS2_SYNCFLUSH
* or GCAPS2_SYNCTIMER, as appropriate.
*
* History:
*  15-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vSynchronizeDriver(FLONG flSynchronizeType)
{
    HDEV    hdev;

    //
    // Note that we check the synchronize counts outside of a lock, which
    // is okay.
    //

    if (((flSynchronizeType == GCAPS2_SYNCFLUSH) && (gcSynchronizeFlush != -1)) ||
        ((flSynchronizeType == GCAPS2_SYNCTIMER) && (gcSynchronizeTimer != -1)))
    {
        for (hdev = hdevEnumerate(NULL); hdev; hdev = hdevEnumerate(hdev))
        {
            PDEVOBJ pdo(hdev);

            ASSERTGDI(pdo.bValid(), "GreFlush: invalid PDEV");
            ASSERTGDI(pdo.bDisplayPDEV(), "GreFlush: not a display PDEV");

            if (pdo.flGraphicsCaps2NotDynamic() & flSynchronizeType)
            {
                GreAcquireSemaphoreEx(pdo.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
                GreEnterMonitoredSection(pdo.ppdev, WD_DEVLOCK);

                if ((pdo.flGraphicsCaps2() & flSynchronizeType) &&
                    !(pdo.bDisabled()))
                {
                    FLONG   fl = 0;

                    if ((flSynchronizeType == GCAPS2_SYNCFLUSH) &&
                        (gcSynchronizeFlush != -1))
                    {
                        fl |= DSS_FLUSH_EVENT;
                    }

                    if ((flSynchronizeType == GCAPS2_SYNCTIMER) &&
                        (gcSynchronizeTimer != -1))
                    {
                        fl |= DSS_TIMER_EVENT;
                    }

                    pdo.vSync(pdo.pSurface()->pSurfobj(), NULL, fl);
                }

                GreExitMonitoredSection(pdo.ppdev, WD_DEVLOCK);
                GreReleaseSemaphoreEx(pdo.hsemDevLock());
            }
        }
    }
}

/******************************Public*Routine******************************\
* GreFlush
*
* Called for GdiFlush.
*
* Calls DrvSynchronize if it is hooked and GCAPS2_SYNCFLUSH is set.
*
* History:
*  15-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreFlush()
{
    vSynchronizeDriver(GCAPS2_SYNCFLUSH);
}

/******************************Public*Routine******************************\
* GreSynchronizeTimer
*
* When the synchronization timer is enabled, this routine will be called
* by User's RIT.  We, in turn, call any driver that has set GCAPS_SYNCTIMER.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreSynchronizeTimer(PVOID pwnd, UINT msg, UINT_PTR id, LPARAM lParam)
{
    vSynchronizeDriver(GCAPS2_SYNCTIMER);
}

/******************************Public*Routine******************************\
* vEnableSynchronize
*
* This routine enables GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER
* synchronization for the driver.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vEnableSynchronize(HDEV hdev)
{
    GDIFunctionID(vEnableSynchronize);

    PDEVOBJ po(hdev);

    FLONG flCaps = po.flGraphicsCaps2();

    if (flCaps & (GCAPS2_SYNCFLUSH | GCAPS2_SYNCTIMER))
    {
        BOOL    AcquireUserCritSec;

        //
        // We will be calling User, which needs to acquire its critical
        // section.  The devlock must always be acquired after the User
        // critical section; consequently, we cannot be holding a devlock
        // at this point if we're not already holding the user lock.
        //

        AcquireUserCritSec = !UserIsUserCritSecIn();
        if (AcquireUserCritSec)
        {
            po.vAssertNoDevLock();
            UserEnterUserCritSec();
        }

        if (flCaps & GCAPS2_SYNCTIMER)
        {
            //
            // It's the responsibility of the first thread to increment
            // the count past -1 to create the timer.
            //

            if (++gcSynchronizeTimer == 0)
            {
                ASSERTGDI(gidSynchronizeTimer == 0,
                    "Expected no timer to have already been created.");

                //
                // Note that at boot time we actually expect this timer
                // creation to fail, as User hasn't had a chance to
                // create the RIT yet.  GreSetTimers handles the actual
                // timer creation for that case.  Because of this case,
                // we can't strictly fail here if the timer can't be
                // created; however, it's not the end of the world --
                // this will happen only in a degenerate case, and at
                // worst the video will be very jerky.
                //

                gidSynchronizeTimer = UserSetTimer(SYNCTIMER_FREQUENCY,
                                                   GreSynchronizeTimer);
            }
        }

        if (flCaps & GCAPS2_SYNCFLUSH)
        {
            gcSynchronizeFlush++;
        }

        po.vSynchronizeEnabled(TRUE);

        if (AcquireUserCritSec)
        {
            UserLeaveUserCritSec();
        }
    }
}

/******************************Public*Routine******************************\
* vDisableSynchronize(HDEV hdev)
*
* This routine disables GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER
* synchronization for the driver.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDisableSynchronize(HDEV hdev)
{
    GDIFunctionID(vDisableSynchronize);

    PDEVOBJ po(hdev);
    BOOL    AcquireUserCritSec;

    //
    // We will be calling User, which needs to acquire its critical
    // section.  The devlock must always be acquired after the User
    // critical section; consequently, we cannot be holding a devlock
    // at this point if we're not already holding the user lock.
    //

    AcquireUserCritSec = !UserIsUserCritSecIn();
    if (AcquireUserCritSec)
    {
        po.vAssertNoDevLock();
        UserEnterUserCritSec();
    }

    if (po.bSynchronizeEnabled())
    {
        FLONG flCaps = po.flGraphicsCaps2();

        if (flCaps & GCAPS2_SYNCFLUSH)
        {
            ASSERTGDI(gcSynchronizeFlush > -1, "Unexpected flush count");

            gcSynchronizeFlush--;
        }

        if (flCaps & GCAPS2_SYNCTIMER)
        {
            //
            // It's the responsibility of the first thread to decrement
            // the count to -1 to kill the timer.
            //

            ASSERTGDI(gcSynchronizeTimer > -1, "Unexpected timer count");

            if (--gcSynchronizeTimer < 0)
            {
                if (gidSynchronizeTimer != 0)
                {
                    UserKillTimer(gidSynchronizeTimer);
                    gidSynchronizeTimer = 0;
                }
            }
        }

        po.vSynchronizeEnabled(FALSE);
    }

    if (AcquireUserCritSec)
    {
        UserLeaveUserCritSec();
    }
}

/******************************Public*Routine******************************\
* GreStartTimers()
*
* Called by User when the RIT thread is finally initialized, and we
* can set up timers.  We need this because driver initialization
* occurs before the RIT is initialized, which would have been the
* natural place to put the timer initialization for us.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID GreStartTimers()
{
    GDIFunctionID(GreStartTimers);

    BOOL    AcquireUserCritSec;

    AcquireUserCritSec = !UserIsUserCritSecIn();
    if (AcquireUserCritSec)
    {
        UserEnterUserCritSec();
    }

    if (gcSynchronizeTimer != -1)
    {
        ASSERTGDI(gidSynchronizeTimer == NULL,
                "Expected no timer to have already been created.");

        gidSynchronizeTimer = UserSetTimer(SYNCTIMER_FREQUENCY,
                                           GreSynchronizeTimer);
    }

    if (AcquireUserCritSec)
    {
        UserLeaveUserCritSec();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\multi.cxx ===
/******************************Module*Header*******************************\
* Module Name: multi.cxx
*
* Supports splitting of request over multiple PDEVs
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PPALETTE DrvRealizeHalftonePalette(HDEV hdevPalette, BOOL bForce);

BOOL  gbMultiMonMismatchColor = FALSE;

RECTL grclEmpty;    // Implicitly initialized to (0,0,0,0)

BYTE  gaMixNeedsPattern[] = { 0, 0, 1, 1, 1, 1, 0, 1,
                              1, 1, 1, 0, 1, 1, 1, 1 };

#define ROP4_NEEDS_PATTERN(rop4) ((((rop4) >> 4) ^ (rop4)) & 0x0f0f)
// Work around for bug #362287
// #define MIX_NEEDS_PATTERN(mix)   (gaMixNeedsPattern[mix & 0xf])
#define MIX_NEEDS_PATTERN(mix)   (TRUE)

#define REALIZE_HALFTONE_PALETTE(hdev) (DrvRealizeHalftonePalette((hdev),FALSE))

typedef struct _MULTIFONTINFO
{
    PVDEV pvdev;
    PVOID pv[1];
} MULTIFONTINFO, *PMULTIFONTINFO;

class MULTIFONT {
private:
    FONTOBJ*        pfoOrg;
    PMULTIFONTINFO  pMultiFontInfo;

public:
    MULTIFONT(FONTOBJ *pfo, LONG csurf, PVDEV pvdev)
    {
        /********************************************************************
        *********************************************************************

            MulDestroyFont calls this constructor with csurf of -1 and a
            pvdev of NULL if and only if pfo->pvConsumer != NULL.  It needs to
            call the pvdev() method.  csurf and pvdev are ONLY referenced if
            pfo->pvConsumer == NULL.

            *** KEEP IT THAT WAY***

        *********************************************************************
        ********************************************************************/

        pfoOrg = pfo;

        if (pfoOrg)
        {
            if (pfoOrg->pvConsumer == NULL)
            {
                pfoOrg->pvConsumer = (PVOID)EngAllocMem(FL_ZERO_MEMORY,
                                      (sizeof(MULTIFONTINFO) + ((csurf-1) *
                                       sizeof(PVOID))), 'lumG');
                pMultiFontInfo = (PMULTIFONTINFO)pfoOrg->pvConsumer;
                if (pMultiFontInfo)
                {
                    pMultiFontInfo->pvdev = pvdev;
                }
                else
                {
                    KdPrint(("MULTIFONT::MULTIFONT failed table allocation\n"));
                }
            }
            else
            {
                pMultiFontInfo = (PMULTIFONTINFO)pfoOrg->pvConsumer;
            }
        }
    }

   ~MULTIFONT()
    {
        if (pfoOrg)
        {
            pfoOrg->pvConsumer = pMultiFontInfo;
        }
    }

    BOOL Valid()
    {
        return (pMultiFontInfo ? TRUE : FALSE);
    }

    VOID DestroyTable()
    {
        if (pfoOrg && (pMultiFontInfo != NULL))
        {
            EngFreeMem(pMultiFontInfo);
            pMultiFontInfo = NULL;
        }
    }

    VOID LoadElement(LONG i)
    {
        if (pfoOrg)
        {
            pfoOrg->pvConsumer = pMultiFontInfo->pv[i];
        }
    }

    VOID StoreElement(LONG i)
    {
        if (pfoOrg)
        {
            pMultiFontInfo->pv[i] = pfoOrg->pvConsumer;
        }
    }

    PVDEV pvdev()
    {
        return pMultiFontInfo->pvdev;
    }
};

typedef struct _MULTIREALIZEDBRUSH
{
    PVOID pvD;
    PVOID pvE;
} MULTIREALIZEDBRUSH;

typedef struct _MULTIBRUSHINFO
{
    ULONG              cSurfaces;
    MULTIREALIZEDBRUSH aBrush[1];
} MULTIBRUSHINFO, *PMULTIBRUSHINFO;

class MULTIBRUSH {
private:
    BOOL            bValid;
    EBRUSHOBJ*      pboOrg;
    SURFACE*        psurfOrg;
    XEPALOBJ        palSurfOrg;
    PMULTIBRUSHINFO pMultiBrushInfo;
    ULONG           iSolidColorOrg;
    PENGBRUSH       pengbrushOrg;

public:
    MULTIBRUSH(BRUSHOBJ *pbo,
               LONG      csurf,
               PVDEV     pvdev,
               SURFOBJ  *pso,
               BOOL      bPatternNeeded)
    {
        bValid = TRUE;

        // This function is monstrous and should probably be moved out of
        // line.  But beware that 'bPatternNeeded' is often passed in as
        // a constant 'FALSE', meaning that for those case this currently
        // expands to nothing.

        pboOrg = (EBRUSHOBJ*) pbo;

        // pso might be NULL, so we make sure to check psurfOrg
        // whenever we use it.

        psurfOrg = SURFOBJ_TO_SURFACE(pso);

        // Invalidate other fields.

        pMultiBrushInfo = NULL;
        iSolidColorOrg  = 0xffffffff;
        pengbrushOrg    = (PENGBRUSH)-1;

        if (pboOrg)
        {
            // Early out for solid brush.

            if ((!bPatternNeeded) || (pboOrg->iSolidColor != 0xffffffff))
            {
                // Keep original color index for iSolidColor.

                iSolidColorOrg = pboOrg->iSolidColor;

                return;
            }

            // Save the original palette for the surface (since we will switch the surface)

            palSurfOrg   = pboOrg->palSurf();

            if (pboOrg->pvRbrush == NULL)
            {
                LONG cj = (sizeof(MULTIBRUSHINFO) + ((csurf-1) * sizeof(MULTIREALIZEDBRUSH)));

                pboOrg->pvRbrush = BRUSHOBJ_pvGetRbrush(pboOrg);

                // It is possible that BRUSHOBJ_pvGetRbrush will fail because
                // the hatch type of the brush is NULL.  In this case we have
                // pMultiBrushInfo == NULL even though there is a brush.  This will
                // be ok because the pvRbrush will not be accessed for such a
                // brush.

                pMultiBrushInfo = (PMULTIBRUSHINFO)pboOrg->pvRbrush;

                if (pMultiBrushInfo)
                {
                    memset (pMultiBrushInfo, 0, cj);
                    pMultiBrushInfo->cSurfaces = pvdev->cSurfaces;

                    PRBRUSH prbrush = (PDBRUSH)DBRUSHSTART(pboOrg->pvRbrush);
                    prbrush->bMultiBrush(TRUE);
                }
                else
                {
                    bValid = FALSE;
                }
            }
            else
            {
                pMultiBrushInfo = (PMULTIBRUSHINFO)pboOrg->pvRbrush;
            }
        }
    }

   ~MULTIBRUSH()
    {
    }

    BOOL Valid()
    {
        return (bValid);
    }

    VOID DestroyTable()
    {
        // NOTE: This routine MUST NOT access any data in from 'pvdev',
        // as the DDML may already be disabled, and 'pvdev' freed, when
        // this brush is deleted.

        if (pboOrg && (pMultiBrushInfo != NULL))
        {
            ULONG csurf = pMultiBrushInfo->cSurfaces;

            ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

            while (csurf)
            {
                csurf--;

                // Free the driver's DBRUSH if there is one

                PVOID pvRbrush;

                if (pvRbrush = pMultiBrushInfo->aBrush[csurf].pvD)
                {
                    PRBRUSH prbrush = (PDBRUSH) DBRUSHSTART(pvRbrush);
                                        // point to DBRUSH (pvRbrush points to
                                        // realization, which is at the end of DBRUSH)
                    prbrush->vRemoveRef(RB_DRIVER);
                                        // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
                    pMultiBrushInfo->aBrush[csurf].pvD = NULL;
                }

                if (pvRbrush = pMultiBrushInfo->aBrush[csurf].pvE) 
                {
                    PRBRUSH prbrush = (PENGBRUSH) pvRbrush;
                                        // point to engine brush realization
                    prbrush->vRemoveRef(RB_ENGINE);
                                        // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
                    pMultiBrushInfo->aBrush[csurf].pvE = NULL;
                }
            }
        }
    }

    VOID LoadElement(DISPSURF *pds, SURFACE *psurf)
    {
        if (pboOrg)
        {
            // If psurf == NULL, we were called from MulDestroyBrush.
            // We just leave the brush associated with the multi layer.
            // Otherwise, associate it with the driver we're about to call.

            if (psurf != NULL)
            {
                if (pds->iCompatibleColorFormat != 0)
                {
                    PDEVOBJ  pdo(pds->hdev);
                    PPALETTE ppalDC = ppalDefault;

                    //
                    // If this is palette managed device, use halftone palette.
                    //
                    if (pdo.bIsPalManaged())
                    {
                        ppalDC = REALIZE_HALFTONE_PALETTE(pdo.hdev());
                    }

                    //
                    // If current device has higher color depth than primary
                    // and this dithered brush. we don't use dithered brush
                    // on this, just use solid color here... since this device
                    // should be able to produce much colors...
                    //
                    if ((pds->iCompatibleColorFormat > 0) &&
                        (pboOrg->iSolidColor == 0xffffffff) &&
                        (pboOrg->crDCPalColor() != 0xffffffff))
                    {
                        // Try to map the solid color from surface palette.

                        pboOrg->iSolidColor = ulGetNearestIndexFromColorref(
                                                  psurf->ppal(),
                                                  ppalDC,
                                                  pboOrg->crDCPalColor());
  
                        // Behave as solid color brush.

                        pboOrg->pvRbrush = NULL;
                    }
                    //
                    // If this is solid color, map color index in destination
                    // device palette. we can not use the color index from
                    // meta device when this is different color depth than
                    // primary.
                    //
                    else if (pboOrg->iSolidColor != 0xffffffff)
                    {
                        // Try to map the solid color from surface palette.

                        pboOrg->iSolidColor = ulGetNearestIndexFromColorref(
                                                  psurf->ppal(),
                                                  ppalDC,
                                                  pboOrg->crDCPalColor());

                        // ASSERTGDI(pboOrg->pvRbrush == NULL,
                        //          "MBRUSH:LoadElement(): solid brush, but Rbrush != NULL\n");
                    }
                    else if (pMultiBrushInfo)
                    {
                        // Save the original engine brush, then replace with device specific one.

                        pengbrushOrg = pboOrg->pengbrush();
                        pboOrg->pengbrush((ENGBRUSH *)(pMultiBrushInfo->aBrush[pds->iDispSurf].pvE));

                        // Get device specifc Dbrush.

                        pboOrg->pvRbrush = pMultiBrushInfo->aBrush[pds->iDispSurf].pvD;
                    }
                }
                else if (pMultiBrushInfo)
                {
                    // Get device specifc Dbrush.

                    pboOrg->pvRbrush = pMultiBrushInfo->aBrush[pds->iDispSurf].pvD;
                }

                if (pMultiBrushInfo)
                {
                    pboOrg->psoTarg(psurf);

                    if (psurf->ppal())
                    {
                        pboOrg->palSurf(psurf->ppal());
                    }
                }
            }
        }
    }

    VOID StoreElement(LONG i)
    {
        if (pboOrg)
        {
            if (pMultiBrushInfo)
            {
                // Restore engine brush (if saved)

                if (pengbrushOrg != (PENGBRUSH)-1)
                {
                #if DBG
                    if (pengbrushOrg)
                    {
                        // Make sure the engbrush is not freed.
                        // If freed, this might causes bugcheck.
                        pengbrushOrg->vAddRef();
                        pengbrushOrg->vRemoveRef(RB_ENGINE);
                    }
                #endif

                    pMultiBrushInfo->aBrush[i].pvE = pboOrg->pengbrush();
                    pboOrg->pengbrush(pengbrushOrg);
                    pengbrushOrg = (PENGBRUSH)-1;
                }

                // Restore device brush.

                pMultiBrushInfo->aBrush[i].pvD = pboOrg->pvRbrush;

                if (psurfOrg)
                {
                    pboOrg->psoTarg(psurfOrg);
                }

                if (palSurfOrg.bValid())
                {
                    pboOrg->palSurf(palSurfOrg);
                }
            }

            pboOrg->iSolidColor = iSolidColorOrg;
            pboOrg->pvRbrush    = pMultiBrushInfo;
        }
    }
};

/******************************Public*Routine******************************\
* BOOL GreIsPaletteDisplay
*
* Return TRUE if the display is palettized
*
* History:
*  1-Jan-1997 -by- Vadim Gorokhovsky [vadimg]
\**************************************************************************/

BOOL GreIsPaletteDisplay(HDEV hdev)
{
    PDEVOBJ po(hdev);
    ASSERTGDI(po.bValid(), "Invalid PDEV");
    return (po.GdiInfoNotDynamic()->flRaster & RC_PALETTE);
}

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL FASTCALL bIntersect(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2,
RECTL*          prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* Returns TRUE if 'prcl1' and 'prcl2' intersect.
*
\**************************************************************************/

BOOL FASTCALL bIntersect(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2)
{
    return((prcl1->left   < prcl2->right)  &&
           (prcl1->top    < prcl2->bottom) &&
           (prcl1->right  > prcl2->left)   &&
           (prcl1->bottom > prcl2->top));
}

/******************************Public*Routine******************************\
* BOOL bContains
*
* Returns TRUE if 'prcl1' contains 'prcl2'.
*
\**************************************************************************/

BOOL FASTCALL bContains(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2)
{
    return((prcl1->left   <= prcl2->left)  &&
           (prcl1->right  >= prcl2->right) &&
           (prcl1->top    <= prcl2->top)   &&
           (prcl1->bottom >= prcl2->bottom));
}

/******************************Public*Routine******************************\
* BOOL MSURF::bFindSurface
*
* Given the drawing bounds and clip object, this routine finds a surface
* that will be affected by the drawing.  The child surface's driver should
* then be called using MSURF's public 'pso' surface and 'pco' clip object
* members.
*
* If no surface can be found (the drawing is occuring off-screen from all
* video cards), FALSE is returned.
*
\**************************************************************************/

BOOL MSURF::bFindSurface(
SURFOBJ*    psoOriginal,
CLIPOBJ*    pcoOriginal,
RECTL*      prclDraw)
{
    GDIFunctionID(MSURF::bFindSurface);

    pvdev = (VDEV*) psoOriginal->dhpdev;

    ASSERTGDI((prclDraw->left < prclDraw->right) &&
              (prclDraw->top < prclDraw->bottom),
        "Poorly ordered draw rectangle");

    pmdsurf = NULL;
    if (psoOriginal->iType == STYPE_DEVBITMAP)
    {
        PDEVOBJ pdo(psoOriginal->hdev);
        ASSERTGDI(pdo.bValid() && pdo.bMetaDriver(), "Surface is not a valid Meta surface");

        // Some drivers want to hook drawing calls to device bitmaps and
        // DIBs.  We handle those cases here.

        pmdsurf = (MDSURF*) psoOriginal->dhsurf;

        ASSERTGDI(pmdsurf != NULL, "Unexpected NULL dhsurf");

        pco = pcoOriginal;

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (pmdsurf->apso[pds->iDispSurf] != NULL)
            {
                pso  = pmdsurf->apso[pds->iDispSurf];
                pOffset = &gptlZero;

                return(TRUE);
            }
        }
    }
    else
    {
        // Okay, the drawing is to the screen:

        if ((pcoOriginal == NULL) || (pcoOriginal->iDComplexity == DC_TRIVIAL))
        {
            pco                  = pvdev->pco;
            iOriginalDComplexity = DC_TRIVIAL;
            rclOriginalBounds    = pco->rclBounds;
            rclDraw              = *prclDraw;
        }
        else
        {
            pco                  = pcoOriginal;
            iOriginalDComplexity = pco->iDComplexity;
            rclOriginalBounds    = pco->rclBounds;

            // Intersect the drawing bounds with the clipping bounds, because
            // we touch pixels that intersect both:

            if (!bIntersect(prclDraw, &rclOriginalBounds, &rclDraw))
            {
                return(FALSE);
            }
        }

        // Find the first surface that is affected:

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            // WINBUG #340569 3-29-2001 jasonha
            //  Prevent access to screen during mode change / full screen mode

            if (!pds->po.bDisabled())
            {
                // First, test for the trivial case where the drawing is
                // contained entirely within this surface:

                if ((iOriginalDComplexity == DC_TRIVIAL) &&
                    (rclDraw.left   >= pds->rcl.left)    &&
                    (rclDraw.top    >= pds->rcl.top)     &&
                    (rclDraw.right  <= pds->rcl.right)   &&
                    (rclDraw.bottom <= pds->rcl.bottom))
                {
                    pco->iDComplexity = DC_TRIVIAL;
                    pco->rclBounds    = rclDraw;

                    pso     = pds->pso;
                    pOffset = &pds->Off;

                    return(TRUE);
                }
                else if (bIntersect(&rclDraw, &pds->rcl, &pco->rclBounds))
                {
                    // Since the drawing is not contained entirely within this
                    // surface, then we don't have DC_TRIVIAL clipping:

                    pco->iDComplexity = (iOriginalDComplexity != DC_TRIVIAL)
                                      ? iOriginalDComplexity
                                      : DC_RECT;

                    pso     = pds->pso;
                    pOffset = &pds->Off;

                    return(TRUE);
                }
            }
        }

        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL MSURF::bNextSurface
*
* Finds the next driver surface that is affected by the drawing call.
*
* Returns FALSE if no surface can be found.
*
\**************************************************************************/

BOOL MSURF::bNextSurface()
{
    if (pmdsurf != NULL)
    {
        // Find the next driver that wants to hook drawing to device
        // bitmaps and DIBs.

        for (pds = pds->pdsNext; pds != NULL; pds = pds->pdsNext)
        {
            if (pmdsurf->apso[pds->iDispSurf] != NULL)
            {
                pso  = pmdsurf->apso[pds->iDispSurf];
                pOffset = &gptlZero;

                return(TRUE);
            }
        }
    }
    else
    {
        // Find the next driver that is affected by this drawing to the
        // screen.

        for (pds = pds->pdsNext; pds != NULL; pds = pds->pdsNext)
        {
            // WINBUG #340569 3-29-2001 jasonha
            //  Prevent access to screen during mode change / full screen mode

            if (!pds->po.bDisabled())
            {
                // First, test for the trivial case where the drawing is
                // contained entirely within this surface:
    
                if ((iOriginalDComplexity == DC_TRIVIAL) &&
                    (rclDraw.left   >= pds->rcl.left)    &&
                    (rclDraw.top    >= pds->rcl.top)     &&
                    (rclDraw.right  <= pds->rcl.right)   &&
                    (rclDraw.bottom <= pds->rcl.bottom))
                {
                    pco->iDComplexity = DC_TRIVIAL;
    
                    pso     = pds->pso;
                    pOffset = &pds->Off;
    
                    return(TRUE);
                }
    
                else if (bIntersect(&rclDraw, &pds->rcl, &pco->rclBounds))
                {
                    // Since the drawing is not contained entirely within this
                    // surface, then we don't have DC_TRIVIAL clipping:
    
                    pco->iDComplexity = (iOriginalDComplexity != DC_TRIVIAL)
                                      ? iOriginalDComplexity
                                      : DC_RECT;
    
                    pso     = pds->pso;
                    pOffset = &pds->Off;
    
                    return(TRUE);
                }
            }
        }

        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }

    return(FALSE);
}

/******************************Member*Routine******************************\
* MSURF::vRestore
*
* Restores state that may have been changed by bFindSurface/bNextSurface.
*
* Note: This must always be used when bFindSurface/bNextSurface return
*       TRUE, but won't be called again.  (Early loop termination.)
*
\**************************************************************************/

void MSURF::vRestore()
{
    // WINBUG: 451121 pravins 08/07/2001 Should be checking for non DEVBITMAP case here. For time being just check the PCO.
    if (pmdsurf != NULL && pco != NULL)
    {
        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }
}


/*****************************Private*Routine******************************\
* MULTISURF::vInit
*
* Initializes members and prepares default source surface values
*
\**************************************************************************/

void
MULTISURF::vInit(
    SURFOBJ *psoOriginal,
    RECTL *prclOriginal
    )
{
    GDIFunctionID(MULTISURF::vInit);

    pso = psoOriginal;
    prcl = &rclOrg;
    fl = 0;
    pmdsurf = NULL;

    if (psoOriginal != NULL)
    {
        rclOrg = *prclOriginal;
        dhpdevOrg = psoOriginal->dhpdev;

        // Is this a device associated bitmap?
        if (dhpdevOrg != NULL)
        {
            // Save original source settings
            psurfOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal);
            dhsurfOrg = psurfOrg->dhsurf();
            flagsOrg = psurfOrg->flags();

            PDEVOBJ pdo(psurfOrg->hdev());

            ASSERTGDI(pdo.bValid(), "Source doesn't have a valid HDEV");

            // Setup up source
            if (psurfOrg->iType() == STYPE_DEVBITMAP && pdo.bMetaDriver())
            {
                pmdsurf = (MDSURF*) dhsurfOrg;

                ASSERTGDI(psurfOrg->pvBits() != NULL, "Meta DEVBITMAP doesn't have pvBits");

                // Unmark source to make it look like a DIB
                fl = MULTISURF_SET_AS_DIB;
                psurfOrg->iType(STYPE_BITMAP);
                psurfOrg->dhsurf(NULL);
                psurfOrg->dhpdev(NULL);
                psurfOrg->flags(0);
            }
            else
            {
                // Is the surface opaque or does it live in video memory?
                if (psurfOrg->iType() != STYPE_BITMAP ||
                    pso->fjBitmap & BMF_NOTSYSMEM)
                {
                    fl = MULTISURF_USE_COPY;
                }
            }
        }
    }
    else
    {
        dhpdevOrg = NULL;
    }
}


/*****************************Private*Routine******************************\
* MULTISURF::bCreateDIB
*
* Creates a DIB copy of the original surface and computes an adjusted
* rectangle/origin for the surface.
*
\**************************************************************************/

BOOL
MULTISURF::bCreateDIB()
{
    GDIFunctionID(MULTISURF::bCreateDIB);

    ASSERTGDI(!SurfDIB.bValid(), "SurfDIB already created");

    PDEVOBJ  pdo(psurfOrg->hdev());

    ERECTL erclTrim(0L,
                    0L,
                    psurfOrg->sizl().cx,
                    psurfOrg->sizl().cy);

    // Find intersection of surface and area needed
    erclTrim *= rclOrg;

    ERECTL erclTmp(0L,
                   0L,
                   erclTrim.right - erclTrim.left,
                   erclTrim.bottom - erclTrim.top);

    DEVBITMAPINFO dbmi;
    dbmi.iFormat    = psurfOrg->iFormat();
    dbmi.cxBitmap   = erclTmp.right;
    dbmi.cyBitmap   = erclTmp.bottom;
    dbmi.hpal       = psurfOrg->ppal() ? (HPALETTE)psurfOrg->ppal()->hGet() : 0;
    ASSERTGDI(!psurfOrg->bUMPD(), "UMPD surface");
    dbmi.fl         = BMF_TOPDOWN;

    if (!SurfDIB.bCreateDIB(&dbmi, NULL))
    {
        WARNING("Failed SurfDIB memory allocation\n");
        return FALSE;
    }


    (*PPFNDRV(pdo,CopyBits)) (SurfDIB.pSurfobj(),
                              &psurfOrg->so,
                              (CLIPOBJ *) NULL,
                              NULL,
                              (PRECTL) &erclTmp,
                              (POINTL *) &erclTrim);

    rclDIB.left   = prcl->left   - erclTrim.left;
    rclDIB.top    = prcl->top    - erclTrim.top;
    rclDIB.right  = prcl->right  - erclTrim.left;
    rclDIB.bottom = prcl->bottom - erclTrim.top;

    return TRUE;
}


/*****************************Public*Members*******************************\
* BOOL MULTISURF::bLoadSource (2 versions)
*
* Prepares the next source surface for the given destination as follows:
*
*  For a non-device BITMAP (dhpdev = NULL), the orignal surface is used.
*
*  For a Meta DEVBITMAP, a matching device surface is used or if there
*   isn't a match the backing DIB is used (unmarked during vInit).
*
*  For other surfaces, if the destination device is different the original
*   surface is unmarked to look like a DIB when the bits are present in
*   system memory or a DIB copy is created.
*
* Returns FALSE if no surface can be prepared.
*
\**************************************************************************/

BOOL MULTISURF::bLoadSource(
    DISPSURF* pdsDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSource);

    BOOL bRet = TRUE;

    // If this is a device bitmap, there is work to do.
    if (dhpdevOrg != NULL)
    {
        if (pmdsurf != NULL)
        {
            // Meta DEVBITMAP:
            //  Use device managed bitmap for source, else go for the DIB
            pso = pmdsurf->apso[pdsDst->iDispSurf];

            if (pso == NULL)
            {
                pso = &psurfOrg->so;
            }
        }
        else
        {
            bRet = bLoadSourceNotMetaDEVBITMAP(pdsDst->hdev);
        }
    }

    return bRet;
}

BOOL MULTISURF::bLoadSource(
    HDEV hdevDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSource);

    BOOL bRet = TRUE;

    // If this is a device bitmap, there is work to do.
    if (dhpdevOrg != NULL)
    {
        if (pmdsurf != NULL)
        {
            // Meta DEVBITMAP:
            //  Use device managed bitmap for source, else go for the DIB
            VDEV *pvdev = pmdsurf->pvdev;
            DISPSURF *pds;

            ASSERTGDI(pvdev != NULL, "pvdev is NULL.\n");

            for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
            {
                if (pds->hdev == hdevDst)
                {
                    pso = pmdsurf->apso[pds->iDispSurf];
                    break;
                }
            }

            if (pso == NULL)
            {
                pso = &psurfOrg->so;
            }
        }
        else
        {
            bRet = bLoadSourceNotMetaDEVBITMAP(hdevDst);
        }
    }

    return bRet;
}


/*****************************Private*Member*******************************\
* BOOL MULTISURF::bLoadSourceNotMetaDEVBITMAP
*
*  If the destination device is different the original surface is unmarked
*   to look like a DIB when the bits are present in system memory or a DIB
*   copy is created.
*
* Returns FALSE if no surface can be prepared.
*
* NOTE: This routine assumes BITMAPs and Meta DEVBITMAPs have already been
*       handled and won't come here.  See bLoadSource members.
*
\**************************************************************************/

BOOL MULTISURF::bLoadSourceNotMetaDEVBITMAP(
    HDEV hdevDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSourceNotMetaDEVBITMAP);

    if (fl & MULTISURF_USE_COPY)
    {
        // Opaque or video memory surface:
        //  Use a DIB copy if destination doesn't match the source
        if (psurfOrg->hdev() != hdevDst)
        {
            // Do we already have a DIB copy?
            if (!SurfDIB.bValid())
            {
                // Allocate an intermediate DIB for a source
                if (!bCreateDIB())
                {
                    return FALSE;
                }
            }

            // Make pso and prcl point to the copy
            pso = SurfDIB.pSurfobj();
            prcl = &rclDIB;
        }
        else
        {
            // Just use original surface
            pso = &psurfOrg->so;
            prcl = &rclOrg;
        }
    }
    else
    {
        // BITMAP in system memory:
        //  Unmark to appear as DIB if destination doesn't match the source
        if (psurfOrg->hdev() != hdevDst)
        {
            if (!(fl & MULTISURF_SET_AS_DIB))
            {
                if (!(fl & MULTISURF_SYNCHRONIZED))
                {
                    PDEVOBJ pdo(psurfOrg->hdev());
                    pdo.vSync(pso, prcl, 0);
                    fl |= MULTISURF_SYNCHRONIZED;
                }

                // Unset fields to look like a DIB
                fl |= MULTISURF_SET_AS_DIB;
                psurfOrg->dhpdev(NULL);
                psurfOrg->dhsurf(NULL);
                psurfOrg->flags(0);
            }
        }
        else
        {
            if (fl & MULTISURF_SET_AS_DIB)
            {
                // Restore original settings
                fl &= ~MULTISURF_SET_AS_DIB;
                psurfOrg->dhpdev(dhpdevOrg);
                psurfOrg->dhsurf(dhsurfOrg);
                psurfOrg->flags(flagsOrg);
            }
        }
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* BOOL MulEnableDriver
*
* Standard driver DrvEnableDriver function
*
\**************************************************************************/

BOOL MulEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnMulti;
    pded->c              = gcdrvfnMulti;
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DHPDEV MulEnablePDEV
*
* Creates a single large VDEV that will represent the combination of other
* smaller PDEVs
*
* This function creates an internal structure that keeps the location of
* the various cards, and also keeps the appropriate data structures to
* be passed down to each driver.
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW *pdm,
LPWSTR    pwszLogAddress,
ULONG     cPat,
HSURF    *phsurfPatterns,
ULONG     cjCaps,
GDIINFO  *pdevcaps,
ULONG     cjDevInfo,
DEVINFO  *pdi,
HDEV      hdev,
LPWSTR    pwszDeviceName,
HANDLE    hDriver)
{
    PMDEV       pmdev = (PMDEV) pdm;
    PVDEV       pvdev;
    DISPSURF    dsAnchor;
    DISPSURF*   pds;
    DISPSURF*   pdsPrev;
    DISPSURF*   pdsTmp;
    HDEV*       paHdev;
    ULONG       i,j;
    ULONG       flGraphicsCaps  = 0xffffffff;
    ULONG       flGraphicsCaps2 = 0xffffffff;
    HDEV        hdevPrimary = NULL;
    BOOL        bPrimaryPalManaged  = FALSE;

    pdsPrev = &dsAnchor;

    // Create the main multi dispsurf structure.

    LONG cjAlloc = ((sizeof(VDEV)) + (sizeof(DISPSURF) * pmdev->chdev));

    pvdev = (VDEV*) EngAllocMem(FL_ZERO_MEMORY, cjAlloc, 'vdVG');
    if (pvdev == NULL)
        return(NULL);

    paHdev = (HDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(HDEV) * pmdev->chdev, 'sdvG');
    if (paHdev == NULL)
    {
        EngFreeMem(pvdev);
        return(NULL);
    }

    pds = (DISPSURF*) ((BYTE*)pvdev + sizeof(VDEV));

    pvdev->cSurfaces = pmdev->chdev;
    pvdev->hdev      = hdev;

    // Loop through the list of MDEVs passed in.

    pvdev->rclBounds.left =   0x7fffffff;
    pvdev->rclBounds.top =    0x7fffffff;
    pvdev->rclBounds.right =  0x80000000;
    pvdev->rclBounds.bottom = 0x80000000;

    ASSERTGDI((pmdev->chdev > 0), "Expected at least one surface in the list.");

    for (i = 0; i < pmdev->chdev; i++)
    {
        // Set this PDEV as parent to each of the PDEVs that we'll manage.

        PDEVOBJ pdo(pmdev->Dev[i].hdev);

    #if TEXTURE_DEMO
        if ((pmdev->Dev[i].rect.left == 0) && (pmdev->Dev[i].rect.top == 0))
    #else
        if (pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
    #endif
        {
            ASSERTGDI(!hdevPrimary, "2 or more primary devices in MulEnablePDEV");
            ASSERTGDI(pmdev->Dev[i].rect.left == 0, "mispositioned primary");
            ASSERTGDI(pmdev->Dev[i].rect.top == 0, "mispositioned primary");

            hdevPrimary = pdo.hdev();
            bPrimaryPalManaged = pdo.bIsPalManaged();

            *pdevcaps = *pdo.GdiInfo();
            *pdi = *pdo.pdevinfo();
        }

        // Take the intersection of flags that are capabilities.

        flGraphicsCaps  &= pdo.pdevinfo()->flGraphicsCaps;
        flGraphicsCaps2 &= pdo.pdevinfo()->flGraphicsCaps2;

        pdsPrev->pdsNext    = pds;
        pdsPrev->pdsBltNext = pds;

        pds->iDispSurf      = i;
        pds->rcl            = *((PRECTL) &(pmdev->Dev[i].rect));

        pds->hdev  = pmdev->Dev[i].hdev;
        pds->po.vInit(pds->hdev);
        pds->po.vReferencePdev();

        pds->Off.x = -pdo.pptlOrigin()->x;
        pds->Off.y = -pdo.pptlOrigin()->y;
        pds->pso   =  pdo.pSurface()->pSurfobj();

        // Primary (readable) surfaces are always first in the MDEV structure;
        // Secondary (non-readable) surfaces are always second.  So if this
        // surfaces overlaps a previous one, this surface must be non-readable:

        pds->bIsReadable = TRUE;
        for (pdsTmp = dsAnchor.pdsNext; pdsTmp != pds; pdsTmp = pdsTmp->pdsNext)
        {
            if (bIntersect(&pdsTmp->rcl, &pds->rcl))
                pds->bIsReadable = FALSE;
        }

        // Adjust bounding rectangle:

        pvdev->rclBounds.left   = min(pvdev->rclBounds.left,   pds->rcl.left);
        pvdev->rclBounds.top    = min(pvdev->rclBounds.top,    pds->rcl.top);
        pvdev->rclBounds.right  = max(pvdev->rclBounds.right,  pds->rcl.right);
        pvdev->rclBounds.bottom = max(pvdev->rclBounds.bottom, pds->rcl.bottom);

        pdsPrev = pds;
        pds++;
    }

    ASSERTGDI(hdevPrimary, "No primary devices found in MulEnablePDEV");

    // Make these numbers negative since we don't want them scaled again
    // by GDI.

    pdevcaps->ulHorzSize = (ULONG) -((LONG)pdevcaps->ulHorzSize);
    pdevcaps->ulVertSize = (ULONG) -((LONG)pdevcaps->ulVertSize);

    // Plug in the intersection of the GCAPS:

    flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE | GCAPS_PANNING);

    // If primary is palette managed device, make it Meta device palette managed, too.

    if (bPrimaryPalManaged)
        pdi->flGraphicsCaps = (flGraphicsCaps | GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    else
        pdi->flGraphicsCaps = flGraphicsCaps;

    pdi->flGraphicsCaps2 = flGraphicsCaps2;

    pvdev->iBitmapFormat = pdi->iDitherFormat;

    // Set the root of the list of dispsurfs

    pvdev->pds    = dsAnchor.pdsNext;
    pvdev->pdsBlt = dsAnchor.pdsNext;

    // Set hdev primary

    pvdev->hdevPrimary = hdevPrimary;

    PDEVOBJ poMeta(hdev);

    // Walk through pds list to check each device's colour depth and format

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);

        if (poThis.hdev() == hdevPrimary)
        {
            // This is primary PDEV. 0 means compatible.

            pds->iCompatibleColorFormat = 0;

            KdPrint(("GDI DDML: %ws - iDitherFormat is %d, and this is primary.\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        poThis.iDitherFormat()));
        }
        else
        {
            // Compare colour depth primary and this device.
            //
            // iCompatibleColorFormat will be ...
            //     0           - same as the primary
            //     Plus value  - higher colour depth than primary
            //     Minus value - lower colour depth than primary 

            pds->iCompatibleColorFormat = (poThis.iDitherFormat() - pvdev->iBitmapFormat);

            KdPrint(("GDI DDML: %ws - iDitherFormat is %d.\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        poThis.iDitherFormat()));

            KdPrint(("GDI DDML: %ws - PalManaged - %s\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        (poThis.bIsPalManaged() ? "Yes" : "No")));

            // If colour depth is same check palette format.

            if (pds->iCompatibleColorFormat == 0)
            {
                EPALOBJ palMeta(pdi->hpalDefault);
                EPALOBJ palThis(poThis.pdevinfo()->hpalDefault);

                // Compare the palette type.
                //
                // If not equal, treat it as 1 (this is higher colour depth than primary)

                pds->iCompatibleColorFormat =
                    ((palMeta.iPalMode() == palThis.iPalMode()) ? 0 : 1);

                KdPrint(("GDI DDML: %ws - iPalMode is %d.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                            palThis.iPalMode()));

                if ((pds->iCompatibleColorFormat == 0) &&
                    (palMeta.iPalMode() == PAL_BITFIELDS))
                {
                    // If the palette is bitfields, should check R, G, B assignment.
                    //
                    // If not equal, treat it as 1 (this is higher colour depth than primary)

                    pds->iCompatibleColorFormat =
                       (((palMeta.flRed() == palThis.flRed()) &&
                         (palMeta.flGre() == palThis.flGre()) &&
                         (palMeta.flBlu() == palThis.flBlu())) ? 0 : 1);
                }
            }

            // Mark in global variable if one of device is not same as Meta.

            if (pds->iCompatibleColorFormat != 0)
            {
                // mark hdev in this mdev does not have same color depth.

                pmdev->ulFlags |= MDEV_MISMATCH_COLORDEPTH;

                gbMultiMonMismatchColor = TRUE;

                KdPrint(("GDI DDML: %ws is NOT compatible as primary.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName));
            }
            else
            {
                // This flag should not be back to FALSE, if system once became mismatch
                // color depth mode. This flag only can be FALSE, when system NEVER experience
                // mismatch color depth mode since system booted.
                //
                // gbMultiMonMismatchColor = FALSE;

                KdPrint(("GDI DDML: %ws is compatible as primary.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName));
            }
        }
    }

    // Set the origin in the meta-PDEV.  Note that we do NOT set 'ptlOffset'
    // in the surface, as that would cause all our drawing to the meta-surface
    // to be offset by that amount, which is NOT what we want.

    poMeta.ppdev->ptlOrigin.x = pvdev->rclBounds.left;
    poMeta.ppdev->ptlOrigin.y = pvdev->rclBounds.top;
    poMeta.ppdev->sizlMeta.cx = pvdev->rclBounds.right - pvdev->rclBounds.left;
    poMeta.ppdev->sizlMeta.cy = pvdev->rclBounds.bottom - pvdev->rclBounds.top;

    // Mark this as Meta-PDEV.

    poMeta.bMetaDriver(TRUE);

    KdPrint(("GDI DDML: %li devices at (%li, %li, %li, %li).\n",
        pmdev->chdev, pvdev->rclBounds.left, pvdev->rclBounds.top,
        pvdev->rclBounds.right, pvdev->rclBounds.bottom));

#if TEXTURE_DEMO
    if (ghdevTextureParent)
    {
        paHdev[0] = ghdevTextureParent;
        vSpEnableMultiMon(hdev, 1, paHdev);         // References 'paHdev'
        return((DHPDEV) pvdev);
    }
#endif

    // Initialize Sprite stuff.
    // (Put Mirroring device first, then other drivers).

    j = 0;

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdoTmp(pmdev->Dev[i].hdev);
        if (pdoTmp.flGraphicsCaps() & GCAPS_LAYERED)
        {
            paHdev[j++] = pmdev->Dev[i].hdev;
        }
    }

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdoTmp(pmdev->Dev[i].hdev);
        if (!(pdoTmp.flGraphicsCaps() & GCAPS_LAYERED))
        {
            paHdev[j++] = pmdev->Dev[i].hdev;
        }
    }

    vSpEnableMultiMon(hdev, pmdev->chdev, paHdev);  // References 'paHdev'

    return((DHPDEV) pvdev);
}

/******************************Public*Routine******************************\
* VOID MulDisablePDEV
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    DISPSURF*   pds;

    pvdev = (PVDEV) dhpdev;

    vSpDisableMultiMon(pvdev->hdev); // Frees 'paHdev'

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        pds->po.vUnreferencePdev();
    }

    EngFreeMem(pvdev);
}

/******************************Public*Routine******************************\
* VOID MulCompletePDEV
*
* This function informs us of the 'hdev' that GDI has assigned us.
* We already got that initially information from MulEnablePDEV, but
* GDI reassigns 'hdev's during some mode changes.
*
* WINBUG #289937 01-23-2001 jasonha
*   PDEV still has a reference after removing a monitor
*
* If we are being assigned an 'hdev' that was previously assigned to
* one of the children, then that child is taking over our previously
* assigned 'hdev'.  We update our 'hdev's accordingly.
* NOTE: We must be able to grab ghsemDriverMgmt to successfully
*       reference and unreference PDEV's.
*
* All of the layered drivers that have hdev changes have their
* DrvCompletePDEV functions called directly by GDI.
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    GDIFunctionID(MulCompletePDEV);

    PVDEV       pvdev = (PVDEV) dhpdev;
    HDEV        hdevPrev = pvdev->hdev;
    DISPSURF*   pds;

    if (hdevPrev != hdev)
    {
        // Update hdevPrimary
        if (pvdev->hdevPrimary == hdev)
        {
            pvdev->hdevPrimary = hdevPrev;
        }

        // Update child 'hdev's
        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (pds->po.hdev() == hdev)
            {
                ASSERTGDI(pds->po.cPdevRefs() > 1, "Incorrect PDEV reference count.\n");
                pds->po.vUnreferencePdev();

                pds->hdev = hdevPrev;
                pds->po.vInit(hdevPrev);
                pds->po.vReferencePdev();
            }
        }

        pvdev->hdev = hdev;
    }
}

/******************************Public*Routine******************************\
* HSURF MulEnableSurface
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    SIZEL       sizlVirtual;
    HSURF       hsurfVirtual;
    HSURF       hsurf;
    CLIPOBJ*    pco;
    SURFACE    *psurf;

    pvdev = (VDEV*) dhpdev;

    // Note that we don't hook SYNCHRONIZE because we always return a
    // device managed surface to GDI.

    pvdev->flHooks = (HOOK_BITBLT
                    | HOOK_TEXTOUT
                    | HOOK_STROKEPATH
                    | HOOK_FILLPATH
                    | HOOK_STROKEANDFILLPATH
                    | HOOK_LINETO
                    | HOOK_COPYBITS
                    | HOOK_STRETCHBLT
                    | HOOK_GRADIENTFILL
                    | HOOK_TRANSPARENTBLT
                    | HOOK_ALPHABLEND);

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pvdev->rclBounds.right - pvdev->rclBounds.left;
    sizlVirtual.cy = pvdev->rclBounds.bottom - pvdev->rclBounds.top;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pvdev,
                                          sizlVirtual,
                                          pvdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pvdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pvdev->hdev, pvdev->flHooks))
        goto ReturnFailure;

    // Get and save a pointer to the SURFOBJ for the DDML

    pvdev->pso = EngLockSurface(hsurfVirtual);
    if (!pvdev->pso)
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pco->rclBounds = pvdev->rclBounds;
    ((ECLIPOBJ*) pco)->vSet(&pco->rclBounds);

    pvdev->pco = pco;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);

        if (poThis.flGraphicsCaps() & GCAPS_LAYERED)
        {
            poThis.pSurface()->hMirrorParent = hsurfVirtual;
        }
    }

    // We're done!

    return(hsurfVirtual);

ReturnFailure:
    KdPrint(("Failed MulEnableSurface\n"));

    MulDisableSurface((DHPDEV) pvdev);
    return(0);
}

/******************************Public*Routine******************************\
* VOID MulDisableSurface
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    HSURF       hsurf;
    HOBJ        hobj;
    SURFACE*    pSurface;

    pvdev = (VDEV*) dhpdev;

    PDEVOBJ po(pvdev->hdev);

    ASSERTGDI(po.bValid(), "Invalid PDEV");

    EngDeleteClip(pvdev->pco);
    EngUnlockSurface(pvdev->pso);
    EngDeleteSurface(pvdev->hsurf);
}

/******************************Public*Routine******************************\
* BOOL MulSetPalette
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ *ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    BOOL        bRet = TRUE;

    pvdev   = (VDEV*) dhpdev;
    pds     = pvdev->pds;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ pdo(pds->hdev);

        if (pdo.bIsPalManaged() && PPFNVALID(pdo,SetPalette))
        {
            bRet &= (*PPFNDRV(pdo,SetPalette)) (pdo.dhpdev(),
                                                ppalo,
                                                fl,
                                                iStart,
                                                cColors);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL MulIcmSetDeviceGammaRamp
*
* History:
*   19-Feb-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

ULONG MulIcmSetDeviceGammaRamp(
DHPDEV  dhpdev,
ULONG   iFormat,
LPVOID  lpRamp)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    BOOL        bRet = FALSE;

    pvdev   = (VDEV*) dhpdev;
    pds     = pvdev->pds;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ pdo(pds->hdev);

        if ((PPFNVALID(pdo, IcmSetDeviceGammaRamp)) && 
            (pdo.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
        {
            bRet &= (*PPFNDRV(pdo,IcmSetDeviceGammaRamp))
                                        (pdo.dhpdev(),
                                         iFormat,
                                         lpRamp);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL MulRealizeBrush
*
* This function's only job is to handle the call caused by the pvGetRbrush
* in the MULTIBRUSH object.  It should just allocate enough memory for the
* object, and return.
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ *pbo,
SURFOBJ  *psoDst,
SURFOBJ  *psoPat,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo,
ULONG    iHatch)
{
    PVDEV       pvdev;
    LONG        cj;

    pvdev = (VDEV*) psoDst->dhpdev;

    ASSERTGDI(pbo->pvRbrush == NULL, "MulRealizeBrush has a memory leak.\n"
                                     "Called with pbo->pvRbrush != NULL");

    cj = sizeof(MULTIBRUSHINFO) +
         (pvdev->cSurfaces - 1) * sizeof(MULTIREALIZEDBRUSH);

    return(BRUSHOBJ_pvAllocRbrush(pbo, cj) != NULL);
}

/******************************Public*Routine******************************\
* ULONG MulEscape
*
* History:
*   12-Jul-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

ULONG MulEscape(
SURFOBJ *pso,
ULONG    iEsc,
ULONG    cjIn,
PVOID    pvIn,
ULONG    cjOut,
PVOID    pvOut)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    ULONG       ulRet = 0;

    ASSERTGDI((pso->dhsurf != NULL), "Expected device dest.");

    // OpenGL ExtEscapes from the ICD (and MCD) can still
    // end up here at DeletContext time when the original
    // DC has been lost and they try to communicate to the
    // driver with a DC they got by GetDC(NULL).
    //
    // This routine really shouldn't do anything but return 0.

    if ((iEsc == OPENGL_CMD) || (iEsc == OPENGL_GETINFO) ||
        (iEsc == MCDFUNCS)   || (iEsc == WNDOBJ_SETUP))
    {
        return (0);
    } 

    pvdev = (VDEV*) pso->dhpdev;
    pds     = pvdev->pds;
    csurf   = pvdev->cSurfaces;

    ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

    while (csurf--)
    {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo,Escape))
        {

            ULONG ulTmp;
            ulTmp = pdo.Escape(pds->pso, iEsc, cjIn, pvIn, cjOut, pvOut);

            // set ulRet to last non-zero value returned

            if (ulTmp != 0)
            {
                ulRet = ulTmp;
            }
        }
        pds = pds->pdsNext;
    }
    return(ulRet);
}

/******************************Public*Routine******************************\
* VOID MulDestroyFont
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDestroyFont(
FONTOBJ*    pfo)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = TRUE;

    if (pfo->pvConsumer != NULL)
    {
        MULTIFONT   MFONT(pfo, -1, NULL);

        pvdev   = MFONT.pvdev();
        pds     = pvdev->pds;
        csurf   = pvdev->cSurfaces;

        ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

        while (csurf--)
        {
            PDEVOBJ pdo(pds->hdev);

            if (PPFNVALID(pdo,DestroyFont))
            {
                MFONT.LoadElement(pds->iDispSurf);
                pdo.DestroyFont(pfo);
                MFONT.StoreElement(pds->iDispSurf);
            }
            pds = pds->pdsNext;
        }
        MFONT.DestroyTable();
    }
}

/******************************Public*Routine******************************\
* VOID MulDestroyBrushInternal
*
* Internal brush destruction routine.  This is called to delete our
* private information associated with multi brushes.
*
* History:
*   9-July-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDestroyBrushInternal(
PVOID pvRbrush)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = TRUE;

    if (pvRbrush != NULL)
    {
        BRUSHOBJ boTmp;

        boTmp.iSolidColor = 0xffffffff;
        boTmp.pvRbrush = pvRbrush;
        boTmp.flColorType = 0;

        MULTIBRUSH   MBRUSH(&boTmp, -1, NULL, NULL, TRUE);
        MBRUSH.DestroyTable();
    }
}

/******************************Public*Routine******************************\
* ULONG ulSimulateSaveScreenBits
*
* This function simulates SaveScreenBits for those drivers that do not
* hook it, by using a temporary bitmap and copying in and out of that.
*
\**************************************************************************/

ULONG_PTR ulSimulateSaveScreenBits(
SURFOBJ*    psoScreen,
ULONG       iMode,
ULONG_PTR   ulIdent,
RECTL*      prcl)          // Already in device's coordinates
{
    SIZEL       sizl;
    HSURF       hsurf;
    SURFOBJ*    psoSave;
    SURFACE*    psurfSave;
    SURFACE*    psurfScreen;
    ULONG_PTR    ulRet;
    RECTL       rclDst;
    POINTL      ptlSrc;

    PDEVOBJ pdo(psoScreen->hdev);

    if (iMode == SS_SAVE)
    {
        sizl.cx = prcl->right - prcl->left;
        sizl.cy = prcl->bottom - prcl->top;

        ASSERTGDI((sizl.cx > 0) && (sizl.cy > 0), "Empty rectangle on save");

        // First, try to create the temporary save bitmap as a Device-Format-
        // Bitmap, and if that fails try it as a normal DIB.  (Many display
        // drivers support off-screen bitmaps via CreateDeviceBitmap, so this
        // is often the fastest way to do it.)

        hsurf = 0;

        if (PPFNVALID(pdo, CreateDeviceBitmap))    
        {
            hsurf = (HSURF) (*PPFNDRV(pdo, CreateDeviceBitmap))
                                           (psoScreen->dhpdev,
                                            sizl,
                                            psoScreen->iBitmapFormat);
        }
        if (hsurf == 0)
        {
            hsurf = (HSURF) EngCreateBitmap(sizl,
                                            0,
                                            psoScreen->iBitmapFormat,
                                            BMF_TOPDOWN,
                                            NULL);
        }

        psoSave = EngLockSurface(hsurf);
        if (psoSave)
        {
            rclDst.left   = 0;
            rclDst.top    = 0;
            rclDst.right  = sizl.cx;
            rclDst.bottom = sizl.cy;

            psurfSave = SURFOBJ_TO_SURFACE(psoSave);

            // Copy the screen to the temporary bitmap.  Note that
            // we do not use OffCopyBits as the coordinates have
            // already been offset to take into account the monitor's
            // origin:

            (*PPFNGET(pdo, CopyBits, psurfSave->flags()))(psoSave,
                                                          psoScreen,
                                                          NULL,
                                                          NULL,
                                                          &rclDst,
                                                          (POINTL*) prcl);
        }

        ulRet = (ULONG_PTR) psoSave;
    }
    else
    {
        psoSave = (SURFOBJ*) ulIdent;

        if (iMode == SS_RESTORE)
        {
            ptlSrc.x = 0;
            ptlSrc.y = 0;
            psurfScreen = SURFOBJ_TO_SURFACE(psoScreen);

            // Copy the temporary bitmap back to the screen:

            (*PPFNGET(pdo, CopyBits, psurfScreen->flags()))(psoScreen,
                                                            psoSave,
                                                            NULL,
                                                            NULL,
                                                            prcl,
                                                            &ptlSrc);
        }

        // Free the bitmap, remembering to retrieve any data from the
        // SURFOBJ before we unlock it.  Note that EngDeleteSurface
        // handles calling DrvDeleteDeviceBitmap if it's a device
        // format bitmap:

        hsurf = psoSave->hsurf;
        EngUnlockSurface(psoSave);
        EngDeleteSurface(hsurf);

        ulRet = TRUE;
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG MulSaveScreenBits
*
* It's important for the DDML to hook SaveScreenBits even if some of the
* underlying drivers do not, for scenarios such as NetMeeting.  This is
* because if SaveScreenBits is not hooked, USER goes and simulates by
* creating a temporary bitmap and saving and restoring the bits into that
* bitmap via CopyBits -- meaning that for NetMeeting the temporary bitmap
* is sent in full both ways over the wire.  NetMeeting much prefers to be
* able to hook SaveScreenBits so that it can send a small token over the wire
* representing the save or restore.  The problem is that most drivers do
* not support SaveScreenBits, and so for those drivers we simply emulate
* ourselves (thus allowing us to hook SaveScreenBits even if all the
* drivers do not hook SaveScreenBits).
*
* Note also that NetMeeting likes to be able to fail its SS_RESTORE call so
* that it can force a repaint if it wants to.
*
\**************************************************************************/

#define SS_GDI_ENGINE 1
#define SS_GDI_DRIVER 2

typedef struct _MULTISAVEBITS {
   FLONG     flType;
   ULONG_PTR ulBits;
} MULTISAVEBITS, *PMULTISAVEBITS; 

ULONG_PTR MulSaveScreenBits(
SURFOBJ*    pso,
ULONG       iMode,
ULONG_PTR   ulIdent,
RECTL*      prcl)
{
    PVDEV                   pvdev;
    PDISPSURF               pds;
    LONG                    csurf;
    ULONG_PTR               ulRet;
    ULONG_PTR               ulThisBits;
    FLONG                   flThisType;
    MULTISAVEBITS*          pulIdent;
    RECTL                   rclThis;
    PFN_DrvSaveScreenBits   pfnSaveScreenBits;

    pvdev   = (VDEV*) pso->dhpdev;
    pds     = pvdev->pds;
    csurf   = pvdev->cSurfaces;

    if (iMode == SS_SAVE)
    {
        pulIdent = (MULTISAVEBITS*)
            EngAllocMem(FL_ZERO_MEMORY, csurf * sizeof(MULTISAVEBITS), 'vdVG');

        ulRet = (ULONG_PTR)pulIdent;

        if (pulIdent)
        {
            do {
                ulThisBits = 0;

                if (bIntersect(prcl, &pds->rcl, &rclThis))
                {
                    rclThis.left   -= pds->rcl.left;
                    rclThis.right  -= pds->rcl.left;
                    rclThis.top    -= pds->rcl.top;
                    rclThis.bottom -= pds->rcl.top;

                    PDEVOBJ pdoThis(pds->hdev);

                    pfnSaveScreenBits = PPFNVALID(pdoThis, SaveScreenBits)
                                      ? PPFNDRV(pdoThis, SaveScreenBits)
                                      : ulSimulateSaveScreenBits;

                    ulThisBits = pfnSaveScreenBits(pds->pso,
                                                   SS_SAVE,
                                                   0,
                                                   &rclThis);

                    if (ulThisBits == 0)
                    {
                        // Ack, this driver failed to save its screenbits.
                        //
                        // Try the software simulation (if we haven't tried)

                        if (pfnSaveScreenBits != ulSimulateSaveScreenBits)
                        {
                            pfnSaveScreenBits = ulSimulateSaveScreenBits;

                            ulThisBits = pfnSaveScreenBits(pds->pso,
                                                           SS_SAVE,
                                                           0,
                                                           &rclThis);
                        }

                        if (ulThisBits == 0)
                        {
                            // We have to free any screenbits that any earlier
                            // driver saved:

                            MulSaveScreenBits(pso,
                                              SS_FREE,
                                              ulRet,
                                              &grclEmpty);
                            return(0);
                        }
                    }
                }

                if ((pulIdent[pds->iDispSurf].ulBits = ulThisBits) != 0)
                {
                    pulIdent[pds->iDispSurf].flType = 
                        (pfnSaveScreenBits == ulSimulateSaveScreenBits)
                      ? SS_GDI_ENGINE : SS_GDI_DRIVER;
                }

                pds = pds->pdsNext;
            } while (--csurf);
        }
    }
    else
    {
        pulIdent = (MULTISAVEBITS*)ulIdent;

        ulRet = TRUE;           // Assume success

        do {
            ulThisBits = pulIdent[pds->iDispSurf].ulBits;
            flThisType = pulIdent[pds->iDispSurf].flType;

            if (ulThisBits)
            {
                PDEVOBJ pdoThis(pds->hdev);

                if (bIntersect(prcl, &pds->rcl, &rclThis))
                {
                    rclThis.left   -= pds->rcl.left;
                    rclThis.right  -= pds->rcl.left;
                    rclThis.top    -= pds->rcl.top;
                    rclThis.bottom -= pds->rcl.top;
                }
                else
                {
                    rclThis = grclEmpty;
                }

                if ((flThisType == SS_GDI_DRIVER) &&
                    (PPFNVALID(pdoThis, SaveScreenBits)))
                {
                    pfnSaveScreenBits = PPFNDRV(pdoThis, SaveScreenBits);
                }
                else
                {
                    pfnSaveScreenBits = ulSimulateSaveScreenBits;
                }

                ulThisBits = pfnSaveScreenBits(pds->pso,
                                               iMode,
                                               ulThisBits,
                                               &rclThis);

                if ((ulThisBits == 0) && (iMode == SS_RESTORE))
                {
                    // Ack, this driver failed to restore its screenbits.
                    // We'll have to tell USER that we failed, too.  But
                    // first, we have to continue to free the screenbits of
                    // any drivers following in the DDML list:

                    ulRet = FALSE;
                    iMode = SS_FREE;
                    prcl = &grclEmpty;
                }
            }

            pds = pds->pdsNext;
        } while (--csurf);

        EngFreeMem((VOID*) ulIdent);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* VOID MulDeleteDeviceBitmap
*
* If the surface has been hooked by the DDML, do any clean-up required
* so that the surface can be deleted.
*
\**************************************************************************/

VOID MulDeleteDeviceBitmap(
DHSURF dhsurf)
{
    MDSURF*     pmdsurf;
    VDEV*       pvdev;
    DISPSURF*   pds;
    SURFOBJ*    psoMirror;
    HSURF       hsurfMirror;

    pmdsurf = (MDSURF*) dhsurf;
    pvdev   = pmdsurf->pvdev;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        psoMirror = pmdsurf->apso[pds->iDispSurf];
        if (psoMirror != NULL)
        {
            // Note that EngDeleteSurface takes care of calling
            // DrvDeleteDeviceBitmap:

            hsurfMirror = psoMirror->hsurf;
            EngUnlockSurface(psoMirror);
            EngDeleteSurface(hsurfMirror);
        }
    }

    // Note that GDI handles the freeing of the hsurfDevice bitmap.

    EngFreeMem(pmdsurf);
}

/******************************Public*Routine******************************\
* HBITMAP MulCreateDeviceBitmap
*
* Screen readers and other clients of the DDML have to be able to watch
* all drawing calls to compatible bitmaps.  
*
\**************************************************************************/

HBITMAP MulCreateDeviceBitmap(           
DHPDEV dhpdev,
SIZEL  sizl,
ULONG  iFormat)
{
    GDIFunctionID(MulCreateDeviceBitmap);

    HSURF       hsurfDevice;
    HSURF       hsurfMirror;
    MDSURF*     pmdsurf;
    VDEV*       pvdev;
    DISPSURF*   pds;
    SURFOBJ*    psoMirror;
    SURFACE*    psurfMirror;
    FLONG       flHooks;

    pvdev = (VDEV*) dhpdev;

    flHooks = 0;

    pmdsurf = NULL;
    hsurfDevice = NULL;

    // First, pass the call to every mirrored driver and see if they 
    // want to create a Mirrored version:
    
    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);
   
        if ((poThis.flGraphicsCaps() & GCAPS_LAYERED) && 
            PPFNDRV(poThis, CreateDeviceBitmap))
        {
            // We compare to TRUE to allow for the possibility that
            // in the future we'll change the return value to be
            // something other than BOOL.
    
            hsurfMirror = (HSURF) PPFNDRV(poThis, CreateDeviceBitmap)
                                        (poThis.dhpdev(),
                                         sizl,
                                         iFormat);
            if (hsurfMirror)
                psoMirror = EngLockSurface(hsurfMirror);
            else
                psoMirror = NULL;

            if (psoMirror)
            {
                if (pmdsurf == NULL)
                {
                    
                    hsurfDevice = (HSURF) EngCreateBitmap(sizl, 0, iFormat, BMF_TOPDOWN, NULL);
                   
                    pmdsurf = (MDSURF*) EngAllocMem(
                                 FL_ZERO_MEMORY,
                                 sizeof(MDSURF) + pvdev->cSurfaces * sizeof(SURFOBJ*),
                                 'fsVG');
    
                    if ((pmdsurf == NULL) || (hsurfDevice == NULL))
                    {

                        if (pmdsurf != NULL)
                        {
                             EngFreeMem(pmdsurf);
                        }

                        // Failure, so we're outta here...

                        EngUnlockSurface(psoMirror);
                        EngDeleteSurface(hsurfDevice);

                        return((HBITMAP) NULL);

                    }

                    pmdsurf->apso = (SURFOBJ**)
                      ((BYTE*)pmdsurf + sizeof(MDSURF));

                }

                pmdsurf->pvdev = pvdev;
                pmdsurf->apso[pds->iDispSurf] = psoMirror;

                psurfMirror = SURFOBJ_TO_SURFACE_NOT_NULL(psoMirror);

                psurfMirror->vSetMirror();
                psurfMirror->hMirrorParent = hsurfDevice;

                if (!poThis.bIsPalManaged())
                {
                    // Dev bitmap will have device palette. 
                
                    HPALETTE hpalDevice = (HPALETTE) poThis.ppalSurf()->hGet();

                    EPALOBJ palDeviceSurf(hpalDevice);

                    ASSERTGDI(palDeviceSurf.bValid(), "ERROR invalid palette\n");

                    psurfMirror->ppal(palDeviceSurf.ppalGet());

                    // Reference count it by making it not unlocked.

                    palDeviceSurf.ppalSet((PPALETTE)NULL);
                }
            }
        }
    }

    // If any layering driver hooked the call, make our surface opaque
    // so that we can catch all drawing calls.

    if (pmdsurf != NULL)
    {

        SURFREF sr(hsurfDevice);
          
        if (sr.bValid()) 
        {
        
            sr.ps->vSetEngCreateDeviceBitmap();
            sr.ps->iType(STYPE_DEVBITMAP);
   
            sr.ps->so.dhsurf = (DHSURF)pmdsurf;

            flHooks = pvdev->flHooks;

            // DrvCreateDeviceBitmap calls must always 'EngAssociateSurface'
            // the returned bitmap:
             
            EngAssociateSurface(hsurfDevice, pvdev->hdev, flHooks);
        }
    }

    return((HBITMAP) hsurfDevice);
}

#ifdef OPENGL_MM

// ICD calls directly dispatch to real driver in API level, so it bypass DDML.

#else

/******************************Public*Routine******************************\
* BOOL MulSetPixelFormat
*
*
\**************************************************************************/

BOOL MulSetPixelFormat(
SURFOBJ*    pso,
LONG        iPixelFormat,
HWND        hwnd)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = FALSE;

    pvdev = (VDEV*) pso->dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, SetPixelFormat))
        {
            bRet = (*PPFNDRV(pdo, SetPixelFormat))(pds->pso,
                                                   iPixelFormat,
                                                   hwnd);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG MulDescribePixelFormat
*
*
\**************************************************************************/

LONG MulDescribePixelFormat(
DHPDEV                  dhpdev,
LONG                    iPixelFormat,
ULONG                   cjpfd,
PIXELFORMATDESCRIPTOR*  ppfd)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    DHPDEV      dhpdevDriver;

    LONG        lRet = 0;

    pvdev = (VDEV*) dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, DescribePixelFormat))
        {
            dhpdevDriver = pds->pso->dhpdev;

            lRet = (*PPFNDRV(pdo, DescribePixelFormat))(dhpdevDriver,
                                                        iPixelFormat,
                                                        cjpfd,
                                                        ppfd);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(lRet);
}

/******************************Public*Routine******************************\
* BOOL MulSwapBuffers
*
*
\**************************************************************************/

BOOL MulSwapBuffers(
SURFOBJ*    pso,
WNDOBJ*     pwo)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    BOOL        bRet = FALSE;

    pvdev = (VDEV*) pso->dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, SwapBuffers))
        {
            bRet = (*PPFNDRV(pdo, SwapBuffers))(pds->pso,
                                                pwo);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(bRet);
}

#endif // #ifdef OPENGL_MM

/******************************Public*Routine******************************\
* BOOL MulTextOut
*
* WARNING - WHEN OPTIMIZING
*
* When optimizing for one driver, remember that you'll still
* have to set the psurf on brushes to the driver's surface.
* Otherwise, you'll get a callback for DrvRealizeBrush.
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ  *pso,
STROBJ   *pstro,
FONTOBJ  *pfo,
CLIPOBJ  *pco,
RECTL    *prclExtra,
RECTL    *prclOpaque,
BRUSHOBJ *pboFore,
BRUSHOBJ *pboOpaque,
POINTL   *pptlOrg,
MIX       mix)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    ULONG   cgposCopied;
    RECTL   rclOpaque;

    ASSERTGDI((pboFore->iSolidColor != (ULONG) -1) &&
              (pboOpaque->iSolidColor != (ULONG) -1),
              "Didn't expect patterned brush");

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngTextOut(mDst.pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore,
                          pboOpaque, pptlOrg, mix);
    }

    MULTIBRUSH  MBRUSH_Fore(pboFore, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH_Fore.Valid())
    {
        return (FALSE);
    }

    MULTIBRUSH  MBRUSH_Opaque(pboOpaque, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH_Opaque.Valid())
    {
        return (FALSE);
    }

    MULTIFONT   MFONT(pfo, pvdev->cSurfaces, pvdev);
    if (!MFONT.Valid())
    {
        return (FALSE);
    }

    RECTL*      prclBounds = (prclOpaque != NULL)
                           ? prclOpaque
                           : &pstro->rclBkGround;

    cgposCopied = ((ESTROBJ*)pstro)->cgposCopied;

    rclOpaque = *prclBounds;

    if (msurf.bFindSurface(pso, pco, prclBounds))
    {
        do {
            STROBJ_vEnumStart(pstro);

            MFONT.LoadElement(msurf.pds->iDispSurf);
            MBRUSH_Fore.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));
            MBRUSH_Opaque.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            ((ESTROBJ*)pstro)->cgposCopied = cgposCopied;

            // Some drivers modify 'prclOpaque', so always pass them a copy:

            *prclBounds = rclOpaque;

            bRet &= OffTextOut(PPFNMGET(msurf, TextOut),
                               msurf.pOffset,
                               msurf.pso,
                               pstro,
                               pfo,
                               msurf.pco,
                               prclExtra,
                               prclOpaque,
                               pboFore,
                               pboOpaque,
                               pptlOrg,
                               mix);

            MBRUSH_Fore.StoreElement(msurf.pds->iDispSurf);
            MBRUSH_Opaque.StoreElement(msurf.pds->iDispSurf);
            MFONT.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStrokePath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *pla,
MIX        mix)
{
    PVDEV       pvdev = (VDEV*) pso->dhpdev;
    BOOL        bRet = TRUE;
    FLOAT_LONG  elStyleState = pla->elStyleState;
    MSURF       msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngStrokePath(mDst.pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix);
    }

    MULTIBRUSH  MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            PATHOBJ_vEnumStart(ppo);
            pla->elStyleState = elStyleState;
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffStrokePath(PPFNMGET(msurf, StrokePath),
                                  msurf.pOffset,
                                  msurf.pso,
                                  ppo,
                                  msurf.pco,
                                  pxo,
                                  pbo,
                                  pptlBrushOrg,
                                  pla,
                                  mix);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulFillPath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ  *pso,
PATHOBJ  *ppo,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngFillPath(mDst.pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            PATHOBJ_vEnumStart(ppo);
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffFillPath(PPFNMGET(msurf, FillPath),
                                msurf.pOffset,
                                msurf.pso,
                                ppo,
                                msurf.pco,
                                pbo,
                                pptlBrushOrg,
                                mix,
                                flOptions);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStrokeAndFillPath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *pla,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mixFill,
FLONG      flOptions)
{
    PVDEV       pvdev = (VDEV*) pso->dhpdev;
    BOOL        bRet = TRUE;
    FLOAT_LONG  elSavedStyleState = pla->elStyleState;
    MSURF       msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngStrokeAndFillPath(mDst.pso, ppo, pco, pxo, pboStroke, pla, pboFill,
                                    pptlBrushOrg, mixFill, flOptions);
    }

    MULTIBRUSH  MBRUSH_Stroke(pboStroke, pvdev->cSurfaces, pvdev, pvdev->pso, FALSE);
    if (!MBRUSH_Stroke.Valid())
    {
        return FALSE;
    }

    MULTIBRUSH  MBRUSH_Fill(pboFill, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mixFill));
    if (!MBRUSH_Fill.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            pla->elStyleState = elSavedStyleState;
            PATHOBJ_vEnumStart(ppo);
            MBRUSH_Stroke.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));
            MBRUSH_Fill.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffStrokeAndFillPath(PPFNMGET(msurf, StrokeAndFillPath),
                                         msurf.pOffset,
                                         msurf.pso,
                                         ppo,
                                         msurf.pco,
                                         pxo,
                                         pboStroke,
                                         pla,
                                         pboFill,
                                         pptlBrushOrg,
                                         mixFill,
                                         flOptions);

            MBRUSH_Stroke.StoreElement(msurf.pds->iDispSurf);
            MBRUSH_Fill.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulLineTo
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso,prclBounds);

        bRet = EngLineTo(mDst.pso, pco, pbo, x1, y1, x2, y2, mDst.prcl, mix);
    }

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, FALSE);
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    if (msurf.bFindSurface(pso, pco, prclBounds))
    {
        do {
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffLineTo(PPFNMGET(msurf, LineTo),
                              msurf.pOffset,
                              msurf.pso,
                              msurf.pco,
                              pbo,
                              x1,
                              y1,
                              x2,
                              y2,
                              prclBounds,
                              mix);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulGradientFill
*
* History:
*  23-Apr-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

BOOL MulGradientFill(
SURFOBJ     *pso,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
TRIVERTEX   *pVertex,
ULONG        nVertex,
PVOID        pMesh,
ULONG        nMesh,
RECTL       *prclExtents,
POINTL      *pptlDitherOrg,
ULONG        ulMode)
{
    PVDEV     pvdev = (VDEV*) pso->dhpdev;
    XLATEOBJ *pxloSave = pxlo;
    BOOL      bRet = TRUE;
    MSURF     msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso,prclExtents);

        bRet = EngGradientFill(mDst.pso, pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                               mDst.prcl, pptlDitherOrg, ulMode);
    }

    if (msurf.bFindSurface(pso, pco, prclExtents))
    {
         do {
             
             PSURFACE pSurfDest = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
             EXLATEOBJ xloDevice;
 
             // if the target surface is not compatible to primary surface,
             // create XLATEOBJ for source surface to target. otherwise
             // we can just use given XLATEOBJ.
 
             if (pSurfDest->iFormat() > BMF_8BPP) 
             {
                 // 16bpp or above do not require a translation object.

                 pxlo = NULL;
             } 
             else if (msurf.pds->iCompatibleColorFormat != 0)
             {
                 XLATE    *pxloM         = (XLATE *) pxlo;
                 PPALETTE  ppalDestDC    = ppalDefault;
                 PPALETTE  ppalSurfSrc   = gppalRGB;

                 PDEVOBJ pdo(msurf.pds->hdev);

                 if (pdo.bIsPalManaged())
                 {
                     // Use halftone palette for pal-managed device.

                     ppalDestDC = REALIZE_HALFTONE_PALETTE(pdo.hdev());
                 }
 
                 if (xloDevice.bInitXlateObj(
                             (pxloM ? pxloM->hcmXform : NULL),
                             (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                             ppalSurfSrc,       // Source palette
                             pSurfDest->ppal(), // Destination palette
                             ppalDestDC,        // Source DC palette
                             ppalDestDC,        // Destination DC palette
                             (pxloM ? pxloM->iForeDst : 0x0L),
                             (pxloM ? pxloM->iBackDst : 0x0L),
                             (pxloM ? pxloM->iBackSrc : 0x0L),
                             0))
                 {
                     pxlo = xloDevice.pxlo();
                 }
             }

             bRet &= OffGradientFill(PPFNMGET(msurf, GradientFill),
                                    msurf.pOffset,
                                    msurf.pso,
                                    msurf.pco,
                                    pxlo,
                                    pVertex,
                                    nVertex,
                                    pMesh,
                                    nMesh,
                                    prclExtents,
                                    pptlDitherOrg,
                                    ulMode);

             // Restore XLATEOBJ
 
             pxlo = pxloSave;
             
        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStretchBlt
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    GDIFunctionID(MulStretchBlt);

    XLATEOBJ *pxloSave = pxlo;
    
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PSURFACE pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);
    PDEVOBJ  pdoSrc(pSurfSrc->hdev());
    RECTL    rclSrcCopy = *prclSrc;     

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclSrcCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }

        prclSrc = &rclSrcCopy; 
        psoSrc  = srcCopy.pSurfobj();         
        pSurfSrc= SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    //
    // Inverting stretches are a pain because 'bFindSurface' doesn't
    // understand poorly ordered rectangles.  So we'll make yet 
    // another copy of the source in this case. 
    //

    SURFMEM  srcInv; 
    RECTL    rclDstCopy;
    
    PPALETTE ppalSrc  = pSurfSrc->ppal(); 
    
    if ((prclDst->left >= prclDst->right) || 
        (prclDst->top >= prclDst->bottom))
    {
        DEVBITMAPINFO   dbmi;

        RECTL rclSrcClip = *prclSrc; 

        if( rclSrcClip.left < 0 )
        {
            rclSrcClip.left = 0; 
        }
        if( rclSrcClip.right > pSurfSrc->sizl().cx ) 
        {
            rclSrcClip.right = pSurfSrc->sizl().cx;
        }
        if( rclSrcClip.top < 0 ) 
        {
            rclSrcClip.top = 0;
        }
        if( rclSrcClip.bottom > pSurfSrc->sizl().cy ) 
        {
            rclSrcClip.bottom = pSurfSrc->sizl().cy; 
        }

        if( (rclSrcClip.right <= rclSrcClip.left) || 
            (rclSrcClip.bottom <= rclSrcClip.top ) )
        {
            return TRUE; 
        }

        dbmi.cxBitmap = rclSrcClip.right - rclSrcClip.left;
        dbmi.cyBitmap = rclSrcClip.bottom - rclSrcClip.top;
        dbmi.hpal     = ppalSrc ? ((HPALETTE) ppalSrc->hGet()) : 0;
        dbmi.iFormat  = pSurfSrc->iFormat();
        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

        srcInv.bCreateDIB(&dbmi, (VOID *) NULL);

        if (!srcInv.bValid())
             return(FALSE);

        rclSrcCopy.left   -= rclSrcClip.left; 
        rclSrcCopy.right  -= rclSrcClip.left; 
        rclSrcCopy.top    -= rclSrcClip.top; 
        rclSrcCopy.bottom -= rclSrcClip.top; 

        RECTL rclInv;

        // Setup for x-inversion

        if( prclDst->left >= prclDst->right ) 
        {
            rclDstCopy.left = prclDst->right; 
            rclDstCopy.right= prclDst->left; 
            
            rclInv.left  = rclSrcCopy.right; 
            rclInv.right = rclSrcCopy.left; 
        }
        else
        {
            rclDstCopy.left = prclDst->left; 
            rclDstCopy.right= prclDst->right; 
        
            rclInv.left  = rclSrcCopy.left; 
            rclInv.right = rclSrcCopy.right; 
        }

        // Setup for y-inversion 

        if( prclDst->top >= prclDst->bottom ) 
        {
            rclDstCopy.top = prclDst->bottom; 
            rclDstCopy.bottom = prclDst->top; 
            
            rclInv.top  = rclSrcCopy.bottom; 
            rclInv.bottom = rclSrcCopy.top; 
        }
        else
        {
            rclDstCopy.top = prclDst->top; 
            rclDstCopy.bottom = prclDst->bottom; 
            
            rclInv.top  = rclSrcCopy.top; 
            rclInv.bottom = rclSrcCopy.bottom; 
        }

        // Do the actual inversion

        if(!EngStretchBlt(srcInv.pSurfobj(), psoSrc, NULL, (CLIPOBJ *)NULL, &xloIdent, NULL,
                             NULL, &rclInv, prclSrc, NULL, COLORONCOLOR))
            return FALSE;

        prclSrc  = &rclSrcCopy; 
        prclDst  = &rclDstCopy; 
    
        psoSrc   = srcInv.pSurfobj();         
        pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc); 
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    // WINBUG #298689 4-4-2001 jasonha  Handle multi-device stretches
    MULTISURF   mSrc(psoSrc, prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst); 
        bRet = EngStretchBlt(mDst.pso, mSrc.pso, psoMask, pco, pxlo, pca,
                             pptlHTOrg, mDst.prcl, mSrc.prcl, pptlMask, iMode);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError;

            EXLATEOBJ xloDevice;

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);

            bError = !mSrc.bLoadSource(msurf.pds);

            if (bError == FALSE)
            {
                pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);
                ppalSrc = pSurfSrc->ppal();

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;                                
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }

                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulStretchBlt(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvStretchBlt pfn = PPFNMGET(msurf, StretchBlt);                

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 

                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                // 
                // If the driver does not support halftoning we call Eng
                //

                if( iMode == HALFTONE ) 
                {
                    PDEVOBJ pdoTrg(pSurfDst->hdev()); 

                    if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                        pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                // Don't call the driver if the source rectangle exceeds the source
                // surface. Some drivers punt using a duplicate of the source
                // SURFOBJ, but without preserving its sizlBitmap member.
                // This causes a source clipping bug (77102).       

                if((mSrc.prcl->left < 0) || 
                   (mSrc.prcl->top  < 0) ||
                   (mSrc.prcl->right  > mSrc.pso->sizlBitmap.cx) ||
                   (mSrc.prcl->bottom > mSrc.pso->sizlBitmap.cy))
                {
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                bRet &= OffStretchBlt(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,
                                      psoMask,
                                      msurf.pco,
                                      pxlo,
                                      pca,
                                      pptlHTOrg,
                                      prclDst,
                                      mSrc.prcl,
                                      pptlMask,
                                      iMode);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL MulAlphaBlend
*
* History:
*   17-dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulAlphaBlend(
SURFOBJ       *psoDst,
SURFOBJ       *psoSrc,
CLIPOBJ       *pco,
XLATEOBJ      *pxlo,
RECTL         *prclDst,
RECTL         *prclSrc,
BLENDOBJ      *pBlendObj)
{
    GDIFunctionID(MulAlphaBlend);

    XLATEOBJ *pxloSave       = pxlo;
    XLATEOBJ *pxloSaveDCto32 = ((EBLENDOBJ*)pBlendObj)->pxloDstTo32;
    XLATEOBJ *pxloSave32toDC = ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst;
    XLATEOBJ *pxloSaveSrcTo32 = ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32;
 
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    RECTL    rclCopy = *prclSrc; 

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL ) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }


        prclSrc = &rclCopy; 
        psoSrc  = srcCopy.pSurfobj(); 
        pdoSrc.vInit(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    }
 
    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    MULTISURF mSrc(psoSrc,prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to
    // the master DIB also.
    //

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst);

        bRet = EngAlphaBlend(mDst.pso, mSrc.pso, pco, pxlo, mDst.prcl,
                             mSrc.prcl, pBlendObj);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;
            EXLATEOBJ xloDstDCto32; 
            EXLATEOBJ xlo32toDstDC;
            EXLATEOBJ xloSrcTo32;

            XEPALOBJ  palRGB(gppalRGB);

            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE pSurfDst = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE pSurfSrc;

            if (bError == FALSE)
            {
                pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.
                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }

                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulAlphaBlend(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        ULONG iForeDst; 
                   
                        if( pxloM ) 
                        {
                            iForeDst = pxloM->iForeDst; 
                        }
                        else
                        {
                            iForeDst = 0x0L; 
                        }

                        ULONG iBackDst; 

                        if( pxloM ) 
                        {
                            iBackDst = pxloM->iBackDst; 
                        }
                        else
                        {
                            iBackDst = 0x0L; 
                        }

                        ULONG iBackSrc; 

                        if( pxloM ) 
                        {
                            iBackSrc = pxloM->iBackSrc; 
                        }
                        else
                        {
                            iBackSrc = 0x0L; 
                        }

                        //
                        // Src to Dst 
                        // 

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    iForeDst,
                                    iBackDst,
                                    iBackSrc,
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }

                        //
                        // Dst to 32 
                        // 

                        if ((bError == FALSE) &&
                             xloDstDCto32.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        pSurfDst->ppal(),
                                        palRGB,
                                        ppalDestDC,
                                        ppalDestDC,
                                        iForeDst,
                                        iBackDst,
                                        iBackSrc))
                        {
                            ((EBLENDOBJ*)pBlendObj)->pxloDstTo32 = xloDstDCto32.pxlo(); 
                        }
                        else
                        {
                            bError = TRUE; 
                        }                    

                        //
                        // 32 to Dst
                        //

                        if ((bError == FALSE) &&
                             xlo32toDstDC.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        palRGB,
                                        pSurfDst->ppal(),
                                        ppalDestDC,
                                        ppalDestDC,
                                        iForeDst,
                                        iBackDst,
                                        iBackSrc))
                        {
                            ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst = xlo32toDstDC.pxlo();
                        }
                        else
                        {
                            bError = TRUE; 
                        }

                        //
                        // Src to 32
                        //

                        if ((bError == FALSE) &&
                            (mSrc.pso != psoSrc))
                        {
                            if (xloSrcTo32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            pSurfSrc->ppal(),
                                            palRGB,
                                            ppalDefault,
                                            ppalDestDC,
                                            iForeDst,
                                            iBackDst,
                                            iBackSrc))
                            {
                                ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32 = xloSrcTo32.pxlo();
                            }
                            else
                            {
                                bError = TRUE;
                            }
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvAlphaBlend pfn = PPFNMGET(msurf, AlphaBlend); 

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvAlphaBlend)EngAlphaBlend;
                }

                bRet &= OffAlphaBlend(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,
                                      msurf.pco,
                                      pxlo,
                                      prclDst,
                                      mSrc.prcl,
                                      pBlendObj);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            ((EBLENDOBJ*)pBlendObj)->pxloDstTo32 = pxloSaveDCto32;
            ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst = pxloSave32toDC;
            ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32 = pxloSaveSrcTo32;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulTransparentBlt
*
* History:
*   22-Dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulTransparentBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
ULONG               TransColor,
ULONG               ulReserved)
{
    GDIFunctionID(MulTransparentBlt);

    XLATEOBJ *pxloSave = pxlo;
    ULONG    TransColorSave = TransColor;
    
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    RECTL    rclCopy = *prclSrc; 

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL ) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }

        prclSrc = &rclCopy; 
        psoSrc  = srcCopy.pSurfobj(); 
        pdoSrc.vInit(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    MULTISURF mSrc(psoSrc,prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst);

        bRet = EngTransparentBlt(mDst.pso, mSrc.pso, pco, pxlo, 
                                 mDst.prcl, mSrc.prcl, TransColor, ulReserved);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;

            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE  pSurfSrc; 

            if (bError == FALSE)
            {
                pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }

                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulTransparent(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }

                if (mSrc.pso != psoSrc)
                {
                    PSURFACE    pSurfSrcOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                    TransColor =
                        ulGetNearestIndexFromColorref(
                            pSurfSrc->ppal(),
                            ppalDefault,
                            ulIndexToRGB(
                                pSurfSrcOrg->ppal(),
                                ppalDefault,
                                TransColor),
                            SE_DO_SEARCH_EXACT_FIRST);
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvTransparentBlt pfn = PPFNMGET(msurf, TransparentBlt); 

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvTransparentBlt)EngTransparentBlt;
                }

                bRet &= OffTransparentBlt(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,                                
                                      msurf.pco,
                                      pxlo,
                                      prclDst,
                                      mSrc.prcl,
                                      TransColor,
                                      ulReserved);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            TransColor = TransColorSave;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL MulDrawStream
*
* 1-27-2001 bhouse
* Wrote it.
*
\**************************************************************************/

BOOL MulDrawStream(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDstBounds,
POINTL*             pptlDstOffset,
ULONG               ulIn,
PVOID               pvIn,
DSSTATE*            pdss)
{
    GDIFunctionID(MulDrawStream);

    XLATEOBJ *      pxloSave = pxlo;
    PDRAWSTREAMINFO pdsi = (PDRAWSTREAMINFO) pdss;
    XLATEOBJ *      pxloSaveDstToBGRA = pdsi->pxloDstToBGRA;
    XLATEOBJ *      pxloSaveBGRAToDst = pdsi->pxloBGRAToDst;
    XLATEOBJ *      pxloSaveSrcToBGRA = pdsi->pxloSrcToBGRA;
    COLORREF        crSaveColorKey    = pdsi->dss.crColorKey;
    
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() &&  
        pdoSrc.bMetaDriver())
    {
        DbgPrint("MulDrawStream: this should never happen\n");
        return TRUE;
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDstBounds);

    MULTISURF mSrc(psoSrc);
    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst);
        bRet = EngDrawStream(mDst.pso, mSrc.pso, pco, pxlo, 
                    prclDstBounds, pptlDstOffset, ulIn, pvIn, pdss);
    }

    // TODO bhouse
    // Need to fix translates in pdsi

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;
            EXLATEOBJ xloDstToBGRA; 
            EXLATEOBJ xloBGRAToDst;
            EXLATEOBJ xloSrcToBGRA;

            XEPALOBJ  palRGB(gppalRGB);
            
            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE  pSurfSrc;

            if (bError == FALSE)
            {
                pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.


                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }

                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulDrawStream(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    
                        if ((bError == FALSE) &&
                             xloDstToBGRA.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        pSurfDst->ppal(),
                                        palRGB,
                                        ppalDestDC,
                                        ppalDestDC,
                                        (pxloM ? pxloM->iForeDst : 0x0L),
                                        (pxloM ? pxloM->iBackDst : 0x0L),
                                        (pxloM ? pxloM->iBackSrc : 0x0L)))
                        {
                            pdsi->pxloDstToBGRA = xloDstToBGRA.pxlo(); 
                        }
                        else
                        {
                            bError = TRUE; 
                        }                    

                        //
                        // 32 to Dst
                        //

                        if ((bError == FALSE) &&
                             xloBGRAToDst.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        palRGB,
                                        pSurfDst->ppal(),
                                        ppalDestDC,
                                        ppalDestDC,
                                        (pxloM ? pxloM->iForeDst : 0x0L),
                                        (pxloM ? pxloM->iBackDst : 0x0L),
                                        (pxloM ? pxloM->iBackSrc : 0x0L)))
                        {
                            pdsi->pxloBGRAToDst = xloBGRAToDst.pxlo();
                        }
                        else
                        {
                            bError = TRUE; 
                        }

                        if ((bError == FALSE) &&
                            (mSrc.pso != psoSrc))
                        {
                            //
                            // Src to 32
                            //

                            if (xloSrcToBGRA.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            pSurfSrc->ppal(),
                                            palRGB,
                                            ppalDefault,
                                            ppalDestDC,
                                            (pxloM ? pxloM->iForeDst : 0x0L),
                                            (pxloM ? pxloM->iBackDst : 0x0L),
                                            (pxloM ? pxloM->iBackSrc : 0x0L)))
                            {
                                pdsi->pxloSrcToBGRA = xloSrcToBGRA.pxlo();
                            }
                            else
                            {
                                bError = TRUE;
                            }

                            if (bError == FALSE)
                            {
                                PSURFACE    pSurfSrcOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                                pdsi->dss.crColorKey =
                                    ulGetNearestIndexFromColorref(
                                        pSurfSrc->ppal(),
                                        ppalDefault,
                                        ulIndexToRGB(
                                            pSurfSrcOrg->ppal(),
                                            ppalDefault,
                                            pdsi->dss.crColorKey),
                                        SE_DO_SEARCH_EXACT_FIRST);
                            }
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvDrawStream pfn = PPFNDRVENG(msurf.pds->po, DrawStream);

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvDrawStream) EngDrawStream;
                }

                bRet &= OffDrawStream(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      mSrc.pso,                                
                                      msurf.pco,
                                      pxlo,
                                      prclDstBounds,
                                      pptlDstOffset,
                                      ulIn,
                                      pvIn,
                                      pdss);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            pdsi->pxloBGRAToDst = pxloSaveBGRAToDst;
            pdsi->pxloDstToBGRA = pxloSaveDstToBGRA;
            pdsi->pxloSrcToBGRA = pxloSaveSrcToBGRA;
            pdsi->dss.crColorKey = crSaveColorKey;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL bSrcBeforeDst
*
* This function determines if the source rectangle, offset by dx and dy,
* will intersect the destination rectangle.  In other words, the source
* will be required to do the blt to the destination.  This means that the
* blt must be done to the destination before the blt to the source so that
* the source bits are not overwritten before they're used.
*
* History:
*  25-Apr-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

inline BOOL bSrcBeforeDst(
RECTL*  prclDst,
RECTL*  prclSrc,
LONG    dx,
LONG    dy)
{
    return((prclDst->left   < dx + prclSrc->right)  &&
           (prclDst->right  > dx + prclSrc->left)   &&
           (prclDst->top    < dy + prclSrc->bottom) &&
           (prclDst->bottom > dy + prclSrc->top));
}

/******************************Public*Routine******************************\
* VOID vSortBltOrder
*
* This function sorts the list of surfaces for the correct ordering on
* screen-to-screen blts that span boards.
*
* When this routine is done, 'pvdev->pdsBlt' will point to the first
* surface that should be processed, and each surface's 'pdsBltNext'
* field will point to the next one in order.
*
* History:
*  25-Apr-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID vSortBltOrder(
VDEV*   pvdev,
LONG    dx,
LONG    dy)
{
    DISPSURF* pdsBltHeadOld = pvdev->pdsBlt;
    DISPSURF* pdsBltHeadNew = pdsBltHeadOld;

    pdsBltHeadOld = pdsBltHeadOld->pdsBltNext;
    pdsBltHeadNew->pdsBltNext = NULL;

    while (pdsBltHeadOld)
    {
        DISPSURF * pdsBltInsert = pdsBltHeadOld;
        DISPSURF * pdsBltPrev = pdsBltHeadNew;
        DISPSURF * pdsBltCur = pdsBltHeadNew;

        pdsBltInsert = pdsBltHeadOld;
        pdsBltHeadOld = pdsBltHeadOld->pdsBltNext;

        while((pdsBltCur) &&
              (!bSrcBeforeDst(&pdsBltInsert->rcl,    // Dst
                              &pdsBltCur->rcl,       // Src
                              dx,
                              dy)))
        {
            pdsBltPrev = pdsBltCur;
            pdsBltCur = pdsBltCur->pdsBltNext;
        }

        if (pdsBltCur == pdsBltHeadNew)
        {
            pdsBltHeadNew = pdsBltInsert;
            pdsBltInsert->pdsBltNext = pdsBltCur;
        }
        else
        {
            pdsBltPrev->pdsBltNext = pdsBltInsert;
            pdsBltInsert->pdsBltNext = pdsBltCur;
        }
    }

    pvdev->pdsBlt = pdsBltHeadNew;
}

/******************************Public*Routine******************************\
* BOOL bBitBltScreenToScreen
*
* Handles screen-to-screen blts that may possibly span multiple displays.
*
\**************************************************************************/

BOOL bBitBltScreenToScreen(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    VDEV*       pvdev;
    LONG        dx;
    LONG        dy;
    DISPSURF*   pdsDst;
    DISPSURF*   pdsSrc;
    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    POINTL*     pOffDst;
    POINTL*     pOffSrc;
    RECTL       rclDst;
    POINTL      ptlSrc;
#if _MSC_VER < 1300
    DHSURF      dhsurfSave;
    DHPDEV      dhpdevSave;
#endif
    SIZEL       sizl;
    HSURF       hsurfTmp;
    SURFOBJ*    psoTmp;
    RECTL       rclDstTmp;
    BOOL        bRet;
    RECTL       rclSaveBounds;

    bRet = TRUE;

    pvdev = (VDEV*) pso->dhpdev;

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top - pptlSrc->y;

    vSortBltOrder(pvdev, dx, dy);

    XLATEOBJ *pxloSave = pxlo;

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, ROP4_NEEDS_PATTERN(rop4));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    if (pco != NULL)
    {
        rclSaveBounds = pco->rclBounds;
    }

    BOOL bWndBltNotify = (pso != NULL) && (pso->fjBitmap & BMF_WINDOW_BLT);

    for (pdsDst = pvdev->pdsBlt; pdsDst != NULL; pdsDst = pdsDst->pdsBltNext)
    {
        for (pdsSrc = pdsDst; pdsSrc != NULL; pdsSrc = pdsSrc->pdsBltNext)
        {
            rclDst.left   = dx + pdsSrc->rcl.left;
            rclDst.right  = dx + pdsSrc->rcl.right;
            rclDst.top    = dy + pdsSrc->rcl.top;
            rclDst.bottom = dy + pdsSrc->rcl.bottom;

            if (bIntersect(prclDst, &rclDst, &rclDst) &&
                bIntersect(&rclDst, &pdsDst->rcl, &rclDst))
            {
                ptlSrc.x = rclDst.left - dx;
                ptlSrc.y = rclDst.top  - dy;

                psoSrc = pdsSrc->pso;
                psoDst = pdsDst->pso;

                pOffSrc = &pdsSrc->Off;
                pOffDst = &pdsDst->Off;

#if _MSC_VER < 1300
                dhpdevSave = NULL;
#endif
                hsurfTmp   = NULL;

                if (psoSrc == psoDst)
                {
                    // This simply amounts to a screen-to-screen blt on
                    // the same surface.
                }
                else if ((!pdsSrc->bIsReadable) ||
                         (bIntersect(&pdsSrc->rcl, &pdsDst->rcl)))
                {
                    // If the source surface isn't readable, or if the two
                    // surfaces overlap (such as can happen when two display
                    // cards are echoing the same output), don't use the
                    // source as a destination for updating the display.  We
                    // need to do this otherwise when we do a screen-to-
                    // screen blt with a mirroring driver in the background,
                    // we'll think that the mirrored surface has to be blt
                    // to the screen -- but the read of the surface will
                    // fail and we'll end up blting blackness.

                    psoSrc = NULL;
                }
                else
                {
                    // This blt has to happen across boards, and the source
                    // bits aren't directly readable.  We'll have to create
                    // a temporary buffer and make a copy:

                    sizl.cx = rclDst.right - rclDst.left;
                    sizl.cy = rclDst.bottom - rclDst.top;

                    PDEVOBJ pdoSrc(pdsSrc->hdev);

                    hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                                       0,
                                                       pdoSrc.iDitherFormat(),
                                                       0,
                                                       NULL);

                    psoTmp = EngLockSurface(hsurfTmp);
                    if (psoTmp)
                    {
                        rclDstTmp.left   = 0;
                        rclDstTmp.top    = 0;
                        rclDstTmp.right  = sizl.cx;
                        rclDstTmp.bottom = sizl.cy;

                        bRet &= OffCopyBits(*PPFNGET(pdoSrc, 
                                                     CopyBits, 
                                                     pdoSrc.pSurface()->flags()),
                                            &gptlZero,
                                            psoTmp,
                                            &pdsSrc->Off,
                                            psoSrc,
                                            NULL,
                                            NULL,
                                            &rclDstTmp,
                                            &ptlSrc);
                    }

                    psoSrc  = psoTmp;
                    pOffSrc = &gptlZero;

                    ptlSrc.x = 0;
                    ptlSrc.y = 0;
                }

                // Do the blt:

                if (psoSrc)
                {
                    BOOL bError = FALSE;

                    PDEVOBJ pdoSrc(pdsSrc->hdev);
                    PDEVOBJ pdoDst(pdsDst->hdev);

                    EXLATEOBJ xloDevice;

                    if ((psoDst != psoSrc) &&
                        ((pdsDst->iCompatibleColorFormat != 0) ||
                         (pdsSrc->iCompatibleColorFormat != 0)))
                    {
                        XLATE    *pxloM    = (XLATE *) pxlo;
                        PSURFACE  pSurfSrc = pdsSrc->po.pSurface();
                        PSURFACE  pSurfDst = pdsDst->po.pSurface();
                        PPALETTE  ppalSrcDC = ppalDefault;
                        PPALETTE  ppalDstDC = ppalDefault;

                        // If destination surface is not compatible as primary
                        // and pal-managed device, then use halftone palette
                        // (source is higher then destination).

                        if ((pdsDst->iCompatibleColorFormat != 0) &&
                             pdoDst.bIsPalManaged())
                        {
                            ppalDstDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    pSurfSrc->ppal(), // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalSrcDC,        // Source DC palette
                                    ppalDstDC,        // Destination DC palette
                                    (pxloM ? pxloM->iForeDst  : 0x0L),
                                    (pxloM ? pxloM->iBackDst  : 0x0L),
                                    (pxloM ? pxloM->iBackSrc  : 0x0L),
                                    (pdsSrc->po.bIsPalManaged() ? XLATE_USE_SURFACE_PAL : 0)))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }

                    if (bError == FALSE)
                    {
                        // If we have a clipobj,
                        // We must ensure that pco->rclBounds is never bigger than
                        // prclDst on the CopyBits call.
                        if ((pco == NULL) ||
                            bIntersect(&rclSaveBounds, &rclDst, &pco->rclBounds))
                        {
                            if (rop4 == 0xcccc)
                            {
                                // If window blt notification is needed (i.e.,
                                // destination meta-surface has BMF_WINDOW_BLT bit
                                // set), setthe notification bit in the destination
                                // surfobj.

                                USHORT fjBitmapSave = psoDst->fjBitmap;

                                if (bWndBltNotify)
                                    psoDst->fjBitmap |= BMF_WINDOW_BLT;

                                bRet &= OffCopyBits(PPFNGET(pdoDst, 
                                                            CopyBits,
                                                            pdoDst.pSurface()->flags()),
                                                    pOffDst,
                                                    psoDst,
                                                    pOffSrc,
                                                    psoSrc,
                                                    pco,
                                                    pxlo,
                                                    &rclDst,
                                                    &ptlSrc);

                                // Restore the surfobj flagss.

                                psoDst->fjBitmap = fjBitmapSave;
                            }
                            else
                            {
                                MBRUSH.LoadElement(pdsDst, SURFOBJ_TO_SURFACE_NOT_NULL(psoDst));

                                bRet &= OffBitBlt(PPFNGET(pdoDst, 
                                                          BitBlt, 
                                                          pdoDst.pSurface()->flags()),
                                                  pOffDst,
                                                  psoDst,
                                                  pOffSrc,
                                                  psoSrc,
                                                  psoMask,
                                                  pco,
                                                  pxlo,
                                                  &rclDst,
                                                  &ptlSrc,
                                                  pptlMask,
                                                  pbo,
                                                  pptlBrush,
                                                  rop4);

                                MBRUSH.StoreElement(pdsDst->iDispSurf);
                            }
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }

                    // Restore XLATEOBJ.

                    pxlo = pxloSave;
                }

                // Now undo everything:

#if _MSC_VER < 1300
                if (dhpdevSave)
                {
                    psoSrc->dhsurf = dhsurfSave;
                    psoSrc->dhpdev = dhpdevSave;
                }
                else
#endif
                if (hsurfTmp)
                {
                    EngUnlockSurface(psoTmp);
                    EngDeleteSurface(hsurfTmp);
                }
            }
        }
    }

    if (pco != NULL)
    {
        pco->rclBounds = rclSaveBounds;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bBitBltFromScreen
*
* Handles screen-to-bitmap blts that may possibly span multiple displays.
*
\**************************************************************************/

BOOL bBitBltFromScreen(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    GDIFunctionID(bBitBltFromScreen);

    VDEV*       pvdev;
    DHPDEV      dhpdevDst;
    RECTL       rclDraw;
    MSURF       msurf;
    POINTL      ptlSrc;
    RECTL       rclDst;
    SURFOBJ*    psoDstTmp;
    LONG        dx;
    LONG        dy;

    XLATEOBJ   *pxloSave = pxlo;

    BOOL    bRet = TRUE;

    pvdev = (VDEV*) psoSrc->dhpdev;

    MULTISURF mDst(psoDst,prclDst);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Trim the destination rectangle to what's specified in the CLIPOBJ's
    // 'rclBounds':

    rclDraw = *prclDst;
    if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
    {
        if (!bIntersect(&pco->rclBounds, &rclDraw, &rclDraw))
            return(TRUE);
    }

    // Convert 'rclDraw' from destination coordinates to source coordinates:

    rclDraw.left   -= dx;
    rclDraw.right  -= dx;
    rclDraw.top    -= dy;
    rclDraw.bottom -= dy;

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, ROP4_NEEDS_PATTERN(rop4));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Source is screen.

    if (msurf.bFindSurface(psoSrc, NULL, &rclDraw))
    {
        do {

            PDEVOBJ poSrc(msurf.pso->hdev);

            // for DIB we blit once from each screen.  For device managed bitmaps, we blit
            // once to the master compatible bitmap and once to the device managed bitmap
            // for each screen.
            if (poSrc.flGraphicsCaps() & GCAPS_LAYERED)
            {
                if (mDst.pmdsurf == NULL || mDst.pmdsurf->apso[msurf.pds->iDispSurf] == NULL)
                    continue;
               psoDstTmp = mDst.pmdsurf->apso[msurf.pds->iDispSurf];
            }
            else
                psoDstTmp = mDst.pso;
            
            do {
               
               BOOL bError = FALSE;
            
               EXLATEOBJ xloDevice;

               // if the source surface is not compatible to primary surface,
               // create XLATEOBJ for source surface to target. otherwise
               // we can just use given XLATEOBJ.

               if (msurf.pds->iCompatibleColorFormat != 0)
               {
                  XLATE    *pxloM     = (XLATE *) pxlo;
                  PSURFACE  pSurfSrc  = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
                  PSURFACE  pSurfDst  = SURFOBJ_TO_SURFACE_NOT_NULL(psoDstTmp);
                  PPALETTE  ppalDst   = pSurfDst->ppal();

                  if (!ppalDst)
                  {
                     // Destination surface does not have associated palette.
                     // (Destination surface is compatible bitmap)

                     if (pxloM && pxloM->ppalDst)
                     {
                        // if XLATEOBJ has destination palette, use it.

                        ppalDst = pxloM->ppalDst;
                     }
                     else
                     {
                        if ((pxloM == NULL) || pxloM->bIsIdentity())
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                            // if translation is identity, we can use the palette for
                            // meta-source surface as destination. since it's trivial.

                            // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                            if (psoDstTmp == psoDst)
                            {
                                ppalDst = pSurfTmp->ppal();
                            }
                        }
                        else
                        {
                        #if HIDEYUKN_DBG
                            DbgPrint("GDI DDML: bBitBltFromScreen(): ppalDst is NULL\n");
                            DbgBreakPoint();
                        #endif
                            bError = TRUE;
                        }
                     }
                  }

                  if (bError == FALSE)
                  {

                      // WINBUG #365408 4-10-2001 jasonha Need to investigate old comment in bBitBltFromScreen
                      //
                      // We need to investigate the following old comment:
                      //    make sure that when the target surface is paletee managed we should
                      //    foreground realization to copy bits from non-primary surface.

                     if (xloDevice.bInitXlateObj(
                               (pxloM ? pxloM->hcmXform : NULL),
                               (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                               pSurfSrc->ppal(), // Source (device surface) palette
                               ppalDst,          // Destination palette
                               ppalDefault,      // Source DC palette
                               ppalDefault,      // Destination DC palette
                               (pxloM ? pxloM->iForeDst : 0x0L),
                               (pxloM ? pxloM->iBackDst : 0x0L),
                               (pxloM ? pxloM->iBackSrc : 0x0L),
                               XLATE_USE_SURFACE_PAL))
                     {
                        pxlo = xloDevice.pxlo();
                     }
                     else
                     {
                        bError = TRUE;
                     }
                  }
               }

               if (bError == FALSE)
               {
                  if (msurf.pco->iDComplexity == DC_TRIVIAL)
                  {
                     // Since bFindSurface/bNextSurface specified no clipping,
                     // the entire source surface is readable in one shot:

                     ptlSrc = *pptlSrc;
                     rclDst = *prclDst;
                  }
                  else
                  {
                     // Since the screen is the source, but the clip bounds
                     // apply to the destination, we have to convert our surface
                     // clipping information to destination coordinates:

                     ptlSrc.x      = msurf.pco->rclBounds.left;
                     ptlSrc.y      = msurf.pco->rclBounds.top;

                     rclDst.left   = msurf.pco->rclBounds.left   + dx;
                     rclDst.right  = msurf.pco->rclBounds.right  + dx;
                     rclDst.top    = msurf.pco->rclBounds.top    + dy;
                     rclDst.bottom = msurf.pco->rclBounds.bottom + dy;
                  }

                  if (rop4 == 0xcccc)
                  {
                     bRet &= OffCopyBits(
                                PPFNMGET(msurf, CopyBits),
                                &gptlZero,
                                psoDstTmp,
                                msurf.pOffset,
                                msurf.pso,
                                pco,       // Note that this is the original 'pco'
                                pxlo,
                                &rclDst,
                                &ptlSrc);
                  }
                  else
                  {
                     MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                     bRet &= OffBitBlt(
                                PPFNMGET(msurf, BitBlt),
                                &gptlZero,
                                psoDstTmp,
                                msurf.pOffset,
                                msurf.pso,
                                psoMask,
                                pco,       // Note that this is the original 'pco'
                                pxlo,
                                &rclDst,
                                &ptlSrc,
                                pptlMask,
                                pbo,
                                pptlBrush,
                                rop4);

                     MBRUSH.StoreElement(msurf.pds->iDispSurf);
                  }
               }
               else
               {
                  bRet = FALSE;
               }

               // Restore XLATEOBJ.

               pxlo = pxloSave;

#if 1
               ASSERTGDI(!((mDst.pmdsurf != NULL) &&
                           (psoDstTmp == mDst.pso) &&
                           (mDst.pmdsurf->apso[msurf.pds->iDispSurf] != NULL)),
                         "Non-Layered device is part of Meta DEVBITMAP.\n");
               psoDstTmp = NULL;
#else
               if ((mDst.pmdsurf != NULL) && (psoDstTmp == mDst.pso))
                   psoDstTmp = mDst.pmdsurf->apso[msurf.pds->iDispSurf];
               else
                   psoDstTmp = NULL;
#endif

            } while (psoDstTmp != NULL);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    GDIFunctionID(MulBitBlt);

    BOOL        bFromScreen;
    BOOL        bToScreen;
    VDEV*       pvdev;
    USHORT      iDstType;
    BOOL        bMultiDst;
    MDSURF*     pmdsurfSrc;
    DHPDEV      dhpdevSrc;
    RECTL       rclDst;
    MSURF       msurf;
    BOOL        bRet;
    BOOL        bError;

    XLATEOBJ   *pxloSave = pxlo;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = (psoDst->iType == STYPE_DEVICE);

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        return(bBitBltScreenToScreen(psoDst, psoMask, pco, pxlo,
                                     &rclDst, pptlSrc, pptlMask, pbo,
                                     pptlBrush, rop4));
    }
    else if (bFromScreen)
    {
        return(bBitBltFromScreen(psoDst, psoSrc, psoMask, pco, pxlo,
                                 &rclDst, pptlSrc, pptlMask, pbo,
                                 pptlBrush, rop4));
    }
    else // if (bToScreen)
    {
        bRet = TRUE;

        pvdev = (VDEV*) psoDst->dhpdev;

        // WINBUG #380128 05-04-2001 jasonha Initialize MSURF before MULTISURF
        // WINBUG #402896 05-24-2001 jasonha Initialize MULTIBURSH before MULTISURF
        //  MULTIBRUSH and MSURF must be intialized before the destination
        //  SURFACE might be modified.  The destination SURFACE may be changed
        //  when the source and destination are the same.

        iDstType = psoDst->iType;
        bMultiDst = (iDstType != STYPE_BITMAP) && msurf.bFindSurface(psoDst, pco, prclDst);

        // MBRUSH is only needed for the bMultiDst case, therefore pass
        // a NULL pbo, to reduce unnecessary setup.
        MULTIBRUSH  MBRUSH(((bMultiDst) ? pbo : NULL),
                           ((bMultiDst) ? pvdev->cSurfaces : 0),
                           ((bMultiDst) ? pvdev: NULL),
                           ((bMultiDst) ? pvdev->pso : NULL),
                           ((bMultiDst) ? ROP4_NEEDS_PATTERN(rop4) : FALSE));

        MULTISURF   mSrc(psoSrc, pptlSrc, rclDst.right - rclDst.left, rclDst.bottom - rclDst.top);

        if (iDstType != STYPE_DEVICE)
        {
            // For STYPE_BITMAP, we only blit to the DIB.
            // For STYPE_DEVBITMAP, we then blit to each device bitmap.

            MULTISURF mDst(psoDst,prclDst);
           
            bRet = EngBitBlt(mDst.pso, mSrc.pso, psoMask, pco, pxlo, mDst.prcl,
                             mSrc.pptl(), pptlMask, pbo, pptlBrush, rop4);
        }

        if (bMultiDst) 
        {
            if (!MBRUSH.Valid())
            {
                msurf.vRestore();
                return FALSE;
            }

            do {

                bError = !mSrc.bLoadSource(msurf.pds);

                EXLATEOBJ xloDevice;

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if ((bError == FALSE) &&
                    (mSrc.pso != NULL) &&
                    (msurf.pds->iCompatibleColorFormat != 0))
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PSURFACE  pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);
                    PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ   pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }

                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulBitBlt(): ppalDst is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }

                if (bError == FALSE)
                {
                    if (0) // (bHalftone)
                    {
                        MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                        bRet &= OffStretchBltROP(EngStretchBltROP,
                                          msurf.pOffset,
                                          msurf.pso,
                                          &gptlZero,
                                          mSrc.pso,
                                          psoMask,
                                          msurf.pco,
                                          pxlo,
                                          NULL,
                                          &gptlZero,
                                          &rclDst,
                                          mSrc.prcl,
                                          pptlMask,
                                          HALFTONE,
                                          pbo,
                                          rop4);

                        MBRUSH.StoreElement(msurf.pds->iDispSurf);
                    }
                    else if (rop4 == 0xcccc)
                    {
                        bRet &= OffCopyBits(PPFNMGET(msurf, CopyBits),
                                            msurf.pOffset,
                                            msurf.pso,
                                            &gptlZero,
                                            mSrc.pso,
                                            msurf.pco,
                                            pxlo,
                                            &rclDst,
                                            mSrc.pptl());
                    }
                    else
                    {
                        MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                        bRet &= OffBitBlt(PPFNMGET(msurf, BitBlt),
                                          msurf.pOffset,
                                          msurf.pso,
                                          &gptlZero,
                                          mSrc.pso,
                                          psoMask,
                                          msurf.pco,
                                          pxlo,
                                          &rclDst,
                                          mSrc.pptl(),
                                          pptlMask,
                                          pbo,
                                          pptlBrush,
                                          rop4);

                        MBRUSH.StoreElement(msurf.pds->iDispSurf);
                    }
                }
                else
                {
                    bRet = FALSE;
                }

                // Restore XLATEOBJ.

                pxlo = pxloSave;

            } while (msurf.bNextSurface());
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc)
{
    return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                     pptlSrc, NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* BOOL MulUpdateColors
*
* History:
*  18-Aug-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

BOOL MulUpdateColors(
SURFOBJ  *pso,
CLIPOBJ  *pco,
XLATEOBJ *pxlo)
{
    VDEV*       pvdev;
    DISPSURF*   pdsDst;
    SURFOBJ*    psoDst;
    POINTL*     pOffDst;
    RECTL       rclDst;
    POINTL      ptlSrc;
    RECTL       rclBounds;
    BOOL        bRet;

    bRet = TRUE;

    pvdev = (VDEV*) pso->dhpdev;

    ASSERTGDI(pco,"MulUpdateColors(): pco is null\n");

    //
    // Save bounds rectangle to updates.
    //

    rclBounds = pco->rclBounds;

    //
    // Walk through all devices.
    //

    for (pdsDst = pvdev->pds; pdsDst != NULL; pdsDst = pdsDst->pdsNext)
    {
        PDEVOBJ pdo(pdsDst->hdev);

        //
        // Check the device is palette managed or not.
        //
        // + If this is not palette managed device, we don't need to
        // do anything.
        // 
        // + Palette is shared with all palette devices, so we can
        // use exactly same XLATEOBJ for all palette devices.
        //

        if (pdo.bIsPalManaged())
        {
            //
            // Clip the rectangle to monitor.
            //

            if (bIntersect(&rclBounds, &pdsDst->rcl, &rclDst))
            {
                //
                // We must ensure that pco->rclBounds is never bigger than
                // prclDst on the CopyBits call.
                //

                pco->rclBounds = rclDst;

                //
                // Source points is same as destination upper-left.
                //

                ptlSrc.x = rclDst.left;
                ptlSrc.y = rclDst.top;

                psoDst  = pdsDst->pso;
                pOffDst = &pdsDst->Off;

                //
                // Update each pixel with correct color (by XLATEOBJ).
                //

                bRet &= OffCopyBits(PPFNGET(pdo, 
                                            CopyBits,
                                            pdo.pSurface()->flags()),
                                    pOffDst, psoDst, 
                                    pOffDst, psoDst,
                                    pco,     pxlo,
                                    &rclDst, &ptlSrc);
            }
        }
    }

    //
    // Restore original.
    //

    pco->rclBounds = rclBounds;

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulCopyDeviceToDIB
*
* Copies the specified rectangle of a multimon device surface to a DIB
* updating the rectangle to be relativeto the DIB's origin (0,0)  
* 
* The surface is not actually created if the rectangle is 
* out of bounds, so the caller has to check if the value 
* of pDibSurface.ps was modified at all. 
* 
* History:
*  16-Dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulCopyDeviceToDIB( 
SURFOBJ *pso, 
SURFMEM *pDibSurf,
RECTL   *prclSrc)
{
    DEVBITMAPINFO   dbmi;

    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(pso);
    PDEVOBJ  pdoSrc(pSurfSrc->hdev()); 

    RECTL rclSrcClip = *prclSrc; 

    if(rclSrcClip.left < pdoSrc.pptlOrigin()->x) 
    {
        rclSrcClip.left = pdoSrc.pptlOrigin()->x;
    }
    if(rclSrcClip.right > 
       (pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx)) 
    {
        rclSrcClip.right = 
            pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx;
    }
    if(rclSrcClip.top < pdoSrc.pptlOrigin()->y) 
    {
        rclSrcClip.top = pdoSrc.pptlOrigin()->y;
    }
    if(rclSrcClip.bottom > 
       (pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy)) 
    {
        rclSrcClip.bottom = 
            pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy;
    }

    // If the source rectangle was outside of the source 
    // surface, we can return. 

    if((rclSrcClip.top >= rclSrcClip.bottom) ||
       (rclSrcClip.left >= rclSrcClip.right )) 
    {
        return TRUE; 
    }

    RECTL rclDst = {0, 0, rclSrcClip.right - rclSrcClip.left, 
        rclSrcClip.bottom - rclSrcClip.top};
    
    POINTL srcOrigin = { rclSrcClip.left, rclSrcClip.top }; 

    PPALETTE ppalSrc = pSurfSrc->ppal(); 

    dbmi.cxBitmap = rclDst.right;
    dbmi.cyBitmap = rclDst.bottom;
    dbmi.hpal     = ppalSrc ? ((HPALETTE) ppalSrc->hGet()) : 0;
    dbmi.iFormat  = pSurfSrc->iFormat();
    dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;    

    pDibSurf->bCreateDIB(&dbmi, (VOID *) NULL);

    if (!pDibSurf->bValid())
         return(FALSE);

    if (!MulBitBlt(pDibSurf->pSurfobj(), pso, NULL, (CLIPOBJ *) NULL, 
             &xloIdent, &rclDst, &srcOrigin, NULL, NULL, NULL, 0xcccc)) 
        return FALSE; 

    prclSrc->left   -= rclSrcClip.left; 
    prclSrc->right  -= rclSrcClip.left; 
    prclSrc->top    -= rclSrcClip.top; 
    prclSrc->bottom -= rclSrcClip.top; 

    return TRUE; 
}

/******************************Public*Structure****************************\
* DRVFN gadrvfnMulti[]
*
* Build the driver function table gadrvfnMulti with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

DRVFN gadrvfnMulti[] = {

    // Effectively required by all drivers:

    {  INDEX_DrvEnablePDEV            , (PFN) MulEnablePDEV           },
    {  INDEX_DrvCompletePDEV          , (PFN) MulCompletePDEV         },
    {  INDEX_DrvDisablePDEV           , (PFN) MulDisablePDEV          },
    {  INDEX_DrvEnableSurface         , (PFN) MulEnableSurface        },
    {  INDEX_DrvDisableSurface        , (PFN) MulDisableSurface       },
    {  INDEX_DrvSetPalette            , (PFN) MulSetPalette           },
    {  INDEX_DrvRealizeBrush          , (PFN) MulRealizeBrush         },

    //
    // The DDML is special in that it does not manage any physical device.
    // GDI and USER should handle all calls involing modes, and those calls
    // should never get to the DDML.
    //
    // {  INDEX_DrvAssertMode         , (PFN) MulAssertMode           },
    // {  INDEX_DrvGetModes           , (PFN) MulGetModes             },

    // Required for device-managed surfaces:

    {  INDEX_DrvTextOut               , (PFN) MulTextOut              },
    {  INDEX_DrvStrokePath            , (PFN) MulStrokePath           },
    {  INDEX_DrvCopyBits              , (PFN) MulCopyBits             },

    // Optional, must be supported by "Eng" backup calls:

    {  INDEX_DrvBitBlt                , (PFN) MulBitBlt               },
    {  INDEX_DrvLineTo                , (PFN) MulLineTo               },
    {  INDEX_DrvFillPath              , (PFN) MulFillPath             },
    {  INDEX_DrvStrokeAndFillPath     , (PFN) MulStrokeAndFillPath    },
    {  INDEX_DrvStretchBlt            , (PFN) MulStretchBlt           },
    {  INDEX_DrvAlphaBlend            , (PFN) MulAlphaBlend           },
    {  INDEX_DrvTransparentBlt        , (PFN) MulTransparentBlt       },
    {  INDEX_DrvGradientFill          , (PFN) MulGradientFill         },
    {  INDEX_DrvDrawStream            , (PFN) MulDrawStream           },

    // For handling device bitmaps with layered drivers:

    {  INDEX_DrvCreateDeviceBitmap    , (PFN) MulCreateDeviceBitmap   },
    {  INDEX_DrvDeleteDeviceBitmap    , (PFN) MulDeleteDeviceBitmap   },

    // These calls only go to drivers that specifically need to get them.
    // DrvDestroyFont is only called for the specific drivers that hooked
    // it.  I checked it out, and the engine calls DrvDestroyFont regardless
    // of whether or not pvConsumer is NULL.  Therefore, I do the same for
    // each of the drivers.

    {  INDEX_DrvDestroyFont           , (PFN) MulDestroyFont          },
    {  INDEX_DrvEscape                , (PFN) MulEscape               },
    {  INDEX_DrvSaveScreenBits        , (PFN) MulSaveScreenBits       },

#ifdef OPENGL_MM
    // ICD calls directly dispatch to real driver in API level, so it bypass DDML.
#else
    {  INDEX_DrvSetPixelFormat        , (PFN) MulSetPixelFormat       },
    {  INDEX_DrvDescribePixelFormat   , (PFN) MulDescribePixelFormat  },
    {  INDEX_DrvSwapBuffers           , (PFN) MulSwapBuffers          },
#endif // OPENGL_MM

    // Image Color Management - DeviceGammaRamp control:

    {  INDEX_DrvIcmSetDeviceGammaRamp , (PFN) MulIcmSetDeviceGammaRamp},

};

ULONG gcdrvfnMulti = sizeof(gadrvfnMulti) / sizeof(DRVFN);

#ifdef OPENGL_MM

/******************************Public*Routine******************************\
* HDEV hdevFindDeviceHDEV
*
* OpenGL calls should only go to one driver and not the meta device.
* Try to find the appropriate hdev and return it.
*
* History:
*   28-Jan-1998 -by- Robert Tray [v-rotray]
* First pass.
*
\**************************************************************************/

HDEV hdevFindDeviceHdev(
    HDEV      hdevMeta,
    RECTL     rect,
    PEWNDOBJ  pwo)       // OPTIONAL
{
    //
    // *PixelFormat, SwapBuffers, & OGL Escape calls should
    // only go to one device.   Which one?
    // If there is a valid WNDOBJ then it will tell us
    // which surface is the right one.
    // If the extents of the window are completely contained
    // on one monitor then return the hdev of that device.
    // If the window straddles monitors then .... how about
    // we return 0 and hopefully in that case the app will
    // fall back to software rendering.  By the time the app
    // is serious about rendering he has a WNDOBJ.  So hopefully
    // we will only hit these ambiguous situations while the
    // app is doing a DescribePixelFormat.
    //

    PDEVOBJ pdo(hdevMeta);

    ASSERTGDI(pdo.bMetaDriver(),"hdevFindDeviceHDEV(): hdevMeta is not meta-PDEV\n");

    PVDEV     pvdev = (VDEV*) pdo.dhpdev();

    PDISPSURF pds;
    HDEV      hdevMatch = NULL;

    //
    // If WNDOBJ is given and the HDEV for the WNDOBJ
    // is one of child of this meta-PDEV. use it.
    //
    if (pwo && pwo->bValid())
    {
        hdevMatch = pwo->pto->pSurface->hdev();

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (hdevMatch == pds->hdev)
            {
                // found the match

                return (hdevMatch);
            }
        }
    }

    ULONG intersectMon = 0;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        if (bContains(&pds->rcl,&rect))
        {
            // The window is contained on this device

            return (pds->hdev);
        }

        if (bIntersect(&pds->rcl,&rect))
        {
            // The window is intersected with this device.

            PDEVOBJ pdoDevice(pds->hdev);

            // If this device has GCAPS2_ICD_MULTIMON flag, they
            // wants us to call them with any OpenGL window intersect
            // with thier device.

            if (pdoDevice.flGraphicsCaps2() & GCAPS2_ICD_MULTIMON)
            {
                return (pds->hdev);
            }

            intersectMon++;

            hdevMatch = pds->hdev;
        }
    }

    //
    // If the window is not contained on one monitor but
    // it only intersects one then that might mean that it's
    // hanging off the outside edge of a monitor.
    //

    if (intersectMon == 1)
    {
        return hdevMatch;
    }

    //
    // I suppose you could possibly return the hdev for the
    // primary monitor in some of these ambiguous cases but
    // until I think of them I'll just return NULL
    //

    return NULL;
}

#endif // OPENGL_MM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\opendc.cxx ===
/******************************Module*Header*******************************\
* Module Name: OPENDC.CXX
*
* Handles DC creation and driver loading.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern FLONG flRaster(ULONG, FLONG);

/******************************Exported*Routine****************************\
* GreCreateDisplayDC
*
* Opens a DC on the specified display PDEV.
* Allocates space for a DC, fills in the defaults.
* If successfull, increments the PDEV reference count.
*
\**************************************************************************/

HDC
GreCreateDisplayDC(
    HDEV hdev,
    ULONG iType,
    BOOL bAltType)
{
    GDIFunctionID(GreCreateDisplayDC);

    HDC hdc = (HDC) NULL;

    //
    // We hold the devlock to protect against dynamic mode changes
    // while we're copying mode specific information to the DC.
    //

    PDEVOBJ pdo(hdev);
    DEVLOCKOBJ dlo(pdo);

    DCMEMOBJ dcmo(iType, bAltType);

    if (dcmo.bValid())
    {
        //
        // Copy info from the PDEV into the DC.
        //

        dcmo.pdc->ppdev((PDEV *) pdo.hdev());
        dcmo.pdc->flGraphicsCaps(pdo.flGraphicsCaps());    // cache it for later use by graphics output functions
        dcmo.pdc->flGraphicsCaps2(pdo.flGraphicsCaps2());  // cache it for later use by graphics output functions
        dcmo.pdc->dhpdev(pdo.dhpdev());
        dcmo.hsemDcDevLock(pdo.hsemDevLock());

        if (iType == DCTYPE_MEMORY)
        {
            SIZEL sizlTemp;

            sizlTemp.cx = 1;
            sizlTemp.cy = 1;

            dcmo.pdc->sizl(sizlTemp);
        }
        else
        {
            dcmo.pdc->sizl(pdo.sizl());

            //
            // The info and direct DC's for the screen need to grab
            // the semaphore before doing output, the memory DC's will
            // grab the semaphore only if a DFB is selected.
            //

            if (iType == DCTYPE_DIRECT)
            {
                dcmo.bSynchronizeAccess(pdo.bDisplayPDEV());
                dcmo.pdc->vDisplay(pdo.bDisplayPDEV());

                //
                // If this DC is created against with disabled PDEV,
                // mark it as full screen mode. All hdc on disbaled
                // PDEV should be marked as 'in fullscreen'.
                // (see PDEVOBJ::bDisabled(BOOL bDisable))
                //

                dcmo.pdc->bInFullScreen(pdo.bDisabled());

                if (!pdo.bPrinter())
                    dcmo.pdc->pSurface(pdo.pSurface());
            }
        }

        //
        // Call the region code to set a default clip region.
        //

        if (dcmo.pdc->bSetDefaultRegion())
        {
            // If display PDEV, select in the System stock font.

            dcmo.vSetDefaultFont(pdo.bDisplayPDEV());

            // set user mode VisRect
            dcmo.pdc->vUpdate_VisRect(dcmo.pdc->prgnVis());

            if (GreSetupDCAttributes((HDC)(dcmo.pdc->hGet())))
            {
                // Mark the DC as permanent, hold the PDEV reference.

                dcmo.vKeepIt();

                // This will permanently increase the ref count to indicate
                // a new DC has been created.

                pdo.vReferencePdev();

                // turn on the DC_PRIMARY_DISPLAY flag for primary dc's

                if (hdev == UserGetHDEV())
                {
                    dcmo.pdc->ulDirtyAdd(DC_PRIMARY_DISPLAY);
                }

                // finish initializing the DC.

                hdc = dcmo.hdc();
            }
            else
            {
                // DCMEMOBJ will be freed, delete vis region

                dcmo.pdc->vReleaseVis();

                // delete LOGFONT in DC which set by dcmo.vSetDefaultFont() in above.

                DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dcmo.pdc->plfntNew());
            }
        }

        if (hdc == NULL)
        {
            // dec reference counts on brush, pen and others
            // (which incremented in DCOBJ::DCOBJ())

            DEC_SHARE_REF_CNT_LAZY0(dcmo.pdc->pbrushFill());
            DEC_SHARE_REF_CNT_LAZY0(dcmo.pdc->pbrushLine());
            DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(dcmo.pdc->pColorSpace());
        }
#if DBG
        else
        {
            // Enable visrgn validation from this point

            GreValidateVisrgn(hdc, TRUE);
        }
#endif
    }

    return hdc;
}

/******************************Public*Routine******************************\
* NtGdiCreateMetafileDC()
*
* History:
*  01-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
NtGdiCreateMetafileDC(
    HDC   hdc
    )
{
    HDC hdcNew = NULL;

    if (hdc)
    {
        //
        // Lock down the given DC.
        //

        DCOBJ   dco(hdc);

        if (dco.bValid())
        {
            //
            // Allocate the DC, fill it with defaults.
            //

            hdcNew = GreCreateDisplayDC((HDEV) dco.pdc->ppdev(), DCTYPE_INFO, TRUE);
        }
    }
    else
    {
        //
        // We must call USER to get the current PDEV\HDEV for this thread
        // This should end up right back in GreCreateDisplayDC
        //

        hdcNew = UserGetDesktopDC(DCTYPE_INFO, TRUE, FALSE);
    }

    return hdcNew;
}

/******************************Public*Routine******************************\
* NtGdiCreateCompatibleDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
NtGdiCreateCompatibleDC(
    HDC      hdc
    )
{
    HDC hdcRet = GreCreateCompatibleDC(hdc);

    //
    // Make sure user attributes are added to this dc
    //

    #if DBG

    if (hdcRet)
    {
        DCOBJ dco(hdcRet);
        if (dco.bValid())
        {
            ASSERTGDI((PENTRY_FROM_POBJ((POBJ)dco.pdc))->pUser != NULL,"NtGdiCreateCompatibleDC: pUser == NULL");
        }
    }

    #endif

    return(hdcRet);
}

/******************************Public*Routine******************************\
* HDC GreCreateCompatibleDC(hdc)
*
* History:
*  01-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*
\**************************************************************************/

HDC APIENTRY GreCreateCompatibleDC(HDC hdc)
{
    HDC hdcNew = NULL;

    if (hdc)
    {
        //
        // Lock down the given DC.
        //

        DCOBJ   dco(hdc);

        if (dco.bValid())
        {
            //
            // Allocate the DC, fill it with defaults.
            //

            hdcNew = GreCreateDisplayDC((HDEV) dco.pdc->ppdev(),
                                        DCTYPE_MEMORY,
                                        FALSE);
            //
            // If the compatible DC for a mirrored DC then mirror it.
            //

            if (hdcNew)
            {
                DWORD dwLayout = dco.pdc->dwLayout();

                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    GreSetLayout(hdcNew, -1, dwLayout);
                }
            }
       }
    }
    else
    {
        hdcNew = UserGetDesktopDC(DCTYPE_MEMORY, FALSE, FALSE);
    }

    return hdcNew;
}


/******************************Public*Routine******************************\
* BOOL GreSelectRedirectionBitmap
*
* This routine selects a redirection bitmap into a redirection DC.  A single
* redirection bitmap can be selected into multiple redirection DCs.
* Note:  The caller needs to hold the devlock.
* Note:  The redirection bitmap must be in system memory because GDI may
*     attempt to convert it to a memory bitmap in the future (mode change,
*     speed optimizations in some code paths, etc.) and we cannot do that
*     here because there's no easy way of getting the list of redirection
*     DCs on that surface.
*
* Arguments:
*
*   hdc -- The redirection DC as created by GreCreateRedirectionDC.
*
*   hbitmap -- The redirection bitmap to be selected into hdc.  This needs
*       to be a memory bitmap (but not DIB-section) which is compatible with
*       the display pdev.
*
* Return Value:
*
*   True upon success
*
* History:
*  21-Sep-1998 -by-  Ori Gershony [orig]
* Wrote it.
*
\**************************************************************************/

BOOL
APIENTRY
GreSelectRedirectionBitmap(
    HDC hdc,
    HBITMAP hBitmap
    )
{
    ULONG ulRet=TRUE;

    DCOBJA dco(hdc);
    if (dco.bValid())
    {
        SURFACE* pSurface = NULL;
        PDEVOBJ po(dco.hdev());

#if DBG
        po.vAssertDevLock();
#endif

        if (hBitmap == NULL)
        {
            dco.pdc->bRedirection(FALSE);

            pSurface = po.pSurface();
        }
        else
        {
            dco.pdc->bRedirection(TRUE);

            SURFREF surfref((HSURF) hBitmap);
            if (surfref.bValid())
            {
                pSurface = surfref.ps;

                ASSERTGDI((pSurface->iType() == STYPE_BITMAP) && (!(pSurface->fjBitmap() & BMF_NOTSYSMEM)),
                    "GreSelectRedirectionBitmap: bitmap must be in system memory");

                ASSERTGDI(!pSurface->hDIBSection(),
                    "GreSelectRedirectionBitmap: cannot select DIB-section into a redirection DC");

                PPALETTE ppalReference;
                ASSERTGDI(bIsCompatible(&ppalReference, NULL, pSurface, dco.hdev()),
                    "GreSelectRedirectionBitmap:  hBitmap not compatible with display hdev");

                //
                // Mark bitmap as redirection bitmap if not one already
                //
                if (!pSurface->bRedirection())
                {
                    pSurface->vSetRedirection();
                }
            }
        }

        if (pSurface != NULL)
        {
            //
            // Replace the surface in all the saved DCs too.
            //
            if (dco.lSaveDepth() > 1)
            {
                ulRet = GreSelectRedirectionBitmap (dco.hdcSave(), hBitmap);

                //
                // The recursive call above should never fail, and we are not
                // setup to deal with failure correctly (need to undo change
                // to DC redirection flag, etc.).  We can add code to do that,
                // but user (who calls us) cannot deal with failure either.  So
                // instead we assert that this call succeeded.
                //
                ASSERTGDI(ulRet == TRUE,
                          "GreSelectRedirectionBitmap:  Recursive call on hdcSave failed");
            }

            if (ulRet)
            {
                //
                // Replace the pSurf reference in the DCLEVEL
                //
                dco.pdc->pSurface(pSurface);

                //
                // Set the size to that of the new surface
                //
                dco.pdc->sizl(pSurface->sizl());

                //
                // Make sure that the surface pointers in any EBRUSHOBJ's get
                // updated, by ensuring that vInitBrush() gets called the next
                // time any brush is used in this DC.
                //
                dco.pdc->flbrushAdd(DIRTY_BRUSHES);

                //
                // Note:  we don't set the visrgn so that if user wants to reuse this dc over
                // the same redirection bitmap it won't have to recompute the visrgn (though it
                // will have to recompute it if it will be reused for a different redirection
                // bitmap).
                //
            }
        }
        else
        {
            ulRet = FALSE;
        }
    }
    else
    {
        ulRet = FALSE;
    }

    return ulRet;
}

/******************************Exported*Routine****************************\
* hdcOpenDCW
*
* Opens a DC for a device which is not a display.  GDI should call this
* function from within DevOpenDC, in the case that an hdc is not passed
* in.  This call locates the device and creates a new PDEV.  The physical
* surface associated with this PDEV will be distinct from all other
* physical surfaces.
*
* The window manager should not call this routine unless it is providing
* printing services for an application.
*
* pwszDriver
*
*   This points to a string which identifies the device driver.
*   The given string must be a fully qualified path name.
*
* pdriv
*
*   This is a pointer to the DEVMODEW block.
*
*   Since a single driver, like PSCRIPT.DRV, may support multiple
*   different devices, the szDeviceName field defines which device to
*   use.
*
*   This structure also contains device specific data in abGeneralData.
*   This data is set by the device driver in bPostDeviceModes.
*
*   If the pdriv pointer is NULL, the device driver assumes some default
*   configuration.
*
* iType
*
*   Identifies the type of the DC.  Must be one of DCTYPE_DIRECT,
*   DCTYPE_INFO, or DCTYPE_MEMORY.
*
* Returns:
*
*   HDC         - A handle to the DC.
*
\**************************************************************************/

class PRINTER
{
public:
    HANDLE hSpooler_;
    BOOL   bKeep;

public:
    PRINTER(PWSZ pwszDevice,DEVMODEW *pdriv,HANDLE hspool );
   ~PRINTER()
    {
        if (!bKeep && (hSpooler_ != (HANDLE) NULL))
            ClosePrinter(hSpooler_);
    }

    BOOL   bValid()     {return(hSpooler_ != (HANDLE) NULL);}
    VOID   vKeepIt()    {bKeep = TRUE;}
    HANDLE hSpooler()   {return(hSpooler_);}
};

// PRINTER constructor -- Attempts to open a spooler connection to the
//                        printer.

PRINTER::PRINTER(
    PWSZ pwszDevice,
    DEVMODEW *pdriv,
    HANDLE hspool )
{
    bKeep = FALSE;

    PRINTER_DEFAULTSW defaults;

    defaults.pDevMode = pdriv;
    defaults.DesiredAccess = PRINTER_ACCESS_USE;

    //
    // Attempt to open the printer for spooling journal files.
    // NOTE: For debugging, a global flag disables journaling.
    //

    defaults.pDatatype = (LPWSTR) L"RAW";

    if (hspool)
    {

        hSpooler_ = hspool;

    }
    else
    {
        if (!OpenPrinterW(pwszDevice,&hSpooler_,&defaults))
        {
            //
            // It's not a printer.  OpenPrinterW doesn't guarantee the value
            // of hSpooler in this case, so we have to clear it.
            //

            hSpooler_ = (HANDLE) NULL;
        }
    }

    return;
}

/******************************Public*Routine******************************\
* See comments above.
*
* History:
*  Andre Vachon [andreva]
*
\**************************************************************************/

HDC hdcOpenDCW(
    PWSZ               pwszDevice,  // The device driver name.
    DEVMODEW          *pdriv,       // Driver data.
    ULONG              iType,       // Identifies the type of DC to create.
    HANDLE             hspool,      // do we already have a spooler handle?
    PREMOTETYPEONENODE prton,
    DRIVER_INFO_2W    *pDriverInfo2, // we pass in pDriverInfo for UMPD, NULL otherwise
    PVOID              pUMdhpdev
    )
{
    HDC hdc = (HDC) 0;              // Prepare for the worst.
    DWORD cbNeeded = 0;
    PVOID mDriverInfo;
    BOOL bUMPD = pDriverInfo2 ? TRUE: FALSE;      // TRUE if User Mode driver

    TRACE_INIT(("\nhdcOpenDCW: ENTERING\n"));

    //
    // Attempt to open a display DC.
    //

    if (pwszDevice && !bUMPD)
    {
        PMDEV pmdev = NULL;
        HDEV  hdev = NULL;
        UNICODE_STRING usDevice;

        RtlInitUnicodeString(&usDevice,
                             pwszDevice);

        if (pdriv == NULL)
        {
            //
            // If no DEVMODE is present, then we just want to create a DC on
            // the specific device.
            // This will allow an application to make some escape calls to a
            // specific device\driver.
            //

            hdev = DrvGetHDEV(&usDevice);
        }
        else
        {
            //
            // We have to acquire the USER lock to synchronize with
            // ChangeDisplaySettings.
            //

            UserEnterUserCritSec();

            TRACE_INIT(("hdcOpenDCW: Trying to open as a second display device\n"));

            //
            // Only let the user do this if the device is not part of the
            // desktop.
            //

            pmdev = DrvCreateMDEV(&usDevice,
                                  pdriv,
                                  (PVOID) (ULONG_PTR)0xFFFFFFFF,
                                  GRE_DISP_CREATE_NODISABLE |
                                  GRE_DISP_NOT_APARTOF_DESKTOP,
                                  NULL,
                                  KernelMode,
                                  GRE_RAWMODE,
                                  FALSE); // buffer is captured in NtGdiOpenDCW()

            if (!pmdev)
            {
                DWORD dwDesktopId;

                if (UserGetCurrentDesktopId(&dwDesktopId))
                {
                    //
                    // Try match from current desktop display.
                    // but don't create new display instance.
                    //

                    pmdev = DrvCreateMDEV(&usDevice,
                                          pdriv,
                                          (PVOID) (ULONG_PTR) dwDesktopId,
                                          GRE_DISP_CREATE_NODISABLE |
                                          GRE_DISP_NOT_APARTOF_DESKTOP,

                                          NULL,
                                          KernelMode,
                                          GRE_RAWMODE,
                                          FALSE);
                }
            }

            UserLeaveUserCritSec();

            if (pmdev)
            {
                TRACE_INIT(("Drv_Trace: CreateExclusiveDC: We have an hdev\n"));
                ASSERTGDI(pmdev->chdev == 1,"hdcOpenDCW(): pmdev->chdev != 1");

                hdev = pmdev->Dev[0].hdev;
            }
        }

        if (hdev)
        {
            hdc = GreCreateDisplayDC(hdev, DCTYPE_DIRECT, FALSE);

            if (hdc)
            {
                if (pmdev || hdev)
                {
                    DCOBJ dco(hdc);
                    PDEVOBJ po(dco.hdev());

                    //
                    // Dereference the object since we want DeleteDC
                    // to automatically destroy the PDEV.
                    //
                    // This basically counteracts the extra reference that it done
                    // by DrvCreateMDEV(), or DrvGetHDEV().
                    //
                    po.vUnreferencePdev();
                }
            }
            else
            {
                TRACE_INIT(("hdcOpenDCW: Failed to get DC\n"));
                if (pmdev)
                {
                    DrvDestroyMDEV(pmdev);
                }
                else
                {
                    PDEVOBJ po(hdev);
                    po.vUnreferencePdev();
                }
            }
        }

        if (pmdev)
        {
            VFREEMEM(pmdev);
        }
    }

    //
    // Attempt to open a new printer DC.
    //

    if (hdc == NULL)
    {
        //
        // Open the spooler connection to the printer.
        // Allocate space for DRIVER_INFO.
        //

        PRINTER print(pwszDevice, pdriv, hspool);

        if (print.bValid())
        {
            if (!bUMPD)
            {
               if (mDriverInfo = PALLOCMEM(512, 'pmtG'))
               {
                   //
                   // Fill the DRIVER_INFO.
                   //

                   if (!GetPrinterDriverW(
                         print.hSpooler(),
                         NULL,
                         2,
                         (LPBYTE) mDriverInfo,
                         512,
                         &cbNeeded))
                   {

                       //
                       // Call failed - free the memory.
                       //

                       VFREEMEM(mDriverInfo);
                       mDriverInfo = NULL;

                       //
                       // Get more space if we need it.
                       //

                       if ((EngGetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
                           (cbNeeded > 0))
                       {
                           if (mDriverInfo = PALLOCMEM(cbNeeded, 'pmtG'))
                           {

                               if (!GetPrinterDriverW(print.hSpooler(),
                                                      NULL,
                                                      2,
                                                      (LPBYTE) mDriverInfo,
                                                      cbNeeded,
                                                      &cbNeeded))
                               {
                                   VFREEMEM(mDriverInfo);
                                   mDriverInfo = NULL;
                               }
                           }
                       }
                   }
               }
            }
            else
            {
                //
                // we have a pDriverInfo2 passed in for UMPD
                //
                mDriverInfo = pDriverInfo2;
            }

            if (mDriverInfo != (PVOID) NULL)
            {
                PLDEV pldev;

                if ( bUMPD)
                {
                    //
                    // we fake a pldev for each LoadDriver call.
                    // the real driver list is kept at the client side as a pUMPD list
                    //
                    pldev = UMPD_ldevLoadDriver(((DRIVER_INFO_2W *)mDriverInfo)->pDriverPath,
                                       LDEV_DEVICE_PRINTER);
                }
                else
                {
                    pldev = ldevLoadDriver(((DRIVER_INFO_2W *)mDriverInfo)->pDriverPath,
                                       LDEV_DEVICE_PRINTER);
                }

                if (pldev == NULL)
                {
                    SAVE_ERROR_CODE(ERROR_BAD_DRIVER_LEVEL);
                }
                else
                {

                    //
                    // Create a PDEV.  If no DEVMODEW passed in from above,
                    // use the default from the printer structure.
                    //
                    PDEVOBJ po(pldev,
                            (PDEVMODEW) pdriv,
                            pwszDevice,
                            ((DRIVER_INFO_2W *)mDriverInfo)->pDataFile,
                            ((DRIVER_INFO_2W *)mDriverInfo)->pName,
                            print.hSpooler(),
                            prton,
                            NULL,
                            NULL,
                            bUMPD);

                    if (po.bValid())
                    {
                        //
                        // Make a note that this is a printer.
                        //

                        po.bPrinter(TRUE);

                        //
                        // Allocate the DC, fill it with defaults.
                        //

                        hdc = GreCreateDisplayDC(po.hdev(),
                                                 iType,
                                                 TRUE);

                        //
                        // If the DC was properly create, keep the printer
                        // object so the printer stays open

                        if (hdc)
                        {
                            print.vKeepIt();

                            if (bUMPD && pUMdhpdev)
                            {
                               __try
                               {
                                   ProbeForWritePointer(pUMdhpdev);
                                   *(PUMDHPDEV *)pUMdhpdev = (PUMDHPDEV)po.dhpdev();
                               }
                               __except(EXCEPTION_EXECUTE_HANDLER)
                               {
                                   bDeleteDCInternal(hdc, FALSE, FALSE);
                                   hdc = 0;
                               }
                            }

                        }

                        //
                        // Always delete the PEV reference count.
                        // If the DC was created, the DC keeps the ref count
                        // at 1, and the PDEV will get destroyed when the
                        // DC gets destroyed.
                        // If the DC was not created properly, this will cause
                        // the PDEV to get destroyed immediately.
                        //

                        po.vUnreferencePdev();

                    }
                    else
                    {
                        if (!bUMPD)
                        {
                            ldevUnloadImage(pldev);
                        }
                        else
                        {
                            UMPD_ldevUnloadImage(pldev);
                        }
                    }
                }

                if (!bUMPD)
                {
                    VFREEMEM(mDriverInfo);
                }
            }
        }
    }

    if (hdc == (HDC) NULL)
    {
        WARNING("opendc.cxx: failed to create DC in hdcOpenDCW\n");
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* GreResetDCInternal
*
*   Reset the mode of a DC.  The DC returned will be a different DC than
*   the original.  The only common piece between the original DC and the
*   new one is the hSpooler.
*
*   There are a number of intresting problems to be carefull of.  The
*   original DC can be an info DC.  The new one will always be a direct DC.
*
*   Also, it is important to be carefull of the state of the DC when this
*   function is called and the effects of journaling vs non journaling.
*   In the case of journaling, the spooler is responsible for doing a CreateDC
*   to play the journal file to.  For this reason, the spooler must have the
*   current DEVMODE.  For this reason, ResetDC must call ResetPrinter for
*   spooled DC's.
*
*   ResetDC can happen at any time other than between StartPage-EndPage, even
*   before StartDoc.
*
*
* History:
*  13-Jan-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" BOOL GreResetDCInternal(
    HDC       hdc,
    DEVMODEW *pdmw,  // Driver data.
    BOOL      *pbBanding,
    DRIVER_INFO_2W *pDriverInfo2,
    PVOID     ppUMdhpdev)
{
    BOOL bSurf;
    BOOL bTempInfoDC = FALSE;
    HDC  hdcNew;
    BOOL bRet = FALSE;

    // we need this set of brackets so the DC's get unlocked before we try to delete
    // the dc>

    {
        DCOBJ   dco(hdc);

        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            // if this has been made into a TempInfoDC for printing, undo it now

            bTempInfoDC = dco.pdc->bTempInfoDC();

            if (bTempInfoDC)
                dco.pdc->bMakeInfoDC(FALSE);

            PDEVOBJ po(dco.hdev());

            // get list of Type1 remote type one fonts if there is one and transfer
            // it accross PDEV's.

            PREMOTETYPEONENODE prton = po.RemoteTypeOneGet();
            po.RemoteTypeOneSet(NULL);

            // This call only makes sense on RASTER technology printers.

            if (!dco.bKillReset() &&
                !(dco.dctp() == DCTYPE_MEMORY) &&
                (po.ulTechnology() == DT_RASPRINTER))
            {
                // First, remember if a surface needs to be created

                bSurf = dco.bHasSurface();

                // Now, clean up the DC

                if (dco.bCleanDC())
                {
                    // If there are any outstanding references to this PDEV, fail.

                    if (((PDEV *) po.hdev())->cPdevRefs == 1)
                    {
                        // create the new DC

                        hdcNew = hdcOpenDCW(L"",
                                            pdmw,
                                            DCTYPE_DIRECT,
                                            po.hSpooler(),
                                            prton,
                                            pDriverInfo2,
                                            ppUMdhpdev);

                        if (hdcNew)
                        {
                            // don't want to delete the spooler handle since it
                            // is in the new DC

                            po.hSpooler(NULL);

                            // lock down the new DC and PDEV

                            DCOBJ dcoNew(hdcNew);

                            if (!dcoNew.bValid())
                            {
                                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                            }
                            else
                            {
                                // Transfer any remote fonts

                                dcoNew.PFFListSet(dco.PFFListGet());
                                dco.PFFListSet(NULL);

                                // Transfer any color transform

                                dcoNew.CXFListSet(dco.CXFListGet());
                                dco.CXFListSet(NULL);

                                PDEVOBJ poNew((HDEV) dcoNew.pdc->ppdev());

                                // let the driver know

                                PFN_DrvResetPDEV rfn = PPFNDRV(po,ResetPDEV);

                                if (rfn != NULL)
                                {
                                    (*rfn)(po.dhpdev(),poNew.dhpdev());
                                }

                                // now swap the two handles

                                {
                                    MLOCKFAST mlo;

                                    BOOL bRes = HmgSwapLockedHandleContents((HOBJ)hdc,0,(HOBJ)hdcNew,0,DC_TYPE);
                                    ASSERTGDI(bRes,"GreResetDC - SwapHandleContents failed\n");
                                }

                                bRet = TRUE;
                            }
                        }
                    }
                }
            }
        }

        // DON'T DO ANYTHING HERE, the dcobj's don't match the handles, so
        // unlock them first
    }

    if (bRet)
    {
        // got a new dc, get rid of the old one (remember the handles have
        // been swapped)

        bDeleteDCInternal(hdcNew,TRUE,FALSE);

        // now deal with the new one

        DCOBJ newdco(hdc);

        if (!newdco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            bRet = FALSE;
        }
        else
        {
            PDEVOBJ newpo(newdco.hdev());

            // Create a new surface for the DC.

            if (bSurf)
            {
                if (!newpo.bMakeSurface())
                {
                    bRet = FALSE;
                }
                else
                {
                    newdco.pdc->pSurface(newpo.pSurface());
                    *pbBanding = newpo.pSurface()->bBanding();

                    if( *pbBanding )
                    {
                    // if banding set Clip rectangle to size of band

                        newdco.pdc->sizl((newpo.pSurface())->sizl());
                        newdco.pdc->bSetDefaultRegion();
                    }

                    PFN_DrvStartDoc pfnDrvStartDoc = PPFNDRV(newpo, StartDoc);
                    (*pfnDrvStartDoc)(newpo.pSurface()->pSurfobj(),NULL,0);
                }
            }
            else
            {
                // important to set this to FALSE is a surface has not yet been created
                // ie StartDoc has not yet been called.
                *pbBanding = FALSE;
            }

            // if the original was a tempinfo dc for printing, this one needs to be too.

            if (bRet && bTempInfoDC)
            {
                newdco.pdc->bMakeInfoDC(TRUE);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bDynamicMatchEnoughForModeChange
*
* We can dynamically change modes only if the new mode matches the old
* in certain respects.  This is because, for example, we don't have code
* written to track down all the places where flGraphicsCaps has been copied,
* and then change it asynchronously.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicMatchEnoughForModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew
    )
{
    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);
    BOOL    b = TRUE;

    // We would get quite confused with converting monochrome bitmaps if
    // we were to handle 1bpp:

    if ((poOld.iDitherFormat() == BMF_1BPP) ||
        (poNew.iDitherFormat() == BMF_1BPP))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Can't handle 1bpp");
        b = FALSE;
    }

    // Some random stuff must be the same between the old instance and
    // the new:
    //
    // We impose the restriction that some flGraphicsCaps flags must stay
    // the same with the new mode.  Specifically, we can't allow the
    // following to change:
    //
    // o  We don't allow GCAPS_HIGHRESTEXT to change because ESTROBJ::
    //    vInit needs to look at it sometimes without acquiring a lock,
    //    and it's pretty much a printer specific feature anyway.
    // o  We don't allow GCAPS_FORCEDITHER to change because vInitBrush
    //    needs to look for this flag without holding a lock, and because
    //    this flag is intended to be used only by printer drivers.

    if ((poNew.flGraphicsCaps() ^ poOld.flGraphicsCaps())
           & (GCAPS_HIGHRESTEXT | GCAPS_FORCEDITHER))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Driver's flGraphicsCaps did");
        WARNING("  not match for GCAPS_HIGHRESTEXT and GCAPS_FORCEDITHER\n");
        b = FALSE;
    }

    if ((poNew.ulLogPixelsX() != poOld.ulLogPixelsX()) ||
        (poNew.ulLogPixelsY() != poOld.ulLogPixelsY()))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Driver's ulLogPixels did not match\n");
        b = FALSE;
    }

    // We can't handle font producers because I haven't bothered with
    // code to traverse the font code's producer lists and Do The Right
    // Thing (appropriate locks are the biggest pain).  Fortunately,
    // font producing video drivers should be extremely rare.

    if (PPFNDRV(poNew, QueryFont)     ||
        PPFNDRV(poNew, QueryFontCaps) ||
        PPFNDRV(poNew, LoadFontFile)  ||
        PPFNDRV(poNew, QueryFontFile) ||
        PPFNDRV(poNew, GetGlyphMode))
    {
        WARNING("bDynamicMatchEnoughForModeChange: New driver can't be a font provider\n");
        b = FALSE;
    }

    if (PPFNDRV(poOld, QueryFont)     ||
        PPFNDRV(poOld, QueryFontCaps) ||
        PPFNDRV(poOld, LoadFontFile)  ||
        PPFNDRV(poOld, QueryFontFile) ||
        PPFNDRV(poOld, GetGlyphMode))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Old driver can't be a font provider\n");
        b = FALSE;
    }

    ASSERTGDI((poNew.ulTechnology() == DT_RASDISPLAY) &&
              (poOld.ulTechnology() == DT_RASDISPLAY),
        "Display drivers must specify DT_RASDISPLAY for ulTechnology");

    ASSERTGDI((poNew.flTextCaps() & ~TC_SCROLLBLT) ==
              (poOld.flTextCaps() & ~TC_SCROLLBLT),
        "Display drivers should set only TC_RA_ABLE in flTextCaps");

    return(b);
}

/******************************Public*Routine******************************\
* vAssertPaletteRefCountCorrect
*
* Validates the reference count for a palette by counting all the surfaces
* that use it.
*
* History:
*  14-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#if DBG

VOID
vAssertPaletteRefCountCorrect(
    PALETTE*    ppalOld
    )
{
    LONG        cAltLocks;
    LONG        cSurfaces;
    HOBJ        hobj;
    SURFACE*    pSurface;
    PALETTE*    ppalSurface;

    MLOCKFAST   mo;

    cSurfaces = 0;
    hobj = 0;
    while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
    {
        hobj = (HOBJ) pSurface->hGet();

        ppalSurface = pSurface->ppal();

        if (ppalSurface == ppalOld)
        {
            cSurfaces++;
        }
        else if ((ppalSurface != NULL) && (ppalSurface->ppalColor == ppalOld))
        {
            cSurfaces++;
        }
    }

    cAltLocks = ((POBJ) ppalOld)->ulShareCount;

    // The PDEV keeps a reference count on the palette, as does the
    // EngCreatePalette call.  So the number of Alt-locks should be
    // two more than the number of surfaces with this palette:

    if (cAltLocks < cSurfaces + 2)
    {
        KdPrint(("vAssertPaletteRefCountCorrect cAltLocks: %li != cSurfaces: %li.\n",
            cAltLocks - 2, cSurfaces));

        hobj = 0;
        while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
        {
            hobj = (HOBJ) pSurface->hGet();

            ppalSurface = pSurface->ppal();

            if (ppalSurface == ppalOld)
            {
                KdPrint(("  %p\n", pSurface));
            }
            else if ((ppalSurface != NULL) && (ppalSurface->ppalColor == ppalOld))
            {
                KdPrint((" -%p\n", pSurface));
            }
        }

        RIP("Breaking to debugger...");
    }
}

#else

    #define vAssertPaletteRefCountCorrect(ppalOld)

#endif

/******************************Public*Routine******************************\
* bDynamicRemoveAllDriverRealizations
*
* Cleanses a PDEV of all state that is specific to the device, such as
* device format bitmaps, and brush and font realizations.
*
* NOTE: The following locks must be held:
*
*           1. Devlock;
*           2. RFont list lock;
*           3. Handle manager lock.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicRemoveAllDriverRealizations(
    HDEV    hdev
    )
{
    BOOL                bConversionSuccessful;
    HOBJ                hobj;               // Temporary object handle
    SURFACE*            pSurface;           // Temporary surface pointer
    RFONT*              prfnt;              // Temporary RFONT pointer
    FONTOBJ*            pfo;                // Temporary FONTOBJ pointer
    BRUSH*              pbrush;             // Temporary BRUSH pointer
    PFN_DrvDestroyFont  pfnDrvDestroyFont;
    PDEV*               ppdev;

    PDEVOBJ po(hdev);

    ppdev = po.ppdev;

    // Now traverse all the device bitmaps associated with this device,
    // and convert any driver-owned bitmaps to DIBs.

    bConversionSuccessful = TRUE;

    hobj = 0;
    while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
    {
      // Retrieve the handle to the next surface before we delete
      // the current one:

      hobj = (HOBJ) pSurface->hGet();

      // Note that the sprite code handles mode changes for sprite
      // surfaces.

      if ((pSurface->hdev() == hdev) &&
          (pSurface->bDeviceDependentBitmap()) &&
          (pSurface->dhpdev() != NULL))
      {
        // The surface cannot be converted if there is any
        // outstanding lock other than those done to select
        // a bitmap into a DC.  We can't very well go and de-
        // allocate 'pSurface' while someone is looking at it.
        //
        // However, we really shouldn't fail a dynamic mode
        // change if some thread somewhere in the system should
        // happen to be doing a bitmap operation with a DFB.
        // For that reason, wherever a surface is locked,
        // we endeavour to hold either the dynamic mode change
        // lock or the devlock -- and since at this very moment
        // we have both, that should mean that these conversions
        // will never fail due to lock issues.

        if (pSurface->hdc() != 0)
        {
            // WinBug #242572 3-13-2001 jasonha Surface not selected by DC it thinks it is
            //
            // When a DC is saved while a DFB is selected, but then another
            // surface or no surface is selected, bConvertDfbDcToDib will
            // try to convert the top-level DC's surface to a DIB.
            //
            // Walk the saved DC chain until the first DC actually referencing
            // this surface is found.
            //

            HDC hdc = pSurface->hdc();

            while (1)
            {
                MDCOBJA dco(hdc);           // Alt-lock

                ASSERTGDI(dco.bValid(), "Surface DC is invalid");

                if (dco.pSurface() == pSurface)
                {
                    if (!bConvertDfbDcToDib(&dco))
                    {
                      WARNING("Failed DC surface conversion (possibly from low memory)\n");
                      bConversionSuccessful = FALSE;
                    }
                    break;
                }

                ASSERTGDI(dco.lSaveDepth() > 1, "DC selected surface not found in DC stack.");

                hdc = dco.hdcSave();
            }
        }
        else
        {
          // Handle Compatible Stock Surfaces
          if (pSurface->bStockSurface())
          {

            if (!pConvertDfbSurfaceToDib(hdev, pSurface, pSurface->cRef()))
            {
              WARNING("Failed stock surface conversion in bConvertStockDfbToDib()\n");
              bConversionSuccessful = FALSE;
            }
          }
          else
          {

            // No-one should have a lock on the bitmap:

            if (!pConvertDfbSurfaceToDib(hdev, pSurface, 0))
            {
              WARNING("Failed surface conversion (possibly from low memory)\n");
              bConversionSuccessful = FALSE;
            }
          }
        }
      }
    }

    // We are safe from new DFBs being created right now because we're
    // holding the devlock.

    if (bConversionSuccessful)
    {
      // Now get rid of any font caches that the old instance
      // of the driver may have.
      //
      // We're protected against having bDeleteRFONT call the
      // driver at the same time because it has to grab the
      // Devlock, and we're already holding it.

      pfnDrvDestroyFont = PPFNDRV(po, DestroyFont);
      if (pfnDrvDestroyFont != NULL)
      {
        // We must hold the RFONT list semaphore while we traverse the
        // RFONT list!

        for (prfnt = ppdev->prfntInactive;
             prfnt != NULL;
             prfnt = prfnt->rflPDEV.prfntNext)
        {
          pfo = &prfnt->fobj;
          pfnDrvDestroyFont(pfo);
          pfo->pvConsumer = NULL;
        }

        for (prfnt = ppdev->prfntActive;
             prfnt != NULL;
             prfnt = prfnt->rflPDEV.prfntNext)
        {
          pfo = &prfnt->fobj;
          pfnDrvDestroyFont(pfo);
          pfo->pvConsumer = NULL;
        }
      }

      // Make it so that any brush realizations are invalidated, because
      // we don't want a new instance of the driver trying to use old
      // instance 'pvRbrush' data.
      //
      // This also takes care of invalidating the brushes for all the
      // DDB to DIB conversions.
      //
      // Note that we're actually invalidating the caches of all brushes
      // in the system, because we don't store any 'hdevOld' information
      // with the brush.  Because dynamic mode changes should be relatively
      // infrequent, and because realizations are reasonably cheap, I don't
      // expect this to be a big hit.

      hobj = 0;
      while (pbrush = (BRUSH*) HmgSafeNextObjt(hobj, BRUSH_TYPE))
      {
        hobj = (HOBJ) pbrush->hGet();

        // Mark as dirty by setting the cache ID to
        // an invalid state.

        pbrush->ulSurfTime((ULONG) -1);

        // Set the uniqueness so the are-you-really-
        // dirty check in vInitBrush will not think
        // an old realization is still valid.

        pbrush->ulBrushUnique(pbrush->ulGlobalBrushUnique());
      }

      // We must disable the halftone device information when changing
      // colour depths because the GDIINFO data it was constructed with
      // are no longer valid.  It is always enabled lazily, so there's no
      // need to reenable it here:

      if (ppdev->pDevHTInfo != NULL)
      {
        po.bDisableHalftone();
      }
    }

    return(bConversionSuccessful);
}

/******************************Public*Routine******************************\
* bDynamicIntersectVisRect
*
* It is critical that we must be able to update all VisRgns if the new
* mode is smaller than the old.  If this did not happen, we could allow
* GDI calls to the driver that are outside the bounds of the visible
* display, and as a result the driver would quite likely fall over.
*
* We don't entrust USER to always take care of this case because it
* updates the VisRgns after it knows that bDynamicModeChange was
* successful -- which is too late if the VisRgn change should fail
* because of low memory.  It's acceptable in low memory situations to
* temporarily draw incorrectly as a result of a wrong VisRgn, but it
* is *not* acceptable to crash.
*
* Doing this here also means that USER doesn't have to call
* us while holding the Devlock.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicIntersectVisRect(
    SURFACE*  pSurfaceOld,
    SIZEL     sizlNew
    )
{
    HOBJ    hobj;
    DC*     pdc;

    hobj = 0;
    while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
    {
      hobj = (HOBJ) pdc->hGet();

      if ((!(pdc->fs() & DC_IN_CLONEPDEV)) &&
          (pdc->pSurface() == pSurfaceOld) &&
          (pdc->prgnVis() != NULL))
      {
        if (!GreIntersectVisRect((HDC) hobj, 0, 0,
                                 sizlNew.cx, sizlNew.cy))
        {
          WARNING("bDynamicModeChange: Failed reseting VisRect!\n");

          // Note that if we fail here, we may have already
          // shrunk some VisRgn's.  However, we should have only
          // failed in a very low-memory situation, in which case
          // there will be plenty of other drawing problems.  The
          // regions will likely all be reset back to the correct
          // dimensions by the owning applications, eventually.

          return(FALSE);
        }
      }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDynamicSwitchPalettes
*
* Device Independent Bitmaps (DIBs) are great when switching colour
* depths because, by virtue of their attached colour table (also known
* as a 'palette'), they Just Work at any colour depth.
*
* Device Dependent Bitmaps (DDBs) are more problematic.  They implicitly
* share their palette with the display -- meaning that if the display's
* palette is dynamically changed, the old DDBs will not work.  We get
* around this by dynamically creating palettes to convert them to DIBs.
* Unfortunately, at palettized 8bpp we sometimes have to guess at what
* the appropriate palette would be.  For this reason, whenever we switch
* back to 8bpp we make sure we convert them back to DDBs by removing their
* palettes.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDynamicSwitchPalettes(
    SURFACE*    pSurface,
    PDEV*       ppdevOld,
    PDEV*       ppdevNew
    )
{
    PALETTE*    ppalOld;
    HOBJ        hobj;
    BOOL        bHintCreated;

    ASSERTGDI(pSurface->iType() == STYPE_BITMAP,
        "Unexpected bitmap type");
    ASSERTGDI(pSurface->iFormat() == ppdevOld->devinfo.iDitherFormat,
        "Unexpected bitmap format");

    // Device Format Bitmaps (DFBs) are DDBs that are created via
    // CreateCompatibleBitmap, and so we know what device they're
    // associated with.
    //
    // Unfortunately, non-DFB DDBs (created via CreateBitmap or
    // CreateDiscardableBitmap) have no device assocation -- so we
    // don't know whether or not they're really associated with the
    // display.
    //
    // If a non-DFB DDB is currently selected into a DC owned by the
    // display, we will add a palette to it.  If a non-DFB DDB is
    // not currently selected into a DC owned by the display (implied
    // by having its surface 'hdev' as zero), we will not convert it.
    // SelectBitmap will refuse to load it into a DC.  (In 4.0 we used
    // to always assume that any such bitmap was intended for the
    // display, but that's not always a valid assumption, and doesn't
    // make much sense in a multiple-monitor or multi-user environment
    // anyway.)  Fortunately, non-DFB DDBs are increasingly rare.
    //
    // Note that DFBs are synchronized by the Devlock, and we don't
    // need a lock to change the palette for a non-DFB DDB (see
    // PALETTE_SELECT_SET logic).

    ppalOld = ppdevOld->ppalSurf;

    if (pSurface->ppal() == NULL)
    {
      // Mark the surface to note that we added a palette:

      pSurface->vSetDynamicModePalette();

      if (ppdevOld->GdiInfo.flRaster & RC_PALETTE)
      {
        bHintCreated = FALSE;
        if (pSurface->hpalHint() != 0)
        {
          EPALOBJ palDC(pSurface->hpalHint());
          if ((palDC.bValid())         &&
              (palDC.bIsPalDC())       &&
              (!palDC.bIsPalDefault()) &&
              (palDC.ptransFore() != NULL))
          {
            PALMEMOBJ palPerm;
            XEPALOBJ  palSurf(ppalOld);

            if (palPerm.bCreatePalette(PAL_INDEXED,
                    256,
                    (ULONG*) palSurf.apalColorGet(),
                    0,
                    0,
                    0,
                    PAL_FREE))
            {
              ULONG nPhysChanged = 0;
              ULONG nTransChanged = 0;

              palPerm.ulNumReserved(palSurf.ulNumReserved());

              bHintCreated = TRUE;
              vMatchAPal(NULL,
                         palPerm,
                         palDC,
                         &nPhysChanged,
                         &nTransChanged);

              palPerm.vKeepIt();
              pSurface->ppal(palPerm.ppalGet());

              // Keep a reference active:

              palPerm.ppalSet(NULL);
            }
          }
        }

        if (!bHintCreated)
        {
          INC_SHARE_REF_CNT(ppalDefaultSurface8bpp);
          pSurface->ppal(ppalDefaultSurface8bpp);
        }
      }
      else
      {
        INC_SHARE_REF_CNT(ppalOld);
        pSurface->ppal(ppalOld);
      }
    }
    else if ((pSurface->ppal() == ppalOld) &&
             (pSurface->flags() & PALETTE_SELECT_SET))
    {
      ASSERTGDI((pSurface->hdc() != 0) &&
                (pSurface->cRef() != 0),
               "Expected bitmap to be selected into a DC");

      INC_SHARE_REF_CNT(pSurface->ppal());
      pSurface->flags(pSurface->flags() & ~PALETTE_SELECT_SET);
    }

    // When switching back to palettized 8bpp, remove any palettes we
    // had to add to 8bpp DDBs:

    if (ppdevNew->GdiInfo.flRaster & RC_PALETTE)
    {
      if (pSurface->bDynamicModePalette())
      {
        ASSERTGDI(pSurface->ppal() != NULL,
            "Should be a palette here");

        XEPALOBJ pal(pSurface->ppal());
        pal.vUnrefPalette();

        pSurface->vClearDynamicModePalette();
        pSurface->ppal(NULL);
      }
    }
}

/******************************Public*Routine******************************\
* bDynamicModeChange
*
* USER callable function that switches driver instances between two PDEVs.
*
* GDI's 'HDEV' and 'PDEV' stay the same; only the device's 'pSurface',
* 'dhpdev', GDIINFO, DEVINFO, and palette information change.
*
* The caller is ChangeDisplaySettings in USER, which is reponsible for:
*
*   o Calling us with a valid devmode;
*   o Ensuring that the device is not currently in full-screen mode;
*   o Invalidating all of its SaveScreenBits buffers;
*   o Changing the VisRgn's on all DCs;
*   o Resetting the pointer shape;
*   o Sending the appropriate messages to everyone;
*   o Redrawing the desktop.
*
* Since CreateDC("DISPLAY") always gets mapped to GetDC(NULL), there are
* no DC's for which GDI is responsible for updating the VisRgn.
*
* Dynamically changes a display driver or mode.
*
* Rules of This Routine
* ---------------------
*
* o An important precept is that no drawing by any threads to any
*   application's bitmaps should be affected by this routine.  This means,
*   for example, that we cannot exclusive lock any DCs.
*
* o While we keep GDI's 'HDEV' and 'PDEV' in place, we do have to modify
*   fields like 'dhpdev' and 'pSurface'.  Because we also have to update
*   copies of these fields that are stashed in DC's, it means that *all*
*   accesses to mode-dependent fields such as 'dhpdev,' 'pSurface,' and
*   'sizl' must be protected by holding a resource that this routine
*   acquires -- such as the devlock or handle-manager lock.
*
* o If the function fails for whatever reason, the mode MUST be restored
*   back to its original state.
*
* Returns: TRUE if successful, FALSE if the two PDEVs didn't match enough,
*          or if we're out of memory.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*
*  27-Aug-1996 -by- J. Andrew Goossen [andrewgo]
* Added support for dynamic display driver changes.
*
\**************************************************************************/

ULONG gcModeChanges;    // # of mode changes, for debugging even on free builds

#define SWAP(x, y, tmp) { (tmp) = (x); (x) = (y); (y) = (tmp); }

typedef union {
    GDIINFO                     GdiInfo;
    DEVINFO                     devinfo;
    PFN                         apfn[INDEX_LAST];
    LDEV*                       pldev;
    HANDLE                      hSpooler;
    PVOID                       pDesktopId;
    PGRAPHICS_DEVICE            pGraphicsDevice;
    POINTL                      ptlOrigin;
    PDEVMODEW                   ppdevDevmode;
    PFN_DrvSetPointerShape      pfnSet;
    PFN_DrvMovePointer          pfnMove;
    PFN_DrvSynchronize          pfnSync;
    PFN_DrvSynchronizeSurface   pfnSyncSurface;
    PFN_DrvSetPalette           pfnSetPalette;
    PFN_DrvBitBlt               pfnUnfilteredBitBlt;
    PFN_DrvNotify               pfnNotify;
    BYTE                        dc[sizeof(DC)];
    SIZEL                       sizlMeta;
    HSURF                       ahsurf[HS_DDI_MAX];
    HLFONT                      hlfnt;
    DWORD                       dwDriverAccelerationLevel;
    DWORD                       dwDriverCapableOverride;
#ifdef DDI_WATCHDOG
    PVOID                       pWatchdogContext;
    PWATCHDOG_DATA              pWatchdogData;
#endif
} SWAPBUFFER;

BOOL
bDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew
    )
{
    BOOL                bRet;
    BOOL                bFormatChange;
    PDEV*               ppdevOld;
    PDEV*               ppdevNew;
    DHPDEV              dhpdevOld;
    DHPDEV              dhpdevNew;
    SURFACE*            pSurfaceOld;
    SURFACE*            pSurfaceNew;
    PALETTE*            ppalOld;
    PALETTE*            ppalNew;
    ULONG               cBppOld;
    ULONG               cBppNew;
    SIZEL               sizlOld;
    SIZEL               sizlNew;
    SURFACE*            pSurface;        // Temporary surface pointer
    DC*                 pdc;             // Temporary DC pointer
    DRVOBJ*             pdo;             // Temporary DRVOBJ pointer
    HOBJ                hobj;            // Temporary object handle
    BOOL                bPermitModeChange;
    BRUSH*              pbrGrayPattern;
    DC*                 pdcBuffer;       // Points to temporary DC buffer
    SWAPBUFFER*         pswap;
    BOOL                bDisabledOld;
    BOOL                bDisabledNew;
    PFN_DrvResetPDEV    pfnDrvResetPDEV;

    bRet = FALSE;                           // Assume failure

    // We impose some restrictions upon what capabilities may change
    // between drivers:

    if (bDynamicMatchEnoughForModeChange(hdevOld, hdevNew))
    {

      ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
                  "ShareDevlock must held be before calling bDynamicModeChange");

      // Allocate a temporary buffer for use swapping data:

      pswap = (SWAPBUFFER*) PALLOCNOZ(sizeof(SWAPBUFFER), 'pmtG');
      if (pswap)
      {
        PDEVOBJ poOld(hdevOld);
        PDEVOBJ poNew(hdevNew);

        bDisabledNew = poNew.bDisabled();
        bDisabledOld = poOld.bDisabled();

        // Disable timer-based synchronization for these PDEVs for now.
        // This is mainly so that the PDEV_SYNCHRONIZE_ENABLED is set
        // correctly.

        vDisableSynchronize(hdevNew);
        vDisableSynchronize(hdevOld);

        cBppOld = poOld.GdiInfo()->cBitsPixel * poOld.GdiInfo()->cPlanes;
        cBppNew = poNew.GdiInfo()->cBitsPixel * poNew.GdiInfo()->cPlanes;

        // Ideally, we would check the palettes here, too:

        bFormatChange = (cBppOld != cBppNew);

        ppdevOld = (PDEV*) hdevOld;
        ppdevNew = (PDEV*) hdevNew;

        // PDEV shouldn't be clone

        ASSERTGDI(!poOld.bCloneDriver(),"pdevOld is clone!");
        ASSERTGDI(!poNew.bCloneDriver(),"pdevNew is clone!");

        // The following lock rules must be abided, otherwise deadlocks may
        // arise:
        //
        // o  Pointer lock must be acquired after Devlock (GreSetPointer);
        //
        // And see drvsup.cxx, too.
        //
        // So we acquire locks in the following order (note that the
        // vAssertDynaLock() routines should be modified if this list ever
        // changes):

        ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(poOld.hsemDevLock()),
                  "Devlock must be held before acquiring the pointer semaphore");

        SEMOBJ soPointer(poOld.hsemPointer()); // No asynchronous pointer moves

        ASSERTGDI(ppdevOld->pSurface != NULL, "Must be called on a completed PDEV");
        ASSERTGDI(poOld.bDisplayPDEV(), "Must be called on a display PDEV");
        ASSERTGDI((prgnDefault->cScans == 1) && (prgnDefault->rcl.right == 0),
            "Someone changed prgnDefault; could cause driver access violations");

        // Free all PDEV state that is dependent on or cached by the driver:

        if (bDynamicRemoveAllDriverRealizations(hdevOld) &&
            bDynamicRemoveAllDriverRealizations(hdevNew))
        {
          bPermitModeChange = TRUE;

          sizlOld       = poOld.sizl();
          pSurfaceOld   = ppdevOld->pSurface;
          ppalOld       = ppdevOld->ppalSurf;
          dhpdevOld     = ppdevOld->dhpdev;

          sizlNew       = poNew.sizl();
          pSurfaceNew   = ppdevNew->pSurface;
          ppalNew       = ppdevNew->ppalSurf;
          dhpdevNew     = ppdevNew->dhpdev;

          // Make sure the VisRgns are immediately shrunk if necessary:

          if ((sizlNew.cx < sizlOld.cx) || (sizlNew.cy < sizlOld.cy))
          {
            bPermitModeChange &= bDynamicIntersectVisRect(pSurfaceOld, sizlNew);
          }
          if ((sizlOld.cx < sizlNew.cx) || (sizlOld.cy < sizlNew.cy))
          {
            bPermitModeChange &= bDynamicIntersectVisRect(pSurfaceNew, sizlOld);
          }

          // Finally, if we're not switching drivers then let the driver know
          // about the mode switch.  This has to be the last step because we
          // are implicitly telling the driver that it can transfer data from
          // the old instance to the new instance with the assurance that the
          // new instance won't later be abandoned.

          pfnDrvResetPDEV = PPFNDRV(poNew, ResetPDEV);
	  if ((pfnDrvResetPDEV != NULL) &&
	      (pfnDrvResetPDEV == PPFNDRV(poOld, ResetPDEV)) &&
	      (poNew.pldev() == poOld.pldev()))
          {
            // The driver can refuse the mode switch if it wants:

            if (bPermitModeChange)
            {
              GreEnterMonitoredSection(poOld.ppdev, WD_DEVLOCK);
              bPermitModeChange = pfnDrvResetPDEV(dhpdevOld, dhpdevNew);
              GreExitMonitoredSection(poOld.ppdev, WD_DEVLOCK);
            }
          }

          if (bPermitModeChange)
          {
            /////////////////////////////////////////////////////////////
            // At this point, we're committed to the mode change.
            // Nothing below this point can be allowed to fail.
            /////////////////////////////////////////////////////////////

            // Traverse all DC's and update their surface information if
            // they're associated with this device.
            //
            // Note that bDeleteDCInternal wipes some fields in the DC via
            // bCleanDC before freeing the DC, but this is okay since the
            // worst we'll do is update some fields just before the DC gets
            // deleted.

            hobj = 0;
            while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
            {
              hobj = (HOBJ) pdc->hGet();

              if (!(pdc->fs() & DC_IN_CLONEPDEV))
              {
                // Note that we don't check that pdc->hdevOld() == hdevOld
                // because the SaveDC stuff doesn't bother copying the hdevOld,
                // but DOES copy the dclevel.
                //
                // Note that 'flbrushAdd()' is not an atomic operation.
                // However, since we're holding the devlock and the palette
                // lock, there shouldn't be any other threads alt-locking our
                // DC and modifying these fields at the same time:

                if (pdc->pSurface() == pSurfaceOld)
                {
                  pdc->pSurface(pSurfaceNew);
                  pdc->sizl(sizlNew);
                  pdc->flbrushAdd(DIRTY_BRUSHES);
                }
                else if (pdc->pSurface() == pSurfaceNew)
                {
                  pdc->pSurface(pSurfaceOld);
                  pdc->sizl(sizlOld);
                  pdc->flbrushAdd(DIRTY_BRUSHES);
                }

                if (pdc->dhpdev() == dhpdevOld)
                {
                  pdc->dhpdev(dhpdevNew);
                  pdc->flGraphicsCaps(poNew.flGraphicsCaps());
                  pdc->flGraphicsCaps2(poNew.flGraphicsCaps2());
                }
                else if (pdc->dhpdev() == dhpdevNew)
                {
                  pdc->dhpdev(dhpdevOld);
                  pdc->flGraphicsCaps(poOld.flGraphicsCaps());
                  pdc->flGraphicsCaps2(poOld.flGraphicsCaps2());
                }
              }
            }

            // Compatible bitmap palettes may have to be changed if the
            // mode changes.  Note that the sprite code handles any
            // sprite surfaces:

            hobj = 0;
            while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
            {
              hobj = (HOBJ) pSurface->hGet();

              if (pSurface->hdev() == hdevOld)
              {
                if (pSurface->bApiBitmap())
                {
                  if ((bFormatChange) &&
                      (pSurface->iFormat() == pSurfaceOld->iFormat()))
                  {
                    vDynamicSwitchPalettes(pSurface, ppdevOld, ppdevNew);
                  }
                }

                // Surfaces private to the driver should be transferred
                // along with the driver instance.

                else if (pSurface->bDriverCreated() && !pSurface->bDirectDraw())
                {
                  pSurface->hdev(hdevNew);
                }
              }
              else if (pSurface->hdev() == hdevNew)
              {
                if (pSurface->bApiBitmap())
                {
                  if ((bFormatChange) &&
                      (pSurface->iFormat() == pSurfaceNew->iFormat()))
                  {
                    vDynamicSwitchPalettes(pSurface, ppdevNew, ppdevOld);
                  }
                }

                // Surfaces private to the driver should be transferred
                // along with the driver instance.

                else if (pSurface->bDriverCreated() && !pSurface->bDirectDraw())
                {
                  pSurface->hdev(hdevOld);
                }
              }
            }

            // DRIVEROBJs are transferred with the driver to the new PDEV:

            hobj = 0;
            while (pdo = (DRVOBJ*) HmgSafeNextObjt(hobj, DRVOBJ_TYPE))
            {
              hobj = (HOBJ) pdo->hGet();

              if (pdo->hdev == hdevOld)
              {
                pdo->hdev = hdevNew;
                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
              }
              else if (pdo->hdev == hdevNew)
              {
                pdo->hdev = hdevOld;
                poOld.vReferencePdev();
                poNew.vUnreferencePdev();
              }
            }

            // Same with WNDOBJs:

            vChangeWndObjs(pSurfaceOld, hdevOld, pSurfaceNew, hdevNew);

            // Re-realize the gray pattern brush which is used for drag
            // rectangles:

            pbrGrayPattern = (BRUSH*) HmgShareLock((HOBJ)ghbrGrayPattern,
                                                   BRUSH_TYPE);

            pdcBuffer = (DC*) &pswap->dc;
            pdcBuffer->pDCAttr = &pdcBuffer->dcattr;
            pdcBuffer->crTextClr(0x00000000);
            pdcBuffer->crBackClr(0x00FFFFFF);
            pdcBuffer->lIcmMode(DC_ICM_OFF);
            pdcBuffer->hcmXform(NULL);

            poOld.pbo()->vInitBrush(pdcBuffer,
                                    pbrGrayPattern,
                                    (XEPALOBJ) ppalDefault,
                                    (XEPALOBJ) ppalNew,
                                    pSurfaceNew);
            poNew.pbo()->vInitBrush(pdcBuffer,
                                    pbrGrayPattern,
                                    (XEPALOBJ) ppalDefault,
                                    (XEPALOBJ) ppalOld,
                                    pSurfaceOld);

            DEC_SHARE_REF_CNT(pbrGrayPattern);

            /////////////////////////////////////////////////////////////
            // Update all our PDEV fields:
            /////////////////////////////////////////////////////////////

            // Swap surface data between the two PDEVs:

            ppdevNew->pSurface = pSurfaceOld;
            ppdevNew->ppalSurf = ppalOld;
            ppdevNew->dhpdev   = dhpdevOld;

            ppdevOld->pSurface = pSurfaceNew;
            ppdevOld->ppalSurf = ppalNew;
            ppdevOld->dhpdev   = dhpdevNew;

            if (!pSurfaceOld->bReadable())
            {
              pSurfaceNew->flags(pSurfaceNew->flags() | UNREADABLE_SURFACE);

              SPRITESTATE *pStateOld = poOld.pSpriteState();
              if (pStateOld)
              {
                if (pStateOld->flOriginalSurfFlags & UNREADABLE_SURFACE ||
                    pStateOld->flSpriteSurfFlags & UNREADABLE_SURFACE)
                {
                  SPRITESTATE *pStateNew = poNew.pSpriteState();
                  if (pStateNew)
                  {
                    pStateNew->flOriginalSurfFlags |= UNREADABLE_SURFACE;
                    pStateNew->flSpriteSurfFlags |= UNREADABLE_SURFACE;
                  }
                }
              }
            }
            else if (!pSurfaceNew->bReadable())
            {
              pSurfaceOld->flags(pSurfaceOld->flags() | UNREADABLE_SURFACE);

              SPRITESTATE *pStateNew = poNew.pSpriteState();
              if (pStateNew)
              {
                if (pStateNew->flOriginalSurfFlags & UNREADABLE_SURFACE ||
                    pStateNew->flSpriteSurfFlags & UNREADABLE_SURFACE)
                {
                  SPRITESTATE *pStateOld = poOld.pSpriteState();
                  if (pStateOld)
                  {
                    pStateOld->flOriginalSurfFlags |= UNREADABLE_SURFACE;
                    pStateOld->flSpriteSurfFlags |= UNREADABLE_SURFACE;
                  }
                }
              }
            }
            // WINBUG #365395 4-10-2001 jasonha Need to investigate old comments in bDynamicModeChange
            //
            // Old Comments:
            //  - vUnrefPalette of old palette for mirrored drivers?
            //  - Secondary palette fix?

            SWAP(ppdevNew->pldev          ,ppdevOld->pldev          ,pswap->pldev          );
            SWAP(ppdevNew->devinfo        ,ppdevOld->devinfo        ,pswap->devinfo        );
            SWAP(ppdevNew->GdiInfo        ,ppdevOld->GdiInfo        ,pswap->GdiInfo        );
            SWAP(ppdevNew->hSpooler       ,ppdevOld->hSpooler       ,pswap->hSpooler       );
            SWAP(ppdevNew->pDesktopId     ,ppdevOld->pDesktopId     ,pswap->pDesktopId     );
            SWAP(ppdevNew->pGraphicsDevice,ppdevOld->pGraphicsDevice,pswap->pGraphicsDevice);
            SWAP(ppdevNew->ptlOrigin      ,ppdevOld->ptlOrigin      ,pswap->ptlOrigin      );
            SWAP(ppdevNew->ppdevDevmode   ,ppdevOld->ppdevDevmode   ,pswap->ppdevDevmode   );

            SWAP(ppdevNew->pfnUnfilteredBitBlt,
                 ppdevOld->pfnUnfilteredBitBlt,
                 pswap->pfnUnfilteredBitBlt);

            SWAP(ppdevNew->dwDriverCapableOverride,
                 ppdevOld->dwDriverCapableOverride,
                 pswap->dwDriverCapableOverride);

            SWAP(ppdevNew->dwDriverAccelerationLevel,
                 ppdevOld->dwDriverAccelerationLevel,
                 pswap->dwDriverAccelerationLevel);

            // Swap multimon data between the two PDEVs:

            if (poOld.bMetaDriver() != poNew.bMetaDriver())
            {
                BOOL bMetaDriver = poOld.bMetaDriver();
                poOld.bMetaDriver(poNew.bMetaDriver());
                poNew.bMetaDriver(bMetaDriver);
            }

            SWAP(ppdevNew->sizlMeta, ppdevOld->sizlMeta, pswap->sizlMeta);

            // Swap pattern brushes

            RtlCopyMemory(pswap->ahsurf,    ppdevNew->ahsurf, sizeof(HSURF)*HS_DDI_MAX);
            RtlCopyMemory(ppdevNew->ahsurf, ppdevOld->ahsurf, sizeof(HSURF)*HS_DDI_MAX);
            RtlCopyMemory(ppdevOld->ahsurf, pswap->ahsurf,    sizeof(HSURF)*HS_DDI_MAX);

            // Swap log fonts.

            SWAP(ppdevNew->hlfntDefault,      ppdevOld->hlfntDefault,      pswap->hlfnt);
            SWAP(ppdevNew->hlfntAnsiVariable, ppdevOld->hlfntAnsiVariable, pswap->hlfnt);
            SWAP(ppdevNew->hlfntAnsiFixed,    ppdevOld->hlfntAnsiFixed,    pswap->hlfnt);

            // Swap the dispatch tables and accelerators:

            RtlCopyMemory(pswap->apfn,    ppdevNew->apfn, sizeof(PFN)*INDEX_LAST);
            RtlCopyMemory(ppdevNew->apfn, ppdevOld->apfn, sizeof(PFN)*INDEX_LAST);
            RtlCopyMemory(ppdevOld->apfn, pswap->apfn,    sizeof(PFN)*INDEX_LAST);

            SWAP(ppdevNew->pfnDrvSetPointerShape, ppdevOld->pfnDrvSetPointerShape, pswap->pfnSet);
            SWAP(ppdevNew->pfnDrvMovePointer,     ppdevOld->pfnDrvMovePointer,     pswap->pfnMove);
            SWAP(ppdevNew->pfnSync,               ppdevOld->pfnSync,               pswap->pfnSync);
            SWAP(ppdevNew->pfnSyncSurface,        ppdevOld->pfnSyncSurface,        pswap->pfnSyncSurface);
            SWAP(ppdevNew->pfnSetPalette,         ppdevOld->pfnSetPalette,         pswap->pfnSetPalette);
            SWAP(ppdevNew->pfnNotify,             ppdevOld->pfnNotify,             pswap->pfnNotify);
#ifdef DDI_WATCHDOG
            SWAP(ppdevNew->pWatchdogContext,      ppdevOld->pWatchdogContext,      pswap->pWatchdogContext);
            SWAP(ppdevNew->pWatchdogData,         ppdevOld->pWatchdogData,         pswap->pWatchdogData);
#endif

            // Inform the drivers of their new PDEVs:

            (*PPFNDRV(poNew, CompletePDEV))(poNew.dhpdev(), poNew.hdev());
            (*PPFNDRV(poOld, CompletePDEV))(poOld.dhpdev(), poOld.hdev());

            // Transfer all the DirectDraw state:

            DxDdDynamicModeChange(hdevOld, hdevNew, 0);

            // Transfer the disabled state:

            poOld.bDisabled(bDisabledNew);
            poNew.bDisabled(bDisabledOld);

            // Update the magic colours in the surface palette:

            vResetSurfacePalette(hdevOld);
            vResetSurfacePalette(hdevNew);

            // Transfer all the sprites between the two PDEVs:

            vSpDynamicModeChange(hdevOld, hdevNew);

            // Update the gamma-ramp on the device only if a gamma-ramp
            // existed in the old (but at this moment, old is "new") PDEV:

            UpdateGammaRampOnDevice(hdevOld, FALSE);

            // Update some handy debug information:

            gcModeChanges++;

            bRet = TRUE;
          }
        }

        VFREEMEM(pswap);

        vEnableSynchronize(hdevNew);
        vEnableSynchronize(hdevOld);
      }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\os.cxx ===
/******************************Module*Header*******************************\
* Module Name: os.cxx                                                      *
*                                                                          *
* Convenient functions to access the OS interface.                         *
*                                                                          *
* Created: 29-Aug-1989 19:59:05                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1989-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"
#include "winstaw.h"

extern BOOL G_fConsole;
extern PFILE_OBJECT G_RemoteVideoFileObject;
extern "C" USHORT gProtocolType;

/******************************Public*Routine******************************\
* EngGetProcessHandle
*
* Returns the current thread of the application.
*
* History:
*  24-Jan-1996 -by- Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetProcessHandle()
{
    return (HANDLE) NULL;
}

/******************************Public*Routine******************************\
* EngGetCurrentProcessId
*
* Returns the current process id of the application.
*
* History:
*  28-May-1999 -by- Barton House [bhouse]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetCurrentProcessId()
{
    return PsGetCurrentProcessId();
}

/******************************Public*Routine******************************\
* EngGetCurrentThreadId
*
* Returns the current thread id of the application.
*
* History:
*  28-May-1999 -by- Barton House [bhouse]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetCurrentThreadId()
{
    return PsGetCurrentThreadId();
}

#if !defined(_GDIPLUS_)
// Kernel-mode version

    /******************************Public*Routine******************************\
    * GreCreateSemaphore
    *
    * Create a semaphore with tracking.
    *
    * For use by GDI internal code. Tracking
    * allows semaphores to be released during MultiUserNtGreCleanup (Hydra)
    * cleanup.
    *
    * Warning! For code dealing with pool/semaphore tracking, as
    *   in pooltrk.cxx and muclean.cxx, do not create semaphores with
    *   this function, as it may call functions which use those semaphores. Instead,
    *   use GreCreateSemaphoreNonTracked and GreDeleteSemaphoreNonTracked.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    * History:
    *
    *    25-May-1995 - Changed to PERESOURCE
    *    19-May-1998 - Changed to HSEMAPHORE.
    *                  Merged AcquireGreResource with hsemCreateTracked
    *                  to create this function.
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphore()
    {
	return GreCreateSemaphoreInternal(OBJ_ENGINE_CREATED);
    }

    HSEMAPHORE
    GreCreateSemaphoreInternal(ULONG CreateFlags)
    {
        PERESOURCE pres;
        ULONGSIZE_T cj = sizeof(ERESOURCE);

        //
        // Adjust size to include ENGTRACKHDR header.
        //

        cj += sizeof(ENGTRACKHDR);

        //
        // Allocate ERESOURCE (must be nonpaged pool).
        //

        pres = (PERESOURCE) GdiAllocPoolNonPagedNS(cj, 'mesG');

        if (pres)
        {
            //
            // Adjust resource to exclude the ENGTRACKHDR.
            //
            //                 Buffer
            //   pethNew --> +----------------+
            //               | ENGTRACKHDR    |
            //      pres --> +----------------+
            //               | ERESOURCE      |
            //               |                |
            //               +----------------+
            //
            // Note that pethNew always points to base of allocation.
            //

            ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pres;

            pres = (PERESOURCE) (pethNew + 1);

            //
            // Initialize the resource.
            //

            if (NT_SUCCESS(ExInitializeResourceLite(pres)))
            {
                //
                // Track the resource.
                //

		if (CreateFlags & OBJ_DRIVER_CREATED) {
		    MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_DRIVER_SEMAPHORE);
		} else {
		    MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_SEMAPHORE);
		}
            }
            else
            {
                GdiFreePool(pethNew);
                pres = NULL;
            }
        }
        return (HSEMAPHORE) pres;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphore
    *
    * Deletes the given semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphore(
        HSEMAPHORE hsem
        )
    {
        PERESOURCE pres = (PERESOURCE) hsem;
        if (pres)
        {
            ENGTRACKHDR *pethVictim = (ENGTRACKHDR *) pres;

            //
            // Need to adjust peth pointer to header.
            //
            // Note: whether Hydra or non-Hydra, pethVictim will always
            // point to the base of the allocation.
            //

            //
            // Remove victim from tracking list.
            //

            pethVictim -= 1;
            MultiUserGreTrackRemoveEngResource(pethVictim);
    
            ASSERTGDI(pres->OwnerThreads[0].OwnerThread
                != (ERESOURCE_THREAD) PsGetCurrentThread(),
                "The resource is being deleted while it's still held!");

            ExDeleteResourceLite(pres);
            GdiFreePool(pethVictim);
        }
    }

    /******************************Public*Routine******************************\
    * GreCreateSemaphoreNonTracked
    *
    * Create a semaphore, without pool-tracking or semaphore-tracking.
    *
    * Only for use by the pool-tracking and semaphore-tracking code. This
    * avoids the circular dependency which using GreCreateSemaphore would
    * cause.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphoreNonTracked()
    {
        PERESOURCE pres;

        pres = (PERESOURCE) ExAllocatePoolWithTag(
                   (POOL_TYPE)NonPagedPool,
                   sizeof(ERESOURCE), 'mesG');

        if (pres)
        {
            if (!NT_SUCCESS(ExInitializeResourceLite(pres)))
            {
                ExFreePool(pres);
                pres = NULL;
            }
        }

        return (HSEMAPHORE) pres;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphoreNonTracked
    *
    * Deletes the given non-tracked semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphoreNonTracked(
        HSEMAPHORE hsem
        )
    {
        PERESOURCE pres = (PERESOURCE) hsem;

        if (pres)
        {

            ASSERTGDI(pres->OwnerThreads[0].OwnerThread
                != (ERESOURCE_THREAD) PsGetCurrentThread(),
                "The resource is being deleted while it's still held!");

            ExDeleteResourceLite(pres);
            ExFreePool(pres);
        }
    }

#if VALIDATE_LOCKS

    BOOL gDebugSem = TRUE;
    BOOL gDebugSemBreak = FALSE;

#define SEM_HISTORY_LENGTH  4

    typedef struct {
        const char *name;
        const char *func;
        const char *file;
        int         line;
    } SemHistory;

    typedef struct SemEntry {
        HSEMAPHORE  hsem;
        ULONG       count;
        ULONG       order;
        HSEMAPHORE  parent;
#if SEM_HISTORY_LENGTH
        SemHistory  Acquired[SEM_HISTORY_LENGTH];
#endif
    } SemEntry;

#define kMaxSemEntries  64

    typedef struct SemTable {
        FLONG       flags;
        ULONG       numEntries;
        SemEntry    entries[kMaxSemEntries];
    } SemTable;


    /******************************Public*Routine******************************\
    * SemTrace::SemTrace                                                       *
    \**************************************************************************/

    SemTrace::SemTrace(FLONG SetFlags)
    {
        DontClearMask = ~0;

        if (gDebugSem && gDebugSemBreak)
        {
            pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable *pSemTable = (SemTable *) pThread->pSemTable;

                if(pSemTable != NULL)
                {
                    DontClearMask = pSemTable->flags | ~SetFlags;

                    if (DontClearMask != ~0)
                    {
                        DbgPrint(" ** Enabling additional sem tracing for W32THREAD @ %p, SemTable @ %p\n", pThread, pSemTable);
                        pSemTable->flags |= SetFlags;
                    }
                }
            }
        }
    }

    /******************************Public*Routine******************************\
    * SemTrace::~SemTrace                                                      *
    \**************************************************************************/

    SemTrace::~SemTrace()
    {
        // Have anything to clear?
        if (DontClearMask != ~0)
        {
            SemTable *pSemTable = (SemTable *)pThread->pSemTable;

            if (pSemTable)
            {
                DbgPrint(" ** Disabling additional sem tracing for W32THREAD @ %p, SemTable @ %p\n", pThread, pSemTable);
                pSemTable->flags &= DontClearMask;
            }
            else
            {
                DbgPrint(" ** Couldn't disable added sem tracing for W32THREAD @ %p; SemTable is NULL\n", pThread);
            }
        }
    }


    /*****************************Private*Routine******************************\
    * FindSemEntry                                                             *
    \**************************************************************************/

    SemEntry * FindSemEntry(SemTable * pTable, HSEMAPHORE hsem)
    {
        SemEntry *  entry = pTable->entries;
        SemEntry *  sentry = entry + pTable->numEntries;

        while(entry < sentry)
        {
            if(entry->hsem == hsem)
                return entry;
            entry++;
        }

        return NULL;

    }


    /*****************************Private*Routine******************************\
    * RemoveSemEntry                                                           *
    \**************************************************************************/

    void
    RemoveSemEntry(
        SemTable   *pTable,
        SemEntry   *entry,
        const char *name,
        const char *func,
        const char *file,
        int         line
        )
    {
        SemEntry   *sentry;
        SemEntry    OldEntry;

        ASSERTGDI(pTable->numEntries > 0, "numEntries is invalid");
        ASSERTGDI(entry < pTable->entries + pTable->numEntries, "entry is invalid");

        OldEntry = *entry;

        pTable->numEntries--;

        sentry = &pTable->entries[pTable->numEntries];

        if (entry != sentry)
        {
            DbgPrint("Locks released out of acquisition order\n");
            DbgPrint("  Now releasing order %4d %s (%X) in %s @ %s:%d\n",
                     entry->order, name, entry->hsem, func, file, line);

            while (entry < sentry)
            {
                *entry = *(entry + 1);
#if SEM_HISTORY_LENGTH
                DbgPrint("  Warning: Still holding order %4d %s (%X) %u times\n"
                         "   First acquired in %s @ %s:%d\n",
                         entry->order,
                         entry->Acquired[0].name,
                         entry->hsem,
                         entry->count,
                         entry->Acquired[0].func,
                         entry->Acquired[0].file,
                         entry->Acquired[0].line
                         );
#else
                DbgPrint("  Warning: Still holding order %4d %s (%X) %u times\n",
                         entry->order, entry->hsem, entry->count
                         );

#endif
                if (OldEntry.hsem == entry->parent)
                {
                    DbgPrint("   * Error: Releasing parent before child.\n");
                }
                else if (OldEntry.parent == entry->parent && OldEntry.order < entry->order)
                {
                    DbgPrint("   * Error: Higher order semaphore is still held.\n");
                }
                entry++;
            }

            if (gDebugSemBreak)
            {
                DbgBreakPoint();
            }
        }

        if (pTable->flags & ST_SAVE_RELEASES)
        {
            // Maintain a history of released locks
            // 
            sentry = &pTable->entries[kMaxSemEntries-1];

            while(entry < sentry)
            {
                *entry = *(entry + 1);
                entry++;
            }

            *sentry = OldEntry;
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphoreAndValidate                                           *
    *                                                                          *
    *  Call via GreAcquireSemaphoreEx with VALIDATE_LOCKS enabled.             *
    \**************************************************************************/

    VOID 
    GreAcquireSemaphoreAndValidate(
        HSEMAPHORE  hsem,
        ULONG       order,
        HSEMAPHORE  parent,
        const char *name,
        const char *func,
        const char *file,
        int         line
        ) 
    {
        GDIFunctionID(GreAcquireSemaphoreAndValidate);

        GreAcquireSemaphore(hsem);
    
        if(gDebugSem)
        {
            PW32THREAD pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable *pSemTable = (SemTable *) pThread->pSemTable;
        
                if(pSemTable == NULL)
                {
                    pThread->pSemTable = PALLOCMEM(sizeof(SemTable), 'dtdG');

                    pSemTable = (SemTable *) pThread->pSemTable;

                    if(pSemTable != NULL)
                    {
                        pThread->pSemTable = (PVOID)pSemTable;
                        pSemTable->flags = ST_DEFAULT;
                        pSemTable->numEntries = 0;
                    }
                }
        
                if(pSemTable != NULL)
                {
                    SemEntry *pSemEntry = FindSemEntry(pSemTable, hsem);
        
                    if(pSemEntry != NULL)
                    {
                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            DbgPrint("SemTrace: Reacquire (%d) order %4d %24s (%X) in %s @ %s:%d\n",
                                     pSemEntry->count, order, name, hsem, func, file, line);
                        }

                        if (order != pSemEntry->order)
                        {
                            DbgPrint("* Different order specification (%d) for %24s (%X) in %s @ %s:%d\n"
                                     "  Originally acquired with order %d as %s in %s @ %s:%d (%d acquisitions)\n",
                                     order, name, hsem, func, file, line,
                                     pSemEntry->order,
                                     pSemEntry->Acquired[0].name,
                                     pSemEntry->Acquired[0].func,
                                     pSemEntry->Acquired[0].file,
                                     pSemEntry->Acquired[0].line,
                                     pSemEntry->count
                                     );
                        }

#if SEM_HISTORY_LENGTH > 1
                        if (pSemEntry->count < SEM_HISTORY_LENGTH)
                        {
                            pSemEntry->Acquired[pSemEntry->count].name = name;
                            pSemEntry->Acquired[pSemEntry->count].func = func;
                            pSemEntry->Acquired[pSemEntry->count].file = file;
                            pSemEntry->Acquired[pSemEntry->count].line = line;
                        }
#endif
                        pSemEntry->count++;
                    }
                    else
                    {
                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            DbgPrint("SemTrace: Now acquiring order %4d %24s (%X) in %s @ %s:%d\n",
                                     order, name, hsem, func, file, line);
                        }

                        ASSERTGDI(pSemTable->numEntries < kMaxSemEntries, "too many entries");
        
                        pSemEntry = &pSemTable->entries[pSemTable->numEntries++];
                        pSemEntry->hsem = hsem;
                        pSemEntry->order = order;
                        pSemEntry->parent = parent;
                        pSemEntry->count = 1;
#if SEM_HISTORY_LENGTH
                        pSemEntry->Acquired[0].name = name;
                        pSemEntry->Acquired[0].func = func;
                        pSemEntry->Acquired[0].file = file;
                        pSemEntry->Acquired[0].line = line;
#endif
        
                        // Check order

                        if(parent != NULL)
                        {
                            if(FindSemEntry(pSemTable, parent) == NULL)
                            {
                                DbgPrint("Parent semaphore not acquired");
                                if (gDebugSemBreak)
                                {
                                    DbgBreakPoint();
                                }
                            }
                        }

                        SemEntry *  entry = pSemTable->entries;
                        SemEntry *  sentry = entry + pSemTable->numEntries;

                        BOOL    Misordered = FALSE;

                        while(entry < sentry)
                        {
                            if(entry->parent == parent && entry->order > order)
                            {
                                if (!Misordered)
                                {
                                    DbgPrint("Locks obtained out of order\n");
                                    if (!(pSemTable->flags & ST_VERBOSE))
                                    {
                                        DbgPrint("  Now acqquiring order %4d %24s (%X) in %s @ %s:%d\n",
                                                 order, name, hsem, func, file, line);
                                    }
                                    Misordered = TRUE;
                                }
#if SEM_HISTORY_LENGTH
                                DbgPrint("  Conflicts with order %4d %24s (%X) first acquired in %s @ %s:%d with %d acquisitions\n",
                                         entry->order,
                                         entry->Acquired[0].name,
                                         entry->hsem,
                                         entry->Acquired[0].func,
                                         entry->Acquired[0].file,
                                         entry->Acquired[0].line,
                                         entry->count
                                         );
#else
                                DbgPrint("  Conflicts with order %4d (%X)\n",
                                         entry->order, entry->hsem
                                         );
#endif
                            }
                            entry++;
                        }

                        if (Misordered && gDebugSemBreak)
                        {
                            DbgBreakPoint();
                        }
                    }
                }
            }
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphoreAndValidate                                           *
    *                                                                          *
    *  Call via GreReleaseSemaphoreEx with VALIDATE_LOCKS enabled.             *
    \**************************************************************************/

    VOID
    GreReleaseSemaphoreAndValidate(
        HSEMAPHORE hsem,
        const char *name,
        const char *func,
        const char *file,
        int         line
        )
    {
        GDIFunctionID(GreReleaseSemaphoreAndValidate);

        if(gDebugSem)
        {
            PW32THREAD pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable * pSemTable = (SemTable *) pThread->pSemTable;

                if(pSemTable != NULL)
                {
                    SemEntry * pSemEntry = FindSemEntry(pSemTable, hsem);

                    ASSERTGDI(pSemEntry != NULL, "error finding sem");

                    if(pSemEntry != NULL)
                    {
                        pSemEntry->count--;

                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            if (pSemEntry->count)
                            {
                                DbgPrint("TraceSem: Releasing (%d) order %4d %24s (%X) in %s @ %s:%d\n",
                                         pSemEntry->count, pSemEntry->order, name, hsem, func, file, line);
                            }
                            else
                            {
                                DbgPrint("TraceSem: Fully release order %4d %24s (%X) in %s @ %s:%d\n",
                                         pSemEntry->order, name, hsem, func, file, line);
                            }
                        }

#if SEM_HISTORY_LENGTH > 1
                        if (pSemTable->flags & ST_SAVE_RELEASES)
                        {
                            // Maintain a history of releases
                            //
                            SemHistory *entry = &pSemEntry->Acquired[pSemEntry->count];
                            SemHistory *sentry = &pSemEntry->Acquired[SEM_HISTORY_LENGTH-1];

                            SemHistory  OldAcquisition = *entry;

                            while(entry < sentry)
                            {
                                *entry = *(entry + 1);
                                entry++;
                            }

                            *sentry = OldAcquisition;
                        }
#endif

                        if(pSemEntry->count == 0)
                        {
                            RemoveSemEntry(pSemTable, pSemEntry, name, func, file, line);
                        }
                    }
                }
            }
        }

        GreReleaseSemaphore(hsem);
    }
#endif

    
    /******************************Public*Routine******************************\
    * GreAcquireSemaphore                                                      *
    \**************************************************************************/

    VOID 
    FASTCALL GreAcquireSemaphore(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            KeEnterCriticalRegion();
            ExAcquireResourceExclusiveLite((PERESOURCE) hsem, TRUE);
        }
        else
        {
#if defined(DBG)
            if (G_fConsole)
            {
                RIP("Tried to acquire a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to acquire a non-existant or deleted semaphore\n");
            }
#endif
        }
    }


    /******************************Public*Routine******************************\
    * GreAcquireSemaphoreShared                                                *
    \**************************************************************************/

    VOID
    FASTCALL GreAcquireSemaphoreShared(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            KeEnterCriticalRegion();
            ExAcquireResourceSharedLite((PERESOURCE) hsem, TRUE);
        }
        else
        {
#if defined(DBG)
            if (G_fConsole)
            {
                RIP("Tried to acquire a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to acquire a non-existant or deleted semaphore\n");
            }
#endif
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphore                                                      *
    \**************************************************************************/
    VOID
    FASTCALL GreReleaseSemaphore(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            ExReleaseResourceLite((PERESOURCE) hsem);
            KeLeaveCriticalRegion();
        }
        else
        {
#if defined(DBG)
            if (G_fConsole)
            {
                RIP("Tried to release a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to release a non-existant or deleted semaphore\n");
            }
#endif
        }
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwned                                                      *
    *                                                                          *
    * Returns TRUE if the semaphore is currently held.                         *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwned(
        HSEMAPHORE hsem
        )
    {
        return ((PERESOURCE) hsem)->ActiveCount != 0;
    }


    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwnedByCurrentThread                                       *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwnedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ((PERESOURCE) hsem)->OwnerThreads[0].OwnerThread ==
               (ERESOURCE_THREAD) PsGetCurrentThread();
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreSharedByCurrentThread                                      *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreSharedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ExIsResourceAcquiredSharedLite((PERESOURCE) hsem);
    }

    /******************************Public*Routine******************************\
    * GreCreateFastMutex                                                       *
    *                                                                          *
    * Creates a fast mutex. Exactly like a semaphore, except it is not         *
    * reentrant. Fast mutexes are not tracked either (since they do not need   *
    * to be destroyed by the kernel.) Their pool may be tracked.               *
    *                                                                          *
    \**************************************************************************/
    HFASTMUTEX
    GreCreateFastMutex()
    {
        PFAST_MUTEX pfm;
        pfm = (PFAST_MUTEX) GdiAllocPoolNonPagedNS(sizeof(FAST_MUTEX),
                                                    'msfG');

        if (pfm)
        {
            ExInitializeFastMutex(pfm);
        }

        return (HFASTMUTEX) pfm;
    }

    /******************************Public*Routine******************************\
    * GreDeleteFastMutex                                                       *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreDeleteFastMutex(
        HFASTMUTEX hfm
        )
    {
        if (hfm) {
            GdiFreePool(hfm);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreAcquireFastMutex(
        HFASTMUTEX hfm
        )
    {
        KeEnterCriticalRegion();
        ExAcquireFastMutex((PFAST_MUTEX) hfm);
    }

    /******************************Public*Routine******************************\
    * GreReleaseFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/

    VOID
    GreReleaseFastMutex(
        HFASTMUTEX hfm
        )
    {
        ExReleaseFastMutex((PFAST_MUTEX) hfm);
        KeLeaveCriticalRegion();
    }

#else // _GDIPLUS_
// User-mode version

    /******************************Public*Routine******************************\
    * GreCreateSemaphore
    *
    * Create a semaphore with tracking.
    *
    * For use by GDI internal code. Tracking
    * allows semaphores to be released during MultiUserNtGreCleanup
    * cleanup.
    *
    * Warning! For code dealing with pool/semaphore tracking, as
    *   in pooltrk.cxx and muclean.cxx, do not create semaphores with
    *   this function, as it may call functions which use those semaphores. Instead,
    *   use GreCreateSemaphoreNonTracked and GreDeleteSemaphoreNonTracked.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphore()
    {
	return GreCreateSemaphoreInternal(OBJ_ENGINE_CREATED);
    }

    HSEMAPHORE
    GreCreateSemaphoreInternal(ULONG CreateFlags)
    {
        LPCRITICAL_SECTION pcs;
        SIZE_T cj = sizeof(CRITICAL_SECTION);

        //
        // Adjust size to include ENGTRACKHDR header.
        //
>>  
        cj += sizeof(ENGTRACKHDR);
    
        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(), 
                                                   0, 
==                                                 sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Adjust semaphore to exclude the ENGTRACKHDR.
            //
            //                 Buffer
            //   pethNew --> +------------------+
            //               | ENGTRACKHDR      |
            //       pcs --> +------------------+
            //               | CRITICAL_SECTION |
            //               |                  |
            //               +------------------+
            //
            // Note that pethNew always points to base of allocation.
            //

            ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pcs;
>>  
            pcs = (LPCRITICAL_SECTION) (pethNew + 1);
    
==          //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);

            //
            // Track the semaphore
            //
>>  
	    if (CreateFlags & OBJ_DRIVER_CREATED) {
		MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_DRIVER_SEMAPHORE);
	    } else {
		MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_SEMAPHORE);
	    }
==	}

        return (HSEMAPHORE) pcs;

    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphore
    *
    * Deletes the given semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphore(
        HSEMAPHORE hsem
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

        if (pcs)
        {
            ENGTRACKHDR *pethVictim = (ENGTRACKHDR *) pcs;

            //
            // Need to adjust peth pointer to header.
            //
            // Note: whether Hydra or non-Hydra, pethVictim will always
            // point to the base of the allocation.
            //
>>  
            //
            // Remove victim from tracking list.
            //
    
            pethVictim -= 1;
            MultiUserGreTrackRemoveEngResource(pethVictim);

==          DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pethVictim);
        }
    }

    /******************************Public*Routine******************************\
    * GreCreateSemaphoreNonTracked
    *
    * Create a semaphore, without pool-tracking or semaphore-tracking.
    *
    * Only for use by the pool-tracking and semaphore-tracking code. This
    * avoids the circular dependency which using GreCreateSemaphore would
    * cause.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphoreNonTracked()
    {
        LPCRITICAL_SECTION pcs;

        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(),
                                                   0,
                                                   sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);
        }

        return (HSEMAPHORE) pcs;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphoreNonTracked
    *
    * Deletes the given non-tracked semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphoreNonTracked(
        HSEMAPHORE hsem
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

        if (pcs)
        {
            DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pcs);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireSemaphore                                                      *
    \**************************************************************************/
    VOID
    GreAcquireSemaphore(
        HSEMAPHORE hsem
        )
    {
        EnterCriticalSection((LPCRITICAL_SECTION) hsem);
    }

    /******************************Public*Routine******************************\
    * GreReleaseSemaphore                                                      *
    \**************************************************************************/
    VOID
    GreReleaseSemaphore(
        HSEMAPHORE hsem
        )
    {
        LeaveCriticalSection((LPCRITICAL_SECTION) hsem);
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwned                                                      *
    *                                                                          *
    * Returns TRUE if the semaphore is currently held.                         *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwned(
        HSEMAPHORE hsem
        )
    {
        return ((RTL_CRITICAL_SECTION *) hsem)->LockCount != -1;
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwnedByCurrentThread                                       *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwnedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ((RTL_CRITICAL_SECTION *) hsem)->OwningThread ==
               (HANDLE) GetCurrentThreadId();
    }

    /******************************Public*Routine******************************\
    * GreCreateFastMutex                                                       *
    *                                                                          *
    * Creates a fast mutex. In this, the user mode version, it is exactly      *
    * the same as a non-tracked semaphore.
    *                                                                          *
    \**************************************************************************/
    HFASTMUTEX
    GreCreateFastMutex()
    {
        LPCRITICAL_SECTION pcs;

        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(),
                                                   0,
                                                   sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);
        }

        return (HFASTMUTEX) pcs;
    }

    /******************************Public*Routine******************************\
    * GreDeleteFastMutex                                                       *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreDeleteFastMutex(
        HFASTMUTEX hfm
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hfm;

        if (pcs)
        {
            DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pcs);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreAcquireFastMutex(
        HFASTMUTEX hfm
        )
    {
        EnterCriticalSection((LPCRITICAL_SECTION) hfm);
    }

    /******************************Public*Routine******************************\
    * GreReleaseFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/

    VOID
    GreReleaseFastMutex(
        HFASTMUTEX hfm
        )
    {
        LeaveCriticalSection((LPCRITICAL_SECTION) hfm);
    }

#endif // _GDIPLUS_

/******************************Public*Routines*****************************\
* GreAcquireHmgrSemaphore                                                  *
* GreReleaseHmgrSemaphore                                                  *
*                                                                          *
* Convenience functions for the handle manager semaphore.                  *
*                                                                          *
\**************************************************************************/
VOID
GreAcquireHmgrSemaphore()
{
    GDIFunctionID(GreAcquireHmgrSemaphore);

    GreAcquireSemaphoreEx(ghsemHmgr, SEMORDER_HMGR, NULL);
}

VOID
GreReleaseHmgrSemaphore()
{
    GDIFunctionID(GreReleaseHmgrSemaphore);

    GreReleaseSemaphoreEx(ghsemHmgr);
}

/******************************Public*Routine******************************\
* EngCreateSemaphore()
*
* History:
*  22-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HSEMAPHORE
EngCreateSemaphore(
    VOID
    )
{
    return GreCreateSemaphoreInternal(OBJ_DRIVER_CREATED);
}

VOID
EngAcquireSemaphore(
    HSEMAPHORE hsem
    )
{
    GreAcquireSemaphore(hsem);

    W32THREAD * pThread = W32GetCurrentThread();

    if(pThread != NULL)
    {
        pThread->dwEngAcquireCount++;
    }
}


VOID
EngReleaseSemaphore(
    HSEMAPHORE hsem
    )
{
    W32THREAD * pThread = W32GetCurrentThread();

    if(pThread != NULL)
    {
        pThread->dwEngAcquireCount--;
    }
    
    GreReleaseSemaphore(hsem);
}

#if CHECK_SEMAPHORE_USAGE
VOID
GreCheckSemaphoreUsage(
    VOID
    )
{
    W32THREAD * pThread = W32GetCurrentThread();

    if(pThread != NULL)
    {
        if(pThread->dwEngAcquireCount != 0)
        {
            DbgPrint("GreCheckSemaphoreUsage(): EngAcquireCount non-zero\n");
            DbgBreakPoint();
        }
    }
    
}
#endif

VOID
EngDeleteSemaphore(
    HSEMAPHORE hsem
    )
{
    GreDeleteSemaphore(hsem);
}

BOOL
EngIsSemaphoreOwned(
    HSEMAPHORE hsem
    )
{
    return(GreIsSemaphoreOwned(hsem));
}

BOOL
EngIsSemaphoreOwnedByCurrentThread(
    HSEMAPHORE hsem
    )
{
    return(GreIsSemaphoreOwnedByCurrentThread(hsem));
}

/******************************Public*Routine******************************\
*
* EngInitializeSafeSemaphore
* EngDeleteSafeSemaphore
*
* Manages semaphore lifetime in a reference-counted thread-safe manner.
*
* History:
*  Wed Apr 16 18:23:40 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL
EngInitializeSafeSemaphore(ENGSAFESEMAPHORE *pssem)
{
    // Do create/destroy inside the handle manager global lock
    // as a convenient way to synchronize them.
    MLOCKFAST mlf;

    ASSERTGDI(pssem->lCount >= 0, "InitSafeSem: bad lCount\n");

    if (pssem->lCount == 0)
    {
        ASSERTGDI(pssem->hsem == NULL, "InitSafeSem: overwriting hsem\n");

	pssem->hsem = GreCreateSemaphoreInternal(OBJ_DRIVER_CREATED);
        if (pssem->hsem == NULL)
        {
            return FALSE;
        }
    }

    pssem->lCount++;

    return TRUE;
}

void
EngDeleteSafeSemaphore(ENGSAFESEMAPHORE *pssem)
{
    // Do create/destroy inside the handle manager global lock
    // as a convenient way to synchronize them.
    MLOCKFAST mlf;

    ASSERTGDI(pssem->lCount >= 1, "DeleteSafeSem: lCount underflow\n");

    if (pssem->lCount == 1)
    {
        ASSERTGDI(pssem->hsem != NULL, "DeleteSafeSem: No hsem\n");

        GreDeleteSemaphore(pssem->hsem);
        pssem->hsem = NULL;
    }

    pssem->lCount--;
}

/******************************Public*Routine******************************\
* EngSetLastError
*
* Saves Error code passed in.
*
* History:
*  Sat 31-Oct-1992 -by- Patrick Haluptzok [patrickh]
* Remove wrapper.
*
*  28-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  EngSetLastError(ULONG iError)
{
    //
    // Warning: NtCurrentTeb() accesses the TEB structure via the
    // KPCR structure. However, during session shutdown, the
    // TEB ptr is set to zero in the TCB, but not the KPCR.  So if
    // code is callable during session shutdown, cannot invoke
    // NtCurrentTeb.  Use KeGetCurrentThread()->Teb instead.
    //

    PTEB pteb = (PTEB) PsGetCurrentThreadTeb();

    if (pteb)
        pteb->LastErrorValue = iError;

#if DBG
    PSZ psz;

    switch (iError)
    {
    case ERROR_INVALID_HANDLE:
        psz = "ERROR_INVALID_HANDLE";
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        psz = "ERROR_NOT_ENOUGH_MEMORY";
        break;

    case ERROR_INVALID_PARAMETER:
        psz = "ERROR_INVALID_PARAMETER";
        break;

    case ERROR_BUSY:
        psz = "ERROR_BUSY";
        break;

    case ERROR_ARITHMETIC_OVERFLOW:
        psz = "ERROR_ARITHMETIC_OVERFLOW";
        break;

    case ERROR_INVALID_FLAGS:
        psz = "ERROR_INVALID_FLAGS";
        break;

    case ERROR_CAN_NOT_COMPLETE:
        psz = "ERROR_CAN_NOT_COMPLETE";
        break;

    default:
        psz = "unknown error code";
        break;
    }

    // DbgPrint("GRE Err: %s = 0x%04X\n", psz, (USHORT) iError);
#endif
}

/******************************Public*Routine******************************\
*
* History:
*  27-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY EngGetLastError()
{
    ULONG ulError = 0;

    //
    // Warning: NtCurrentTeb() accesses the TEB structure via the
    // KPCR structure. However, during session shutdown, the
    // TEB ptr is set to zero in the TCB, but not the KPCR.  So if
    // code is callable during session shutdown, cannot invoke
    // NtCurrentTeb.  Use KeGetCurrentThread()->Teb instead.
    //

    PTEB pteb = (PTEB) PsGetCurrentThreadTeb();

    if (pteb)
        ulError = pteb->LastErrorValue;

    return(ulError);
}

/******************************Public*Routine******************************\
* GreLockDisplay()
*
* History:
*  01-Nov-1994 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreLockDisplay(
    HDEV hdev
    )
{
    GDIFunctionID(GreLockDisplay);

    PDEVOBJ pdo(hdev);

    GreAcquireSemaphoreEx(pdo.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(pdo.ppdev, WD_DEVLOCK);
}

/******************************Public*Routine******************************\
* GreUnlockDisplay()
*
* History:
*  01-Nov-1994 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreUnlockDisplay(
    HDEV hdev
    )
{
    GDIFunctionID(GreUnlockDisplay);

    PDEVOBJ pdo(hdev);

    GreExitMonitoredSection(pdo.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(pdo.hsemDevLock());
}

#if DBG
/******************************Public*Routine******************************\
* GreIsDisplayLocked()
*
* History:
*  10-Jun-1998 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
GreIsDisplayLocked(
    HDEV hdev
    )
{
    PDEVOBJ pdo(hdev);
    if (GreIsSemaphoreOwnedByCurrentThread(pdo.hsemDevLock()))
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }

}
#endif


/***************************************************************************\
* EngDebugPrint
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\***************************************************************************/

VOID
EngDebugPrint(
    PCHAR StandardPrefix,
    PCHAR DebugMessage,
    va_list ap
    )
{
    char buffer[256];
    int  len;

    //
    // We prepend the STANDARD_DEBUG_PREFIX to each string, and
    // append a new-line character to the end:
    //

    DbgPrint(StandardPrefix);

    vsprintf(buffer, DebugMessage, ap);
    DbgPrint(buffer);

}


/******************************Public*Routine******************************\
* EngDebugBreak()
*
* History:
*  16-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngDebugBreak(
    VOID
    )
{
    DbgBreakPoint();
}


/******************************Public*Routine******************************\
* EngAllocMem()
*
* History:
*  27-May-1995 -by-  Tom Zakrajsek [tomzak]
* Added a flags parameter to allow zeroing of memory.
*
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocMem(
    ULONG fl,
    ULONG cj,
    ULONG tag
    )
{
    PVOID pvRet;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    //
    // Adjust size to include ENGTRACKHDR header.
    //
    // Sundown note: sizeof(ENGTRACKHDR) will fit in 32-bit, so ULONG cast OK
    //

    if (cj <= (MAXULONG - sizeof(ENGTRACKHDR)))
        cj += ((ULONG) sizeof(ENGTRACKHDR));
    else
        return(NULL);

    if (cj >= (PAGE_SIZE * 10000))
    {
        WARNING("EngAllocMem: temp buffer >= 10000 pages");
        return(NULL);
    }

    if (fl & FL_NONPAGED_MEMORY)
    {
        pvRet = GdiAllocPoolNonPaged(cj,tag);
    }
    else
    {
        pvRet = GdiAllocPool(cj,tag); 
    }

    if (fl & FL_ZERO_MEMORY) 
    {
        if (pvRet)
        {
            RtlZeroMemory(pvRet,cj);
        }
    }

    if (pvRet)
    {
        //
        // Add allocation to the tracking list.
        //

        ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pvRet;
        MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_ALLOCMEM);

        //
        // Adjust return pointer to hide the LIST_ENTRY header.
        //

        pvRet = (PVOID) (pethNew + 1);
    }

    return pvRet;
}


/******************************Public*Routine******************************\
* EngFreeMem()
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
EngFreeMem(
    PVOID pv
    )
{
    if (pv)
    {
        //
        // Remove victim from tracking list.
        //

        ENGTRACKHDR *pethVictim = ((ENGTRACKHDR *) pv) - 1;
        MultiUserGreTrackRemoveEngResource(pethVictim);

        //
        // Adjust pointer to base of allocation.
        //

        pv = (PVOID) pethVictim;

        VFREEMEM(pv);
    }

    return;
}

/******************************Public*Routine******************************\
* EngProbeForRead()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
EngProbeForRead(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    )
{
    ProbeForRead(Address, Length, Alignment);
}

/******************************Public*Routine******************************\
* EngAllocUserMem()
*
*   This routine allocates a piece of memory for USER mode and locks it
*   down.  A driver must be very careful with this memory as it is only
*   valid for this process.
*
* History:
*  10-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocUserMem(
    SIZE_T cj,  //ZwAllocateVirtualMemory uses SIZE_T, change accordingly
    ULONG tag
    )
{
    NTSTATUS status;
    PVOID    pv = NULL;
    HANDLE   hSecure;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    //
    // Add two dwords so we have space to store the hSecure and tag.
    //

    cj += sizeof(ULONG_PTR) * 4;

    status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    0,
                    &cj,
                    MEM_COMMIT | MEM_RESERVE,
                    PAGE_READWRITE);

    if (NT_SUCCESS(status))
    {
        hSecure = MmSecureVirtualMemory(pv,cj,PAGE_READWRITE);

        if (hSecure)
        {
            ((PULONG_PTR)pv)[0] = 'xIDG';
            ((PULONG_PTR)pv)[1] = cj;
            ((PULONG_PTR)pv)[2] = tag;
            ((PULONG_PTR)pv)[3] = (ULONG_PTR)hSecure;
            pv = (PBYTE)pv + sizeof(ULONG_PTR)*4;
        }
        else
        {
            ZwFreeVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    &cj,
                    MEM_RELEASE);
            pv = NULL;
        }
    }

    return(pv);
}

/******************************Public*Routize******************************\
* EngSecureMem()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
EngSecureMem(
    PVOID Address,
    ULONG Length
    )
{
    return (MmSecureVirtualMemory(Address, Length, PAGE_READWRITE));
}

/******************************Public*Routine******************************\
* EngUnsecureMem()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*
* Note:  Forwarder only - no code needed
\**************************************************************************/


/******************************Public*Routine******************************\
* EngFreeUserMem()
*
* History:
*  10-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID
EngFreeUserMem(
    PVOID pv
    )
{
    if (pv)
    {
        pv = (PBYTE)pv - sizeof(ULONG_PTR)*4;

        if (((PULONG)pv)[0] == 'xIDG') // GDIx
        {
            ULONG_PTR cj   = ((PULONG_PTR)pv)[1];
            HANDLE hSecure = (HANDLE)((PULONG_PTR)pv)[3];

            MmUnsecureVirtualMemory(hSecure);

            ZwFreeVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    &cj,
                    MEM_RELEASE);
        }
        else
        {
            RIP("EngFreeUserMem passed bad pointer\n");
        }
    }

    return;
}

/******************************Public*Routine******************************\
* EngDeviceIoControl()
*
* History:
*  04-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

NTSTATUS
GreDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )

{

    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    IO_STATUS_BLOCK Iosb;
    PIRP pIrp;
    KEVENT event;


    if (hDevice == NULL) {
        return STATUS_INVALID_HANDLE;
    }

    if ( (nInBufferSize >= (PAGE_SIZE * 10000) ) ||
         (nOutBufferSize >= (PAGE_SIZE * 10000)) ||
         ((nInBufferSize + nOutBufferSize) >= (PAGE_SIZE * 10000))) {
        WARNING("EngDeviceIoControl is asked to allocate >= 10000 pages");
        return (STATUS_INVALID_PARAMETER);
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
               dwIoControlCode,
               (PDEVICE_OBJECT) hDevice,
               lpInBuffer,
               nInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               FALSE,
               &event,
               &Iosb);

    if (pIrp)
    {
        /*
        * Even though the remote video channel emulates a video port, this
        * code doesn't actually use a HANDLE it just uses a DEVICE_OBJECT.
        * Unfortueately, there's only one of those for the remote video driver
        * and so it's not Multi-Session enabled.  Remember the file
        * object handle and stuff it in the call here.  (This code could
        * be called from any process, but globals are in Session space.)
        */
            PIO_STACK_LOCATION irpSp;

        if ( gProtocolType != PROTOCOL_CONSOLE ) {
            irpSp = IoGetNextIrpStackLocation( pIrp );
            irpSp->FileObject = G_RemoteVideoFileObject;
        }
        
        Status = IoCallDriver((PDEVICE_OBJECT) hDevice,
                              pIrp);

        //
        // If the call is synchronous, the IO is always completed
        // and the Status is the same as the Iosb.Status.
        //

        if (Status == STATUS_PENDING) {

            Status = KeWaitForSingleObject(&event,
                                           UserRequest,
                                           KernelMode,
                                           TRUE,
                                           NULL);

            Status = Iosb.Status;
        }

        *lpBytesReturned = (DWORD)Iosb.Information;
    }

    return (Status);

}


DWORD
EngDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )

{
    DWORD retStatus;
    NTSTATUS Status = GreDeviceIoControl(hDevice,
                                         dwIoControlCode,
                                         lpInBuffer,
                                         nInBufferSize,
                                         lpOutBuffer,
                                         nOutBufferSize,
                                         lpBytesReturned);

    //
    // Do the inverse translation to what the video port does
    // so that we can have the original win32 status codes.
    //
    // Maybe, somehow, we can completely eliminate this double
    // translation - but I don't care for now.  It's just a bit
    // longer on the very odd failiure case
    //

    switch (Status) {

    case STATUS_SUCCESS:
        retStatus = NO_ERROR;
        break;

    case STATUS_NOT_IMPLEMENTED:
        retStatus = ERROR_INVALID_FUNCTION;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        retStatus = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case STATUS_INVALID_PARAMETER:
        retStatus = ERROR_INVALID_PARAMETER;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        retStatus = ERROR_INSUFFICIENT_BUFFER;
        break;

    case STATUS_BUFFER_OVERFLOW:
        retStatus = ERROR_MORE_DATA;
        break;

    case STATUS_PENDING:
        retStatus = ERROR_IO_PENDING;
        break;

    case STATUS_DEVICE_DOES_NOT_EXIST:
        retStatus = ERROR_DEV_NOT_EXIST;
        break;

    default:
        retStatus = Status;
        break;

    }


    return retStatus;
}

VOID
EngMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    )

{

    RtlMultiByteToUnicodeN(UnicodeString,
                           MaxBytesInUnicodeString,
                           BytesInUnicodeString,
                           MultiByteString,
                           BytesInMultiByteString);
}

VOID
EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    RtlUnicodeToMultiByteN( MultiByteString,
                            MaxBytesInMultiByteString,
                            BytesInMultiByteString,
                            UnicodeString,
                            BytesInUnicodeString );
}




/******************************Public*Routine******************************\
* EngQueryPerformanceCounter
*
* Queries the performance counter.
*
* It would have been preferable to use 'KeQueryTickCount,' but has a
* resolution of about 10ms on an x86, which is not sufficient for
* getting an accurate measure of the time between vertical blanks, which
* is typically between 8ms and 17ms.
*
* NOTE: Use this routine sparingly, calling it as infrequently as possible!
*       Calling this routine too frequently can degrade I/O performance
*       for the calling driver and for the system as a whole.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngQueryPerformanceCounter(
    LONGLONG    *pPerformanceCount
    )
{
    LARGE_INTEGER li;

    li = KeQueryPerformanceCounter(NULL);

    *pPerformanceCount = *((LONGLONG*) &li);
}

/******************************Public*Routine******************************\
* EngQueryPerformanceFrequency
*
* Queries the resolution of the performance counter.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngQueryPerformanceFrequency(
    LONGLONG    *pFrequency
    )
{
    KeQueryPerformanceCounter((LARGE_INTEGER*) pFrequency);
}


/******************************Public*Routine******************************\
* EngAllocSectionMem
*
* Allocate mapped memory in session space.
*
* History:
*  23-Oct-2000 -by- Chenyin Zhong [chenyz]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocSectionMem(
    PVOID   *pSectionObject,
    ULONG   fl,
    ULONG   cj,
    ULONG   tag
    )
{
    LARGE_INTEGER   SectionSize;
    PVOID           pMappedBase;
    NTSTATUS        Status;
    HANDLE          hSecure;
    SIZE_T          MemSize = 0;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    SectionSize.LowPart  = cj;
    SectionSize.HighPart = 0;

    Status = MmCreateSection(
                pSectionObject,
                SECTION_ALL_ACCESS,
                (POBJECT_ATTRIBUTES)NULL,
                &SectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                (HANDLE)NULL,
                NULL);

    if (!NT_SUCCESS(Status)) 
    {
        KdPrint(("MmCreateSection fails in EngAllocSectionMem with error code: 0x%x\n", Status));
        return(NULL);
    }
    cj = 0;
    
    pMappedBase = NULL;
    Status = MmMapViewInSessionSpace(*pSectionObject, &pMappedBase, &MemSize);

    if (!NT_SUCCESS(Status)) 
    {
        KdPrint(("MmMapViewInSessionSpace fails in EngAllocSectionMem with error code: 0x%x\n", Status));

        ObDereferenceObject(*pSectionObject);
        pMappedBase = NULL;
        *pSectionObject = NULL;
    }

    cj = (ULONG)MemSize;

    if (fl & FL_ZERO_MEMORY)
    {
        if (pMappedBase)
        {
            RtlZeroMemory(pMappedBase,cj);
        }
    }

    return pMappedBase;
}        


/******************************Public*Routine******************************\
* EngFreeSectionMem()
*
* History:
*  25-Oct-2000 -by-  Chenyin Zhong [chenyz]
* Wrote it.
\**************************************************************************/

VOID
EngFreeSectionMem(
    PVOID SectionObject,
    PVOID pv   
    )
{
    NTSTATUS Status;

    if(pv)
    {
        Status = MmUnmapViewInSessionSpace(pv);
        if (!NT_SUCCESS(Status)) 
        {
            KdPrint(("MmUnmapViewInSessionSpace fails in EngFreeSectionMem with error code: 0x%x\n", Status));
            RIP("MmUnmapViewInSessionSpace failed!");
        }
    }
        
    if(SectionObject)    
    {
        ObDereferenceObject(SectionObject);
    }
   
    return;
}          


/******************************Public*Routine******************************\
* EngMapSection()
*
* History:
*  25-Oct-2000 -by-  Chenyin Zhong [chenyz]
* Wrote it.
\**************************************************************************/


BOOL
EngMapSection(
    PVOID SectionObject,
    BOOL bMap,
    HANDLE ProcessHandle,
    PVOID *pMapBase
    )
{
    NTSTATUS        Status;
    PEPROCESS       Process;
    LARGE_INTEGER   SectionOffset;
    ULONG           AllocationType = 0L;
    SIZE_T          ViewSize = 0;

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;

    Status = ObReferenceObjectByHandle(ProcessHandle,
                                       PROCESS_VM_OPERATION,
                                       NULL,
                                       KernelMode,
                                       (PVOID *)&Process,
                                       NULL);
    if(!NT_SUCCESS(Status)) 
    {
        return FALSE;
    }


    if(bMap)    //Map section memory
    {   
        *pMapBase = NULL;
        Status = MmMapViewOfSection(SectionObject,              // SectionToMap,
                                    Process,                    // process
                                    pMapBase,                   // CapturedBase,
                                    0L,                         // ZeroBits,
                                    0L,                         // CommitSize,
                                    &SectionOffset,             // SectionOffset,
                                    &ViewSize,                  // CapturedViewSize,
                                    ViewShare,                  // InheritDisposition,
                                    AllocationType,             // AllocationType,
                                    PAGE_READWRITE);            // Allow writing on this view

        if(!NT_SUCCESS(Status))
        {
            ObDereferenceObject(Process);
            *pMapBase = NULL;

            KdPrint(("MmMapViewofSection fails in EngMapSection with error code: %u\n", Status));
            return FALSE;
        }
    }
    else        //Unmap section memory
    {
        Status = MmUnmapViewOfSection (Process, *pMapBase);

        if (!NT_SUCCESS(Status)) 
        {
            ObDereferenceObject(Process);
            return FALSE;
        }
    }

    ObDereferenceObject (Process);
    
    return TRUE;
}         



/******************************Public*Routine******************************\
* EngSave/RestoreFloatingPointState
*
* Saves the floating point state so that drivers can do floating point
* operations.  If the state were no preserved and floating point operations
* were used, we would be corrupting the thread's user-mode state!
*
* History:
*  17-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

typedef struct {
    BOOL            bSaved;
    KFLOATING_SAVE  fsFpState;
} FP_STATE_SAVE;

ULONG
APIENTRY
EngSaveFloatingPointState(
    VOID    *pBuffer,
    ULONG    cjBufferSize       // Must be zero initialized
    )
{
    ULONG           ulRet = 0;
    FP_STATE_SAVE*  pFpStateSave;
    KFLOATING_SAVE  fsTestState;

    pFpStateSave = (FP_STATE_SAVE*) pBuffer;

    if ((pFpStateSave == NULL) || (cjBufferSize == 0))
    {
        // Check to see if the processor supports floating point by
        // simply seeing whether or not KeSaveFloatingPointState
        // succeeds:

        if (!NT_SUCCESS(KeSaveFloatingPointState(&fsTestState)))
        {
            // No floating point hardware.

            return(ulRet);
        }

        KeRestoreFloatingPointState(&fsTestState);
        return(sizeof(FP_STATE_SAVE));
    }

    if (cjBufferSize < sizeof(FP_STATE_SAVE))
    {
        KdPrint(("EngSaveFloatingPointState: The driver's buffer is too small.\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");
        return(ulRet);
    }

    if (pFpStateSave->bSaved)
    {
        KdPrint(("EngSaveFloatingPointState: Your driver called save twice in a row.\n"));
        KdPrint(("(Either that or it didn't zero initialize the buffer.)\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");

        // No point in returning failure because at this point they're just
        // plain hosed if they called Save twice in succession.  If however
        // they simply did not zero initialize the buffer, things would still
        // be okay, because KeSaveFloatingPointState itself doesn't need the
        // buffer to be zero initialized.
    }

    ulRet = NT_SUCCESS(KeSaveFloatingPointState(&pFpStateSave->fsFpState));

    pFpStateSave->bSaved = (ulRet != 0);

    return(ulRet);
}

BOOL
APIENTRY
EngRestoreFloatingPointState(
    VOID    *pBuffer
    )
{
    FP_STATE_SAVE*  pFpStateSave;

    pFpStateSave = (FP_STATE_SAVE*) pBuffer;

    if (!pFpStateSave->bSaved)
    {
        KdPrint(("EngRestoreFloatingPointState: Your driver called restore "
                 "twice in a row or called restore without a preceeding "
                 "successful call to save.\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");
        return(FALSE);
    }

    pFpStateSave->bSaved = FALSE;

    return(NT_SUCCESS(KeRestoreFloatingPointState(&pFpStateSave->fsFpState)));
}

/******************************Public*Routine******************************\
*
* EngQuerySystemAttribute
*
* Can be used by a driver to query certain processor or system specific
* capabilities.
*
\**************************************************************************/

BOOL
EngQuerySystemAttribute(
    ENG_SYSTEM_ATTRIBUTE CapNum,
    PDWORD pCapability)
{
    switch (CapNum) {

    case EngProcessorFeature: {

        SYSTEM_PROCESSOR_INFORMATION spi;

        if (NT_SUCCESS(ZwQuerySystemInformation(
                           SystemProcessorInformation,
                           &spi,
                           sizeof(SYSTEM_PROCESSOR_INFORMATION),
                           NULL))) {

            *pCapability = spi.ProcessorFeatureBits;
            return TRUE;
        }

        break;
    }

    case EngNumberOfProcessors: {

        SYSTEM_BASIC_INFORMATION sbi;

        if (NT_SUCCESS(ZwQuerySystemInformation(
                           SystemBasicInformation,
                           &sbi,
                           sizeof(SYSTEM_BASIC_INFORMATION),
                           NULL))) {

            *pCapability = sbi.NumberOfProcessors;
            return TRUE;
        }

        break;
    }

    case EngOptimumAvailableUserMemory:
    case EngOptimumAvailableSystemMemory:

        break;

    default:

        break;
    }

    return FALSE;
}

#if defined(_GDIPLUS_)

VOID
GreQuerySystemTime(
    PLARGE_INTEGER CurrentTime
    )
{
    GetSystemTimeAsFileTime((PFILETIME) CurrentTime);
}

VOID
GreSystemTimeToLocalTime (
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER LocalTime
    )
{
    FileTimeToLocalFileTime((PFILETIME) SystemTime, (PFILETIME) LocalTime);
}

#else // !_GDIPLUS_

VOID
GreQuerySystemTime(
    PLARGE_INTEGER CurrentTime
    )
{
    KeQuerySystemTime(CurrentTime);
}

VOID
GreSystemTimeToLocalTime (
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER LocalTime
    )
{
    ExSystemTimeToLocalTime (SystemTime, LocalTime);
}

#endif // _GDIPLUS_

#ifdef DDI_WATCHDOG

/******************************Public*Routine******************************\
*
* GreCreateWatchdogContext
*
* Creates shared watchdog context. In our case context is a UNICODE_STRING
* driver name.
*
* Return Value:
*
*   A pointer context or NULL.
*
* Note:
*
*   Created context must be in non-paged, non-session kernel memory. 
*
\**************************************************************************/

//
// TODO:
//
// this structure is duplicated here and in watchdog\gdisup.c.  We need
// to find the proper .h file to put it in.
//

typedef struct _WATCHDOG_DPC_CONTEXT
{
    PLDEV *ppldevDrivers;
    HANDLE hDriver;
    UNICODE_STRING DisplayDriverName;
} WATCHDOG_DPC_CONTEXT, *PWATCHDOG_DPC_CONTEXT;

PVOID
GreCreateWatchdogContext(
    PWSTR pwszDriverName,
    HANDLE hDriver,
    PLDEV *ppldevDriverList
    )
{
    PWATCHDOG_DPC_CONTEXT pWatchdogContext;
    ULONG ulLength;
    SIZE_T stSize;

    if (pwszDriverName == NULL) {
	return NULL;
    }

    ulLength = wcslen(pwszDriverName);
    stSize = sizeof(WATCHDOG_DPC_CONTEXT) + ((ulLength + 1) * sizeof(WCHAR));

    //
    // Watchdog context must be allocated from non-paged, non-session kernel memory.
    //

    pWatchdogContext = (PWATCHDOG_DPC_CONTEXT)GdiAllocPoolNonPagedNS(stSize, GDITAG_WATCHDOG);

    if (pWatchdogContext)
    {
	pWatchdogContext->ppldevDrivers = ppldevDriverList;
	pWatchdogContext->hDriver = hDriver;

	//
	// Stuff UNICODE_STRING and driver name into the context attached to watchdog object.
	//

	RtlCopyMemory(pWatchdogContext+1,
		      pwszDriverName,
		      (ulLength + 1) * sizeof(WCHAR));

	RtlInitUnicodeString(&pWatchdogContext->DisplayDriverName,
			     (PCWSTR)(pWatchdogContext+1));
    }

    return pWatchdogContext;
}

/******************************Public*Routine******************************\
*
* GreDeleteWatchdogContext
*
* Deletes shared watchdog context. In our case context is a UNICODE_STRING
* driver name.
*
\**************************************************************************/

VOID
GreDeleteWatchdogContext(
    PVOID pContext
    )
{
    if (pContext)
    {
	GdiFreePool(pContext);
    }
}

/******************************Public*Routine******************************\
*
* GreCreateWatchdogs
*
* Creates an array of WATCHDOG_DATA objects pool, and creates and
* initializes associated DPC and DEFERRED_WATCHDOG objects.
*
* Return Value:
*
*   A pointer the new array or NULL
*
* Note:
*
*   dpcCallback must be in non-pagable, non-session kernel memory.
*   DPC objects must be in non-paged, non-session kernel memory.
*   Watchdog objects must be in non-paged, non-session kernel memory.
*   Deferred context must be in non-paged, non-session kernel memory. 
*
\**************************************************************************/

PWATCHDOG_DATA
GreCreateWatchdogs(
    PDEVICE_OBJECT pDeviceObject,
    ULONG ulNumberOfWatchdogs,
    LONG lPeriod,
    PKDEFERRED_ROUTINE dpcCallback,
    PVOID pvDeferredContext
    )
{
    PWATCHDOG_DATA pWatchdogData;

    pWatchdogData = (PWATCHDOG_DATA)GdiAllocPool(ulNumberOfWatchdogs * sizeof (WATCHDOG_DATA), GDITAG_WATCHDOG);

    if (pWatchdogData)
    {
        ULONG i;

        //
        // Zero out in case we won't be able to create all we need and we'll have to back off.
        //

        RtlZeroMemory(pWatchdogData, ulNumberOfWatchdogs * sizeof (WATCHDOG_DATA));

        for (i = 0; i < ulNumberOfWatchdogs; i++)
        {
            //
            // Allocate DPC object from non-paged, non-session pool.
            //

            pWatchdogData[i].pDpc = (PKDPC)GdiAllocPoolNonPagedNS(sizeof (KDPC), GDITAG_WATCHDOG);

            if (NULL == pWatchdogData[i].pDpc)
            {
                //
                // Allocation failed - delete what we created so far and bail out.
                //

                GreDeleteWatchdogs(pWatchdogData, i);
                pWatchdogData = NULL;
                break;
            }

            //
            // Allocate deferred watchdog object.
            //

            pWatchdogData[i].pWatchdog = WdAllocateDeferredWatchdog(pDeviceObject, WdKernelTime, GDITAG_WATCHDOG);

            if (NULL == pWatchdogData[i].pWatchdog)
            {
                //
                // Allocation failed - delete what we created so far and bail out.
                // Note: We have to free last DPC object here.
                //

                GdiFreePool(pWatchdogData[i].pDpc);
                pWatchdogData[i].pDpc = NULL;

                GreDeleteWatchdogs(pWatchdogData, i);
                pWatchdogData = NULL;
                break;
            }

            //
            // Initialize DPC object and start deferred watch.
            //

            KeInitializeDpc(pWatchdogData[i].pDpc, dpcCallback, pvDeferredContext);
            WdStartDeferredWatch(pWatchdogData[i].pWatchdog, pWatchdogData[i].pDpc, lPeriod);
        }
    }

    return pWatchdogData;
}

/******************************Public*Routine******************************\
*
* GreDeleteWatchdogs
*
* Stops watchdogs and deletes an array of WATCHDOG_DATA objects.
*
\**************************************************************************/

VOID
GreDeleteWatchdogs(
    PWATCHDOG_DATA pWatchdogData,
    ULONG ulNumberOfWatchdogs
    )
{
    if (NULL != pWatchdogData)
    {
        ULONG i;

        for (i = 0; i < ulNumberOfWatchdogs; i++)
        {
            if (NULL != pWatchdogData[i].pWatchdog)
            {
                //
                // Stop and free deferred watchdog.
                //

                WdStopDeferredWatch(pWatchdogData[i].pWatchdog);
                WdFreeDeferredWatchdog(pWatchdogData[i].pWatchdog);
                pWatchdogData[i].pWatchdog = NULL;
            }

            if (NULL != pWatchdogData[i].pDpc)
            {
                //
                // Free pool allocated for DPC object.
                //

                GdiFreePool(pWatchdogData[i].pDpc);
                pWatchdogData[i].pDpc = NULL;
            }
        }

        //
        // Free pool allocated for WatchdogData array.
        //

        GdiFreePool(pWatchdogData);
    }
}

#endif  // DDI_WATCHDOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\ntgdi.c ===
/******************************Module*Header*******************************\
* Module Name: priv.c
*   This file contains stubs for calls made by USERSRVL
*
* Created: 01-Nov-1994 07:45:35
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/


#include "engine.h"
#include "winfont.h"

#include "server.h"
#include "dciddi.h"
#include "limits.h"
#include "drvsup.hxx"

#ifdef DBGEXCEPT
    int bStopExcept = FALSE;
    int bWarnExcept = FALSE;
#endif

#define DWORD_TO_FLOAT(dw)  (*(PFLOAT)(PDWORD)&(dw))
#define DWORD_TO_FLOATL(dw) (*(FLOATL *)(PDWORD)&(dw))

typedef struct {
   ULONG uM11;
   ULONG uM12;
   ULONG uM21;
   ULONG uM22;
   ULONG uDx;
   ULONG uDy;
} ULONGXFORM, *PULONGXFORM;

VOID ProbeAndWriteBuffer(PVOID Dst, PVOID Src, ULONG Length)
{
    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||
       ((ULONG_PTR)Dst + Length > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;
    }

    RtlCopyMemory(Dst, Src, Length);

    return;
}

VOID ProbeAndWriteAlignedBuffer(PVOID Dst, PVOID Src, ULONG Length, ULONG Alignment)
{

    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||
           ((Alignment) == 4) || ((Alignment) == 8) ||
           ((Alignment) == 16));

    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||
        ((ULONG_PTR)Dst + Length > (ULONG_PTR) MM_USER_PROBE_ADDRESS)  ||
        ((((ULONG_PTR)Dst) & (Alignment - 1)) != 0))    {
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;
    }

    RtlCopyMemory(Dst, Src, Length);

    return;
}


/******************************Public*Routine******************************\
* bConvertDwordToFloat
*
*     This routine casts a DWORD to a float, and checks whether the float
*     is valid (on the Alpha).  This is accomplished by doing a floating
*     point operation and catching the exception if one is generated.
*
* Arguments:
*
*     dword   - the float before the cast
*     *floatl - a pointer to a float that will receive the value after the
*               cast
*
* Return Value:
*
*    TRUE for valid floats, FALSE otherwise.
*
* History:
*
*   13-May-1998 -by- Ori Gershony [OriG]
*
\**************************************************************************/

BOOL
bConvertDwordToFloat(
    DWORD   dword,
    FLOATL *floatl
    )
{
    BOOL bRet=TRUE;

    try
    {
        *floatl = DWORD_TO_FLOATL(dword);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* ProbeAndConvertXFORM
*
* This routine probe and copy a user mode xform into kernel mode address,
* At the same time, it checks if the each FLOAT in the XFORM is valid, to prevent
* us to get into a floating point trap on ALPHA. Refer to bConvertDwordToFloat
* for more info.
*
* History:
*  11/24/98 by Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
ProbeAndConvertXFORM(
      XFORML *kpXform,
      XFORML *pXform
      )
{
   BOOL bRet=TRUE;

   try
   {
       ULONGXFORM *pUXform = (ULONGXFORM *)kpXform;
       ProbeForRead(pUXform, sizeof(ULONGXFORM), sizeof(BYTE));

       bRet = (bConvertDwordToFloat (pUXform->uM11, &(pXform->eM11))) &&
              (bConvertDwordToFloat (pUXform->uM12, &(pXform->eM12))) &&
              (bConvertDwordToFloat (pUXform->uM21, &(pXform->eM21))) &&
              (bConvertDwordToFloat (pUXform->uM22, &(pXform->eM22))) &&
              (bConvertDwordToFloat (pUXform->uDx, &(pXform->eDx))) &&
              (bConvertDwordToFloat (pUXform->uDy, &(pXform->eDy)));
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       bRet = FALSE;
   }

   return bRet;
}

/******************************Public*Routine******************************\
*
* NtGdiGetCharacterPlacementW
*
* History:
*  26-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define ALIGN4(X) (((X) + 3) & ~3)

DWORD NtGdiGetCharacterPlacementW(
    HDC              hdc,
    LPWSTR           pwsz,
    int              nCount,
    int              nMaxExtent,
    LPGCP_RESULTSW   pgcpw,
    DWORD            dwFlags
)
{
    DWORD   dwRet = 0;
    BOOL    bOk = TRUE;     // only change is something goes wrong
    LPWSTR  pwszTmp = NULL; // probe for read
    ULONG   cjW = 0;

    ULONG   dpOutString = 0;
    ULONG   dpOrder = 0;
    ULONG   dpDx = 0;
    ULONG   dpCaretPos = 0;
    ULONG   dpClass = 0;
    ULONG   dpGlyphs = 0;
    DWORD   cjWord, cjDword;

    LPGCP_RESULTSW   pgcpwTmp = NULL;
    VOID            *pv       = NULL;

// it is much easier to structure the code if we copy pgcpw locally
// at the beginning.

    GCP_RESULTSW    gcpwLocal;

// valitidy checking

    if ((nCount < 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)) || !pwsz)
    {
        return dwRet;
    }

    if (pgcpw)
    {
        try
        {
        // we are eventually going to want to write to this structure
        // so we will do ProbeForWrite now, which will probe the structure
        // for both writing and reading. Otherwise, at this time
        // ProbeForRead would suffice.

           ProbeForWrite(pgcpw, sizeof(GCP_RESULTSW), sizeof(DWORD));
           gcpwLocal = *pgcpw;

        // take nCount to be the smaller of the nCounts and gcpwLocal.nGlyphs
        // Win 95 does the same thing [bodind]

            if (nCount > (int)gcpwLocal.nGlyphs)
                nCount = (int)gcpwLocal.nGlyphs;

        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(1);
            return dwRet;
        }
    }

// Check for overflow of cjByte, cjWord, and cjDword (cjByte is implicit
// in handling of gcpwLocal.lpClass case below).

    if (nCount > (MAXIMUM_POOL_ALLOC / sizeof(DWORD)))
    {
        return dwRet;
    }

    cjWord  = (DWORD)nCount * sizeof(WCHAR);
    cjDword = (DWORD)nCount * sizeof(DWORD);

// if pgcpw != NULL, pgcpw may contain some input data and it may
// point to some output data.

    if (pgcpw)
    {
        cjW = sizeof(GCP_RESULTSW);

        if (gcpwLocal.lpOutString)
        {
            dpOutString = cjW;
            cjW += ALIGN4(cjWord);

            if (cjW < dpOutString)
                return dwRet;
        }

        if (gcpwLocal.lpOrder)
        {
            dpOrder = cjW;
            cjW += cjDword;

            if (cjW < dpOrder)
                return dwRet;
        }

        if (gcpwLocal.lpDx)
        {
            dpDx = cjW;
            cjW += cjDword;

            if (cjW < dpDx)
                return dwRet;
        }

        if (gcpwLocal.lpCaretPos)
        {
            dpCaretPos = cjW;
            cjW += cjDword;

            if (cjW < dpCaretPos)
                return dwRet;
        }

        if (gcpwLocal.lpClass)
        {
            dpClass = cjW;
            cjW += ALIGN4(sizeof(char) * nCount);

            if (cjW < dpClass)
                return dwRet;
        }

        if (gcpwLocal.lpGlyphs)
        {
            dpGlyphs = cjW;
            cjW += cjWord;

            if (cjW < dpGlyphs)
                return dwRet;
        }
    }

// alloc mem for gcpw and the string

    if (cjW <= (MAXIMUM_POOL_ALLOC - cjWord))
        pv = AllocFreeTmpBuffer(cjW + cjWord);

    if (pv)
    {
        pwszTmp = (WCHAR*)((BYTE*)pv + cjW);

        if (pgcpw)
        {
            pgcpwTmp = (LPGCP_RESULTSW)pv;

            if (gcpwLocal.lpOutString)
                pgcpwTmp->lpOutString = (LPWSTR)((BYTE *)pgcpwTmp + dpOutString);
            else
                pgcpwTmp->lpOutString = NULL;

            if (gcpwLocal.lpOrder)
                pgcpwTmp->lpOrder = (UINT FAR*)((BYTE *)pgcpwTmp + dpOrder);
            else
                pgcpwTmp->lpOrder = NULL;

            if (gcpwLocal.lpDx)
                pgcpwTmp->lpDx = (int FAR *)((BYTE *)pgcpwTmp + dpDx);
            else
                pgcpwTmp->lpDx = NULL;

            if (gcpwLocal.lpCaretPos)
                pgcpwTmp->lpCaretPos = (int FAR *)((BYTE *)pgcpwTmp + dpCaretPos);
            else
                pgcpwTmp->lpCaretPos = NULL;

            if (gcpwLocal.lpClass)
                pgcpwTmp->lpClass = (LPSTR)((BYTE *)pgcpwTmp + dpClass);
            else
                pgcpwTmp->lpClass = NULL;

            if (gcpwLocal.lpGlyphs)
                pgcpwTmp->lpGlyphs = (LPWSTR)((BYTE *)pgcpwTmp + dpGlyphs);
            else
                pgcpwTmp->lpGlyphs = NULL;

            pgcpwTmp->lStructSize = cjW;
            pgcpwTmp->nGlyphs     = nCount;
        }

    // check the memory with input data:

        try
        {
            ProbeAndReadBuffer(pwszTmp, pwsz, cjWord);
            if ((dwFlags & GCP_JUSTIFYIN) && pgcpw && gcpwLocal.lpDx)
            {
            // must probe for read, lpDx contains input explaining which glyphs to
            // use as spacers for in justifying string

                ProbeAndReadBuffer(pgcpwTmp->lpDx,gcpwLocal.lpDx, cjDword);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(2);
            // SetLastError(GetExceptionCode());
            bOk = FALSE;
        }

        if (bOk)
        {
            dwRet = GreGetCharacterPlacementW(hdc, pwszTmp,(DWORD)nCount,
                                              (DWORD)nMaxExtent,
                                              pgcpwTmp, dwFlags);

            if (dwRet && pgcpw) // copy data out
            {
                try
                {
                // ProbeForWrite(pgcpw, sizeof(GCP_RESULTSW), sizeof(DWORD));
                // we did this above, see the comment

                    pgcpw->nMaxFit = pgcpwTmp->nMaxFit;
                    pgcpw->nGlyphs = nCount = pgcpwTmp->nGlyphs;

                    cjWord  = (DWORD)nCount * 2;
                    cjDword = (DWORD)nCount * 4;

                    if (gcpwLocal.lpOutString)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpOutString, pgcpwTmp->lpOutString,
                                      cjWord);
                    }

                    if (gcpwLocal.lpOrder)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpOrder, pgcpwTmp->lpOrder, cjDword);
                    }

                    if (gcpwLocal.lpDx)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpDx, pgcpwTmp->lpDx, cjDword);
                    }

                    if (gcpwLocal.lpCaretPos)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpCaretPos, pgcpwTmp->lpCaretPos,
                                      cjDword);
                    }

                    if (gcpwLocal.lpClass)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpClass, pgcpwTmp->lpClass, nCount);
                    }

                    if (gcpwLocal.lpGlyphs)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpGlyphs, pgcpwTmp->lpGlyphs, cjWord);
                    }

                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(3);
                    // SetLastError(GetExceptionCode());
                    bOk = FALSE;
                }
            }
        }
        FreeTmpBuffer(pv);
    }
    else
    {
        bOk = FALSE;
    }

    return (bOk ? dwRet : 0);
}

/*******************************************************************\
* pbmiConvertInfo                                                  *
*                                                                  *
*  Converts BITMAPCOREHEADER into BITMAPINFOHEADER                 *
*  copies the the color table                                      *
*                                                                  *
* 10-1-95 -by- Lingyun Wang [lingyunw]                             *
\******************************************************************/

LPBITMAPINFO pbmiConvertInfo(CONST BITMAPINFO *pbmi, ULONG iUsage)
{
    LPBITMAPINFO pbmiNew;
    ULONG cjRGB;
    ULONG cColorsMax;
    ULONG cColors;
    UINT  uiBitCount;
    ULONG ulSize;
    RGBTRIPLE *pTri;
    RGBQUAD *pQuad;

    ASSERTGDI (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER), "bad header size\n");

    //
    // convert COREHEADER and copy color table
    //

    cjRGB = sizeof(RGBQUAD);
    uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;

    //
    // figure out the number of entries
    //
    switch (uiBitCount)
    {
    case 1:
        cColorsMax = 2;
        break;
    case 4:
        cColorsMax = 16;
        break;
    case 8:
        cColorsMax = 256;
        break;
    default:

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        cColorsMax = 0;

        switch (uiBitCount)
        {
        case 16:
        case 24:
        case 32:
            break;
        default:
            WARNING("pbmiConvertInfo failed invalid bitcount in bmi BI_RGB\n");
            return(0);
        }
    }

    cColors = cColorsMax;

    if (iUsage == DIB_PAL_COLORS)
        cjRGB = sizeof(USHORT);
    else if (iUsage == DIB_PAL_INDICES)
        cjRGB = 0;

    //
    // convert the core header
    //

    ulSize = sizeof(BITMAPINFOHEADER);

    pbmiNew = PALLOCNOZ(ulSize +
                        cjRGB * cColors,'pmtG');

    if (pbmiNew == NULL)
        return (0);

    pbmiNew->bmiHeader.biSize = ulSize;

    //
    // copy BITMAPCOREHEADER
    //
    pbmiNew->bmiHeader.biWidth = ((BITMAPCOREHEADER *)pbmi)->bcWidth;
    pbmiNew->bmiHeader.biHeight = ((BITMAPCOREHEADER *)pbmi)->bcHeight;
    pbmiNew->bmiHeader.biPlanes = ((BITMAPCOREHEADER *)pbmi)->bcPlanes;
    pbmiNew->bmiHeader.biBitCount = ((BITMAPCOREHEADER *)pbmi)->bcBitCount;
    pbmiNew->bmiHeader.biCompression = 0;
    pbmiNew->bmiHeader.biSizeImage = 0;
    pbmiNew->bmiHeader.biXPelsPerMeter = 0;
    pbmiNew->bmiHeader.biYPelsPerMeter = 0;
    pbmiNew->bmiHeader.biClrUsed = 0;
    pbmiNew->bmiHeader.biClrImportant = 0;

    //
    // copy the color table
    //

    pTri = (RGBTRIPLE *)((LPBYTE)pbmi + sizeof(BITMAPCOREHEADER));
    pQuad = (RGBQUAD *)((LPBYTE)pbmiNew + sizeof(BITMAPINFOHEADER));

    //
    // copy RGBTRIPLE to RGBQUAD
    //
    if (iUsage != DIB_PAL_COLORS)
    {
        INT cj = cColors;

        while (cj--)
        {
            pQuad->rgbRed = pTri->rgbtRed;
            pQuad->rgbGreen = pTri->rgbtGreen;
            pQuad->rgbBlue = pTri->rgbtBlue;
            pQuad->rgbReserved = 0;

            pQuad++;
            pTri++;
        }
    }
    else
    // DIB_PAL_COLORS
    {
        RtlCopyMemory((LPBYTE)pQuad,(LPBYTE)pTri,cColors * sizeof(USHORT));
    }

    return(pbmiNew);
}


LPDEVMODEW
CaptureDEVMODEW(
    LPDEVMODEW pdm
    )

/*++

Routine Description:

    Make a kernel-mode copy of a user-mode DEVMODEW structure

Arguments:

    pdm - Pointer to user mode DEVMODEW structure to be copied

Return Value:

    Pointer to kernel mode copy of DEVMODEW structure
    NULL if there is an error

Note:

    This function must be called inside try/except.

--*/

{
    LPDEVMODEW  pdmKm;
    WORD        dmSize, dmDriverExtra;
    ULONG       ulSize;

    ProbeForRead (pdm, offsetof(DEVMODEW, dmFields), sizeof(BYTE));
    dmSize = pdm->dmSize;
    dmDriverExtra = pdm->dmDriverExtra;
    ulSize = dmSize + dmDriverExtra;

    if ((ulSize <= offsetof(DEVMODEW, dmFields)) || BALLOC_OVERFLOW1(ulSize, BYTE))
    {
        WARNING("bad devmodew size\n");
        return NULL;
    }

    if ((pdmKm = PALLOCNOZ(ulSize, 'pmtG')) != NULL)
    {
        try
        {
            ProbeAndReadBuffer(pdmKm, pdm, ulSize);
            pdmKm->dmSize = dmSize;
            pdmKm->dmDriverExtra = dmDriverExtra;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            VFREEMEM(pdmKm);
            pdmKm = NULL;
        }
    }
    else
    {
        WARNING("Memory allocation failed in CaptureDEVMODEW\n");
    }

    return pdmKm;
}


DRIVER_INFO_2W*
CaptureDriverInfo2W(
    DRIVER_INFO_2W  *pUmDriverInfo2
    )

/*++

Routine Description:

    Make a kernel-mode copy of a user-mode DRIVER_INFO_2W structure

Arguments:

    pUmDriverInfo2 - Pointer to user mode DRIVER_INFO_2W structure

Return Value:

    Pointer to copied kernel mode DRIVER_INFO_2W structure
    NULL if there is an error

Note:

    We're not copying pEnvironment and pConfigFile fields of
    DRIVER_INFO_2W structure.

    This function must be called inside try/except.

--*/

{
    DRIVER_INFO_2W *pKmDriverInfo2;
    ULONG           NameLen, DriverPathLen, DataFileLen, TotalSize;
    PWSTR           pName, pDriverPath, pDataFile;

    ProbeForRead(pUmDriverInfo2, sizeof(DRIVER_INFO_2W), sizeof(BYTE));

    if ((pName = pUmDriverInfo2->pName) == NULL ||
        (pDriverPath = pUmDriverInfo2->pDriverPath) == NULL ||
        (pDataFile = pUmDriverInfo2->pDataFile) == NULL)
    {
        WARNING("Missing driver name or driver path\n");
        return NULL;
    }

    NameLen = wcslensafe(pName);
    DriverPathLen = wcslensafe(pDriverPath);

    TotalSize = sizeof(DRIVER_INFO_2W) +
                (NameLen + 1) * sizeof(WCHAR) +
                (DriverPathLen + 1) * sizeof(WCHAR);

    // pDataFile != NULL
    DataFileLen = wcslensafe(pDataFile);
    TotalSize += (DataFileLen + 1) * sizeof(WCHAR);

    if (BALLOC_OVERFLOW1(TotalSize, BYTE))
        return NULL;

    // Note: allocated memory is zero-initialized.

    pKmDriverInfo2 = (DRIVER_INFO_2W *) PALLOCMEM(TotalSize, 'pmtG');

    if (pKmDriverInfo2 != NULL)
    {
        __try
        {
            RtlCopyMemory(pKmDriverInfo2, pUmDriverInfo2, sizeof(DRIVER_INFO_2W));

            pKmDriverInfo2->pEnvironment =
            pKmDriverInfo2->pConfigFile = NULL;

            pKmDriverInfo2->pName = (PWSTR) ((PBYTE) pKmDriverInfo2 + sizeof(DRIVER_INFO_2W));
            pKmDriverInfo2->pDriverPath = pKmDriverInfo2->pName + (NameLen + 1);

            ProbeAndReadBuffer(pKmDriverInfo2->pName, pName, NameLen * sizeof(WCHAR));
            ProbeAndReadBuffer(pKmDriverInfo2->pDriverPath, pDriverPath, DriverPathLen * sizeof(WCHAR));

            pKmDriverInfo2->pDataFile = pKmDriverInfo2->pDriverPath + (DriverPathLen + 1);
            ProbeAndReadBuffer(pKmDriverInfo2->pDataFile, pDataFile, DataFileLen * sizeof(WCHAR));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            VFREEMEM(pKmDriverInfo2);
            pKmDriverInfo2 = NULL;
        }
    }
    else
    {
        WARNING("Memory allocation failed in CaptureDriverInfo2W\n");
    }

    return pKmDriverInfo2;
}

__inline VOID
vFreeDriverInfo2(
    DRIVER_INFO_2W  *pKmDriverInfo2
    )

{
     if (pKmDriverInfo2 != NULL)
         VFREEMEM(pKmDriverInfo2);
}

/******************************Public*Routine******************************\
* GreGetBitmapSize
*
* Returns the size of the header and the color table.
*
* History:
*  Wed 19-Aug-1992 -by- Patrick Haluptzok [patrickh]
* add 16 and 32 bit support
*
*  Wed 04-Dec-1991 -by- Patrick Haluptzok [patrickh]
* Make it handle DIB_PAL_INDICES.
*
*  Tue 08-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make it handle DIB_PAL_COLORS, calculate max colors based on bpp.
*
*  22-Jul-1991 -by- Eric Kutter [erick]
*  14-Apr-1998 FritzS Convert to Gre function for use by ntuser
* Wrote it.
\**************************************************************************/

ULONG GreGetBitmapSize(CONST BITMAPINFO *pbmi, ULONG iUsage)
{
    ULONG cjRet;
    ULONG cjHeader;
    ULONG cjRGB;
    ULONG cColorsMax;
    ULONG cColors;
    UINT  uiBitCount;
    UINT  uiPalUsed;
    UINT  uiCompression;
    UINT  uiHeaderSize;

    // check for error

    if (pbmi == (LPBITMAPINFO) NULL)
    {
        WARNING("GreGetBitmapSize failed - NULL pbmi\n");
        return(0);
    }

    uiHeaderSize = pbmi->bmiHeader.biSize;

    // Check for PM-style DIB

    if (uiHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        cjHeader = sizeof(BITMAPCOREHEADER);
        cjRGB = sizeof(RGBTRIPLE);
        uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;
        uiPalUsed = 0;
        uiCompression =  (UINT) BI_RGB;
    }
    else if (uiHeaderSize >= sizeof(BITMAPINFOHEADER))
    {
        cjHeader = uiHeaderSize;
        cjRGB    = sizeof(RGBQUAD);
        uiBitCount = pbmi->bmiHeader.biBitCount;
        uiPalUsed = pbmi->bmiHeader.biClrUsed;
        uiCompression = (UINT) pbmi->bmiHeader.biCompression;
    }
    else
    {
        WARNING("cjBitmapHeaderSize failed - invalid header size\n");
        return(0);
    }

    if (uiCompression == BI_BITFIELDS)
    {
        // Handle 16 and 32 bit per pel bitmaps.

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            #if DBG
                DbgPrint("GreGetBitmapSize %lu\n", uiBitCount);
            #endif
            WARNING("GreGetBitmapSize failed for BI_BITFIELDS\n");
            return(0);
        }

        if (uiHeaderSize <= sizeof(BITMAPINFOHEADER))
        {
            uiPalUsed = cColorsMax = 3;
        }
        else
        {
            //
            // masks are imbedded in BITMAPV4 +
            //

            uiPalUsed = cColorsMax = 0;
        }
    }
    else if (uiCompression == BI_RGB)
    {
        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        default:

            if (iUsage == DIB_PAL_COLORS)
            {
                iUsage = DIB_RGB_COLORS;
            }

            cColorsMax = 0;

            switch (uiBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING("GreGetBitmapSize failed invalid bitcount in bmi BI_RGB\n");
                return(0);
            }
        }
    }
    else if (uiCompression == BI_CMYK)
    {
        ASSERTGDI (iUsage == DIB_RGB_COLORS, "BI_CMYK:iUsage should be DIB_RGB_COLORS\n");

        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        case 32:
            cColorsMax = 0;
            break;
        default:
            WARNING("GreGetBitmapSize failed invalid bitcount in bmi BI_CMYK\n");
            return(0);
        }
    }
    else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
    {
        if (uiBitCount != 4)
        {
            return(0);
        }

        cColorsMax = 16;
    }
    else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
    {
        if (uiBitCount != 8)
        {
            return(0);
        }

        cColorsMax = 256;
    }
    else if ((uiCompression == BI_JPEG) || (uiCompression == BI_PNG))
    {
        cColorsMax = 0;
    }
    else
    {
        WARNING("GreGetBitmapSize failed invalid Compression in header\n");
        return(0);
    }

    if (uiPalUsed != 0)
    {
        if (uiPalUsed <= cColorsMax)
            cColors = uiPalUsed;
        else
            cColors = cColorsMax;
    }
    else
        cColors = cColorsMax;

    if (iUsage == DIB_PAL_COLORS)
        cjRGB = sizeof(USHORT);
    else if (iUsage == DIB_PAL_INDICES)
        cjRGB = 0;

    cjRet = ((cjHeader + (cjRGB * cColors)) + 3) & ~3;

    // (cjRGB * cColors) has a maximum of 256*sizeof(USHORT) so it will not
    // overflow, but we need to check the sum.

    if (cjRet < cjHeader)
        return 0;
    else
        return cjRet;

    return(((cjHeader + (cjRGB * cColors)) + 3) & ~3);
}


/******************************Public*Routine******************************\
* noOverflowCJSCAN
*
*   compute the amount of memory used by a bitmap
*
* Arguments:
*
*   ulWidth -- The width of the bitmap
*   wPlanes -- The number of color planes
*   wBitCount -- The number of bits per color
*   ulHeight -- The height of the bitmap
*
* Return Value:
*
*   The storage required (assuming each scanline is DWORD aligned) if less than
*   ULONG_MAX, 0 otherwise.
*
* History:
*
*    27-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/

ULONG
noOverflowCJSCAN(
    ULONG ulWidth,
    WORD  wPlanes,
    WORD  wBitCount,
    ULONG ulHeight
    )
{
    ULONGLONG product;

    //
    // Note that the following cannot overflow: 32+16+16=64
    // (even after adding 31!)
    //
    product = (((ULONGLONG) ulWidth) * wPlanes * wBitCount);
    product = ((product + 31) & ((ULONGLONG) ~31)) / 8;

    if (product > MAXULONG)
    {
        //
        // Already too large, final result will not fit in a ULONG
        //
        return 0;  // Overflow
    }

    product *= ulHeight;

    if (product > MAXULONG)
    {
        return 0;  // Overflow
    }
    else
    {
        return ((ULONG) product);
    }
}


/******************************Public*Routine******************************\
* noOverflowCJSCANW
*
*   compute the amount of memory used by a bitmap
*
* Arguments:
*
*   ulWidth -- The width of the bitmap
*   wPlanes -- The number of color planes
*   wBitCount -- The number of bits per color
*   ulHeight -- The height of the bitmap
*
* Return Value:
*
*   The storage required (assuming each scanline is WORD aligned) if less than
*   ULONG_MAX, 0 otherwise.
*
* History:
*
*    27-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/

ULONG
noOverflowCJSCANW(
    ULONG ulWidth,
    WORD  wPlanes,
    WORD  wBitCount,
    ULONG ulHeight
    )
{
    ULONGLONG product;

    //
    // Note that the following cannot overflow: 32+16+16=64
    // (even after adding 31!)
    //
    product = (((ULONGLONG) ulWidth) * wPlanes * wBitCount);
    product = ((product + 15) & ((ULONGLONG) ~15)) / 8;

    if (product > MAXULONG)
    {
        //
        // Already too large, final result will not fit in a ULONG
        //
        return 0;  // Overflow
    }

    product *= ulHeight;

    if (product > MAXULONG)
    {
        return 0;  // Overflow
    }
    else
    {
        return ((ULONG) product);
    }
}




/******************************Public*Routine******************************\
* GreGetBitmapBitsSize()
*
*   copied from gdi\client
*
* History:
*  20-Feb-1995 -by-  Eric Kutter [erick]
*  14-Apr-1998 FritzS make Gre call for use by ntuser
* Wrote it.
\**************************************************************************/

ULONG GreGetBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
    // Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(noOverflowCJSCAN(pbmci->bmciHeader.bcWidth,
                                pbmci->bmciHeader.bcPlanes,
                                pbmci->bmciHeader.bcBitCount,
                                pbmci->bmciHeader.bcHeight));
    }

    // not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB)  ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK)
        )
    {
        return(noOverflowCJSCAN(pbmi->bmiHeader.biWidth,
                                (WORD) pbmi->bmiHeader.biPlanes,
                                (WORD) pbmi->bmiHeader.biBitCount,
                                ABS(pbmi->bmiHeader.biHeight)));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

/******************************Public*Routine******************************\
* BOOL bCaptureBitmapInfo (LPBITMAPINFO pbmi, INT *pcjHeader)
*
* Capture the Bitmapinfo struct.  The header must be a BITMAPINFOHEADER
* or BITMAPV4HEADER
* converted at the client side already.
*
* Note: this has to be called inside a TRY-EXCEPT.
*
*  23-Mar-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL bCaptureBitmapInfo (
    LPBITMAPINFO pbmi,
    DWORD        dwUsage,
    UINT         cjHeader,
    LPBITMAPINFO *ppbmiTmp)
{
    ASSERTGDI(ppbmiTmp != NULL,"bCaptureBitmapInfo(): pbmiTmp == NULL\n");

    //
    // Make sure we have at least the biSize field of header.
    //

    if ((cjHeader < sizeof(DWORD)) || (pbmi == (LPBITMAPINFO) NULL))
    {
        WARNING("bCaptureBitmapInfo - header too small or NULL\n");
        return FALSE;
    }
    else
    {
        *ppbmiTmp = PALLOCNOZ(cjHeader,'pmtG');

        if (*ppbmiTmp)
        {
            ProbeAndReadBuffer (*ppbmiTmp,pbmi,cjHeader);

            //
            // First, make sure that cjHeader is at least as
            // big as biSize so that the captured header
            // has sufficient data for GreGetBitmapSize to use.
            // Note that the first thing GreGetBitmapSize does is
            // validate biSize, so it isn't necessary for us
            // to check cjHeader against BITMAPCOREHEADER, etc.
            //
            // Next, recompute the header size from the captured
            // header: it better still match.  Otherwise, we have
            // failed to safely capture the entire header (i.e.,
            // another thread changed the data changed during
            // capture or bogus data was passed to the API).
            //

            if (((*ppbmiTmp)->bmiHeader.biSize < sizeof(BITMAPINFOHEADER)) ||
                (cjHeader < (*ppbmiTmp)->bmiHeader.biSize) ||
                (cjHeader != GreGetBitmapSize(*ppbmiTmp, dwUsage)))
            {
                WARNING("bCapturebitmapInfo - bad header size\n");

                VFREEMEM(*ppbmiTmp);
                *ppbmiTmp = NULL;
                return FALSE;
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}

/******************************Public*Routine******************************\
* NtGdiSetDIBitsToDeviceInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  23-Mar-1995 -by-  Lingyun Wang [lingyunw]
* call CaptureBitmapInfo to convert BITMAPCOREINFO if it is so.
\**************************************************************************/

int
APIENTRY
NtGdiSetDIBitsToDeviceInternal(
    HDC          hdcDest,
    int          xDst,
    int          yDst,
    DWORD        cx,
    DWORD        cy,
    int          xSrc,
    int          ySrc,
    DWORD        iStartScan,
    DWORD        cNumScan,
    LPBYTE       pInitBits,
    LPBITMAPINFO pbmi,
    DWORD        iUsage,
    UINT         cjMaxBits,
    UINT         cjMaxInfo,
    BOOL         bTransformCoordinates,
    HANDLE       hcmXform
    )
{
    int   iRet     = 1;
    HANDLE hSecure = 0;
    ULONG cjHeader = cjMaxInfo;
    LPBITMAPINFO pbmiTmp = NULL;

    iUsage &= (DIB_PAL_INDICES | DIB_PAL_COLORS | DIB_RGB_COLORS);

    try
    {
        if (bCaptureBitmapInfo(pbmi,iUsage,cjHeader,&pbmiTmp))
        {
            if (pInitBits)
            {
                //
                // Use cjMaxBits passed in, this size takes cNumScan
                // into account. pInitBits has already been aligned
                // in user mode.
                //

                ProbeForRead(pInitBits,cjMaxBits,sizeof(DWORD));

                hSecure = MmSecureVirtualMemory(pInitBits,cjMaxBits, PAGE_READONLY);

                if (hSecure == 0)
                {
                    iRet = 0;
                }
            }
        }
        else
        {
            iRet = 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(4);
        // SetLastError(GetExceptionCode());

        iRet = 0;
    }

    // if we didn't hit an error above

    if (iRet == 1)
    {
        iRet = GreSetDIBitsToDeviceInternal(
                        hdcDest,
                        xDst,
                        yDst,
                        cx,
                        cy,
                        xSrc,
                        ySrc,
                        iStartScan,
                        cNumScan,
                        pInitBits,
                        pbmiTmp,
                        iUsage,
                        cjMaxBits,
                        cjHeader,
                        bTransformCoordinates,
                        hcmXform
                        );
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    if (pbmiTmp)
        VFREEMEM(pbmiTmp);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiPolyPolyDraw()
*
* History:
*  22-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiFastPolyPolyline(HDC, CONST POINT*, ULONG*, ULONG); // drawgdi.cxx

ULONG_PTR
APIENTRY
NtGdiPolyPolyDraw(
    HDC    hdc,
    PPOINT ppt,
    PULONG pcpt,
    ULONG  ccpt,
    int    iFunc
    )
{
    ULONG  cpt;
    PULONG pulCounts;
    ULONG_PTR ulRet = 1;
    ULONG  ulCount;
    POINT  apt[10];
    PPOINT pptTmp;

    if (ccpt > 0)
    {
        // If a PolyPolyline, first try the fast-path polypolyline code.

        if ((iFunc != I_POLYPOLYLINE) ||
            (!NtGdiFastPolyPolyline(hdc, ppt, pcpt, ccpt)))
        {
            if (ccpt > 1)
            {
                //
                // make sure allocation is within reasonable limits
                //

                if (!BALLOC_OVERFLOW1(ccpt,ULONG))
                {
                    pulCounts = PALLOCNOZ(ccpt * sizeof(ULONG),'pmtG');
                }
                else
                {
                    EngSetLastError(ERROR_INVALID_PARAMETER);
                    pulCounts = NULL;
                }
            }
            else
            {
                pulCounts = &ulCount;
            }

            if (pulCounts)
            {
                pptTmp = apt;

                try
                {
                    UINT i;

                    //
                    // we did make sure ccpt * sizeof(ULONG) will not overflow
                    // in above. then here is safe.
                    //

                    ProbeAndReadBuffer(pulCounts,pcpt,ccpt * sizeof(ULONG));

                    cpt = 0;

                    for (i = 0; i < ccpt; ++i)
                        cpt += pulCounts[i];

                    // we need to make sure that the cpt array won't overflow
                    // a DWORD in terms of number of bytes

                    if (!BALLOC_OVERFLOW1(cpt,POINT))
                    {
                        if (cpt > 10)
                        {
                            pptTmp = AllocFreeTmpBuffer(cpt * sizeof(POINT));
                        }

                        if (pptTmp)
                        {
                            ProbeAndReadBuffer(pptTmp,ppt,cpt*sizeof(POINT));
                        }
                        else
                        {
                            ulRet = 0;
                        }
                    }
                    else
                    {
                        ulRet = 0;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(5);
                    // SetLastError(GetExceptionCode());

                    ulRet = 0;
                }

                if (ulRet != 0)
                {
                    switch(iFunc)
                    {
                    case I_POLYPOLYGON:
                        ulRet =
                          (ULONG_PTR) GrePolyPolygonInternal
                                  (
                                    hdc,
                                    pptTmp,
                                    (LPINT)pulCounts,
                                    ccpt,
                                    cpt
                                  );
                        break;

                    case I_POLYPOLYLINE:
                        ulRet =
                          (ULONG_PTR) GrePolyPolylineInternal
                                  (
                                    hdc,
                                    pptTmp,
                                    pulCounts,
                                    ccpt,
                                    cpt
                                  );
                        break;


                    case I_POLYBEZIER:
                        ulRet =
                          (ULONG_PTR) GrePolyBezier
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYLINETO:
                        ulRet =
                          (ULONG_PTR) GrePolylineTo
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYBEZIERTO:
                        ulRet =
                          (ULONG_PTR) GrePolyBezierTo
                                  (
                                    hdc,
                                    pptTmp,
                                    ulCount
                                  );
                        break;

                    case I_POLYPOLYRGN:
                        ulRet =
                          (ULONG_PTR) GreCreatePolyPolygonRgnInternal
                                  (
                                    pptTmp,
                                    (LPINT)pulCounts,
                                    ccpt,
                                    (INT)(ULONG_PTR)hdc, // the mode
                                    cpt
                                  );
                        break;

                    default:
                        ulRet = 0;
                    }

                }

                if (pptTmp && (pptTmp != apt))
                    FreeTmpBuffer(pptTmp);

                if (pulCounts != &ulCount)
                    VFREEMEM(pulCounts);


            }
            else
            {
                ulRet = 0;
            }
        }
    }
    else
    {
        ulRet = 0;
    }
    return(ulRet);
}


/******************************Public*Routine******************************\
* NtGdiStretchDIBitsInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  04-MAR-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

int
APIENTRY
NtGdiStretchDIBitsInternal(
    HDC          hdc,
    int          xDst,
    int          yDst,
    int          cxDst,
    int          cyDst,
    int          xSrc,
    int          ySrc,
    int          cxSrc,
    int          cySrc,
    LPBYTE       pjInit,
    LPBITMAPINFO pbmi,
    DWORD        dwUsage,
    DWORD        dwRop4,
    UINT         cjMaxInfo,
    UINT         cjMaxBits,
    HANDLE       hcmXform
    )
{
    LPBITMAPINFO pbmiTmp = NULL;
    INT          iRet = 1;
    ULONG        cjHeader = cjMaxInfo;
    ULONG        cjBits   = cjMaxBits;
    HANDLE       hSecure = 0;

    if (pjInit && pbmi && cjHeader)
    {
        try
        {
            if (bCaptureBitmapInfo(pbmi, dwUsage, cjHeader, &pbmiTmp))
            {
                if (pjInit)
                {
                     ProbeForRead(pjInit, cjBits, sizeof(DWORD));

                     hSecure = MmSecureVirtualMemory(pjInit, cjBits, PAGE_READONLY);

                     if (!hSecure)
                     {
                        iRet = 0;
                     }
                }
            }
            else
            {
                iRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(6);
            // SetLastError(GetExceptionCode());
            iRet = 0;
        }
    }
    else
    {
        // it is completely valid to pass in NULL here if the ROP doesn't use
        // a source.

        pbmiTmp = NULL;
        pjInit  = NULL;
        pjInit  = NULL;
    }

    if (iRet)
    {
        iRet = GreStretchDIBitsInternal(
                    hdc,
                    xDst,
                    yDst,
                    cxDst,
                    cyDst,
                    xSrc,
                    ySrc,
                    cxSrc,
                    cySrc,
                    pjInit,
                    pbmiTmp,
                    dwUsage,
                    dwRop4,
                    cjHeader,
                    cjBits,
                    hcmXform
                    );

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }

    if (pbmiTmp)
    {
        VFREEMEM(pbmiTmp);
    }

    return (iRet);

}

/******************************Public*Routine******************************\
* NtGdiGetOutlineTextMetricsInternalW
*
* Arguments:
*
*   hdc   - device context
*   cjotm - size of metrics data array
*   potmw - pointer to array of OUTLINETEXTMETRICW structures or NULL
*   ptmd  - pointer to  TMDIFF strcture
*
* Return Value:
*
*   If potmw is NULL, return size of buffer needed, else TRUE.
*   If the function fails, the return value is FALSE;
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetOutlineTextMetricsInternalW(
    HDC                 hdc,
    ULONG               cjotm,
    OUTLINETEXTMETRICW *potmw,
    TMDIFF             *ptmd
    )
{

    DWORD dwRet = (DWORD)1;
    OUTLINETEXTMETRICW *pkmOutlineTextMetricW;
    TMDIFF kmTmDiff;


    if ((cjotm == 0) || (potmw == (OUTLINETEXTMETRICW *)NULL))
    {
        cjotm = 0;
        pkmOutlineTextMetricW = (OUTLINETEXTMETRICW *)NULL;
    }
    else
    {
        pkmOutlineTextMetricW = AllocFreeTmpBuffer(cjotm);

        if (pkmOutlineTextMetricW == (OUTLINETEXTMETRICW *)NULL)
        {
            dwRet = (DWORD)-1;
        }
    }

    if (dwRet != (DWORD)-1)
    {

        dwRet = GreGetOutlineTextMetricsInternalW(
                                            hdc,
                                            cjotm,
                                            pkmOutlineTextMetricW,
                                            &kmTmDiff);

        if (dwRet != (DWORD)-1 && dwRet != (DWORD) 0)
        {
            try
            {
                //
                // copy TMDIFF structure out
                //
                ProbeAndWriteAlignedBuffer(ptmd, &kmTmDiff, sizeof(TMDIFF), sizeof(DWORD));

                //
                // copy OTM out if needed
                //

                if (cjotm != 0)
                {
                    ProbeAndWriteAlignedBuffer(potmw, pkmOutlineTextMetricW, cjotm, sizeof(DWORD));
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(7);
                // SetLastError(GetExceptionCode());
                dwRet = (DWORD)-1;
            }
        }
    }

    if (pkmOutlineTextMetricW != (OUTLINETEXTMETRICW *)NULL)
    {
        FreeTmpBuffer(pkmOutlineTextMetricW);
    }

    return(dwRet);
}

// PUBLIC

/******************************Public*Routine******************************\
* NtGdiGetBoundsRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
NtGdiGetBoundsRect(
    HDC    hdc,
    LPRECT prc,
    DWORD  f
    )
{
    DWORD dwRet;

    RECT rc = {0, 0, 0, 0};

    dwRet = GreGetBoundsRect(hdc,&rc,f);

    if (dwRet)
    {
        try
        {
            ProbeAndWriteStructure(prc,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(8);
            // SetLastError(GetExceptionCode());

            dwRet = 0;
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetBitmapBits()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  03-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

LONG
APIENTRY
NtGdiGetBitmapBits(
    HBITMAP hbm,
    ULONG   cjMax,
    PBYTE   pjOut
   )
{
    LONG    lRet = 1;
    HANDLE  hSecure = 0;
    LONG    lOffset = 0;

    ULONG   cjBmSize = 0;

    //
    // get the bitmap size, just in case they pass
    // in a cjMax greater than the bitmap size
    //
    cjBmSize = GreGetBitmapBits(hbm,0,NULL,&lOffset);

    if (cjMax > cjBmSize)
    {
        cjMax = cjBmSize;
    }

    if (pjOut)
    {
        try
        {
            // WINBUG #83051 2-8-2000 bhouse Investigate possible stale comment
            // The below old comment mentions how this is ideal for try execept block ...
            // hmmm ... but we are in a try except block... this needs verifying that
            // it is just an old stale comment.
            // Old Comment:
            //       - this would be a prime candidate for a try/except
            //         instead of MmSecureVirtualMemory

            ProbeForWrite(pjOut,cjMax,sizeof(BYTE));
            hSecure = MmSecureVirtualMemory (pjOut, cjMax, PAGE_READWRITE);
            if (hSecure == 0)
            {
                lRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(9);
            // SetLastError(GetExceptionCode());

            lRet = 0;
       }
    }

    if (lRet)
    {
        lRet = GreGetBitmapBits(hbm,cjMax,pjOut,&lOffset);
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return (lRet);

}

/******************************Public*Routine******************************\
* NtGdiCreateDIBitmapInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*
* History:
*  03-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
*
* Difference from  NtGdiCreateDIBitmapInternal():
* Takes in cx, cy
*
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateDIBitmapInternal(
    HDC                hdc,
    INT                cx,     //Bitmap width
    INT                cy,     //Bitmap Height
    DWORD              fInit,
    LPBYTE             pjInit,
    LPBITMAPINFO       pbmi,
    DWORD              iUsage,
    UINT               cjMaxInitInfo,
    UINT               cjMaxBits,
    FLONG              f,
    HANDLE             hcmXform
    )
{
    LPBITMAPINFO       pbmiTmp = NULL;
    ULONG              cjHeader = cjMaxInitInfo;
    ULONG              cjBits = cjMaxBits;
    ULONG_PTR           iRet = 1;
    HANDLE             hSecure = 0;

    if (pbmi && cjHeader)
    {
        try
        {
            if (bCaptureBitmapInfo(pbmi, iUsage, cjHeader, &pbmiTmp))
            {
                if (pjInit)
                {
                    ProbeForRead(pjInit,cjBits,sizeof(DWORD));

                    hSecure = MmSecureVirtualMemory(pjInit, cjBits, PAGE_READONLY);

                    if (!hSecure)
                    {
                        iRet = 0;
                    }
                }
            }
            else
            {
                iRet = 0;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(10);
            // SetLastError(GetExceptionCode());
            iRet = 0;
        }

   }

   // if we didn't hit an error above

   if (iRet == 1)
   {

        if (!(fInit & CBM_CREATEDIB))
        {
            //create an compatible bitmap
            iRet = (ULONG_PTR)GreCreateDIBitmapComp(
                            hdc,
                            cx,
                            cy,
                            fInit,
                            pjInit,
                            pbmiTmp,
                            iUsage,
                            cjHeader,
                            cjBits,
                            0,
                            hcmXform);
        }
        else
        {
            iRet = (ULONG_PTR)GreCreateDIBitmapReal(
                                        hdc,
                                        fInit,
                                        pjInit,
                                        pbmiTmp,
                                        iUsage,
                                        cjHeader,
                                        cjBits,
                                        (HANDLE)0,
                                        0,
                                        (HANDLE)0,
                                        0,
                                        0,
                                        NULL);
        }
   }

   //free up
   if (pbmiTmp)
   {
       VFREEMEM(pbmiTmp);
   }

   if (hSecure)
   {
        MmUnsecureVirtualMemory(hSecure);
   }

   return((HBITMAP)iRet);
}


/******************************Public*Routine******************************\
* NtGdiCreateDIBSection
*
* Arguments:
*
* hdc      - Handle to a device context.  If the value of iUsage is
*            DIB_PAL_COLORS, the function uses this device context's logical
*            palette to initialize the device-independent bitmap's colors.
*
*
* hSection - Handle to a file mapping object that the function will use to
*            create the device-independent bitmap.  This parameter can be
*            NULL.  If hSection is not NULL, it must be a handle to a file
*            mapping object created by calling the CreateFileMapping
*            function.  Handles created by other means will cause
*            CreateDIBSection to fail.  If hSection is not NULL, the
*            CreateDIBSection function locates the bitmap's bit values at
*            offset dwOffset in the file mapping object referred to by
*            hSection.  An application can later retrieve the hSection
*            handle by calling the GetObject function with the HBITMAP
*            returned by CreateDIBSection.
*
*
*
* dwOffset - Specifies the offset from the beginning of the file mapping
*            object referenced by hSection where storage for the bitmap's
*            bit values is to begin. This value is ignored if hSection is
*            NULL. The bitmap's bit values are aligned on doubleword
*            boundaries, so dwOffset must be a multiple of the size of a
*            DWORD.
*
*            If hSection is NULL, the operating system allocates memory for
*            the device-independent bitmap.  In this case, the
*            CreateDIBSection function ignores the dwOffset parameter.  An
*            application cannot later obtain a handle to this memory: the
*            dshSection member of the DIBSECTION structure filled in by
*            calling the GetObject function will be NULL.
*
*
* pbmi     - Points to a BITMAPINFO structure that specifies various
*            attributes of the device-independent bitmap, including the
*            bitmap's dimensions and colors.iUsage
*
* iUsage   - Specifies the type of data contained in the bmiColors array
*            member of the BITMAPINFO structure pointed to by pbmi: logical
*            palette indices or literal RGB values.
*
* cjMaxInfo - Maximum size of pbmi
*
* cjMaxBits - Maximum size of bitamp
*
*
* Return Value:
*
*   handle of bitmap or NULL
*
* History:
*
*    28-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateDIBSection(
    IN  HDC          hdc,
    IN  HANDLE       hSectionApp,
    IN  DWORD        dwOffset,
    IN  LPBITMAPINFO pbmi,
    IN  DWORD        iUsage,
    IN  UINT         cjHeader,
    IN  FLONG        fl,
    IN  ULONG_PTR     dwColorSpace,
    OUT PVOID       *ppvBits
    )
{
    HBITMAP hRet    = NULL;
    BOOL    bStatus = FALSE;

    if (pbmi != NULL)
    {
        LPBITMAPINFO pbmiTmp = NULL;
        PVOID        pvBase  = NULL;

        try
        {
            bCaptureBitmapInfo(pbmi, iUsage, cjHeader, &pbmiTmp);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(11);

            EngSetLastError(ERROR_INVALID_PARAMETER);

            if (pbmiTmp != NULL)
            {
                VFREEMEM(pbmiTmp);
                pbmiTmp = NULL;
            }
        }

        if (pbmiTmp)
        {
            NTSTATUS Status;
            ULONG cjBits = GreGetBitmapBitsSize(pbmiTmp);
            SIZE_T cjView = (SIZE_T)cjBits;

            if (cjBits)
            {
                HANDLE hDIBSection = hSectionApp;

                //
                // if the app's hsection is NULL, then just
                // allocate the proper range of virtual memory
                //

                if (hDIBSection == NULL)
                {
                    Status = ZwAllocateVirtualMemory(
                                            NtCurrentProcess(),
                                            &pvBase,
                                            0L,
                                            &cjView,
                                            MEM_COMMIT | MEM_RESERVE,
                                            PAGE_READWRITE
                                            );

                    dwOffset = 0;

                    if (!Status)
                    {
                       EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                else
                {
                    LARGE_INTEGER SectionOffset;
                    PVOID pObj;

                    SectionOffset.LowPart = dwOffset & 0xFFFF0000;
                    SectionOffset.HighPart = 0;

                    //
                    // Notice, header is not included in section as it is
                    // in client-server.  We do need to leave room for
                    // the offset, however.
                    //

                    cjView += (dwOffset & 0x0000FFFF);


                    Status = ObReferenceObjectByHandle(hDIBSection,
                                              SECTION_MAP_READ|SECTION_MAP_WRITE,
                                              *(POBJECT_TYPE *)MmSectionObjectType,
                                              PsGetCurrentThreadPreviousMode(),
                                              &pObj,
                                              0L);

                    if(NT_SUCCESS(Status))
                    {
                        Status = MmMapViewOfSection(
                                         pObj,
                                         PsGetCurrentProcess(),
                                         (PVOID *) &pvBase,
                                         0L,
                                         cjView,
                                         &SectionOffset,
                                         &cjView,
                                         ViewShare,
                                         0L,
                                         PAGE_READWRITE);

                        if (!Status)
                        {
                           EngSetLastError(ERROR_INVALID_PARAMETER);
                        }

                        //
                        // we're not going to use this again
                        //

                        ObDereferenceObject(pObj);
                    }
                    else
                    {
                        WARNING("NtGdiCreateDIBSection: ObReferenceObjectByHandle failed\n");

                        EngSetLastError(ERROR_INVALID_PARAMETER);

                        //
                        //This will now fall through to the cleanup code at the end of the routine
                        //to free pbmiTmp
                        //
                    }
                }
                // set the pointer to the beginning of the bits

                if (NT_SUCCESS(Status))
                {
                    HANDLE hSecure     = NULL;
                    PBYTE  pDIB        = NULL;

                    pDIB = (PBYTE)pvBase + (dwOffset & 0x0000FFFF);

                    //
                    // try to secure memory, keep secure until bitmap
                    // is deleted
                    //

                    hSecure = MmSecureVirtualMemory(
                                                pvBase,
                                                cjView,
                                                PAGE_READWRITE);

                    if (hSecure)
                    {
                        //
                        // Make the GDI Bitmap
                        //

                        hRet = GreCreateDIBitmapReal(
                                                hdc,
                                                CBM_CREATEDIB,
                                                pDIB,
                                                pbmiTmp,
                                                iUsage,
                                                cjHeader,
                                                cjBits,
                                                hDIBSection,
                                                dwOffset,
                                                hSecure,
                                                (fl & CDBI_NOPALETTE) | CDBI_DIBSECTION,
                                                dwColorSpace,
                                                NULL);

                        if (hRet != NULL)
                        {
                            try
                            {
                                ProbeAndWriteStructure(ppvBits,pDIB,PVOID);
                                bStatus = TRUE;
                            }
                            except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                WARNINGX(12);
                                EngSetLastError(ERROR_INVALID_PARAMETER);
                            }
                        }
                        else
                        {
                           EngSetLastError(ERROR_INVALID_PARAMETER);
                        }
                    }
                    else
                    {
                       EngSetLastError(ERROR_INVALID_PARAMETER);
                    }

                    // if we failed, we need to do cleanup.

                    if (!bStatus)
                    {

                        //
                        // The bDeleteSurface call will free DIBSection memory,
                        // only do cleanup if MmSecureVirtualMemory or GreCreateDIBitmapReal
                        // failed
                        //

                        if (hRet)
                        {
                            bDeleteSurface((HSURF)hRet);
                            hRet = NULL;
                        }
                        else
                        {
                            // do we need to unsecure the memory?

                            if (hSecure)
                            {
                                MmUnsecureVirtualMemory(hSecure);
                            }

                            // free the memory based on allocation

                            if (hSectionApp == NULL)
                            {
                                cjView = 0;

                                ZwFreeVirtualMemory(
                                            NtCurrentProcess(),
                                            &pDIB,
                                            &cjView,
                                            MEM_RELEASE);
                            }
                            else
                            {
                                //
                                // unmap view of section
                                //

                                ZwUnmapViewOfSection(
                                            NtCurrentProcess(),
                                            pvBase);
                            }
                        }
                    }
                }
            }

            // the only way to have gotten here is if we did allocate the pbmiTmp

            VFREEMEM(pbmiTmp);
        }
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* NtGdiExtCreatePen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiExtCreatePen(
    ULONG  flPenStyle,
    ULONG  ulWidth,
    ULONG  iBrushStyle,
    ULONG  ulColor,
    ULONG_PTR  lClientHatch,
    ULONG_PTR   lHatch,
    ULONG  cstyle,
    PULONG pulStyle,
    ULONG  cjDIB,
    BOOL   bOldStylePen,
    HBRUSH hbrush
    )
{
    PULONG pulStyleTmp = NULL;
    PULONG pulDIB      = NULL;
    HPEN hpenRet = (HPEN)1;

    if (pulStyle)
    {
        if (!BALLOC_OVERFLOW1(cstyle,ULONG))
        {
            pulStyleTmp = PALLOCNOZ(cstyle * sizeof(ULONG),'pmtG');
        }

        if (!pulStyleTmp)
            hpenRet = (HPEN)0;
    }

    if (iBrushStyle == BS_DIBPATTERNPT)
    {
        pulDIB = AllocFreeTmpBuffer(cjDIB);

        if (!pulDIB)
            hpenRet = (HPEN)0;
    }

    if (hpenRet)
    {
        try
        {
            if (pulStyle)
            {
                ProbeAndReadAlignedBuffer(pulStyleTmp,pulStyle,cstyle * sizeof(ULONG), sizeof(ULONG));
            }

            // if it is a DIBPATTERN type, the lHatch is a pointer to the BMI

            if (iBrushStyle == BS_DIBPATTERNPT)
            {
                ProbeAndReadAlignedBuffer(pulDIB,(PVOID)lHatch,cjDIB,sizeof(ULONG));
                lHatch = (ULONG_PTR)pulDIB;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(13);
            // SetLastError(GetExceptionCode());

            hpenRet = (HPEN)0;
        }

        // if all has succeeded

        if (hpenRet)
        {
            hpenRet = GreExtCreatePen(
                        flPenStyle,ulWidth,iBrushStyle,
                        ulColor,lClientHatch,lHatch,cstyle,
                        pulStyleTmp,cjDIB,bOldStylePen,hbrush
                        );
        }
    }
    else
    {
        // SetLastError(GetExceptionCode());
    }

    // cleanup

    if (pulDIB)
        FreeTmpBuffer(pulDIB);

    if (pulStyleTmp)
        VFREEMEM(pulStyleTmp);

    return(hpenRet);
}



/******************************Public*Routine******************************\
* NtGdiHfontCreate()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HFONT
APIENTRY
NtGdiHfontCreate(
    ENUMLOGFONTEXDVW * plfw,
    ULONG              cjElfw,
    LFTYPE        lft,
    FLONG         fl,
    PVOID         pvCliData
    )
{
    ULONG_PTR iRet = 1;

// check for bad parameter

    if (plfw && cjElfw && (cjElfw <= sizeof(ENUMLOGFONTEXDVW)))
    {
        ENUMLOGFONTEXDVW elfwTmp; // too big a structure on the stack?

        try
        {
            ProbeAndReadBuffer(&elfwTmp, plfw, cjElfw);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(15);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }

    // Ignore the DV because adobe said they will never ship a mm otf font
    // This is a hack to avoid changing lot of code to remove mm support from the system

        elfwTmp.elfDesignVector.dvNumAxes = 0;

        if (iRet)
        {
            iRet = (ULONG_PTR)hfontCreate(&elfwTmp, lft, fl, pvCliData);
        }
    }
    else
    {
        iRet = 0;
    }

    return ((HFONT)iRet);
}

/******************************Public*Routine******************************\
* NtGdiExtCreateRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by-  Lingyun Wang [lingyunw]
* expanded it.
\**************************************************************************/

HRGN
APIENTRY
NtGdiExtCreateRegion(
    LPXFORM   px,
    DWORD     cj,
    LPRGNDATA prgn
    )
{
    LPRGNDATA prgnTmp;
    XFORM     xf;
    HRGN      hrgn = (HRGN)NULL;

    // check for bad parameter

    if (cj >= sizeof(RGNDATAHEADER))
    {
        // do the real work

        prgnTmp = AllocFreeTmpBuffer(cj);

        if (prgnTmp)
        {
            BOOL bConvert = TRUE;

            if (px)
            {
                bConvert = ProbeAndConvertXFORM ((XFORML *)px, (XFORML *)&xf);
                px = &xf;
            }

            if (bConvert)
            {
               try
               {

                    ProbeAndReadBuffer(prgnTmp, prgn, cj);
                    hrgn = (HRGN)1;

               }
               except(EXCEPTION_EXECUTE_HANDLER)
               {
                   WARNINGX(16);
                   // SetLastError(GetExceptionCode());
               }
            }

            if (hrgn)
                hrgn = GreExtCreateRegion((XFORML *)px,cj,prgnTmp);

            FreeTmpBuffer(prgnTmp);
        }
        else
        {
            // fail to allocate memory
            // SetLastError();
        }
    }

    return(hrgn);
}

/******************************Public*Routine******************************\
* NtGdiPolyDraw()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyDraw(
    HDC     hdc,
    LPPOINT ppt,
    LPBYTE  pjAttr,
    ULONG   cpt
    )
{
    BOOL   bRet = TRUE;
    BOOL   bLocked = FALSE;
    HANDLE hSecure1 = 0;
    HANDLE hSecure2 = 0;

    try
    {
        // Make sure lengths do not overflow.
        //
        // Note: sizeof(BYTE) < sizeof(POINT), so the single test
        //       suffices for both lengths
        //
        // Note: using MAXULONG instead of MAXIMUM_POOL_ALLOC (or the
        //       BALLOC_ macros) because we are not allocating memory.

        if (cpt <= (MAXULONG / sizeof(POINT)))
        {
            ProbeForRead(ppt,   cpt * sizeof(POINT), sizeof(DWORD));
            ProbeForRead(pjAttr,cpt * sizeof(BYTE),  sizeof(BYTE));

            hSecure1 = MmSecureVirtualMemory(ppt, cpt * sizeof(POINT), PAGE_READONLY);
            hSecure2 = MmSecureVirtualMemory(pjAttr, cpt * sizeof(BYTE), PAGE_READONLY);
        }

        if (!hSecure1 || !hSecure2)
        {
            bRet = FALSE;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(17);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GrePolyDraw(hdc,ppt,pjAttr,cpt);
    }

    if (hSecure1)
    {
        MmUnsecureVirtualMemory(hSecure1);
    }

    if (hSecure2)
    {
        MmUnsecureVirtualMemory(hSecure2);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiPolyTextOutW
*
* Arguments:
*
*   hdc  - Handle to device context
*   pptw - pointer to array of POLYTEXTW
*   cStr - number of POLYTEXTW
*
* Return Value:
*
*   Status
*
* History:
*
*   24-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyTextOutW(
    HDC        hdc,
    POLYTEXTW *pptw,
    UINT       cStr,
    DWORD      dwCodePage
    )
{
    BOOL bStatus = TRUE;
    ULONG  ulSize = sizeof(POLYTEXTW) * cStr;
    ULONG  ulIndex;
    PPOLYTEXTW pPoly = NULL;
    PBYTE pjBuffer;
    PBYTE pjBufferEnd;
    ULONG cjdx;

    //
    // Check for overflow
    //

    if (!BALLOC_OVERFLOW1(cStr,POLYTEXTW))
    {
        //
        // add up size off all array elements
        //

        try
        {
            ProbeForRead(pptw,cStr * sizeof(POLYTEXTW),sizeof(ULONG));

            for (ulIndex=0;ulIndex<cStr;ulIndex++)
            {
                int n = pptw[ulIndex].n;
                ULONG ulTmp;                // used to check for
                                            // overflow of ulSize

                //
                // Pull count from each, also check for
                // non-zero length and NULL string
                //

                ulTmp = ulSize;
                ulSize += n * sizeof(WCHAR);
                if (BALLOC_OVERFLOW1(n, WCHAR) || (ulSize < ulTmp))
                {
                    bStatus = FALSE;
                    break;
                }

                if (pptw[ulIndex].pdx != (int *)NULL)
                {
                    cjdx = n * sizeof(int);
                    if (pptw[ulIndex].uiFlags & ETO_PDY)
                    {
                        if (BALLOC_OVERFLOW1(n*2,int))
                            bStatus = FALSE;

                        cjdx *= 2;
                    }
                    else
                    {
                        if (BALLOC_OVERFLOW1(n,int))
                            bStatus = FALSE;
                    }

                    ulTmp = ulSize;
                    ulSize += cjdx;
                    if (!bStatus || (ulSize < ulTmp))
                    {
                        bStatus = FALSE;
                        break;
                    }
                }

                if (n != 0)
                {
                    if (pptw[ulIndex].lpstr == NULL)
                    {
                        bStatus = FALSE;
                        break;
                    }
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(18);
            // SetLastError(GetExceptionCode());
            bStatus = FALSE;
        }
    }
    else
    {
        bStatus = FALSE;
    }

    if (bStatus && ulSize)
    {
        pPoly = (PPOLYTEXTW)AllocFreeTmpBuffer(ulSize);

        if (pPoly != (POLYTEXTW *)NULL)
        {
            try
            {
                // Note: pptw already read probed

                RtlCopyMemory(pPoly,pptw,sizeof(POLYTEXTW) * cStr);
                pjBuffer = ((PBYTE)pPoly) + sizeof(POLYTEXTW) * cStr;
                pjBufferEnd = ((PBYTE)pPoly) + ulSize;

                //
                // copy strings and pdx into kernel mode
                // buffer and update pointers. Copy all pdx
                // values first, then copy strings to avoid
                // unaligned accesses due to odd length strings...
                //

                for (ulIndex=0;ulIndex<cStr;ulIndex++)
                {
                    //
                    // Pull count from each, also check for
                    // non-zero length and NULL string
                    //

                    if (pPoly[ulIndex].n != 0)
                    {
                        if (pPoly[ulIndex].pdx != (int *)NULL)
                        {
                            cjdx = pPoly[ulIndex].n * sizeof(int);

                            if (pPoly[ulIndex].uiFlags & ETO_PDY)
                            {
                                typedef struct _TWOINT
                                {
                                    int i1;
                                    int i2;
                                } TWOINT;


                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n,TWOINT))
                                {
                                    bStatus = FALSE;
                                }
                                cjdx *= 2;
                            }
                            else
                            {
                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n,int))
                                {
                                    bStatus = FALSE;
                                }
                            }

                            //
                            // Check for cjdx overflow and check that kernel
                            // mode buffer still has space.
                            //

                            if (!bStatus || ((pjBuffer + cjdx) > pjBufferEnd))
                            {
                                bStatus = FALSE;    // need set if past end of
                                                    // KM buffer but compuation                                                    // overflowed but computa
                                                    // of cjdx didn't overflow
                                break;
                            }

                            ProbeAndReadAlignedBuffer(
                                    pjBuffer,
                                    pPoly[ulIndex].pdx,
                                    cjdx, sizeof(int));

                            pPoly[ulIndex].pdx = (int *)pjBuffer;
                            pjBuffer += cjdx;
                        }
                    }
                }

                //
                // now copy strings
                //

                if (bStatus)
                {
                    for (ulIndex=0;ulIndex<cStr;ulIndex++)
                    {
                        //
                        // Pull count from each, also check for
                        // non-zero length and NULL string
                        //

                        if (pPoly[ulIndex].n != 0)
                        {
                            if (pPoly[ulIndex].lpstr != NULL)
                            {
                                ULONG StrSize = pPoly[ulIndex].n * sizeof(WCHAR);

                                //
                                // Check for overflow of StrSize and check
                                // that kernel mode buffer has space.
                                //

                                if (BALLOC_OVERFLOW1(pPoly[ulIndex].n, WCHAR) ||
                                    ((pjBuffer + StrSize) > pjBufferEnd))
                                {
                                    bStatus = FALSE;
                                    break;
                                }

                                ProbeAndReadAlignedBuffer(
                                        pjBuffer,
                                        (PVOID)pPoly[ulIndex].lpstr,
                                        StrSize,
                                        sizeof(WCHAR));

                                pPoly[ulIndex].lpstr = (LPWSTR)pjBuffer;
                                pjBuffer += StrSize;
                            }
                            else
                            {
                                //
                                // data error, n != 0 but lpstr = NULL
                                //

                                bStatus = FALSE;
                                break;
                            }
                        }
                    }
                }
            } except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(19);
                // SetLastError(GetExceptionCode());
                bStatus = FALSE;
            }

            if (bStatus)
            {

                //
                // Finally ready to call gre function
                //

                bStatus = GrePolyTextOutW(hdc,pPoly,cStr,dwCodePage);

            }

            FreeTmpBuffer(pPoly);
        }
        else
        {
            WARNING("NtGdiPolyTextOut failed to allocate memory\n");
            bStatus = FALSE;
        }
    }

    return(bStatus);
}




/******************************Public*Routine******************************\
* NtGdiRectVisible()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRectVisible(
    HDC    hdc,
    LPRECT prc
    )
{
    DWORD dwRet;
    RECT rc;

    try
    {
        rc = ProbeAndReadStructure(prc,RECT);
        dwRet = 1;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(22);
        // SetLastError(GetExceptionCode());

        dwRet = 0;
    }

    if (dwRet)
    {
        dwRet = GreRectVisible(hdc,&rc);
    }

    return(dwRet);


}


/******************************Public*Routine******************************\
* NtGdiSetMetaRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiSetMetaRgn(
    HDC hdc
    )
{
    return(GreSetMetaRgn(hdc));
}

/******************************Public*Routine******************************\
* NtGdiGetAppClipBox()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetAppClipBox(
    HDC    hdc,
    LPRECT prc
    )
{
    int iRet;

    RECT rc;

    iRet = GreGetAppClipBox(hdc,&rc);

    if (iRet != ERROR)
    {
        try
        {
            ProbeAndWriteStructure(prc,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(23);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextExtentEx()
*
* History:
*  Fri 06-Oct-1995 -by- Bodin Dresevic [BodinD]
* Rewrote it.
*  07-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

#define LOCAL_CWC_MAX   16

BOOL
APIENTRY
NtGdiGetTextExtentExW(
    HDC     hdc,
    LPWSTR  lpwsz,
    ULONG   cwc,
    ULONG   dxMax,
    ULONG  *pcCh,
    PULONG  pdxOut,
    LPSIZE  psize,
    FLONG   fl
    )
{

    SIZE size;
    ULONG cCh = 0;
    ULONG Localpdx[LOCAL_CWC_MAX];
    WCHAR Localpwsz[LOCAL_CWC_MAX];
    PWSZ pwszCapt = NULL;
    PULONG pdxCapt = NULL;
    BOOL UseLocals = FALSE;

    BOOL bRet = FALSE;
    BOOL b;

    if ( (b = (psize != NULL)) )
    {
        if (cwc == 0)
        {
            cCh = 0;
            size.cx = 0;
            size.cy = 0;
            bRet = TRUE;
        }
        else
        {
        // capture the string
        // NULL string causes failiure.

            if ( cwc > LOCAL_CWC_MAX ) {
                UseLocals = FALSE;
            } else {
                UseLocals = TRUE;
            }

            if (lpwsz != NULL)
            {
                try
                {
                    if ( UseLocals ) {
                        pwszCapt = Localpwsz;
                        pdxCapt = Localpdx;
                    } else {
                        if (cwc && !BALLOC_OVERFLOW2(cwc,ULONG,WCHAR))
                        {
                            pdxCapt = (PULONG) AllocFreeTmpBuffer(cwc * (sizeof(ULONG) + sizeof(WCHAR)));
                        }
                        pwszCapt = (PWSZ) &pdxCapt[cwc];
                    }

                    if (pdxCapt)
                    {
                    // Capture the string into the buffer.

                        ProbeAndReadBuffer(pwszCapt, lpwsz, cwc*sizeof(WCHAR));
                        bRet = TRUE;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(24);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                bRet = GreGetTextExtentExW(hdc,
                                           pwszCapt,
                                           cwc,
                                           pcCh ? dxMax : ULONG_MAX,
                                           &cCh,
                                           pdxOut ? pdxCapt : NULL,
                                           &size, fl);
            }
        }

    // Write the value back into the user mode buffer if the call succeded

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,size,SIZE);

                if (pcCh)
                {
                    ProbeAndWriteUlong(pcCh,cCh);
                }

                // We will only try to copy the data if pcCh is not zero,
                // and it is set to zero if cwc is zero.

                if (cCh)
                {
                // only copy if the caller requested the data, and the
                // data is present.

                    if (pdxOut && pdxCapt)
                    {
                        ProbeAndWriteAlignedBuffer(pdxOut, pdxCapt, cCh * sizeof(ULONG), sizeof(ULONG));
                    }
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(25);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }

        if (!UseLocals && pdxCapt)
        {
            FreeTmpBuffer(pdxCapt);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetCharABCWidthsW()
*
* Arguments:
*
*   hdc      - handle to device context
*   wchFirst - first char (if pwch is NULL)
*   cwch     - Number of chars to get ABC widths for
*   pwch     - array of WCHARs (mat be NULL)
*   bInteger - return int or float ABC values
*   pvBuf    - results buffer
*
* Return Value:
*
*   BOOL Status
*
* History:
*
*   14-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetCharABCWidthsW(
    HDC    hdc,
    UINT   wchFirst,
    ULONG  cwch,
    PWCHAR pwch,
    FLONG  fl,
    PVOID  pvBuf
    )
{
    BOOL    bStatus = FALSE;
    PVOID   pTemp_pvBuf = NULL;
    PWCHAR  pTemp_pwc = (PWCHAR)NULL;
    BOOL    bUse_pwc  = FALSE;
    ULONG   OutputBufferSize = 0;

    if (pvBuf == NULL)
    {
        return(bStatus);
    }

    //
    // allocate memory for buffers, pwch may be NULL
    //

    if (pwch != (PWCHAR)NULL)
    {
        bUse_pwc  = TRUE;

        if (cwch && !BALLOC_OVERFLOW1(cwch,WCHAR))
        {
            pTemp_pwc = (PWCHAR)PALLOCNOZ(cwch * sizeof(WCHAR),'pmtG');
        }
    }

    if ((!bUse_pwc) || (pTemp_pwc != (PWCHAR)NULL))
    {
        if (fl & GCABCW_INT)
        {
            if (!BALLOC_OVERFLOW1(cwch,ABC))
            {
                pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwch * sizeof(ABC));
                OutputBufferSize = cwch * sizeof(ABC);
            }
        }
        else
        {
            if (!BALLOC_OVERFLOW1(cwch,ABCFLOAT))
            {
                pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwch * sizeof(ABCFLOAT));
                OutputBufferSize = cwch * sizeof(ABCFLOAT);
            }
        }

        if (pTemp_pvBuf != NULL)
        {
            BOOL bErr = FALSE;
            //
            // copy input data to kernel mode buffer, if needed
            //

            if (bUse_pwc)
            {
                try
                {
                    ProbeAndReadBuffer(pTemp_pwc,pwch,cwch * sizeof(WCHAR));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(26);
                    // SetLastError(GetExceptionCode());
                    bErr = TRUE;
                }
            }

            if (!bErr)
            {
                bStatus = GreGetCharABCWidthsW(hdc,wchFirst,cwch,pTemp_pwc,fl,pTemp_pvBuf);

                //
                // copy results from kernel mode buffer to user buffer
                //

                if (bStatus)
                {
                    try
                    {
                        ProbeAndWriteBuffer(pvBuf,pTemp_pvBuf,OutputBufferSize);
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(27);
                        // SetLastError(GetExceptionCode());
                        bStatus = FALSE;
                    }

                }
            }

            FreeTmpBuffer(pTemp_pvBuf);
        }

        if (bUse_pwc)
        {
            if (pTemp_pwc)
                VFREEMEM(pTemp_pwc);
        }
    }

    return(bStatus);
}




/******************************Public*Routine******************************\
* NtGdiAngleArc()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiAngleArc(
    HDC   hdc,
    int   x,
    int   y,
    DWORD dwRadius,
    DWORD dwStartAngle,
    DWORD dwSweepAngle
    )
{
    FLOATL l_eStartAngle;
    FLOATL l_eSweepAngle;

    // Validate arguments and cast to floats
    BOOL bRet = (bConvertDwordToFloat(dwStartAngle, &l_eStartAngle) &&
                 bConvertDwordToFloat(dwSweepAngle ,&l_eSweepAngle));

    if (bRet)
    {
        bRet = GreAngleArc(hdc,x,y,dwRadius,l_eStartAngle,l_eSweepAngle);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiSetMiterLimit()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetMiterLimit(
    HDC    hdc,
    DWORD  dwNew,
    PDWORD pdwOut
    )
{
    BOOL   bRet = TRUE;
    FLOATL l_e;
    FLOATL l_eNew;

    ASSERTGDI(sizeof(FLOATL) == sizeof(DWORD),"sizeof(FLOATL) != sizeof(DWORD)\n");

    // Validate argument and cast to float
    bRet = bConvertDwordToFloat(dwNew, &l_eNew);

    if (bRet)
    {
        bRet = GreSetMiterLimit(hdc,l_eNew,&l_e);
    }

    if (bRet && pdwOut)
    {
        try
        {
           ProbeAndWriteAlignedBuffer(pdwOut, &l_e, sizeof(DWORD), sizeof(DWORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(113);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetFontXform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetFontXform(
    HDC   hdc,
    DWORD dwxScale,
    DWORD dwyScale
    )
{
    FLOATL l_exScale;
    FLOATL l_eyScale;

    // Validate arguments and cast to floats
    BOOL bRet = (bConvertDwordToFloat (dwxScale, &l_exScale) &&
                 bConvertDwordToFloat (dwyScale, &l_eyScale));

    if (bRet)
    {
        bRet = GreSetFontXform(hdc,l_exScale,l_eyScale);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiGetMiterLimit()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetMiterLimit(
    HDC    hdc,
    PDWORD pdwOut
    )
{
    BOOL   bRet;
    FLOATL l_e;

    bRet = GreGetMiterLimit(hdc,&l_e);

    if (bRet)
    {
        try
        {
           ProbeAndWriteAlignedBuffer(pdwOut, &l_e, sizeof(DWORD), sizeof(DWORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(29);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiMaskBlt()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiMaskBlt(
    HDC     hdc,
    int     xDst,
    int     yDst,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   dwRop4,
    DWORD   crBackColor
    )
{
    return(GreMaskBlt(
        hdc,xDst,yDst,cx,cy,
        hdcSrc,xSrc,ySrc,
        hbmMask,xMask,yMask,
        dwRop4,crBackColor
        ));
}


/******************************Public*Routine******************************\
* NtGdiGetCharWidthW
*
* History:
*
*   10-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetCharWidthW(
    HDC    hdc,
    UINT   wcFirst,
    UINT   cwc,
    PWCHAR pwc,
    FLONG  fl,
    PVOID  pvBuf
    )
{
    BOOL    bStatus = FALSE;
    PVOID   pTemp_pvBuf = NULL;
    PWCHAR  pTemp_pwc = (PWCHAR)NULL;
    BOOL    bUse_pwc  = FALSE;

    //
    // allocate memory for buffers, pwc may be NULL
    //

    if (!cwc)
    {
        return(FALSE);
    }

    if (pwc != (PWCHAR)NULL)
    {
        bUse_pwc = TRUE;

        if (!BALLOC_OVERFLOW1(cwc,WCHAR))
        {
            pTemp_pwc = (PWCHAR)PALLOCNOZ(cwc * sizeof(WCHAR),'pmtG');
        }
    }

    if ((!bUse_pwc) || (pTemp_pwc != (PWCHAR)NULL))
    {
        if (!BALLOC_OVERFLOW1(cwc,ULONG))
        {
            pTemp_pvBuf = (PVOID)AllocFreeTmpBuffer(cwc * sizeof(ULONG));
        }

        if (pTemp_pvBuf != NULL)
        {
            //
            // copy input data to kernel mode buffer, if needed
            //

            if (bUse_pwc)
            {
                try
                {
                    ProbeAndReadBuffer(pTemp_pwc,pwc,cwc * sizeof(WCHAR));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(30);
                    // SetLastError(GetExceptionCode());
                    bStatus = FALSE;
                }
            }

            bStatus = GreGetCharWidthW(hdc,wcFirst,cwc,pTemp_pwc,fl,pTemp_pvBuf);

            //
            // copy results from kernel mode buffer to user buffer
            //

            if (bStatus)
            {
                try
                {
                    ProbeAndWriteBuffer(pvBuf,pTemp_pvBuf,cwc * sizeof(ULONG));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(31);
                    // SetLastError(GetExceptionCode());
                    bStatus = FALSE;
                }

            }

            FreeTmpBuffer(pTemp_pvBuf);
        }

        if (bUse_pwc)
        {
            VFREEMEM(pTemp_pwc);
        }
    }

    return(bStatus);
}


/******************************Public*Routine******************************\
* NtGdiDrawEscape
*
* Arguments:
*
*   hdc  - handle of device context
*   iEsc - specifies escape function
*   cjIn - size of structure for input
*   pjIn - address of structure for input
*
* Return Value:
*
*   >  0 if successful
*   == 0 if function not supported
*   <  0 if error
*
* History:
*
*   16-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define DRAWESCAPE_BUFFER_SIZE 64

int
APIENTRY
NtGdiDrawEscape(
    HDC   hdc,
    int   iEsc,
    int   cjIn,
    LPSTR pjIn
    )
{
    int   cRet = 0;
    ULONG AllocSize;
    UCHAR StackBuffer[DRAWESCAPE_BUFFER_SIZE];
    LPSTR pCallBuffer = pjIn;
    HANDLE hSecure = 0;

    //
    // Validate.
    //

    if (cjIn < 0)
    {
        return -1;
    }

    //
    // Check cjIn is 0 for NULL pjIn
    //

    if (pjIn == (LPSTR)NULL)
    {
        if (cjIn != 0)
        {
            cRet = -1;
        }
        else
        {
            cRet = GreDrawEscape(hdc,iEsc,0,(LPSTR)NULL);
        }
    }
    else
    {
        //
        // Try to alloc off stack, otherwise lock buffer
        //

        AllocSize = (cjIn + 3) & ~0x03;

        if (AllocSize <= DRAWESCAPE_BUFFER_SIZE)
        {
            pCallBuffer = (LPSTR)StackBuffer;

            //
            // copy data into buffer
            //

            try
            {
                ProbeAndReadBuffer(pCallBuffer,pjIn,cjIn);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(32);
                // SetLastError(GetExceptionCode());
                cRet = -1;
            }
        }
        else
        {
            hSecure = MmSecureVirtualMemory(pjIn, cjIn, PAGE_READONLY);

            if (hSecure == 0)
            {
                cRet = -1;
            }
        }

        if (cRet >= 0)
        {
            cRet = GreDrawEscape(hdc,iEsc,cjIn,pCallBuffer);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    return(cRet);
}

/******************************Public*Routine******************************\
* NtGdiExtEscape
*
* Arguments:
*
*   hdc      - handle of device context
*   pDriver  - buffer containing name of font driver
*   nDriver  - length of driver name
*   iEsc     - escape function
*   cjIn     - size, in bytes, of input data structure
*   pjIn     - address of input structure
*   cjOut    - size, in bytes, of output data structure
*   pjOut    - address of output structure
*
* Return Value:
*
*   >  0 : success
*   == 0 : escape not implemented
*   <  0 : error
*
* History:
*
*   17-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define EXT_STACK_DATA_SIZE 32

int
APIENTRY
NtGdiExtEscape(
    HDC     hdc,
    PWCHAR  pDriver,     // only used for NamedEscape call
    int     nDriver,     // only used for NamedEscape call
    int     iEsc,
    int     cjIn,
    LPSTR   pjIn,
    int     cjOut,
    LPSTR   pjOut
    )

{
    UCHAR  StackInputData[EXT_STACK_DATA_SIZE];
    UCHAR  StackOutputData[EXT_STACK_DATA_SIZE];
    WCHAR  StackDriver[EXT_STACK_DATA_SIZE];
    HANDLE hSecureIn;
    LPSTR  pkmIn, pkmOut;
    BOOL   bAllocOut, bAllocIn, bAllocDriver;
    PWCHAR pkmDriver = NULL;
    BOOL   bStatus = TRUE;
    BOOL   iRet = -1;

    bAllocOut = bAllocIn = bAllocDriver = FALSE;
    hSecureIn = NULL;
    pkmIn = pkmOut = NULL;

    if ((cjIn < 0) || (cjOut < 0) || (nDriver < 0))
    {
        WARNING("NtGdiExtEscape: negative count passed in\n");
        bStatus = FALSE;
    }

    if (pDriver && bStatus)
    {
        if (nDriver <= EXT_STACK_DATA_SIZE-1)
        {
            pkmDriver = StackDriver;
        }
        else
        {
            if (!BALLOC_OVERFLOW1((nDriver+1),WCHAR))
            {
                pkmDriver = (WCHAR*)PALLOCNOZ((nDriver+1) * sizeof(WCHAR),'pmtG');
            }

            // even if we fail this is okay because we check for NULL before FREE

            bAllocDriver = TRUE;
        }

        if (pkmDriver != NULL)
        {
            try
            {
                ProbeAndReadAlignedBuffer(pkmDriver,pDriver,nDriver*sizeof(WCHAR), sizeof(WCHAR));
                pkmDriver[nDriver] = 0;  // NULL terminate the string
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(94);
                bStatus = FALSE;
            }
        }
        else
        {
            bStatus = FALSE;
        }
    }

    if ((cjIn != 0) && bStatus)
    {
        try
        {
            if (cjIn <= EXT_STACK_DATA_SIZE)
            {
                pkmIn = (LPSTR) StackInputData;
                ProbeAndReadBuffer(pkmIn, pjIn, cjIn);
            }
            else if (pkmDriver != NULL)
            {
                //
                // make kernel copies for the fontdrv
                // otherwise just secure the memory
                //
                pkmIn = (LPSTR)PALLOCNOZ(cjIn,'pmtG');

                 if (pkmIn != (LPSTR)NULL)
                 {
                    bAllocIn = TRUE;

                     try
                     {
                         ProbeAndReadBuffer(pkmIn,pjIn,cjIn);
                     }
                     except(EXCEPTION_EXECUTE_HANDLER)
                     {
                         WARNINGX(33);
                         // SetLastError(GetExceptionCode());
                         bStatus = FALSE;
                     }
                 }
                 else
                 {
                     bStatus = FALSE;
                 }

            }
            else
            {
                ProbeForRead(pjIn,cjIn,sizeof(BYTE));

                if (hSecureIn = MmSecureVirtualMemory(pjIn, cjIn, PAGE_READONLY))
                {
                    pkmIn = pjIn;
                }
                else
                {
                    bStatus = FALSE;
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(33);
            bStatus = FALSE;
        }
    }

    if ((cjOut != 0) && bStatus)
    {
        if (cjOut <= EXT_STACK_DATA_SIZE)
            pkmOut = (LPSTR) StackOutputData;
        else if (pkmOut = (LPSTR) PALLOCNOZ(cjOut, 'pmtG'))
            bAllocOut = TRUE;
        else
            bStatus = FALSE;

        // Security: zero initialize the return buffer or we may open
        // a hole that returns old pool data or old kernel stack data.

        if (pkmOut)
        {
            RtlZeroMemory((PVOID) pkmOut, cjOut);
        }

    }

    if (bStatus)
    {

        iRet = (pkmDriver) ?
                GreNamedEscape(pkmDriver, iEsc, cjIn, pkmIn, cjOut, pkmOut) :
                GreExtEscape(hdc, iEsc, cjIn, pkmIn, cjOut, pkmOut);

        if (cjOut != 0)
        {
            try
            {
                ProbeAndWriteBuffer(pjOut, pkmOut, cjOut);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(34);
                iRet = -1;
            }
        }
    }

    if (hSecureIn)
        MmUnsecureVirtualMemory(hSecureIn);

    if (bAllocOut && pkmOut)
        VFREEMEM(pkmOut);

    if (bAllocIn && pkmIn)
        VFREEMEM(pkmIn);


    if (bAllocDriver && pkmDriver)
        VFREEMEM(pkmDriver);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetFontData()
*
* Arguments:
*
*   hdc      - handle to device context
*   dwTable  - name of a font metric table
*   dwOffset - ffset from the beginning of the font metric table
*   pvBuf    - buffer to receive the font information
*   cjBuf    - length, in bytes, of the information to be retrieved
*
* Return Value:
*
*   Count of byte written to buffer, of GDI_ERROR for failure
*
* History:
*
*   14-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetFontData(
    HDC    hdc,
    DWORD  dwTable,
    DWORD  dwOffset,
    PVOID  pvBuf,
    ULONG  cjBuf
    )
{
    PVOID  pvkmBuf = NULL;
    ULONG  ReturnBytes = GDI_ERROR;

    if (cjBuf == 0)
    {
        ReturnBytes = ulGetFontData(
                                hdc,
                                dwTable,
                                dwOffset,
                                pvkmBuf,
                                cjBuf);
    }
    else
    {
        pvkmBuf = AllocFreeTmpBuffer(cjBuf);

        if (pvkmBuf != NULL)
        {

            ReturnBytes = ulGetFontData(
                                    hdc,
                                    dwTable,
                                    dwOffset,
                                    pvkmBuf,
                                    cjBuf);

            if (ReturnBytes != GDI_ERROR)
            {
                try
                {
                    ProbeAndWriteBuffer(pvBuf,pvkmBuf,ReturnBytes);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(35);
                    // SetLastError(GetExceptionCode());
                    ReturnBytes = GDI_ERROR;
                }
            }

            FreeTmpBuffer(pvkmBuf);
        }
    }

    return(ReturnBytes);
}

/******************************Public*Routine******************************\
* NtGdiGetGlyphOutline
*
* Arguments:
*
*   hdc             - device context
*   wch             - character to query
*   iFormat         - format of data to return
*   pgm             - address of structure for metrics
*   cjBuf           - size of buffer for data
*   pvBuf           - address of buffer for data
*   pmat2           - address of transformation matrix structure
*   bIgnoreRotation - internal rotation flag
*
* Return Value:
*
*   If the function succeeds, and GGO_BITMAP or GGO_NATIVE is specified,
*       then return value is greater than zero.
*   If the function succeeds, and GGO_METRICS is specified,
*       then return value is zero.
*   If GGO_BITMAP or GGO_NATIVE is specified,
*       and the buffer size or address is zero,
*       then return value specifies the required buffer size.
*       If GGO_BITMAP or GGO_NATIVE is specified,
*       and the function fails for other reasons,
*       then return value is GDI_ERROR.
*   If GGO_METRICS is specified, and the function fails,
*       then return value is GDI_ERROR.
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetGlyphOutline(
    HDC            hdc,
    WCHAR          wch,
    UINT           iFormat,
    LPGLYPHMETRICS pgm,
    ULONG          cjBuf,
    PVOID          pvBuf,
    LPMAT2         pmat2,
    BOOL           bIgnoreRotation
    )
{
    // error return value of -1 from server.inc

    DWORD   dwRet = (DWORD)-1;
    PVOID   pvkmBuf;
    MAT2    kmMat2;
    GLYPHMETRICS kmGlyphMetrics;

// try to allocate buffer

    pvkmBuf = (cjBuf) ? AllocFreeTmpBuffer(cjBuf) : NULL;

    if ((pvkmBuf != NULL) || !cjBuf)
    {
        BOOL bStatus = TRUE;

    // copy input structures

        try
        {
            kmMat2 = ProbeAndReadStructure(pmat2,MAT2);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(36);
            // SetLastError(GetExceptionCode());
            bStatus = FALSE;
        }

        if (bStatus)
        {
            dwRet = GreGetGlyphOutlineInternal(
                                        hdc,
                                        wch,
                                        iFormat,
                                        &kmGlyphMetrics,
                                        cjBuf,
                                        pvkmBuf,
                                        &kmMat2,
                                        bIgnoreRotation);

            if (dwRet != (DWORD)-1)
            {
                try
                {
                    if( pvkmBuf )
                    {
                        ProbeAndWriteBuffer(pvBuf,pvkmBuf,cjBuf);
                    }
                    ProbeAndWriteStructure(pgm,kmGlyphMetrics,GLYPHMETRICS);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(37);
                    // SetLastError(GetExceptionCode());
                    dwRet = (DWORD)-1;
                }
            }
        }

        if( pvkmBuf )
        {
            FreeTmpBuffer(pvkmBuf);
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetRasterizerCaps()
*
* History:
*  08-Mar-1995 -by-  Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetRasterizerCaps(
    LPRASTERIZER_STATUS praststat,
    ULONG               cjBytes
    )
{

    BOOL              bStatus = FALSE;
    RASTERIZER_STATUS tempRasStatus;

    if (praststat && cjBytes)
    {
        cjBytes = min(cjBytes, sizeof(RASTERIZER_STATUS));

        if (GreGetRasterizerCaps(&tempRasStatus))
        {
            try
            {
                ProbeAndWriteAlignedBuffer(praststat, &tempRasStatus, cjBytes, sizeof(DWORD));
                bStatus = TRUE;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(38);
                // SetLastError(GetExceptionCode());
            }
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* NtGdiGetKerningPairs
*
* Arguments:
*
*   hdc    - device context
*   cPairs - number of pairs to retrieve
*   pkpDst - Pointer to buffer to recieve kerning pairs data or NULL
*
* Return Value:
*
*   If pkpDst is NULL, return number of Kerning pairs in font,
*   otherwise return number of kerning pairs written to buffer.
*   If failure, return 0
*
* History:
*
*   15-Mar-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetKerningPairs(
    HDC          hdc,
    ULONG        cPairs,
    KERNINGPAIR *pkpDst
    )
{
    ULONG cRet = 0;
    KERNINGPAIR *pkmKerningPair = (KERNINGPAIR *)NULL;

    if (pkpDst != (KERNINGPAIR *)NULL)
    {
         if (!BALLOC_OVERFLOW1(cPairs,KERNINGPAIR))
         {
             pkmKerningPair = AllocFreeTmpBuffer(sizeof(KERNINGPAIR) * cPairs);
         }
    }

    if ((pkpDst == (KERNINGPAIR *)NULL) ||
        (pkmKerningPair != (KERNINGPAIR *)NULL))
    {
        cRet = GreGetKerningPairs(hdc,cPairs,pkmKerningPair);

        //
        // copy data out if needed
        //

        if (pkpDst != (KERNINGPAIR *)NULL)
        {
            if (cRet != 0)
            {
                try
                {
                    ProbeAndWriteBuffer(pkpDst,pkmKerningPair,sizeof(KERNINGPAIR) * cRet);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(39);
                    // SetLastError(GetExceptionCode());
                    cRet = 0;
                }
            }

            FreeTmpBuffer(pkmKerningPair);
        }
    }
    return(cRet);
}


/******************************Public*Routine******************************\
* NtGdiGetObjectBitmapHandle()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiGetObjectBitmapHandle(
    HBRUSH hbr,
    UINT  *piUsage
    )
{
    UINT iUsage;
    HBITMAP hbitmap = (HBITMAP)1;

    // error checking
    int iType = LO_TYPE(hbr);

    if ((iType != LO_BRUSH_TYPE) &&
        (iType != LO_EXTPEN_TYPE))
    {
        return((HBITMAP)hbr);
    }

    hbitmap = GreGetObjectBitmapHandle(hbr,&iUsage);

    if (hbitmap)
    {
        try
        {
            ProbeAndWriteUlong(piUsage,iUsage);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(40);
            // SetLastError(GetExceptionCode());

            hbitmap = (HBITMAP)0;
        }
    }

    return (hbitmap);
}

/******************************Public*Routine******************************\
* NtGdiResetDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  26-Feb-1995 -by- Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiResetDC(
    HDC             hdc,
    LPDEVMODEW      pdm,
    BOOL           *pbBanding,
    DRIVER_INFO_2W *pDriverInfo2,
    PVOID           ppUMdhpdev
    )
{
    LPDEVMODEW      pdmTmp = NULL;
    DWORD           dwTmp;
    INT             iRet = 1;
    INT             cj;
    DRIVER_INFO_2W *pKmDriverInfo2 = NULL;

    try
    {
        // Make a kernel mode copy of DEVMODEW structure

        iRet = (pdm == NULL) ||
               (pdmTmp = CaptureDEVMODEW(pdm)) != NULL;


        // Make a kernel mode copy of DRIVER_INFO_2W structure

        iRet = iRet &&
               ((pDriverInfo2 == NULL) ||
                (pKmDriverInfo2 = CaptureDriverInfo2W(pDriverInfo2)) != NULL);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(41);
        iRet = 0;
    }

    if (iRet)
    {
        iRet = GreResetDCInternal(hdc,pdmTmp,&dwTmp, pKmDriverInfo2, ppUMdhpdev);

        if (iRet)
        {
            try
            {
                ProbeAndWriteUlong(pbBanding,dwTmp);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(42);
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }

        }
    }

    if (pdmTmp)
    {
        VFREEMEM(pdmTmp);
    }

    vFreeDriverInfo2(pKmDriverInfo2);

    return (iRet);

}

/******************************Public*Routine******************************\
* NtGdiSetBoundsRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
NtGdiSetBoundsRect(
    HDC    hdc,
    LPRECT prc,
    DWORD  f
    )
{
    DWORD dwRet=0;
    RECT rc;

    if (prc)
    {
        try
        {
            rc    = ProbeAndReadStructure(prc,RECT);
            prc   = &rc;
            dwRet = 1;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(43);
            // SetLastError(GetExceptionCode());

            dwRet = 0;
        }
    }
    else
    {
        // can't use the DCB_ACCUMULATE without a rectangle

        f &= ~DCB_ACCUMULATE;
        dwRet = 1;
    }

    if (dwRet)
        dwRet = GreSetBoundsRect(hdc,prc,f);

    return(dwRet);
}

/******************************Public*Routine******************************\
* NtGdiGetColorAdjustment()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetColorAdjustment(
    HDC              hdc,
    PCOLORADJUSTMENT pcaOut
    )
{
    BOOL bRet;
    COLORADJUSTMENT ca;

    bRet = GreGetColorAdjustment(hdc,&ca);

    if (bRet)
    {
        try
        {
            ProbeAndWriteStructure(pcaOut,ca,COLORADJUSTMENT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(44);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetColorAdjustment()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetColorAdjustment(
    HDC              hdc,
    PCOLORADJUSTMENT pca
    )
{
    BOOL bRet;
    COLORADJUSTMENT ca;

    try
    {
        ca = ProbeAndReadStructure(pca,COLORADJUSTMENT);
        bRet = 1;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(45);
        // SetLastError(GetExceptionCode());

        bRet = 0;
    }

    if (bRet)
    {
        // Range check all the adjustment values.  Return FALSE if any of them
        // is out of range.

        if ((ca.caSize != sizeof(COLORADJUSTMENT)) ||
            (ca.caIlluminantIndex > ILLUMINANT_MAX_INDEX) ||
            ((ca.caRedGamma > RGB_GAMMA_MAX) ||
             (ca.caRedGamma < RGB_GAMMA_MIN)) ||
            ((ca.caGreenGamma > RGB_GAMMA_MAX) ||
             (ca.caGreenGamma < RGB_GAMMA_MIN)) ||
            ((ca.caBlueGamma > RGB_GAMMA_MAX) ||
             (ca.caBlueGamma < RGB_GAMMA_MIN)) ||
            ((ca.caReferenceBlack > REFERENCE_BLACK_MAX) ||
             (ca.caReferenceBlack < REFERENCE_BLACK_MIN)) ||
            ((ca.caReferenceWhite > REFERENCE_WHITE_MAX) ||
             (ca.caReferenceWhite < REFERENCE_WHITE_MIN)) ||
            ((ca.caContrast > COLOR_ADJ_MAX) ||
             (ca.caContrast < COLOR_ADJ_MIN)) ||
            ((ca.caBrightness > COLOR_ADJ_MAX) ||
             (ca.caBrightness < COLOR_ADJ_MIN)) ||
            ((ca.caColorfulness > COLOR_ADJ_MAX) ||
             (ca.caColorfulness < COLOR_ADJ_MIN)) ||
            ((ca.caRedGreenTint > COLOR_ADJ_MAX) ||
             (ca.caRedGreenTint < COLOR_ADJ_MIN)))
        {
            bRet = 0;
        }
        else
        {
            bRet = GreSetColorAdjustment(hdc,&ca);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiCancelDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiCancelDC(
    HDC hdc
    )
{
    return(GreCancelDC(hdc));
}

//API's used by USER

/******************************Public*Routine******************************\
* NtGdiSelectBrush()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiSelectBrush(
    HDC    hdc,
    HBRUSH hbrush
    )
{
    return(GreSelectBrush(hdc,(HANDLE)hbrush));
}

/******************************Public*Routine******************************\
* NtGdiSelectPen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiSelectPen(
    HDC  hdc,
    HPEN hpen
    )
{
    return(GreSelectPen(hdc,hpen));
}

/******************************Public*Routine******************************\
* NtGdiSelectFont()
*
* History:
*  18-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

HFONT
APIENTRY
NtGdiSelectFont(HDC hdc, HFONT hf)
{
    return(GreSelectFont(hdc, hf));
}

/******************************Public*Routine******************************\
* NtGdiSelectBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiSelectBitmap(
    HDC     hdc,
    HBITMAP hbm
    )
{
    return(hbmSelectBitmap(hdc,hbm,FALSE));
}

/******************************Public*Routine******************************\
* NtGdiExtSelectClipRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExtSelectClipRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iMode
    )
{
    return(GreExtSelectClipRgn(hdc,hrgn,iMode));
}

/******************************Public*Routine******************************\
* NtGdiCreatePen()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPEN
APIENTRY
NtGdiCreatePen(
    int      iPenStyle,
    int      iPenWidth,
    COLORREF cr,
    HBRUSH   hbr
    )
{
    return(GreCreatePen(iPenStyle,iPenWidth,cr,hbr));
}


/******************************Public*Routine******************************\
*
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiStretchBlt(
    HDC   hdcDst,
    int   xDst,
    int   yDst,
    int   cxDst,
    int   cyDst,
    HDC   hdcSrc,
    int   xSrc,
    int   ySrc,
    int   cxSrc,
    int   cySrc,
    DWORD dwRop,
    DWORD dwBackColor
    )
{
    return(GreStretchBlt(
                    hdcDst,xDst,yDst,cxDst,cyDst,
                    hdcSrc,xSrc,ySrc,cxSrc,cySrc,
                    dwRop,dwBackColor));
}

/******************************Public*Routine******************************\
* NtGdiMoveTo()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiMoveTo(
    HDC     hdc,
    int     x,
    int     y,
    LPPOINT pptOut
    )
{
    BOOL bRet;
    POINT pt;

    bRet = GreMoveTo(hdc,x,y,&pt);

    if (bRet && pptOut)
    {
        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(47);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetDeviceCaps()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetDeviceCaps(
    HDC hdc,
    int i
    )
{
    return(GreGetDeviceCaps(hdc,i));
}

/******************************Public*Routine******************************\
* NtGdiSaveDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiSaveDC(
    HDC hdc
    )
{
    return(GreSaveDC(hdc));
}

/******************************Public*Routine******************************\
* NtGdiRestoreDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRestoreDC(
    HDC hdc,
    int iLevel
    )
{
    return(GreRestoreDC(hdc,iLevel));
}

/******************************Public*Routine******************************\
* NtGdiGetNearestColor()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

COLORREF
APIENTRY
NtGdiGetNearestColor(
    HDC      hdc,
    COLORREF cr
    )
{
    return(GreGetNearestColor(hdc,cr));
}

/******************************Public*Routine******************************\
* NtGdiGetSystemPaletteUse()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiGetSystemPaletteUse(
    HDC hdc
    )
{
    return(GreGetSystemPaletteUse(hdc));
}

/******************************Public*Routine******************************\
* NtGdiSetSystemPaletteUse()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiSetSystemPaletteUse(
    HDC  hdc,
    UINT ui
    )
{
    return(GreSetSystemPaletteUse(hdc,ui));
}


/******************************Public*Routine******************************\
* NtGdiGetRandomRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetRandomRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iRgn
    )
{
    return(GreGetRandomRgn(hdc,hrgn,iRgn));
}

/******************************Public*Routine******************************\
* NtGdiIntersectClipRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiIntersectClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    return(GreIntersectClipRect(hdc,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiExcludeClipRect()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExcludeClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    return(GreExcludeClipRect(hdc,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiOpenDCW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  27-Feb-1995 -by- Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

HDC
APIENTRY
NtGdiOpenDCW(
    PUNICODE_STRING     pustrDevice,
    DEVMODEW *          pdm,
    PUNICODE_STRING     pustrLogAddr,
    ULONG               iType,
    HANDLE              hspool,
    DRIVER_INFO_2W     *pDriverInfo2,
    PVOID               ppUMdhpdev
    )
{
    HDC             hdc = NULL;
    ULONG           iRet = 0;
    PWSZ            pwszDevice = NULL;
    LPDEVMODEW      pdmTmp = NULL;
    INT             cjDevice;
    PWSTR           pwstrDevice;
    DRIVER_INFO_2W *pKmDriverInfo2 = NULL;

    //
    // This API overloads the pwszDevice parameter.
    //
    // If pustrDevice is NULL, it is equivalent to calling with "DISPLAY"
    // which means to get a DC on the current device, which is done by
    // calling USER
    //

    if (pustrDevice == NULL)
    {
        hdc = UserGetDesktopDC(iType, FALSE, TRUE);
    }
    else
    {
        try
        {
            ProbeForRead(pustrDevice,sizeof(UNICODE_STRING), sizeof(CHAR));
            cjDevice = pustrDevice->Length;
            pwstrDevice = pustrDevice->Buffer;

            if (cjDevice)
            {
                if (cjDevice <= (MAXIMUM_POOL_ALLOC - sizeof(WCHAR)))
                {
                    pwszDevice = AllocFreeTmpBuffer(cjDevice + sizeof(WCHAR));
                }

                if (pwszDevice)
                {
                    ProbeAndReadBuffer(pwszDevice,pwstrDevice,cjDevice);
                    pwszDevice[(cjDevice/sizeof(WCHAR))] = L'\0';
                }

            }

            // Make a kernel copy of DEVMODEW structure

            iRet = (pdm == NULL) ||
                   (pdmTmp = CaptureDEVMODEW(pdm)) != NULL;

            // Make a kernel copy of DRIVER_INFO_2W structure

            iRet = iRet &&
                   ((pDriverInfo2 == NULL) ||
                    (pKmDriverInfo2 = CaptureDriverInfo2W(pDriverInfo2)) != NULL);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(48);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }

        if (iRet)
        {
            hdc = hdcOpenDCW(pwszDevice,
                             pdmTmp,
                             iType,
                             hspool,
                             NULL,
                             pKmDriverInfo2,
                             ppUMdhpdev);

        }

        if (pwszDevice)
            FreeTmpBuffer(pwszDevice);

        if (pdmTmp)
            VFREEMEM(pdmTmp);

        vFreeDriverInfo2(pKmDriverInfo2);
    }

    return (hdc);
}

/******************************Public*Routine******************************\
* NtGdiCreateCompatibleBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateCompatibleBitmap(
    HDC hdc,
    int cx,
    int cy
    )
{
    return(GreCreateCompatibleBitmap(hdc,cx,cy));
}

/******************************Public*Routine******************************\
* NtGdiCreateBitmap()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  04-MAR-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiCreateBitmap(
    int    cx,
    int    cy,
    UINT   cPlanes,
    UINT   cBPP,
    LPBYTE pjInit
    )
{
    ULONG_PTR iRet = 1;
    HANDLE hSecure = 0;

    INT cj;

    if (pjInit == (VOID *) NULL)
    {
        cj = 0;
    }
    else
    {
        // only needs to word aligned and sized

        cj = noOverflowCJSCANW(cx,(WORD) cPlanes,(WORD) cBPP,cy);
        
        if (cj == 0)
            iRet = 0;
    }

    if (cj)
    {
        try
        {
            ProbeForRead(pjInit,cj,sizeof(BYTE));

            hSecure = MmSecureVirtualMemory(pjInit, cj, PAGE_READONLY);

            if (hSecure == 0)
            {
                iRet = 0;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(49);
            iRet = 0;
        }
    }

    // if we didn't hit an error above

    if (iRet)
    {
        iRet = (ULONG_PTR)GreCreateBitmap(cx,cy,cPlanes,cBPP,pjInit);

    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return((HBITMAP)iRet);
}

/******************************Public*Routine******************************\
* NtGdiSetBitmapAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiSetBitmapAttributes(
    HBITMAP hbm,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBitmapStock(hbm));
    return (HBITMAP)0;
}

/******************************Public*Routine******************************\
* NtGdiClearBitmapAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
NtGdiClearBitmapAttributes(
    HBITMAP hbm,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBitmapNonStock(hbm));
    return (HBITMAP)0;
}

/******************************Public*Routine******************************\
* NtGdiSetBrushAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiSetBrushAttributes(
    HBRUSH hbr,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBrushStock(hbr));
    return (HBRUSH)0;
}

/******************************Public*Routine******************************\
* NtGdiClearBrushAttributes()
*
* History:
*  27-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiClearBrushAttributes(
    HBRUSH hbr,
    DWORD dwFlags
    )
{
    if (dwFlags & SBA_STOCK)
        return(GreMakeBrushNonStock(hbr));
    return (HBRUSH)0;
}

/******************************Public*Routine******************************\
* NtGdiCreateHalftonePalette()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
NtGdiCreateHalftonePalette(
    HDC hdc
    )
{
    return(GreCreateCompatibleHalftonePalette(hdc));
}

/******************************Public*Routine******************************\
* NtGdiGetStockObject()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
NtGdiGetStockObject(
    int iObject
    )
{
    return(GreGetStockObject(iObject));
}

/******************************Public*Routine******************************\
* NtGdiExtGetObjectW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiExtGetObjectW(
    HANDLE h,
    int    cj,
    LPVOID pvOut
    )
{
    int iRet = 0;
    union
    {
        BITMAP          bm;
        DIBSECTION      ds;
        EXTLOGPEN       elp;
        LOGPEN          l;
        LOGBRUSH        lb;
        LOGFONTW        lf;
        ENUMLOGFONTEXDVW elf;
        LOGCOLORSPACEEXW lcsp;
    } obj;
    int iType = LO_TYPE(h);
    int ci;

    if ((cj < 0) || (cj > sizeof(obj)))
    {
        WARNING("GetObject size too big\n");
        cj = sizeof(obj);
    }
    ci = cj;

    //
    // make the getobject call on brush
    // still work even the app passes in
    // a cj < sizeof(LOGBRUSH)
    //
    if (iType == LO_BRUSH_TYPE)
    {
        cj = sizeof(LOGBRUSH);
    }

    iRet = GreExtGetObjectW(h,cj,pvOut ? &obj : NULL);

    if (iType == LO_BRUSH_TYPE)
    {
        cj = min(cj, ci);
    }

    if (iRet && pvOut)
    {
        try
        {
            ProbeAndWriteAlignedBuffer(pvOut,&obj,MIN(cj,iRet), sizeof(WORD));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(50);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiSetBrushOrg()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetBrushOrg(
    HDC     hdc,
    int     x,
    int     y,
    LPPOINT pptOut
    )
{
    BOOL bRet;
    POINT pt;

    bRet = GreSetBrushOrg(hdc,x,y,&pt);

    if (bRet && pptOut)
    {
        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(51);
            // SetLastError(GetExceptionCode());

            bRet = 0;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiUnrealizeObject()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiUnrealizeObject(
    HANDLE h
    )
{
    return(GreUnrealizeObject(h));
}

/******************************Public*Routine******************************\
*
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiCombineRgn(
    HRGN hrgnDst,
    HRGN hrgnSrc1,
    HRGN hrgnSrc2,
    int  iMode
    )
{
    return(GreCombineRgn(hrgnDst,hrgnSrc1,hrgnSrc2,iMode));
}

/******************************Public*Routine******************************\
* NtGdiSetRectRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetRectRgn(
    HRGN hrgn,
    int  xLeft,
    int  yTop,
    int  xRight,
    int  yBottom
    )
{
    return(GreSetRectRgn(hrgn,xLeft,yTop,xRight,yBottom));
}

/******************************Public*Routine******************************\
* NtGdiSetBitmapBits()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG
APIENTRY
NtGdiSetBitmapBits(
    HBITMAP hbm,
    ULONG   cj,
    PBYTE   pjInit
    )
{
    LONG    lRet = 1;
    LONG    lOffset = 0;
    HANDLE hSecure = 0;

    try
    {
        //  Each scan is copied seperately

        ProbeForRead(pjInit,cj,sizeof(BYTE));
        hSecure = MmSecureVirtualMemory(pjInit, cj, PAGE_READONLY);

        if (hSecure == 0)
        {
            lRet = 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(52);
        // SetLastError(GetExceptionCode());

        lRet = 0;
    }

    if (lRet)
        lRet = GreSetBitmapBits(hbm,cj,pjInit,&lOffset);

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return (lRet);
}

/******************************Public*Routine******************************\
* NtGdiOffsetRgn()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiOffsetRgn(
    HRGN hrgn,
    int  cx,
    int  cy
    )
{
    return(GreOffsetRgn(hrgn,cx,cy));
}

/******************************Public*Routine******************************\
* NtGdiGetRgnBox()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
*  24-Feb-1995 -by- Lingyun Wang [lingyunw]
* expanded it.
\**************************************************************************/

int
APIENTRY
NtGdiGetRgnBox(
    HRGN   hrgn,
    LPRECT prcOut
    )
{
    RECT rc;
    int iRet;

    iRet = GreGetRgnBox(hrgn,&rc);

    if (iRet)
    {
        try
        {
            ProbeAndWriteStructure(prcOut,rc,RECT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(53);
            // SetLastError(GetExceptionCode());

            iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiRectInRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRectInRegion(
    HRGN   hrgn,
    LPRECT prcl
    )
{
    RECT rc;
    BOOL bRet;

    if (prcl)
    {
        RECT   rclTmp;
        bRet = TRUE;

        try
        {
            rclTmp = ProbeAndReadStructure(prcl,RECT);

            //
            // Order the rectangle
            //

            if (rclTmp.left > rclTmp.right)
            {
                rc.left = rclTmp.right;
                rc.right = rclTmp.left;
            }
            else
            {
                rc.left = rclTmp.left;
                rc.right = rclTmp.right;
            }

            if (rclTmp.top > rclTmp.bottom)
            {
                rc.top = rclTmp.bottom;
                rc.bottom = rclTmp.top;
            }
            else
            {
                rc.top = rclTmp.top;
                rc.bottom = rclTmp.bottom;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(54);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }

        if (bRet)
        {
            bRet = GreRectInRegion(hrgn,&rc);

            if (bRet)
            {
                try
                {
                    ProbeAndWriteStructure(prcl,rc,RECT);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(55);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiPtInRegion()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiPtInRegion(
    HRGN hrgn,
    int  x,
    int  y
    )
{
    return(GrePtInRegion(hrgn,x,y));
}



/******************************Public*Routine******************************\
* NtGdiGetDIBitsInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetDIBitsInternal(
    HDC          hdc,
    HBITMAP      hbm,
    UINT         iStartScan,
    UINT         cScans,
    LPBYTE       pBits,
    LPBITMAPINFO pbmi,
    UINT         iUsage,
    UINT         cjMaxBits,
    UINT         cjMaxInfo
    )
{
    int   iRet = 0;
    ULONG cjHeader = 0;
    BOOL  bNullWidth = TRUE;
    HANDLE hSecure = 0;

    union
    {
        BITMAPINFOHEADER bmih;
        BITMAPCOREHEADER bmch;
    } bmihTmp;

    PBITMAPINFO pbmiTmp = (PBITMAPINFO)&bmihTmp.bmih;

    // do some up front validation

    if (((iUsage != DIB_RGB_COLORS) &&
         (iUsage != DIB_PAL_COLORS) &&
         (iUsage != DIB_PAL_INDICES)) ||
        (pbmi == NULL) ||
        (hbm  == NULL))
    {
        return(0);
    }

    if (cScans == 0)
        pBits = (PVOID) NULL;

    try
    {
        //
        // pbmi might not be aligned.
        // First probe to get the size of the structure
        // located in the first DWORD. Later, probe the
        // actual structure size
        //

        ProbeForRead(pbmi,sizeof(DWORD),sizeof(BYTE));

        // If the bitcount is zero, we will return only the bitmap info or core
        // header without the color table.  Otherwise, we always return the bitmap
        // info with the color table.

        {
            ULONG StructureSize = pbmi->bmiHeader.biSize;

            //
            // probe the correct structure size,
            // so that we can read/write entire of bitmap header.
            //

            ProbeForWrite(pbmi,StructureSize,sizeof(BYTE));

            if (pBits == (PVOID) NULL)
            {
                if ((StructureSize == sizeof(BITMAPCOREHEADER)) &&
                    (((PBITMAPCOREINFO) pbmi)->bmciHeader.bcBitCount == 0))
                {
                    cjHeader = sizeof(BITMAPCOREHEADER);
                }
                else if ((StructureSize >= sizeof(BITMAPINFOHEADER)) &&
                         (pbmi->bmiHeader.biBitCount == 0))
                {
                    cjHeader = sizeof(BITMAPINFOHEADER);
                }
            }
        }

        // we just need the header so copy it.

        if (cjHeader)
        {
            RtlCopyMemory(pbmiTmp,pbmi,cjHeader);
            pbmiTmp->bmiHeader.biSize = cjHeader;
        }
        else
        {
            // We need to set biClrUsed to 0 so GreGetBitmapSize computes
            // the correct values.  biClrUsed is not a input, just output.

            if (pbmi->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
            {
                // NOTE: We are going to modify bitmap header
                // in user mode memory here
                // that's why we need to do ProbeWrite()

                pbmi->bmiHeader.biClrUsed = 0;
            }

            // We need more than just the header.  This may include bits.
            // Compute the the full size of the BITMAPINFO

            cjHeader = GreGetBitmapSize(pbmi,iUsage);

            if (cjHeader)
            {
                pbmiTmp = PALLOCMEM(cjHeader,'pmtG');

                if (pbmiTmp)
                {
                    // The earlier write probe does not probe all of the
                    // memory we might read in this case.

                    ProbeAndReadBuffer(pbmiTmp,pbmi,cjHeader);

                    // Now that it is safe, make sure it hasn't changed

                    if (GreGetBitmapSize(pbmiTmp,iUsage) != cjHeader)
                    {
                        cjHeader = 0;
                    }
                    else
                    {
                        // We need to set biClrUsed to 0 so GreGetBitmapSize computes
                        // the correct values.  biClrUsed is not a input, just output.

                        if (pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
                        {
                            pbmiTmp->bmiHeader.biClrUsed = 0;
                        }

                        // Get iStartScan and cNumScan in a valid range.

                        if (cScans)
                        {
                            if (pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
                            {
                                ULONG ulHeight = ABS(pbmiTmp->bmiHeader.biHeight);

                                iStartScan = MIN(ulHeight, iStartScan);
                                cScans     = MIN((ulHeight - iStartScan), cScans);

                                bNullWidth = (pbmiTmp->bmiHeader.biWidth    == 0) ||
                                             (pbmiTmp->bmiHeader.biPlanes   == 0) ||
                                             (pbmiTmp->bmiHeader.biBitCount == 0);
                            }
                            else
                            {
                                LPBITMAPCOREHEADER pbmc = (LPBITMAPCOREHEADER)pbmiTmp;

                                iStartScan = MIN((UINT)pbmc->bcHeight, iStartScan);
                                cScans     = MIN((UINT)(pbmc->bcHeight - iStartScan), cScans);

                                bNullWidth = (pbmc->bcWidth    == 0) ||
                                             (pbmc->bcPlanes   == 0) ||
                                             (pbmc->bcBitCount == 0);
                            }
                        }
                    }
                }
            }
        }

        if (cjHeader && pBits && pbmiTmp)
        {
            // if they passed a buffer and it isn't BI_RGB,
            // they must supply buffer size, 0 is an illegal value

            if ((pbmiTmp->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) &&
                ((pbmiTmp->bmiHeader.biCompression == BI_RLE8) ||
                 (pbmiTmp->bmiHeader.biCompression == BI_RLE4))       &&
                (pbmiTmp->bmiHeader.biSizeImage == 0))
            {
                cjHeader = 0;
            }
            else
            {
                if (cjMaxBits == 0)
                    cjMaxBits = GreGetBitmapBitsSize(pbmiTmp);

                if (cjMaxBits)
                {
                    ProbeForWrite(pBits,cjMaxBits,sizeof(DWORD));
                    hSecure = MmSecureVirtualMemory(pBits, cjMaxBits, PAGE_READWRITE);
                }

                if (hSecure == 0)
                {
                    cjHeader = 0;
                }
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(56);
        cjHeader = 0;
    }

    // did we have an error

    if ((pBits && bNullWidth) || (cjHeader == 0) || (pbmiTmp == NULL))
    {
        //GdiSetLastError(ERROR_INVALID_PARAMETER);
        iRet = 0;
    }
    else
    {
        // do the work

        iRet = GreGetDIBitsInternal(
                            hdc,hbm,
                            iStartScan,cScans,
                            pBits,pbmiTmp,
                            iUsage,cjMaxBits,cjHeader
                            );

        // copy out the header

        if (iRet)
        {
            try
            {
                RtlCopyMemory(pbmi,pbmiTmp,cjHeader);

                // WINBUG #83055 2-7-2000 bhouse Investigate need to unlock bits
                // Old Comment:
                //    - we also need to unlock the bits
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(57);
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }

        }
    }

    if (hSecure)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    if (pbmiTmp && (pbmiTmp != (PBITMAPINFO)&bmihTmp.bmih))
        VFREEMEM(pbmiTmp);

    return(iRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextExtent(
*
* History:
*  07-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTextExtent(
    HDC     hdc,
    LPWSTR  lpwsz,
    int     cwc,
    LPSIZE  psize,
    UINT    flOpts
    )
{
    SIZE size;
    PWSZ pwszCapt = NULL;
    WCHAR Localpwsz[LOCAL_CWC_MAX];
    BOOL UseLocals;

    BOOL bRet = FALSE;

    if (cwc >= 0)
    {
        if (cwc == 0)
        {
            size.cx = 0;
            size.cy = 0;

            bRet = TRUE;
        }
        else
        {
            if ( cwc > LOCAL_CWC_MAX ) {
                UseLocals = FALSE;
            } else {
                UseLocals = TRUE;
            }

            //
            // capture the string
            //

            if (lpwsz != NULL)
            {
                try
                {
                    if ( UseLocals )
                    {
                        pwszCapt = Localpwsz;
                    }
                    else
                    {
                        if (!BALLOC_OVERFLOW1(cwc,WCHAR))
                        {
                            pwszCapt = (PWSZ) AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
                        }
                    }

                    if (pwszCapt)
                    {
                        ProbeAndReadAlignedBuffer(pwszCapt, lpwsz, cwc*sizeof(WCHAR), sizeof(WCHAR));
                        bRet = TRUE;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(58);
                    // SetLastError(GetExceptionCode());

                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                bRet = GreGetTextExtentW(hdc, pwszCapt, cwc, &size, flOpts);
            }

            if (!UseLocals && pwszCapt)
            {
                FreeTmpBuffer(pwszCapt);
            }
        }

        //
        // Write the value back into the user mode buffer
        //

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,size,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(59);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return (bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetTextMetricsW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTextMetricsW(
    HDC            hdc,
    TMW_INTERNAL * ptm,
    ULONG cj
    )
{

    BOOL bRet = FALSE;
    TMW_INTERNAL tmw;

    if (cj <= sizeof(tmw))
    {
        bRet = GreGetTextMetricsW(hdc,&tmw);

        if (bRet)
        {
            try
            {
                ProbeAndWriteAlignedBuffer(ptm,&tmw,cj, sizeof(DWORD));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(60);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextFaceW()
*
* History:
* 10-Mar-1995 -by- Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetTextFaceW(
    HDC    hdc,
    int    cChar,
    LPWSTR pszOut,
    BOOL   bAliasName
    )
{
    int    cRet = 0;
    BOOL   bStatus = TRUE;
    PWCHAR pwsz_km = (PWCHAR)NULL;

    if ((cChar > 0) && (pszOut))
    {
        if (!BALLOC_OVERFLOW1(cChar,WCHAR))
        {
            pwsz_km = AllocFreeTmpBuffer(cChar * sizeof(WCHAR));
        }

        if (pwsz_km == (PWCHAR)NULL)
        {
            bStatus = FALSE;
        }
    }

    if (bStatus)
    {
        cRet = GreGetTextFaceW(hdc,cChar,pwsz_km, bAliasName);

        if ((cRet > 0) && (pszOut))
        {

            ASSERTGDI(cRet <= cChar, "GreGetTextFaceW, cRet too big\n");
            try
            {
                ProbeAndWriteBuffer(pszOut,pwsz_km,cRet * sizeof(WCHAR));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(61);
                // SetLastError(GetExceptionCode());
                cRet = 0;
            }
        }

        if (pwsz_km != (PWCHAR)NULL)
        {
            FreeTmpBuffer(pwsz_km);
        }
    }
    return(cRet);
}
/******************************Public*Routine******************************\
* NtGdiFontIsLinked()
*
* History:
* 9-July-1998 -by- Yung-Jen Tony Tsai [marke]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiFontIsLinked(
    HDC    hdc
    )
{
    return GreFontIsLinked(hdc);
}

/****************************************************************************
*  NtGdiQueryFonts
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

INT NtGdiQueryFonts(
    PUNIVERSAL_FONT_ID pufiFontList,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
    )
{
    INT iRet = 0;
    PUNIVERSAL_FONT_ID pufi = NULL;
    LARGE_INTEGER TimeStamp;

    if( ( nBufferSize > 0 ) && ( pufiFontList != NULL ) )
    {
        if (!BALLOC_OVERFLOW1(nBufferSize,UNIVERSAL_FONT_ID))
        {
            pufi = AllocFreeTmpBuffer(nBufferSize * sizeof(UNIVERSAL_FONT_ID));
        }

        if( pufi == NULL )
        {
            iRet = -1 ;
        }
    }

    if( iRet != -1 )
    {
        iRet = GreQueryFonts(pufi, nBufferSize, &TimeStamp );

        if( iRet != -1 )
        {
            try
            {
                ProbeAndWriteStructure(pTimeStamp,TimeStamp,LARGE_INTEGER);

                if( pufiFontList )
                {
                    ProbeAndWriteAlignedBuffer(pufiFontList,pufi,
                                  sizeof(UNIVERSAL_FONT_ID)*nBufferSize, sizeof(DWORD));
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(62);
                iRet = -1;
            }

        }
    }

    if( pufi != NULL )
    {
        FreeTmpBuffer( pufi );
    }

    if( iRet == -1 )
    {
        // We need to set the last error here to something because the spooler
        // code that calls this relies on there being a non-zero error code
        // in the case of failure.  Since we really have no idea I will just
        // set this to ERROR_NOT_ENOUGH_MEMORY which would be the most likely
        // reason for a failure

        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(iRet);

}

BOOL
GreExtTextOutRect(
    HDC     hdc,
    LPRECT  prcl
    );


/******************************Public*Routine******************************\
* NtGdiExtTextOutW()
*
* History:
*  06-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

BOOL NtGdiExtTextOutW
(
    HDC     hdc,
    int     x,                  // Initial x position
    int     y,                  // Initial y position
    UINT    flOpts,             // Options
    LPRECT  prcl,               // Clipping rectangle
    LPWSTR  pwsz,               // UNICODE Character array
    int     cwc,                // char count
    LPINT   pdx,                // Character spacing
    DWORD   dwCodePage          // Code page
)
{
    RECT newRect;
    BOOL bRet;
    BYTE CaptureBuffer[TEXT_CAPTURE_BUFFER_SIZE];
    BYTE *pjAlloc;
    BYTE *pjCapture;
    BYTE *pjStrobj;
    LONG cjDx;
    LONG cjStrobj;
    LONG cjString;
    LONG cj;

// huge values of cwc will lead to an overflow below causing the system to
// crash

    if ((cwc < 0) || (cwc > 0xffff))
    {
        return(FALSE);
    }

    if (prcl)
    {
        if (flOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            try
            {
                newRect = ProbeAndReadStructure(prcl,RECT);
                prcl = &newRect;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(63);
                // SetLastError(GetExceptionCode());

                return FALSE;
            }
        }
        else
            prcl = NULL;
    }

    // 0 char case, pass off to special case code.

    if (cwc == 0)
    {
        if ((prcl != NULL) && (flOpts & ETO_OPAQUE))
        {
            bRet = GreExtTextOutRect(hdc, prcl);
        }
        else
        {
            // Bug fix, we have to return TRUE here, MS Publisher
            // doesn't work otherwise.  Not really that bad, we
            // did succeed to draw nothing.

            bRet = TRUE;
        }
    }
    else
    {
        //
        // Make sure there is a rectangle or a string if we need them:
        //

        if ( ((flOpts & (ETO_CLIPPED | ETO_OPAQUE)) && (prcl == NULL)) ||
             (pwsz == NULL) )
        {
            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;

            //
            // We allocate a single buffer to hold the captured copy of
            // the pdx array (if there is one), room for the STROBJ,
            // and to hold the captured copy of the string (in that
            // order).
            //
            // NOTE: With the appropriate exception handling in the
            //       body of ExtTextOutW, we might not need to copy
            //       these buffers:
            //

            //
            // see if it is for a user mode printer driver
            //

            cjDx     = 0;                             // dword sized
            cjStrobj = SIZEOF_STROBJ_BUFFER(cwc);     // dword sized
            cjString = cwc * sizeof(WCHAR);           // not dword sized

            if (pdx)
            {
                cjDx = cwc * sizeof(INT);             // dword sized
                if (flOpts & ETO_PDY)
                    cjDx *= 2; // space for pdy array
            }
            cj = ALIGN_PTR(cjDx) + cjStrobj + cjString;

            if (cj <= TEXT_CAPTURE_BUFFER_SIZE)
            {
                pjAlloc   = NULL;
                pjCapture = (BYTE*) &CaptureBuffer;
            }
            else
            {
                pjAlloc   = AllocFreeTmpBuffer(cj);
                pjCapture = pjAlloc;
                if (pjAlloc == NULL)
                    return(FALSE);
            }

            if (pdx)
            {
                try
                {
                // NOTE: Works95 passes byte aligned pointers for
                // this.  Since we copy it any ways, this is not
                // really a problem and it is compatible with NT 3.51.

                    ProbeForRead(pdx, cjDx, sizeof(BYTE));
                    RtlCopyMemory(pjCapture, pdx, cjDx);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(64);
                    bRet = FALSE;
                }

                pdx = (INT*) pjCapture;
                pjCapture += ALIGN_PTR(cjDx);
            }

            pjStrobj = pjCapture;
            pjCapture += cjStrobj;

            ASSERTGDI((((ULONG_PTR) pjCapture) & (sizeof(PVOID)-1)) == 0,
                      "Buffers should be ptr aligned");

            try
            {
                ProbeForRead(pwsz, cwc*sizeof(WCHAR), sizeof(WCHAR));
                RtlCopyMemory(pjCapture, pwsz, cwc*sizeof(WCHAR));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(65);
                bRet = FALSE;
            }

            if (bRet)
            {
                bRet = GreExtTextOutWInternal(hdc,
                                      x,
                                      y,
                                      flOpts,
                                      prcl,
                                      (LPWSTR) pjCapture,
                                      cwc,
                                      pdx,
                                      pjStrobj,
                                      dwCodePage);
            }

            if (pjAlloc)
            {
                FREEALLOCTEMPBUFFER(pjAlloc);
            }
        }
    }

    return bRet;
}


/************************Public*Routine**************************\
* NtGdiConsoleTextOut()
*
* History:
*  23-Mar-1998 -by-  Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

#define CONSOLE_BUFFER 128

BOOL NtGdiConsoleTextOut(
    HDC        hdc,
    POLYTEXTW *lpto,            // Ptr to array of polytext structures
    UINT       nStrings,        // number of polytext structures
    RECTL     *prclBounds
)
{
    BOOL        bStatus = TRUE;
    ULONG       ulSize = nStrings * sizeof(POLYTEXTW);
    POLYTEXTW   *lptoTmp = NULL, *ppt;
    RECTL       rclBoundsTmp;
    PBYTE       pjBuffer, pjBufferEnd;
    ULONG       aulTmp[CONSOLE_BUFFER];

    if (nStrings == 0)
        return TRUE;

    if (!lpto)
        return FALSE;

    if (prclBounds)
    {
        try
        {
            rclBoundsTmp = ProbeAndReadStructure(prclBounds, RECTL);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiConsoleTextOut invalid prclBounds\n");
            return FALSE;
        }
    }

    if (!BALLOC_OVERFLOW1(nStrings,POLYTEXTW))
    {
        try
        {
            ProbeForRead(lpto, nStrings * sizeof(POLYTEXTW), sizeof(ULONG));

            for (ppt = lpto; ppt < lpto + nStrings; ppt++)
            {
                int n = ppt->n;
                ULONG ulTmp;                // used to check for
                                            // overflow of ulSize

                //
                // Pull count from each, also check for
                // non-zero length and NULL string
                //

                ulTmp = ulSize;
                ulSize += n * sizeof(WCHAR);

                if (BALLOC_OVERFLOW1(n, WCHAR) ||
                    (ulSize < ulTmp) ||
                    (ppt->pdx != (int *)NULL) ||
                    ((n != 0) && (ppt->lpstr == NULL)))
                {
                    bStatus = FALSE;
                    break;
                }
            }

        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            bStatus = FALSE;
            WARNING("NtGdiConsoleTextOut invalid lpto\n");
        }
    }
    else
    {
        bStatus = FALSE;
    }

    if (bStatus)
    {
        if (ulSize > (CONSOLE_BUFFER * sizeof(ULONG)))
        {
            lptoTmp = AllocFreeTmpBuffer(ulSize);
        }
        else
        {
            lptoTmp = (POLYTEXTW *)aulTmp;
        }

        if (lptoTmp)
        {
            try
            {
                ProbeAndReadBuffer(lptoTmp, lpto, nStrings * sizeof(POLYTEXTW));
                pjBuffer = ((BYTE*)lptoTmp) + nStrings * sizeof(POLYTEXTW);
                pjBufferEnd = pjBuffer + ulSize;

                for (ppt = lptoTmp; ppt < lptoTmp + nStrings; ppt++)
                {
                    if (ppt->n)
                    {
                        ULONG StrSize = ppt->n * sizeof(WCHAR);

                        if (ppt->pdx || (ppt->lpstr == NULL))
                        {
                            bStatus = FALSE;
                            break;
                        }

                        if (BALLOC_OVERFLOW1(ppt->n, WCHAR) || ((pjBuffer + StrSize) > pjBufferEnd))
                        {
                            bStatus = FALSE;
                            break;
                        }

                        ProbeAndReadAlignedBuffer(pjBuffer, ppt->lpstr, StrSize, sizeof(WCHAR));
                        ppt->lpstr = (LPWSTR)pjBuffer;
                        pjBuffer += StrSize;
                    }
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bStatus = FALSE;
                WARNING("NtGdiConsoleTextOut() failed to copy lpto\n");
            }

            if (bStatus)
            {
                bStatus = GreConsoleTextOut(hdc, lptoTmp, nStrings, prclBounds ? &rclBoundsTmp : NULL);
            }

            if (lptoTmp != (POLYTEXTW *)aulTmp)
                FreeTmpBuffer(lptoTmp);
        }
        else
        {
            WARNING("NtGdiConsoleTextOut() failed to alloc mem\n");
        }
    }

    return bStatus;
}


/******************************Public*Routine******************************\
*
* BOOL bCheckAndCapThePath, used in add/remove font resoruce
*
* History:
*  11-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bCheckAndCapThePath (
    WCHAR          *pwszUcPath,   // output
    WCHAR          *pwszFiles,    // input
    ULONG           cwc,
    ULONG           cFiles
    )
{
    ULONG cFiles1 = 1; // for consistency checking
    BOOL  bRet = TRUE;
    ULONG iwc;

    ASSERTGDI(!BALLOC_OVERFLOW1(cwc,WCHAR),
              "caller should check for overflow\n");

    ProbeForRead(pwszFiles, cwc * sizeof(WCHAR), sizeof(CHAR));

    if (pwszFiles[cwc - 1] == L'\0')
    {
    // this used to be done later, in gdi code which now expects capped string

        cCapString(pwszUcPath, pwszFiles, cwc);

    // replace separators by zeros, want zero terminated strings in
    // the engine

        for (iwc = 0; iwc < cwc; iwc++)
        {
            if (pwszUcPath[iwc] == PATH_SEPARATOR)
            {
                pwszUcPath[iwc] = L'\0';
                cFiles1++;
            }
        }

    // check consistency

        if (cFiles != cFiles1)
            bRet = FALSE;

    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}



// MISC FONT API's

/******************************Public*Routine******************************\
* NtGdiAddFontResourceW()
*
* History:
*  Wed 11-Oct-1995 -by- Bodin Dresevic [BodinD]
*  Rewrote it
\**************************************************************************/

#define CWC_PATH 80

int
APIENTRY
NtGdiAddFontResourceW(
    WCHAR          *pwszFiles,
    ULONG           cwc,
    ULONG           cFiles,
    FLONG           f,
    DWORD           dwPidTid,
    DESIGNVECTOR   *pdv
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    int    iRet = 0;
    ULONG  iwc;
    DESIGNVECTOR   dvTmp;
    DWORD  cjDV = 0;
    DWORD  dvNumAxes = 0;

    try
    {
        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (cwc <= 4 * (MAX_PATH + 1))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }
            else
            {
                iRet = 0;
                WARNING("NtGdiAddFontResourceW: pwszFiles longer than 4*(MAX_PATH+1)\n");
            }

            if (pwszPath)
            {
                // RtlUpcaseUnicodeString() doesn't initialize the buffer
                // if it is bigger than 0x7FFF

                iRet = (int)bCheckAndCapThePath(pwszPath,pwszFiles,cwc,cFiles);
            }
        }

        if (iRet && pdv)
        {
            // get the dvNumAxes first
            ProbeForRead(pdv, offsetof(DESIGNVECTOR,dvValues) , sizeof(BYTE));
            dvNumAxes = pdv->dvNumAxes;

            if ((dvNumAxes > 0) && (dvNumAxes <= MM_MAX_NUMAXES))
            {
                cjDV = SIZEOFDV(dvNumAxes);
                if (!BALLOC_OVERFLOW1(cjDV, BYTE))
                {
                    ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                    pdv = &dvTmp;
                }
                else
                    iRet = 0;
            }
            else if (dvNumAxes == 0)
            {
                pdv = 0;
            }
            else
            {
                iRet = 0;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = 0;
        WARNINGX(95);
    }

    if (iRet)
        iRet = GreAddFontResourceWInternal(pwszPath, cwc, cFiles,f,dwPidTid, pdv, cjDV);

    if (iRet)   //Increase global time stamp for realization info
        (gpGdiSharedMemory->timeStamp)++;

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    TRACE_FONT(("Leaving: NtGdiAddFontResourceW"));

    return iRet;
}


/*************Public*Routine***************************\
* BOOL APIENTRY NtGdiUnmapMemFont                      *
*                                                      *
* History:                                             *
*  Jul-03-1996   -by-    Xudong Wu [TessieW]           *
*                                                      *
* Wrote it.                                            *
*******************************************************/
BOOL APIENTRY NtGdiUnmapMemFont(PVOID pvView)
{
// we may need this if we ever figure out how to map the memory font to
// the application's address space

    return 1;
}


/***************Public*Routine**************************\
* HANDLE NtGdiAddFontMemResourceEx()                    *
*                                                       *
* History:                                              *
*  09-Jun-1996   -by-    Xudong Wu [TessieW]            *
*                                                       *
* Wrote it.                                             *
********************************************************/
HANDLE APIENTRY NtGdiAddFontMemResourceEx
(
    PVOID   pvBuffer,
    ULONG   cjBuffer,
    DESIGNVECTOR    *pdv,
    DWORD   cjDV,
    DWORD   *pNumFonts
)
{
    BOOL          bOK = TRUE;
    HANDLE        hMMFont = 0;
    DESIGNVECTOR  dvTmp;

    // check the size and pointer

    if ((cjBuffer == 0) || (pvBuffer == NULL) || (pNumFonts == NULL))
    {
        return 0;
    }

    __try
    {
        if (cjDV)
        {
            if (cjDV <= SIZEOFDV(MM_MAX_NUMAXES))
            {
                ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                pdv = &dvTmp;
            }
            else
            {
                bOK = FALSE;
            }
        }
        else
        {
            pdv = NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bOK = FALSE;
        WARNING("NtGdiAddFontMemResource() try-except\n");
    }

    if (bOK)
    {
        DWORD   cFonts;

        if (hMMFont = GreAddFontMemResourceEx(pvBuffer, cjBuffer, pdv, cjDV, &cFonts))
        {
            __try
            {
                ProbeAndWriteUlong(pNumFonts, cFonts);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                GreRemoveFontMemResourceEx(hMMFont);
                hMMFont = 0;
            }
        }
    }

    return hMMFont;
}


/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiRemoveFontResourceW
*
* History:
*  28-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiRemoveFontResourceW(
    WCHAR  *pwszFiles,
    ULONG   cwc,
    ULONG   cFiles,
    ULONG   fl,
    DWORD   dwPidTid,
    DESIGNVECTOR   *pdv
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    BOOL   bRet = FALSE;
    DESIGNVECTOR   dvTmp;
    DWORD  cjDV = 0, dvNumAxes = 0;

    TRACE_FONT(("Entering: NtGdiRemoveFontResourceW(\"%ws\",%-#x,%-#x)\n",pwszFiles, cwc,cFiles));
    try
    {

        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (!BALLOC_OVERFLOW1(cwc,WCHAR))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }

            if (pwszPath)
            {
                bRet = bCheckAndCapThePath(pwszPath, pwszFiles, cwc, cFiles);
            }
        }

        if (bRet && pdv)
        {
            // get the dvNumAxes first
            ProbeForRead(pdv, offsetof(DESIGNVECTOR,dvValues) , sizeof(BYTE));
            dvNumAxes = pdv->dvNumAxes;

            if ((dvNumAxes > 0) && (dvNumAxes <= MM_MAX_NUMAXES))
            {
                cjDV = SIZEOFDV(dvNumAxes);
                if (!BALLOC_OVERFLOW1(cjDV, BYTE))
                {
                    ProbeAndReadBuffer(&dvTmp, pdv, cjDV);
                    pdv = &dvTmp;
                }
                else
                    bRet = FALSE;
            }
            else if (dvNumAxes == 0)
            {
                pdv = 0;
            }
            else
            {
                bRet = FALSE;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        WARNINGX(96);
    }

    if (bRet)
        bRet = GreRemoveFontResourceW(pwszPath, cwc, cFiles, fl, dwPidTid, pdv, cjDV);

    if (bRet)   //Increase global time stamp for realization info
        (gpGdiSharedMemory->timeStamp)++;

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    TRACE_FONT(("Leaving: NtGdiRemoveFontResourceW"));

    return bRet;
}


/***************Public*Routine**************************\
* NtGdiRemoveFontMemResourceEx()                        *
*                                                       *
* History:                                              *
*  09-Jun-1996   -by-    Xudong Wu [TessieW]             *
*                                                       *
* Wrote it.                                             *
********************************************************/
BOOL
APIENTRY
NtGdiRemoveFontMemResourceEx(HANDLE hMMFont)
{
    BOOL    bRet = TRUE;

    if (hMMFont == 0)
    {
        return FALSE;
    }

    if (bRet)
    {
        bRet = GreRemoveFontMemResourceEx(hMMFont);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiEnumFontClose()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiEnumFontClose(
    ULONG_PTR idEnum
    )
{
    return(bEnumFontClose(idEnum));
}

/******************************Public*Routine******************************\
* NtGdiEnumFontChunk()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiEnumFontChunk(
    HDC            hdc,
    ULONG_PTR       idEnum,
    ULONG          cjEfdw,
    ULONG         *pcjEfdw,
    PENUMFONTDATAW pefdw
    )
{
    HANDLE hSecure;
    BOOL   bRet = TRUE;
    ULONG  cjEfdwRet = 0;

    try
    {
         ProbeForWrite(pefdw, cjEfdw, sizeof(DWORD));

         hSecure = MmSecureVirtualMemory(pefdw, cjEfdw, PAGE_READWRITE);

         if (!hSecure)
         {
            bRet = FALSE;
         }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(66);
        // SetLastError(GetExceptionCode());
        bRet = FALSE;
    }

    if (bRet)
    {
        try
        {
            bRet = bEnumFontChunk(hdc,idEnum,cjEfdw,&cjEfdwRet,pefdw);
            ProbeAndWriteUlong(pcjEfdw,cjEfdwRet);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(105);
            bRet = FALSE;
        }

        MmUnsecureVirtualMemory(hSecure);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiEnumFontOpen()
*
* History:
*  08-Mar-1995 Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

ULONG_PTR
APIENTRY
NtGdiEnumFontOpen(
    HDC     hdc,
    ULONG   iEnumType,
    FLONG   flWin31Compat,
    ULONG   cwchMax,
    LPWSTR  pwszFaceName,
    ULONG   lfCharSet,
    ULONG   *pulCount
    )
{
    ULONG       cwchFaceName;
    PWSTR       pwszKmFaceName = NULL;
    ULONG_PTR    ulRet = 0;
    BOOL        bRet = TRUE;
    ULONG       ulCount = 0;


    if (pwszFaceName != (PWSZ)NULL)
    {
        if ((cwchMax == 0) || (cwchMax > LF_FACESIZE))
            return FALSE;

        if (!BALLOC_OVERFLOW1(cwchMax,WCHAR))
        {
            pwszKmFaceName = (PWSZ)AllocFreeTmpBuffer(cwchMax * sizeof(WCHAR));
        }

        if (pwszKmFaceName != (PWSZ)NULL)
        {
            try
            {
                ProbeAndReadAlignedBuffer(pwszKmFaceName,pwszFaceName, cwchMax * sizeof(WCHAR), sizeof(WCHAR));

            // GreEnumFontOpen expects zero terminated sting

                pwszKmFaceName[cwchMax-1] = 0;

            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(66);
                // SetLastError(GetExceptionCode());
                bRet = FALSE;
            }
        }
        else
        {
            // SetLastError(GetExceptionCode());
                bRet = FALSE;
        }
    }
    else
    {
        pwszKmFaceName = (PWSZ)NULL;
        cwchMax   = 0;
    }

    if (bRet)
    {

        ulRet = GreEnumFontOpen(hdc,iEnumType,flWin31Compat,cwchMax,
                                (PWSZ)pwszKmFaceName, lfCharSet,&ulCount);

        if (ulRet)
        {
            try
            {
                 ProbeAndWriteUlong(pulCount,ulCount);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(67);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }

    }

    if (pwszKmFaceName != (PWSTR)NULL)
    {
        FreeTmpBuffer(pwszKmFaceName);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* NtGdiGetFontResourceInfoInternalW()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetFontResourceInfoInternalW(
    LPWSTR   pwszFiles,
    ULONG    cwc,
    ULONG    cFiles,
    UINT     cjIn,
    LPDWORD  pdwBytes,
    LPVOID   pvBuf,
    DWORD    iType
    )
{
    WCHAR  awcPath[CWC_PATH];
    WCHAR *pwszPath = NULL; // essential initialization
    BOOL   bRet = FALSE;

    SIZE_T dwBytesTmp;

    LOGFONTW lfw;
    LPVOID   pvBufTmp = NULL;

    TRACE_FONT(("Entering: NtGdiGetFontResourceInfoInternalW(\"%ws\",%-#x,%-#x)\n",pwszFiles, cwc,cFiles));

    try
    {
        if (cwc > 1)
        {
            if (cwc <= CWC_PATH)
            {
                pwszPath = awcPath;
            }
            else if (!BALLOC_OVERFLOW1(cwc,WCHAR))
            {
                pwszPath = AllocFreeTmpBuffer(cwc * sizeof(WCHAR));
            }

            if (pwszPath)
            {
                bRet = bCheckAndCapThePath(pwszPath, pwszFiles, cwc, cFiles);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(97);
    }

    if (cjIn > sizeof(LOGFONTW))
    {
        if (!BALLOC_OVERFLOW1(cjIn, BYTE))
        {
            pvBufTmp = PALLOCMEM(cjIn, 'pmtG');

            if (!pvBufTmp)
            {
                WARNING("NtGdiGetFontResourceInfoInternalW: failed to allocate memory\n");
                bRet = FALSE;
            }
        }
    }
    else
    {
        pvBufTmp = (PVOID)&lfw;
    }

    if (bRet && (bRet = GetFontResourceInfoInternalW(pwszPath,cwc, cFiles, cjIn,
                                            &dwBytesTmp, pvBufTmp, iType)))
    {
        try
        {
            ProbeAndWriteUlong(pdwBytes, (ULONG) dwBytesTmp);

            if (cjIn)
            {
                ProbeAndWriteBuffer(pvBuf, pvBufTmp, cjIn);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(110);
        }
    }

    if (pwszPath && (pwszPath != awcPath))
        FreeTmpBuffer(pwszPath);

    if (pvBufTmp && (pvBufTmp != (PVOID)&lfw))
    {
        VFREEMEM(pvBufTmp);
    }

    TRACE_FONT(("Leaving: NtGdiGetFontResourceInfoInternalW\n"));

    return bRet;

}


ULONG
APIENTRY
NtGdiGetEmbedFonts()
{
    return GreGetEmbedFonts();
}

BOOL
APIENTRY
NtGdiChangeGhostFont(KERNEL_PVOID *pfontID, BOOL bLoad)
{
    BOOL bRet = TRUE;
    VOID *fontID;

    try
    {
        ProbeAndReadBuffer(&fontID, pfontID, sizeof(VOID*));
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    bRet = bRet && GreChangeGhostFont(fontID, bLoad);

    return bRet;
}


/******************************Public*Routine******************************\
* NtGdiGetUFI()
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*  01-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetUFI(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi,
    DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
    FLONG  *pfl
    )
{
    UNIVERSAL_FONT_ID ufiTmp;
    BOOL  bRet = TRUE;
    FLONG flTmp;
    DESIGNVECTOR dvTmp;
    ULONG        cjDVTmp;
    ULONG        ulBaseCheckSum = 0;

    bRet = GreGetUFI(hdc, &ufiTmp, &dvTmp, &cjDVTmp, &ulBaseCheckSum, &flTmp, NULL);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pufi,ufiTmp,UNIVERSAL_FONT_ID);
            ProbeAndWriteUlong(pfl, flTmp);

            if ((flTmp & FL_UFI_DESIGNVECTOR_PFF) && pdv)
            {
                ProbeAndWriteBuffer(pdv, &dvTmp, cjDVTmp);
                ProbeAndWriteUlong(pcjDV, cjDVTmp);
                ProbeAndWriteUlong(pulBaseCheckSum, ulBaseCheckSum);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


BOOL
APIENTRY
NtGdiGetEmbUFI(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi,
    DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
    FLONG  *pfl,
    KERNEL_PVOID *pEmbFontID
    )
{
    UNIVERSAL_FONT_ID ufiTmp;
    BOOL  bRet = TRUE;
    FLONG flTmp;
    DESIGNVECTOR dvTmp;
    ULONG        cjDVTmp;
    ULONG        ulBaseCheckSum = 0;
    VOID        *fontID;

    bRet = GreGetUFI(hdc, &ufiTmp, &dvTmp, &cjDVTmp, &ulBaseCheckSum, &flTmp, &fontID);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pufi,ufiTmp,UNIVERSAL_FONT_ID);
            ProbeAndWriteUlong(pfl, flTmp);
            ProbeAndWriteBuffer(pEmbFontID, &fontID, sizeof(VOID*));

            if ((flTmp & FL_UFI_DESIGNVECTOR_PFF) && pdv)
            {
                ProbeAndWriteBuffer(pdv, &dvTmp, cjDVTmp);
                ProbeAndWriteUlong(pcjDV, cjDVTmp);
                ProbeAndWriteUlong(pulBaseCheckSum, ulBaseCheckSum);
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(68);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetUFIBits()
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*  01-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetUFIBits(
    PUNIVERSAL_FONT_ID pufi,
    ULONG cjMaxBytes,
    PVOID pjBits,
    PULONG pulFileSize,
    FLONG  fl
    )
{
    UNIVERSAL_FONT_ID ufiTmp;
    PVOID pjBitsTmp;
    ULONG ulFileSizeTmp;
    BOOL  bRet = TRUE;

// Get the input data

    try
    {
        ufiTmp = ProbeAndReadStructure(pufi,UNIVERSAL_FONT_ID);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(69);
        // SetLastError(GetExceptionCode());
        bRet = FALSE;
    }

    if (bRet)
    {
    //alloc temp memory

        pjBitsTmp = (cjMaxBytes) ? AllocFreeTmpBuffer(cjMaxBytes) : NULL;

        if( pjBitsTmp || ( cjMaxBytes == 0 ) )
        {
            bRet = GreGetUFIBits(&ufiTmp, cjMaxBytes, pjBitsTmp, &ulFileSizeTmp, fl);

        // if didn't hit error above, retrieve filesize and pjBits back

            if (bRet)
            {
                try
                {
                    ProbeAndWriteUlong(pulFileSize,ulFileSizeTmp);

                    ProbeAndWriteAlignedBuffer(pjBits, pjBitsTmp, cjMaxBytes, sizeof(DWORD));
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(70);
                    // SetLastError(GetExceptionCode());
                    bRet = FALSE;
                }
            }

            if( pjBitsTmp )
            {
                FreeTmpBuffer(pjBitsTmp);
            }
        }
        else
        {
            //fail to alloc temp memory
            bRet = FALSE;
        }
    }

    return (bRet);
}


/**************************Public*Routine**************************\
* NtGdiGetUFIPathname()
*
* Return the font file path name according to the input ufi.
*
* History:
*  Feb-04-1997  Xudong Wu   [tessiew]
* Wrote it.
*
\*******************************************************************/
BOOL
APIENTRY
NtGdiGetUFIPathname
(
    PUNIVERSAL_FONT_ID pufi,
    ULONG* pcwc,
    LPWSTR pwszPathname,
    ULONG* pcNumFiles,
    FLONG fl,
    BOOL  *pbMemFont,
    ULONG *pcjView,
    PVOID  pvView,
    BOOL  *pbTTC,
    ULONG *piTTC
)
{
    UNIVERSAL_FONT_ID ufiTmp;
    WCHAR    awszTmp[MAX_PATH], *pwszTmp = NULL;
    COUNT   cwcTmp, cNumFilesTmp;
    BOOL  bRet = TRUE;
    BOOL  bMemFontTmp;
    PVOID  pvViewTmp = pvView;
    ULONG  cjViewTmp;
    BOOL   bTTC;
    ULONG  iTTC;

    try
    {
        ufiTmp = ProbeAndReadStructure(pufi, UNIVERSAL_FONT_ID);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(105);
        bRet = FALSE;
    }

    if (bRet && (bRet = GreGetUFIPathname(&ufiTmp,
                                          &cwcTmp,
                                          NULL, // just ask for the size
                                          &cNumFilesTmp,
                                          fl,
                                          &bMemFontTmp,
                                          &cjViewTmp,
                                          pvViewTmp,
                                          pbTTC ? &bTTC : NULL,
                                          piTTC ? &iTTC : NULL)))
    {
        if (cwcTmp <= MAX_PATH)
        {
            pwszTmp = awszTmp;
        }
        else
        {
            if (!BALLOC_OVERFLOW1(cwcTmp,WCHAR))
            {
                pwszTmp = AllocFreeTmpBuffer(cwcTmp * sizeof(WCHAR));
            }
            if (!pwszTmp)
                bRet = FALSE;
        }
    }

    if (bRet && (!bMemFontTmp) && pwszTmp)
    {
        bRet = GreGetUFIPathname(&ufiTmp,
                                 &cwcTmp,
                                 pwszTmp,
                                 &cNumFilesTmp,
                                 fl,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pbTTC ? &bTTC : NULL,
                                 piTTC ? &iTTC : NULL
                                 );
    }

    if (bRet)
    {
        try
        {
            if (pcwc)
            {
                ProbeAndWriteStructure(pcwc, cwcTmp, ULONG);
            }

            if (pwszPathname)
            {
                ProbeAndWriteBuffer(pwszPathname, pwszTmp, cwcTmp * sizeof(WCHAR));
            }

            if (pcNumFiles)
            {
                ProbeAndWriteStructure(pcNumFiles, cNumFilesTmp, ULONG);
            }

            if (bMemFontTmp)
            {
                if (pbMemFont)
                {
                    ProbeAndWriteStructure(pbMemFont, bMemFontTmp, BOOL);
                }

                if (pcjView)
                {
                    ProbeAndWriteUlong(pcjView, cjViewTmp);
                }
            }

            if (pbTTC)
            {
                ProbeAndWriteStructure(pbTTC, bTTC, BOOL);
            }

            if (piTTC)
            {
                ProbeAndWriteUlong(piTTC, iTTC);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(107);
            bRet = FALSE;
        }
    }

    if (pwszTmp && (pwszTmp != awszTmp))
    {
        FreeTmpBuffer(pwszTmp);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetLayout
*
* History:
*  29-Oct-1997 -by-  Mohamed Hassanin [mhamid]
* Wrote it.
\**************************************************************************/
DWORD
APIENTRY
NtGdiSetLayout(
    HDC hdc,
    LONG wox,
    DWORD dwLayout)
{
    return GreSetLayout(hdc, wox, dwLayout);
}

BOOL
APIENTRY
NtGdiMirrorWindowOrg(
    HDC hdc)
{
    return GreMirrorWindowOrg(hdc);
}

LONG
APIENTRY
NtGdiGetDeviceWidth(
    HDC hdc)
{
    return GreGetDeviceWidth(hdc);
}

/******************************Public*Routine******************************\
* NtGdiGetDCPoint()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetDCPoint(
    HDC     hdc,
    UINT    iPoint,
    PPOINTL pptOut
    )
{
    BOOL bRet;
    POINTL pt;

    if (bRet = GreGetDCPoint(hdc,iPoint,&pt))
    {

        // modify *pptOut only if successful

        try
        {
            ProbeAndWriteStructure(pptOut,pt,POINT);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(71);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiScaleWindowExtEx()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiScaleWindowExtEx(
    HDC    hdc,
    int    xNum,
    int    xDenom,
    int    yNum,
    int    yDenom,
    LPSIZE pszOut
    )
{
    BOOL bRet;
    SIZE sz;

    bRet = GreScaleWindowExtEx(hdc,xNum,xDenom,yNum,yDenom,&sz);

    if (bRet && pszOut)
    {
        try
        {
            ProbeAndWriteStructure(pszOut,sz,SIZE);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(73);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* NtGdiGetTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetTransform(
    HDC     hdc,
    DWORD   iXform,
    LPXFORM pxf
    )
{
    BOOL bRet;
    XFORM xf;

    bRet = GreGetTransform(hdc,iXform,(XFORML *)&xf);

    if (bRet)
    {
        try
        {
            ProbeAndWriteStructure(pxf,xf,XFORM);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(74);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiCombineTransform()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiCombineTransform(
    LPXFORM  pxfDst,
    LPXFORM pxfSrc1,
    LPXFORM pxfSrc2
    )
{
    BOOL bRet;
    XFORM xfSrc1;
    XFORM xfSrc2;
    XFORM xfDst;

    bRet = ProbeAndConvertXFORM ((XFORML *)pxfSrc1, (XFORML *)&xfSrc1)
           && ProbeAndConvertXFORM ((XFORML *)pxfSrc2, (XFORML *)&xfSrc2);

    if (bRet)
    {
        bRet = GreCombineTransform((XFORML *)&xfDst,(XFORML *)&xfSrc1,(XFORML *)&xfSrc2);

        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(pxfDst,xfDst,XFORM);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(76);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiTransformPoints()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiTransformPoints(
    HDC    hdc,
    PPOINT pptIn,
    PPOINT pptOut,
    int    c,
    int    iMode
    )
{
    BOOL bRet = TRUE;
    POINT  apt[10];
    PPOINT pptTmp = apt;

    //
    // validate
    //
    if (c <= 0)
    {
        //
        // GetTransformPoints returns TRUE for this condition, as does
        // the DPtoLP and LPtoDP APIs.
        //

        return bRet;
    }

    //
    // we will just use the the stack if there are less than 10 points
    // otherwise allocate mem from heap
    //
    if (c > 10)
    {
        //
        // local stack is not enough, invalidate pointer and try to allocate.
        //
        pptTmp = NULL;

        if (!BALLOC_OVERFLOW1(c,POINT))
        {
            pptTmp = AllocFreeTmpBuffer(c * sizeof(POINT));
        }
    }

    //
    // copy pptIn into pptTmp
    //
    if (pptTmp)
    {
        try
        {
            ProbeForRead(pptIn,c * sizeof(POINT), sizeof(BYTE));

            RtlCopyMemory(pptTmp,pptIn,c*sizeof(POINT));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(77);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GreTransformPoints(hdc,pptTmp,pptTmp,c,iMode);
    }

    //
    // copy pptTmp out to pptOut
    //
    if (bRet)
    {
        try
        {
            ProbeAndWriteBuffer(pptOut,pptTmp,c*sizeof(POINT));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(77);
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    if (pptTmp && (pptTmp != apt))
        FreeTmpBuffer(pptTmp);

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetTextCharsetInfo()
*
* History:
*  Thu 23-Mar-1995 -by- Bodin Dresevic [BodinD]
* update: fixed it.
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetTextCharsetInfo(
    HDC             hdc,
    LPFONTSIGNATURE lpSig,
    DWORD           dwFlags
    )
{
    FONTSIGNATURE fsig;
    int iRet = GDI_ERROR;

    fsig.fsUsb[0] = 0;
    fsig.fsUsb[1] = 0;
    fsig.fsUsb[2] = 0;
    fsig.fsUsb[3] = 0;
    fsig.fsCsb[0] = 0;
    fsig.fsCsb[1] = 0;

    iRet = GreGetTextCharsetInfo(hdc, lpSig ? &fsig : NULL , dwFlags);

    if (iRet != GDI_ERROR)
    {
        if (lpSig)
        {
            try
            {
                ProbeAndWriteStructure(lpSig, fsig, FONTSIGNATURE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(78);
                // SetLastError(GetExceptionCode());

            // look into gtc.c win95 source file, this is what they return
            // in case of bad write pointer [bodind],
            // cant return 0 - that's ANSI_CHARSET!

                iRet = DEFAULT_CHARSET;
            }
        }
    }
    return iRet;
}


/******************************Public*Routine******************************\
* NtGdiGetBitmapDimension()
*
* History:
*  23-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetBitmapDimension(
    HBITMAP hbm,
    LPSIZE  psize
    )
{
    BOOL bRet;
    SIZE tmpsize;


    // check for null handle
    if (hbm == 0)
    {
        bRet = FALSE;
    }
    // do the real work
    else
    {

        bRet = GreGetBitmapDimension(hbm,&tmpsize);

        // if Gre call is successful do this, otherwise
        // we don't bother
        if (bRet)
        {
            try
            {
                ProbeAndWriteStructure(psize,tmpsize,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(81);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }
        }
    }

    return (bRet);

}


/******************************Public*Routine******************************\
* NtGdiSetBitmapDimension()
*
* History:
*  23-Feb-1995 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetBitmapDimension(
    HBITMAP hbm,
    int     cx,
    int     cy,
    LPSIZE  psizeOut
    )
{
    BOOL bRet;
    SIZE tmpsize;

    // check for null handle
    if (hbm == 0)
    {
        bRet = FALSE;
    }
    // do the real work
    else
    {
        bRet = GreSetBitmapDimension(hbm,cx, cy, &tmpsize);

        // if the Gre call is successful, we copy out
        // the original size
        if (bRet && psizeOut)
        {

            try
            {
                ProbeAndWriteStructure(psizeOut,tmpsize,SIZE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(82);
                // SetLastError(GetExceptionCode());

                bRet = FALSE;
            }

        }
    }

    return (bRet);

}



BOOL
APIENTRY
NtGdiForceUFIMapping(
    HDC hdc,
    PUNIVERSAL_FONT_ID pufi
    )
{
    BOOL bRet = FALSE;

    if( pufi )
    {
        try
        {
            UNIVERSAL_FONT_ID ufi;

            ufi  = ProbeAndReadStructure( pufi, UNIVERSAL_FONT_ID);
            bRet = GreForceUFIMapping( hdc, &ufi);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(87);
            bRet = FALSE;
        }
    }

    return bRet;
}


typedef LONG (*NTGDIPALFUN)(HPALETTE,UINT,UINT,PPALETTEENTRY);
NTGDIPALFUN palfun[] =
{
    (NTGDIPALFUN)GreAnimatePalette,
    (NTGDIPALFUN)GreSetPaletteEntries,
    (NTGDIPALFUN)GreGetPaletteEntries,
    (NTGDIPALFUN)GreGetSystemPaletteEntries,
    (NTGDIPALFUN)GreGetDIBColorTable,
    (NTGDIPALFUN)GreSetDIBColorTable
};

/******************************Public*Routine******************************\
* NtGdiDoPalette
*
* History:
*  08-Mar-1995 Mark Enstrom [marke]
* Wrote it.
\**************************************************************************/

LONG
APIENTRY
NtGdiDoPalette(
    HPALETTE hpal,
    WORD  iStart,
    WORD  cEntries,
    PALETTEENTRY *pPalEntries,
    DWORD iFunc,
    BOOL  bInbound)
{

    LONG lRet = 0;
    BOOL bStatus = TRUE;
    PALETTEENTRY *ppalBuffer = (PALETTEENTRY*)NULL;

    if (iFunc <= 5)
    {
        if (bInbound)
        {
            //
            // copy  pal entries to temp buffer if needed
            //

            if ((cEntries > 0) && (pPalEntries != (PALETTEENTRY*)NULL))
            {
                if (!BALLOC_OVERFLOW1(cEntries,PALETTEENTRY))
                {
                    ppalBuffer = (PALETTEENTRY *)AllocFreeTmpBuffer(cEntries * sizeof(PALETTEENTRY));
                }

                if (ppalBuffer == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    try
                    {
                        ProbeAndReadBuffer(ppalBuffer,pPalEntries,cEntries * sizeof(PALETTEENTRY));
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(88);
                        bStatus = FALSE;
                        //SetLastError(GetExceptionCode());
                    }
                }
            }

            if (bStatus)
            {
                lRet = (*palfun[iFunc])(
                                hpal,
                                iStart,
                                cEntries,
                                ppalBuffer);
            }
        }
        else
        {
            LONG lRetEntries;

            //
            // Query of palette information
            //

            if (pPalEntries != (PALETTEENTRY*)NULL)
            {
                if (cEntries == 0)
                {
                    // if there is a buffer but no entries, we're done.

                    bStatus = FALSE;
                    lRet = 0;
                }
                else
                {
                    if (!BALLOC_OVERFLOW1(cEntries,PALETTEENTRY))
                    {
                        ppalBuffer = (PALETTEENTRY *)AllocFreeTmpBuffer(cEntries * sizeof(PALETTEENTRY));
                    }

                    if (ppalBuffer == NULL)
                    {
                        bStatus = FALSE;
                    }
                }
            }

            if (bStatus)
            {
                lRet = (*palfun[iFunc])(
                                hpal,
                                iStart,
                                cEntries,
                                ppalBuffer);

                //
                // copy data back (if there is a buffer)
                //

                lRetEntries = min((LONG)cEntries,lRet);

                if ((lRetEntries > 0) && (pPalEntries != (PALETTEENTRY*)NULL))
                {
                    try
                    {
                        ProbeAndWriteBuffer(pPalEntries, ppalBuffer, lRetEntries * sizeof(PALETTEENTRY));
                    }
                    except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(89);
                        // SetLastError(GetExceptionCode());
                        lRet = 0;
                    }
                }
            }
        }

        if (ppalBuffer != (PALETTEENTRY*)NULL)
        {
            FreeTmpBuffer(ppalBuffer);
        }

    }
    return(lRet);
}


/******************************Public*Routine******************************\
* NtGdiGetSpoolMessage()
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG NtGdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG     cjMsg,
    PULONG    pulOut,
    ULONG     cjOut
    )
{
    ULONG     ulRet = 0;
    HANDLE    hSecure = 0;

    // psesc contains two pieces.  The header which includes data going
    // in and out and the variable length data which is only output.  We
    // divide the message into two pieces here since we only need to validate
    // the header up front.  We just put a try/except around the output buffer
    // when we copy it in later.

    if (psesc && (cjMsg >= offsetof(SPOOLESC,ajData)))
    {
        try
        {
            ProbeForWrite(psesc,cjMsg,PROBE_ALIGNMENT(SPOOLESC));

            hSecure = MmSecureVirtualMemory (psesc, cjMsg, PAGE_READWRITE);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(90);
        }

        if (hSecure)
        {
            ulRet = GreGetSpoolMessage(
                        psesc,
                        psesc->ajData,
                        cjMsg - offsetof(SPOOLESC,ajData),
                        pulOut,
                        cjOut );

            MmUnsecureVirtualMemory (hSecure);
        }
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* NtGdiUnloadPrinterDriver()
*
* This function is called by the spooler when the printer driver has to be
* unloaded for upgrade purposes. The driver will be marked to be unloaded when
* the DC count goes to zero.
*
* History:
*  11/18/97  Ramanathan Venkatapathy
* Wrote it.
\**************************************************************************/
BOOL APIENTRY NtGdiUnloadPrinterDriver(
    LPWSTR  pDriverName,
    ULONG   cbDriverName)
{
    BOOL    bReturn = FALSE;
    WCHAR   pDriverFile[MAX_PATH + 1];

    RtlZeroMemory(pDriverFile, (MAX_PATH + 1) * sizeof(WCHAR));

    // Check for invalid driver name.
    if (cbDriverName > (MAX_PATH * sizeof(WCHAR)))
    {
        return bReturn;
    }

    __try
    {
        ProbeAndReadAlignedBuffer(pDriverFile, pDriverName, cbDriverName, sizeof(WCHAR) );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiUnloadPrinterDriver: bad driver file name.\n");
        return bReturn;
    }

    bReturn = ldevArtificialDecrement(pDriverFile);

    return bReturn;
}

/******************************Public*Routine******************************\
*
* NtGdiDescribePixelFormat
*
* Returns information about pixel formats for driver-managed surfaces
*
* History:
*  Thu Nov 02 18:16:26 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int NtGdiDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                             PPIXELFORMATDESCRIPTOR ppfd)
{
    PIXELFORMATDESCRIPTOR pfdLocal;
    int iRet;

    if (cjpfd > 0 && ppfd == NULL)
    {
        return 0;
    }

    // Make sure we cannot overrun our local structure.
    cjpfd = min(cjpfd, sizeof(pfdLocal));

    // Retrieve information into a local copy because the
    // devlock is held when the driver fills it in.  If there
    // was an access violation then the lock wouldn't be cleaned
    // up
    iRet = GreDescribePixelFormat(hdc, ipfd, cjpfd, &pfdLocal);

    // Copy data back if necessary
    if (iRet != 0 && cjpfd > 0)
    {
        try
        {
            ProbeAndWriteAlignedBuffer(ppfd, &pfdLocal, cjpfd, sizeof(ULONG));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(92);
            iRet = 0;
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* NtGdiFlush: Stub onle
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    1-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
NtGdiFlush()
{
    GreFlush();
}

/******************************Public*Routine*****************************\
* NtGdiGetCharWidthInfo
*
* Get the lMaxNegA lMaxNegC and lMinWidthD
*
* History:
*  14-Feb-1996  -by-  Xudong Wu [tessiew]
* Wrote it.
\*************************************************************************/

BOOL
APIENTRY
NtGdiGetCharWidthInfo(
   HDC  hdc,
   PCHWIDTHINFO  pChWidthInfo
)
{
   BOOL  bRet = FALSE;
   CHWIDTHINFO   tempChWidthInfo;

   bRet = GreGetCharWidthInfo( hdc, &tempChWidthInfo );

   if (bRet)
   {
        try
        {
            ProbeAndWriteBuffer( pChWidthInfo, &tempChWidthInfo, sizeof(CHWIDTHINFO) );
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            WARNINGX(93);
            bRet = FALSE;
        }
   }

   return ( bRet );
}


ULONG
APIENTRY
NtGdiMakeFontDir(
    FLONG    flEmbed,            // mark file as "hidden"
    PBYTE    pjFontDir,          // pointer to structure to fill
    unsigned cjFontDir,          // >= CJ_FONTDIR
    PWSZ     pwszPathname,       // path of font file to use
    unsigned cjPathname          // <= sizeof(WCHAR) * (MAX_PATH+1)
    )
{
    ULONG ulRet;
    WCHAR awcPathname[MAX_PATH+1];  // safe buffer for path name
    BYTE  ajFontDir[CJ_FONTDIR];    // safe buffer for return data

    ulRet = 0;
    if ( (cjPathname <= (sizeof(WCHAR) * (MAX_PATH+1))) &&
         (cjFontDir >= CJ_FONTDIR) )
    {
        ulRet = 1;
        __try
        {
            ProbeAndReadAlignedBuffer( awcPathname, pwszPathname, cjPathname, sizeof(*pwszPathname));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiMakeFondDir: bad pwszPathname\n");
            ulRet = 0;
        }
        if ( ulRet )
        {
            awcPathname[MAX_PATH] = 0;
            ulRet = GreMakeFontDir( flEmbed, ajFontDir, awcPathname );
            if ( ulRet )
            {
                __try
                {
                    ProbeAndWriteBuffer( pjFontDir, ajFontDir,  CJ_FONTDIR   );
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiMakeFondDir: bad pjFontDir\n");
                    ulRet = 0;
                }
            }
        }
    }
    return( ulRet );
}


DWORD   APIENTRY NtGdiGetGlyphIndicesWInternal(
    HDC    hdc,
    LPWSTR pwc,
    int    cwc,
    LPWORD pgi,
    DWORD iMode,
    BOOL   bSubset
    )
{

    WORD awBuffer[2*LOCAL_CWC_MAX];
    LPWSTR pwcTmp;
    LPWORD pgiTmp = NULL;
    DWORD  dwRet = GDI_ERROR;

    if (cwc < 0)
        return dwRet;

// test for important special case

    if ((cwc == 0) && (pwc == NULL) && (pgi == NULL) && (iMode == 0))
        return GreGetGlyphIndicesW(hdc, NULL, 0, NULL, 0, bSubset);

    if (cwc <= LOCAL_CWC_MAX)
    {
        pgiTmp = awBuffer;
    }
    else
    {
        if (!BALLOC_OVERFLOW2(cwc,WORD,WCHAR))
        {
            pgiTmp = (LPWORD)AllocFreeTmpBuffer(cwc * (sizeof(WORD)+sizeof(WCHAR)));
        }
    }

    if (pgiTmp)
    {
    // make a temp buffer for the string in the same buffer, after the indices

        pwcTmp = &pgiTmp[cwc];

        try
        {
            ProbeAndReadBuffer(pwcTmp, pwc, cwc * sizeof(WCHAR));
            dwRet = cwc; // indicate that we did not hit the exception
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(98);
            dwRet = GDI_ERROR;
        }

        if (dwRet != GDI_ERROR)
            dwRet = GreGetGlyphIndicesW(hdc, pwcTmp, cwc, pgiTmp, iMode, bSubset);

        if (dwRet != GDI_ERROR)
        {
            try
            {
                ProbeAndWriteBuffer(pgi, pgiTmp, cwc * sizeof(WORD));
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(99);
                dwRet = GDI_ERROR;
            }
        }

        if (pgiTmp != awBuffer)
            FreeTmpBuffer(pgiTmp);
    }

    return dwRet;
}


DWORD   APIENTRY NtGdiGetGlyphIndicesW(
    HDC    hdc,
    LPWSTR pwc,
    int    cwc,
    LPWORD pgi,
    DWORD iMode
    )
{
    return NtGdiGetGlyphIndicesWInternal(hdc, pwc, cwc, pgi, iMode, FALSE);
}


/******************************Public*Routine******************************\
*
* NtGdi stub for GetFontUnicodeRanges
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD NtGdiGetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgs)
{
    DWORD dwRet, dwRet1;
    LPGLYPHSET pgsTmp = NULL;

    dwRet = GreGetFontUnicodeRanges(hdc, NULL);

    if (dwRet && pgs)
    {
        if (pgsTmp = (LPGLYPHSET)AllocFreeTmpBuffer(dwRet))
        {
            dwRet1 = GreGetFontUnicodeRanges(hdc, pgsTmp);
            if (dwRet1 && (dwRet == dwRet1)) // consistency check
            {
                try
                {
                    ProbeAndWriteBuffer(pgs, pgsTmp, dwRet);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(102);
                    dwRet = 0;
                }
            }
            else
            {
                WARNINGX(101);
                dwRet = 0;
            }

            FreeTmpBuffer(pgsTmp);
        }
        else
        {
            WARNINGX(100);
            dwRet = 0;
        }
    }

    return dwRet;
}

#ifdef LANGPACK
BOOL
APIENTRY
NtGdiGetRealizationInfo(
    HDC hdc,
    PREALIZATION_INFO pri,
    KHFONT hf
    )
{
    REALIZATION_INFO riTmp;
    BOOL  bRet = TRUE;
    int     ii;

    bRet = GreGetRealizationInfo(hdc, &riTmp);

    try
    {
        if (bRet)
        {
            ProbeAndWriteStructure(pri,riTmp,REALIZATION_INFO);
        }

        if (bRet)
        {
            if (hf)
            {
                // Find CFONT Location
                for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
                    if (gpGdiSharedMemory->acfPublic[ii].hf == (HFONT)hf)
                        break;

                if (ii < MAX_PUBLIC_CFONT){
                    CFONT* pcf = &gpGdiSharedMemory->acfPublic[ii];

                    pcf->ri = riTmp;

                    pcf->fl |= CFONT_CACHED_RI;

                    pcf->timeStamp = gpGdiSharedMemory->timeStamp;
                }
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(104);
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return (bRet);
}


#endif

/******************************Public*Routine******************************\
* NtGdiDrawStream
*
* Arguments:
*
*   hdc      - handle to primary destination device context
*   cjIn     - size, in bytes, of input draw stream
*   pjIn     - address of input draw stream
*
* Return Value:
*
*   TRUE : success
*   FALSE : faiure
*
* History:
*
*   3-19-2001 bhouse Created it
*
\**************************************************************************/

#define DS_STACKBUFLENGTH  256

BOOL
APIENTRY
NtGdiDrawStream(
    HDC                 hdcDst,
    ULONG               cjIn,
    PVOID               pvIn
    )
{
    BYTE                pbScratchBuf[DS_STACKBUFLENGTH];
    BOOL                bRet = FALSE;
    PVOID               pvScratch = NULL;

    if(cjIn > sizeof(pbScratchBuf))
    {
        if (BALLOC_OVERFLOW1(cjIn,BYTE))
        {
            WARNING("NtGdiDrawStream: input stream is too large\n");
            goto exit;
        }
        
        pvScratch = AllocFreeTmpBuffer(cjIn);

        if (pvScratch == NULL)
        {
            WARNING("NtGdiDrawStream: unable to allocate temp buffer\n");
            goto exit;
        }
        
    }
    else
    {
        pvScratch = (PVOID) pbScratchBuf;
    }

    // copy the stream from user mode
    // NOTE: we can get rid of the copy if we try/except in all appropriate
    //       places during the handling of the stream.

    try 
    {
        ProbeAndReadBuffer(pvScratch, pvIn,cjIn);
    }

    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiDrawStream: exception occured reading stream\n");
        goto exit;
    }

    bRet = GreDrawStream(hdcDst, cjIn, pvScratch);

exit:

    if(pvScratch != NULL && pvScratch != pbScratchBuf)
    {
        FreeTmpBuffer(pvScratch);
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\muio.c ===
/*************************************************************************
*
* io.c
*
* Functions to perform kernel level file I/O.
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
*
*************************************************************************/

#include <ntosp.h>
#include <ctxdd.h>

#if !defined(_GDIPLUS_)

/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp 
    );

NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*******************************************************************************
 *
 *  CtxReadFile
 *
 *    Kernel read file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to read buffer
 *    Length (input)
 *       length of read buffer
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxReadFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    return( _CtxDoFileIo( IRP_MJ_READ, fileObject, Buffer, Length, pEvent, pIosb, ppIrp ) );
}


/*******************************************************************************
 *
 *  CtxWriteFile
 *
 *    Kernel write file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to write buffer
 *    Length (input)
 *       length of write buffer
 *    pEvent (input) 
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxWriteFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    return( _CtxDoFileIo( IRP_MJ_WRITE, fileObject, Buffer, Length, pEvent, pIosb, ppIrp ) );
}


NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp
    )
{
    PDEVICE_OBJECT deviceObject;
    LARGE_INTEGER Offset;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    KIRQL irql;
    extern ULONG IoReadOperationCount, IoWriteOperationCount;
    static IO_STATUS_BLOCK Iosb;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * If the caller does not supply an IOSB, supply
     * a static one to avoid the overhead of the exception
     * handler in the IO completion APC. Since the caller(s)
     * do not care about the result, we can point all such
     * callers to the same one.
     */
    if( pIosb == NULL ) {
        pIosb = &Iosb;
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    Offset.LowPart = FILE_WRITE_TO_END_OF_FILE;
    Offset.HighPart = -1;
    irp = IoBuildAsynchronousFsdRequest( MajorFunction, deviceObject,
                                         Buffer, Length, &Offset, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );
   
    /*
     * Save callers event pointer.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    irp->UserEvent = pEvent;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;

    /*
     * Set the address of the current thread in the packet so the
     * completion code will have a context to execute in.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue the IRP to the current thread
    //
    IoQueueThreadIrp( irp );


    //
    // Call driver
    //
    status = IoCallDriver( deviceObject, irp );

    //
    // If irp->UserEvent == NULL, IO completion will set the file
    // object event and status.
    //
    if (pEvent == NULL) {

        if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            KernelMode, // Prevent KSTACK from paging
                                            FALSE,      // Non-alertable
                                            (PLARGE_INTEGER) NULL );

            ASSERT(status != STATUS_ALERTED);
            ASSERT(status != STATUS_USER_APC);

            status = fileObject->FinalStatus;
        }
    }

    if ( pEvent != NULL && ppIrp != NULL ) {
        // Trap whatever driver uses this inheritly broken interface
        *ppIrp = NULL;
    }

    return( status );
}


/*******************************************************************************
 *
 *  CtxDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IoControlCode (input)
 *       Io control code
 *    InputBuffer (input)
 *       pointer to input buffer (optional)
 *    InputBufferLength (input)
 *       length of input buffer
 *    OutputBuffer (input)
 *       pointer to output buffer (optional)
 *    OutputBufferLength (input)
 *       length of output buffer
 *    InternalDeviceIoControl (input)
 *       if TRUE, use IOCTL_INTERNAL_DEVICE_IO_CONTROL
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxDeviceIoControlFile(
    IN PFILE_OBJECT fileObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( IoControlCode, deviceObject,
                                         InputBuffer, InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         InternalDeviceIoControl,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


/*******************************************************************************
 *
 *  CtxInternalDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IrpParameters (input)
 *       information to write to the parameters section of the
 *       stack location of the IRP.
 *    IrpParametersLength (input)
 *       length of the parameter information.  Cannot be greater than 16.
 *    MdlBuffer (input)
 *       if non-NULL, a buffer of nonpaged pool to be mapped
 *       into an MDL and placed in the MdlAddress field of the IRP.
 *    MdlBufferLength (input)
 *       the size of the buffer pointed to by MdlBuffer.
 *    MinorFunction (input)
 *       the minor function code for the request.
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxInternalDeviceIoControlFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( 0, deviceObject,
                                         NULL, 0,
                                         NULL, 0,
                                         TRUE,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * If an MDL buffer was specified, get an MDL, map the buffer,
     * and place the MDL pointer in the IRP.
     */
    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Fill in the service-dependent parameters for the request.
     */
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    /*
     * Set up a completion routine which we'll use to free the MDL
     * allocated previously.
     */
    IoSetCompletionRoutine( irp, _CtxDeviceControlComplete, NULL, TRUE, TRUE, TRUE );

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return( STATUS_SUCCESS );

}

#endif // !defined(_GDIPLUS_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\paintddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: paintddi.cxx
*
* Paint callbacks
*
* Created: 05-Mar-1992 18:30:39
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngPaint
*
* Paint the clipping region with the specified brush
*
* History:
*  05-Mar-1992 -by- Donald Sidoroff [donalds]
* add accelerators for common mix modes.
*
*  Sat 07-Sep-1991 -by- Patrick Haluptzok [patrickh]
* add translate of mix to rop
*
*  01-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngPaint(
SURFOBJ  *pso,
CLIPOBJ  *pco,
BRUSHOBJ *pdbrush,
POINTL   *pptlBrush,
MIX       mix)
{
    GDIFunctionID(EngPaint);

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    ASSERTGDI(pso != (SURFOBJ *) NULL, "NULL SURFOBJ\n");
    ASSERTGDI(pco != (CLIPOBJ *) NULL, "NULL CLIPOBJ\n");
    ASSERTGDI(pco->iMode == TC_RECTANGLES,"iMode not rects\n");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

    ROP4 rop4 = gaMix[(mix >> 8) & 0x0F];
    rop4 = rop4 << 8;
    rop4 = rop4 | ((ULONG) gaMix[mix & 0x0F]);

    return(pSurf->pfnBitBlt())(
                (SURFOBJ *) pso,
                (SURFOBJ *) NULL,
                (SURFOBJ *) NULL,
                pco,
                NULL,
                (RECTL *) &(((ECLIPOBJ *) pco)->erclExclude()),
                (POINTL *)  NULL,
                (POINTL *)  NULL,
                pdbrush,
                pptlBrush,
                rop4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\palddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: palddi.cxx
*
* provides driver callbacks for palette management.
*
* Created: 06-Dec-1990 11:16:58
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngCreatePalette
*
* This is the engine entry point for device drivers to create palettes.
*
* History:
*  05-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPALETTE EngCreatePalette(
ULONG iMode,
ULONG cColors,
PULONG pulColors,
FLONG flRed,
FLONG flGre,
FLONG flBlu)
{
    HPALETTE hpal = (HPALETTE) 0;
    BOOL     bUMPD = iMode & UMPD_FLAG;
    PALMEMOBJ pal;

    iMode = iMode & ~UMPD_FLAG;

// If PAL_BITFIELDS, check to see if we can substitute one of the
// special cases PAL_RGB or PAL_BGR.

    if ( (iMode == PAL_BITFIELDS) && (flGre == 0x0000ff00) &&
         ( ((flRed == 0x000000ff) && (flBlu == 0x00ff0000)) ||
           ((flRed == 0x00ff0000) && (flBlu == 0x000000ff)) ) )
    {
        iMode = (flRed == 0x000000ff) ? PAL_RGB : PAL_BGR;
    }

// We default to assuming it's fixed palette and then at EngAssociate
// time we look at his pdev and decide if this guy is more capable
// than that and set the palette up accordingly.

    if (pal.bCreatePalette(iMode, cColors, pulColors,
                           flRed, flGre, flBlu, PAL_FIXED))
    {
        pal.vKeepIt();
        hpal = (HPALETTE)pal.hpal();
        pal.ppalSet(NULL);      // Leave a reference count of 1 so that we
                                // can do vUnrefPalette() in EngDeletePalette

        if (bUMPD)
        {
            GreSetPaletteOwner(hpal, OBJECT_OWNER_CURRENT);
        }
    }

    return(hpal);
}

/******************************Public*Routine******************************\
* EngQueryPalette
*
* This is the engine entry point for device drivers to query palettes.
* This is intended mostly for remote-control drivers such as NetMeeting
* to determine the palette type of the primary display.
*
* Note that the driver has to look at GCAPS_PALMANAGED to determine
* whether it's a fixed palette or not.
*
* History:
*  04-Jan-1997 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

ULONG EngQueryPalette(
HPALETTE    hpal,
ULONG      *piMode,
ULONG       cColors,
ULONG      *pulColors)
{
    ULONG ulRet = 0;

    EPALOBJ pal(hpal);
    if (pal.bValid())
    {
        *piMode
            = pal.flPal() & (PAL_INDEXED | PAL_BITFIELDS | PAL_RGB | PAL_BGR);

        if (pal.cEntries() != 0)
        {
            // It's palettized:

            ulRet = pal.ulGetEntries(0, cColors, (PALETTEENTRY*) pulColors, TRUE);
        }
        else
        {
            // It's bitfields:

            ulRet = 3;

            if ((cColors >= 3) && (pulColors != NULL))
            {
                *(pulColors)     = pal.flRed();
                *(pulColors + 1) = pal.flGre();
                *(pulColors + 2) = pal.flBlu();
            }
        }
    }
    else
    {
        WARNING("EngQueryPalette -- Invalid palette");
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* EngDeletePalette
*
* Driver entry point for deleting palettes it has created
*
* History:
*  05-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngDeletePalette(HPALETTE hpal)
{
    BOOL b = FALSE;

    EPALOBJ palobj(hpal);
    if (palobj.bValid() && !palobj.bIsPalDC())
    {
        // First, undo the alt-lock we just did by invoking EPALOBJ:

        DEC_SHARE_REF_CNT(palobj.ppalGet());

        // Device dependent bitmaps for RGB colour depths have their palettes
        // pointing to the surface's primary palette.  With dynamic colour
        // depth changing, we want to keep those palette references around
        // even after the primary surface is deleted.
        //
        // This means that during the dynamic mode change, the palette should
        // not be deleted when the old instance of the driver asks it to be
        // deleted, but instead when the last bitmap referencing the palette
        // is deleted.  Having everyone use 'vUnrefPalette' makes this Just
        // Work.

        palobj.vUnrefPalette();

        b = TRUE;
    }

    return(b);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\paleng.cxx ===
/******************************Module*Header*******************************\
* Module Name: paleng.cxx
*
* Palette support routines used by NT components.
*
* Created: 27-Nov-1990 12:28:40
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* GreSetPaletteOwner
*
* Sets the palette owner.
*
\**************************************************************************/

BOOL
GreSetPaletteOwner(
                  HPALETTE hpal,
                  W32PID lPid)
{
    BOOL bRet = FALSE;


    if (hpal==(HPALETTE)STOCKOBJ_PAL)
    {
        WARNING("GreSetPaletteOwner: Cannot set owner for the stock Palette\n");
    }
    else
    {
        bRet = HmgSetOwner((HOBJ)hpal,lPid,PAL_TYPE);
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* CreateSurfacePal
*
* Turns a physical palette into a palette managed palette for a device.
*
* History:
*  Tue 04-Dec-1990 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL CreateSurfacePal(XEPALOBJ palSrc, FLONG iPalType, ULONG ulNumReserved, ULONG ulNumPalReg)
{
    ASSERTGDI(iPalType == PAL_MANAGED, "ERROR: CreateSurfacePalette passed bad iPalType\n");
    ASSERTGDI(palSrc.bValid(), "ERROR CreateSurfacePal palSrc");
    ASSERTGDI(palSrc.cEntries() != 0, "ERROR CreateSurfacePal");

    //
    // If it is a Palette managed surface we must keep an exact
    // copy of it's origal state for certain functionality.
    //

    PALMEMOBJ pal;
    BOOL b;

    b = pal.bCreatePalette(palSrc.iPalMode(),
                           palSrc.cEntries(),
                           (PULONG) palSrc.apalColorGet(),
                           0,
                           0,
                           0,
                           iPalType);
    if (b)
    {
        ASSERTGDI(pal.bIsIndexed(), "Creating a non-indexed managed surface ???");
        ASSERTGDI(pal.bIsPalManaged(), "ERROR PAL_MANaged not pal managed");

        //
        // Now we have to set the type or the source to be PAL_MANAGED.
        //

        palSrc.flPalSet((palSrc.flPal() & ~(PAL_FIXED)) | PAL_MANAGED);

        //
        // Set the used and foreground flags on the reserved palette entries.
        //

        PAL_ULONG palTemp;

        ASSERTGDI((ulNumReserved & 0x00001) == 0, "ERROR non multiple of 2 reserved colors");

        palSrc.ulNumReserved(ulNumReserved);
        pal.ulNumReserved(ulNumReserved);
        ulNumReserved >>= 1;

        ULONG iPalMode;

        for (iPalMode = 0; iPalMode < ulNumReserved; iPalMode++)
        {
            palTemp.ul = pal.ulEntryGet(iPalMode);
            palTemp.pal.peFlags = (PC_FOREGROUND | PC_USED);
            pal.ulEntrySet(iPalMode, palTemp.ul);

            palTemp.ul = pal.ulEntryGet(iPalMode + (ulNumPalReg - ulNumReserved));
            palTemp.pal.peFlags = (PC_FOREGROUND | PC_USED);
            pal.ulEntrySet(iPalMode + (ulNumPalReg - ulNumReserved), palTemp.ul);
        }

        //
        // Ok the palette is in perfect initial shape, copy it.
        //

        palSrc.vCopyEntriesFrom(pal);
        palSrc.ppalOriginal(pal.ppalGet());
        pal.ulTime(palSrc.ulTime());
        pal.vKeepIt();
    }

    return(b);
}


/******************************Public*Routine******************************\
* ulGetNearestIndexFromColorref
*
*  Given the surface palette and the DC palette, this returns the index in
*  palSurf that crColor maps to.
*
*  Modifies: Nothing.
*
*  Returns: Index in palSurf that crColor maps to.
*
*  PALETTERGB   puts a 2 in the high byte.
*  PALETTEINDEX puts a 1 in the high byte.
*
* History:
*  Mon 02-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

ULONG
ulGetNearestIndexFromColorref(
    XEPALOBJ    palSurf,
    XEPALOBJ    palDC,
    ULONG       crColor,
    ULONG       seSearchExactFirst)
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PDEV          *ppdev = (PDEV *)palDC.hdev();

    PAL_ULONG palTemp;
    palTemp.ul = crColor;

    //
    // Check if it's palette managed.  If it's a device bitmap for a palette managed
    // device it will have an invalid palette.  If the palettes valid then it may be
    // the palette managed device's palette.
    //

    if ((!palSurf.bValid()) || (palSurf.bIsPalManaged()))
    {

        //
        // RGB:             Match to default palette or dither
        //
        // PALETTERGB:      Match RGB value to nearest entry in palette
        //
        // PALETTEINDEX:    The low 16 bits is a direct index to a palette entry
        //

        //
        // Check if it's a color forces us to access the xlate
        //

        if (palTemp.ul & 0x03000000)
        {
            if (palTemp.ul & 0x01000000)
            {
                //
                // PALETTEINDEX:
                //
                // This means they have an explicit entry in the DC palette they want
                //

                palTemp.pal.peFlags = 0;

                if (palTemp.ul >= palDC.cEntries())
                {
                    palTemp.ul = 0;
                }
            }
            else
            {
                //
                // PALETTERGB:
                //
                // Get rid of the top byte first.  It's 0x02 and we want to
                // search with this being an RGB.
                //


                palTemp.pal.peFlags = 0;

                palTemp.ul = palDC.ulGetNearestFromPalentry(
                                                            palTemp.pal,
                                                            seSearchExactFirst
                                                           );
            }

            //
            // If the DC's palette is the default palette, adjust if this is in the
            // top 10 colors, then we're done, because there's no translation of
            // the default palette
            //

            if (palDC.bIsPalDefault())
            {
                if (palTemp.ul >= 10)
                {
                    palTemp.ul = palTemp.ul + 236;
                }

                return(palTemp.ul);
            }

            //
            // Now do the right thing based on whether we are on the device bitmap
            // or the device surface.
            //

            if ((palSurf.bValid()) && (palDC.ptransCurrent() != NULL))
            {
                return(palDC.ulTranslateDCtoCurrent(palTemp.ul));
            }

            if ((!palSurf.bValid()) && (palDC.ptransFore() != NULL))
            {
                return(palDC.ulTranslateDCtoFore(palTemp.ul));
            }

            //
            // App is in hosed state which is possible in multi-tasking system.
            // Map as best we can into static colors, get the RGB from palDC.
            //

            palTemp.pal = palDC.palentryGet(palTemp.ul);

            //
            // If PC_EXPLICIT is set just return value modulo 256.
            //

            if (palTemp.pal.peFlags == PC_EXPLICIT)
            {
                return(palTemp.ul & 0x000000FF);
            }
        }

        //
        // check for DIBINDEX
        //

        if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
        {
            return(palTemp.ul & 0x000000FF);
        }

        //
        // At this point palTemp is an RGB value
        //
        // Well we need to match against the default palette.  We quickly
        // check for black and white and pass the rest through.
        //

        palTemp.pal.peFlags = 0;

        if (palTemp.ul == 0xFFFFFF)
        {
            palTemp.ul = 19;
        }
        else if (palTemp.ul != 0)
        {
            palTemp.ul =
                ((XEPALOBJ) ppalDefault).ulGetNearestFromPalentry(
                                                palTemp.pal,
                                                seSearchExactFirst
                                               );
        }

        if (palTemp.ul >= 10)
        {
            palTemp.ul = palTemp.ul + 236;
        }

        return(palTemp.ul);
    }

    //
    // This means they are not palette managed.
    //

    if (palTemp.ul & 0x01000000)
    {
        //
        // PALETTEINDEX:
        // This means they have an explicit entry in the DC palette they want.
        //

        palTemp.ul &= 0x0000FFFF;

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        palTemp.pal = palDC.palentryGet(palTemp.ul);
    }
    else if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
    {
        //
        // check for DIBINDEX
        //

        palTemp.ul &= 0x000000FF;

        return((palTemp.ul >= palSurf.cEntries()) ? 0 : palTemp.ul);
    }
    else
    {
        //
        // We just look for the closest RGB.
        //

        palTemp.pal.peFlags = 0;
    }

    //
    // Now it is time to look in the surface palette for the matching color.
    //

    return(palSurf.ulGetNearestFromPalentry(palTemp.pal, seSearchExactFirst));
}


/******************************Public*Routine******************************\
* ulGetMatchingIndexFromColorref
*
*  Given the surface palette and the DC palette, this returns the index in
*  palSurf that crColor maps to exactly, or 0xFFFFFFFF if it doesn't map
*  exactly to any color. Note that if the "find nearest in palette managed"
*  bit (0x20000000) is set, the nearest color qualifies as a match, because
*  that's what they're asking for. However, there is no guarantee that either
*  of the special bits will result in a match, because the palette may be in
*  an incorrect state or they could be asking for a direct index into the DC
*  palette that produces a color that's not in the surface's palette (in the
*  case of a non-palette-managed surface).
*
*  Modifies: Nothing.
*
*  Returns: Index in palSurf that crColor maps to.
*
*  PALETTERGB   puts a 2 in the high byte (find nearest)
*  PALETTEINDEX puts a 1 in the high byte (find specified index)
*
* History:
*  Sun 27-Dec-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

ULONG
ulGetMatchingIndexFromColorref(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG    crColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG       palTemp;
    PDEV           *ppdev = (PDEV *)palDC.hdev();

    palTemp.ul = crColor;

    //
    // Check if it's palette managed.  If it's a device bitmap for a palette managed
    // device it will have an invalid palette.  If the palette's valid then it may be
    // the palette managed device's palette.
    //

    if ((!palSurf.bValid()) || (palSurf.bIsPalManaged()))
    {

        //
        // RGB:             Match to default palette or dither
        //
        // PALETTERGB:      Match RGB value to nearest entry in palette
        //
        // PALETTEINDEX:    The low 16 bits is a direct index to a palette entry
        //
        //
        // Check if it's a color forces us to access the xlate
        //

        if (palTemp.ul & 0x03000000)
        {
            if (palTemp.ul & 0x01000000)
            {
                //
                // PALETTEINDEX:
                //
                // This means they have an explicit entry in the DC palette they
                // want; only the lower byte is valid
                //

                palTemp.ul &= 0x0000FFFF;

                if (palTemp.ul >= palDC.cEntries())
                {
                    palTemp.ul = 0;
                }

            }
            else // (palTemp.ul & 0x02000000)
            {
                //
                // Get rid of the top byte first.  It's 0x02 and we want to search
                // the DC's palette for the nearest match with this being an RGB.
                // Note that in this case the nearest match and exact match are
                // logically equivalent
                //

                palTemp.pal.peFlags = 0;

                palTemp.ul = palDC.ulGetNearestFromPalentry(palTemp.pal);
            }

            //
            // If the DC's palette is the default palette, adjust if this is in the
            // top 10 colors, then we're done, because there's no translation of
            // the default palette
            //

            if (palDC.bIsPalDefault())
            {
                if (palTemp.ul >= 10)
                {
                    palTemp.ul = palTemp.ul + 236;
                }

                return(palTemp.ul);
            }

            //
            // Now do the right thing based on whether we are on the device bitmap
            // or the device surface
            //

            if ((palSurf.bValid()) && (palDC.ptransCurrent() != NULL))
            {
                //
                // We're drawing to a palette managed device surface, using the
                // current translation (which may be either back or fore, depending
                // on whether the application is in the foreground and owns the
                // palette)
                //

                return(palDC.ulTranslateDCtoCurrent(palTemp.ul));
            }

            if ((!palSurf.bValid()) && (palDC.ptransFore() != NULL))
            {
                //
                // We're drawing to a bitmap for a palette managed device, using
                // the fore translation (always treat drawing to a bitmap as
                // foreground drawing)
                //

                return(palDC.ulTranslateDCtoFore(palTemp.ul));
            }

            //
            // App is in hosed state which is possible in multi-tasking system.
            // Map as best we can into static colors, get the RGB from palDC and
            // try to find that in the default palette
            //

            palTemp.pal = palDC.palentryGet(palTemp.ul);

            //
            // If PC_EXPLICIT is set just return value modulo 256.
            //

            if (palTemp.pal.peFlags == PC_EXPLICIT)
            {
                return(palTemp.ul & 0x000000FF);
            }
        }

        //
        // check for DIBINDEX
        //

        if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
        {
            return(palTemp.ul & 0x000000FF);
        }

        //
        // Well, we're palette managed and have a plain old RGB (or failed to
        // find  the desired translation), so we need to match against the
        // default palette.  We quickly check for black and white and pass
        // the rest through.
        //

        palTemp.pal.peFlags = 0;

        if (palTemp.ul == 0xFFFFFF)
        {
            palTemp.ul = 19;
        }
        else if (palTemp.ul != 0)
        {
            palTemp.ul = ((XEPALOBJ) ppalDefault).ulGetMatchFromPalentry(palTemp.pal);
        }

        //
        // If we're in the top half of the default palette, adjust to the high end
        // of the 256-color palette, where the top half of the default palette
        // actually resides
        //

        if ((palTemp.ul != 0xFFFFFFFF) && (palTemp.ul >= 10))
        {
            palTemp.ul = palTemp.ul + 236;
        }

        return(palTemp.ul);
    }

    //
    // Not palette managed.
    //

    if (palTemp.ul & 0x01000000)
    {
        //
        // This means they have an explicit entry in the DC palette they want.
        // Limit the maximum explicit entry to 8 bits.
        //

        palTemp.ul &= 0x0000FFFF;

        //
        // If the index is off the end of the palette, wrap it modulo the palette
        // length.
        //

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        //
        // Search the palette for the color closest to the color selected from the
        // DC palette by the specified index
        //

        palTemp.pal = palDC.palentryGet(palTemp.ul);
    }
    else if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
    {
        //
        // check for DIBINDEX
        //

        palTemp.ul &= 0x000000FF;

        return((palTemp.ul >= palSurf.cEntries()) ? 0 : palTemp.ul);
    }
    else
    {
        //
        // We just look for the closest RGB; mask off the flags.
        //

        palTemp.pal.peFlags = 0;
    }

    //
    // Now it is time to look in the surface palette for the matching color.
    //

    return(palSurf.ulGetMatchFromPalentry(palTemp.pal));
}

/******************************Public*Routine******************************\
* ulColorRefToRGB
*
* Given a color ref this returns the RGB it corresponds to.
*
* This is a helper function given a color ref that may contain
* DIBINDEX value, do the appropriate translation of the DIBINDEX.
*
* History:
*  19-Jan-2001 -by- Barton House bhouse
* Wrote it.
\**************************************************************************/

ULONG
ulColorRefToRGB(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG iColorRef
    )
{
    if((iColorRef & 0x10FF0000) == 0x10FF0000)
    {
        return ulIndexToRGB(palSurf, palDC, iColorRef & 0xFF);
    }
    else
    {
        return iColorRef;
    }
}


/******************************Public*Routine******************************\
* ulIndexToRGB
*
* Given an index this returns the RGB it corresponds to.
*
* History:
*  21-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG
ulIndexToRGB(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG iSolidColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG palTemp;

    if (palSurf.bValid())
    {
        return(palSurf.ulIndexToRGB(iSolidColor));
    }

    //
    // It's a palette managed device bitmap.
    //

    if (iSolidColor < 10)
    {
        palTemp.pal = logDefaultPal.palPalEntry[iSolidColor];
        return(palTemp.ul);
    }

    if (iSolidColor > 245)
    {
        palTemp.pal = logDefaultPal.palPalEntry[iSolidColor - 236];
        return(palTemp.ul);
    }

    //
    // Well it's the first entry in the logical palette that mapped here in the
    // foreground xlate.  If the foreground Xlate is invalid, who knows, return 0.
    //

    SEMOBJ  semo(ghsemPalette);

    if (palDC.ptransFore() != NULL)
    {
        PBYTE pjTemp = palDC.ptransFore()->ajVector;
        palTemp.ul = palDC.cEntries();

        for (palTemp.ul = 0; palTemp.ul < palDC.cEntries(); palTemp.ul++,pjTemp++)
        {
            if (*pjTemp == ((BYTE) iSolidColor))
                return(palDC.ulEntryGet(palTemp.ul));
        }
    }

    //
    // Well we just don't know.
    //

    return(0);
}

/******************************Public*Routine******************************\
* bIsCompatible
*
* This returns TRUE if the bitmap can be selected into this PDEV's memory
* DC's based on "Can we determine the color information".  It also returns
* the palette you could use for a reference for color information.
*
* History:
*  28-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bIsCompatible(PPALETTE *pppalReference, PPALETTE ppalBM, SURFACE *pSurfBM, HDEV hdev)
{
    BOOL bRet = TRUE;

    XEPALOBJ palBM(ppalBM);
    PDEVOBJ po(hdev);


    // We need to make sure this could be selected into this DC.  If it is a device
    // managed bitmap, it must be the same device.

    if (((pSurfBM->iType() != STYPE_BITMAP) || (pSurfBM->dhsurf() != 0)) &&
        (pSurfBM->hdev() != hdev))
    {
        WARNING1("bIsCompatible failed Device surface for another PDEV\n");
        bRet = FALSE;
    }
    else if (palBM.bValid())
    {
        // No problem, we already have color information.

        *pppalReference = palBM.ppalGet();
    }
    else if (pSurfBM->iFormat() != po.iDitherFormat())
    {
        // Check surface is compatible with PDEV for selection.

        WARNING1("bIsCompatible: Bitmap not compatible with DC\n");
        bRet = FALSE;
    }
    else
    {
        // If it's not palette managed set in palette for the device.  Otherwise
        // leave it NULL and the right stuff will happen.

        if (!po.bIsPalManaged())
        {
            *pppalReference = po.ppalSurf();
        }
        else
        {
            *pppalReference = (PPALETTE) NULL;
            ASSERTGDI(po.iDitherFormat() == BMF_8BPP, "ERROR GetDIBits no palette not 8BPP");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* rgbFromColorref
*
* Given the surface palette and the DC palette, this returns the rgb that
* this colorref represents.
*
* Returns: RGB that crColor maps to.
*
* PALETTERGB   puts a 2 in the high byte (find nearest)
* PALETTEINDEX puts a 1 in the high byte (find specified index)
*
* History:
*  Thu 18-Feb-1993 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

ULONG
rgbFromColorref(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG crColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG palTemp;
    palTemp.ul = crColor;

    if (palTemp.ul & 0x01000000)
    {
        //
        // This means they have an explicit entry in the DC palette they
        // want.  Only the lower byte is valid.
        //

        palTemp.ul &= 0x0000FFFF;

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        palTemp.pal = palDC.palentryGet(palTemp.ul);

        //
        // If PC_EXPLICIT reach into the surface palette if possible.
        //

        if (palTemp.pal.peFlags == PC_EXPLICIT)
        {
            if (palSurf.bValid())
            {
                if (palSurf.cEntries())
                {
                    palTemp.ul &= 0x000000FF;

                    if (palTemp.ul >= palSurf.cEntries())
                    {
                        palTemp.ul = palTemp.ul % palSurf.cEntries();
                    }

                    palTemp.pal = palSurf.palentryGet(palTemp.ul);
                }
            }
        }
    }

    palTemp.pal.peFlags = 0;

    return(palTemp.ul);
}

/******************************Public*Routine******************************\
* bEqualRGB_In_Palette
*
* This function determines if 2 palettes contain identical RGB entries and
* palette sizes and therefore have an identity xlate between them.  This is
* need with DIBSECTIONS which may have duplicate palette entries but still
* should have identity xlates when blting between them.
*
* History:
*  10-Mar-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bEqualRGB_In_Palette(XEPALOBJ palSrc, XEPALOBJ palDst)
{
    ASSERTGDI(palSrc.bValid(), "ERROR invalid SRC");
    ASSERTGDI(palDst.bValid(), "ERROR invalid DST");

    //
    // Check for equal size palettes that are == to 256 in size.
    // 256 is the size of our palette managed palettes.
    //

    if ((palSrc.cEntries() != palDst.cEntries()) ||
        (palDst.cEntries() != 256))
    {
        return(FALSE);
    }

    //
    // If the Dst is a DC palette make sure it contains an identity
    // realization in it.
    //

    UINT uiIndex;

    if (palDst.bIsPalDC())
    {
        //
        // Check the translate for the current if it's the screen, otherwise
        // check the translate for the foreground for a bitmap.
        //

        TRANSLATE *ptrans = palDst.ptransFore();

        if (ptrans == NULL)
            return(FALSE);

        uiIndex = palDst.cEntries();

        while(uiIndex--)
        {
            if (ptrans->ajVector[uiIndex] != uiIndex)
                return(FALSE);
        }
    }

    uiIndex = palDst.cEntries();
    ULONG ulTemp;

    while(uiIndex--)
    {
        ulTemp = palSrc.ulEntryGet(uiIndex) ^ palDst.ulEntryGet(uiIndex);

        if (ulTemp & 0xFFFFFF)
        {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\panning.cxx ===
/******************************Module*Header*******************************\
* Module Name: panning.cxx
*
* Contains the code for a layered 'virtual' driver that emulates panning
* by switching the display device to the requested panning dimensions, and
* creating a shadow buffer the size of the desktop to which GDI does all
* the drawing.  To update the physical display, we employ a 'dirty
* rectangles' technique where we simply blt from the shadow buffer to the
* screen for the affected areas.
*
* Created: 15-Sep-96
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern BOOL G_fDoubleDpi;

// The panning layer's equivalent of a 'PDEV':

typedef struct _PANDEV
{
    LONG        cxScreen;           // The smaller dimensions (the dimensions of
    LONG        cyScreen;           //   the physical screen)
    LONG        cxDesktop;          // The larger dimensions (the dimensions of
    LONG        cyDesktop;          //   the virtual desktop)
    RECTL       rclVisible;         // Position of panning window on virtual
                                    //   desktop
    DHPDEV      dhpdevDevice;       // The device's 'dhpdev'
    ULONG       iBitmapFormat;      // Bitmap format of surface
    FLONG       flOriginalCaps;     // Driver's original flGraphicsCaps setting
    HDEV        hdev;               // Handle to GDI's PDEV
    HSURF       hsurfScreen;        // Handle to GDI's surface
    SURFOBJ*    psoShadow;          // Pointer to our shadow surface
    SURFOBJ*    psoDevice;          // Pointer to device's surface
    SURFOBJ*    psoShrink;          // Pointer to shrink scratch buffer surface
    REGION*     prgnDirty;          // Points to the current dirty region
    REGION*     prgnOld;            // Points to the previous dirty region
    REGION*     prgnRect;           // Points to a rectangular region we cache
    BOOL        bDirty;             // If TRUE, we have some dirty rectangles
                                    //   that should be updated at the next tick
    PFN         apfn[INDEX_LAST];   // Dispatch table to device
} PANDEV;

/******************************Public*Routine******************************\
* VOID vPanningUpdate(ppan, prcl, pco)
*
* Updates the screen from the DIB surface for the given rectangle.
*
\**************************************************************************/

VOID vPanningUpdate(PANDEV* ppan, RECTL* prcl, CLIPOBJ* pco)
{
    RECTL rcl;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        rcl = *prcl;
    }
    else
    {
        // We may as well save ourselves some blting by clipping to
        // the clip object's maximum extent.  The clip object's bounds
        // are guaranteed to be contained within the dimensions of the
        // desktop:

        rcl.left   = max(pco->rclBounds.left,   prcl->left);
        rcl.top    = max(pco->rclBounds.top,    prcl->top);
        rcl.right  = min(pco->rclBounds.right,  prcl->right);
        rcl.bottom = min(pco->rclBounds.bottom, prcl->bottom);
    }

    if (ppan->psoShrink)
    {
        rcl.left >>= 1;
        rcl.top  >>= 1;
        rcl.right  = (rcl.right + 1) >> 1;
        rcl.bottom = (rcl.bottom + 1) >> 1;
    }

    if ((rcl.left < rcl.right) && (rcl.top < rcl.bottom))
    {
        // Merge this rectangle into the dirty region.  We swap the 'old'
        // and 'current' dirty regions in the process, so that we don't
        // have to do an extra allocation:
    
        RGNOBJ roRect(ppan->prgnRect);
        RGNOBJ roDirty(ppan->prgnOld);
        RGNOBJ roOld(ppan->prgnDirty);
    
        roRect.vSet(&rcl);
        if (!roDirty.bMerge(roOld, roRect, gafjRgnOp[RGN_OR]))
        {
            roDirty.vSet();
        }
    
        ppan->prgnOld   = roOld.prgnGet();
        ppan->prgnDirty = roDirty.prgnGet();
        ppan->bDirty    = TRUE;
    }
}

/******************************Public*Routine******************************\
* vFiltered2xShrinkRectangle32bpp
*
* Quick and dirty single rectangle 0.5x shrink with simple color averaging.
*
\**************************************************************************/

VOID vFilteredShrinkRectangle2x32bpp(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    RECTL*      prclDst)
{
    LONG        cx;
    LONG        cy;
    LONG        lSrcDelta;
    BYTE*       pjSrc;
    LONG        lSrcSkip;
    LONG        lDstDelta;
    BYTE*       pjDst;
    LONG        lDstSkip;
    LONG        i;
    ULONG       ulDst;

    ASSERTGDI((psoDst->iBitmapFormat == BMF_32BPP) &&
              (psoSrc->iBitmapFormat == BMF_32BPP),
        "Unexpected type");

    cy = prclDst->bottom - prclDst->top;
    cx = prclDst->right - prclDst->left;

    lSrcDelta = psoSrc->lDelta;
    pjSrc = (BYTE*) psoSrc->pvScan0 + (prclDst->top * 2) * lSrcDelta
                                    + (prclDst->left * 2) * sizeof(ULONG);
    lSrcSkip = 2 * lSrcDelta - (cx * 2 * sizeof(ULONG));

    lDstDelta = psoDst->lDelta;
    pjDst = (BYTE*) psoDst->pvScan0 + prclDst->top * lDstDelta
                                    + prclDst->left * sizeof(ULONG);
    lDstSkip = lDstDelta - (cx * sizeof(ULONG));

    do {
        i = cx;
        do {
            ulDst = *(pjSrc) 
                  + *(pjSrc + 4) 
                  + *(pjSrc + lSrcDelta) 
                  + *(pjSrc + 4 + lSrcDelta);

            *(pjDst) = (BYTE) (ulDst >> 2);

            ulDst = *(pjSrc + 1) 
                  + *(pjSrc + 5) 
                  + *(pjSrc + 1 + lSrcDelta) 
                  + *(pjSrc + 5 + lSrcDelta);

            *(pjDst + 1) = (BYTE) (ulDst >> 2);

            ulDst = *(pjSrc + 2) 
                  + *(pjSrc + 6) 
                  + *(pjSrc + 2 + lSrcDelta) 
                  + *(pjSrc + 6 + lSrcDelta);

            *(pjDst + 2) = (BYTE) (ulDst >> 2);

            pjDst += 4;
            pjSrc += 8;

        } while (--i != 0);

        pjDst += lDstSkip;
        pjSrc += lSrcSkip;

    } while (--cy != 0);
}

/******************************Public*Routine******************************\
* vFiltered2xShrink32bpp
*
* Quick and dirty bilinear filtered 2x shrink routine.
*
\**************************************************************************/

VOID vFilteredShrink2x32bpp(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    ECLIPOBJ*   pco,
    RECTL*      prclDst)
{
    BOOL            bMore;
    ULONG           i;
    CLIPENUMRECT    clenr;
    RECTL           rclDst;

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do {
        bMore = pco->bEnum(sizeof(clenr), &clenr);

        for (i = 0; i < clenr.c; i++)
        {
            if (bIntersect(&clenr.arcl[i], prclDst, &rclDst))
            {
                vFilteredShrinkRectangle2x32bpp(psoDst, psoSrc, &rclDst);
            }
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* PanSynchronize
*
* Dumps the list of dirty rectangles to the screen.  Because we set
* GCAPS2_SYNCTIMER, this routine is called by User 20 times a second.
*
\**************************************************************************/

VOID PanSynchronize(
DHPDEV  dhpdev,
RECTL*  prcl)
{
    PANDEV*             ppan;
    SURFACE*            psurfDevice;
    RECTL*              prclVisible;
    RECTL               rclDevice;
    RECTL               rclSrc;
    PFN_DrvCopyBits     pfnCopyBits;
    PFN_DrvStretchBlt   pfnStretchBlt;
    SURFOBJ*            psoCopySrc;
    SURFOBJ*            psoDst;
    SURFOBJ*            psoDevice;

    ppan = (PANDEV*) dhpdev;
    if (ppan->bDirty)
    {
        ECLIPOBJ eco;
        
        ASSERTGDI((ppan->rclVisible.right == ppan->rclVisible.left + ppan->cxScreen) &&
                  (ppan->rclVisible.bottom == ppan->rclVisible.top + ppan->cyScreen),
                  "Unexpected rclVisible dimensions");

        prclVisible = &ppan->rclVisible;

        eco.vSetup(ppan->prgnDirty, *(ERECTL*)prclVisible);
        if (!eco.erclExclude().bEmpty())
        {
            psurfDevice = SURFOBJ_TO_SURFACE(ppan->psoDevice);

            rclDevice.left   = 0;
            rclDevice.top    = 0;
            rclDevice.right  = psurfDevice->sizl().cx;
            rclDevice.bottom = psurfDevice->sizl().cy;

            // Assume we'll be calling CopyBits straight from the shadow
            // buffer:

            psoCopySrc = ppan->psoShadow;

            if (ppan->psoShrink)
            {
                ASSERTGDI(ppan->iBitmapFormat == BMF_32BPP,
                    "Expected psoShrink only when 32bpp");

                // As a small optimization, we can draw directly to the
                // frame buffer (and bypass the shrink buffer) if the primary 
                // surface was created as a GDI-managed surface:

                if (psurfDevice->iType() == STYPE_BITMAP)
                {
                    psoDst = psurfDevice->pSurfobj();
                    psoCopySrc = NULL;
                }
                else
                {
                    psoDst = ppan->psoShrink;
                    psoCopySrc = ppan->psoShrink;
                }

                vFilteredShrink2x32bpp(psoDst,
                                       ppan->psoShadow,
                                       &eco,
                                       &rclDevice);
            }

            if (psoCopySrc)
            {
                // Call the device's DrvCopyBits routine to do the copy (noting that
                // if it's an engine managed surface, we may have to call EngCopyBits):
    
                pfnCopyBits = (psurfDevice->flags() & HOOK_COPYBITS)
                            ? PPFNTABLE(ppan->apfn, CopyBits)
                            : EngCopyBits;
            
                (*pfnCopyBits)(psurfDevice->pSurfobj(),
                               psoCopySrc,
                               &eco,
                               NULL,
                               &rclDevice,
                               (POINTL*) prclVisible);
            }
        }

        // Mark the fact that we have no dirty rectangles, and clear the
        // dirty region:

        ppan->bDirty = FALSE;

        RGNOBJ ro(ppan->prgnDirty);
        ro.vSet();
    }
}

/******************************Public*Routine******************************\
* PanStrokePath
*
\**************************************************************************/

BOOL PanStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL    b;
    PANDEV* ppan;
    RECTFX  rcfxBounds;
    RECTL   rclBounds;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngStrokePath(ppan->psoShadow, ppo, pco, pxo, pbo, pptlBrush, pla, mix);

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    vPanningUpdate(ppan, &rclBounds, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanTransparentBlt
*
\**************************************************************************/

BOOL PanTransparentBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
RECTL*      prclSrc,
ULONG       iTransColor,
ULONG       ulReserved)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngTransparentBlt(ppan->psoShadow, psoSrc, pco, pxlo, prclDst,
                          prclSrc, iTransColor, ulReserved);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanAlphaBlend
*
\**************************************************************************/

BOOL PanAlphaBlend(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
BLENDOBJ*           pBlendObj)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngAlphaBlend(ppan->psoShadow, psoSrc, pco, pxlo, prclDst,
                      prclSrc, pBlendObj);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanGradientFill
*
\**************************************************************************/

BOOL PanGradientFill(
SURFOBJ*            pso,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
TRIVERTEX*          pVertex,
ULONG               nVertex,
PVOID               pMesh,
ULONG               nMesh,
RECTL*              prclExtents,
POINTL*             pptlDitherOrg,
ULONG               ulMode)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngGradientFill(ppan->psoShadow, pco, pxlo, pVertex, nVertex, pMesh,
                        nMesh, prclExtents, pptlDitherOrg, ulMode);

    vPanningUpdate(ppan, prclExtents, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanStretchBlt
*
\**************************************************************************/

BOOL PanStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) psoDst->dhpdev;

    b = EngStretchBlt(ppan->psoShadow, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMsk, iMode);

    vPanningUpdate(ppan, prclDst, pco);

    return(b);
}

/******************************Public*Routine******************************\
* PanBitBlt
*
\**************************************************************************/

BOOL PanBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL    bUpdate;
    BOOL    b;
    PANDEV* ppan;

    bUpdate = FALSE;
    if (psoDst->iType == STYPE_DEVICE)
    {
        bUpdate = TRUE;
        ppan    = (PANDEV*) psoDst->dhpdev;
        psoDst  = ppan->psoShadow;
    }
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ppan    = (PANDEV*) psoSrc->dhpdev;
        psoSrc  = ppan->psoShadow;
    }

    b = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc,
                  pptlMask, pbo, pptlBrush, rop4);

    if (bUpdate)
    {
        vPanningUpdate(ppan, prclDst, pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* PanCopyBits
*
\**************************************************************************/

BOOL PanCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL    bUpdate;
    BOOL    b;
    PANDEV* ppan;

    return(PanBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc,
                     NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* PanTextOut
*
\**************************************************************************/

BOOL PanTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL    b;
    PANDEV* ppan;

    ppan = (PANDEV*) pso->dhpdev;

    b = EngTextOut(ppan->psoShadow, pstro, pfo, pco, prclExtra, prclOpaque,
                   pboFore, pboOpaque, pptlOrg, mix);

    vPanningUpdate(ppan,
                   (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                   pco);

    return(b);
}

/******************************Public*Routine******************************\
* VOID PanMovePointer
*
\**************************************************************************/

VOID PanMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PANDEV*             ppan;
    BOOL                bUpdate;
    PFN_DrvMovePointer  pfnMovePointer;

    ppan = (PANDEV*) pso->dhpdev;

    // A negative 'y' coordinate indicates a positional notification.
    // Use this to move the panning coordinates if need be:

    ASSERTGDI((y < 0) && (x >= 0), "Unexpected coordinates");

    // It's weird, but the display driver may actually be panning
    // underneath our virtual panning display driver!  (This will
    // only happen when all the video driver's accelerations are
    // disabled.)

    pfnMovePointer = PPFNTABLE(ppan->apfn, MovePointer);
    if ((pfnMovePointer != NULL) &&
        (ppan->flOriginalCaps & GCAPS_PANNING))
    {
        (*pfnMovePointer)(ppan->psoDevice,
                          x,
                          y,
                          prcl);
    }

    // Adjust to positive space:

    y += pso->sizlBitmap.cy;

    bUpdate = FALSE;

    if (x < ppan->rclVisible.left)
    {
        ppan->rclVisible.left  = x;
        ppan->rclVisible.right = x + ppan->cxScreen;
        bUpdate = TRUE;
    }
    if (x > ppan->rclVisible.right)
    {
        ppan->rclVisible.right = x;
        ppan->rclVisible.left  = x - ppan->cxScreen;
        bUpdate = TRUE;
    }
    if (y < ppan->rclVisible.top)
    {
        ppan->rclVisible.top    = y;
        ppan->rclVisible.bottom = y + ppan->cyScreen;
        bUpdate = TRUE;
    }
    if (y > ppan->rclVisible.bottom)
    {
        ppan->rclVisible.bottom = y;
        ppan->rclVisible.top    = y - ppan->cyScreen;
        bUpdate = TRUE;
    }

    ASSERTGDI((ppan->rclVisible.left >= 0) &&
              (ppan->rclVisible.top  >= 0) &&
              (ppan->rclVisible.right  <= ppan->cxDesktop) &&
              (ppan->rclVisible.bottom <= ppan->cyDesktop),
              "unexpected pointer coordinates");

    if (bUpdate)
    {
        // The panning coordinates changed, so update the display.
        //
        // NOTE: A screen-to-screen blt could be done as an optimization.

        vPanningUpdate(ppan,
                       &ppan->rclVisible,
                       NULL);
    }

    // Flush anything pending.  We do this for a couple of reasons:
    //
    //    1. To flush the vPanningUpdate we may have just done;
    //    2. For smoother mouse movement.

    PanSynchronize((DHPDEV) ppan, NULL);
}

/******************************Public*Routine******************************\
* PanDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colors.
*
\**************************************************************************/

ULONG APIENTRY PanDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PANDEV* ppan;
    ULONG   iRet;

    ppan = (PANDEV*) dhpdev;

    // EngDitherColor supports dithers only for 8bpp and higher, so at 
    // anything lower we have to call the driver.

    if (ppan->iBitmapFormat >= BMF_8BPP)
    {
        iRet = EngDitherColor(ppan->hdev, iMode, rgb, pul);
    }
    else
    {
        iRet = PPFNTABLE(ppan->apfn, DitherColor)(ppan->dhpdevDevice, 
                                                  iMode, 
                                                  rgb, 
                                                  pul);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL PanSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL PanSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppal,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    return((*PPFNTABLE(ppan->apfn, SetPalette))(ppan->dhpdevDevice,
                                                ppal,
                                                fl,
                                                iStart,
                                                cColors));
}

/******************************Public*Routine******************************\
* VOID PanAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL PanAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PANDEV* ppan;
    BOOL    b;

    ppan = (PANDEV*) dhpdev;

    b = (*PPFNTABLE(ppan->apfn, AssertMode))(ppan->dhpdevDevice,
                                             bEnable);

    return(b);
}

/******************************Public*Routine******************************\
* DHPDEV PanEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after PanEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; PanEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV PanEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PANDEV*     ppan;
    PFN*        ppfnDevice;
    DHPDEV      dhpdevDevice;
    GDIINFO*    pGdiInfo;
    DEVMODEW    dmTmp;

    ASSERTGDI((pdm->dmPanningWidth  <= pdm->dmPelsWidth) &&
              (pdm->dmPanningHeight <= pdm->dmPelsHeight),
              "Bad devmode sizes");

    ppan = (PANDEV*) PALLOCMEM(sizeof(PANDEV), 'napG');
    if (ppan != NULL)
    {
        PPDEV ppdev = (PPDEV)hdev;

        // Snag a copy of the device's dispatch table, from
        // the private PDEV structure, which is the hdev.

        ppfnDevice = &ppdev->pldev->apfn[0];

        RtlCopyMemory(ppan->apfn, ppfnDevice, sizeof(PFN) * INDEX_LAST);

        // Remember our dimensions:

        ppan->cxDesktop = pdm->dmPelsWidth;
        ppan->cyDesktop = pdm->dmPelsHeight;

        if (pdm->dmPanningWidth != 0)
        {
            ppan->cxScreen = pdm->dmPanningWidth;
            ppan->cyScreen = pdm->dmPanningHeight;
        }
        else
        {
            ppan->cxScreen = pdm->dmPelsWidth;
            ppan->cyScreen = pdm->dmPelsHeight;
        }

        // Ask the driver to set its physical mode to the panning
        // dimensions:

        dmTmp = *pdm;
        dmTmp.dmPelsWidth  = ppan->cxScreen;
        dmTmp.dmPelsHeight = ppan->cyScreen;

        // But wait, if we're being asked to double the DPI and the
        // mode is 32bpp, drvsup.cxx already set up the Devmode so
        // that it's double the actual resolution.  That means that we
        // then have to halve the resolution that we request of the
        // driver:

        if ((G_fDoubleDpi) && (dmTmp.dmBitsPerPel == 32))
        {
            dmTmp.dmPelsWidth >>= 1;
            dmTmp.dmPelsHeight >>= 1;
        }

        dhpdevDevice = (*PPFNTABLE(ppan->apfn, EnablePDEV))
                            (&dmTmp,
                             pwszLogAddr,
                             cPat,
                             phsurfPatterns,
                             cjCaps,
                             (GDIINFO*) pdevcaps,
                             cjDevInfo,
                             pdi,
                             hdev,
                             pwszDeviceName,
                             hDriver);

        if (dhpdevDevice != NULL)
        {
            ppan->iBitmapFormat  = pdi->iDitherFormat;
            ppan->dhpdevDevice   = dhpdevDevice;
            ppan->hdev           = hdev;
            ppan->flOriginalCaps = pdi->flGraphicsCaps;

            // The display driver will have set the desktop coordinates
            // to the smaller screen coordinates, so we'll have to
            // overwrite that:

            pGdiInfo = (GDIINFO*) pdevcaps;

            pGdiInfo->ulHorzRes = ppan->cxDesktop;
            pGdiInfo->ulVertRes = ppan->cyDesktop;

            // Overwrite some of the driver's capabilities:

            pdi->flGraphicsCaps &= (GCAPS_PALMANAGED  |
                                    GCAPS_MONO_DITHER |
                                    GCAPS_COLOR_DITHER);
            pdi->flGraphicsCaps |= GCAPS_PANNING;

            // Enable synchronization calls:

            pdi->flGraphicsCaps2 = (GCAPS2_SYNCFLUSH |
                                    GCAPS2_SYNCTIMER);

            return((DHPDEV) ppan);
        }

        VFREEMEM(ppan);
    }

    return(0);
}

/******************************Public*Routine******************************\
* PanDisablePDEV
*
* Release the resources allocated in PanEnablePDEV.  If a surface has been
* enabled PanDisableSurface will have already been called.
*
\**************************************************************************/

VOID PanDisablePDEV(
DHPDEV  dhpdev)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    (*PPFNTABLE(ppan->apfn, DisablePDEV))(ppan->dhpdevDevice);

    VFREEMEM(ppan);
}

/******************************Public*Routine******************************\
* VOID PanCompletePDEV
*
\**************************************************************************/

VOID PanCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    PANDEV* ppan;

    ppan = (PANDEV*) dhpdev;

    ppan->hdev = hdev;

    (*PPFNTABLE(ppan->apfn, CompletePDEV))(ppan->dhpdevDevice,
                                           hdev);
}

/******************************Public*Routine******************************\
* HSURF PanEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after PanEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF PanEnableSurface(
DHPDEV dhpdev)
{
    PANDEV*     ppan;
    HSURF       hsurfDevice;
    HSURF       hsurfScreen;
    HSURF       hsurfShadow;
    HSURF       hsurfShrink;
    SIZEL       sizl;
    SIZEL       sizlShrink;
    SURFOBJ*    psoShadow;
    SURFOBJ*    psoDevice;
    SURFOBJ*    psoShrink;
    BOOL        bShrink;

    ppan = (PANDEV*) dhpdev;

    // Initialize the paning position:

    ppan->rclVisible.left   = (ppan->cxDesktop - ppan->cxScreen) >> 1;
    ppan->rclVisible.top    = (ppan->cyDesktop - ppan->cyScreen) >> 1;
    ppan->rclVisible.right  = (ppan->rclVisible.left + ppan->cxScreen);
    ppan->rclVisible.bottom = (ppan->rclVisible.top  + ppan->cyScreen);

    // Call the device to enable its surface:

    hsurfDevice = (*PPFNTABLE(ppan->apfn, EnableSurface))(ppan->dhpdevDevice);
    if (hsurfDevice)
    {
        psoDevice = EngLockSurface(hsurfDevice);
        if (psoDevice)
        {
            SURFACE* pDevSurface = SURFOBJ_TO_SURFACE(psoDevice);

            pDevSurface->flags(pDevSurface->flags() & ~(HOOK_SYNCHRONIZE));

            ppan->psoDevice = psoDevice;

            // Now reset the device's 'dhpdev' field that the device's
            // EngAssociateSurface call so rudely overwrote with the pointer
            // to *our* 'ppan' structure!

            psoDevice->dhpdev = ppan->dhpdevDevice;

            // Have GDI create the actual SURFOBJ.
            //
            // Our drawing surface is going to be 'device-managed', meaning
            // that GDI cannot draw on the framebuffer bits directly, and as
            // such we create the surface via EngCreateSurface.  By doing
            // this, we ensure that GDI will only ever access the bitmaps
            // bits via the Pan calls that we've HOOKed.

            sizl.cx = ppan->cxDesktop;
            sizl.cy = ppan->cyDesktop;

            hsurfScreen = EngCreateDeviceSurface(NULL,
                                                 sizl,
                                                 ppan->iBitmapFormat);
            if (hsurfScreen != 0)
            {
                ppan->hsurfScreen = hsurfScreen;

                // Now associate the surface and the PANDEV.
                //
                // We have to associate the surface we just created with our
                // physical device so that GDI can get information related to
                // the PANDEV when it's drawing to the surface (such as, for
                // example, the length of styles on the device when simulating
                // styled lines).

                if (EngAssociateSurface(hsurfScreen,
                                        ppan->hdev,
                                        (HOOK_BITBLT         |
                                         HOOK_TEXTOUT        |
                                         HOOK_COPYBITS       |
                                         HOOK_STRETCHBLT     |
                                         HOOK_ALPHABLEND     |
                                         HOOK_TRANSPARENTBLT |
                                         HOOK_GRADIENTFILL   |
                                         HOOK_STROKEPATH     |
                                         HOOK_SYNCHRONIZE)))
                {
                    // Create the shadow DIB on which we'll have GDI do all
                    // the drawing.  We'll merely occasionally blt portions
                    // to the screen to update.

                    hsurfShadow = (HSURF) EngCreateBitmap(sizl,
                                                          sizl.cx,
                                                          ppan->iBitmapFormat,
                                                          BMF_TOPDOWN,
                                                          NULL);

                    psoShadow = EngLockSurface(hsurfShadow);
                    if (psoShadow != NULL)
                    {
                        ppan->psoShadow = psoShadow;

                        // If we're doing the double-dpi thing, we need to
                        // create a scratch buffer for the shrink:

                        hsurfShrink = NULL;
                        psoShrink = NULL;
                        bShrink = ((G_fDoubleDpi) && 
                                   (ppan->iBitmapFormat == BMF_32BPP));

                        if (bShrink)
                        {
                            // Create a temporary surface used as the scratch 
                            // buffer destination for our 'shrink' blt:

                            sizlShrink.cx = sizl.cx >> 1;
                            sizlShrink.cy = sizl.cy >> 1;
    
                            hsurfShrink = (HSURF) EngCreateBitmap(sizlShrink,
                                                                  sizlShrink.cx,
                                                                  ppan->iBitmapFormat,
                                                                  BMF_TOPDOWN,
                                                                  NULL);
                            psoShrink = EngLockSurface(hsurfShrink);
                        }

                        // If shrinking and couldn't allocate 'psoShrink', 
                        // then fail:

                        if ((!bShrink) || (psoShrink != NULL))
                        {
                            ppan->psoShrink = psoShrink;

                            if (EngAssociateSurface(hsurfShadow,
                                                    ppan->hdev,
                                                    0))
                            {
                                RGNMEMOBJ rmoDirty;
                                RGNMEMOBJ rmoOld;
                                RGNMEMOBJ rmoRect;
    
                                if ((rmoOld.bValid()) && 
                                    (rmoDirty.bValid()) && 
                                    (rmoRect.bValid()))
                                {
                                    rmoDirty.vSet();
                                    rmoOld.vSet();
    
                                    ppan->prgnDirty = rmoDirty.prgnGet();
                                    ppan->prgnOld   = rmoOld.prgnGet();
                                    ppan->prgnRect  = rmoRect.prgnGet();
    
                                    // Blank the screen:
    
                                    PanSynchronize(dhpdev, NULL);
        
                                    // Success!
        
                                    return(hsurfScreen);
                                }
    
                                rmoOld.vDeleteRGNOBJ();
                                rmoDirty.vDeleteRGNOBJ();
                                rmoRect.vDeleteRGNOBJ();
                            }
                        }

                        EngUnlockSurface(psoShrink);
                        EngDeleteSurface(hsurfShrink);
                    }

                    EngUnlockSurface(psoShadow);
                    EngDeleteSurface(hsurfShadow);
                }

                EngDeleteSurface(hsurfScreen);
            }

            EngUnlockSurface(psoDevice);
        }

        (*PPFNTABLE(ppan->apfn, DisableSurface))(ppan->dhpdevDevice);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID PanDisableSurface
*
* Free resources allocated by PanEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID PanDisableSurface(
DHPDEV dhpdev)
{
    PANDEV*   ppan;
    HSURF     hsurfShadow;
    HSURF     hsurfShrink;

    ppan = (PANDEV*) dhpdev;

    RGNOBJ roDirty(ppan->prgnDirty);
    RGNOBJ roOld(ppan->prgnOld);
    RGNOBJ roRect(ppan->prgnRect);

    roOld.vDeleteRGNOBJ();
    roDirty.vDeleteRGNOBJ();
    roRect.vDeleteRGNOBJ();

    hsurfShadow = ppan->psoShadow->hsurf;
    EngUnlockSurface(ppan->psoShadow);
    EngDeleteSurface(hsurfShadow);

    if (ppan->psoShrink)
    {
        hsurfShrink = ppan->psoShrink->hsurf;
        EngUnlockSurface(ppan->psoShrink);
        EngDeleteSurface(hsurfShrink);
    }

    EngDeleteSurface(ppan->hsurfScreen);
    EngUnlockSurface(ppan->psoDevice);

    (*PPFNTABLE(ppan->apfn, DisableSurface))(ppan->dhpdevDevice);
}

/******************************Public*Structure****************************\
* DFVFN gadrvfnPanning[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

DRVFN gadrvfnPanning[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) PanEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) PanCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) PanDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) PanEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) PanDisableSurface         },
    {   INDEX_DrvDitherColor,           (PFN) PanDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) PanAssertMode             },
    {   INDEX_DrvBitBlt,                (PFN) PanBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) PanTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) PanStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) PanCopyBits               },
    {   INDEX_DrvTransparentBlt,        (PFN) PanTransparentBlt         },
    {   INDEX_DrvAlphaBlend,            (PFN) PanAlphaBlend             },
    {   INDEX_DrvGradientFill,          (PFN) PanGradientFill           },
    {   INDEX_DrvStretchBlt,            (PFN) PanStretchBlt             },
    {   INDEX_DrvSetPalette,            (PFN) PanSetPalette             },
    {   INDEX_DrvMovePointer,           (PFN) PanMovePointer            },
    {   INDEX_DrvSynchronize,           (PFN) PanSynchronize            },
};

ULONG gcdrvfnPanning = sizeof(gadrvfnPanning) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL PanEnableDriver
*
* Standard driver DrvEnableDriver function
*
\**************************************************************************/

BOOL PanEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnPanning;
    pded->c              = gcdrvfnPanning;
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\patblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: patblt.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with solid color and patterns.
*
* Created: 03-Mar-1991 22:01:14
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// The amount to shift cx and xDstStart left by

ULONG aulShiftFormat[7] =
{
    0,  // BMF_DEVICE
    0,  // BMF_1BPP
    2,  // BMF_4BPP
    3,  // BMF_8BPP
    4,  // BMF_16BPP
    0,  // BMF_24BPP
    5   // BMF_32BPP
};

PFN_PATBLT apfnPatBlt[][3] =
{
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { NULL,         NULL,         NULL         },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 },
    { vPatCpyRect8, vPatNotRect8, vPatXorRect8 }
};

ULONG aulMulFormat[] =
{
    0,   // BMF_DEVICE
    0,   // BMF_1BPP
    0,   // BMF_4BPP
    1,   // BMF_8BPP
    2,   // BMF_16BPP
    3,   // BMF_24BPP
    4    // BMF_32BPP
};

/******************************Public*Routine******************************\
* vDIBSolidBlt
*
* This does solid color and DstInvert blts.
*
* History:
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Improved it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vDIBSolidBlt(
SURFACE    *pSurfDst,
RECTL     *prclDst,
CLIPOBJ   *pco,
ULONG      iColor,    // the index to use for color.
BOOL       bInvert)
{
    PFN_SOLIDBLT pfnDibSolid;
    ULONG        cShift;       // Shift by this for format conversion
    ULONG        ircl;
    PBYTE        pjDstBits;
    LONG         lDeltaDst;
    BOOL         bMore = FALSE;
    BOOL         bClip = FALSE;
    CLIPENUMRECT clenr;

    //ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibSo");

// Set ircl to be the format of the dst surface.

    ircl = pSurfDst->iFormat();

// Assert the world is in order for our switch

    ASSERTGDI((ircl >= BMF_1BPP) && (ircl <= BMF_32BPP), "ERROR GDI vDibPatBlt");

// Set up cShift, pfnDibSolid, and iColor.

    cShift = aulShiftFormat[ircl];

    if (bInvert)
    {
        if (ircl == BMF_24BPP)
            pfnDibSolid = vSolidXorRect24;
        else
            pfnDibSolid = vSolidXorRect1;
    }
    else
    {
        if (ircl == BMF_24BPP)
            pfnDibSolid = vSolidFillRect24;
        else
            pfnDibSolid = vSolidFillRect1;
    }

// Note cascaded fall through on switch to build up iColor.
// Also note that 24BPP doesn't change.
// Finally, note that the non-significant bits have to be masked off because
// we generate Pn in the calling routine with ~.

    switch(ircl)
    {
    case BMF_1BPP:

        if ((iColor &= 1) != 0)
            iColor = 0xFFFFFFFF;
        break;

    case BMF_4BPP:

        iColor &= 0x0F;
        iColor = iColor | (iColor << 4);

    case BMF_8BPP:

        iColor &= 0xFF;
        iColor = iColor | (iColor << 8);

    case BMF_16BPP:

        iColor &= 0xFFFF;
        iColor = iColor | (iColor << 16);
    }

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            break;
        case DC_RECT:
            bClip = TRUE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping
            break;
        case DC_COMPLEX:
            bClip = TRUE;
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,CT_RECTANGLES,CD_ANY,CLIPOBJ_ENUM_LIMIT);
            break;
        default:
            RIP("ERROR: vDIBSolidBlt - bad clipping type");
        }
    }

    pjDstBits = (PBYTE) pSurfDst->pvScan0();
    lDeltaDst = pSurfDst->lDelta();

    if (!bClip)
    {
        (*pfnDibSolid)(
                    prclDst,
                    1,
                    pjDstBits,
                    lDeltaDst,
                    iColor,
                    cShift);
    }
    else
        do
        {
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;

                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;

                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;

                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

            // We check for NULL or inverted rectanges because we may get them.

                if ((prcl->top < prcl->bottom) &&
                    (prcl->left < prcl->right))
                {
                    (*pfnDibSolid)(
                                    prcl,
                                    1,
                                    pjDstBits,
                                    lDeltaDst,
                                    iColor,
                                    cShift);
                }

            }
        } while (bMore);
}

/******************************Public*Routine******************************\
* vDIBPatBlt
*
* This does pattern blts
*
* History:
*  20-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vDIBPatBlt(
SURFACE    *pSurfDst,
CLIPOBJ   *pco,
RECTL     *prclDst,
BRUSHOBJ  *pbo,
POINTL    *pptlBrush,
ULONG      iMode)
{
    PFN_PATBLT   pfnPat;
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    ULONG        ircl;
    BOOL         bMore = FALSE;
    BOOL         bClip = FALSE;

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

// Set ircl to be the format of the dst surface.

    ircl = pSurfDst->iFormat();

// Assert the world is in order for our switch

    ASSERTGDI((ircl >= BMF_1BPP) && (ircl <= BMF_32BPP), "ERROR GDI vDibPatBlt");

// Set up pfnPat and cMul.

    pfnPat = apfnPatBlt[ircl][iMode];
    pbf.cMul = aulMulFormat[ircl];

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:
            break;
        case DC_RECT:
            bClip = TRUE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping
            break;
        case DC_COMPLEX:
            bClip = TRUE;
            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,CT_RECTANGLES,CD_ANY,CLIPOBJ_ENUM_LIMIT);
            break;
        default:
            RIP("ERROR: vDibPatBlt - bad clipping type");
        }
    }

    pbf.pvTrg     = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat     = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;
    pbf.lDeltaPat = ((EBRUSHOBJ *) pbo)->pengbrush()->lDeltaPat;
    pbf.cxPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cxPat * pbf.cMul;
    pbf.cyPat     = ((EBRUSHOBJ *) pbo)->pengbrush()->cyPat;
    pbf.xPat      = pptlBrush->x * pbf.cMul;
    pbf.yPat      = pptlBrush->y;

    if (!bClip)
    {
        pbf.pvObj = (PVOID) prclDst;
        (*pfnPat)(&pbf);
    }
    else
        do
        {
            if (bMore)
                bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            for (ircl = 0; ircl < clenr.c; ircl++)
            {
                PRECTL prcl = &clenr.arcl[ircl];

                if (prcl->left < prclDst->left)
                    prcl->left = prclDst->left;

                if (prcl->right > prclDst->right)
                    prcl->right = prclDst->right;

                if (prcl->top < prclDst->top)
                    prcl->top = prclDst->top;

                if (prcl->bottom > prclDst->bottom)
                    prcl->bottom = prclDst->bottom;

            // We check for NULL or inverted rectanges because we may get them.

                if ((prcl->top < prcl->bottom) &&
                    (prcl->left < prcl->right))
                {
                    pbf.pvObj = (PVOID) prcl;
                    (*pfnPat)(&pbf);
                }
            }
        } while (bMore);
}

/******************************Public*Routine******************************\
* vDIBPatBltSrccopy8x8
*
* This does only SRCCOPY blts of 8x8 patterns to DIBs.
* lDelta for the pattern must be exactly # of bytes per pixel * 8.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vDIBPatBltSrccopy8x8(
SURFACE    *pSurfDst,
CLIPOBJ   *pco,
RECTL     *prclDst,
BRUSHOBJ  *pbo,
POINTL    *pptlBrush,
PFN_PATBLT2 pfnPat)
{
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    BOOL         bMore;
    PRECTL       prcl;
    INT          ircl;

// Assert this is the right sort of destination

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

    pbf.pvTrg = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;
    pbf.lDeltaPat = ((EBRUSHOBJ *) pbo)->pengbrush()->lDeltaPat;

    //
    // Force the X and Y pattern origin coordinates into the ranges 0-7 and 0-7,
    // so we don't have to do modulo arithmetic all over again at a lower level
    //

    pbf.xPat = pptlBrush->x & 0x07;
    pbf.yPat = pptlBrush->y & 0x07;

    if (pco == (CLIPOBJ *) NULL)
    {

    // Unclipped

        pbf.pvObj = (PVOID) prclDst;
        pfnPat(&pbf, 1);
        return;
    }
    else
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:                    // unclipped

            pbf.pvObj = (PVOID) prclDst;
            pfnPat(&pbf, 1);
            return;

        case DC_RECT:                       // rectangle clipped

            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping

        // Clip the destination rectangle to the clip rectangle; it's
        // guaranteed that the resulting rectangle will never be null

            if (clenr.arcl[0].left <= prclDst->left)
                clenr.arcl[0].left = prclDst->left;

            if (clenr.arcl[0].right >= prclDst->right)
                clenr.arcl[0].right = prclDst->right;

            if (clenr.arcl[0].top <= prclDst->top)
                clenr.arcl[0].top = prclDst->top;

            if (clenr.arcl[0].bottom >= prclDst->bottom)
                clenr.arcl[0].bottom = prclDst->bottom;

            if ((clenr.arcl[0].left < clenr.arcl[0].right) &&
                (clenr.arcl[0].top  < clenr.arcl[0].bottom))
            {
                pbf.pvObj = (PVOID) clenr.arcl;
                pfnPat(&pbf, 1);
            }

            return;

        case DC_COMPLEX:                // complex region clipped

            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,
                                           CT_RECTANGLES,
                                           CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);

            do
            {

            // Get the next batch of rectangles in the clip region

                bMore =
                    ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            // If there are any rectangles in this enumeration, clip the
            // destination rectangle to each clip region rectangle, then
            // fill all the rectangles at once

                if (clenr.c > 0)
                {

                // Clip the rectangles

                    for (ircl = 0, prcl = clenr.arcl; ircl < (INT) clenr.c;
                            ircl++, prcl++)
                    {
                        if (prcl->left < prclDst->left)
                            prcl->left = prclDst->left;

                        if (prcl->right > prclDst->right)
                            prcl->right = prclDst->right;

                        if (prcl->top < prclDst->top)
                            prcl->top = prclDst->top;

                        if (prcl->bottom > prclDst->bottom)
                            prcl->bottom = prclDst->bottom;

                        //
                        // make sure rectangle is not inverted,
                        // this can happen for single scan line
                        // clip regions clipped to dst. If found,
                        // set to NULL rectangle
                        //

                        if (prcl->right < prcl->left)
                        {
                            prcl->right = prcl->left;
                        }

                        if (prcl->bottom < prcl->top)
                        {
                            prcl->bottom = prcl->top;
                        }

                    }

                // Draw the rectangles

                    pbf.pvObj = (PVOID) clenr.arcl;
                    pfnPat(&pbf, (INT) clenr.c);
                }

            } while (bMore);

            return;

        default:
            RIP("ERROR: vDIBPatBltSrccopy8x8 - bad clipping type");
        }
    }
}

/******************************Public*Routine******************************\
* vDIBnPatBltSrccopy6x6
*
* This does SRCCOPY pattern blts to 6x6 4-bpp DIBs and 1-bpp DIBs.
* lDelta for the pattern must be exactly 6 pixels (4 bytes).
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
*
*  17-Nov-1992 -by- Stephen Estrop [StephenE]
* Made it take a pointer to a
\**************************************************************************/

VOID vDIBnPatBltSrccopy6x6(
SURFACE              *pSurfDst,
CLIPOBJ             *pco,
RECTL               *prclDst,
BRUSHOBJ            *pbo,
POINTL              *pptlBrush,
PFN_PATBLT2 pfnPatBlt)
{
    PATBLTFRAME  pbf;
    CLIPENUMRECT clenr;
    BOOL         bMore;
    PRECTL       prcl;
    ULONG        ircl;

// Assert this is the right sort of destination

    ASSERTGDI(pSurfDst->iType() == STYPE_BITMAP, "ERROR GDI vDibPat");

    pbf.pvTrg = pSurfDst->pvScan0();
    pbf.lDeltaTrg = pSurfDst->lDelta();
    pbf.pvPat = (PVOID) ((EBRUSHOBJ *) pbo)->pengbrush()->pjPat;

// Force the X and Y pattern origin coordinates into the ranges 0-5 and 0-5,
// so we don't have to do modulo arithmetic all over again at a lower level

    if (pptlBrush->x >= 0)
        pbf.xPat = pptlBrush->x % 0x06;
    else
        pbf.xPat = (6 - 1) - ((-pptlBrush->x - 1) % 6);

    if (pptlBrush->y >= 0)
        pbf.yPat = pptlBrush->y % 0x06;
    else
        pbf.yPat = (6 - 1) - ((-pptlBrush->y - 1) % 6);

    if (pco == (CLIPOBJ *) NULL)
    {

    // Unclipped

        pbf.pvObj = (PVOID) prclDst;
        (*pfnPatBlt)(&pbf, 1);
        return;
    }
    else
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:                    // unclipped

            pbf.pvObj = (PVOID) prclDst;
            (*pfnPatBlt)(&pbf, 1);
            return;

        case DC_RECT:                       // rectangle clipped

            clenr.arcl[0] = pco->rclBounds; // Use acclerator for clipping

        // Clip the destination rectangle to the clip rectangle

            if (clenr.arcl[0].left <= prclDst->left)
                clenr.arcl[0].left = prclDst->left;

            if (clenr.arcl[0].right >= prclDst->right)
                clenr.arcl[0].right = prclDst->right;

            if (clenr.arcl[0].top <= prclDst->top)
                clenr.arcl[0].top = prclDst->top;

            if (clenr.arcl[0].bottom >= prclDst->bottom)
                clenr.arcl[0].bottom = prclDst->bottom;

            if ((clenr.arcl[0].left < clenr.arcl[0].right) &&
                (clenr.arcl[0].top  < clenr.arcl[0].bottom))
            {
                pbf.pvObj = (PVOID) clenr.arcl;
                (*pfnPatBlt)(&pbf, 1);
            }

            return;

        case DC_COMPLEX:                // complex region clipped

            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,
                                           CT_RECTANGLES,
                                           CD_ANY,
                                           CLIPOBJ_ENUM_LIMIT);

            do
            {

            // Get the next batch of rectangles in the clip region

                bMore =
                    ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);

            // If there are any rectangles in this enumeration, clip the
            // destination rectangle to each clip region rectangle, then
            // fill all the rectangles at once

                if (clenr.c > 0)
                {

                // Clip the rectangles

                    for (ircl = 0, prcl = clenr.arcl; ircl < clenr.c;
                            ircl++, prcl++)
                    {
                        if (prcl->left < prclDst->left)
                            prcl->left = prclDst->left;

                        if (prcl->right > prclDst->right)
                            prcl->right = prclDst->right;

                        if (prcl->top < prclDst->top)
                            prcl->top = prclDst->top;

                        if (prcl->bottom > prclDst->bottom)
                            prcl->bottom = prclDst->bottom;
                    }

                // Draw the rectangles

                    pbf.pvObj = (PVOID) clenr.arcl;
                    (*pfnPatBlt)(&pbf, clenr.c);
                }

            } while (bMore);

            return;

        default:
            RIP("ERROR: vDIBnSrccopyPatBlt - bad clipping type");
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pathflat.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathflat.cxx
*
* Code to flatten paths
*
* Created: 3-Dec-1990 10:15:00
* Author: Paul Butzi [paulb]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "pathwide.hxx"

#define INLINE inline

INLINE BOOL bIntersect(RECTFX* prcfx1, RECTFX* prcfx2)
{
    BOOL bRet = (prcfx1->yTop <= prcfx2->yBottom &&
                 prcfx1->yBottom >= prcfx2->yTop &&
                 prcfx1->xLeft <= prcfx2->xRight &&
                 prcfx1->xRight >= prcfx2->xLeft);
    return(bRet);
}

INLINE VOID vBoundBox(POINTFIX* aptfx, RECTFX* prcfx)
{
    if (aptfx[0].x >= aptfx[1].x)
        if (aptfx[2].x >= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[2].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[3].x);
        }
    else
        if (aptfx[2].x <= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[3].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[2].x);
        }

    if (aptfx[0].y >= aptfx[1].y)
        if (aptfx[2].y >= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[2].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[3].y);
        }
    else
        if (aptfx[2].y <= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[3].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[2].y);
        }
}

INLINE VOID HFDBASIS32::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
//    ASSERTGDI(((p1 | p2 | p3 | p4) & 0xffffc000) == 0, "Range too big");

    #if (LTOFX(1) != 0x10)
    #error "FIX format changed, update flattener routine"
    #endif

// Change basis and convert from 28.4 to 18.14 format:

    e0 = (p1                     ) << 10;
    e1 = (p4 - p1                ) << 10;
    e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
    e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
}

INLINE VOID HFDBASIS32::vLazyHalveStepSize(LONG cShift)
{
    e2 = (e2 + e3) >> 1;
    e1 = (e1 - (e2 >> cShift)) >> 1;
}

INLINE VOID HFDBASIS32::vSteadyState(LONG cShift)
{
// We now convert from 18.14 fixed format to 15.17:

    e0 <<= 3;
    e1 <<= 3;

    register LONG lShift = cShift - 3;

    if (lShift < 0)
    {
        lShift = -lShift;
        e2 <<= lShift;
        e3 <<= lShift;
    }
    else
    {
        e2 >>= lShift;
        e3 >>= lShift;
    }
}

INLINE VOID HFDBASIS32::vHalveStepSize()
{
    e2 = (e2 + e3) >> 3;
    e1 = (e1 - e2) >> 1;
    e3 >>= 2;
}

INLINE VOID HFDBASIS32::vDoubleStepSize()
{
    e1 += e1 + e2;
    e3 <<= 2;
    e2 = (e2 << 3) - e3;
}

INLINE VOID HFDBASIS32::vTakeStep()
{
    e0 += e1;
    register LONG lTemp = e2;
    e1 += lTemp;
    e2 += lTemp - e3;
    e3 = lTemp;
}

typedef struct _BEZIERCONTROLS {
    POINTFIX ptfx[4];
} BEZIERCONTROLS;

BOOL BEZIER32::bInit(
POINTFIX* aptfxBez,     // Pointer to 4 control points
RECTFX* prcfxClip)      // Bound box of visible region (optional)
{
    POINTFIX aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register FIX fxOr;
        register FIX fxOffset;

        fxOffset = rcfxBound.xLeft;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.yTop;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

BOOL BEZIER32::bNext(POINTFIX* pptfx)
{
// Return current point:

    pptfx->x = x.fxValue() + rcfxBound.xLeft;
    pptfx->y = y.fxValue() + rcfxBound.yTop;

// If cSteps == 0, that was the end point in the curve!

    if (cSteps == 0)
        return(FALSE);

// Okay, we have to step:

    if (MAX(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
    {
        x.vHalveStepSize();
        y.vHalveStepSize();
        cSteps <<= 1;
    }

    ASSERTGDI(MAX(x.lError(), y.lError()) <= TEST_MAGNITUDE_NORMAL,
              "Please tell AndrewGo he was wrong");

    while (!(cSteps & 1) &&
           x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
           y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
    {
        x.vDoubleStepSize();
        y.vDoubleStepSize();
        cSteps >>= 1;
    }

    cSteps--;
    x.vTakeStep();
    y.vTakeStep();

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////
// BEZIER64
//
// All math is done using 64 bit fixed numbers in a 36.28 format.
//
// All drawing is done in a 31 bit space, then a 31 bit window offset
// is applied.  In the initial transform where we change to the HFD
// basis, e2 and e3 require the most bits precision: e2 = 6(p2 - 2p3 + p4).
// This requires an additional 4 bits precision -- hence we require 36 bits
// for the integer part, and the remaining 28 bits is given to the fraction.
//
// In rendering a Bezier, every 'subdivide' requires an extra 3 bits of
// fractional precision.  In order to be reversible, we can allow no
// error to creep in.  Since a FIX coordinate is 32 bits, and we
// require an additional 4 bits as mentioned above, that leaves us
// 28 bits fractional precision -- meaning we can do a maximum of
// 9 subdivides.  Now, the maximum absolute error of a Bezier curve in 27
// bit integer space is 2^29 - 1.  But 9 subdivides reduces the error by a
// guaranteed factor of 2^18, meaning we can crack down only to an error
// of 2^11 before we overflow, when in fact we want to crack error to less
// than 1.
//
// So what we do is HFD until we hit an error less than 2^11, reverse our
// basis transform to get the four control points of this smaller curve
// (rounding in the process to 32 bits), then invoke another copy of HFD
// on the reduced Bezier curve.  We again have enough precision, but since
// its starting error is less than 2^11, we can reduce error to 2^-7 before
// overflowing!  We'll start a low HFD after every step of the high HFD.
////////////////////////////////////////////////////////////////////////////

// The following is our 2^11 target error encoded as a 36.28 number
// (don't forget the additional 4 bits of fractional precision!) and
// the 6 times error multiplier:

LONGLONG geqErrorHigh = (LONGLONG)(6 * (1L << 15) >> (32 - FRACTION64)) << 32;

// The following is the default 2/3 error encoded as a 36.28 number,
// multiplied by 6, and leaving 4 bits for fraction:

LONGLONG geqErrorLow = (LONGLONG)4 << 32;

LONGLONG* gpeqErrorHigh = &geqErrorHigh;
LONGLONG* gpeqErrorLow  = &geqErrorLow;

INLINE FIX HFDBASIS64::fxValue()
{
// Convert from 36.28 and round:

    LONGLONG eq = e0;
    eq += (1L << (FRACTION64 - 1));
    eq >>= FRACTION64;
    return((FIX) (LONG) eq);
}

INLINE VOID HFDBASIS64::vParentError(LONGLONG* peq)
{
    *peq = MAX(ABS(e3 << 2), ABS((e2 << 3) - (e3 << 2)));
}

INLINE VOID HFDBASIS64::vError(LONGLONG* peq)
{
    *peq = MAX(ABS(e2), ABS(e3));
}


VOID HFDBASIS64::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
    LONGLONG eqTmp;
    LONGLONG eqP2 = (LONGLONG) p2;
    LONGLONG eqP3 = (LONGLONG) p3;

// e0 = p1
// e1 = p4 - p1
// e2 = 6(p2 - 2p3 + p4)
// e3 = 6(p1 - 2p2 + p3)

// Change basis:

    e0 = p1;                                        // e0 = p1
    e1 = p4;
    e2 = eqP2; e2 -= eqP3; e2 -= eqP3; e2 += e1;    // e2 = p2 - 2*p3 + p4
    e3 = e0;   e3 -= eqP2; e3 -= eqP2; e3 += eqP3;  // e3 = p1 - 2*p2 + p3
    e1 -= e0;                                       // e1 = p4 - p1

// Convert to 36.28 format and multiply e2 and e3 by six:

    e0 <<= FRACTION64;
    e1 <<= FRACTION64;
    eqTmp = e2; e2 += eqTmp; e2 += eqTmp; e2 <<= (FRACTION64 + 1);
    eqTmp = e3; e3 += eqTmp; e3 += eqTmp; e3 <<= (FRACTION64 + 1);
}

VOID HFDBASIS64::vUntransform(FIX* afx)
{
// Declare some temps to hold our operations, since we can't modify e0..e3.

    LONGLONG eqP0;
    LONGLONG eqP1;
    LONGLONG eqP2;
    LONGLONG eqP3;

// p0 = e0
// p1 = e0 + (6e1 - e2 - 2e3)/18
// p2 = e0 + (12e1 - 2e2 - e3)/18
// p3 = e0 + e1

    eqP0 = e0;

// NOTE PERF: Convert this to a multiply by 6: [andrewgo]

    eqP2 = e1;
    eqP2 += e1;
    eqP2 += e1;
    eqP1 = eqP2;
    eqP1 += eqP2;           // 6e1
    eqP1 -= e2;             // 6e1 - e2
    eqP2 = eqP1;
    eqP2 += eqP1;           // 12e1 - 2e2
    eqP2 -= e3;             // 12e1 - 2e2 - e3
    eqP1 -= e3;
    eqP1 -= e3;             // 6e1 - e2 - 2e3

// NOTE PERF: May just want to approximate these divides! [andrewgo]
// Or can do a 64 bit divide by 32 bit to get 32 bits right here.

    VDIV(eqP1, 18, 0);
    VDIV(eqP2, 18, 0);
    eqP1 += e0;
    eqP2 += e0;

    eqP3 = e0;
    eqP3 += e1;

// Convert from 36.28 format with rounding:

    eqP0 += (1L << (FRACTION64 - 1)); eqP0 >>= FRACTION64; afx[0] = (LONG) eqP0;
    eqP1 += (1L << (FRACTION64 - 1)); eqP1 >>= FRACTION64; afx[2] = (LONG) eqP1;
    eqP2 += (1L << (FRACTION64 - 1)); eqP2 >>= FRACTION64; afx[4] = (LONG) eqP2;
    eqP3 += (1L << (FRACTION64 - 1)); eqP3 >>= FRACTION64; afx[6] = (LONG) eqP3;
}

VOID HFDBASIS64::vHalveStepSize()
{
// e2 = (e2 + e3) >> 3
// e1 = (e1 - e2) >> 1
// e3 >>= 2

    e2 += e3; e2 >>= 3;
    e1 -= e2; e1 >>= 1;
    e3 >>= 2;
}

VOID HFDBASIS64::vDoubleStepSize()
{
// e1 = 2e1 + e2
// e3 = 4e3;
// e2 = 8e2 - e3

    e1 <<= 1; e1 += e2;
    e3 <<= 2;
    e2 <<= 3; e2 -= e3;
}

VOID HFDBASIS64::vTakeStep()
{
    e0 += e1;
    LONGLONG eqTmp = e2;
    e1 += e2;
    e2 += eqTmp; e2 -= e3;
    e3 = eqTmp;
}

VOID BEZIER64::vInit(
POINTFIX* aptfx,        // Pointer to 4 control points
RECTFX*   prcfxVis,     // Pointer to bound box of visible area (may be NULL)
LONGLONG*    peqError)     // Fractional maximum error (32.32 format)
{
    LONGLONG eqTmp;

    cStepsHigh = 1;
    cStepsLow  = 0;

    xHigh.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    yHigh.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

// Initialize error:

    eqErrorLow = *peqError;

    if (prcfxVis == (RECTFX*) NULL)
        prcfxClip = (RECTFX*) NULL;
    else
    {
        rcfxClip = *prcfxVis;
        prcfxClip = &rcfxClip;
    }

    while (((xHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh) ||
           ((yHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh))
    {
        cStepsHigh <<= 1;
        xHigh.vHalveStepSize();
        yHigh.vHalveStepSize();
    }
}

// Returns TRUE if there is another point after this one:

BOOL BEZIER64::bNext(POINTFIX* pptfx)
{
    POINTFIX aptfx[4];
    RECTFX   rcfxBound;
    LONGLONG    eqTmp;

    if (cStepsLow == 0)
    {
    // Optimization that if the bound box of the control points doesn't
    // intersect with the bound box of the visible area, render entire
    // curve as a single line:

        xHigh.vUntransform(&aptfx[0].x);
        yHigh.vUntransform(&aptfx[0].y);

        xLow.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
        yLow.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);
        cStepsLow = 1;

        if (prcfxClip != (RECTFX*) NULL)
            vBoundBox(aptfx, &rcfxBound);


        if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
        {
            while (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
                   ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
            {
                cStepsLow <<= 1;
                xLow.vHalveStepSize();
                yLow.vHalveStepSize();
            }
        }

    // This 'if' handles the case where the initial error for the Bezier
    // is already less than the target error:

        if (--cStepsHigh != 0)
        {
            xHigh.vTakeStep();
            yHigh.vTakeStep();

            if (((xHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh) ||
                ((yHigh.vError(&eqTmp), eqTmp) > *gpeqErrorHigh))
            {
                cStepsHigh <<= 1;
                xHigh.vHalveStepSize();
                yHigh.vHalveStepSize();
            }

            while (!(cStepsHigh & 1) &&
                   ((xHigh.vParentError(&eqTmp), eqTmp) <= *gpeqErrorHigh) &&
                   ((yHigh.vParentError(&eqTmp), eqTmp) <= *gpeqErrorHigh))
            {
                xHigh.vDoubleStepSize();
                yHigh.vDoubleStepSize();
                cStepsHigh >>= 1;
            }
        }
    }

    xLow.vTakeStep();
    yLow.vTakeStep();

    pptfx->x = xLow.fxValue();
    pptfx->y = yLow.fxValue();

    cStepsLow--;
    if (cStepsLow == 0 && cStepsHigh == 0)
        return(FALSE);

    if (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
        ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
    {
        cStepsLow <<= 1;
        xLow.vHalveStepSize();
        yLow.vHalveStepSize();
    }

    while (!(cStepsLow & 1) &&
           ((xLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow) &&
           ((yLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow))
    {
        xLow.vDoubleStepSize();
        yLow.vDoubleStepSize();
        cStepsLow >>= 1;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* newpathrec (pppr,pcMax,cNeeded)					   *
*									   *
* Create a new pathrecord.						   *
*									   *
* History:								   *
*  Fri 19-Jun-1992 19:24:56 -by- Charles Whitmer [chuckwh]		   *
* Added the quick out if we get enough points.				   *
*									   *
*  5-Dec-1990 -by- Paul Butzi [paulb]					   *
* Wrote it.								   *
\**************************************************************************/

BOOL EPATHOBJ::newpathrec(PATHRECORD **pppr,COUNT *pcMax,COUNT cNeeded)
{
    PATHALLOC *ppa = ppath->ppachain;

    *pcMax = 0;

    if ( ppa != (PPATHALLOC) NULL )
    {
    // we have a current pathalloc, see how much will fit
    // computation done into temps to avoid compiler assertion!

        POINTFIX *start = &(ppa->pprfreestart->aptfx[0]);
        POINTFIX *end = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

        if ( end > start )
        {
            //Sundown safe truncation
            ASSERT4GB((ULONGLONG)(end - start));
            *pcMax = (ULONG)(end - start);
        }
    }

// Now we can decide if we need a new pathalloc

    if ((*pcMax < cNeeded) && (*pcMax < PATHALLOCTHRESHOLD))
    {
    // allocate a new pathalloc, link it into path

        if ( (ppa = newpathalloc()) == (PPATHALLOC) NULL)
            return FALSE;

        ppa->ppanext = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

    // Sundown safe truncation

        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONG numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);

        *pcMax = (numbytes - offsetof(PATHRECORD, aptfx))/sizeof(POINTFIX);
    }

// create new pathrec header

    *pppr = ppa->pprfreestart;

    return(TRUE);
}


/******************************Public*Routine******************************\
* EPATHOBJ::bFlatten()
*
* Cruise over a path, translating all of the beziers into sequences of lines.
*
* History:
*  5-Dec-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bFlatten()
{
// stress failure in RFONTOBJ::bInsertMetricsPlusPath caused by invalid
// ppath. After Beta2, we will pick up the fix from Adobe.

    if (!bValid())
    {
        return (FALSE);
    }

// Run down the path, looking for records that contain beziers.
// Skip over the records containing lines.

    for ( PATHRECORD *ppr = ppath->pprfirst;
          ppr != (PPATHREC) NULL;
          ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_BEZIERS)
        {
            ppr = pprFlattenRec(ppr);
            if (ppr == (PPATHREC) NULL)
                return(FALSE);
        }
    }

    fl &= ~PO_BEZIERS;

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::pprFlattenRec(ppr)
*
* Cruise over a path, translating all of the beziers into sequences of lines.
*
* History:
*  5-Dec-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PPATHREC EPATHOBJ::pprFlattenRec(PATHRECORD *ppr)
{
// Create a new record

    PATHRECORD *pprNew;
    COUNT maxadd;

    if ( newpathrec(&pprNew,&maxadd,MAXLONG) != TRUE )
        return (PPATHREC) NULL;

// Take record of Beziers out of path list, and put a new record
// in its place.  Update 'pprNew->pprnext' when we exit.

    pprNew->pprprev = ppr->pprprev;
    pprNew->count = 0;
    pprNew->flags = (ppr->flags & ~PD_BEZIERS);

    if (pprNew->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprNew;
    else
        pprNew->pprprev->pprnext = pprNew;

    POINTFIX  aptfxControl[4];   // If needed, temp buf for control points
    PPOINTFIX pptfxControl;      // Points to Bezier's 4 control points
    PPOINTFIX pptfxNext;         // Points to 2nd point of next Bezier

// Now, run down the beziers, flattening them into the record
// First, set up for the first bezier in record

    if ((ppr->flags & PD_BEGINSUBPATH) == 0)
    {
    // Because we are not starting a new subpath we don't need to
    // enter the first control point into the record of lines.  Since
    // all 4 control points for the first Bezier aren't contiguous in
    // memory, copy the points to aptfxControl[].

        aptfxControl[0] = ppr->pprprev->aptfx[ppr->pprprev->count - 1];
        pptfxNext = ppr->aptfx;

        for (LONG ii = 1; ii < 4; ii++)
        {

        // If the Bezier's control points are spread across two
        // pathrecords, then handle it.

            if (pptfxNext >= &ppr->aptfx[ppr->count])
            {
                ASSERTGDI(ppr->pprnext != NULL, "Lost the other control points");
                ppr = ppr->pprnext;
                ASSERTGDI((ppr->flags & (PD_BEZIERS | PD_BEGINSUBPATH)) != 0,
                          "Mucked up continuation");
                pptfxNext = ppr->aptfx;
            }
            aptfxControl[ii] = *pptfxNext++;
        }
        pptfxControl = aptfxControl;

        ASSERTGDI(PATHALLOCTHRESHOLD > 3, "Threshold too small.");
        ASSERTGDI(pptfxNext <= &ppr->aptfx[ppr->count], "Threshold too small");
    }
    else
    {
        pptfxNext = ppr->aptfx + 4;
        pptfxControl = ppr->aptfx;
        pprNew->aptfx[pprNew->count++] = ppr->aptfx[0];
    }

// Now run down the list of Beziers, flattening them out.

    while (TRUE)
    {
    // We've removing a curve, so adjust the curve count appropriately:

        cCurves--;

    // Crack Bezier described by points pointed to by pptfxControl:

        BEZIER bez;
        bez.vInit(pptfxControl);

        do
        {
            if ( pprNew->count >= maxadd )
            {
            // Since we're continuing this path record onto another,
            // we have to adjust this record's flags to note that:

                pprNew->flags &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);

            // Filled the record, get a new one.  Insert it after one we
            // just filled and adjust the pathalloc record.

                ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);

                PATHRECORD *pprNewNew;
		if (newpathrec(&pprNewNew,&maxadd,MAXLONG) != TRUE)
                    return((PPATHREC) NULL);

                pprNewNew->pprprev = pprNew;
                pprNew->pprnext = pprNewNew;
                pprNew = pprNewNew;

                pprNew->count = 0;
                pprNew->flags = (ppr->flags &
                              ~(PD_BEZIERS | PD_BEGINSUBPATH | PD_RESETSTYLE));
            }

        // Now that we've generated the next point, stash it into the
        // new path record:

            cCurves++;

        } while (bez.bNext(&pprNew->aptfx[pprNew->count++]));

    // Move on to the next bezier:

    // Sundown safe truncation
        COUNT cptfxRemaining = (COUNT)(&ppr->aptfx[ppr->count] - pptfxNext);

        if (cptfxRemaining <= 0)
            break;

        if (cptfxRemaining >= 3)
        {
            pptfxControl = pptfxNext - 1;
            pptfxNext += 3;
        }
        else
        {

        // Handle case where the Bezier's control points are spread
        // across two pathrecord's.  Copy all the points to
        // aptfxControl[].

            pptfxNext--;
            for (INT ii = 0; ii < 4; ii++)
            {
                if (pptfxNext >= &ppr->aptfx[ppr->count])
                {
                    ASSERTGDI(ppr != NULL, "Lost the other control points.");
                    ppr = ppr->pprnext;
                    ASSERTGDI((ppr->flags &
                              (PD_BEZIERS | PD_BEGINSUBPATH)) != 0,
                              "Mucked up continuation.");
                    pptfxNext = ppr->aptfx;
                }
                aptfxControl[ii] = *pptfxNext++;
            }
            pptfxControl = aptfxControl;
        }
    }

    ASSERTGDI(pptfxNext == &ppr->aptfx[ppr->count], "Lost some points");

// Adjust the pathalloc record:

    ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);

    pprNew->pprnext = ppr->pprnext;
    if (pprNew->pprnext == (PPATHREC) NULL)
        ppath->pprlast = pprNew;
    else
        pprNew->pprnext->pprprev = pprNew;

    return(pprNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\palgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: palgdi.cxx
*
* This module provides the API level interface functions for dealing with
* palettes.
*
* Created: 07-Nov-1990 22:21:11
* Author: Patrick Haluptzok  patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// hForePalette is a global variable that tells which palette is currently
// realized in the foreground.

HPALETTE    hForePalette = 0;
PW32PROCESS hForePID = 0;


#if DBG

ULONG   DbgPal = 0;
#define PAL_DEBUG(l,x)  {if (l <= DbgPal) {DbgPrint("%p ", hpalDC); DbgPrint(x);}}

#else

#define PAL_DEBUG(l,x)

#endif

/******************************Public*Routine******************************\
* GreGetDIBColorTable
*
* Get the color table of the DIB section currently selected into the dc
* identified by the given hdc.  If the surface is not a DIB section,
* this function will fail.
*
* History:
*  07-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

#if ((BMF_1BPP != 1) || (BMF_4BPP != 2) || (BMF_8BPP != 3))
#error GetDIBColorTable BAD FORMAT
#endif

UINT
APIENTRY
GreGetDIBColorTable(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *pRGB
    )
{

    UINT  iRet = 0;
    DCOBJ dco(hdc);

    if (pRGB != (RGBQUAD *)NULL)
    {
        if (dco.bValid())
        {
            //
            // Protect against dynamic mode changes while we go grunging
            // around in the surface.
            //

            DEVLOCKOBJ dlo;
            dlo.vLockNoDrawing(dco);

            //
            // Fail if the selected in surface is not a DIB or the depth is more than
            // 8BPP.
            //

            SURFACE *pSurf = dco.pSurfaceEff();
            ULONG iFormat = pSurf->iFormat();
            if ((pSurf->bDIBSection() || (pSurf->pPal != NULL)) &&
                (iFormat <= BMF_8BPP) && (iFormat >= BMF_1BPP))
            {
                //
                // Lock the surface palette and figure out the max index allowed on the
                // palette.  Win95 does not return un-used entries.
                //

                XEPALOBJ pal(pSurf->ppal());
                ASSERTGDI(pal.bValid(), "GetDIBColorTable: invalid pal\n");

                UINT iMax = (UINT) pal.cEntries();

                if (iStart >= iMax)
                {
                    return(0);
                }

                UINT iLast = iStart + cEntries;

                if (iLast > iMax)
                {
                    iLast = iMax;
                }

                pal.vFill_rgbquads(pRGB, iStart, iRet = iLast - iStart);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* GreSetDIBColorTable
*
* Set the color table of the DIB section currently selected into the dc
* identified by the given hdc.  If the surface is not a DIB section,
* this function will fail.
*
* History:
*  07-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
GreSetDIBColorTable(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *pRGB
    )
{

    UINT  iRet = 0;
    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // Protect against dynamic mode changes while we go grunging
        // around in the surface.
        //

        DEVLOCKOBJ dlo;
        dlo.vLockNoDrawing(dco);

        //
        // Fail if the selected in surface is not a DIB or the depth is more than
        // 8BPP.
        //

        SURFACE *pSurf = dco.pSurfaceEff();
        ULONG iFormat = pSurf->iFormat();
        if (pSurf->bDIBSection() &&
            (iFormat <= BMF_8BPP) && (iFormat >= BMF_1BPP))
        {
            //
            // Mark the brushes dirty.
            //

            dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);

            //
            // Lock the surface palette and figure out the max
            // index allowed on the palette.
            //

            XEPALOBJ pal(pSurf->ppal());
            ASSERTGDI(pal.bValid(), "GetDIBColorTable: invalid pal\n");

            UINT iMax = (UINT) pal.cEntries();
            if (iStart < iMax)
            {
                UINT iLast = iStart + cEntries;
                if (iLast > iMax)
                    iLast = iMax;

                pal.vCopy_rgbquad(pRGB, iStart, iRet = iLast - iStart);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* GreCreatePalette - creates a palette from the logpal information given
*
* API function.
*
* returns HPALETTE for succes, (HPALETTE) 0 for failure
*
* History:
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
GreCreatePalette(
    LPLOGPALETTE pLogPal
    )
{

    return(GreCreatePaletteInternal(pLogPal,pLogPal->palNumEntries));
}

HPALETTE
APIENTRY
GreCreatePaletteInternal(
    LPLOGPALETTE pLogPal,
    UINT cEntries
    )
{
    if ((pLogPal->palVersion != 0x300) || (cEntries == 0))
    {
        WARNING("GreCreatePalette failed, 0 entries or wrong version\n");
        return((HPALETTE) 0);
    }

    //
    // The constructor checks for invalid flags and fails if they are found.
    //

    PALMEMOBJ pal;

    if (!pal.bCreatePalette(PAL_INDEXED,
                            cEntries,
                            (PULONG) pLogPal->palPalEntry,
                            0, 0, 0,
                            (PAL_DC | PAL_FREE)))
    {
        return((HPALETTE) 0);
    }

    ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

    pal.vKeepIt();
    GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);
    return((HPALETTE) pal.hpal());
}

/******************************Public*Routine******************************\
* NtGdiCreatePaletteInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
NtGdiCreatePaletteInternal(
    LPLOGPALETTE pLogPal,
    UINT         cEntries
    )
{
    HPALETTE hpalRet = (HPALETTE)1;

    //
    // verify cEntries
    //

    if (cEntries <= 65536)
    {
        int cj = cEntries * sizeof(PALETTEENTRY) + offsetof(LOGPALETTE,palPalEntry);
        WORD Version;
        PULONG pPaletteEntry;

        __try
        {
            // it is safe to do a byte here.  If we can access dword's on byte boundries
            // this will work.  If not we will hit an exception under a try except.  Winhelp
            // passes in an unaligned palette but only on x86.

            ProbeForRead(pLogPal,cj, sizeof(BYTE));
            Version = pLogPal->palVersion;
            pPaletteEntry = (PULONG) pLogPal->palPalEntry;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            hpalRet = (HPALETTE)0;
        }

        if (hpalRet)
        {
            if ((Version != 0x300) || (cEntries == 0))
            {
                WARNING("GreCreatePalette failed, 0 entries or wrong version\n");
                hpalRet = (HPALETTE)0;
            }

            if (hpalRet)
            {

                //
                // The constructor checks for invalid flags and fails if they are found.
                //

                PALMEMOBJ pal;
                BOOL bStatus;

                //
                // bCreatePalette must use a try-except when accessing pPaletteEntry
                //

                bStatus = pal.bCreatePalette(PAL_INDEXED,
                                             cEntries,
                                             pPaletteEntry,
                                             0,
                                             0,
                                             0,
                                             (PAL_DC | PAL_FREE));

                if (bStatus)
                {
                    ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

                    bStatus = GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);

                    if (bStatus)
                    {
                        pal.vKeepIt();
                        hpalRet = pal.hpal();
                    }
                    else
                    {
                        hpalRet = (HPALETTE)0;
                    }
                }
                else
                {
                    hpalRet = (HPALETTE)0;
                }
            }
        }
    }
    else
    {
        hpalRet = 0;
        WARNING("GreCreatePalette failed,cEntries too large\n");
    }


    return(hpalRet);
}

/******************************Public*Routine******************************\
* GreCreateCompatibleHalftonePalette
*
*   Creates the win95 compatible halftone palette
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/27/1996 Mark Enstrom [marke]
*
\**************************************************************************/

HPALETTE
APIENTRY
GreCreateCompatibleHalftonePalette(
    HDC hdc
    )
{
    HPALETTE  hpalRet;
    PALMEMOBJ pal;
    BOOL      bStatus;

    //
    // bCreatePalette must use a try-except when accessing pPaletteEntry
    //

    bStatus = pal.bCreatePalette(PAL_INDEXED,
                                 256,
                                 (PULONG)&aPalHalftone[0].ul,
                                 0,
                                 0,
                                 0,
                                 (PAL_DC | PAL_FREE | PAL_HT));

    if (bStatus)
    {
        ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

        pal.flPal(PAL_HT);

        bStatus = GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);

        if (bStatus)
        {
            pal.vKeepIt();
            hpalRet = pal.hpal();
        }
        else
        {
            hpalRet = (HPALETTE)0;
        }
    }
    else
    {
        hpalRet = (HPALETTE)0;
    }
    return(hpalRet);
}

/******************************Public*Routine******************************\
* GreCreateHalftonePalette(hdc)
*
* Create a halftone palette for the given DC.
*
* History:
*  31-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
GreCreateHalftonePalette(
    HDC hdc
    )
{
    //
    // Validate and lock down the DC.  NOTE: Even though the surface is accessed
    // in this function, it is only for information purposes.  No reading or
    // writing of the surface occurs.
    //

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return((HPALETTE) 0);
    }

    //
    // Get the PDEV from the DC.
    //

    PDEVOBJ po(dco.hdev());

    //
    // Acquire the devlock to protect against dynamic mode changes while
    // we enable halftoning for the PDEV and we construct the halftone
    // palette from this information.
    //

    DEVLOCKOBJ dlo(po);

    //
    // Create the halftone block if it has not existed yet.
    //

    if ((po.pDevHTInfo() == NULL) &&
        !po.bEnableHalftone((PCOLORADJUSTMENT)NULL))
        return((HPALETTE) 0);

    DEVICEHALFTONEINFO *pDevHTInfo = (DEVICEHALFTONEINFO *)po.pDevHTInfo();

    //
    // Use the entries in the halftone palette in the halftone block to create
    // the palette.
    //

    EPALOBJ palHT((HPALETTE)pDevHTInfo->DeviceOwnData);
    ASSERTGDI(palHT.bValid(), "GreCreateHalftonePalette: invalid HT pal\n");

    PALMEMOBJ pal;
    if (palHT.cEntries())
    {
        if (!pal.bCreatePalette(PAL_INDEXED, palHT.cEntries(),
                                (PULONG)palHT.apalColorGet(), 0, 0, 0,
                                (PAL_DC | PAL_FREE | PAL_HT)))
        {
            return((HPALETTE) 0);
        }
    }
    else
    {
        //
        // 16BPP halftone uses 555 for RGB.  We can't create a zero
        // entry palette at the API level, so lets create a default palette.
        //

        if (!pal.bCreatePalette(PAL_INDEXED, (ULONG)logDefaultPal.palNumEntries,
                                (PULONG)logDefaultPal.palPalEntry, 0, 0, 0,
                                PAL_DC | PAL_FREE | PAL_HT))
        {
            return(FALSE);
        }
    }

    pal.vKeepIt();
    GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);
    return((HPALETTE) pal.hpal());
}

/******************************Public*Routine******************************\
* GreGetNearestPaletteIndex - returns the nearest palette index to crColor
*   in the hpalette.  Can only fail if hpal passed in is busy or bad.
*
* API function.
*
* returns value >= 0 for success, -1 for failure.
*
* History:
*  09-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiGetNearestPaletteIndex(
    HPALETTE hpal,
    COLORREF crColor
    )
{
    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        //
        // If the palette has 0 entries return the color passed in.
        //

        if (pal.cEntries())
        {
            if (crColor & 0x01000000)
            {
                crColor &= 0x0000FFFF;

                if (crColor >= pal.cEntries())
                    crColor = 0;
            }
            else
            {
                crColor &= 0x00FFFFFF;
                crColor = pal.ulGetNearestFromPalentry(*((PPALETTEENTRY) &crColor));
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        crColor = CLR_INVALID;
    }

    return((UINT) crColor);
}

/******************************Public*Routine******************************\
* GreAnimatePalette
*
* API function
*
* Returns: The number of logical palette entries animated, 0 for error.
*
* History:
*  17-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreAnimatePalette(HPALETTE hpal, UINT ulStartIndex,
                    UINT ulNumEntries,  CONST PALETTEENTRY *lpPaletteColors)
{
    BOOL bReturn = FALSE;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        bReturn = (BOOL) pal.ulAnimatePalette(ulStartIndex, ulNumEntries, lpPaletteColors);
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreGetPaletteEntries
*
* API function
*
* returns: 0 for failure, else number of entries retrieved.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetPaletteEntries(HPALETTE hpal, UINT ulStartIndex,
                                 UINT ulNumEntries, LPPALETTEENTRY pRGB)
{
    //
    // Note on this call we can just let the default palette go through
    // since it isn't getting modified, and the constructor is smart
    // enough not to really lock it down.
    //

    EPALOBJ pal((HPALETTE) hpal);

    if (!pal.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    return(pal.ulGetEntries(ulStartIndex, ulNumEntries, pRGB, FALSE));
}

/******************************Public*Routine******************************\
* GreSetPaletteEntries
*
* API function
*
* returns: 0 for failure, else number of entries retrieved.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT
GreSetPaletteEntries(
    HPALETTE hpal,
    UINT     ulStartIndex,
    UINT     ulNumEntries,
    CONST PALETTEENTRY *pRGB
    )
{
    //
    // Note on this call we don't worry about STOCKOBJ_PAL because ulSetEntries
    // won't let the default palette get modified.
    //

    UINT uiReturn = 0;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        //
        // You must grab the palette semaphore to touch the linked list of DC's.
        //

        SEMOBJ  semo(ghsemPalette);

        uiReturn = (UINT) pal.ulSetEntries(ulStartIndex, ulNumEntries, pRGB);

        //
        // Run down all the DC's for this palette.
        // Set the flags to dirty the brushes, since we changed the palette!
        //

        {
            MLOCKFAST mlo;

            HDC hdcNext = pal.hdcHead();
            while ( hdcNext != (HDC)0 )
            {
                MDCOBJA dco(hdcNext);

                //
                // WINBUG #55203 2-1-2000 bhouse Remove temporary fix to avoid AV when setting DIRTY_BRUSHES
                // This is just a temp fix (since '95 hehehe) to keep
                // this from doing an AV. Lingyun, making the
                // brush flags all be in kernel memory will
                // fix this.
                //
                // this should just be
                // dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                //

                if (GreGetObjectOwner((HOBJ)hdcNext,DC_TYPE) ==  W32GetCurrentPID())
                {
                    dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                }
                else
                {
                    dco.pdc->flbrushAdd(DIRTY_FILL);
                }

                hdcNext = dco.pdc->hdcNext();
            }
        }
    }

    return(uiReturn);
}

/******************************Public*Routine******************************\
* GreGetNearestColor
*
* This function returns the color that will be displayed on the device
* if a solid brush was created with the given colorref.
*
* History:
*  Mon 29-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Don't round the color on non-indexed devices
*
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

COLORREF APIENTRY GreGetNearestColor(HDC hdc, COLORREF crColor)
{
    ULONG ulRet;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {

        //
        // Protect against dynamic mode changes while we go grunging
        // around in the surface.
        //

        DEVLOCKOBJ dlo;
        dlo.vLockNoDrawing(dco);

        XEPALOBJ palDC(dco.ppal());

        XEPALOBJ palSurf;

        SURFACE *pSurf = dco.pSurfaceEff();

        if ((dco.dctp() == DCTYPE_INFO) || (dco.dctp() == DCTYPE_DIRECT))
        {
            PDEVOBJ po(dco.hdev());
            ASSERTGDI(po.bValid(), "ERROR GreGetNearestColor invalid PDEV\n");

            palSurf.ppalSet(po.ppalSurf());
            ASSERTGDI(palSurf.bValid(), "ERROR GreGetNearestColor invalid palDefault");
        }
        else
        {
            ASSERTGDI(dco.dctp() == DCTYPE_MEMORY, "Not a memory DC type");
            palSurf.ppalSet(pSurf->ppal());
        }

        //
        // if ICM translate the color to CMYK, just return the passed CMYK color.
        //
        if (dco.pdc->bIsCMYKColor())
        {
            ulRet = crColor;
        }
        else
        {
            if (((crColor & 0x01000000) == 0) &&
                (palSurf.bValid() && !(palSurf.bIsIndexed())))
            {
                //
                // Well if it isn't index it's RGB,BGR, or Bitfields.
                // In any case to support Win3.1 we need to return exactly
                // what was passed in otherwise they think we are a monochrome
                // device.  Bitfields could result is some messy rounding so
                // it's more exact to just return the RGB passed in.
                //

                ulRet = crColor & 0x00FFFFFF;  // mask off the highest byte
            }
            else
            {
                ulRet = ulIndexToRGB(palSurf, palDC, ulGetNearestIndexFromColorref(palSurf, palDC, crColor));
            }
        }
    }
    else
    {
        ulRet = CLR_INVALID;
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreGetSystemPaletteEntries
*
* API Function - copies out the range of palette entries from the DC's
*                surface's palette.
*
* returns: number of entries retrieved from the surface palette, 0 for FAIL
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetSystemPaletteEntries(HDC hdc, UINT ulStartIndex,
                            UINT ulNumEntries, PPALETTEENTRY pRGB)
{
    UINT uiReturn = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Acquire the devlock while grunging in the surface palette to
        // protect against dynamic mode changes.
        //

        DEVLOCKOBJ dlo(po);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());
            uiReturn = (UINT) palSurf.ulGetEntries(ulStartIndex, ulNumEntries,
                                                   pRGB, TRUE);
        }
    }

    return(uiReturn);
}

/******************************Public*Routine******************************\
* GreGetSystemPaletteUse
*
* API function
*
* returns: SYSPAL_STATIC or SYSPAL_NOSTATIC, 0 for an error
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetSystemPaletteUse(HDC hdc)
{
    ULONG ulReturn = SYSPAL_ERROR;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Acquire the devlock while grunging in the surface palette to
        // protect against dynamic mode changes.
        //

        DEVLOCKOBJ dlo(po);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());

            if (palSurf.bIsNoStatic())
            {
                ulReturn = SYSPAL_NOSTATIC;
            }
            else if (palSurf.bIsNoStatic256())
            {
                ulReturn = SYSPAL_NOSTATIC256;
            }
            else
            {
                ulReturn = SYSPAL_STATIC;
            }
        }
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* GreSetSystemPaletteUse
*
* API function - Sets the number of reserved entries if palette managed
*
* returns - the old flag for the palette, 0 for error
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreSetSystemPaletteUse(HDC hdc, UINT ulUsage)
{
    //
    // Validate the parameters, Win3.1 sets the flag to static if it's invalid.
    //

    if ((ulUsage != SYSPAL_STATIC) && (ulUsage != SYSPAL_NOSTATIC) &&
        (ulUsage != SYSPAL_NOSTATIC256))
        ulUsage = SYSPAL_STATIC;

    //
    // Initialize return value.
    //

    ULONG ulReturn = SYSPAL_ERROR;
    BOOL bPalChanged = FALSE;
    ULONG i;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        //
        // Lock the screen semaphore so that we don't get flipped into
        // full screen after checking the bit.  This also protects us
        // from dynamic mode changes that change the 'bIsPalManaged'
        // status.
        //

        PDEVOBJ po(dco.hdev());

        DEVLOCKOBJ dlo(po);

        XEPALOBJ palSurf(po.ppalSurf());
        XEPALOBJ palDC(dco.ppal());

        if (po.bIsPalManaged())
        {
            //
            // The palette managed case.
            //

            {
                //
                // Protect access to the goodies in the system palette
                // with the SEMOBJ.  We don't want a realize happening
                // while we fiddle flags.
                //

                SEMOBJ  semo(ghsemPalette);

                if (palSurf.bIsNoStatic())
                {
                    ulReturn = SYSPAL_NOSTATIC;
                }
                else if (palSurf.bIsNoStatic256())
                {
                    ulReturn = SYSPAL_NOSTATIC256;
                }
                else
                {
                    ulReturn = SYSPAL_STATIC;
                }


                if (ulUsage == SYSPAL_STATIC)
                {
                    //
                    // reset the colors from their original copy in the devinfo palette.
                    // The copy already has the flags properly set.
                    //

                    if (palSurf.bIsNoStatic() || palSurf.bIsNoStatic256())
                    {
                        //
                        // Change the palette that GDI manages, copy over up to
                        // 20 static colors from ppalDefault
                        //

                        XEPALOBJ palOriginal(ppalDefault);
                        ASSERTGDI(palOriginal.bValid(), "ERROR ulMakeStatic0");

                        ULONG ulNumReserved = palSurf.ulNumReserved() >> 1;

                        if (ulNumReserved > 10)
                        {
                            ulNumReserved = 10;
                        }

                        //
                        // set the beginning entries
                        //

                        for (i = 0; i < ulNumReserved; i++)
                        {
                            PALETTEENTRY palEntry = palOriginal.palentryGet(i);

                            palEntry.peFlags = PC_USED | PC_FOREGROUND;
                            palSurf.palentrySet(i,palEntry);
                        }

                        //
                        // set the ending entries
                        //

                        ULONG ulCurrentPal = palSurf.cEntries();
                        ULONG ulCurrentDef = 20;

                        for (i = 0; i < ulNumReserved; i++)
                        {
                            PALETTEENTRY palEntry;

                            ulCurrentPal--;
                            ulCurrentDef--;

                            palEntry = palOriginal.palentryGet(ulCurrentDef);
                            palEntry.peFlags = PC_USED | PC_FOREGROUND;
                            palSurf.palentrySet(ulCurrentPal,palEntry);
                        }

                        //
                        // Mark the brushes dirty for this DC.
                        //

                        dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);


                        palSurf.flPalSet(palSurf.flPal() & ~PAL_NOSTATIC & ~PAL_NOSTATIC256);
                        palSurf.vUpdateTime();
                        bPalChanged = TRUE;
                    }
                }
                else if (ulUsage == SYSPAL_NOSTATIC)
                {
                    //
                    // unmark all the static colors, with the exception of black and
                    // white that stay with us.
                    //

                    for (i = 1; i < (palSurf.cEntries()-1); i++)
                    {
                        palSurf.apalColorGet()[i].pal.peFlags = 0;
                    }

                    palSurf.vSetNoStatic();
                }
                else //SYSPAL_NOSTATIC256
                {
                    //
                    // unmark all the static colors
                    //
                    for (i = 0; i < (palSurf.cEntries()); i++)
                    {
                        palSurf.apalColorGet()[i].pal.peFlags = 0;
                    }

                    palSurf.vSetNoStatic256();

                }

            }

            if (bPalChanged)
            {
                SEMOBJ so(po.hsemPointer());

                if (!po.bDisabled())
                {
                    po.pfnSetPalette()(
                        po.dhpdevParent(),
                        (PALOBJ *) &palSurf,
                        0,
                        0,
                        palSurf.cEntries());
                }
            }
        }
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* NtGdiResizePalette()
*
* API function
*
* returns: TRUE for success, FALSE for failure
*
* History:
*  Tue 10-Sep-1991 -by- Patrick Haluptzok [patrickh]
* rewrite to be multi-threaded safe
*
*  19-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define PAL_MAX_SIZE 1024

BOOL
APIENTRY
NtGdiResizePalette(
    HPALETTE hpal,
    UINT     cEntry
    )
{
    //
    // Check for quick out before constructors
    //

    if ((cEntry > PAL_MAX_SIZE) || (cEntry == 0))
    {
        WARNING("GreResizePalette failed - invalid size\n");
        return(FALSE);
    }

    BOOL bReturn = FALSE;

    //
    // Validate the parameter.
    //

    EPALOBJ palOld(hpal);

    if ((palOld.bValid()) && (!palOld.bIsPalDefault()) && (palOld.bIsPalDC()))
    {
        //
        // Create a new palette. Don't mark it to keep because after
        // bSwap it will be palOld and we want it to be deleted.
        //

        PALMEMOBJ pal;

        if (pal.bCreatePalette(PAL_INDEXED,
                                cEntry,
                                (PULONG) NULL,
                                0, 0, 0,
                                PAL_DC | PAL_FREE))
        {

            //
            // Grab the palette semaphore which stops any palettes from being selected
            // in or out.  It protects the linked DC list, can't copy DC head until
            // we hold it.
            //

            SEMOBJ  semo(ghsemPalette);

            //
            // Copy the data from old palette.
            //

            pal.vCopyEntriesFrom(palOld);
            pal.flPalSet(palOld.flPal());
            pal.hdcHead(palOld.hdcHead());
            pal.hdev(palOld.hdev());
            pal.cRefhpal(palOld.cRefhpal());
            pal.vComputeCallTables();

            HDC hdcNext, hdcTemp;

            MLOCKFAST mlo;

            //
            // Run down the list and exclusive lock all the handles.
            //

            {
                hdcNext = pal.hdcHead();

                while (hdcNext != (HDC) 0)
                {
                    MDCOBJ dcoLock(hdcNext);

                    if (!dcoLock.bLocked())
                    {
                        WARNING1("ResizePalette failed because a DC the hpal is in is busy\n");
                        break;
                    }

                    hdcNext = dcoLock.pdc->hdcNext();
                    dcoLock.vDontUnlockDC();
                }
            }

            if (hdcNext == (HDC) 0)
            {
                //
                // We have the palette semaphore and all the DC's exclusively locked.  Noone else
                // can be accessing the translates because you must hold one of those things to
                // access them.  So we can delete the translates.
                //

                palOld.vMakeNoXlate();
                palOld.vUpdateTime();

                //
                // Note that bSwap calls locked SpapHandle vesrion so the Hmgr Resource
                // is required (luckily it was grabbed earlier).
                //

                //
                // try to swap palettes, bSwap can only succedd if
                // this routine owns the only locks on the objecs
                //

                bReturn = pal.bSwap((PPALETTE *) &palOld,1,1);

                if (bReturn)
                {
                    ASSERTGDI(bReturn, "ERROR no way");

                    //
                    // Run down all the DC's for this palette and update the pointer.
                    // Set the flags to dirty the brushes since we changed the palette.
                    //

                    {
                        hdcNext = pal.hdcHead();

                        while (hdcNext != (HDC)0)
                        {
                            MDCOBJA dcoAltLock(hdcNext);
                            dcoAltLock.pdc->ppal(palOld.ppalGet());
                            dcoAltLock.ulDirty(dcoAltLock.ulDirty() | DIRTY_BRUSHES);
                            hdcNext = dcoAltLock.pdc->hdcNext();
                        }
                    }
                }
                else
                {
                    WARNING1("ResizePalette failed - ref count != 1\n");
                }

            }
            else
            {
                WARNING1("ResizePalette failed lock of DC in chain\n");
            }

            //
            // Unlock all the DC we have locked and return FALSE
            //

            {
                hdcTemp = pal.hdcHead();

                while (hdcTemp != hdcNext)
                {
                    MDCOBJ dcoUnlock(hdcTemp);
                    ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                    DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                    hdcTemp = dcoUnlock.pdc->hdcNext();
                }
            }
        }
        else
        {
            WARNING("GreResizePalette failed palette creation\n");
        }
    }
    else
    {
        WARNING("GreResizePalette failed invalid hpal\n");
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreUpdateColors
*
* API function - Updates the colors in the Visible Region for a Window on
* a palette mangaged device.
*
* This is an example of how UpdateColors is used:
*
*   case WM_PALETTECHANGED:
*
*       // if NTPAL was not responsible for palette change and if
*       // palette realization causes a palette change, do a redraw.
*
*       if ((HWND)wParam != hWnd)
*       {
*           if (bLegitDraw)
*           {
*               hDC = GetDC(hWnd);
*               hOldPal = SelectPalette(hDC, hpalCurrent, 0);
*
*               i = RealizePalette(hDC);
*
*               if (i)
*               {
*                   if (bUpdateColors)
*                   {
*                       UpdateColors(hDC);
*                       UpdateCount++;
*                   }
*                   else
*                       InvalidateRect(hWnd, (LPRECT) (NULL), 1);
*               }
*
*               SelectPalette(hDC, hOldPal, 0);
*               ReleaseDC(hWnd, hDC);
*           }
*       }
*       break;
*
* The hpal can only be selected into 1 type of device DC at a time.
* Xlates from the DC palette to the surface palette are only done on DC's
* that are for the PDEV surface.  Since an hpal can only be selected into
* one of these and creation and deletion of the pxlate needs to be semaphored
* we use the PDEV semaphore to protect it's access.
*
* An xlate vector mapping the DC palette to the surface palette is created
* during a RealizePalette if the surface is a palette managed device.  This
* is put in pxlate in the hpal.  The old pxlate is moved into pxlateOld
* and the xlate in pxlateOld is deleted.  UpdateColors works by looking at
* the difference between the current xlate mapping and the old xlate mapping
* and updating the pixels in the VisRgn to get a closest mapping.
*
* This API can only be called once for a palette.  The old xlate is deleted
* during UpdateColors so that the next time it is called it will fail.  This
* is because it only makes sense to update the pixels once.  Doing it more
* than once would give ugly unpredictable results.
*
* History:
*  12-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiUpdateColors(HDC hdc)
{
    BOOL bReturn = FALSE;

    DCOBJ   dco(hdc);

    if (!dco.bValidSurf())
    {
        return(FALSE);
    }

    PDEVOBJ pdo(dco.hdev());

    //
    // Grab DEVLOCK for output and to lock the surface
    //

    DEVLOCKOBJ dlo(dco);

    if (pdo.bIsPalManaged())
    {
        SURFACE *pSurf = dco.pSurface();

        //
        // This only works on palette managed surfaces.
        //

        if (pSurf == pdo.pSurface())
        {
            XEPALOBJ palSurf(pSurf->ppal());
            XEPALOBJ palDC(dco.ppal());

            //
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.
            //

            if (dco.fjAccum())
                dco.vAccumulate(dco.erclWindow());

            if (dlo.bValid())
            {
                if ((palDC.ptransCurrent() != NULL) &&
                    (palDC.ptransOld() != NULL))
                {
                    XLATEMEMOBJ xlo(palSurf, palDC);

                    if (xlo.bValid())
                    {
                        ECLIPOBJ co(dco.prgnEffRao(), dco.erclWindow());

                        //
                        // Check the destination which is reduced by clipping.
                        //

                        if (!co.erclExclude().bEmpty())
                        {
                            //
                            // Exclude the pointer.
                            //

                            DEVEXCLUDEOBJ dxo(dco,&co.erclExclude(),&co);

                            //
                            // Inc the target surface uniqueness
                            //

                            INC_SURF_UNIQ(pSurf);

                            if (!pdo.bMetaDriver())
                            {
                                //
                                // Dispatch the call.  Give it no mask.
                                //

                                bReturn = (*PPFNGET(pdo, CopyBits, pSurf->flags())) (
                                        pSurf->pSurfobj(),
                                        pSurf->pSurfobj(),
                                        &co,
                                        xlo.pxlo(),
                                        (RECTL *) &co.erclExclude(),
                                        (POINTL *) &co.erclExclude());
                            }
                            else
                            {
                                //
                                // Dispatch to DDML.
                                //

                                bReturn = MulUpdateColors(
                                        pSurf->pSurfobj(),
                                        &co,
                                        xlo.pxlo());
                            }
                        }
                        else
                            bReturn = TRUE;
                    }
                }
                else
                    bReturn = TRUE;  // Nothing to update
            }
            else
            {
                bReturn = dco.bFullScreen();
            }
        }
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* RealizeDefaultPalette
*
* Take away colors that have been realized by other Windows.  Reset it to
* state where no colors have been taken.  Return number of colors
*
* History:
*  07-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
ULONG GreRealizeDefaultPalette(
    HDC  hdcScreen,
    BOOL bClearDefaultPalette)
{

    DCOBJ dco(hdcScreen);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Block out the GreRealizePalette code.  Also protect us from
        // dynamic mode changes while we grunge in the surface palette.
        //
        DEVLOCKOBJ dlo(po);

        SEMOBJ  semo(ghsemPalette);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());
            ASSERTGDI(palSurf.bIsPalManaged(), "GreRealizeDefaultPalette");

            //
            // Now map back to static colors if necesary.  Win3.1 does not do this but we do
            // just in case naughty app died and left the palette hosed.
            //
            //
            if (palSurf.bIsNoStatic() || palSurf.bIsNoStatic256())
            {
                GreSetSystemPaletteUse(hdcScreen, SYSPAL_STATIC);
            }

            //
            // Get rid of the PC_FOREGROUND flag from the non-reserved entries.
            //

            ULONG ulTemp = palSurf.ulNumReserved() >> 1;
            ULONG ulMax = palSurf.cEntries() - ulTemp;

            for (; ulTemp < ulMax; ulTemp++)
            {
                palSurf.apalColorGet()[ulTemp].pal.peFlags &= (~PC_FOREGROUND);
            }

            if (bClearDefaultPalette)
            {
                hForePalette = NULL;
            }

            palSurf.vUpdateTime();

            //
            // Mark the brushes dirty.
            //

            dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
        }
    }
    else
    {
        WARNING("ERROR User called RealizeDefaultPalette with bad hdc\n");
    }

    //
    // What should this return value be ?
    //

    return(0);
}


/******************************Public*Routine******************************\
* UnrealizeObject
*
* Resets a logical palette.
*
* History:
*  16-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreUnrealizeObject(HANDLE hpal)
{
    BOOL bReturn = FALSE;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {

        //
        // You must grab the palette semaphore to access the translates.
        //

        SEMOBJ  semo(ghsemPalette);

        if (pal.ptransFore() != NULL)
        {
            pal.ptransFore()->iUniq = 0;
        }

        if (pal.ptransCurrent() != NULL)
        {
            pal.ptransCurrent()->iUniq = 0;
        }

        bReturn = TRUE;
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* GreRealizePalette
*
* Re-written to be Win3.1 compatible.
*
* History:
*  22-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" DWORD GreRealizePalette(HDC hdc)
{
    ULONG nTransChanged = 0;
    ULONG nPhysChanged = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Lock the screen semaphore so that we don't get flipped into
        // full screen after checking the bit.  This also protects us
        // from dynamic mode changes that change the 'bIsPalManaged'
        // status.
        //

        DEVLOCKOBJ dlo(po);

        XEPALOBJ palSurf(po.ppalSurf());
        XEPALOBJ palDC(dco.ppal());

        HPALETTE hpalDC = palDC.hpal();
        HDC hdcNext, hdcTemp;

        if (po.bIsPalManaged())
        {
            ASSERTGDI(palSurf.bIsPalManaged(), "GreRealizePalette");

            //
            // Access to the ptrans and the fields of the hpal are protected by
            // this semaphore.
            //

            SEMOBJ  semo(ghsemPalette);

            if ((SAMEHANDLE(hpalDC,hForePalette)) ||
                ((dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                 (SAMEINDEX(hpalDC, hForePalette)) &&
                 (hForePID == W32GetCurrentProcess())))
            {
                //
                // Check for early out.
                //

                if (palDC.bIsPalDefault())
                {
                    //
                    // Do nothing.
                    //

                    PAL_DEBUG(2,"DC has default palette quick out\n");

                }
                else
                {
                    if ((palDC.ptransFore() != NULL) &&
                        (palDC.ptransFore() == palDC.ptransCurrent()) &&
                        (palDC.ptransFore()->iUniq == palSurf.ulTime()))
                    {
                        //
                        // Everything is valid.
                        //

                        PAL_DEBUG(2,"ptransCurrent == ptransFore quick out\n");
                    }
                    else
                    {
                        MLOCKFAST mlo;

                        //
                        // Run down the list and exclusive lock all the handles.
                        //

                        {
                            hdcNext = palDC.hdcHead();

                            while (hdcNext != (HDC) 0)
                            {
                                MDCOBJ dcoLock(hdcNext);

                                if (!dcoLock.bLocked())
                                {
                                    WARNING1("GreRealizePalette failed because a DC the hpal is in is busy\n");
                                    break;
                                }

                                dcoLock.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                                hdcNext = dcoLock.pdc->hdcNext();
                                dcoLock.vDontUnlockDC();
                            }
                        }

                        if (hdcNext == (HDC) 0)
                        {
                            //
                            // Get rid of the old mapping, it is useless now.
                            //

                            if (palDC.ptransOld())
                            {
                                if (palDC.ptransOld() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransOld());

                                palDC.ptransOld(NULL);
                            }

                            //
                            // Check if we have stale translates.
                            // UnrealizeObject and SetPaletteEntries can cause it.
                            //

                            if ((palDC.ptransFore()) && (palDC.ptransFore()->iUniq == 0))
                            {
                                if (palDC.ptransCurrent() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransFore());

                                palDC.ptransFore(NULL);
                            }

                            //
                            // Check if we need a new foreground realization.
                            //

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                // Need to force ourselves in for the first time.
                                //

                                PAL_DEBUG(2,"Creating a foreground realization\n");

                                palDC.ptransFore(ptransMatchAPal(dco.pdc,palSurf, palDC, TRUE, &nPhysChanged, &nTransChanged));

                                if (palDC.ptransFore() == NULL)
                                {
                                    WARNING("RealizePalette failed initial foreground realize\n");
                                }
                            }
                            else
                            {
                                //
                                // Foreground Realize already done and isn't stale.
                                // Force the foreground mapping into the physical palette.
                                //

                                PAL_DEBUG(2,"Forcing a foreground realization in to palette\n");


                                vMatchAPal(dco.pdc,palSurf, palDC, &nPhysChanged, &nTransChanged);
                            }

                            palDC.ptransOld(palDC.ptransCurrent());
                            palDC.ptransCurrent(palDC.ptransFore());
                        }
                        else
                        {
                            WARNING("GreRealizePalette failed to lock down all DC's in linked list\n");
                        }

                        //
                        // Unlock all the DC we have locked.
                        //

                        {
                            hdcTemp = palDC.hdcHead();

                            while (hdcTemp != hdcNext)
                            {
                                MDCOBJ dcoUnlock(hdcTemp);
                                ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                                DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                                hdcTemp = dcoUnlock.pdc->hdcNext();
                            }
                        }
                    }

                }
            }
            else
            {
                //
                // We are a background palette.
                //

                if (!palDC.bIsPalDefault())
                {

                    //
                    // Check for the quick out.
                    //

                    if ((palDC.ptransCurrent() != NULL) &&
                        (palDC.ptransCurrent()->iUniq == palSurf.ulTime()))
                    {
                        //
                        // Well it's good enough.  Nothing has changed that
                        // would give us any better mapping.
                        //

                        PAL_DEBUG(2,"ptransCurrent not foreground but good enough\n");
                    }
                    else
                    {
                        MLOCKFAST mlo;

                        //
                        // Run down the list and exclusive lock all the handles.
                        //

                        {
                            hdcNext = palDC.hdcHead();

                            while (hdcNext != (HDC) 0)
                            {
                                MDCOBJ dcoLock(hdcNext);

                                if (!dcoLock.bLocked())
                                {
                                    WARNING1("GreRealizePalette failed because a DC the hpal is in is busy\n");
                                    break;
                                }

                                dcoLock.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                                hdcNext = dcoLock.pdc->hdcNext();
                                dcoLock.vDontUnlockDC();
                            }
                        }

                        if (hdcNext == (HDC) 0)
                        {
                            //
                            // We have work to do, get rid of the old translate.
                            //

                            if (palDC.ptransOld())
                            {
                                if (palDC.ptransOld() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransOld());

                                palDC.ptransOld(NULL);
                            }

                            //
                            // Check if we have stale translates.
                            // UnrealizeObject and SetPaletteEntries can cause it.
                            //

                            if ((palDC.ptransFore()) && (palDC.ptransFore()->iUniq == 0))
                            {
                                if (palDC.ptransCurrent() != palDC.ptransFore())
                                {
                                        VFREEMEM(palDC.ptransFore());
                                }

                                palDC.ptransFore(NULL);
                            }

                            //
                            // Check for initial foreground realization.
                            //

                            PAL_DEBUG(2,"Realizing in the background\n");

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                //  Create a scratch pad to establish a foreground realize.
                                //

                                PAL_DEBUG(2,"Making ptransFore in the background\n");

                                PALMEMOBJ palTemp;

                                if (palTemp.bCreatePalette(PAL_INDEXED,
                                                           palSurf.cEntries(),
                                                           NULL,
                                                           0, 0, 0, PAL_MANAGED))
                                {
                                    ULONG ulTemp = 0;
                                    ASSERTGDI(palTemp.cEntries() == 256, "ERROR palTemp invalid");

                                    palTemp.vCopyEntriesFrom(palSurf);
                                    palTemp.ulNumReserved(palSurf.ulNumReserved());
                                    palTemp.flPalSet(palSurf.flPal());
                                    palTemp.vComputeCallTables();

                                    PAL_DEBUG(2,"Need to make a foreground realize first\n");

                                    //
                                    // Need to map ourselves for the first time.  This actually doesn't
                                    // change the current surface palette but instead computes the
                                    // translate vector that would result if it was to be mapped in now.
                                    //

                                    palDC.ptransFore(ptransMatchAPal(dco.pdc,palTemp, palDC, TRUE, &ulTemp, &ulTemp));
                                }

                                #if DBG
                                if (palDC.ptransFore() == NULL)
                                {
                                    WARNING("RealizePalette failed initial foreground realize\n");
                                }
                                #endif
                            }

                            //
                            // Save the Current mapping into Old.
                            //

                            palDC.ptransOld(palDC.ptransCurrent());

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                // The Current can't be set if the Fore
                                // is NULL so we're done.
                                //

                                palDC.ptransCurrent(NULL);
                            }
                            else
                            {
                                //
                                // Get the new Current mapping.
                                //

                                PAL_DEBUG(2,"Making ptransCurrent\n");

                                palDC.ptransCurrent(ptransMatchAPal(dco.pdc,palSurf, palDC, FALSE, &nPhysChanged, &nTransChanged));

                                if (palDC.ptransCurrent() == NULL)
                                {
                                    //
                                    // Well we can't have the foreground set
                                    // and the current being NULL so just
                                    // make it foreground for this memory
                                    // failure case.
                                    //

                                    palDC.ptransCurrent(palDC.ptransFore());
                                    WARNING("ptransCurrent failed allocation in RealizePalette");
                                }
                            }
                        }

                        //
                        // Unlock all the DC we have locked.
                        //

                        {
                            hdcTemp = palDC.hdcHead();

                            while (hdcTemp != hdcNext)
                            {
                                MDCOBJ dcoUnlock(hdcTemp);
                                ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                                DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                                hdcTemp = dcoUnlock.pdc->hdcNext();
                            }
                        }
                    }
                }
            }
        }

        //
        // Check if the device needs to be notified.
        //

        if (nPhysChanged)
        {
            //
            // Lock the screen semaphore so that we don't get flipped into
            // full screen after checking the bit.
            //

            GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

            {
                SEMOBJ so(po.hsemPointer());

                if (!po.bDisabled())
                {
                    po.pfnSetPalette()(
                        po.dhpdevParent(),
                        (PALOBJ *) &palSurf,
                        0,
                        0,
                        palSurf.cEntries());
                }
            }

            GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(po.hsemDevLock());

            //
            // mark palsurf if it is a halftone palette
            //

            if (palSurf.cEntries() == 256)
            {
                ULONG ulIndex;
                for (ulIndex=0;ulIndex<256;ulIndex++)
                {
                    if (
                         (palSurf.ulEntryGet(ulIndex) & 0xffffff) !=
                         (aPalHalftone[ulIndex].ul & 0xffffff)
                       )
                    {
                        break;
                    }
                }

                if (ulIndex == 256)
                {
                    palSurf.flPal(PAL_HT);
                }
                else
                {
                    FLONG fl = palSurf.flPal();
                    fl &= ~PAL_HT;
                    palSurf.flPalSet(fl);
                }
            }
        }
    }

    return(nTransChanged | (nPhysChanged << 16));
}


/******************************Public*Routine******************************\
* IsDCCurrentPalette
*
* Returns TRUE if the palette is the foreground palette.
*
* History:
*  18-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL IsDCCurrentPalette(HDC hdc)
{
    BOOL bReturn = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        if ((SAMEHANDLE(dco.hpal(), (HPAL)hForePalette)) ||
            ((dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
             (SAMEINDEX(dco.hpal(), hForePalette)) &&
             (hForePID == W32GetCurrentProcess())))
        {
            bReturn = TRUE;
        }
    }

    return(bReturn);
}



/******************************Public*Routine******************************\
* GreSelectPalette
*
* API function for selecting palette into the DC.
*
* Returns previous hpal if successful, (HPALETTE) 0 for failure.
*
* History:
*  17-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
HPALETTE GreSelectPalette(
    HDC      hdc,
    HPALETTE hpalNew,
    BOOL     bForceBackground)
{

    //
    // The palette semaphore serializes access to the reference count and
    // the linked list of DC's a palette is selected into.  We don't want
    // 2 people trying to select at the same time.  We must hold this between
    // the setting of the hsem and the incrementing of the reference count.
    //

    SEMOBJ  semo(ghsemPalette);

    //
    // Validate and lock down the DC and new palette.
    //

    DCOBJ dco(hdc);
    EPALOBJ palNew(hpalNew);

    #if DBG
        if (DbgPal >= 2)
        {
            DbgPrint("GreSelectPalette %p\n",palNew.ppalGet());
        }
    #endif

    if ((!dco.bLocked()) ||
        (!palNew.bValid())|| (!palNew.bIsPalDC()))
    {
        //
        // Error code logged by failed lock.
        //

        WARNING1("GreSelectPalette failed, invalid palette or DC\n");
        return((HPALETTE)NULL);
    }

    if (!bForceBackground)
    {
        hForePID = W32GetCurrentProcess();
        hForePalette = hpalNew;
    }

    HPAL hpalOld = (HPAL) dco.hpal();

    if (SAMEHANDLE(hpalOld,(HPAL)hpalNew))
    {
        return((HPALETTE)hpalOld);
    }

    PDEVOBJ po(dco.hdev());
    XEPALOBJ palOld(dco.ppal());

    //
    // Check that we aren't trying to select the palette into a
    // device incompatible with a type we are already selected into.
    // We need to be able to translate from the DC hpal to the surface hpal
    // to do Animate, ect. So we can only be selected into one
    // surface with a PAL_MANAGED hpal because we only maintain one
    // translate table in the DC hpal.
    //

    if (!palNew.bIsPalDefault())
    {
        if (!palNew.bSet_hdev(dco.hdev()))
        {
            WARNING("GreSelectPalette failed hsemDisplay check\n");
            return((HPALETTE)NULL);
        }
    }

    //
    // Grab the multi-lock semaphore to run the DC link list.
    //

    MLOCKFAST mlo;

    //
    // Take care of the old hpal.  Remove from linked list.  Decrement cRef.
    // Remove the hdc from the linked list of DC's associated with palette.
    //

    palOld.vRemoveFromList(dco);

    //
    // Set the new palette in so the old hpal is truly gone.
    //

    dco.pdc->hpal((HPAL)hpalNew);
    dco.pdc->ppal(palNew.ppalGet());
    dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);

    //
    // Associate the palette with the bitmap for use when converting DDBs
    // to DIBs for dynamic mode changes.  We don't associate the default
    // palette because the normal usage pattern is:
    //
    //     hpalOld = SelectPalette(hdc, hpal);
    //     RealizePalette(hdc);
    //     BitBlt(hdc);
    //     SelectPalette(hdc, hpalOld);
    //

    if ((dco.bHasSurface()) && (!palNew.bIsPalDefault()))
    {
        dco.pSurface()->hpalHint(hpalNew);
    }

    //
    // Take care of the new hpal.
    //

    palNew.vAddToList(dco);

    return((HPALETTE)hpalOld);
}

/******************************Public*Routine******************************\
* ulMagicFind - look for given magic color in default palette
*
* Arguments:
*
*   clrMagic - COLORREF of color to search for
*
* Return Value:
*
*   Index if found, 0xffffffff if not found.
*
* History:
*
*    15-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
ulMagicFind(
    PALETTEENTRY peMagic
    )
{
    XEPALOBJ xePalDefault(ppalDefault);
    return(xePalDefault.ulGetMatchFromPalentry(peMagic));
}


/******************************Public*Routine******************************\
* bSetMagicColor - set the specified magic color in both the device
*   palette and the default palette
*
* Arguments:
*
*   hdev     - hdev
*   Index    - magic color index (8,9,246,247)
*   palSurf  - surface palette
*   palDC    - logical palette
*   palColor - magic color
*
* Return Value:
*
*   Status
*
* History:
*
*    15-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

extern PPALETTE gppalHalftone;

BOOL
bSetMagicColor(
    XEPALOBJ     palSurf,
    ULONG        ulIndex,
    PAL_ULONG    PalEntry
    )
{
    BOOL bRet = FALSE;

    ASSERTGDI(((ulIndex == 8) || (ulIndex == 9) || (ulIndex == 246) || (ulIndex == 247)),
                "bSetMagicColor Error, wrong palette  index");

    //
    // make sure there are 20 reserved entries, and the static
    // colors are in use
    //

    if (
         (palSurf.ulNumReserved() == 20) &&
          (!palSurf.bIsNoStatic()) &&
          (!palSurf.bIsNoStatic256())
       )
    {
        //
        // set the entrie in the surface palette
        //

        PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
        palSurf.ulEntrySet(ulIndex,PalEntry.ul);

        //
        // update the palette time stamp
        //

        palSurf.vUpdateTime();

        //
        // set colors in the defaukt halftone palette for multimon system
        //
        
        if (gppalHalftone)
        {
            XEPALOBJ palHalftone(gppalHalftone);
            palHalftone.ulEntrySet(ulIndex,PalEntry.ul);
        }

        //
        // offset to upper half of default palette if needed
        //

        if (ulIndex > 10)
        {
            ulIndex = ulIndex - 236;
        }

        PalEntry.pal.peFlags = 0;

        //
        // set colors in the default Logical palette.
        //

        logDefaultPal.palPalEntry[ulIndex] = PalEntry.pal;

        //
        // set colors in the default palette and default log palette
        //

        XEPALOBJ palDefault(ppalDefault);
        palDefault.ulEntrySet(ulIndex,PalEntry.ul);

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* vResetSurfacePalette - copy the magic colors from the default palette
*   to the surface palette, and call the driver to set the palette
*
* NOTE: The devlock and pointer semaphore must already be held!
*
* Arguments:
*
*   po       - PDEV object
*   palSurf  - surface palette
*
* Return Value:
*
*   Status
*
* History:
*
*    21-Mar-1996 -by- J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

VOID
vResetSurfacePalette(
    HDEV         hdev
    )
{
    PDEVOBJ po(hdev);

    if (po.bIsPalManaged())
    {
        XEPALOBJ palSurf(po.ppalSurf());

        ASSERTGDI(palSurf.bValid(), "Invalid surface palette");

        if (
             (palSurf.ulNumReserved() == 20) &&
             (!palSurf.bIsNoStatic()) &&
             (!palSurf.bIsNoStatic256())
           )
        {
            PAL_ULONG PalEntry;

            XEPALOBJ palDefault(ppalDefault);

            //
            // set the entries in the surface palette
            //

            PalEntry.pal = palDefault.palentryGet(8);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(8,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(9);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(9,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(246 - 236);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(246,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(247 - 236);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(247,PalEntry.ul);
        }

        if (!po.bDisabled())
        {
            (*PPFNDRV(po,SetPalette))(
                po.dhpdev(),
                (PALOBJ *) &palSurf,
                0,
                0,
                palSurf.cEntries());
        }
    }
}

/******************************Public*Routine******************************\
*
* GreSetMagicColor  win95 compatible: set surface and default palette
*                   "magic" entries. This changes the default palette,
*                   and will affect bitmaps that think they have the
*                   correct 20 default colors already...
*
* Arguments:
*
*   hdc     - DC, specifies device surface
*   Index   - magic index, 1 of 8,9,246,247
*   peMagic - new color
*
* Return Value:
*
*   Status
*
* History:
*
*    10-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiSetMagicColors(
    HDC          hdc,
    PALETTEENTRY peMagic,
    ULONG        Index
    )
{
    return(GreSetMagicColors(hdc,peMagic,Index));
}

BOOL
GreSetMagicColors(
    HDC          hdc,
    PALETTEENTRY peMagic,
    ULONG        Index
    )
{
    DCOBJ     dco(hdc);
    BOOL      bRet = FALSE;
    BOOL      bPaletteChange = FALSE;
    BOOL      bChildDriver = FALSE;

    if (dco.bValid())
    {
        if (
             (Index == 8)   ||
             (Index == 9)   ||
             (Index == 246) ||
             (Index == 247)
           )
        {
            PAL_ULONG PalEntry;

            PalEntry.pal = peMagic;

            //
            // must be RGB or PALETTERGB
            //

            if (
                 ((PalEntry.ul & 0xff000000) == 0) ||
                 ((PalEntry.ul & 0xff000000) == 0x02000000)
               )
            {
                PDEVOBJ  po(dco.hdev());
                BOOL     bSetColor = FALSE;

                //
                // Lock the screen semaphore so that we don't get flipped into
                // full screen after checking the bit.  Plus it also protects
                // us from a dynamic mode change, which can change the
                // bIsPalManaged status.
                //

                DEVLOCKOBJ dlo(po);

                if (po.bIsPalManaged())
                {
                    bSetColor = TRUE;
                }
                else if (po.bMetaDriver())
                {
                    //
                    // If this is meta-driver, check if there is any palette device
                    //
                    PVDEV     pvdev = (VDEV*) po.dhpdev();
                    PDISPSURF pds   = pvdev->pds;
                    LONG      csurf = pvdev->cSurfaces;
                    do
                    {
                        po.vInit(pds->hdev);
                        if (po.bIsPalManaged())
                        {
                            bSetColor = TRUE;
                            bChildDriver = TRUE;
                            break;
                        }
                        pds = pds->pdsNext;
                    } while (--csurf);
                }

                if (bSetColor)
                {
                    XEPALOBJ palSurf(po.ppalSurf());

                    //
                    // palette sem scope
                    //

                    {
                        SEMOBJ  semPalette(ghsemPalette);

                        //
                        // look for color
                        //

                        ULONG ulMagicIndex = ulMagicFind(PalEntry.pal);

                        if (ulMagicIndex != 0xffffffff)
                        {
                            //
                            // found exact match
                            //

                            if (ulMagicIndex >= 10)
                            {
                                //
                                // the returned index must be adjusted for surface palette
                                //

                                ulMagicIndex += 236;
                            }

                            if (ulMagicIndex == Index)
                            {
                                if (bChildDriver)
                                {
                                    // If this is child of meta driver, we still need to call
                                    // driver to update palette. (in the ppalDefault, doesn't
                                    // mean in the child surface palette).
                                    //
                                    // set magic color
                                    //

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = bPaletteChange;
                                }
                                else
                                {
                                    //
                                    // already set
                                    //

                                    bRet = TRUE;
                                }
                            }
                            else
                            {
                                //
                                // make sure RGB is not a non-magic VGA color,
                                // if there is a match, it can only be a magic
                                // color
                                //

                                if (
                                     (ulMagicIndex == 8) ||
                                     (ulMagicIndex == 9) ||
                                     (ulMagicIndex == 246) ||
                                     (ulMagicIndex == 247)
                                   )
                                {
                                    //
                                    // set magic color
                                    //

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = bPaletteChange;
                                }
                                else
                                {
                                    //
                                    // bad rgb, restore Index with
                                    // default color
                                    //

                                    if (Index == 8)
                                    {
                                        PalEntry.ul = 0x00C0DCC0;
                                    }
                                    else if (Index == 9)
                                    {
                                        PalEntry.ul = 0x00F0CAA6;
                                    }
                                    else if (Index == 246)
                                    {
                                        PalEntry.ul = 0x00F0FBFF;
                                    }
                                    else
                                    {
                                        PalEntry.ul = 0x00A4A0A0;
                                    }

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = FALSE;
                                }
                            }
                        }
                        else
                        {
                            //
                            // set magic color
                            //

                            bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                            bRet = bPaletteChange;
                        }
                    }

                    if (bPaletteChange)
                    {
                        SEMOBJ so(po.hsemPointer());

                        if (!po.bDisabled())
                        {
                            po.pfnSetPalette()(
                                po.dhpdevParent(),
                                (PALOBJ *) &palSurf,
                                0,
                                0,
                                palSurf.cEntries());
                        }
                    }
                }
            }
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pathgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathgdi.cxx
*
* Contains the path APIs.
*
* Created: 12-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "pathwide.hxx"

// Default line attributes used for WidenPath:

static LINEATTRS glaNominalGeometric =
{
    LA_GEOMETRIC,           // fl
    JOIN_ROUND,             // iJoin
    ENDCAP_ROUND,           // iEndCap
    {IEEE_0_0F},            // elWidth
    IEEE_0_0F,              // eMiterLimit
    0,                      // cstyle
    (FLOAT_LONG*) NULL,     // pstyle
    {IEEE_0_0F}             // elStyleState
};

/******************************Public*Routine******************************\
* BOOL NtGdiCloseFigure(hdc)
*
* Closes the figure in an active path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiCloseFigure(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bActive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid() || !epath.bCloseFigure())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiAbortPath(hdc)
*
* Aborts a path bracket, or discards the path from a closed path bracket.
*
* History:
*  19-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiAbortPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

// Delete the previous path if there was one:

    if (dco.hpath() != HPATH_INVALID)
    {
    // If we did a SaveDC, we don't actually have to delete the entire path:

        if (dco.pdc->bLazySave())
            dco.pdc->vClearLazySave();
        else
        {
            XEPATHOBJ epath(dco);
            ASSERTGDI(epath.bValid(), "Invalid DC path");

            epath.vDelete();
        }

        dco.pdc->vDestroy();
    }

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiBeginPath(hdc)
*
* Starts a path bracket; subsequent drawing calls are added to the path
* until GreEndPath is called.  Destroys the old one if there was one.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiBeginPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

// Delete the previous path if there was one:

    if (dco.hpath() != HPATH_INVALID)
    {
    // If we did a SaveDC, we don't actually have to delete the entire path:

        if (dco.pdc->bLazySave())
            dco.pdc->vClearLazySave();
        else
        {
            XEPATHOBJ epath(dco);
            ASSERTGDI(epath.bValid(), "Invalid DC path");

            epath.vDelete();
        }

        dco.pdc->vDestroy();
    }

// Create a new path:

    PATHMEMOBJ pmo;
    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

// Tell the path we're keeping it, store the handle in the DC, and
// set the flag that we're now accumulating a path:

    pmo.vKeepIt();
    dco.pdc->hpath(pmo.hpath());
    dco.pdc->vSetActive();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiEndPath(hdc)
*
* Ends an active path bracket.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiEndPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

    if (!dco.pdc->bActive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// Mark the path handle as no longer active:

    dco.pdc->vClearActive();

    bRet = TRUE;
    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL NtGdiFlattenPath(hdc)
*
* Flattens an inactive path.  Path must be inactive, by calling GreEndPath.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiFlattenPath(HDC hdc)
{
    BOOL bRet = FALSE;

// Lock the DC.

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid() || !epath.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    bRet = TRUE;
    return(bRet);
}


/******************************Public*Routine******************************\
* HRGN NtGdiWidenPath(hdc, pac)
*
* Widens the inactive path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiWidenPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    LINEATTRS *pla = dco.plaRealize(xfo);

    if (!(pla->fl & LA_GEOMETRIC))
    {
    // If the pen is an extended pen, it has to be geometric to be used
    // for widening.  If we have an old style pen and the transform says
    // we would normally draw it using a cosmetic pen, substitute a stock
    // solid geometric pen for it instead.  Thus if pens created via
    // CreatePen are used for the widening, we won't suddenly fail the
    // call when the transform gets small enough.

        if (!((PPEN)dco.pdc->pbrushLine())->bIsOldStylePen())
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
            return(bRet);
        }

        pla = &glaNominalGeometric;
    }

    if (!epath.bComputeWidenedBounds((XFORMOBJ *) &xfo, pla))
    {
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
        return(bRet);
    }

    if (!epath.bWiden((XFORMOBJ *) &xfo, pla))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

// The computed widened bounds were only a guess, so recompute based
// on the widened result:

    epath.vReComputeBounds();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL NtGdiSelectClipPath(hdc, iMode)
*
* Selects a path as the DC clip region.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiSelectClipPath(HDC hdc, int iMode)
{
    GDITraceMultiBegin("NtGdiSelectClipPath(%X, %d)\n", (va_list)&hdc);
        GDITraceMultiHandle(hdc);
        GDITraceMulti(NtGdiSelectClipPath);
        GDITraceMulti(PATH);
    GDITraceMultiEnd();

    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid() || ((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    RGNMEMOBJTMP rmo(epath, dco.pdc->jFillMode());

    bRet = (rmo.bValid()  &&
            dco.pdc->iSelect(rmo.prgnGet(), iMode));

// Destroy the path (the region will be destroyed automatically):

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL NtGdiFillPath(hdc, pac)
*
* Fills an inactive path.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiFillPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

    // sync the client side cached brush

    if (dco.pdc->ulDirty() & DC_BRUSH_DIRTY)
    {
       GreDCSelectBrush(dco.pdc, dco.pdc->hbrush());
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    epath.vCloseAllFigures();

    bRet = epath.bFill(dco);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiPathToRegion(hdc)
*
* Creates a region from the inactive path.  Destroys the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HRGN APIENTRY NtGdiPathToRegion(HDC hdc)
{
    DCOBJ dco(hdc);
    HRGN  hrgnRet = (HRGN) 0;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(hrgnRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(hrgnRet);
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(hrgnRet);
    }

    RGNMEMOBJ rmo(epath, dco.pdc->jFillMode());

    if (rmo.bValid())
    {
        hrgnRet = rmo.hrgnAssociate();

        if (hrgnRet == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }
    }
    else
    {
        hrgnRet = NULL;
    }

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(hrgnRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiStrokeAndFillPath(hdc, pac)
*
* StrokeAndFill's the inactive path.  Destroys it.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStrokeAndFillPath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// sync the client side cached brush and pen

    SYNC_DRAWING_ATTRS(dco.pdc);

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    epath.vCloseAllFigures();

    bRet = epath.bStrokeAndFill(dco, dco.plaRealize(xfo), &xfo);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* HRGN NtGdiStrokePath(hdc)
*
* Stroke's the inactive path.  Destroys it.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStrokePath(HDC hdc)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!dco.pdc->bInactive())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(bRet);
    }

// sync the client side cached pen

    if (dco.pdc->ulDirty() & DC_PEN_DIRTY)
    {
       GreDCSelectPen(dco.pdc, dco.pdc->hpen());
    }

// After this point, the path will be deleted no matter what:

    XEPATHOBJ epath(dco);
    if (!epath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    // The path has been deleted, so delete its handle from the DC too:

        dco.pdc->vDestroy();
        return(bRet);
    }

    EXFORMOBJ xfo(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xfo.bValid(), "Invalid DC xform");

    bRet = epath.bStroke(dco, dco.plaRealize(xfo), &xfo);

// Destroy the path:

    epath.vDelete();
    dco.pdc->vDestroy();

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreSetMiterLimit(hdc, eNewLimit, peOldLimit)
*
* Sets the DC's miter limit for wide lines.  Optionally returns the old one.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetMiterLimit
(
HDC     hdc,
FLOATL  l_eNewLimit,
FLOATL *pl_eOldLimit
)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid() || l_eNewLimit < IEEE_1_0F)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (pl_eOldLimit != (FLOATL *) NULL)
    {
        *pl_eOldLimit = dco.pdc->l_eMiterLimit();
    }

    dco.pdc->l_eMiterLimit(l_eNewLimit);

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetMiterLimit(hdc, peMiterLimit)
*
* Returns the DC's miter limit for wide lines.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetMiterLimit(
HDC     hdc,
FLOATL *pl_eMiterLimit)
{
    BOOL bRet = FALSE;
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    *pl_eMiterLimit = dco.pdc->l_eMiterLimit();

    bRet = TRUE;
    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetPath()
*
* Gets the path data.  pcptPath will contain the number of points in the
* path, even if the supplied buffer is too small.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int
APIENTRY
NtGdiGetPath(
    HDC     hdc,
    LPPOINT pptlBuf,
    LPBYTE  pjTypes,
    int     cptBuf
    )
{
    int cptPath = -1;

    DCOBJ dco(hdc);

    if (dco.bValid() && cptBuf >= 0)
    {
        if (dco.pdc->bInactive())
        {
            EXFORMOBJ exfoDtoW(dco, DEVICE_TO_WORLD);

            if (exfoDtoW.bValid())
            {
                //
                // We're not going to modify the path, so we don't have to worry
                // about copying it if a SaveDC is pending:
                //

                XEPATHOBJ epath(dco.hpath());
                ASSERTGDI(epath.bValid(), "Invalid DC path");

                cptPath = (int) epath.cTotalPts();

                //
                // if cptBuf == 0, this is not an error.  This is a request
                // for the size of the path.
                //

                if (cptBuf != 0)
                {
                    //
                    // Return an error if the buffer is too small:
                    //
                    // Note: sizeof(BYTE) < sizeof(POINT), so the single test
                    //       suffices to check for overflow in both write
                    //       probes; also, using MAXULONG instead of
                    //       MAXIMUM_POOL_ALLOC because checking for overflow,
                    //       not allocating memory
                    //

                    ASSERTGDI(sizeof(BYTE) <= sizeof(POINT),
                              "NtGdiGetPath: bad overflow check\n");

                    if ((cptBuf >= cptPath) &&
                        (cptBuf <= (MAXULONG/sizeof(POINT))))
                    {
                        PATHDATA pd;
                        PBYTE    pjEnd;
                        BYTE     jType;
                        BOOL     bMore;

                        epath.vEnumStart();

                        __try {

                            ProbeForWrite(pptlBuf,
                                          cptBuf * sizeof(POINT),
                                          sizeof(DWORD));

                            ProbeForWrite(pjTypes,
                                          cptBuf * sizeof(BYTE),
                                          sizeof(DWORD));

                            do {

                                bMore = epath.bEnum(&pd);

                                // We can get a zero point record if it's an empty path:

                                if (pd.count > 0)
                                {
                                    // Copy points:

                                    if (!exfoDtoW.bXform(pd.pptfx,
                                                         (PPOINTL) pptlBuf,
                                                         (SIZE_T) pd.count))
                                    {
                                        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                                        cptPath = -1;
                                        break;
                                    }

                                    pptlBuf += pd.count;

                                    // Determine types:

                                    pjEnd = pjTypes + pd.count;

                                    // First point in a subpath is always a MoveTo:

                                    if (pd.flags & PD_BEGINSUBPATH)
                                    {
                                        *pjTypes++ = PT_MOVETO;
                                    }

                                    // Other points are LineTo's or BezierTo's:

                                    jType = (pd.flags & PD_BEZIERS)
                                             ? (BYTE) PT_BEZIERTO
                                             : (BYTE) PT_LINETO;

                                    while (pjTypes < pjEnd)
                                    {
                                        *pjTypes++ = jType;
                                    }

                                    // Set CloseFigure bit for last point in a subpath:

                                    if (pd.flags & PD_CLOSEFIGURE)
                                    {
                                        ASSERTGDI(pd.flags & PD_ENDSUBPATH, "Expected on last pd");
                                        *(pjTypes - 1) |= PT_CLOSEFIGURE;
                                    }
                                }

                            } while (bMore);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            // SetLastError(GetExceptionCode());

                            cptPath = -1;
                        }
                    }
                    else
                    {
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                        cptPath = -1;
                    }
                }
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(cptPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\palobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: palobj.cxx
*
* Palette user object functions
*
* Created: 07-Nov-1990 21:30:19
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitPALOBJ();

#pragma alloc_text(INIT, bInitPALOBJ)

#define MAX_PAL_ERROR (3 * (256*256))

// ulXlatePalUnique is used for the uniquess of the xlates and palettes.

ULONG ulXlatePalUnique = 3;

// gpRGBXlate is a global RGBXlate for the rainbow palette

PBYTE gpRGBXlate = NULL;

UINT *pArrayOfSquares;
UINT aArrayOfSquares[511];

typedef BYTE  FAR  *PIMAP;
typedef struct {BYTE r,g,b,x;} RGBX;
BOOL MakeITable(PIMAP lpITable, RGBX FAR *prgb, int nColors);

/******************************Public*Data*********************************\
* Default Monochrome Palette
*
* History:
*  16-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG gaulMono[2] =
{
    0,
    0xFFFFFF
};

/******************************Public*Data*********************************\
* Default Logical Palette
*
*  Default Palette Data Structure, Taken straight from Win 3.1
*  This is the default palette, the stock palette.
*  This contains the 20 default colors.
*  This is the default logical palette put in every DC when it is created.
*
* History:
*  16-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PAL_LOGPALETTE logDefaultPal =
{
    0x300,   // version number
    20,      // number of entries
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0xC0,0xC0,0xC0,0  },  // 7

    { 192, 220, 192, 0  },  // 8
    { 166, 202, 240, 0  },  // 9
    { 255, 251, 240, 0  },  // 10
    { 160, 160, 164, 0  },  // 11

    { 0x80,0x80,0x80,0  },  // 12
    { 0xFF,0,   0,   0  },  // 13
    { 0,   0xFF,0,   0  },  // 14
    { 0xFF,0xFF,0,   0  },  // 15
    { 0,   0,   0xFF,0  },  // 16
    { 0xFF,0,   0xFF,0  },  // 17
    { 0,   0xFF,0xFF,0  },  // 18
    { 0xFF,0xFF,0xFF,0  }   // 19
}
};

/******************************Public*Data**********************************\
*
* This is the same as color table as logDefaultPal except
* entries for magic colors. These are 0x0 to prevent a match.
* We now only match magic colors exactly, otherwise nearest-match
* to this palette
*
\**************************************************************************/

PAL_ULONG aPalDefaultVGA[20] =
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0xC0,0xC0,0xC0,0  },  // 7

    { 000, 000, 000, 0  },  // 8
    { 000, 000, 000, 0  },  // 9
    { 000, 000, 000, 0  },  // 10
    { 000, 000, 000, 0  },  // 11

    { 0x80,0x80,0x80,0  },  // 12
    { 0xFF,0,   0,   0  },  // 13
    { 0,   0xFF,0,   0  },  // 14
    { 0xFF,0xFF,0,   0  },  // 15
    { 0,   0,   0xFF,0  },  // 16
    { 0xFF,0,   0xFF,0  },  // 17
    { 0,   0xFF,0xFF,0  },  // 18
    { 0xFF,0xFF,0xFF,0  }   // 19
};

/******************************Public*Data*********************************\
* This is the default 16 color palette which matches the VGA palette
* exactly.
*
* History:
*  05-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PAL_ULONG aPalVGA[16] =
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0x80,0x80,0x80,0  },  // 7
    { 0xC0,0xC0,0xC0,0  },  // 8
    { 0xFF,0,   0,   0  },  // 9
    { 0,   0xFF,0,   0  },  // 10
    { 0xFF,0xFF,0,   0  },  // 11
    { 0,   0,   0xFF,0  },  // 12
    { 0xFF,0,   0xFF,0  },  // 13
    { 0,   0xFF,0xFF,0  },  // 14
    { 0xFF,0xFF,0xFF,0  }   // 15
};


/******************************Public*Routine******************************\
*
*   win95 halftone palette
*
* History:
*
*    11/27/1996 Mark Enstrom [marke]
*
*   03-Feb-1999 Wed 01:47:31 updated  -by-  Daniel Chou (danielc)
*       Even though this is the one copy from win95, it is wrong for halftone
*       to be use correctly, it missing high luminance green color, I added
*       this back, and the low r/b/m/c luminance color (20% of that color) are
*       patch into gray color.  All window system halftone does not use any
*       gray color in 256 color mode any more.
*
*           Index 10: 0x04:0x04:0x04 --> 0x00:0x00:0x33
*           Index 11: 0x08:0x08:0x08 --> 0x33:0x00:0x00
*           Index 12: 0x0c:0x0c:0x0c --> 0x33:0x00:0x33
*           Index 13: 0x11:0x11:0x11 --> 0x00:0x33:0x33
*           Index 39: 0x33:0x00:0x00 --> 0x33:0xFF:0x00
*           Index 60: 0x00:0x00:0x33 --> 0x00:0xFF:0x33
*           Index 61: 0x33:0x00:0x33 --> 0x33:0x00:0xFF
*           Index 66: 0x00:0x33:0x33 --> 0x00:0x33:0xFF
*
\**************************************************************************/

PAL_ULONG  aPalHalftone[256] =
{
    {0x00,0x00,0x00,0x00},{0x80,0x00,0x00,0x00},{0x00,0x80,0x00,0x00},{0x80,0x80,0x00,0x00},
    {0x00,0x00,0x80,0x00},{0x80,0x00,0x80,0x00},{0x00,0x80,0x80,0x00},{0xc0,0xc0,0xc0,0x00},
    {0xc0,0xdc,0xc0,0x00},{0xa6,0xca,0xf0,0x00},{0x00,0x00,0x33,0x04},{0x33,0x00,0x00,0x04},
    {0x33,0x00,0x33,0x04},{0x00,0x33,0x33,0x04},{0x16,0x16,0x16,0x04},{0x1c,0x1c,0x1c,0x04},
    //1
    {0x22,0x22,0x22,0x04},{0x29,0x29,0x29,0x04},{0x55,0x55,0x55,0x04},{0x4d,0x4d,0x4d,0x04},
    {0x42,0x42,0x42,0x04},{0x39,0x39,0x39,0x04},{0xFF,0x7C,0x80,0x04},{0xFF,0x50,0x50,0x04},
    {0xD6,0x00,0x93,0x04},{0xCC,0xEC,0xFF,0x04},{0xEF,0xD6,0xC6,0x04},{0xE7,0xE7,0xD6,0x04},
    {0xAD,0xA9,0x90,0x04},{0x33,0xFF,0x00,0x04},{0x66,0x00,0x00,0x04},{0x99,0x00,0x00,0x04},
    //2
    {0xcc,0x00,0x00,0x04},{0x00,0x33,0x00,0x04},{0x33,0x33,0x00,0x04},{0x66,0x33,0x00,0x04},
    {0x99,0x33,0x00,0x04},{0xcc,0x33,0x00,0x04},{0xff,0x33,0x00,0x04},{0x00,0x66,0x00,0x04},
    {0x33,0x66,0x00,0x04},{0x66,0x66,0x00,0x04},{0x99,0x66,0x00,0x04},{0xcc,0x66,0x00,0x04},
    {0xff,0x66,0x00,0x04},{0x00,0x99,0x00,0x04},{0x33,0x99,0x00,0x04},{0x66,0x99,0x00,0x04},
    //3
    {0x99,0x99,0x00,0x04},{0xcc,0x99,0x00,0x04},{0xff,0x99,0x00,0x04},{0x00,0xcc,0x00,0x04},
    {0x33,0xcc,0x00,0x04},{0x66,0xcc,0x00,0x04},{0x99,0xcc,0x00,0x04},{0xcc,0xcc,0x00,0x04},
    {0xff,0xcc,0x00,0x04},{0x66,0xff,0x00,0x04},{0x99,0xff,0x00,0x04},{0xcc,0xff,0x00,0x04},
    {0x00,0xFF,0x33,0x04},{0x33,0x00,0xFF,0x04},{0x66,0x00,0x33,0x04},{0x99,0x00,0x33,0x04},
    //4
    {0xcc,0x00,0x33,0x04},{0xff,0x00,0x33,0x04},{0x00,0x33,0xFF,0x04},{0x33,0x33,0x33,0x04},
    {0x66,0x33,0x33,0x04},{0x99,0x33,0x33,0x04},{0xcc,0x33,0x33,0x04},{0xff,0x33,0x33,0x04},
    {0x00,0x66,0x33,0x04},{0x33,0x66,0x33,0x04},{0x66,0x66,0x33,0x04},{0x99,0x66,0x33,0x04},
    {0xcc,0x66,0x33,0x04},{0xff,0x66,0x33,0x04},{0x00,0x99,0x33,0x04},{0x33,0x99,0x33,0x04},
    //5
    {0x66,0x99,0x33,0x04},{0x99,0x99,0x33,0x04},{0xcc,0x99,0x33,0x04},{0xff,0x99,0x33,0x04},
    {0x00,0xcc,0x33,0x04},{0x33,0xcc,0x33,0x04},{0x66,0xcc,0x33,0x04},{0x99,0xcc,0x33,0x04},
    {0xcc,0xcc,0x33,0x04},{0xff,0xcc,0x33,0x04},{0x33,0xff,0x33,0x04},{0x66,0xff,0x33,0x04},
    {0x99,0xff,0x33,0x04},{0xcc,0xff,0x33,0x04},{0xff,0xff,0x33,0x04},{0x00,0x00,0x66,0x04},
    //6
    {0x33,0x00,0x66,0x04},{0x66,0x00,0x66,0x04},{0x99,0x00,0x66,0x04},{0xcc,0x00,0x66,0x04},
    {0xff,0x00,0x66,0x04},{0x00,0x33,0x66,0x04},{0x33,0x33,0x66,0x04},{0x66,0x33,0x66,0x04},
    {0x99,0x33,0x66,0x04},{0xcc,0x33,0x66,0x04},{0xff,0x33,0x66,0x04},{0x00,0x66,0x66,0x04},
    {0x33,0x66,0x66,0x04},{0x66,0x66,0x66,0x04},{0x99,0x66,0x66,0x04},{0xcc,0x66,0x66,0x04},
    //7
    {0x00,0x99,0x66,0x04},{0x33,0x99,0x66,0x04},{0x66,0x99,0x66,0x04},{0x99,0x99,0x66,0x04},
    {0xcc,0x99,0x66,0x04},{0xff,0x99,0x66,0x04},{0x00,0xcc,0x66,0x04},{0x33,0xcc,0x66,0x04},
    {0x99,0xcc,0x66,0x04},{0xcc,0xcc,0x66,0x04},{0xff,0xcc,0x66,0x04},{0x00,0xff,0x66,0x04},
    {0x33,0xff,0x66,0x04},{0x99,0xff,0x66,0x04},{0xcc,0xff,0x66,0x04},{0xff,0x00,0xcc,0x04},
    //8
    {0xcc,0x00,0xff,0x04},{0x00,0x99,0x99,0x04},{0x99,0x33,0x99,0x04},{0x99,0x00,0x99,0x04},
    {0xcc,0x00,0x99,0x04},{0x00,0x00,0x99,0x04},{0x33,0x33,0x99,0x04},{0x66,0x00,0x99,0x04},
    {0xcc,0x33,0x99,0x04},{0xff,0x00,0x99,0x04},{0x00,0x66,0x99,0x04},{0x33,0x66,0x99,0x04},
    {0x66,0x33,0x99,0x04},{0x99,0x66,0x99,0x04},{0xcc,0x66,0x99,0x04},{0xff,0x33,0x99,0x04},
    //9
    {0x33,0x99,0x99,0x04},{0x66,0x99,0x99,0x04},{0x99,0x99,0x99,0x04},{0xcc,0x99,0x99,0x04},
    {0xff,0x99,0x99,0x04},{0x00,0xcc,0x99,0x04},{0x33,0xcc,0x99,0x04},{0x66,0xcc,0x66,0x04},
    {0x99,0xcc,0x99,0x04},{0xcc,0xcc,0x99,0x04},{0xff,0xcc,0x99,0x04},{0x00,0xff,0x99,0x04},
    {0x33,0xff,0x99,0x04},{0x66,0xcc,0x99,0x04},{0x99,0xff,0x99,0x04},{0xcc,0xff,0x99,0x04},
    //a
    {0xff,0xff,0x99,0x04},{0x00,0x00,0xcc,0x04},{0x33,0x00,0x99,0x04},{0x66,0x00,0xcc,0x04},
    {0x99,0x00,0xcc,0x04},{0xcc,0x00,0xcc,0x04},{0x00,0x33,0x99,0x04},{0x33,0x33,0xcc,0x04},
    {0x66,0x33,0xcc,0x04},{0x99,0x33,0xcc,0x04},{0xcc,0x33,0xcc,0x04},{0xff,0x33,0xcc,0x04},
    {0x00,0x66,0xcc,0x04},{0x33,0x66,0xcc,0x04},{0x66,0x66,0x99,0x04},{0x99,0x66,0xcc,0x04},
    //b
    {0xcc,0x66,0xcc,0x04},{0xff,0x66,0x99,0x04},{0x00,0x99,0xcc,0x04},{0x33,0x99,0xcc,0x04},
    {0x66,0x99,0xcc,0x04},{0x99,0x99,0xcc,0x04},{0xcc,0x99,0xcc,0x04},{0xff,0x99,0xcc,0x04},
    {0x00,0xcc,0xcc,0x04},{0x33,0xcc,0xcc,0x04},{0x66,0xcc,0xcc,0x04},{0x99,0xcc,0xcc,0x04},
    {0xcc,0xcc,0xcc,0x04},{0xff,0xcc,0xcc,0x04},{0x00,0xff,0xcc,0x04},{0x33,0xff,0xcc,0x04},
    //c
    {0x66,0xff,0x99,0x04},{0x99,0xff,0xcc,0x04},{0xcc,0xff,0xcc,0x04},{0xff,0xff,0xcc,0x04},
    {0x33,0x00,0xcc,0x04},{0x66,0x00,0xff,0x04},{0x99,0x00,0xff,0x04},{0x00,0x33,0xcc,0x04},
    {0x33,0x33,0xff,0x04},{0x66,0x33,0xff,0x04},{0x99,0x33,0xff,0x04},{0xcc,0x33,0xff,0x04},
    {0xff,0x33,0xff,0x04},{0x00,0x66,0xff,0x04},{0x33,0x66,0xff,0x04},{0x66,0x66,0xcc,0x04},
    //d
    {0x99,0x66,0xff,0x04},{0xcc,0x66,0xff,0x04},{0xff,0x66,0xcc,0x04},{0x00,0x99,0xff,0x04},
    {0x33,0x99,0xff,0x04},{0x66,0x99,0xff,0x04},{0x99,0x99,0xff,0x04},{0xcc,0x99,0xff,0x04},
    {0xff,0x99,0xff,0x04},{0x00,0xcc,0xff,0x04},{0x33,0xcc,0xff,0x04},{0x66,0xcc,0xff,0x04},
    {0x99,0xcc,0xff,0x04},{0xcc,0xcc,0xff,0x04},{0xff,0xcc,0xff,0x04},{0x33,0xff,0xff,0x04},
    //e
    {0x66,0xff,0xcc,0x04},{0x99,0xff,0xff,0x04},{0xcc,0xff,0xff,0x04},{0xff,0x66,0x66,0x04},
    {0x66,0xff,0x66,0x04},{0xff,0xff,0x66,0x04},{0x66,0x66,0xff,0x04},{0xff,0x66,0xff,0x04},
    {0x66,0xff,0xff,0x04},{0xA5,0x00,0x21,0x04},{0x5f,0x5f,0x5f,0x04},{0x77,0x77,0x77,0x04},
    {0x86,0x86,0x86,0x04},{0x96,0x96,0x96,0x04},{0xcb,0xcb,0xcb,0x04},{0xb2,0xb2,0xb2,0x04},
    //f
    {0xd7,0xd7,0xd7,0x04},{0xdd,0xdd,0xdd,0x04},{0xe3,0xe3,0xe3,0x04},{0xea,0xea,0xea,0x04},
    {0xf1,0xf1,0xf1,0x04},{0xf8,0xf8,0xf8,0x04},{0xff,0xfb,0xf0,0x00},{0xa0,0xa0,0xa4,0x00},
    {0x80,0x80,0x80,0x00},{0xff,0x00,0x00,0x00},{0x00,0xff,0x00,0x00},{0xff,0xff,0x00,0x00},
    {0x00,0x00,0xff,0x00},{0xff,0x00,0xff,0x00},{0x00,0xff,0xff,0x00},{0xff,0xff,0xff,0x00}
};


// ppalDefault is the pointer to the default palette info
// We lock the default palette down at creation and never unlock
// it so that multiple apps can access the default palette simultaneously.

PPALETTE ppalDefault = (PPALETTE) NULL;
PPALETTE gppalRGB    = (PPALETTE) NULL;

// ppalDefaultSurface8bpp is the pointer to the default 8bpp surface palette.
// This is used for dynamic mode changes when converting a Device Dependent
// Bitmap, which has no color table, to a Device Indepdent Bitmap, which
// has a color table -- this is what we use for the color table.
// We lock the default palette down at creation and never unlock
// it so that multiple surface  can access the default palette simultaneously.

PPALETTE ppalDefaultSurface8bpp = (PPALETTE) NULL;

// This is the global palette for the monochrome bitmaps.

HPALETTE hpalMono = (HPALETTE) 0;
PPALETTE ppalMono = (PPALETTE) NULL;

/******************************Public*Routine******************************\
* RGB_ERROR
*
* Returns a measure of error between two RGB entries.
*
* History:
*  14-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

inline ULONG RGB_ERROR(PALETTEENTRY palDst, PALETTEENTRY palSrc)
{
    INT lTemp, lTemp1;

    lTemp = ((INT) (UINT) (palDst.peRed))     -
                ((INT) (UINT) (palSrc.peRed));

    lTemp1 = lTemp * lTemp;

    lTemp =     ((INT) (UINT) (palDst.peGreen))   -
                ((INT) (UINT) (palSrc.peGreen));

    lTemp1 +=  lTemp * lTemp;

    lTemp =     ((INT) (UINT) (palDst.peBlue))       -
                ((INT) (UINT) (palSrc.peBlue));

    lTemp1 += lTemp * lTemp;

    return((ULONG) lTemp1);
}

/******************************Public*Routine******************************\
* BOOL XEPALOBJ::bSwap(ppalSrc)
*
* This is for swapping palettes, necesary for ResizePalette.
*
* History:
*  Sun 21-Jun-1992 -by- Patrick Haluptzok [patrickh]
* Make it a Safe swap under MLOCK.
*
*  Fri 18-Jan-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL
XEPALOBJ::bSwap(
    PPALETTE *pppalSrc,
    ULONG cShareCountDst,
    ULONG cShareCountSrc
    )
{
    PPALETTE ppalSrc = *pppalSrc;
    BOOL bRet;

    bRet = HmgSwapLockedHandleContents((HOBJ)ppal->hGet(),
                                 cShareCountDst,
                                 (HOBJ)ppalSrc->hGet(),
                                 cShareCountSrc,
                                 PAL_TYPE);

    //
    // swap user pointers to palette objects
    //

    if (bRet)
    {
        *pppalSrc = ppal;
        ppal = ppalSrc;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulBitfieldToRGB
*
* Converts an index into an RGB for Bitfield palettes.
*
* History:
*  Tue 31-Mar-1992 -by- Patrick Haluptzok [patrickh]
* Does better mapping.
*
*  08-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulBitfieldToRGB(ULONG ulIndex)
{
    ASSERTGDI(bIsBitfields(), "Error ulBitfieldToRGB not bitfields");

    ULONG ulRed = (ulIndex & flRed()) >> cRedRight();

    if (cRedMiddle() < 8)
    {
        ulRed = ulRed << (8 - cRedMiddle());
        ulRed = ulRed | (ulRed >> cRedMiddle());
    }

    ULONG ulGre = (ulIndex & flGre()) >> cGreRight();

    if (cGreMiddle() < 8)
    {
        ulGre = ulGre << (8 - cGreMiddle());
        ulGre = ulGre | (ulGre >> cGreMiddle());
    }

    ulGre = ulGre << 8;

    ULONG ulBlu = (ulIndex & flBlu()) >> cBluRight();

    if (cBluMiddle() < 8)
    {
        ulBlu = ulBlu << (8 - cBluMiddle());
        ulBlu = ulBlu | (ulBlu >> cBluMiddle());
    }

    ulBlu = ulBlu << 16;

    return(ulRed | ulBlu | ulGre);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulIndexToRGB
*
* Converts an index to an RGB for a palette.
*
* History:
*  05-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulIndexToRGB(ULONG ulIndex)
{
    if (bIsIndexed())
    {
        if (cEntries() > ulIndex)
            ulIndex = (ulEntryGet(ulIndex) & 0xFFFFFF);
        else
            ulIndex = 0;
    }
    else if (bIsBitfields())
    {
        ulIndex = ulBitfieldToRGB(ulIndex);
    }
    else if (bIsBGR())
    {
        BGR_ULONG palOld;
        PAL_ULONG palNew;

        palOld.ul = ulIndex;
        palNew.pal.peRed   = palOld.rgb.rgbRed;
        palNew.pal.peGreen = palOld.rgb.rgbGreen;
        palNew.pal.peBlue  = palOld.rgb.rgbBlue;
        palNew.pal.peFlags = 0;
        ulIndex = palNew.ul;
    }
    else
    {
    // 0 out the flags.

        ASSERTGDI(bIsRGB(), "ERROR another type not accounted for\n");
        ulIndex &= 0xFFFFFF;
    }

    return(ulIndex);
}

/******************************Public*Routine******************************\
* ParseBits
*
* This routine computes how much the left and right shifts are for
* PAL_BITFIELDS 16 and 32 bit masks.
*
* History:
*  09-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID ParseBits(FLONG flag, ULONG *pcRight, ULONG *pcLeft, ULONG *pcMiddle, ULONG cForColor)
{
    ULONG ulRight = 0;
    ULONG ulMiddle;

    ASSERTGDI(flag != 0, "ERROR flag");

    while((flag & 1) == 0)
    {
        flag >>= 1;
        ulRight++;
    }

    ulMiddle = ulRight;

    do
    {
        flag >>= 1;
        ulMiddle++;
    } while(flag & 1);

    *pcMiddle = ulMiddle = ulMiddle - ulRight;
    *pcRight = (ulMiddle > 8) ? (ulRight + ulMiddle - 8) : (ulRight);
    *pcLeft  = (ulMiddle > 8) ? (cForColor) : (cForColor + (8 - ulMiddle));
}

/******************************Public*Routine******************************\
* PALMEMOBJ::bCreatePalette
*
* Constructor for creating palettes.
*
* Returns: True for success, False for error.
*
* History:
*  18-Feb-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
PALMEMOBJ::bCreatePalette(
    ULONG iMode,         // The mode the palette is.
    ULONG cColors,       // Number of RGB's if indexed palette.
    ULONG *pulColors,    // Pointer to RGB's if indexed.
    FLONG flRedd,        // Mask for Red if bitfields
    FLONG flGreen,       // Mask for Green if bitfields
    FLONG flBlue,        // Mask for Blue if bitfields
    ULONG iType)         // The type it will be, fixed, free, managed, DC.
{

    ASSERTGDI(bKeep == FALSE, "ERROR bCreatePalette bKeep is not False");
    ASSERTGDI(ppal == (PPALETTE) NULL, "ERROR bCreatePalette ppal is NULL");
    PAL_ULONG palul;
    BOOL bDataStatus = TRUE;

// This data may be coming accross the DDI from a newer driver or from a
// journal file or from a app, so we must validate everything, make sure
// only valid iType flags are set for the iMode.

// Validate the iMode, calculate the size needed into palul.

    palul.ul = sizeof(PALETTE);

    switch(iMode)
    {
    case PAL_BITFIELDS:

    // Bitfields palette is always fixed, we ASSERT values that should
    // be correct to detect bad code in testing, but still assign correct
    // values so that corrupt journal files don't create bad palettes.

        ASSERTGDI(iType & PAL_FIXED, "ERROR bCreatePalette PAL_BITFIELDS");
        ASSERTGDI(cColors == 0, "ERROR GDI EngCreatePalette PAL_BITFIELDS");
        iType = iType & (PAL_FIXED | PAL_HT | PAL_DC);
        cColors = 0;

    // We need to check these so we don't fault ourselves.

        if ((flRedd == 0) || (flBlue == 0) || (flGreen == 0))
        {
            WARNING1("ERROR bCreatePalette 0 flags for PAL_BITFIELDS\n");
            return(FALSE);
        }

        palul.ul += sizeof(P_BITFIELDS);
        break;

    case PAL_BGR:
    case PAL_RGB:
    case PAL_CMYK:

    // RGB and CMYK palette is always fixed.

        ASSERTGDI(iType & PAL_FIXED, "bCreatePalette PAL_RGB/PAL_CMYK: iType not PAL_FIXED");
        ASSERTGDI((iType & ~(PAL_FIXED | PAL_DC | PAL_HT)) == 0, "bCreatePal PAL_RGB/PAL_CMYK: extra flags in iType ");
        ASSERTGDI(cColors == 0, "bCreatePalette PAL_RGB/PAL_CMYK: cColors not 0");
        iType = (iType & (PAL_DC | PAL_HT)) | PAL_FIXED;
        cColors = 0;
        if (iMode != PAL_CMYK)
        {
            if (iMode == PAL_RGB)
            {
                flRedd  = 0x0000FF;
                flGreen = 0x00FF00;
                flBlue  = 0xFF0000;
            }
            else if (iMode == PAL_BGR)
            {
                flRedd  = 0xFF0000;
                flGreen = 0x00FF00;
                flBlue  = 0x0000FF;
            }
            palul.ul += sizeof(P_BITFIELDS);
        }

        break;

    case PAL_INDEXED:

        palul.ul += (sizeof(PAL_ULONG) * cColors);

    // ASSERT for valid flags to detect bad code, mask off invalid flags so in
    // retail we work fine with journal files, bad drivers.

        ASSERTGDI((iType & ~(PAL_MONOCHROME | PAL_DC | PAL_FREE | PAL_FIXED | PAL_MANAGED | PAL_HT)) == 0,
                              "ERROR bCreatePal PAL_INDEXED iType");

        iType = iType & (PAL_MONOCHROME | PAL_DC | PAL_FREE | PAL_FIXED | PAL_MANAGED | PAL_HT);

        if (cColors == 0)
        {
            RIP("ERROR PAL_INDEXED bCreatePalette cColors 0\n");
            return(FALSE);
        }

        break;

    default:
        RIP("bCreatePalette theses modes are not supported at this time\n");
        return(FALSE);
    }

// Allocate the palette.

    PPALETTE ppalTemp;

    ppal = ppalTemp = (PPALETTE) ALLOCOBJ(palul.ul, PAL_TYPE, FALSE);

    if (ppalTemp == (PPALETTE)NULL)
    {
        WARNING("bCreatePalette failed memory allocation\n");
        return(FALSE);
    }

    //
    // Initialize the palette.
    //

    ppalTemp->flPal          = iMode | iType;
    ppalTemp->cEntries       = cColors;
    ppalTemp->ulTime         = ulGetNewUniqueness(ulXlatePalUnique);
    ppalTemp->hdcHead        = (HDC) 0;
    ppalTemp->hSelected.ppal = (PPALETTE) NULL;
    ppalTemp->cRefRegular    = 0;
    ppalTemp->cRefhpal       = 0;
    ppalTemp->ptransFore     = NULL;
    ppalTemp->ptransCurrent  = NULL;
    ppalTemp->ptransOld      = NULL;
    ppalTemp->ulRGBTime      = 0;
    ppalTemp->pRGBXlate      = NULL;
    ppalTemp->ppalColor      = ppalTemp;
    ppalTemp->apalColor      = &ppalTemp->apalColorTable[0];

    switch(iMode)
    {
    case PAL_BITFIELDS:
    case PAL_RGB:
    case PAL_BGR:

    {
    // It won't kill us if any of these flags are 0, but it is
    // definitely an error on someones behalf.

        ASSERTGDI(flRedd   != 0, "ERROR flGre");
        ASSERTGDI(flGreen  != 0, "ERROR flGre");
        ASSERTGDI(flBlue   != 0, "ERROR flBlu");

    // Save away the Masks

        flRed(flRedd);
        flGre(flGreen);
        flBlu(flBlue);

        if ((flRedd  == 0x0000ff) &&
            (flGreen == 0x00ff00) &&
            (flBlue  == 0xff0000))
        {
            ppalTemp->flPal |= PAL_RGB;
        }
        else if ((flRedd  == 0xf800) &&
                 (flGreen == 0x07e0) &&
                 (flBlue  == 0x001f))
        {
            ppalTemp->flPal |= PAL_RGB16_565;
        }
        else if ((flRedd  == 0x7c00) &&
                 (flGreen == 0x03e0) &&
                 (flBlue  == 0x001f))
        {
            ppalTemp->flPal |= PAL_RGB16_555;
        }

    // Let ParseBits calculate the left and right shifts we need.

        ParseBits(flRedd,  &cRedRight(), &cRedLeft(), &cRedMiddle(), 0);
        ParseBits(flGreen, &cGreRight(), &cGreLeft(), &cGreMiddle(), 8);
        ParseBits(flBlue,  &cBluRight(), &cBluLeft(), &cBluMiddle(), 16);
    }

    break;

    case PAL_INDEXED:

    {
        UINT uiTemp;
        PAL_ULONG *ppalstruc = apalColorGet();

        if (pulColors != (PULONG) NULL)
        {
            //
            // Copy the palette values in.
            // Make sure only valid entries are copied.
            //

            __try
            {
                for (uiTemp = 0; uiTemp < cColors; uiTemp++)
                {
                    palul.ul = *(pulColors++);
                    (ppalstruc++)->pal = palul.pal;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());
                bDataStatus = FALSE;
            }
        }
        else
        {
        // Initialize the palette with 0's.

            for (uiTemp = 0; uiTemp < cColors; uiTemp++)
                (ppalstruc++)->ul = 0;
        }
    }

    } // switch

// Now that all the other appropriate fields have been computed, compute
// the call tables.

    XEPALOBJ pal(ppalTemp);
    pal.vComputeCallTables();

// Add it to the handle table.

    if (bDataStatus)
    {
        if (HmgInsertObject(ppalTemp,
                            HMGR_MAKE_PUBLIC | HMGR_ALLOC_ALT_LOCK,
                            PAL_TYPE) != (HOBJ) 0)
        {
            return(TRUE);
        }
        WARNING("bCreatePalette failed HmgInsertObject\n");
    }
    else
    {
        WARNING("bCreatePalette failed Copying user data\n");
    }

// Clean up the allocated memory.

    FREEOBJ(ppalTemp, PAL_TYPE);
    ppal = NULL;
    return(FALSE);
}

PALETTEENTRY apalMono[2] =
{
    { 0,   0,   0,   0  },
    { 0xFF,0xFF,0xFF,0  }
};

PALETTEENTRY apal3BPP[8] =
{
    {0,   0,   0,    0 },
    {0,   0,   0xFF, 0 },
    {0,   0xFF,0,    0 },
    {0,   0xFF,0xFF, 0 },
    {0xFF,0,   0,    0 },
    {0xFF,0,   0xFF, 0 },
    {0xFF,0xFF,0,    0 },
    {0xFF,0xFF,0xFF, 0 }
};

PALETTEENTRY apalVGA[16] =
{
    {0,   0,   0,    0 },
    {0x80,0,   0,    0 },
    {0,   0x80,0,    0 },
    {0x80,0x80,0,    0 },
    {0,   0,   0x80, 0 },
    {0x80,0,   0x80, 0 },
    {0,   0x80,0x80, 0 },
    {0x80,0x80,0x80, 0 },

    {0xC0,0xC0,0xC0, 0 },
    {0xFF,0,   0,    0 },
    {0,   0xFF,0,    0 },
    {0xFF,0xFF,0,    0 },
    {0,   0,   0xFF, 0 },
    {0xFF,0,   0xFF, 0 },
    {0,   0xFF,0xFF, 0 },
    {0xFF,0xFF,0xFF, 0 }
};

#define COLOR_SWAP_BC       0x01
#define COLOR_SWAP_AB       0x02
#define COLOR_SWAP_AC       0x04

/******************************Member*Function*****************************\
* PALMEMOBJ::bCreateHTPalette
*
* Constructor for creating halftone palettes.
*
* Returns: True for success, False for error.
*
* History:
*  04-Jun-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL PALMEMOBJ::bCreateHTPalette(LONG iFormatHT, GDIINFO *pGdiInfo)
{
    if ((iFormatHT == HT_FORMAT_32BPP)  ||
        (iFormatHT == HT_FORMAT_24BPP)  ||
        (iFormatHT == HT_FORMAT_16BPP)) {

    // 32BPP halftone use lower 3 bytes as RGB, same as 24bpp, but with extra
    // pad byte at end, the order can be any of PRIMARY_ORDER_xxx

        ULONG   ulPrimaryOrder = pGdiInfo->ulPrimaryOrder;
        ULONG   ulR;
        ULONG   ulG;
        ULONG   ulB;
        ULONG   ulTmp;

        if (iFormatHT == HT_FORMAT_16BPP) {

            //
            // 16BPP_555 for now, we should also do 16bpp_565

            ulR = 0x00007c00;
            ulG = 0x000003e0;
            ulB = 0x0000001f;

        } else {

            ulR = 0x00FF0000;
            ulG = 0x0000FF00;
            ulB = 0x000000FF;
        }

        if (ulPrimaryOrder & COLOR_SWAP_BC) {

            ulTmp = ulG;
            ulG   = ulB;
            ulB   = ulTmp;
        }

        if (ulPrimaryOrder & COLOR_SWAP_AB) {

            ulTmp = ulR;
            ulR   = ulG;
            ulG   = ulTmp;

        } else if (ulPrimaryOrder & COLOR_SWAP_AC) {

            ulTmp = ulR;
            ulR   = ulB;
            ulB   = ulTmp;
        }

        if (!bCreatePalette(PAL_BITFIELDS, 0, (PULONG)NULL,
                            ulR, ulG, ulB, PAL_FIXED|PAL_HT)) {

            return(FALSE);
        }
#if 0
    } else if (iFormatHT == HT_FORMAT_24BPP) {

    // 24BPP halftone always does BGR

        if (!bCreatePalette(PAL_BGR, 0, (PULONG)NULL,
                            0x0,0x0,0x0,PAL_FIXED|PAL_HT))
        {
            return(FALSE);
        }

    } else if (iFormatHT == HT_FORMAT_16BPP) {

    // 16BPP halftone always does 555 for red, green, and blue.

        if (!bCreatePalette(PAL_BITFIELDS, 0, (PULONG)NULL,
                            0x7c00,0x3e0,0x1f,PAL_FIXED|PAL_HT))
        {
            return(FALSE);
        }
#endif
    }
    else
    {
        ULONG   cEntries;
        BOOL    bAlloc = FALSE;
        PPALETTEENTRY   ppalentry;
        PALETTEENTRY    apalentry[8];

        switch(iFormatHT)
        {
        case HT_FORMAT_1BPP:
            cEntries = 2;
            ppalentry = &apalMono[0];
            if (pGdiInfo->flHTFlags & HT_FLAG_OUTPUT_CMY)
            {
                ppalentry = &apalentry[0];
                *((ULONG *)&apalentry[0]) = 0x0FFFFFF;
                *((ULONG *)&apalentry[1]) = 0;
            }
            break;

        case HT_FORMAT_4BPP_IRGB:
            cEntries = 16;
            ppalentry = &apalVGA[0];
            break;

        default:
            WARNING("unsupported halftone format, use default VGA format\n");
        case HT_FORMAT_4BPP:
        {
            cEntries = 8;
            ppalentry = &apalentry[0];
            RtlCopyMemory(apalentry, apal3BPP, sizeof(PALETTEENTRY) * 8);

            ULONG ulPrimaryOrder = pGdiInfo->ulPrimaryOrder;
            BYTE jTmp;
            int i;

            if (ulPrimaryOrder & COLOR_SWAP_BC)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Green and Blue entries.

                    jTmp = apalentry[i].peGreen;
                    apalentry[i].peGreen = apalentry[i].peBlue;
                    apalentry[i].peBlue = jTmp;
                }
            }

            if (ulPrimaryOrder & COLOR_SWAP_AB)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Red and Green.

                    jTmp = apalentry[i].peRed;
                    apalentry[i].peRed = apalentry[i].peGreen;
                    apalentry[i].peGreen = jTmp;
                }
            }
            else if (ulPrimaryOrder & COLOR_SWAP_AC)
            {
                for (i = 1; i < 7; i++)
                {
                // Swap Red and Blue entries.

                    jTmp = apalentry[i].peRed;
                    apalentry[i].peRed = apalentry[i].peBlue;
                    apalentry[i].peBlue = jTmp;
                }
            }

            if (pGdiInfo->flHTFlags & HT_FLAG_OUTPUT_CMY)
            {
            // Substrative device.

                for (int i = 0; i < 8; i++)
                    *((ULONG *)&apalentry[i]) ^= 0x0FFFFFF;
            }
        }
        break;

        case HT_FORMAT_8BPP:
        // Query the palette entries from Daniel's halftone library.
        // Query the number of entries on the first call.  Get the
        // color entries on the second.

            PCOLORINFO  pci = &pGdiInfo->ciDevice;

            cEntries = HT_Get8BPPMaskPalette((LPPALETTEENTRY)NULL,
                                             (BOOL)(pGdiInfo->flHTFlags &
                                                     HT_FLAG_USE_8BPP_BITMASK),
                                             (BYTE)((pGdiInfo->flHTFlags &
                                                     HT_FLAG_8BPP_CMY332_MASK)
                                                                >> 24),
                                             (UDECI4)pci->RedGamma,
                                             (UDECI4)pci->GreenGamma,
                                             (UDECI4)pci->BlueGamma);

            ppalentry = (PPALETTEENTRY)
                    PALLOCNOZ (sizeof(PALETTEENTRY) * cEntries, 'laPG');

            if (ppalentry == (PPALETTEENTRY)NULL)
                return(FALSE);

            if (pGdiInfo->flHTFlags & HT_FLAG_INVERT_8BPP_BITMASK_IDX) {

                HT_SET_BITMASKPAL2RGB(ppalentry);

            } else {

                ppalentry->peRed   =
                ppalentry->peGreen =
                ppalentry->peBlue  =
                ppalentry->peFlags = 0;
            }

            HT_Get8BPPMaskPalette(ppalentry,
                                  (BOOL)(pGdiInfo->flHTFlags &
                                         HT_FLAG_USE_8BPP_BITMASK),
                                  (BYTE)((pGdiInfo->flHTFlags &
                                          HT_FLAG_8BPP_CMY332_MASK) >> 24),
                                  (UDECI4)pci->RedGamma,
                                  (UDECI4)pci->GreenGamma,
                                  (UDECI4)pci->BlueGamma);

            bAlloc = TRUE;
            break;
        }

        if (!bCreatePalette(PAL_INDEXED, cEntries,
                            (PULONG)ppalentry,0,0,0,PAL_FREE|PAL_HT))
        {
            if (bAlloc)
                VFREEMEM(ppalentry);

            return(FALSE);
        }

        if (bAlloc)
        {
        // 8bpp case.  halftone palette is not the same as the device palette.

            VFREEMEM(ppalentry);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* PALMEMOBJ destructor
*
* destructor for palette memory objects
*
* History:
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PALMEMOBJ::~PALMEMOBJ()
{
    PVOID pvRemove;

    if (ppal != (PPALETTE) NULL)
    {
        if (bKeep)
        {
            DEC_SHARE_REF_CNT(ppal);
        }
        else
        {
            if (ppal != ppalColor())
            {
                //
                // Remove a reference to the palette who owns the color
                // table.
                //

                XEPALOBJ palColor(ppalColor());
                palColor.vUnrefPalette();
            }

            if (ppal->pRGBXlate != NULL)
            {
                if (ppal->pRGBXlate != gpRGBXlate)
                    VFREEMEM(ppal->pRGBXlate);

                ppal->pRGBXlate = NULL;
            }

            pvRemove = HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, TRUE, PAL_TYPE);
            ASSERTGDI(pvRemove != NULL, "Remove failed.  Havoc will result.");

            FREEOBJ(ppal,PAL_TYPE);
        }

        ppal = (PPALETTE) NULL;      // prevent ~PALOBJ from doing anything
    }
}

/******************************Public*Routine******************************\
* ulGetNearestFromPalentryNoExactMatchFirst
*
* Given a palette entry finds the index of the closest matching entry.
*
* History:
*  02-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
*
*  16-Jan-1993 -by- Michael Abrash [mikeab]
* Checked for exact match first.
\**************************************************************************/

ULONG XEPALOBJ::ulGetNearestFromPalentryNoExactMatchFirst(
    CONST PALETTEENTRY palentry)
{
    if (!bIsIndexed())
    {
        return(ulGetMatchFromPalentry(palentry));
    }

    //
    // We should only be called when there wouldn't be an exact match.
    // We don't need to check BGR, RGB, bitfields, or explicit
    // index, because those always produce an exact match.
    // We assume the palette is non-explicitly indexed at this point.
    //

    ASSERTGDI(bIsIndexed(),     "ERROR ulGetNearestFromPalentry not indexed");
    ASSERTGDI(cEntries() != 0,  "ERROR ulGetNearestFromPalentry cEntries is 0");

    PALETTEENTRY *ppalTemp, *ppalMax, *ppalBase;
    PALETTEENTRY *ppalBest;

    if (ppal == ppalDefault)
    {
        ppalTemp = &aPalDefaultVGA[0].pal;
    }
    else
    {
        ppalTemp = &ppal->apalColor[0].pal;
    }

    //
    // last palette entry.
    //

    ppalBase = ppalTemp;
    ppalMax  = ppalTemp + cEntries();

#if defined(_X86_)

    ULONG ulRed = palentry.peRed;
    ULONG ulGre = palentry.peGreen;
    ULONG ulBlu = palentry.peBlue;

_asm
{

   ;eax is a work buffer
    mov ebx, ulBlu
    mov ecx,ppalTemp
    mov edx,MAX_PAL_ERROR
    mov esi,ppalMax
   ;edi is used to accum ulErrTemp

    jmp Begin_Loop

align 16

Check_For_Done:

    add     ecx, 4
    cmp     ecx, esi
    jz      short Done

Begin_Loop:

    mov     edi, edx                // Put best error so far in
    movzx   eax, BYTE PTR [ecx+2]   // Get the blue byte from log pal
    sub     eax, ebx                // Subtract out the blue component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub the square of the
                                    // the red diff from the best so far
    jbe     short Check_For_Done    // If it's 0 or below jump to done
    movzx   eax, BYTE PTR [ecx+1]   // Get green byte from log pal
    sub     eax, ulGre              // Subtract out the green component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub the square of the
                                    // blue diff with the best so far.
    jbe     short Check_For_Done    // If it's 0 or below jump to done
    movzx   eax, BYTE PTR [ecx]     // Put red byte from log pal
    sub     eax, ulRed              // Subtract out red component
    sub     edi, DWORD PTR [aArrayOfSquares+1020+eax*4]  // Sub square of diff
    jbe     short Check_For_Done    // If it's 0 or below jump to done

// New_Best:

    mov     ppalBest, ecx       // Remember our best entry so far
    sub     edx,edi             // Subtract out what remains to
                                // get our new best error.
    jnz     Check_For_Done      // If it's 0 error we are done.

Done:
}

#else

#if defined(_MIPS_)

    ppalBest = ppalSearchNearestEntry(ppalTemp,
                                      palentry,
                                      cEntries(),
                                      pArrayOfSquares);

#else

    ULONG ulError;   // The least error for ppalBest
    ULONG ulErrTemp;
    ulError = MAX_PAL_ERROR;

    do
    {
        if ((ulErrTemp =
                     pArrayOfSquares[ppalTemp->peRed - palentry.peRed] +
                     pArrayOfSquares[ppalTemp->peGreen - palentry.peGreen] +
                     pArrayOfSquares[ppalTemp->peBlue - palentry.peBlue]) < ulError)
        {
            ppalBest = ppalTemp;

            if ((ulError = ulErrTemp) == 0)
            {
                break;
            }
        }

    } while (++ppalTemp < ppalMax);

#endif // #if defined(_MIPS_)
#endif // #if defined(_X86_)

    ASSERTGDI( ((ULONG)(ppalBest - ppalBase) < cEntries()), "index too big ulGetNearestFromPalentry");

    // Sundown safe truncation
    return (ULONG)(ppalBest - ppalBase);
}


/******************************Public*Routine******************************\
* ulIndexedGetMatchFromPalentry
*
* Given a PALETTEENTRY, finds the index of the matching entry in the
* specified palette, or returns 0xFFFFFFFF if there's no exact match.
*
* Note: This function does not use any semaphoring, nor does it expect the
* calling code to have done so. Palettes belong to DCs, and DCs are unique
* on a per-process basis; therefore, the only risk is that a multithreaded
* app acting on a palette-managed DC (because non-palette-managed palettes
* can never change) might have one thread change the palette while another
* thread is creating a brush or doing something similar that reads the
* palette. In that case, the app's in trouble anyway, because unless it
* does its own synchronization (and if it does, there's no issue here at all),
* then it can't be sure which palette will be in effect for the brush, and
* it would get indeterminate results even if we did protect the palette
* while we did this.
*
* History:
*  Sun 27-Dec-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL ulIndexedGetMatchFromPalentry(PALETTE* ppal, ULONG ulRGB)
{
    ULONG ulIndex;
    PAL_ULONG palentryTemp, *ppalTemp, *ppalMax;

    XEPALOBJ pal(ppal);

    //
    // make a copy we can access as a ULONG
    //

    palentryTemp.ul = ulRGB;

    ASSERTGDI(pal.cEntries() != 0, "ERROR ulGetNearestFromPalentry cEntries==0");

    if (palentryTemp.pal.peFlags == PC_EXPLICIT)
    {
        //
        // This is an explicit index, so we can just use it directly.
        // Explicit indices are limited to 8 bits, so mask off high three bytes,
        // then keep within the number of palette entries, if necessary
        //

        ulIndex = palentryTemp.ul & 0x000000FF;

        if (ulIndex >= pal.cEntries())
        {
            ulIndex = ulIndex % pal.cEntries();
        }

        return(ulIndex);
    }

    //
    // We only care about the RGB fields from now on
    //

    palentryTemp.ul &= 0x00FFFFFF;

    //
    // Scan through the palette until we either find an exact match or have
    // rejected all the palette entries
    //

    ppalTemp = pal.apalColorGet(); // point to the first palette entry
    ppalMax = ppalTemp + pal.cEntries();  // last palette entry

    while (ppalTemp != ppalMax)
    {
        //
        // Does the current palette entry match the color we're searching for?
        //

        if ((ppalTemp->ul & 0x00FFFFFF) == palentryTemp.ul)
        {
            //
            // Yes, we've found an exact match.
            //

            goto ExactMatch;
        }

        ppalTemp++;
    }

    //
    // We didn't find an exact match.
    //

    return(0xFFFFFFFF);

    //
    // We've found an exact match.
    //

ExactMatch:

    //Sundown safe truncation
    return(ULONG)(ppalTemp - pal.apalColorGet());
}

/******************************Public*Routine******************************\
* ulIndexedGetNearestFromPalentry
*
* For an indexed palette, finds the index of the matching entry in the
* specified palette by first doing an exact search, then doing a nearest
* search.
*
* Note that this routine isn't in-line because it is sometimes the target
* of indirect calls.
\**************************************************************************/

ULONG FASTCALL ulIndexedGetNearestFromPalentry(PALETTE* ppal, ULONG ulRGB)
{
    ULONG ul = ulIndexedGetMatchFromPalentry(ppal, ulRGB);
    if (ul == 0xffffffff)
    {
        XEPALOBJ pal(ppal);

        ul = pal.ulGetNearestFromPalentryNoExactMatchFirst(*((PALETTEENTRY*) &ulRGB));
    }
    return(ul);
}

/******************************Public*Routine******************************\
* ulRGBToBitfield
*
* Converts an RGB into an index for Bitfield palettes.
*
* History:
*  08-Nov-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL ulRGBToBitfield(PALETTE* ppal, ULONG ulRGB)
{
    XEPALOBJ pal(ppal);
    ASSERTGDI(pal.bIsBitfields(), "Error ulRGBToBitfield not bitfields");

    return((((ulRGB >> pal.cRedLeft()) << pal.cRedRight()) & pal.flRed()) |
           (((ulRGB >> pal.cGreLeft()) << pal.cGreRight()) & pal.flGre()) |
           (((ulRGB >> pal.cBluLeft()) << pal.cBluRight()) & pal.flBlu()));
}

/******************************Public*Routine******************************\
* ulRGBTo565
*
* Converts an RGB into an index for 5-6-5 bitfield palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBTo565(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI((((XEPALOBJ) ppal).bIsBitfields()) &&
              (((XEPALOBJ) ppal).flRed() == 0xf800) &&
              (((XEPALOBJ) ppal).flGre() == 0x07e0) &&
              (((XEPALOBJ) ppal).flBlu() == 0x001f), "Error not 5-6-5");

    return(((ulRGB >> 19) & 0x001f) |
           ((ulRGB >> 5)  & 0x07e0) |
           ((ulRGB << 8)  & 0xf800));
}

/******************************Public*Routine******************************\
* ulRGBTo555
*
* Converts an RGB into an index for 5-5-5 bitfield palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBTo555(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI((((XEPALOBJ) ppal).bIsBitfields()) &&
              (((XEPALOBJ) ppal).flRed() == 0x7c00) &&
              (((XEPALOBJ) ppal).flGre() == 0x03e0) &&
              (((XEPALOBJ) ppal).flBlu() == 0x001f), "Error not 5-5-5");

    return(((ulRGB >> 19) & 0x001f) |
           ((ulRGB >> 6)  & 0x03e0) |
           ((ulRGB << 7)  & 0x7c00));
}

/******************************Public*Routine******************************\
* ulRGBToBGR
*
* Converts an RGB into an index for BGR palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBToBGR(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI(((XEPALOBJ) ppal).bIsBGR(), "Error not BGR");

    return(((ulRGB & 0x0000ff) << 16) |
           ((ulRGB & 0x00ff00)) |
           ((ulRGB & 0xff0000) >> 16));
}

/******************************Public*Routine******************************\
* ulRGBToRGB
*
* Converts an RGB into an index for RGB palettes.
\**************************************************************************/

ULONG FASTCALL ulRGBToRGB(PALETTE* ppal, ULONG ulRGB)
{
    ASSERTGDI(((XEPALOBJ) ppal).bIsRGB(), "Error not RGB");

    return(ulRGB & 0xffffff);
}

/******************************Public*Routine******************************\
* ulRawToRaw
*
* No Converts, just pass through original data
\**************************************************************************/

ULONG FASTCALL ulRawToRaw(PALETTE* ppal, ULONG ulRGB)
{
    UNREFERENCED_PARAMETER(ppal);

    return(ulRGB);
}

/******************************Public*Routine******************************\
* vComputeCallTables
*
* Updates the pfnGetMatchFromPalentry and pfnGetNearestFromPalentry
* function pointers to reflect the current palette settings.
\**************************************************************************/

VOID XEPALOBJ::vComputeCallTables()
{
    PFN_GetFromPalentry pfnGetMatchFromPalentry;
    PFN_GetFromPalentry pfnGetNearestFromPalentry;

    if (bIsIndexed())
    {
        pfnGetMatchFromPalentry = ulIndexedGetMatchFromPalentry;
        pfnGetNearestFromPalentry = ulIndexedGetNearestFromPalentry;
    }
    else
    {
        if (bIsBitfields())
        {
            if ((flBlu() == 0x001f) &&
                (flGre() == 0x07e0) &&
                (flRed() == 0xf800))
            {
                pfnGetMatchFromPalentry = ulRGBTo565;
            }
            else if ((flBlu() == 0x001f) &&
                     (flGre() == 0x03e0) &&
                     (flRed() == 0x7c00))
            {
                pfnGetMatchFromPalentry = ulRGBTo555;
            }
            else
            {
                pfnGetMatchFromPalentry = ulRGBToBitfield;
            }
        }
        else if (bIsBGR())
        {
            pfnGetMatchFromPalentry = ulRGBToBGR;
        }
        else if (bIsCMYK())
        {
            //
            // In CMYK color case, Palette index == CMYK color data.
            //
            pfnGetMatchFromPalentry = ulRawToRaw;
        }
        else
        {
            ASSERTGDI(bIsRGB(), "ERROR invalid type in palette");
            pfnGetMatchFromPalentry = ulRGBToRGB;
        }

        //
        // For non-indexed palettes, an exact match can always be found,
        // so GetMatch and GetNearest can be the same function:
        //

        pfnGetNearestFromPalentry = pfnGetMatchFromPalentry;
    }

    ppal->pfnGetMatchFromPalentry = pfnGetMatchFromPalentry;
    ppal->pfnGetNearestFromPalentry = pfnGetNearestFromPalentry;
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulGetEntries
*
* This function copies the requested palette entries out.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" ULONG PALOBJ_cGetColors(
    PALOBJ *ppo,
    ULONG iStart,
    ULONG cEntry,
    ULONG *ppalentry
    )
{
    XEPALOBJ *ppal = (XEPALOBJ *)ppo;

    //
    // Get color data from PALOBJ
    //
    ULONG ulRet = ppal->ulGetEntries(iStart, cEntry, (PPALETTEENTRY)ppalentry,FALSE);

    //
    // Correct GammaRamp if nessesary.
    //
    if (ppal->bNeedGammaCorrection())
    {
        //
        // Correct color based on GammaRamp table
        //
        ppal->CorrectColors((PPALETTEENTRY)ppalentry,ulRet);
    }

    return (ulRet);
}

ULONG XEPALOBJ::ulGetEntries(ULONG iStart, ULONG cEntry,
                             PPALETTEENTRY ppalentry, BOOL bZeroFlags)
{
// See if the number of entries in the palette is being requested.

    if (ppalentry == (PPALETTEENTRY) NULL)
        return(ppal->cEntries);

// Make sure the start index is valid, this checks RGB case also.

    if (iStart >= ppal->cEntries)
        return(0);

// Make sure we don't ask for more than we have

    if (cEntry > (ppal->cEntries - iStart))
        cEntry = ppal->cEntries - iStart;

// Copy them to the buffer

    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &(ppal->apalColor[iStart]);

    RtlCopyMemory(ppalentry, ppalstruc, cEntry*sizeof(PALETTEENTRY));

    if (bZeroFlags)
    {
        ppalstruc = ppalentry + cEntry;
        while (ppalentry < ppalstruc)
        {
            ppalentry->peFlags = 0;
            ppalentry++;
        }
    }

    return(cEntry);
}

/******************************Public*Routine******************************\
* XEPALOBJ::ulSetEntries
*
* This function copies the requested palette entries into the palette
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulSetEntries(ULONG iStart, ULONG cEntry, CONST PALETTEENTRY *ppalentry)
{
    ASSERTGDI(bIsPalDC(), "ERROR: ulSetEntries called on non-DC palette");

// Make sure they aren't trying to change the default or halftone palette.
// Make sure they aren't trying to pass us NULL.
// Make sure the start index is valid, this checks the RGB case also.

    if ((ppal == ppalDefault)               ||
        bIsHTPal()                          ||
        (ppalentry == (PPALETTEENTRY) NULL) ||
        (iStart >= ppal->cEntries))
    {
        return(0);
    }

// Make sure we don't try to copy off the end of the buffer

    if (iStart + cEntry > ppal->cEntries)
        cEntry = ppal->cEntries - iStart;

// Let's not update the palette time if we don't have to.

    if (cEntry == 0)
        return(0);

// Copy the new values in

    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &(ppal->apalColor[iStart]);
    PBYTE pjFore     = NULL;
    PBYTE pjCurrent  = NULL;

// Mark the foreground translate dirty so we get a new realization done
// in the next RealizePaletette.

    if (ptransFore() != NULL)
    {
        ptransFore()->iUniq = 0;
        pjFore = &(ptransFore()->ajVector[iStart]);
    }

    if (ptransCurrent() != NULL)
    {
        ptransCurrent()->iUniq = 0;
        pjCurrent = &(ptransCurrent()->ajVector[iStart]);
    }

// Hold the orginal values in temporary vars.

    ULONG ulReturn = cEntry;

    while(cEntry--)
    {
        *ppalstruc = *ppalentry;

        if (pjFore)
        {
            *pjFore = 0;
            pjFore++;
        }

        if (pjCurrent)
        {
            *pjCurrent = 0;
            pjCurrent++;
        }

        ppalentry++;
        ppalstruc++;
    }

// Set in the new palette time.

    vUpdateTime();

// Mark foreground translate and current translate invalid so they get rerealized.

    return(ulReturn);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vUnrefPalette()
*
* Palettes are referenced when put into a surface.  If the reference count
* is one when vUnreference is called it mean the last surface using the
* palette is being deleted so the palette should be deleted.  Otherwise the
* reference count should just be decremented.
*
* History:
*  09-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vUnrefPalette()
{
    if (ppal != (PPALETTE) NULL)
    {
        ASSERTGDI(!bIsPalDC(), "ERROR should not be called on DC palette");

        if (HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, FALSE, PAL_TYPE))
        {
            if (bIsPalManaged() && ppalOriginal())
            {
                //
                // We have to delete the original palette.
                //

                PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                FREEOBJ(ppalOriginal(), PAL_TYPE);
            }

            if (ppal != ppalColor())
            {
                //
                // Remove a reference to the palette who owns the color
                // table.
                //

                XEPALOBJ palColor(ppalColor());
                palColor.vUnrefPalette();
            }

            if (ppal->pRGBXlate != NULL)
            {
                if (ppal->pRGBXlate != gpRGBXlate)
                    VFREEMEM(ppal->pRGBXlate);

                ppal->pRGBXlate = NULL;
            }

            ASSERTGDI(ppal != ppalMono, "ERROR mono palette went to 0");
            FREEOBJ(ppal, PAL_TYPE);
        }
        else
        {
            //
            // Just decrement the reference count.
            //

            DEC_SHARE_REF_CNT(ppal);
        }

        ppal = (PPALETTE) NULL;
    }
}

/******************************Public*Routine******************************\
* bDeletePalette
*
* This attempts to delete a palette.  It will fail if the palette
* is currently selected into more than one DC or is busy.
*
* History:
*  Wed 04-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Simplified and renamed.
*
*  27-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bDeletePalette(HPAL hpal, BOOL bCleanup, CLEANUPTYPE cutype)
{
    //
    // Need to grab the palette semaphore so this guy can't get selected in
    // anymore.  Only once we know he isn't selected anywhere and we hold the
    // semaphore so he can't be selected anywhere can we delete the translates.
    // This is because to access the translates you must either hold the palette
    // semaphore or have a lock on a DC that the palette is selected in.
    // Grab the semaphore so ResizePalette doesn't change the palette out from
    // under you.
    //

    SEMOBJ  semo(ghsemPalette);

    EPALOBJ palobj((HPALETTE)hpal);
    return(palobj.bDeletePalette(bCleanup,cutype));
}

/******************************Public*Routine******************************\
* XEPALOBJ::bDeletePalette()
*
* This attempts to delete a palette.  It will fail if the palette
* is currently selected into more than one DC or is busy.
*
* History:
*  27-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bDeletePalette(BOOL bCleanup, CLEANUPTYPE cutype)
{
    BOOL bReturn = TRUE;

    if ((ppal != ppalDefault) &&
        (ppal != (PPALETTE) NULL) &&
        (ppal != ppalMono))
    {
        if (ppal->pRGBXlate != NULL)
        {
            if (ppal->pRGBXlate != gpRGBXlate)
                VFREEMEM(ppal->pRGBXlate);

            ppal->pRGBXlate = NULL;
        }

        if (bIsPalDC())
        {
            if (ppal->cRefhpal != 0)
            {
                WARNING("bDelete failed palette is selected into a DC\n");
                return(FALSE);
            }

            vMakeNoXlate();
        }

        ASSERTGDI(HmgQueryLock((HOBJ)ppal->hGet()) == 0, "bDeletePalette cLock != 0");

        //
        // Need to make sure we are not being used in a palette API somewhere.
        //

        if (HmgRemoveObject((HOBJ)ppal->hGet(), 0, 1, FALSE, PAL_TYPE))
        {
            if (bIsPalManaged() && ppalOriginal())
            {
                //
                // We have to delete the original palette.
                //

                PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                FREEOBJ(ppalOriginal(), PAL_TYPE);
            }

            if (ppal != ppalColor())
            {
                //
                // Remove a reference to the palette who owns the color
                // table.
                //

                XEPALOBJ palColor(ppalColor());
                palColor.vUnrefPalette();
            }

            FREEOBJ(ppal, PAL_TYPE);
            ppal = (PPALETTE) NULL;
        }
        else
        {
            //
            // force deletion of palette at cleanup time
            //
            if (bCleanup)
            {
                WARNING ("DRIVER is leaking palette, we force cleanup here\n");

                if (cutype != CLEANUP_SESSION)
                {
                    //
                    // HmgFree will call FREEOBJ after the handle manager entry is freed
                    //
                    if (bIsPalManaged() && ppalOriginal())
                    {
                       //
                       // We have to delete the original palette.
                       //

                       PVOID ppalOld = HmgRemoveObject((HOBJ)ppalOriginal()->hGet(), 0, 0, FALSE, PAL_TYPE);

                       ASSERTGDI(ppalOld != NULL, "ERROR it failed to remove object handle");

                       FREEOBJ(ppalOriginal(), PAL_TYPE);
                    }


                    if (ppal != ppalColor())
                    {
                       //
                       // Remove a reference to the palette who owns the color
                       // table.
                       //

                       XEPALOBJ palColor(ppalColor());
                       palColor.vUnrefPalette();
                    }
                }

                HmgFree((HOBJ)ppal->hGet());

                ppal = (PPALETTE) NULL;

                bReturn = TRUE;
        }
        else
        {
         #if DBG
            DbgPrint("The count is %lu\n", HmgQueryLock((HOBJ)ppal->hGet()));
        #endif
            WARNING("App error, trying to delete palette that's in use\n");
            bReturn = FALSE;
        }
    }
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vCopy_rgbquad
*
* copies in rgbquad values, used by CreateDIBitmap
*
* History:
*  10-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vCopy_rgbquad(RGBQUAD *prgbquad, ULONG iStart, ULONG cEntries)
{
    ASSERTGDI(iStart < ppal->cEntries,"vCopy_rgbquad iStart > cEntries\n");
    PPALETTEENTRY ppalstruc = (PPALETTEENTRY) &ppal->apalColor[iStart];

    if (iStart + cEntries > ppal->cEntries)
        cEntries =  ppal->cEntries - iStart;

#if defined(_X86_)

_asm
{
    mov ecx, cEntries
    mov esi, prgbquad
    mov edi, ppalstruc
    shr ecx, 1
    jz Done_Unroll

Begin_Loop:
    mov eax, [esi]
    mov edx, [esi+4]
    bswap eax
    bswap edx
    shr eax, 8
    shr edx, 8
    mov [edi], eax
    mov [edi+4], edx
    add esi, 8
    add edi, 8
    dec ecx
    jnz Begin_Loop

Done_Unroll:
    test cEntries, 1
    jz Done

    mov eax, [esi]
    bswap eax
    shr eax, 8
    mov [edi], eax

Done:
}

#else

    while(cEntries--)
    {
        ppalstruc->peFlags = 0;
        ppalstruc->peBlue = prgbquad->rgbBlue;
        ppalstruc->peRed = prgbquad->rgbRed;
        ppalstruc->peGreen = prgbquad->rgbGreen;
        ppalstruc++;
        prgbquad++;
    }

#endif

    vUpdateTime();
}

/******************************Public*Routine******************************\
* XEPALOBJ::vCopy_cmykquad
*
* copies in cmykquad values, used by CreateDIBitmap
*
* History:
*  24-Mar-1997 -by- Hideyuki Nagase hideyukn
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vCopy_cmykquad(ULONG *pcmykquad, ULONG iStart, ULONG cEntries)
{
    ASSERTGDI(iStart < ppal->cEntries,"vCopy_cmykquad iStart > cEntries\n");
    PULONG ppalCMYK = (PULONG) &ppal->apalColor[iStart];

    if (iStart + cEntries > ppal->cEntries)
        cEntries =  ppal->cEntries - iStart;

    RtlCopyMemory(ppalCMYK,pcmykquad,cEntries*sizeof(ULONG));

    vUpdateTime();
}

/******************************Public*Routine******************************\
* BOOL XEPALOBJ::bSet_hdev
*
* Attempts to set the hdev owner of a DC palette.
*
* Returns: True if successful, False for failure.
*
* This operation must be protected by the palette semaphore.
*
* History:
*  08-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bSet_hdev(HDEV hdevNew)
{
    ASSERTGDI(ppal->flPal & PAL_DC, "bSet_() passed invalid palette type\n");
    ASSERTGDI(hdevNew != (HDEV) 0, "ERROR hdev is 0");

    if (hdev() != hdevNew)
    {
        if (ppal->cRefhpal == 0)
        {
        // It is not selected into a DC yet so it is safe to delete xlates
        // without holding the DEVLOCK for the device.  because no output
        // can be occuring now.

            vMakeNoXlate();
            hdev(hdevNew);
        }
        else
            return(FALSE);
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XEPALOBJ::bEqualEntries
*
*  Return TRUE if the given two palettes have same color entries.
*
* History:
*  04-Jun-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL XEPALOBJ::bEqualEntries(XEPALOBJ pal)
{
    if (!pal.bValid())
        return(FALSE);

    if (cEntries() == pal.cEntries())
    {
        if (flPal() & PAL_INDEXED)
        {
            if (!(pal.flPal() & PAL_INDEXED))
                return(FALSE);

            ULONG ulTemp, ulSource, ulDest;
            ULONG cComp = cEntries();

            for (ulTemp = 0; ulTemp < cComp; ulTemp++)
            {
                ulSource = apalColorGet()[ulTemp].ul;
                ulDest = pal.apalColorGet()[ulTemp].ul;

                if ((ulSource ^ ulDest) << 8)
                {
                    return(FALSE);
                }
            }

            return(TRUE);
        }
        else if (flPal() & PAL_BITFIELDS)
        {
            if (!(pal.flPal() & PAL_BITFIELDS))
                return(FALSE);

            return(!memcmp(apalColorGet(), pal.apalColorGet(),
                       sizeof(PALETTEENTRY) * 3));
        }
        else if (flPal() & PAL_RGB)
        {
            if (pal.flPal() & PAL_RGB)
                return(TRUE);
            else
                return(FALSE);
        }
        else if (flPal() & PAL_BGR)
        {
            if (pal.flPal() & PAL_BGR)
                return(TRUE);
            else
                return(FALSE);
        }
        else
            RIP("There is another type we didn't know about");
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* bInitPALOBJ
*
* Initialize the PALOBJ component
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitPALOBJ()
{
    INT iTemp;

    pArrayOfSquares = &(aArrayOfSquares[255]);

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        pArrayOfSquares[iTemp] =
        pArrayOfSquares[-(iTemp)] = iTemp * iTemp;
    }

    if ((ghsemPalette = GreCreateSemaphore()) == NULL)
        return(FALSE);

// Now initialize 20 color default DC palette

    if (!bSetStockObject(GreCreatePalette((LOGPALETTE *) &logDefaultPal),DEFAULT_PALETTE))
    {
        return(FALSE);
    }

    {
        EPALOBJ palDefault((HPALETTE) STOCKOBJ_PAL);
        ASSERTGDI(palDefault.bValid(), "ERROR invalid default palette");

        palDefault.vSetPID(OBJECT_OWNER_PUBLIC);
        ppalDefault = palDefault.ppalGet();
        dclevelDefault.hpal = STOCKOBJ_PAL;
        dclevelDefault.ppal = ppalDefault;

    // Now initialize default surface palette for 8bpp displays

        PALMEMOBJ palDefaultSurface8bpp;
        if (!palDefaultSurface8bpp.bCreatePalette(PAL_INDEXED,
                                                  256,
                                                  NULL,
                                                  0,
                                                  0,
                                                  0,
                                                  PAL_FREE))
        {
            return(FALSE);
        }

        ppalDefaultSurface8bpp = palDefaultSurface8bpp.ppalGet();

    // Copy the 20 default colours.  The middle entries will be black

        PALETTEENTRY palEntry;
        ULONG ulReturn;
        ULONG ulNumReserved = palDefault.cEntries() >> 1;

        for (ulReturn = 0; ulReturn < ulNumReserved; ulReturn++)
        {
            palEntry = palDefault.palentryGet(ulReturn);
            palDefaultSurface8bpp.palentrySet(ulReturn, palEntry);
        }

        ULONG ulCurrentPal = 256;
        ULONG ulCurrentDef = 20;

        for (ulReturn = 0; ulReturn < ulNumReserved; ulReturn++)
        {
            ulCurrentPal--;
            ulCurrentDef--;

            palEntry = palDefault.palentryGet(ulCurrentDef);
            palDefaultSurface8bpp.palentrySet(ulCurrentPal, palEntry);
        }

    // Leave a reference count of 1 so that it never gets deleted

        palDefaultSurface8bpp.ppalSet(NULL);
    }

// Now initialize default monochrome surface palette.

    PALMEMOBJ palMono;

    if (!palMono.bCreatePalette(PAL_INDEXED, 2, gaulMono,
                           0, 0, 0, PAL_FIXED | PAL_MONOCHROME))
    {
        WARNING("GDI failed mono palette create\n");
        return(FALSE);
    }

    palMono.vKeepIt();
    hpalMono = palMono.hpal();
    ppalMono = palMono.ppalGet();

    //
    // Now initialize default RGB palette for gradient fill source
    //

    PALMEMOBJ palRGB;

    if (!palRGB.bCreatePalette(
                                PAL_BGR,
                                0,
                                NULL,
                                0,
                                0,
                                0,
                                PAL_FIXED))
    {
        WARNING("GDI failed RGB palette create\n");
        return(FALSE);
    }

    gppalRGB = palRGB.ppalGet();

    // Leave a reference count of 1 so that it never gets deleted

    palRGB.ppalSet(NULL);


    return(TRUE);
}

/******************************Public*Routine******************************\
* ULONG XEPALOBJ::ulAnimatePalette
*
* This function changes the requested palette entries in the palette.
*
* History:
*  16-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XEPALOBJ::ulAnimatePalette(ULONG iStart, ULONG cEntry, CONST PALETTEENTRY *ppalSrc)
{
    ASSERTGDI(bIsPalDC(), "ERROR this is not a DC palette");

// Make sure they aren't trying to change the default palette.
// Make sure they aren't trying to pass us NULL.
// Make sure the start index is valid, this checks the RGB case also.

    if ((ppal == ppalDefault)               ||
        (ppalSrc == (PPALETTEENTRY) NULL) ||
        (iStart >= ppal->cEntries))
    {
        return(0);
    }

// Make sure we don't try to copy off the end of the buffer

    if (iStart + cEntry > ppal->cEntries)
        cEntry = ppal->cEntries - iStart;

// Let's not update the palette if we don't have to.

    if (cEntry == 0)
        return(0);

// Save the Original values

    ULONG ulReturn = 0;
    ULONG ulTemp = cEntry;

// Copy the new values in

    PAL_ULONG *ppalLogical = (PAL_ULONG *) &(ppal->apalColor[iStart]);
    PAL_ULONG palentry, palPhys;
    TRANSLATE *ptransCurrent = NULL;
    PBYTE pjCurrent = NULL;
    XEPALOBJ palSurf;

// Grab the SEMOBJ so you can access the translates, and can look at cEntries.
{
    SEMOBJ  semo(ghsemPalette);

    if (cRefhpal())
    {
        PDEVOBJ po(hdev());
        ASSERTGDI(po.bValid(), "ERROR invalid pdev");

        if (po.bIsPalManaged())
        {
            palSurf.ppalSet(po.ppalSurf());
            ASSERTGDI(palSurf.bValid(), "ERROR GDI ulAnimatePalette dc");
            ASSERTGDI(palSurf.bIsPalManaged(), "ERROR pdev palmanaged but not palette ???");

            if (ppal->ptransCurrent != NULL)
            {
                ptransCurrent = ppal->ptransCurrent;
                pjCurrent = &(ppal->ptransCurrent->ajVector[iStart]);
            }
        }
    }

    while(ulTemp--)
    {
        palentry.pal = *ppalSrc;

        if (ppalLogical->pal.peFlags & PC_RESERVED)
        {
            ppalLogical->ul = palentry.ul;
            ulReturn++;

            if (pjCurrent != NULL)
            {
                palPhys.ul = palSurf.ulEntryGet((ULONG) *pjCurrent);

                if (palPhys.pal.peFlags & PC_RESERVED)
                {
                    palentry.pal.peFlags = palPhys.pal.peFlags;
                    palSurf.ulEntrySet(*pjCurrent, palentry.ul);
                }
            }
        }
        if (pjCurrent != NULL)
            pjCurrent++;

        ppalSrc++;
        ppalLogical++;
    }

// Release the palette semaphore, we are done accessing protected stuff.
}

// Don't set in a new time, Animate doesn't do that.

    if (pjCurrent)
    {
        PDEVOBJ po(hdev());

    // Lock the screen semaphore so that we don't get flipped into
    // full screen after checking the bit.

        GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
        GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    // Make sure we're still a palettized device -- a dynamic mode change
    // may have occured between the time we released the palette semaphore
    // and acquired the devlock.

        if (po.bIsPalManaged())
        {
            SEMOBJ so(po.hsemPointer());

            if (!po.bDisabled())
            {
                po.pfnSetPalette()(
                    po.dhpdevParent(),
                    (PALOBJ *) &palSurf,
                    0,
                    0,
                    palSurf.cEntries());
            }
        }

        GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
        GreReleaseSemaphoreEx(po.hsemDevLock());
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* VOID XEPALOBJ::vMakeNoXlate()
*
* deletes the pxlate if it exists
*
* History:
*  19-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vMakeNoXlate()
{
    ASSERTGDI(bIsPalDC(), "ERROR trying to delete pxlate from non-dc palette");

// Caller should grab the DEVLOCK to ensure the engine
// isn't in the middle of blt before calling.

    if (ppal->ptransOld)
    {
        if (ppal->ptransOld != ppal->ptransFore)
            VFREEMEM(ppal->ptransOld);

        ppal->ptransOld = NULL;
    }

    if (ppal->ptransCurrent)
    {
        if (ppal->ptransCurrent != ppal->ptransFore)
            VFREEMEM(ppal->ptransCurrent);

        ppal->ptransCurrent = NULL;
    }

    if (ppal->ptransFore)
    {
        VFREEMEM(ppal->ptransFore);

        ppal->ptransFore = NULL;
    }
}

/******************************Public*Routine******************************\
* vAddToList
*
* Add DC to linked list of DC's attached to palette.  The MLOCKOBJ must be
* grabbed before calling this function.
*
* History:
*  16-Dec-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vAddToList(XDCOBJ& dco)
{
    ASSERTGDI(dco.bLocked(), "ERROR 14939");
    ASSERTGDI(bValid(), "ERROR dj945kd");
    ASSERTGDI(bIsPalDC(), "ERROR 234343");

    if (!bIsPalDefault())
    {
    // Well it's a new live hpal.  Add the DC to it's linked list
    // and inc it's cRef count.

        vInc_cRef();
        dco.pdc->hdcNext(hdcHead());
        hdcHead(dco.hdc());
        dco.pdc->hdcPrev((HDC) 0);

        if (dco.pdc->hdcNext() != (HDC) 0)
        {
            MDCOBJA dcoNext(dco.pdc->hdcNext());
            dcoNext.pdc->hdcPrev(dco.hdc());
        }
    }
    else
    {
        dco.pdc->hdcNext((HDC) 0);
        dco.pdc->hdcPrev((HDC) 0);
    }
}

/******************************Public*Routine******************************\
* vRemoveFromList
*
* Remove DC from linked list of DC's.  MLOCKOBJ must be grabbed before call.
*
* History:
*  16-Dec-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vRemoveFromList(XDCOBJ& dco)
{
    ASSERTGDI(dco.bLocked(), "ERROR 1");
    ASSERTGDI(bIsPalDC(), "ERROR 2");

// Take care of the old hpal.  Remove from linked list.  Decrement cRef.
// Remove the hdc from the linked list of DC's associated with palette.

    if (!bIsPalDefault())
    {
    // Remove this DC from the linked list.

        if (dco.pdc->hdcNext() != (HDC) 0)
        {
            MDCOBJA dcoNext(dco.pdc->hdcNext());
            dcoNext.pdc->hdcPrev(dco.pdc->hdcPrev());
        }

        if (dco.pdc->hdcPrev() == (HDC) 0)
        {
        // New head of hdc list for hpal

            hdcHead(dco.pdc->hdcNext());
        }
        else
        {
            MDCOBJA dcoPrev(dco.pdc->hdcPrev());
            dcoPrev.pdc->hdcNext(dco.pdc->hdcNext());
        }

    // Decrement the reference count correctly.

        vDec_cRef();
    }

    dco.pdc->hdcPrev((HDC) 0);
    dco.pdc->hdcNext((HDC) 0);
}

/******************************Public*Routine******************************\
* vFill_triples
*
* For GetDIBits we need to copy a palette out to triples.
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vFill_triples(
RGBTRIPLE *prgb,        // array of quads to fill
ULONG iStart,           // first index in palette to copy out
ULONG cEntry)           // max # of entries to copy out
{
    PALETTEENTRY palentry;
    RGBTRIPLE rgbtrip;
    cEntry = MIN((iStart + cEntry), cEntries());

    ASSERTGDI(cEntries() != 0, "ERROR cEntries");
    ASSERTGDI(!bIsBitfields(), "ERROR bIsBitfields");
    ASSERTGDI(!bIsRGB(), "ERROR bIsRGB");
    ASSERTGDI(!bIsBGR(), "ERROR bIsBGR");

    while (iStart < cEntry)
    {
        palentry = palentryGet(iStart);
        rgbtrip.rgbtRed = palentry.peRed;
        rgbtrip.rgbtBlue = palentry.peBlue;
        rgbtrip.rgbtGreen = palentry.peGreen;
        *prgb++ = rgbtrip;
        iStart++;
    }
}

/******************************Public*Routine******************************\
* vFill_rgbquads
*
* For GetDIBits we need to copy a palette out to rgbquads
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vFill_rgbquads(
RGBQUAD *prgb,          // array of quads to fill
ULONG iStart,           // first index in palette to copy out
ULONG cEntry)           // max # of entries to copy out
{
    if (bIsBGR())
    {
        ((PDWORD) prgb)[0] = 0x00FF0000;
        ((PDWORD) prgb)[1] = 0x0000FF00;
        ((PDWORD) prgb)[2] = 0x000000FF;
    }
    else if (bIsBitfields() && cEntry == 3)
    {
        ((PDWORD) prgb)[0] = flRed();
        ((PDWORD) prgb)[1] = flGre();
        ((PDWORD) prgb)[2] = flBlu();
    }
    else if (bIsRGB())
    {
        ((PDWORD) prgb)[0] = 0x000000FF;
        ((PDWORD) prgb)[1] = 0x0000FF00;
        ((PDWORD) prgb)[2] = 0x00FF0000;
    }
    else
    {
        PALETTEENTRY palentry;
        RGBQUAD  rgbquad;
        cEntry = MIN((iStart + cEntry), cEntries());

        while (iStart < cEntry)
        {
            palentry = palentryGet(iStart);
            rgbquad.rgbRed = palentry.peRed;
            rgbquad.rgbBlue = palentry.peBlue;
            rgbquad.rgbGreen = palentry.peGreen;
            rgbquad.rgbReserved = 0;
            *prgb++ = rgbquad;
            iStart++;
        }
    }
}

/******************************Public*Routine******************************\
* vGetEntriesFrom
*
* This is for the DIB_PAL_COLORS case of CreateDIBitmap.
* This uses the array of ushorts in bmiColors and the DC palette to
* initialize the surface palette.  You need to create a palette that
* represents the essence of a DC palette.  That means if DC palette
* has a PC_EXPLICIT in it, reach down into the surface palette for the
* palette entry.
*
* History:
*  Thu 03-Feb-1994 -by- Patrick Haluptzok [patrickh]
* Chicago compatability, grab the colors out of the VGA palette if the
* system palette is not available.
*
*  09-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vGetEntriesFrom(XEPALOBJ palDC, XEPALOBJ palSurf, PUSHORT pusIndices, ULONG cEntry)
{
    //
    // We assume if the palette was invalid (which indicates it was a compatible
    // bitmap on a palette managed device) then the caller has passed the
    // PDEV surface palette instead which is valid.
    //

    ASSERTGDI(palDC.bValid(), "ERROR palDC not valid");
    ASSERTGDI(palSurf.bValid(), "ERROR palSurf not valid");
    ASSERTGDI(palDC.cEntries() != 0, "ERROR 0 entry palDC");
    ASSERTGDI(cEntry <= cEntries(), "ERROR bGetEntriesFrom cEntry too big");

    PAL_ULONG palentry;
    ULONG cEntryDC;
    ULONG cEntrySurf;

    cEntryDC = palDC.cEntries();

    //
    // We need the PDEV palette for the screen if this is a compatible
    // bitmap on a palette managed device which is indicated by have a
    // NULL ppalSurf.
    //

    cEntrySurf = palSurf.bIsPalManaged() ? palSurf.cEntries() : 0;

    while (cEntry--)
    {
        palentry.ul = (ULONG) pusIndices[cEntry];

        if (palentry.ul >= cEntryDC)
            palentry.ul = palentry.ul % cEntryDC;

        palentry.pal = palDC.palentryGet(palentry.ul);

        if (palentry.pal.peFlags == PC_EXPLICIT)
        {
            if (cEntrySurf)
            {
            // Grab the RGB out of the system palette.

                palentry.ul = palentry.ul & 0x0000FFFF;

                if (palentry.ul >= cEntrySurf)
                    palentry.ul = palentry.ul % cEntrySurf;

                palentry.pal = palSurf.palentryGet(palentry.ul);
            }
            else
            {
            // Get color entries from the VGA palette.  This
            // is Chicago compatible.

                palentry.ul = palentry.ul & 0x0000F;
                palentry.pal = apalVGA[palentry.ul];
            }
        }

        //
        // Always 0 out the flags.
        //

        palentry.pal.peFlags = 0;
        palentrySet(cEntry, palentry.pal);
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInitMono
*
* This initializes a monochrome palette.
*
* History:
*  24-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInitMono()
{
    PAL_ULONG palentry;

    palentry.ul = 0;
    palentrySet(0, palentry.pal);

    palentry.ul = 0x00FFFFFF;
    palentrySet(1, palentry.pal);
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInitVGA
*
* This initializes a 16 color palette to be just like the VGA.
*
* History:
*  Wed 02-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Re-did to be Win3.0 compatible.
*
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInitVGA()
{
    ULONG ulIndex;

    for (ulIndex = 0; ulIndex < 16; ulIndex++)
    {
        palentrySet(ulIndex, aPalVGA[ulIndex].pal);
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::vInit256Rainbow
*
* This initializes a 256 color palette with the default colors at the ends
* and a rainbow in the middle.
*
* History:
*  22-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInit256Rainbow()
{
    ULONG ulIndex;
    PAL_ULONG palentry;
    PBYTE gTmp;

// Generate 256 (= 8*8*4) RGB combinations to fill
// in the palette.

    BYTE red, green, blue;
    red = green = blue = 0;

    for (ulIndex = 0; ulIndex < 256; ulIndex++)
    {
        palentry.pal.peRed = red;
        palentry.pal.peGreen = green;
        palentry.pal.peBlue = blue;
        palentry.pal.peFlags = 0;
        palentrySet(ulIndex, palentry.pal);

        if (!(red += 32))
        if (!(green += 32))
        blue += 64;
    }

    vInit256Default();

    if (gpRGBXlate == NULL)
    {
        gTmp = (PBYTE)PALLOCNOZ(32768,'bgrG');

        if (gTmp)
        {
           //
           // use InterlockedCompareExchangePointer to set
           // gpRGBXlate, so that another thread won't
           // try to do this at the same time
           //

           MakeITable(gTmp,(RGBX *)ppal->apalColor,256);

           if (InterlockedCompareExchangePointer((PVOID *)&gpRGBXlate,
                                             gTmp,
                                             NULL) != NULL)

           {
               //
               // if we failed the InterlockedCompareExchangePointer,
               // it means gpRGBXlate is already set by another thread
               // free the temp buffer here
               //

               if (gTmp)
               {
                  VFREEMEM(gTmp);
               }
           }
        }
        else
        {
           WARNING("Failed to allocate memory in  XEPALOBJ::vInit256Rainbow\n");

           // set this to NULL to be safe

           ppal->pRGBXlate = NULL;
           return;
        }
    }

    ppal->ulRGBTime = ulTime();

    ASSERTGDI(gpRGBXlate, "gpRGBXlate == NULL!\n");
    ppal->pRGBXlate = gpRGBXlate;

}

/******************************Public*Routine******************************\
* XEPALOBJ::vInit256Default
*
* Initialize 256 color palette with the default colors.
*
* History:
*  02-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XEPALOBJ::vInit256Default()
{
// Fill in 20 reserved colors at beginning and end.

    UINT uiIndex;

    for (uiIndex = 0; uiIndex < 10; uiIndex++)
    {
        palentrySet(uiIndex, logDefaultPal.palPalEntry[uiIndex]);
        palentrySet((ULONG)(255 - uiIndex), logDefaultPal.palPalEntry[19 - uiIndex]);
    }
}


/**************************************************************************\
* XEPALOBJ::pGetRGBXlate
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/19/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PRGB555XLATE
XEPALOBJ::pGetRGBXlate()
{
    //
    // palette semaphore?
    //

    PRGB555XLATE prgb555 = NULL;

    if (ppal != NULL)
    {
        prgb555 = ppal->pRGBXlate;

        if (
             (prgb555 == NULL) ||
             (ppal->ulRGBTime != ulTime())
           )
        {
            if (bGenColorXlate555())
            {
                prgb555 = ppal->pRGBXlate;
            }
            else
            {
                prgb555 = NULL;
            }
        }
    }
    else
    {
        WARNING("XEPALOBJ::pGetRGBXlate called with NULL ppal\n");
    }

    return(prgb555);
}




/**************************************************************************\
* XEPALOBJ::bGenColorXlate555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/
BOOL
XEPALOBJ::bGenColorXlate555()
{
    BOOL bRet = FALSE;

    //
    // allocate rgb555 xlate table if needed
    //
    if ((ppal->pRGBXlate == NULL) || (ppal->pRGBXlate == gpRGBXlate))
    {
        ppal->pRGBXlate = (PRGB555XLATE)PALLOCNOZ(32768,'bgrG');
    }

    if (ppal->pRGBXlate)
    {
        MakeITable((PIMAP)ppal->pRGBXlate,(RGBX *)apalColorGet(),cEntries());
        bRet = TRUE;
        ppal->ulRGBTime = ulTime();
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorMatch
*
* Direct from Win3.1 to you.  This function returns the best index to use
* when realizing a palette.  It also returns the error incurred with using
* that index.
*
* Converted from Win3.1 colormat.asm - the ColorMatch function
*
* The only difference is we return a 32-bit error difference, and a 32-bit
* index.  They compress both into 16-bit ax,dx.
*
* History:
*  11-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG ColorMatch(XEPALOBJ palSurf, PAL_ULONG palRGB, ULONG *pulError)
{
    if (palRGB.pal.peFlags & PC_EXPLICIT)
    {
    // Return the low word index.

        palRGB.ul &= 0x0000FFFF;

    // This is an error case Win3.1 does not test for, but we do.

        if (palRGB.ul >= palSurf.cEntries())
        {
            palRGB.ul = 0;
        }

        *pulError = 0;
        return(palRGB.ul);
    }

    if (palRGB.pal.peFlags & PC_RESERVED)
    {
        *pulError = 0x0FFFFFFF;
        return(0);
    }

    ULONG ulTemp, ulError, ulBestIndex, ulBestError;
    PAL_ULONG palTemp;

    ulBestIndex = 0;
    ulBestError = 0x0FFFFFFF;

    for (ulTemp = 0; ulTemp < palSurf.cEntries(); ulTemp++)
    {
        palTemp.ul = palSurf.ulEntryGet(ulTemp);

        if (palTemp.pal.peFlags & PC_USED)
        {
            if (!(palTemp.pal.peFlags & PC_RESERVED))
            {
                ulError = RGB_ERROR(palTemp.pal, palRGB.pal);

                if (ulError < ulBestError)
                {
                    ulBestIndex = ulTemp;
                    ulBestError = ulError;
                }

                if (ulBestError == 0)
                    break;
            }
        }
    }

    if (palRGB.pal.peFlags & PC_NOCOLLAPSE)
    {
    // He doesn't really want to match, so give it a big error.

        *pulError = 0x0FFFFFFF;
    }
    else
        *pulError = ulBestError;

    return(ulBestIndex);
}

/******************************Public*Routine******************************\
* ptransMatchAPal
*
* Direct from Win3.1 to you.  Builds a foreground translate just like Windows
* does.
*
* History:
*  12-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PTRANSLATE
ptransMatchAPal(
    PDC      pdc,
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    BOOL     bForeground,
    ULONG   *pulnPhysChanged,
    ULONG   *pulnTransChanged
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid DC pal");
    ASSERTGDI(palSurf.bValid(), "ERROR invalid Surface pal");
    ASSERTGDI(!palDC.bIsPalDefault(), "ERROR ptransMapIn default palette");
    ASSERTGDI(palSurf.cEntries() == 256, "Error: dinky palette in");
    ASSERTGDI(palDC.bIsPalDC(), "Error: palDC is not a DC");
    ASSERTGDI(*pulnPhysChanged == 0, "ERROR 1349456 ptransMapIn");
    ASSERTGDI(*pulnTransChanged == 0, "ERROR not 0");

    //
    // Determine how many entries are reserved
    //

    ULONG ulReserved;

    if (palSurf.bIsNoStatic())
    {
        ulReserved = 1;
    }
    else if (palSurf.bIsNoStatic256())
    {
        ulReserved = 0;
    }
    else
    {
        ulReserved = palSurf.ulNumReserved() >> 1;
    }

    ULONG ulStartFill = ulReserved;
    ULONG ulMaxInsert = 256 - ulReserved;
    PAL_ULONG palLog, palPhys;
    ULONG ulTemp;
    ULONG iInsertIndex, iLogPal;
    ULONG nPhysChanged = 0;
    ULONG nTransChanged = 0;

    //
    // We allocate the vector that converts logical palette indices to physical
    // palette indices.  Note we subtract out the extra ULONG at compile time
    // rather than run-time.
    //

    PTRANSLATE pTrans = (PTRANSLATE)
            PALLOCNOZ((sizeof(TRANSLATE) - sizeof(BYTE)) +
                       (palDC.cEntries() * sizeof(BYTE)), 'laPG');

    if (pTrans == NULL)
    {
        WARNING("Allocation for pTransMapIn failed\n");
        return(NULL);
    }

    nTransChanged = palDC.cEntries();

    if (bForeground)
    {
        //
        // This is a foreground realize. Clear all PC_FOREGROUND and PC_RESERVED
        // flags in the non-reserved entries of the surface palette.
        //

        //
        // Update the time because we are removing foreground entries.
        //

        palSurf.vUpdateTime();

        //
        // match_fore_pal:
        //

        for (ulTemp = ulReserved; ulTemp < ulMaxInsert; ulTemp++)
        {
            palPhys.ul = palSurf.ulEntryGet(ulTemp);
            
            // WINBUG #2621 5-4-2000 bhouse Foreground realization does not match Win9X

            // We now clear PC_USED thus allowing us to match Win9X palette realization
            // behavior.  Note, we really should not clear PC_USED if we are in a WOW
            // thread but have decided it is not necessary to maintain WOW compat.

            palPhys.pal.peFlags &= (~(PC_FOREGROUND | PC_RESERVED | PC_USED));
            palSurf.ulEntrySet(ulTemp, palPhys.ul);
        }
    }

    BYTE fNotOverwritable = PC_FOREGROUND | PC_USED;

    //
    // match_back_loop:
    //

    for (iLogPal = 0; iLogPal < palDC.cEntries(); iLogPal++)
    {
        palLog.ul = palDC.ulEntryGet(iLogPal);

        iInsertIndex = ColorMatch(palSurf, palLog, &ulTemp);

        if (ulTemp == 0)
        {
            //
            // Awesome, nothing to change.
            //

            if (!(palLog.pal.peFlags & PC_EXPLICIT))
            {
                //
                // Mark it used if not PC_EXPLICIT log pal entry.
                //

                palPhys.ul = palSurf.ulEntryGet(iInsertIndex);
                palPhys.pal.peFlags |= (PC_USED | PC_FOREGROUND);
                palSurf.ulEntrySet(iInsertIndex, palPhys.ul);
            }
        }
        else
        {
            //
            // imperfect_match:
            //

            if (ulStartFill || palSurf.bIsNoStatic256())
            {
                //
                // There is room to jam in an entry.
                //
                //  look_for_overwrite:
                //

look_for_overwriteable_loop:

                for (ulTemp = ulStartFill; ulTemp < ulMaxInsert; ulTemp++)
                {
                    palPhys.ul = palSurf.ulEntryGet(ulTemp);

                    if (!(palPhys.pal.peFlags & fNotOverwritable))
                    {
                        //
                        // replace_opening:
                        //

                        iInsertIndex = ulStartFill = ulTemp;  // New start point for search.
                        palLog.pal.peFlags |= (PC_USED | PC_FOREGROUND);
                        palSurf.ulEntrySet(ulTemp, palLog.ul);
                        nPhysChanged++;
                        goto entry_back_matched;
                    }
                }

                if (fNotOverwritable & PC_USED)
                {
                    //
                    // Can't be so picky, kick out used entries.
                    //

                    fNotOverwritable &= (~PC_USED);
                    ulStartFill = ulReserved;
                    goto look_for_overwriteable_loop;
                }
                else
                {
                    //
                    // all_filled_for_back:
                    //

                    ulStartFill = 0;
                }
            }
        }

entry_back_matched:

        pTrans->ajVector[iLogPal] = (BYTE) iInsertIndex;
    }

    //
    // finished_back_match
    //

    palDC.vUpdateTime();
    pTrans->iUniq = palSurf.ulTime();
    *pulnPhysChanged = nPhysChanged;
    *pulnTransChanged = nTransChanged;
    return(pTrans);
}

/******************************Public*Routine******************************\
* vMatchAPal
*
* This maps the foreground realization into the palette.
*
* History:
*  23-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
vMatchAPal(
    PDC      pdc,
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG   *pulnPhysChanged,
    ULONG   *pulnTransChanged
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid DC pal");
    ASSERTGDI(palSurf.bValid(), "ERROR invalid Surface pal");
    ASSERTGDI(!palDC.bIsPalDefault(), "ERROR ptransMapIn default palette");
    ASSERTGDI(palSurf.cEntries() == 256, "Error: dinky palette in");
    ASSERTGDI(palDC.bIsPalDC(), "Error: palDC is not a DC");
    ASSERTGDI(*pulnPhysChanged == 0, "ERROR 1349456 ptransMapIn");
    ASSERTGDI(*pulnTransChanged == 0, "ERROR not 0");

    //
    // Determine how many entries are reserved
    //

    ULONG ulReserved;

    if (palSurf.bIsNoStatic())
    {
        ulReserved = 1;
    }
    else if (palSurf.bIsNoStatic256())
    {
        ulReserved = 0;
    }
    else
    {
        ulReserved = palSurf.ulNumReserved() >> 1;
    }

    ULONG ulMaxInsert = 256 - ulReserved;
    PAL_ULONG palLog, palPhys;
    ULONG iLogPal;
    ULONG nPhysChanged = 0;
    ULONG nTransChanged = 0;

    PTRANSLATE pTransFore = palDC.ptransFore();
    PTRANSLATE pTransCur  = palDC.ptransCurrent();

    ASSERTGDI(pTransFore != NULL, "ERROR this NULL");

    //
    // un_use_palette_loop: Remove all foreground and reserved flags.
    //

    for (iLogPal = ulReserved; iLogPal < ulMaxInsert; iLogPal++)
    {
        palPhys.ul = palSurf.ulEntryGet(iLogPal);

        palPhys.pal.peFlags &= (~(PC_FOREGROUND | PC_RESERVED));
        palSurf.ulEntrySet(iLogPal, palPhys.ul);
    }

    for (iLogPal = 0; iLogPal < palDC.cEntries(); iLogPal++)
    {
        //
        // slam_foreground_palette_loop
        //

        if ((pTransCur == NULL) ||
            (pTransCur->ajVector[iLogPal] != pTransFore->ajVector[iLogPal]))
        {
            nTransChanged++;
        }

        //
        // fore_no_trans_change:
        //

        palPhys.ul = palSurf.ulEntryGet(pTransFore->ajVector[iLogPal]);

        if (!(palPhys.pal.peFlags & PC_FOREGROUND))
        {
            //
            // Index is not foreground, we have to at least mark it.
            //

            palLog.ul = palDC.ulEntryGet(iLogPal);

            if (!(palLog.pal.peFlags & PC_EXPLICIT))
            {
                //
                // Not explicit, we better make sure it's the same entry.
                //

                if ((palLog.pal.peRed   != palPhys.pal.peRed)   ||
                    (palLog.pal.peGreen != palPhys.pal.peGreen) ||
                    (palLog.pal.peBlue  != palPhys.pal.peBlue)  ||
                    ((palLog.pal.peFlags & PC_RESERVED) != (palPhys.pal.peFlags & PC_RESERVED)))
                {
                    //
                    // Not the same as logical palette, stick it in the palette.
                    //

                    palLog.pal.peFlags &= PC_RESERVED;
                    palPhys.ul = palLog.ul;
                    nPhysChanged++;
                }
            }

            //
            // fore_entry_slammed
            //

            palPhys.pal.peFlags |= (PC_FOREGROUND | PC_USED);

            palSurf.ulEntrySet((ULONG) pTransFore->ajVector[iLogPal], palPhys.ul);
        }
    }

    //
    // Increment the palette's time, we changed removed the foreground flags.
    //

    palSurf.vUpdateTime();
    palDC.vUpdateTime();
    pTransFore->iUniq = palSurf.ulTime();
    *pulnPhysChanged = nPhysChanged;
    *pulnTransChanged = nTransChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pathclip.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathclip.cxx
*
* This module handles the reading of the path for the line-clipping
* component (which resides mostly in clipline.cxx).
*
* Created: 02-Apr-1991 08:45:30
* Author: Eric Kutter [erick]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* PATHOBJ_vEnumStartClipLines
*
*   Engine helper function.
*
* History:
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID PATHOBJ_vEnumStartClipLines(
     PATHOBJ     *ppo,
     CLIPOBJ     *pco,
     SURFOBJ     *pso,
     PLINEATTRS   pla)
{
    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);


    ((ECLIPOBJ *)pco)->vEnumPathStart(ppo, pSurf, pla);
}

/******************************Public*Routine******************************\
* PATHOBJ_bEnumClipLines
*
*   Engine helper function.
*
* History:
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL PATHOBJ_bEnumClipLines(
     PATHOBJ    *ppo,
     ULONG       cj,
    PCLIPLINE   pcl)
{
    ECLIPOBJ *pco = (ECLIPOBJ *)((EPATHOBJ *)ppo)->pco;

    return(pco->bEnumPath(ppo,cj,pcl));
}

/******************************Member*Function*****************************\
* XCLIPOBJ::vEnumPathStart
*
* History:
*  24-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Added styling support.
*
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vEnumPathStart(PATHOBJ *ppo_, SURFACE *pSurf, PLINEATTRS pla)
{
    EPATHOBJ *ppo = (EPATHOBJ *)ppo_;
    pcle = ppo->pcleGet();

    ppo->vEnumStart();
    ppo->pco = (CLIPOBJ *)this;

    pcle->fl      = CLO_LINEDONE;  // need a new line segment
    pcle->cPoints = 0;

// spTotal2 will be non-zero when we're doing styling:

    pcle->spTotal2     = 0;
    pcle->plStyleState = &pla->elStyleState.l;
    pcle->xStep        = 1;
    pcle->yStep        = 1;
    pcle->xyDensity    = 1;

    if (pla->fl & LA_ALTERNATE)
    {
    // Alternate style is special and has every second pixel off, so
    // we pretend a style unit is a single pixel long, and that we
    // have the style array {1}:

        pcle->spTotal2   = 2;
        pcle->spStyleEnd = HIWORD(pla->elStyleState.l) & 1;
    }
    else if (pla->pstyle != (PFLOAT_LONG) NULL)
    {
        if (pSurf->hdev() == 0)
        {
            WARNING("Driver didn't call EngAssociateSurface before calling\n");
            WARNING("EngStrokePath or vEnumPathStart, so styles may be wrong\n");

            pcle->xyDensity = 3;    // Supply a default
        }
        else
        {
            PDEVOBJ po(pSurf->hdev());

            pcle->xStep     = po.xStyleStep();
            pcle->yStep     = po.yStyleStep();
            pcle->xyDensity = po.denStyleStep();
        }

    // Get ready for styling:

        PFLOAT_LONG pstyle = pla->pstyle + pla->cstyle;
        while (pstyle > pla->pstyle)
        {
            pstyle--;
            pcle->spTotal2 += pstyle->l;
        }

        ASSERTGDI((pcle->spTotal2 & ~0x7fffL) == 0, "Style array too long");
        pcle->spTotal2 <<= 1;
        pcle->spTotal2 *= pcle->xyDensity;

    // Construct our scaled style state, remembering that a driver could
    // have left the style state in a funky way:

        pcle->spStyleEnd = HIWORD(pla->elStyleState.l) * pcle->xyDensity +
                           LOWORD(pla->elStyleState.l);
        pcle->spStyleEnd %= (ULONG) pcle->spTotal2;

        if (pcle->spStyleEnd < 0)
        {
            WARNING("GDISRV vEnumPathStart: style state < 0\n");
            pcle->spStyleEnd = 0;
        }
    }

// get the first line.  We don't care about flOld because we
// don't care about last pel exclusion here.

    FLONG flOld;
    bGetLine(ppo,&flOld);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bEnumPath
*
*   bEnumPath fills the pcl data structure with a line and runs that
*   specify uncliped parts of the line.  If there are too many runs to
*   fit in the supplied structure, the next call to this function will
*   return the next set of runs.
*
*   This routine assumes that the line to be clipped is already set in
*   the XCLIPOBJ which initialy is done through vEnumStartPath.  After
*   that, this routine will always complete with the next line setup.
*
* returns
*   TRUE  - there are more runs to enumerate
*   FALSE - this is the last set of runs in the path
*
* History:
*
*  21-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Made lines exclusive of ends.
*
*  04-Apr-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bEnumPath(
     PATHOBJ    *ppo_,
     ULONG       cj,
    PCLIPLINE   pcl)
{
    pcl->c = 0;

// See if we're simply done the path:

    if (bEnumDone())
        return(FALSE);

    EPATHOBJ *ppo = (EPATHOBJ *) ppo_;

    BOOL bMore;

    do
    {
    // assume next line already setup.

    // get the run's for the current line.  If we have all the runs, do
    // last pel exclusion.  If we don't have all of the runs, we know
    // there is at least one unclipped pel after the current set of runs.

        bMore = bEnumLine(cj,pcl);

        if (!bMore)
        {
        // save information about current line

            FLONG  flOld   = pcle->fl;

            ASSERTGDI(pcle->dda.lX1 >= pcle->dda.lX0, "irunOld < 0");

        // get the next non-zero length line (bGetLine is FALSE if there aren't
        // any more lines in the path):

            bGetLine(ppo,&flOld);
        }

    } while ((pcl->c == 0) && !bEnumDone());

// if we made it to here with no runs, we must be done.

    if (bEnumDone() && bStyling())
    {
    // We're all done, so update style state in LINEATTRS:

        *pcle->plStyleState = lGetStyleState(pcle->spStyleEnd);
    }

    return(!bEnumDone());
}

/******************************Public*Routine******************************\
* XCLIPOBJ::bGetLine
*
*   Fill ppo with the next line segment in the path.  This may be a closing
*   segment of the current sub-path.
*
*   It may be necessary to ask the path for more points.
*
* returns
*   TRUE  - if there were more line segments
*   FALSE - if no more line segments.
*
* History:
*  16-Oct-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bGetLine(EPATHOBJ *ppo, FLONG *pflOld)
{
    DONTUSE(pflOld);

    FLONG fl;
    FLONG flBeginSub = 0;

// This for(;;) is for eating zero-length lines

    for (;;)
    {
        if (bEnumDone())
            return(FALSE);

    // if we still have more points in the current set

        if (pcle->cPoints > 1)
        {
            pcle->ptfx0 = *pcle->pptfx1;
            ++pcle->pptfx1;
            --pcle->cPoints;

            if (bEnumStartLine((PD_CLOSEFIGURE & pcle->fl) | flBeginSub))
                return(TRUE);
        }

    // otherwise, if we need to close the figure

        else if (bCloseFigure())
        {
            pcle->ptfx0  = *pcle->pptfx1;
            pcle->pptfx1 = &pcle->ptfxStartSub;

        // bEnumStartLine will turn off PD_CLOSFIGURE and turn on CLO_CLOSING:

            if (!bEnumStartLine(CLO_CLOSING) || flBeginSub)
                continue;

            return(TRUE);
        }

    // otherwise, lets get some more points

        else
        {
            if (!bGetMorePoints(ppo,&fl))
            {
                return(FALSE);
            }

            if (bEnumStartLine(fl | flBeginSub))
                return(TRUE);

        // Okay, the first line in the subpath was zero-length.  So remember
        // that we're really still at the start of a subpath, and get the
        // next line:

        // NOTE: We have to make sure we pass on the RESETSTYLE flag too!

            flBeginSub |= (pcle->fl & (PD_BEGINSUBPATH | PD_RESETSTYLE));
        }
    }
}

/******************************Public*Routine******************************\
* XCLIPOBJ::bGetMorePoints
*
*   This routine gets the next set of points from the path object.  If this
*   routine returns TRUE, it is guranteed that their are at least enough points
*   for one more line segment.
*
* returns
*   TRUE  - If there were more points to get
*   FALSE - if no more points
*
* History:
*  15-Oct-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bGetMorePoints(EPATHOBJ *ppo, FLONG *fl)
{
// if we have already gotten all points, return failure

    if (pcle->fl & CLO_PATHDONE)
    {
        pcle->fl |= CLO_ENUMDONE;

        return(FALSE);
    }

// if this is a continuation, we need to save the last point

    if (pcle->cPoints == 1)
        pcle->ptfx0 = *pcle->pptfx1;

// ask the path for some more points

    PATHDATA pd;

    if (!(ppo->bEnum(&pd)))
    {
    // this is the last chunk of points

        pcle->fl |= CLO_PATHDONE;

    // check if we actualy got any.  If no, we must be done!

        if (pd.count == 0)
        {
            pcle->fl |= CLO_ENUMDONE;
            return(FALSE);
        }
    }

// do a little debugging

    ASSERTGDI(pd.count > 0, "CLIPPATH: Path is Empty\n");
    ASSERTGDI(((pcle->cPoints == 0) ? (pd.flags & PD_BEGINSUBPATH) : TRUE),
	      "XCLIPOBJ::bGetMorePoints - 0 points not at BEGINSUBPATH \n");

// if it is the begining of a sub-path, remember the first point

    if (pd.flags & PD_BEGINSUBPATH)
    {
        pcle->ptfxStartSub = *pd.pptfx;

        pcle->ptfx0 = *pd.pptfx;

    // if we only got one point, we had better ask for more

        if (pd.count == 1)
        {
            ASSERTGDI(!(pcle->fl & CLO_PATHDONE),"One point in subpath");

            if (!ppo->bEnum(&pd))
            {
                pcle->fl |= CLO_PATHDONE;

            // check if we actualy got any.  If no, we must be done!

                if (pd.count == 0)
                {
                    pcle->fl |= CLO_ENUMDONE;
                    return(FALSE);
                }
            }
            pcle->pptfx1  = pd.pptfx;
            pcle->cPoints = pd.count;
        }
        else
        {
        // remember that we took two points out of the current set

            pcle->pptfx1  = pd.pptfx + 1;
            pcle->cPoints = pd.count - 1;
        }
    }
    else
    {
    // this is a continuation of the previous set of points

        pcle->pptfx1  = pd.pptfx;
        pcle->cPoints = pd.count;
    }

    *fl = pd.flags;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pathobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathobj.cxx
*
* Non inline PATHOBJ methods
*
* Created: 28-Sep-1990 12:36:30
* Author: Paul Butzi [paulb]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PBRUSH gpbrBackground;
extern PPEN gpPenNull;
extern PBRUSH gpbrNull;
extern LINEATTRS glaNominalGeometric;

// Default LINEATTRS for bSimpleStroke:

LA glaSimpleStroke =
{
    0,                      // fl
    0,                      // iJoin
    0,                      // iEndCap
    {1L},                   // elWidth
    IEEE_0_0F,              // eMiterLimit
    0,                      // cstyle
    (LONG_FLOAT*) NULL,     // pstyle
    {0L}                    // elStyleState
};

#define XFORMNULL ((EXFORMOBJ *) NULL)

// The following declarations are required by the native c8 compiler.

HSEMAPHORE PATHALLOC::hsemFreelist;        // Semaphore for freelist
PATHALLOC *PATHALLOC::freelist;            // Free-list of pathallocs
COUNT      PATHALLOC::cFree;               // Count of free pathallocs
COUNT      PATHALLOC::cAllocated;          // Count of pathallocs allocated

/******************************Public*Routine******************************\
* XEPATHOBJ::XEPATHOBJ(hpath)
*
* Path user object constructor
*
* History:
*  28-Sep-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::XEPATHOBJ(HPATH hPath)
{
    ppath = (PPATH)HmgShareLock((HOBJ) hPath, PATH_TYPE);

    if (ppath != (PATH*) NULL)
    {

        // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;
    }

    return;
}

/******************************Public*Routine******************************\
* XEPATHOBJ::XEPATHOBJ(dco)
*
* Path user object constructor to get at the DC's path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::XEPATHOBJ(XDCOBJ& dco)
{
    ASSERTGDI(dco.hpath() != HPATH_INVALID, "Invalid path");

// If a SaveDC was done, we may have to copy the path before mucking
// with it:

    if (dco.pdc->bLazySave())
    {
        dco.pdc->vClearLazySave();

        XEPATHOBJ epath(dco.hpath());

        ASSERTGDI (epath.bValid(),"hpath invalid when bLazySave is set");

        PATHMEMOBJ pmo;

        if (pmo.bValid() && epath.bValid() && pmo.bClone(epath))
        {
            pmo.vKeepIt();
            dco.pdc->hpath(pmo.hpath());
        }
        else
        {
        // Error case simply deletes the path if we managed to allocate
        // one, and marks the DC path as invalid:

            pmo.vDelete();
            dco.pdc->hpath(HPATH_INVALID);
        }
    }

    ppath = (PPATH)HmgShareLock((HOBJ) dco.hpath(), PATH_TYPE);
    if (ppath != (PATH*) NULL)
    {

        // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;
    }

    return;
}

/******************************Public*Routine******************************\
* EPATHFONTOBJ::vInit(ULONG)
*
* Initialize a chunk of memory to be a font pathobj
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHFONTOBJ::vInit(ULONGSIZE_T size)
{
    ppath = &path;

    path.ppachain              = &pa;
    path.ptfxSubPathStart.x    = 0;
    path.ptfxSubPathStart.y    = 0;
    path.flags                 = PD_BEGINSUBPATH;
    path.pprfirst              = (PATHRECORD*) NULL;
    path.pprlast               = (PATHRECORD*) NULL;
    path.rcfxBoundBox.xLeft    = 0;
    path.rcfxBoundBox.xRight   = 0;
    path.rcfxBoundBox.yTop     = 0;
    path.rcfxBoundBox.yBottom  = 0;
    path.flType                = PATHTYPE_STACK;

    pa.ppanext       = (PATHALLOC*) NULL;
    pa.pprfreestart  = pa.apr;
    pa.siztPathAlloc = size - offsetof(EPATHFONTOBJ,pa);

    fl      = 0;
    cCurves = 0;
}

/******************************Public*Routine******************************\
* XEPATHOBJ::~XEPATHOBJ()
*
* Path user object destructor
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

XEPATHOBJ::~XEPATHOBJ()
{
    if (ppath != (PPATH) NULL)
    {

        // Since we're keeping the object, save the accelerator values
        // away and unlock the object:

        ppath->cCurves = cCurves;
        ppath->fl      = fl;
        DEC_SHARE_REF_CNT(ppath);
    }

    return;
}

/******************************Public*Routine******************************\
* PATHMEMOBJ::PATHMEMOBJ()
*
* Create a new path object.
*
* Note: Using this constructor, the path will not inherit the current
* point from the DC!
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PATHMEMOBJ::PATHMEMOBJ()
{
    PPATH ppathTemp;

    ppath = ppathTemp = (PPATH)HmgAlloc(sizeof(PATH) ,PATH_TYPE, HMGR_ALLOC_ALT_LOCK);

    if (ppathTemp != (PATH*) NULL)
    {
        // Private debug code to catch invalid hpath handle in DC
        // 6/24/98 - davidx

        ASSERTGDI(HmgObjtype(ppath->hGet()) == PATH_TYPE,
                  "Private debug breakpoint. Please contact ntgdi.");

        //
        // Since we 0 init in the Alloc we don't need to do most of this.
        //

        // pPathTemp->ppachain              = (PATHALLOC*) NULL;
        // pPathTemp->pprfirst              = (PATHRECORD*) NULL;
        // pPathTemp->pprlast               = (PATHRECORD*) NULL;
        // pPathTemp->rcfxBoundBox.xLeft    = 0;
        // pPathTemp->rcfxBoundBox.xRight   = 0;
        // pPathTemp->rcfxBoundBox.yTop     = 0;
        // pPathTemp->rcfxBoundBox.yBottom  = 0;
        // pPathTemp->ptfxSubPathStart.x    = 0;
        // pPathTemp->ptfxSubPathStart.y    = 0;
        // pPathTemp->flType                = 0;
        // pPathTemp->fl                    = 0;
        // pPathTemp->cCurves               = 0;

        ppathTemp->flags                 = PD_BEGINSUBPATH | PD_ENDSUBPATH;
        fl                               = 0;
        cCurves                          = 0;
    }

    return;
}

/******************************Public*Routine******************************\
* PATHMEMOBJ::~PATHMEMOBJ()
*
* Release a path object unless made permanent.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PATHMEMOBJ::~PATHMEMOBJ()
{
// ppath may have been made NULL by vDelete(), or by a failed PATH
// allocation in the constructor:

    if (ppath != (PATH*) NULL)
    {
        if (!(ppath->flType & PATHTYPE_KEEPMEM))
        {
        // Free all the blocks in the path:

            vFreeBlocks();

        // Free the handle too:

            HmgFree((HOBJ) ppath->hGet());
        }
        else
        {
        // Since we're keeping the object, save the accelerator values away
        // and unlock the object:

            ppath->cCurves = cCurves;
            ppath->fl      = fl;
            DEC_SHARE_REF_CNT(ppath);
        }
    }
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::PATHSTACKOBJ()
*
* Create a new path object on the stack.  The path can hold only a small
* number of points on the stack, and will overflow onto the heap if
* necessary.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::PATHSTACKOBJ()
{
    ppath = &path;

    path.ppachain              = &paBuf.pa;
    path.ptfxSubPathStart.x    = 0;
    path.ptfxSubPathStart.y    = 0;
    path.flags                 = PD_BEGINSUBPATH;
    path.pprfirst              = (PATHRECORD*) NULL;
    path.pprlast               = (PATHRECORD*) NULL;
    path.rcfxBoundBox.xLeft    = 0;
    path.rcfxBoundBox.xRight   = 0;
    path.rcfxBoundBox.yTop     = 0;
    path.rcfxBoundBox.yBottom  = 0;
    path.flType                = PATHTYPE_STACK;

    paBuf.pa.ppanext           = (PATHALLOC*) NULL;
    paBuf.pa.pprfreestart      = paBuf.pa.apr;
    paBuf.pa.siztPathAlloc     = PATHSTACKALLOCSIZE;

    cCurves = 0;
    fl      = 0;
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::PATHSTACKOBJ(dco, bUseCP)
*
* Create a new path object on the stack or locate an old one.  If the DC
* is currently in a path bracket, we use the active path (which will NOT
* be on the path).  Otherwise, we create a new path on the stack (it will
* overflow onto the heap if necessary).  If we create a new path, we use
* some of the state from the DC to initialize the path, most notably the
* current position (ptfxSubPathStart).
*
* If bUseCP is set, the current position in the DC will be used to set the
* current position in the path.  Calls that don't use the current position
* (i.e., immediately do a bMoveTo) shouldn't set bUseCP because it may
* require a transform call to set it (we need the value in device space).
*
* SaveDC's do lazy saves of paths.  If a lazy save is pending, we have
* to copy the path and update the DC's path handle before we can modify
* it.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::PATHSTACKOBJ(XDCOBJ& dco, BOOL bUseCP)
{
    if (!dco.pdc->bActive())
    {
        cCurves = 0;
        fl      = 0;

    // There's no active path in the DC, so we create a temporary
    // path on the stack to hold our points:

        ppath = &path;

        path.ppachain              = &paBuf.pa;
        path.flags                 = PD_BEGINSUBPATH;
        path.pprfirst              = (PATHRECORD*) NULL;
        path.pprlast               = (PATHRECORD*) NULL;
        path.rcfxBoundBox.xLeft    = 0;
        path.rcfxBoundBox.xRight   = 0;
        path.rcfxBoundBox.yTop     = 0;
        path.rcfxBoundBox.yBottom  = 0;
        path.flType                = PATHTYPE_STACK;

        paBuf.pa.ppanext           = (PATHALLOC*) NULL;
        paBuf.pa.pprfreestart      = paBuf.pa.apr;
        paBuf.pa.siztPathAlloc     = PATHSTACKALLOCSIZE;

        if (bUseCP)
        {
            if (!dco.pdc->bValidPtfxCurrent())
            {
                ASSERTGDI(dco.pdc->bValidPtlCurrent(), "Both CPs invalid?");

                EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

                exo.bXformRound(&dco.ptlCurrent(), &dco.ptfxCurrent(), 1);
                dco.pdc->vValidatePtfxCurrent();
            }

            path.ptfxSubPathStart = dco.ptfxCurrent();

            // If we're not in a path, and a previous call to MoveToEx means
            // that the style state should be reset, we do it now:

            if (dco.ulDirty() & DIRTY_STYLESTATE)
            {
                dco.ulDirtySub(DIRTY_STYLESTATE);

                LINEATTRS* pla = dco.plaRealized();

                if (pla->fl & LA_GEOMETRIC)
                    pla->elStyleState.e = IEEE_0_0F;
                else
                    pla->elStyleState.l = 0L;
            }
        }
    }
    else
    {
    // If a SaveDC was done, we may have to copy the path before we can
    // muck with it:

        if (dco.pdc->bLazySave())
        {
            dco.pdc->vClearLazySave();

            XEPATHOBJ epath(dco.hpath());

            ASSERTGDI (epath.bValid(),"hpath invalid when bLazySave is set");

            PATHMEMOBJ pmo;

            if (pmo.bValid() && epath.bValid() && pmo.bClone(epath))
            {
                pmo.vKeepIt();
                dco.pdc->hpath(pmo.hpath());
            }
            else
            {
                pmo.vDelete();
                dco.pdc->hpath(HPATH_INVALID);
            }
        }

    // There is an active path bracket, so just add to it:

        ppath = (PPATH)HmgShareLock((HOBJ) dco.hpath(), PATH_TYPE);
        if (ppath == (PATH*) NULL)
            return;

        ASSERTGDI(ppath->flType & PATHTYPE_KEEPMEM, "Path not kept?");

    // Load up accelerator values:

        cCurves = ppath->cCurves;
        fl      = ppath->fl;

        if (bUseCP)
        {
            if (!dco.pdc->bValidPtfxCurrent())
            {
            // If the device space current position has been invalidated
            // (meaning that it's moved), always do a bMoveTo to the new
            // device space point:

                ASSERTGDI(dco.pdc->bValidPtlCurrent(), "Both CPs invalid?");

                EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

                exo.bXformRound(&dco.ptlCurrent(), &dco.ptfxCurrent(), 1);
                dco.pdc->vValidatePtfxCurrent();

                bMoveTo(&dco.ptfxCurrent());
            }
            else
            {
            // See if what we think is the current position matches the DC's
            // value (this code will be used when there is a path bracket
            // and the path is being added to for the first time):

                POINTFIX ptfx = ptfxGetCurrent();

                if (dco.ptfxCurrent().x != ptfx.x ||
                    dco.ptfxCurrent().y != ptfx.y)
                    bMoveTo(&dco.ptfxCurrent());
            }
        }
    }
}

/******************************Public*Routine******************************\
* PATHSTACKOBJ::~PATHSTACKOBJ()
*
* Deletes the path if it isn't the DC path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

PATHSTACKOBJ::~PATHSTACKOBJ()
{
// If we ran out of memory allocating blocks, we would have deleted the path,
// in which case ppath may be NULL:

    if (ppath != (PATH*) NULL)
    {
        ASSERTGDI(ppath->flType == PATHTYPE_KEEPMEM ||
                  ppath->flType == PATHTYPE_STACK, "Unexpected path type");

        if (ppath->flType & PATHTYPE_STACK)
        {
        // Path was only temporary; free any additional blocks if there
        // are any:

            if (ppath->ppachain != (PATHALLOC*) NULL)
                vFreeBlocks();
        }
        else
        {
        // Path is a permanent path, so unlock object and save some
        // accelerator values:

            ppath->cCurves = cCurves;
            ppath->fl      = fl;
            DEC_SHARE_REF_CNT(ppath);
        }
    }
}

/******************************Public*Routine******************************\
* RECTANGLEPATHOBJ::vInit(prcfx, bClockwise)
*
* Initializes the path with a single rectangle.  Should probably only ever
* be called from Rectangle.
*
* History:
*  13-Dec-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID RECTANGLEPATHOBJ::vInit(
    RECTL*  prcl,               // Must be well-ordered
    BOOL    bClockwise)         // Direction rectangle is to be drawn
{
    prRect.pr.pprnext = (PATHRECORD*) NULL;
    prRect.pr.pprprev = (PATHRECORD*) NULL;
    prRect.pr.flags   = (PD_BEGINSUBPATH | PD_ENDSUBPATH |
                         PD_RESETSTYLE   | PD_CLOSEFIGURE);
    prRect.pr.count   = 4;

    path.pprfirst     = &prRect.pr;
    path.pprlast      = &prRect.pr;
    path.flags        = 0;

    ppath             = &path;
    cCurves           = 4;
    fl                = 0;

// Initialize PATHRECORD variables.  When drawing in the counter-
// clockwise direction, we draw the vertices in the following order
// (this must match the EBOX constructor):
//
//       1 ___ 0
//        |   |
//        |___|
//       2     3

    path.rcfxBoundBox.xLeft   = LTOFX(prcl->left);
    prRect.pr.aptfx[1].x      = path.rcfxBoundBox.xLeft;
    prRect.pr.aptfx[2].x      = path.rcfxBoundBox.xLeft;

    path.rcfxBoundBox.xRight  = LTOFX(prcl->right);
    prRect.pr.aptfx[0].x      = path.rcfxBoundBox.xRight;
    prRect.pr.aptfx[3].x      = path.rcfxBoundBox.xRight;

    path.rcfxBoundBox.yTop    = LTOFX(prcl->top);
    path.rcfxBoundBox.yBottom = LTOFX(prcl->bottom);

    if (!bClockwise)
    {
        prRect.pr.aptfx[0].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[1].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[2].y  = path.rcfxBoundBox.yBottom;
        prRect.pr.aptfx[3].y  = path.rcfxBoundBox.yBottom;
    }
    else
    {
        prRect.pr.aptfx[2].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[3].y  = path.rcfxBoundBox.yTop;
        prRect.pr.aptfx[0].y  = path.rcfxBoundBox.yBottom;
        prRect.pr.aptfx[1].y  = path.rcfxBoundBox.yBottom;
    }
}

/******************************Public*Routine******************************\
* EngCreatePath()
*
* DDI entry point to create a temporary path.
*
* History:
*  17-Feb-1992 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

PATHOBJ* EngCreatePath()
{
    PATHMEMOBJ pmo;

    if (!pmo.bValid())
        return((PATHOBJ*) NULL);

    EPATHOBJ* pepo = (EPATHOBJ*) PALLOCMEM(sizeof(EPATHOBJ), 'tapG');

    if (pepo == (EPATHOBJ*) NULL)
        return((PATHOBJ*) NULL);

    pmo.vKeepIt();

    pepo->vLock(pmo.hpath());

    return(pepo);
}

/******************************Public*Routine******************************\
* EngDeletePath()
*
* DDI entry point to delete a path allocated by EngCreatePath().
*
* History:
*  17-Feb-1992 -by- J. Andrew Goossen
* Wrote it.
\**************************************************************************/

VOID EngDeletePath(PATHOBJ* ppo)
{
    if (ppo != (PATHOBJ*) NULL)
    {
        ((EPATHOBJ*) ppo)->vDelete();
        VFREEMEM((PVOID) ppo);
    }
    else
        WARNING("ERROR: EngDeletePath given NULL pointer");
}


/******************************Public*Routine******************************\
* EPATHOBJ::vFreeBlocks()
*
* Frees all the heap blocks in a path.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vFreeBlocks()
{
    ASSERTGDI(ppath != (PATH*) NULL, "Trying to free freed path!");

// Free all the blocks in the path:

    PATHALLOC* ppa = ppath->ppachain;

    while (ppa != (PATHALLOC*) NULL)
    {
        PATHALLOC* ppasave = ppa->ppanext;

    // Don't free blocks that aren't PATHALLOCSIZE in size because
    // those were created on the stack:

        if (ppa->siztPathAlloc == PATHALLOCSIZE)
        {
            ASSERTGDI(ppa->siztPathAlloc != PATHSTACKALLOCSIZE,
                "PATHALLOCSIZE and PATHSTACKALLOCSIZE can't be the same!");

            freepathalloc(ppa);
        }

        ppa = ppasave;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::vDelete()
*
* Delete the path and free the handle if there is one.  It's polymorphic
* and can handle path type EPATHOBJ or PATHMEMOBJ.
*
* It can't handle PATHSTACKOBJ's or journal paths.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vDelete()
{
    if (ppath != (PATH*) NULL)
    {
        ASSERTGDI(!(ppath->flags & PATH_JOURNAL), "Can't delete journal path");

    // Free all the blocks in the path:

        vFreeBlocks();

        if (ppath->flType != PATHTYPE_STACK)
        {
        // Free the handle too (stack paths don't have handles):

            HmgFree((HOBJ) ppath->hGet());
            ppath = (PATH*) NULL;      // Prevent destructors from doing anything
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bClone(epo)
*
* Copy the specified path.
*
* History:
*  22-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bClone(EPATHOBJ& epo)
{
// First, copy path information:

    fl      = epo.fl;
    cCurves = epo.cCurves;

    ppath->pprfirst         = (PATHRECORD*) NULL;
    ppath->pprlast          = (PATHRECORD*) NULL;
    ppath->rcfxBoundBox     = epo.ppath->rcfxBoundBox;
    ppath->ptfxSubPathStart = epo.ppath->ptfxSubPathStart;
    ppath->flags            = epo.ppath->flags;

// Copy rest of path on a PATHRECORD by PATHRECORD basis:

    PATHRECORD* ppr     = epo.ppath->pprfirst;
    PATHRECORD* pprPrev = (PATHRECORD*) NULL;
    PATHRECORD* pprNew;

    while (ppr != (PATHRECORD*) NULL)
    {
        FLONG     fl    = ppr->flags;
        POINTFIX* pptfx = ppr->aptfx;
        COUNT     cpt   = ppr->count;
        COUNT     cptMax;

        while (cpt > 0)
        {
            if (!newpathrec(&pprNew,&cptMax,cpt))
                return(FALSE);

            pprNew->flags   = fl;
            pprNew->pprprev = pprPrev;
            pprNew->pprnext = (PATHRECORD*) NULL;

            if (cpt <= cptMax)
                pprNew->count = cpt;
            else
            {
            // Have to copy this PATHRECORD into two separate PATHRECORDs,
            // so adjust the count and clean up the flags:

            // Adjust cptMax for Beziers.

                if (fl & PD_BEZIERS)
                {
                    if (fl & PD_BEGINSUBPATH)
                        cptMax -= (cptMax-1) % 3;
                    else
                        cptMax -= cptMax % 3;
                }

                pprNew->count = cptMax;
                pprNew->flags &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
                fl            &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);
            }

            ppath->pprlast  = pprNew;
            if (pprPrev == (PATHRECORD*) NULL)
                ppath->pprfirst = pprNew;
            else
                pprPrev->pprnext = pprNew;

            RtlCopyMemory(pprNew->aptfx,
                          pptfx,
                          (SIZE_T) pprNew->count * sizeof(POINTFIX));
            pptfx += pprNew->count;
            cpt   -= pprNew->count;

        // Adjust the PATHALLOC record:

            ppath->ppachain->pprfreestart = NEXTPATHREC(pprNew);
            pprPrev = pprNew;
        }

        ppr = ppr->pprnext;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::cjSize(epo)
*
* Compute the size needed if a single PATHALLOC was to hold the entire
* path.
*
* History:
*  20-May-1992 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

ULONGSIZE_T EPATHOBJ::cjSize()
{
    ULONGSIZE_T cjRV = 0;

// Run down the path, adding up the sizes of the pathrecords.

    PATHRECORD* ppr     = ppath->pprfirst;

    while (ppr != (PATHRECORD*) NULL)
    {
        cjRV += offsetof(PATHRECORD, aptfx)
              + (ULONGSIZE_T)ppr->count * sizeof(POINTFIX);

        ppr = ppr->pprnext;
    }

    return(cjRV);
}

/******************************Member*Function*****************************\
* ULONG EPATHOBJ::cTotalCurves()
*
*  Figure out the number of curves in the path for the path's cCurves
*  field.
*
* History:
*  6-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG EPATHOBJ::cTotalCurves()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_CLOSEFIGURE)
            count++;

        if (ppr->flags & PD_BEZIERS)
            count += ppr->count / 3;
        else
        {
            count += ppr->count;
            if (ppr->flags & PD_BEGINSUBPATH)
                count--;
        }
    }

    return(count);
}

/******************************Member*Function*****************************\
* ULONG EPATHOBJ::cTotalPts()
*
*  Figure out the number of control points in a path.
*
* History:
*  20-Feb-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG EPATHOBJ::cTotalPts()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        count += ppr->count;
    }

    return(count);
}

/******************************Public*Routine******************************\
* EPATHOBJ::bAppend (ppoNew,pptfxDelta)                                    *
*                                                                          *
* Appends an offset version of the given path (ppoNew) to the target path. *
*                                                                          *
*  Wed 17-Jun-1992 00:21:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EPATHOBJ::bAppend(EPATHOBJ *ppoNew,POINTFIX *pptfxDelta)
{
    PATHDATAL   pd;       // Needed to call growlastrec and createrec.
    PATHRECORD *ppr;      // For enumeration.
    POINTFIX    ptfx;

    for
    (
        ppr = ppoNew->ppath->pprfirst;
        ppr != (PPATHREC) NULL;
        ppr = ppr->pprnext
    )
    {
        pd.count = ppr->count;
        pd.flags = ppr->flags & PD_BEZIERS;
        pd.pptl = (POINTL *) &(ppr->aptfx[0]);

    // Call bMoveTo if we are starting a new subpath.

        if (ppr->flags & PD_BEGINSUBPATH)
        {
            ptfx.x = ppr->aptfx[0].x + pptfxDelta->x;
            ptfx.y = ppr->aptfx[0].y + pptfxDelta->y;

            bMoveTo(XFORMNULL,(POINTL *) &ptfx);
            pd.count--;
            pd.pptl++;
        }

    // Copy all the control points.

        while (pd.count > 0)
        {
            if (!createrec(XFORMNULL,&pd,pptfxDelta))
                return(FALSE);
        }

    // Set the CloseFigure flag to close it.

        if (ppr->flags & PD_CLOSEFIGURE)
        {
            ppath->pprlast->flags |= PD_CLOSEFIGURE;

        // Indicate that we are starting a new subpath:

            ppath->flags |= PD_BEGINSUBPATH;
        }
    }

// Always reset the PO_ELLIPSE flag (the Ellipse call will set it
// appropriately) and turn on the PO_BEZIERS flag if we added Beziers:

    fl &= ~PO_ELLIPSE;
    if (ppoNew->fl & PO_BEZIERS)
        fl |= PO_BEZIERS;

// Add in the count of curves.

    cCurves += ppoNew->cCurves;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vOffsetPoints (pptfxDest,pptfxSrc,c,dx,dy)                               *
*                                                                          *
* A simple routine that moves points while offsetting them.  This is much  *
* faster than calling the transform code!                                  *
*                                                                          *
*  Wed 17-Jun-1992 00:54:32 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vOffsetPoints
(
    POINTFIX *pptfxDest,
    POINTFIX *pptfxSrc,
    UINT      c,
    LONG      dx,
    LONG      dy
)
{
    while (c--)
    {
        pptfxDest->x = pptfxSrc->x + dx;
        pptfxDest->y = pptfxSrc->y + dy;
        pptfxDest++;
        pptfxSrc++;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::addpts()
*
*   We add the specified points to the path.  If possible, we tack the
*   points onto the last record ('grow the last record') otherwise we
*   create one or more records and stash the points in them.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::addpoints(EXFORMOBJ *pxfo, PATHDATAL *ppd)
{
// No points always succeeds!

    if (ppd->count == 0)
        return(TRUE);

// Try to add to end of last record.  Can't do it if:
//
//      - beginsubpath flag set in ppath (must be new record)
//
//  growlastrec may do nothing, in which case we just
//  fall thru and add records.

    if ((ppath->flags & PD_BEGINSUBPATH) == 0)
        growlastrec(pxfo,ppd,(POINTFIX *) NULL);

// Now add new records until we're done.  Note that if BEGINSUBPATH is
// set in the path, it means that we must add in the current position
// before the points in the ppd; this is handled by createrec.

    while (ppd->count > 0)
    {
        if (!createrec(pxfo,ppd,(POINTFIX *) NULL))    // Adds a new pathalloc
            return(FALSE);                             //   when needed.
    }

// Always reset the PO_ELLIPSE flag (the Ellipse call will set it
// appropriately) and turn on the PO_BEZIERS flag if we added Beziers:

    fl &= ~PO_ELLIPSE;
    if (ppd->flags & PD_BEZIERS)
        fl |= PO_BEZIERS;

    return(TRUE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::growlastrec()                                                  *
*                                                                          *
*   growlastrec - add data to the already existing last record in path.    *
*                                                                          *
*   Note:                                                                  *
*       If the PD_BEGINSUBPATH flag is set in the path header, then        *
*       it means that the current position has *not* been put in the path, *
*       and it must be added to the path before we begin adding more       *
*       control points.  Note that this cannot happen in this routine,     *
*       since we cannot both start a new path and extend an existing       *
*       record at the same time.                                           *
*                                                                          *
* History:                                                                 *
*  Wed 17-Jun-1992 00:15:06 -by- Charles Whitmer [chuckwh]                 *
* Added the pptfxDelta parameter.                                          *
*                                                                          *
*  1-Oct-1990 -by- Paul Butzi [paulb]                                      *
* Wrote it.                                                                *
\**************************************************************************/

void EPATHOBJ::growlastrec(EXFORMOBJ *pxfo,PATHDATAL *ppd,POINTFIX *pptfxDelta)
{
    PATHALLOC *ppa = ppath->ppachain;
    PATHRECORD *ppr = ppath->pprlast;

// Check conditions for adding to last record
//
//  1. there must be a last record
//  2. there must be an existing pathalloc
//  3. the path data to be added must not start a new
//     sub-path
//  4. the other flags must match (bezier, etc.)

    if ( ppr == (PPATHREC) NULL )
        return;

    if ( ppa == (PATHALLOC*) NULL )
        return;

    if (ppd->flags !=
       (ppr->flags & ~(PD_BEGINSUBPATH | PD_ENDSUBPATH)))
    {
        return;
    }

// Figure out how much we can expand the current last record.
//
//  NOTE: pointer casts are below are safe, since both the
//        start and end of a pathalloc block are aligned on
//        the most restrictive boundary.  These alignment points
//          are the *only* safe points to cast between types, since
//        only there are we guaranteed to be safely aligned.

    POINTFIX *oldend = &(ppr->aptfx[ppr->count]);
    POINTFIX *newend = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

    ULONGSIZE_T maxadd = 0;
    if ( newend > oldend )
    {
        //Sundown truncation
        ASSERT4GB((ULONGLONG)(newend - oldend));
        maxadd = (ULONG)(newend - oldend);
    }

// Don't add more than we need!

    if ( maxadd > ppd->count )
        maxadd =  (ULONGSIZE_T)ppd->count;

// We must add a multiple of 3 points for Beziers.

    if (ppd->flags & PD_BEZIERS)
        maxadd -= maxadd % 3;

    if (maxadd == 0)
        return;

// Copy the points:

    if (pptfxDelta != (POINTFIX *) NULL)
    {
        vOffsetPoints(
                      &(ppr->aptfx[ppr->count]),
                      (POINTFIX *) ppd->pptl,
                      maxadd,
                      pptfxDelta->x,
                      pptfxDelta->y
                     );
    }
    else if (pxfo == XFORMNULL)
        RtlCopyMemory(&(ppr->aptfx[ppr->count]),
                      ppd->pptl,
                      (SIZE_T) maxadd * sizeof(POINTFIX));
    else
        pxfo->bXformRound(ppd->pptl, &(ppr->aptfx[ppr->count]), maxadd);

    ASSERTGDI((CHAR*) &ppr->aptfx[ppr->count + maxadd] <=
              (CHAR*) ppa + ppa->siztPathAlloc,
              "Overwrote bounds!");
    ASSERTGDI((CHAR*) &(ppr->aptfx[ppr->count]) > (CHAR*) ppa, "Bad bound");

// Adjust the bounding box:

    register POINTFIX *pptfx = &ppr->aptfx[ppr->count];
    for ( register ULONG i = 0; i < maxadd; i += 1, pptfx += 1 )
    {
        ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx);
    }

// adjust the path record

    ppr->count += maxadd;

// adjust the pathalloc record

    ppa->pprfreestart = NEXTPATHREC(ppr);

    ASSERTGDI((CHAR*) ppa->pprfreestart <= (CHAR*) ppa + ppa->siztPathAlloc,
              "Weird freestart");

// adjust the pathdata record

    ppd->count -= maxadd;
    ppd->pptl += maxadd;
}


/******************************Public*Routine******************************\
* EPATHOBJ::reinit()                                                       *
*     Reinitialize an existing path so that it becomes an empty path.      *
*     This is useful in error cases when the path cannot be restored,      *
*     but also cannot be deleted (because the handle is in a DC).  See     *
*     bug 177612 for details.                                              *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  11-Aug-1998 -by- Ori Gershony [orig]                                    *
* Wrote it.                                                                *
\**************************************************************************/
VOID EPATHOBJ::reinit()
{
    if (ppath != (PATH *) NULL)
    {
        ASSERTGDI(!(ppath->flags & PATH_JOURNAL), "Can't delete journal path");
    
    // Free all the blocks in the path:

        vFreeBlocks();

    // And reinitialize the path data

        ppath->ppachain              = (PATHALLOC*) NULL;
        ppath->pprfirst              = (PATHRECORD*) NULL;
        ppath->pprlast               = (PATHRECORD*) NULL;
        ppath->rcfxBoundBox.xLeft    = 0;
        ppath->rcfxBoundBox.xRight   = 0;
        ppath->rcfxBoundBox.yTop     = 0;
        ppath->rcfxBoundBox.yBottom  = 0;
        ppath->ptfxSubPathStart.x    = 0;
        ppath->ptfxSubPathStart.y    = 0;
        ppath->flags                 = PD_BEGINSUBPATH | PD_ENDSUBPATH;
        ppath->pprEnum               = (PATHRECORD *) NULL;
        // Don't clear flType - it's used by the destructor to determine
        // how we allocated the memory and hence how to dispose of it correctly.
        //ppath->flType                = 0;
        ppath->fl                    = 0;
        ppath->cCurves               = 0;
        // don't need to initialize ppath->cle, because it will be initialized by vEnumPathStart
        
        fl                           = 0;
        cCurves                      = 0;
    }
}



/******************************Public*Routine******************************\
* EPATHOBJ::createrec()                                                    *
*                                                                          *
*   Add a new path record to the path, taking control points and flags     *
*   from the pathdata struct passed.  We try to fit things in the          *
*   last pathdata block if we can sensibly do it, but otherwise we         *
*   allocate a new pathdata and tack it on the end.  Note that a pathdata  *
*   may not be filled completely if it isn't convenient.                   *
*                                                                          *
* History:                                                                 *
*  Wed 17-Jun-1992 00:15:06 -by- Charles Whitmer [chuckwh]                 *
* Added the pptfxDelta parameter.                                          *
*                                                                          *
*  1-Oct-1990 -by- Paul Butzi [paulb]                                      *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EPATHOBJ::createrec(EXFORMOBJ *pxfo,PATHDATAL *ppd,POINTFIX *pptfxDelta)
{
    PATHALLOC *ppa = ppath->ppachain;
    ULONGSIZE_T maxadd = 0;  // # of pts we can fit into zero space

    if ( ppa != (PATHALLOC*) NULL )
    {
    // We have a current pathalloc, see how much will fit.
    // Computation done into temps to avoid compiler assertion!

        POINTFIX *start = &(ppa->pprfreestart->aptfx[0]);
        POINTFIX *end = (POINTFIX *)((char *)ppa + ppa->siztPathAlloc);

        if (end > start)
        //Sundown safe truncation
            maxadd =(ULONG)(end - start);
    }

// Decide if we need to enter the current position before adding
// the points in the pathdata. cPoints gets the count of how many
// we add; either zero or one.

    COUNT cPoints = (ppath->flags & PD_BEGINSUBPATH) ? 1 : 0;

// We must add a multiple of 3 points for Beziers.

    if ((ppd->flags & PD_BEZIERS) && (maxadd > 0))
        maxadd -= (maxadd - (ULONGSIZE_T)cPoints) % 3;

// At this point, 'maxadd' indicates how many points we could get
// into a record if we added it in the current pathalloc.
// Now we can decide if we need a new pathalloc

    if ( (maxadd < (cPoints + ppd->count)) && (maxadd < PATHALLOCTHRESHOLD) )
    {
    // allocate a new pathalloc, link it into path

        ppa = newpathalloc();
        if (ppa == (PATHALLOC*) NULL)
        {

        // We're out of memory.
        //
        // At this point, our PATHALLOC chain is intact (so we can safely
        // traverse the chain to free the blocks), but the rest of the path
        // data can be corrupt (it's not worth trying to recover in this
        // case), so we can't allow the path to be used anymore.
        //
        // But paths are persistent between API calls when there is an
        // active path; we have to mark that the path is invalid, and not
        // let any subsequent APIs try to do any operation on it other than
        // to delete it.

            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

        // We free all blocks and re-initialize the path.  We don't want to delete
        // it here because the handle might be stored in a DC (see bug 177612)

            reinit();

            return(FALSE);
        }

        ppa->ppanext = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

        ASSERTGDI((CHAR*) ppa + ppa->siztPathAlloc > (CHAR*) ppa->pprfreestart,
                  "Invalid pprfreeestart");

        //Sundown truncation
        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONGSIZE_T numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);
        maxadd = (ULONGSIZE_T)(numbytes - offsetof(PATHRECORD, aptfx)) /
                          sizeof(POINTFIX);

    // We must add a multiple of 3 points for Beziers.

        if (ppd->flags & PD_BEZIERS)
            maxadd -= (maxadd - (ULONGSIZE_T)cPoints) % 3;
    }

// Don't add more points than we need:

    if ( maxadd > (ppd->count + cPoints) )
        maxadd = (ULONGSIZE_T)(ppd->count + cPoints);

// Create new pathrec header:

    PATHRECORD *ppr = ppa->pprfreestart;

    ppr->flags = ppd->flags | PD_ENDSUBPATH;
    ppr->count = maxadd;
    ppr->pprnext = (PPATHREC)NULL;
    ppr->pprprev = ppath->pprlast;

    if ( cPoints == 0 )
    {
    // This new record is a continuation of the old one, so clear
    // the previous record's end-subpath flag

        if (ppath->pprlast != (PPATHREC) NULL)
            ppath->pprlast->flags &= ~PD_ENDSUBPATH;
    }
    else
    {
    // This is a new sub-path, so add in the current point

        *(ppr->aptfx) = ppath->ptfxSubPathStart;
        maxadd -= 1;
        ppr->flags |= (ppath->flags & (PD_BEGINSUBPATH | PD_RESETSTYLE));
        ppath->flags &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);;
    }

// Copy in the points:

    if (pptfxDelta != (POINTFIX *) NULL)
    {
        vOffsetPoints(
                      &(ppr->aptfx[cPoints]),
                      (POINTFIX *) ppd->pptl,
                      maxadd,
                      pptfxDelta->x,
                      pptfxDelta->y
                     );
    }
    else if (pxfo == XFORMNULL)
        RtlCopyMemory(&(ppr->aptfx[cPoints]),
                      ppd->pptl,
                      maxadd * sizeof(POINTFIX));
    else
        pxfo->bXformRound(ppd->pptl, &(ppr->aptfx[cPoints]), maxadd);

    ASSERTGDI((CHAR*) &ppr->aptfx[cPoints + maxadd] <=
              (CHAR*) ppa + ppa->siztPathAlloc,
              "Overwrote bounds!");

// Adjust the bounding box:

    register POINTFIX *pptfx = ppr->aptfx;
    if ( ppath->pprlast == (PPATHREC) NULL )
    {
    // if path was empty, set the bound box to a single pt.

        ppath->rcfxBoundBox.xLeft = ppath->rcfxBoundBox.xRight = pptfx->x;
        ppath->rcfxBoundBox.yTop = ppath->rcfxBoundBox.yBottom = pptfx->y;
    }

    for ( register ULONG i = 0; i < maxadd + cPoints; i += 1, pptfx += 1 )
    {
        ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx);
    }

// Now that we know we have succeeded, add the pathrec to the path chain
// Prior to doing this, we can back out it's as if we hadn't changed anything.

    if (ppath->pprlast == (PPATHREC) NULL )
    {
    // first pathrec in path!

        ppath->pprfirst = ppath->pprlast = ppr;
    }
    else
    {
    // add to pathrec chain

        ppath->pprlast->pprnext = ppr;
        ppath->pprlast = ppr;
    }

// Adjust the pathalloc record:

    ppa->pprfreestart = NEXTPATHREC(ppr);

    ASSERTGDI((CHAR*) ppa->pprfreestart <= (CHAR*) ppa + ppa->siztPathAlloc,
              "Weird freestart");

// Adjust a bunch of state:

    ppd->count -= maxadd;
    ppd->pptl  += maxadd;
    ppd->flags &= ~(PD_BEGINSUBPATH | PD_RESETSTYLE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* PATHOBJ_vGetBounds(ppo, prcfx)
*
*   Gets the path bounds.
*
* History:
*  19-Aug-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID PATHOBJ_vGetBounds(PATHOBJ* ppo, PRECTFX prcfx)
{
    *prcfx = ((EPATHOBJ *) ppo)->rcfxBoundBox();

// Make the box lower-right exclusive if not empty (i.e., not {0,0,0,0}):

    if (prcfx->yTop || prcfx->xLeft || prcfx->yBottom || prcfx->xRight)
    {
        prcfx->yBottom += 1;
        prcfx->xRight  += 1;
    }
}

VOID PATHOBJ_vEnumStart(PATHOBJ* ppo)
{
    ((EPATHOBJ*) ppo)->vEnumStart();
}

/******************************Public*Routine******************************\
* EPATHOBJ::bEnum()
*
*   Enumerate the path
*
* History:
*  19-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bEnum(PATHDATA *ppd)
{
    return(PATHOBJ_bEnum(this, ppd));
}

BOOL PATHOBJ_bEnum(PATHOBJ* ppo, PATHDATA* ppd)
{
    PATH*       ppath;
    LONG        i;
    PATHRECORD* ppr;
    POINTFIX*   pptfx;

    ppath = ((EPATHOBJ*) ppo)->ppath;

// Detect case where he didn't call bStartEnum()

    if (ppath->pprEnum == NULL)
    {
        if (ppath->pprfirst == NULL)
        {
        // It's an empty path:

            ppd->count = 0;
            ppd->flags = 0;
            ppd->pptfx = (PPOINTFIX) NULL;
            return(FALSE);
        }
        else
        {
        // Start again at first record:

            ppath->pprEnum = ppath->pprfirst;
        }
    }

    ppr = ppath->pprEnum;

    ppd->count = ppr->count;
    ppd->flags = ppr->flags;
    ppd->pptfx = ppr->aptfx;

    ppath->pprEnum = ppr->pprnext;

// By setting PO_ENUM_AS_INTEGERS in the PATHOBJ before calling bEnum,
// the driver signals that it saw the PO_ALL_INTEGERS flag and wants
// the coordinates as integers instead of fixed point.  That's great
// because if PO_ALL_INTEGERS was set, that means we recorded the path
// in integer coordinates.

    if ((ppo->fl & (PO_ALL_INTEGERS | PO_ENUM_AS_INTEGERS)) == PO_ALL_INTEGERS)
    {
    // Uh oh, the driver didn't ask for integer coordinates.  So we'll
    // simply convert the path to fixed coordinates and remove the
    // PO_ALL_INTEGERS flag:

        ppo->fl &= ~PO_ALL_INTEGERS;

        for (ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
        {
            for (pptfx = ppr->aptfx, i = ppr->count; i != 0; pptfx++, i--)
            {
                pptfx->x <<= 4;
                pptfx->y <<= 4;
            }
        }
    }

    if ((ppo->fl & (PO_ALL_INTEGERS | PO_ENUM_AS_INTEGERS)) == PO_ENUM_AS_INTEGERS)
    {
    // The driver set PO_ENUM_AS_INTEGERS when PO_ALL_INTEGERS wasn't
    // set.  Tsk, tsk.

        RIP("Driver mustn't set PO_ENUM_AS_INTEGERS unless PO_ALL_INTEGERS was set by GDI");
    }

    return(ppath->pprEnum != (PPATHREC) NULL);
}

/******************************Public*Routine******************************\
* EPATHOBJ::vOffset()
*
*   Enumerate the path
*
* History:
*  29-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vOffset(EPOINTL &eptl)
{
    LONG xOffset = LTOFX(eptl.x);
    LONG yOffset = LTOFX(eptl.y);

    RECTFX *prcfxBoundBox = &ppath->rcfxBoundBox;

    prcfxBoundBox->xLeft   += xOffset;
    prcfxBoundBox->xRight  += xOffset;
    prcfxBoundBox->yTop    += yOffset;
    prcfxBoundBox->yBottom += yOffset;

    if (fl & PO_ALL_INTEGERS)
    {
    // If 'PO_ALL_INTEGERS' is set, the path has been recorded as integers
    // instead of 28.4 fixed point.  So convert the offsets back to integers
    // again:

        xOffset = FXTOL(xOffset);
        yOffset = FXTOL(yOffset);
    }

    register PATHRECORD* ppr;
    for (ppr = ppath->pprfirst; ppr != (PPATHREC) NULL; ppr = ppr->pprnext)
    {
        for (register EPOINTFIX *peptfx = (EPOINTFIX *)ppr->aptfx;
             peptfx < (EPOINTFIX *)&ppr->aptfx[ppr->count];
             peptfx += 1)
        {
            peptfx->x += xOffset;
            peptfx->y += yOffset;
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bMoveTo()
*
*   Set the current position in the path.  Note that the following effects
*   also occur:
*       - last existing record in path is marked as ending the subpath
*       - flag is set indicating that next path record will start a new
*         subpath.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bMoveTo(EXFORMOBJ *pxfo, PPOINTL pptl)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    if (pxfo == XFORMNULL)
        ppath->ptfxSubPathStart = *((PPOINTFIX) pptl);
    else
    {
        pxfo->bXformRound(pptl, &ppath->ptfxSubPathStart, 1);
    }

    ppath->flags |= (PD_BEGINSUBPATH | PD_RESETSTYLE);

    return(TRUE);
}

BOOL PATHOBJ_bMoveTo(PATHOBJ* ppo, POINTFIX ptfx)
{
    return(((EPATHOBJ*) ppo)->bMoveTo(XFORMNULL, (PPOINTL) &ptfx));
}

/******************************Public*Routine******************************\
* EPATHOBJ::bCloseFigure()
*
*   close the current subpath in the path.
*
* History:
*  8-Nov-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bCloseFigure()
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    if (ppath->pprlast != (PATHRECORD*) NULL)
    {
        if (!(ppath->pprlast->flags & PD_CLOSEFIGURE))
        {
            ppath->pprlast->flags |= PD_CLOSEFIGURE;
            cCurves++;
        }
    }

// Indicate that we are starting a new subpath:

    ppath->flags |= PD_BEGINSUBPATH;

// We don't have to update ptfxSubPathStart because the current position
// after a CloseFigure is set to the sub-path start point.

    return(TRUE);
}

BOOL PATHOBJ_bCloseFigure(PATHOBJ* ppo)
{
    return(((EPATHOBJ*) ppo)->bCloseFigure());
}

/******************************Public*Routine******************************\
* EPATHOBJ::vCloseAllFigures()
*
*   Closes any open figures in the path.  Used for FillPath and
*   StrokeAndFillPath.
*
* History:
*  17-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vCloseAllFigures()
{
    PPATHREC ppr = ppath->pprfirst;
    while (ppr != (PPATHREC) NULL)
    {
        if (ppr->flags & PD_ENDSUBPATH)
        {
            if (!(ppr->flags & PD_CLOSEFIGURE))
            {
                ppr->flags |= PD_CLOSEFIGURE;
                cCurves++;
            }
        }
        ppr = ppr->pprnext;
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bPolyLineTo()
*
*   Draw lines from the current position in the path thru the specified
*   points.  Sets the current position to the last specified point.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bPolyLineTo(EXFORMOBJ *pxfo, PPOINTL pptl, ULONG cPts)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    PATHDATAL pd;
    BOOL      bRet;

    pd.flags = 0;
    pd.pptl  = pptl;
    pd.count = cPts;

    bRet = addpoints(pxfo, &pd);
    if (bRet)
        cCurves += cPts;

    return(bRet);
}

BOOL PATHOBJ_bPolyLineTo(PATHOBJ* ppo, PPOINTFIX pptfx, ULONG cptfx)
{
// NULL transform indicates that the points are already in device space:

    return(((EPATHOBJ*) ppo)->bPolyLineTo(XFORMNULL,
                                          (PPOINTL) pptfx,
                                          cptfx));
}

/******************************Public*Routine******************************\
* EPATHOBJ::bPolyBezierTo()
*
*   Draw curves from the current position in the path thru the specified
*   points.  Sets the current position to the last specified point.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bPolyBezierTo(EXFORMOBJ *pxfo, PPOINTL pptl, ULONG cPts)
{
// we can fail if the driver got a previous out of memory error

    if (!bValid())
        return(FALSE);

    PATHDATAL pd;
    BOOL      bRet;

    ASSERTGDI(cPts % 3 == 0, "Weird number of Bezier points");
    pd.flags = PD_BEZIERS;
    pd.pptl  = pptl;
    pd.count = cPts;

    bRet = addpoints(pxfo, &pd);
    if (bRet)
        cCurves += cPts / 3;

    return(bRet);
}

BOOL PATHOBJ_bPolyBezierTo(PATHOBJ* ppo, PPOINTFIX pptfx, ULONG cptfx)
{
// NULL transform indicates that the points are already in device space:

    return(((EPATHOBJ*) ppo)->bPolyBezierTo(XFORMNULL,
                                            (PPOINTL) pptfx,
                                            cptfx));
}


BOOL EPATHOBJ::bTextOutSimpleFill(
XDCOBJ&     dco,
RFONTOBJ&   rfo,
PDEVOBJ*    pdo,
SURFACE*    pSurf,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrushOrg,
MIX         mix,
FLONG       flOptions)
{
    BOOL bSem = FALSE, bRet;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;

    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCace acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    if (dco.bPrinter() && dco.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    bRet = bSimpleFill(dco.flGraphicsCaps(),
                       pdo,
                       pSurf,
                       pco,
                       pbo,
                       pptlBrushOrg,
                       mix,
                       flOptions);
    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);

        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }
    }

    return bRet;
}

BOOL EPATHOBJ::bTextOutSimpleStroke1(
XDCOBJ& dco,
RFONTOBJ& rfo,
PDEVOBJ*   plo,
SURFACE*   pSurface,
CLIPOBJ*   pco,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
MIX        mix)
{
    BOOL bSem = FALSE, bRet;
    ULONG fl = 0, numLinks = 0;
    BOOL  aFaceLink[UMPD_MAX_FONTFACELINK], *pFaceLink = aFaceLink;

    //
    // Release rfont semaphores, otherwise holding rfont semaphores can
    // disable APC queue while calling to the user mode.
    //

    //
    //  WINBUG #214225 tessiew 10-27-2000 Blackcomb: re-visit the RFONT.hsemCace acquiring/releasing issue
    // Need to revisit the font semaphore problem in Blackcomb
    //  It seems that a thread doesn't need to hold the font caching semaphore
    //  during the whole GreExtTextOutWLocked call.
    //

    if (dco.bPrinter() && dco.bUMPD() && rfo.bValid())
    {
        bSem = UMPDReleaseRFONTSem(rfo, NULL, &fl, &numLinks, &pFaceLink);
    }

    LINEATTRS laTmp = glaSimpleStroke.la;

    bRet = bSimpleStroke(dco.flGraphicsCaps(),
                         plo,
                         pSurface,
                         pco,
                         (XFORMOBJ*) NULL,
                         pbo,
                         pptlBrushOrg,
                         &laTmp,
                         mix);

    if (bSem)
    {
        UMPDAcquireRFONTSem(rfo, NULL, fl, numLinks, pFaceLink);

        if (pFaceLink && pFaceLink != aFaceLink)
        {
            VFREEMEM(pFaceLink);
        }
    }

    return bRet;
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleFill(flCaps, plo, pSurf, pco, pbo, pptlBrushOrg,
*                       mix, flOptions)
*
* Fill the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleFill(
FLONG     flCaps,              // For device graphics caps
PDEVOBJ*  pdo,
SURFACE*  pSurf,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL  bRet;

#if DBG
    ASSERTGDI(bAllClosed(), "A sub-path in the filled path wasn't closed.");
#endif
    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

    if (pSurf->flags() & HOOK_FillPath)
    {
        if (((flOptions & WINDING) && (flCaps & GCAPS_WINDINGFILL)) ||
            (!(flOptions & WINDING) && (flCaps & GCAPS_ALTERNATEFILL)))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,FillPath),
                        "Driver hooked FillPath but didn't supply routine");

                    INC_SURF_UNIQ(pSurf);

                    bRet = (*PPFNDRV(*pdo,FillPath)) (
                                       pSurf->pSurfobj(),
                                       (PATHOBJ*) this,
                                       pco,
                                       pbo,
                                       pptlBrushOrg,
                                       mix,
                                       flOptions);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,FillPath),
                "Driver hooked FillPath but didn't supply routine");

            INC_SURF_UNIQ(pSurf);

            bRet = (*PPFNDRV(*pdo,FillPath)) (
                               pSurf->pSurfobj(),
                               (PATHOBJ*) this,
                               pco,
                               pbo,
                               pptlBrushOrg,
                               mix,
                               flOptions);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    INC_SURF_UNIQ(pSurf);

    return(EngFillPath(pSurf->pSurfobj(),
                       (PATHOBJ*) this,
                       pco,
                       pbo,
                       pptlBrushOrg,
                       mix,
                       flOptions));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleStroke(flCaps, pdo, pSurf, pco, pxo, pbo, pptlBrushOrg,
*                         pla, mix)
*
* Stroke the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleStroke(
FLONG      flCaps,             // For device graphics caps
PDEVOBJ*   pdo,
SURFACE*   pSurf,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    BOOL  bRet;

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

// the real thing

    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

    INC_SURF_UNIQ(pSurf);

    if (pSurf->flags() & HOOK_StrokePath)
    {
    // Pass the path to the driver if it's not a wide line, or if the driver
    // says it can take wide lines:

        if (!(pla->fl & LA_GEOMETRIC) || (flCaps & GCAPS_GEOMETRICWIDE))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,StrokePath),
                        "Driver hooked StrokePath but didn't supply routine");

                    bRet = (*PPFNDRV(*pdo,StrokePath)) (
                                         pSurf->pSurfobj(),
                                         (PATHOBJ*) this,
                                         pco,
                                         pxo,
                                         pbo,
                                         pptlBrushOrg,
                                         pla,
                                         mix);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,StrokePath),
                "Driver hooked StrokePath but didn't supply routine");

            bRet = (*PPFNDRV(*pdo,StrokePath)) (
                                 pSurf->pSurfobj(),
                                 (PATHOBJ*) this,
                                 pco,
                                 pxo,
                                 pbo,
                                 pptlBrushOrg,
                                 pla,
                                 mix);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    if (pla->fl & LA_GEOMETRIC)
    {
        //
        // Handle wide lines, remembering that the widened bounds have
        // already been computed:
        //

        if (!bWiden(pxo, pla))
            return(FALSE);

        return(bSimpleFill(flCaps,
                           pdo,
                           pSurf,
                           pco,
                           pbo,
                           pptlBrushOrg,
                           mix,
                           WINDING));
    }

    //
    // Pass it off to the engine:
    //

    return(EngStrokePath(pSurf->pSurfobj(),
                         (PATHOBJ*) this,
                         pco,
                         pxo,
                         pbo,
                         pptlBrushOrg,
                         pla,
                         mix));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bSimpleStrokeAndFill(flCaps, pdo, pSurf, pco, pxo, pboStroke,
*                                pla, pboFill, pptlBrushOrg, mix, flOptions)
*
* Stroke and fill the path, accounting for smart devices.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bSimpleStrokeAndFill(
FLONG      flCaps,             // For device graphics caps
PDEVOBJ*   pdo,
SURFACE*   pSurf,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pboStroke,
LINEATTRS* pla,
BRUSHOBJ*  pboFill,
POINTL*    pptlBrushOrg,
MIX        mix,
FLONG      flOptions)
{
    BOOL  bRet;

#if DBG
    ASSERTGDI(bAllClosed(), "A sub-path in the filled path wasn't closed.");
#endif
    ASSERTGDI(cTotalCurves() == cCurves, "Messed up curve count somewhere.");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

// The DDI restricts all paths to a 2^27 by 2^27 pixel space to allow
// device drivers to compute deltas using 32-bit integers without
// overflowing.

    if (((rcfxBoundBox().xRight - rcfxBoundBox().xLeft) < 0) ||
        ((rcfxBoundBox().yBottom - rcfxBoundBox().yTop) < 0))
    {
        return(FALSE);
    }

    if (cCurves == 0)
    {
        return(TRUE);
    }

    INC_SURF_UNIQ(pSurf);

    if (pSurf->flags() & HOOK_StrokeAndFillPath)
    {
    // Pass the path to the driver if either it's not a wide line, or
    // if the driver says it can take wide lines:

        if (!(pla->fl & LA_GEOMETRIC) || (flCaps & GCAPS_GEOMETRICWIDE))
        {
            if (bBeziers())
            {
                if (flCaps & GCAPS_BEZIERS)
                {
                // The driver says it can handle Beziers, so try giving it
                // the path, Beziers and all:

                    ASSERTGDI(PPFNVALID(*pdo,StrokeAndFillPath),
                         "Driver hooked StrokeAndFillPath but didn't supply routine");

                    bRet = (*PPFNDRV(*pdo,StrokeAndFillPath)) (
                                                pSurf->pSurfobj(),
                                                (PATHOBJ*) this,
                                                pco,
                                                pxo,
                                                pboStroke,
                                                pla,
                                                pboFill,
                                                pptlBrushOrg,
                                                mix,
                                                flOptions);

                    if (bRet == TRUE)
                        return(TRUE);
                    else if (bRet == DDI_ERROR)
                        return(FALSE);
                }

            // If there's complex clipping, the driver might not want to
            // render Beziers itself, so we'll flatten it and try again
            // (or maybe the driver doesn't handle Beziers at all):

                if (!bFlatten())
                    return(FALSE);
            }

            ASSERTGDI(PPFNVALID(*pdo,StrokeAndFillPath),
                 "Driver hooked StrokeAndFillPath but didn't supply routine");

            bRet = (*PPFNDRV(*pdo,StrokeAndFillPath)) (
                                        pSurf->pSurfobj(),
                                        (PATHOBJ*) this,
                                        pco,
                                        pxo,
                                        pboStroke,
                                        pla,
                                        pboFill,
                                        pptlBrushOrg,
                                        mix,
                                        flOptions);

            if (bRet == TRUE)
                return(TRUE);
            else if (bRet == DDI_ERROR)
                return(FALSE);
        }
    }

    BOOL bDemote = FALSE;

// Can demote into separate Fill and Stroke calls if we're not doing a
// wide-line, or if we're doing a SRCCOPY and the display is raster, we
// can also demote (because in that case, we don't mind if we re-light
// pixels):

    if (!(pla->fl & LA_GEOMETRIC))
        bDemote = TRUE;
    else if ((mix & 0xFF) == R2_COPYPEN)
    {
        PDEVOBJ po(pSurf->hdev());
        if (po.ulTechnology() == DT_RASDISPLAY ||
            po.ulTechnology() == DT_RASPRINTER)
            bDemote = TRUE;
    }

    if (bDemote)
    {
        MIX mixFill, mixStroke;

        mixFill = mixStroke = mix;

        if (!((EBRUSHOBJ *)pboFill)->bIsMasking())
        {
            mixFill = (mix & 0xff) | ((mix & 0xff) << 8);
        }

        if (!((EBRUSHOBJ *)pboStroke)->bIsMasking())
        {
            mixStroke = (mix & 0xff) | ((mix & 0xff) << 8);
        }

        return(bSimpleFill(flCaps,
                           pdo,
                           pSurf,
                           pco,
                           pboFill,
                           pptlBrushOrg,
                           mixFill,
                           flOptions) &&
               bSimpleStroke(flCaps,
                             pdo,
                             pSurf,
                             pco,
                             pxo,
                             pboStroke,
                             pptlBrushOrg,
                             pla,
                             mixStroke));
    }

// Hand off to the engine simulation, which will nicely subtract the regions
// if necessary:

    return(EngStrokeAndFillPath(pSurf->pSurfobj(),
                                (PATHOBJ*) this,
                                pco,
                                pxo,
                                pboStroke,
                                pla,
                                pboFill,
                                pptlBrushOrg,
                                mix,
                                flOptions));
}

/******************************Member*Function*****************************\
* EPATHOBJ::bStrokeAndOrFill(dco, pla, pexo, flType)
*
* Stroke and/or fills the path, depending on flType and the current pen
* and brush.
*
* Note that unless the only output operations you're doing is with the
* path, you probably want to do your own locking, pointer exclusion, etc.
* and call bSimpleStroke, bSimpleFill or bSimpleStrokeAndFill.
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bStrokeAndOrFill(
XDCOBJ&    dco,
LINEATTRS* pla,
EXFORMOBJ* pexo,
FLONG      flType)
{
    ASSERTGDI(bValid(), "Invalid Path");
    ASSERTGDI(dco.bValid(), "Invalid DC");

    BOOL  bRet = FALSE;
    BOOL  bOpaqueStyle = FALSE;
    LONG  lOldStyleState;
    MIX   mix;
    BOOL  bCanDither;
    FLONG flOriginal;

// If there aren't any points (as may happen with consecutive calls to
// BeginPath and EndPath), we're all done -- don't let this get down to
// the driver, which won't expect it.

    if (cCurves == 0)
    {
        return(TRUE);
    }

    flOriginal = flType;

// Simplify if NULL pen or NULL brush:

    if (dco.pdc->pbrushLine() == gpPenNull)
    {
        flType &= ~PATH_STROKE;
    }

    if (dco.pdc->pbrushFill() == gpbrNull)
    {
        flType &= ~PATH_FILL;
    }

// If doing a wide line, have to adjust bounds:

    if (flType & PATH_STROKE)
    {
        if (pla->fl & LA_GEOMETRIC)
        {
            if (!bComputeWidenedBounds((XFORMOBJ*) pexo, pla))
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(bRet);
            }

        // We don't support preserving the style state accross DrvStrokePaths
        // in Product One for geometric lines, so make sure we always reset
        // the style state value:

            if (pla->pstyle != (PFLOAT_LONG) NULL)
                pla->elStyleState.e = IEEE_0_0F;
        }
    }

// Compute bound box and make it lower-right exclusive:

    ERECTL erclBoundsDevice(ppath->rcfxBoundBox);
    erclBoundsDevice.bottom++;
    erclBoundsDevice.right++;

    if (dco.fjAccum())
        dco.vAccumulate(erclBoundsDevice);

// If we're in FULLSCREEN mode, exit with success.

    if (dco.bFullScreen())                  // If in FULLSCREEN mode, exit.
        return(TRUE);

// Lock Rao region, VisRgn.  We would really like to do all the flattening,
// widening and converting to regions before we grab this, because they
// are time intensive and the DEVLOCK prevents any other screen updating.
// This might have to change if it becomes a performance issue.

    DEVLOCKOBJ dlo(dco);
    if (!dlo.bValid())
    {
        return(dco.bFullScreen());
    }

    if (dco.bDisplay() && !dco.bRedirection() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

    ERECTL erclBoundsScreen = erclBoundsDevice;
    erclBoundsScreen += dco.eptlOrigin();
    vOffset(dco.eptlOrigin());

    ECLIPOBJ eco(dco.prgnEffRao(), erclBoundsScreen);

// Might be able to do a quick-out:

    if ((dco.dctp() == DCTYPE_INFO) || eco.erclExclude().bEmpty())
    {
        if (flType & PATH_STROKE)
        {
            if ((pla->pstyle != (PFLOAT_LONG) NULL && !(pla->fl & LA_GEOMETRIC))
                || pla->fl & LA_ALTERNATE)
            {
                vUpdateCosmeticStyleState(dco.pSurface(), pla);
            }
        }

        bRet = TRUE;
        return(bRet);
    }

// Lock the destination surface and the ldev:

    SURFACE  *pSurfDest = dco.pSurface();
    PDEVOBJ   po(dco.hdev());
    XEPALOBJ  epalDest(pSurfDest->ppal());
    XEPALOBJ  epalDestDC(dco.ppal());

// Realize the brushes:

    EBRUSHOBJ  *peboPen = dco.peboLine();
    EBRUSHOBJ  *peboBrush = dco.peboFill();
    EBRUSHOBJ  *peboStroke = peboPen;

    if (flType & PATH_STROKE)
    {
        ASSERTGDI(pla != (LINEATTRS*) NULL, "Invalid LineAttrs for stroke");
        ASSERTGDI(!(pla->fl & LA_GEOMETRIC) || pexo != (EXFORMOBJ*) NULL,
                  "Invalid xform on geometric line");

        if (pla->fl & LA_GEOMETRIC)
        {
        // The bCanDither flag actually means 'bCanDitherIfBrushSaysSo' --
        // the brush has to be marked as ditherable AND bCanDither has to be
        // set before the brush is dithered:

            bCanDither = TRUE;

        // Because of Win3.1 compatibility, when the PS_INSIDEFRAME pen
        // is treated as a wideline, we can dither the brush.  But the
        // dither/can't dither decision depends on the transform,
        // and the last time we used this brush we may have realized
        // it as non-ditherable.

        // PS_INSIDEFRAME pens are reasonably rare, and realizing a brush
        // is relatively quick (particularly compared to the wide-line
        // rendering time), so if the cached brush is a solid color, we
        // simply mark the brush so that it will be re-realized (but only
        // for PS_INSIDEFRAME pens):

        // if the driver says dither (mainly for 8 color printer devices) we
        // can dither even if it is not InsideFrame.

        // Note: If the pen is dirty, we'll actually be looking at
        // uninitialized fields!  But that's okay, because we'd only be
        // marking the pen dirty again:

            if ((peboPen->iSolidColor != (ULONG) -1) &&
                (peboPen->bIsInsideFrame() || po.bCapsForceDither()))
            {
                dco.ulDirty(dco.ulDirty() | DIRTY_LINE);
            }
        }
        else
        {
        // Here we've got the opposite case.  When the transform is such
        // that a PS_INSIDEFRAME pen is treated as a cosmetic pen,
        // the brush has to be solid colored:

            bCanDither = FALSE;
            if (peboPen->iSolidColor == (ULONG) -1)
            {
                dco.ulDirty(dco.ulDirty() | DIRTY_LINE);
            }
        }

        if (dco.bDirtyBrush(DIRTY_LINE))
        {
            dco.vCleanBrush(DIRTY_LINE);

            peboPen->vInitBrush(dco.pdc,
                                dco.pdc->pbrushLine(),
                                epalDestDC, epalDest,
                                pSurfDest,
                                bCanDither);
        }

        if (pla->pstyle != (PFLOAT_LONG) NULL &&
            peboPen->bIsOldStylePen() &&
            dco.pdc->jBkMode() == OPAQUE &&
            !(pla->fl & LA_GEOMETRIC)) // Don't style wide Win3 pens
        {
        // If the background mode is OPAQUE, and we're styling with an
        // old Win3-style pen, we have to note it.  We do this styling in
        // two passes.  On the first pass, we use the opaque pen.

            bOpaqueStyle = TRUE;
            ASSERTGDI(peboPen->bIsDefaultStyle(), "Expect only default style");

        // Change the sense of the first element in the style array:

            pla->fl ^= LA_STARTGAP;
            lOldStyleState = pla->elStyleState.l;
            peboStroke     = dco.peboBackground();

        // Initialize the opaque pen:

        // The opaquing brush must be solid colored.  If the cached version
        // isn't solid colored, mark the cached entry as invalid so that
        // we'll re-realize.  I don't expect this to ever happen (we merely
        // implmement this for completeness), so it's hardly a performance
        // hit.

            if (!(dco.ulDirty() & DIRTY_BACKGROUND))
            {
                if (peboStroke->iSolidColor == (ULONG) -1)
                {
                    dco.ulDirty(dco.ulDirty() | DIRTY_BACKGROUND);
                }
            }

            if (dco.bDirtyBrush(DIRTY_BACKGROUND))
            {
                if((dco.flGraphicsCaps() & GCAPS_ARBRUSHOPAQUE) == 0)
                {
                    // BUGFIX #27335 2-18-2000 bhouse
                    // We can clear the DIRTY_BACKGROUND bit only if
                    // we would have otherwise realized it without
                    // dithering enabled.

                    dco.vCleanBrush(DIRTY_BACKGROUND);
                }


                peboStroke->vInitBrush(
                             dco.pdc,
                             (PBRUSH)gpbrBackground,
                             epalDestDC, epalDest,
                             pSurfDest,
                             FALSE);        // False means can't dither
            }
        }

        mix = peboPen->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());
    }

    if (flType & PATH_FILL)
    {
        if (dco.bDirtyBrush(DIRTY_FILL))
        {
            dco.vCleanBrush(DIRTY_FILL);

            peboBrush->vInitBrush(dco.pdc,
                                  dco.pdc->pbrushFill(),
                                  epalDestDC, epalDest,
                                  pSurfDest);
        }

    // For StrokeAndFill, we can pass down only a single 'mix' that applies
    // to both brushes (normally, we don't want to pass down a transparent
    // mix when the brush is not a hatch because the mix is what the display/
    // printer driver cues off of to know if it has to do a transparent fill,
    // which it typically does very slowly).
    //
    // If either brush is a hatched brush, and the BkMode is TRANSPARENT,
    // then 'mix' must indicate a transparent mix.  The way it works here
    // is that if a transparent mix was already initialized for the pen, we
    // don't recompute the mix:

        if (!(flType & PATH_STROKE) ||
            ((mix >> 8) == (mix & 0xff)))
        {
            mix = peboBrush->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());
        }
    }

// Reset the path for enumeration:

    ppath->pprEnum = (PATHRECORD*) NULL;

// Exclude the pointer:

    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

    if ((flType == 0) && (po.ulTechnology() != DT_RASDISPLAY))
    {
    // Microsoft Publisher and Adobe Persuasion draw colored pattern
    // and gradient fills on Postscript by doing the following sequence:
    //
    //    1.  Send BEGIN_PATH printer escape;
    //    2.  Draw a path using a hollow brush and a NULL pen;
    //    3.  Send END_PATH escape;
    //    4.  Send CLIP_TO_PATH.
    //
    // The problem is that we used to detect these path cases and
    // optimize out the calls to the driver, so the clipping path
    // would never get down to Postscript.
    //
    // To fix this, we now detect this case and subsitute R2_NOP for
    // the mix instead, and in this manner the path will still get down
    // to the driver.  If the driver is not currently accumulating a
    // path, the right thing will still be printed: that is, nothing.

        flType = flOriginal;
        mix = ((R2_NOP << 8) | R2_NOP);
        pla = &glaSimpleStroke.la;         // Give them something to look at
    }

// Finally, make the necessary calls:

    switch(flType)
    {
    case 0:
        bRet = TRUE;
        break;

    case PATH_FILL:
        bRet = bSimpleFill(dco.flGraphicsCaps(),
                           &po,
                           pSurfDest,
                           &eco,
                           peboBrush,
                           &dco.pdc->ptlFillOrigin(),
                           mix,
                           dco.pdc->jFillMode());
        break;

    case PATH_STROKE:
        bRet = bSimpleStroke(dco.flGraphicsCaps(),
                             &po,
                             pSurfDest,
                             &eco,
                             (XFORMOBJ *) pexo,
                             peboStroke,
                             &dco.pdc->ptlFillOrigin(),
                             pla,
                             mix);
        break;

    case PATH_STROKE | PATH_FILL:
        bRet = bSimpleStrokeAndFill(dco.flGraphicsCaps(),
                                    &po,
                                    pSurfDest,
                                    &eco,
                                    (XFORMOBJ *) pexo,
                                    peboStroke,
                                    pla,
                                    peboBrush,
                                    &dco.pdc->ptlFillOrigin(),
                                    mix,
                                    dco.pdc->jFillMode());
        break;

    default:
        RIP("Woah Nellie!");
    }

// Do a second pass to draw the dashes for opaque styled lines:

    if (bOpaqueStyle)
    {
        pla->fl ^= LA_STARTGAP;
        pla->elStyleState.l = lOldStyleState;
        ppath->pprEnum = (PATHRECORD*) NULL;

        bRet &= bSimpleStroke(dco.flGraphicsCaps(),
                              &po,
                              pSurfDest,
                              &eco,
                              (XFORMOBJ *) pexo,
                              peboPen,
                              &dco.pdc->ptlFillOrigin(),
                              pla,
                              mix);
    }

    return(bRet);
}

//
//  Pathalloc structure
//
// We allocate the space for paths in blocks that are essentially
// independent of the chain used to order the pathdata records.  Typically
// we will have several ( or many ) pathdata records packed into each
// pathalloc block.  The pathalloc blocks for a path are all chained together
// using the ppanext pointers; the end of the chain is marked with a NULL
// pointer.
//
// Each pathalloc structure has two fields which describe the space available
// in the block; the 'start' field is the pointer to the start of the
// available space, and the 'end' field is the pointer to the address
// *following* the last valid address in the pathalloc.  Thus, the space
// remaining in the pathalloc can be computed as end - start.
//
// Routines to allocate and free pathalloc structures

/******************************Public*Routine******************************\
* friend BOOL bInitPathAlloc()
*
*   Initialize the freelist for pathallocs.  Get a semaphore, set the
*   freelist to empty.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

BOOL bInitPathAlloc()
{
    if ((PATHALLOC::hsemFreelist = GreCreateSemaphore()) == NULL)
    {
        return(FALSE);
    }

    PATHALLOC::freelist   = (PATHALLOC*) NULL;
    PATHALLOC::cFree      = 0;
    PATHALLOC::cAllocated = 0;

    return(TRUE);
}


/******************************Public*Routine******************************\
* friend void freepathalloc()
*
*   Deallocate a pathalloc.
*
* History:
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

VOID freepathalloc(PATHALLOC *ppa)
{
    ASSERTGDI(ppa->siztPathAlloc == PATHALLOCSIZE, "Not a heap PATHALLOC");

    SEMOBJ  so(PATHALLOC::hsemFreelist);

    if (PATHALLOC::cFree >= FREELIST_MAX)
    {
    // Free the memory if we've already got enough blocks on the freelist.

        VFREEMEM(ppa);
        PATHALLOC::cAllocated--;
    }
    else
    {
    // Keep around a couple of blocks on the freelist for fast access.

        ppa->ppanext = PATHALLOC::freelist;
        PATHALLOC::freelist = ppa;
        PATHALLOC::cFree++;
    }
}

/******************************Public*Routine******************************\
* friend PATHALLOC *newpathalloc()
*
*   Allocate a new pathalloc, taking it off the freelist unless the
*   freelist is empty.  In that case, just allocate a new one
*
*  1-Oct-1990 -by- Paul Butzi [paulb]
* Wrote it.
\**************************************************************************/

PPATHALLOC newpathalloc()
{
    SEMOBJ  so(PATHALLOC::hsemFreelist);

    register PPATHALLOC ppaNew = PATHALLOC::freelist;

    if ( ppaNew != (PPATHALLOC) NULL )
    {
        PATHALLOC::freelist = ppaNew->ppanext;
        PATHALLOC::cFree--;
    }
    else
    {
        ppaNew = (PPATHALLOC) PALLOCMEM(PATHALLOCSIZE, 'tapG');

        if (ppaNew == (PPATHALLOC) NULL)
            return((PPATHALLOC) NULL);

        PATHALLOC::cAllocated++;
    }

// Initialize the pathalloc structure:

    ppaNew->pprfreestart  = &(ppaNew->apr[0]);
    ppaNew->ppanext       = (PATHALLOC*) NULL;
    ppaNew->siztPathAlloc = PATHALLOCSIZE;

    return(ppaNew);
}

/******************************Public*Routine******************************\
* BOOL bSavePath(dco, lSave)
*
* Lazily save the DC's active or inactive path.  We only actually copy
* the path when the user starts mucking around with it.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSavePath(XDCOBJ& dco, LONG lSave)
{
    DONTUSE(lSave);

// If there's a path in the DC (either active or inactive), make a note
// to save it when it's about to be modified:

    if (dco.hpath() != HPATH_INVALID)
        dco.pdc->vSetLazySave();

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vRestorePath(dco, lSave)
*
* Restore the active path.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vRestorePath(XDCOBJ& dco, LONG lSave)
{
    DONTUSE(lSave);

// If there's a path in the DC, and the bLazySave flag isn't set, it means
// that it's a new path created at this level, so we have to nuke it:

    if (dco.hpath() != HPATH_INVALID && !dco.pdc->bLazySave())
    {
        XEPATHOBJ epath(dco.hpath());
        ASSERTGDI(epath.bValid(), "Invalid DC path");

        epath.vDelete();
        dco.pdc->vDestroy();
    }
}

/******************************Member*Function*****************************\
* BOOL EPATHOBJ::bAllClosed()
*
*  If a fill is to be done on the path, every subpath must be have been
*  explicitly marked as closed.  This routine returns TRUE if all subpaths
*  have be closed.
*
*  Note: This is needed in checked builds only!
*
* History:
*  77-Nov-1993 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bAllClosed()
{
    ULONG count = 0;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
        if (ppr->flags & PD_ENDSUBPATH)
        {
            if (!(ppr->flags & PD_CLOSEFIGURE))
                return(FALSE);
        }
        else
        {
            ASSERTGDI(!(ppr->flags & PD_CLOSEFIGURE),
                      "Shouldn't be a close figure when not end of subpath");
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID EPATHOBJ::vPrint()
*
* Prints the path points, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vPrint()
{
    DbgPrint("cCurves: %li  fl: %lx\n", cCurves, fl);

    PPATHREC ppr;
    for (ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
    {
        DbgPrint("\n%li: ", ppr->flags);
        COUNT ii;
        for (ii = 0; ii < ppr->count; ii++)
            DbgPrint("(%li, %li) ", ppr->aptfx[ii].x, ppr->aptfx[ii].y);
    }
    DbgPrint("\n");
}

/******************************Public*Routine******************************\
* VOID EPATHOBJ::vPrint()
*
* Prints the path structure, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vDiag()
{
    DbgPrint("flType: %lx\n", ppath->flType);

    DbgPrint("Chain: %p  PprFirst: %p   PprLast: %p\n",
              ppath->ppachain, ppath->pprfirst, ppath->pprlast);

    for (PPATHALLOC ppa = ppath->ppachain; ppa != NULL; ppa = ppa->ppanext)
        DbgPrint("  ppa: %p  ppaNext: %p  pprFreeStart: %p  sizt: %li\n",
              ppa, ppa->ppanext, ppa->pprfreestart, ppa->siztPathAlloc);

    for (PPATHREC ppr = ppath->pprfirst; ppr != NULL; ppr = ppr->pprnext)
        DbgPrint("    ppr: %p  pprNext: %p  pprPrev: %p  count: %li  flags: %li\n",
              ppr, ppr->pprnext, ppr->pprprev, ppr->count, ppr->flags);
}

/******************************Public*Routine******************************\
* VOID vPathDebug()
*
* Prints the number of currently allocated PATHALLOCs, and the number of
* PATHALLOCs available on the free list, for debugging purposes.
*
* History:
*  21-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vPathDebug()
{
    SEMOBJ so(PATHALLOC::hsemFreelist);

    DbgPrint("F: %li A: %li\n", PATHALLOC::cFree, PATHALLOC::cAllocated);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pfeobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pfeobj.cxx
*
* Non-inline methods for physical font entry objects.
*
* Created: 30-Oct-1990 09:32:48
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/
// #pragma warning (disable: 4509)


#include "precomp.hxx"
#include "flhack.hxx"

BOOL  bExtendGlyphSet(FD_GLYPHSET **ppfdgIn, FD_GLYPHSET **ppfdgOut);

INT
__cdecl CompareRoutine(WCHAR *pwc1, WCHAR *pwc2)
{

    return(*pwc1-*pwc2);

}

/******************************Public*Routine******************************\
*
* ULONG cComputeGISET
*
* similar to cComputeGlyphSet in mapfile.c, computes the number of
*(_wcsicmp(pwszFaceName, pFaceName) == 0)* distinct glyph handles in a font and the number of runs, ie. number of
* contiguous ranges of glyph handles
*
*
* History:
*  03-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


ULONG cComputeGISET (
    USHORT * pgi,
    ULONG    cgi,
    GISET  * pgiset,
    ULONG    cGiRuns
    )
{
    ULONG    iRun, iFirst, iFirstNext;
    ULONG    cgiTotal = 0, cgiRun;

// now compute cRuns if pgiset == 0 and fill the glyphset if pgiset != 0

    for (iFirst = 0, iRun = 0; iFirst < cgi; iRun++, iFirst = iFirstNext)
    {
    // find iFirst corresponding to the next range.

        for (iFirstNext = iFirst + 1; iFirstNext < cgi; iFirstNext++)
        {
            if ((pgi[iFirstNext] - pgi[iFirstNext - 1]) > 1)
                break;
        }

    // note that this line here covers the case when there are repetitions
    // in the pgi array.

        cgiRun    = pgi[iFirstNext-1] - pgi[iFirst] + 1;
        cgiTotal += cgiRun;

        if (pgiset != NULL)
        {
            pgiset->agirun[iRun].giLow  = pgi[iFirst];
            pgiset->agirun[iRun].cgi = (USHORT) cgiRun;
        }
    }

// store results if need be

    if (pgiset != NULL)
    {
        ASSERTGDI(iRun == cGiRuns, "gdisrv! iRun != cRun\n");

        pgiset->cGiRuns  = cGiRuns;

    // init the sum before entering the loop

        pgiset->cgiTotal = cgiTotal;
    }

    return iRun;
}

/******************************Public*Routine******************************\
*
* bComputeGISET, similar to ComputeGlyphSet, only for gi's
*
* History:
*  03-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#include "stdlib.h"


VOID vSortPlacebo
(
USHORT        *pwc,
ULONG          cChar
)
{
    ULONG i;

    for (i = 1; i < cChar; i++)
    {
    // upon every entry to this loop the array 0,1,..., (i-1) will be sorted

        INT j;
        WCHAR wcTmp = pwc[i];

        for (j = i - 1; (j >= 0) && (pwc[j] > wcTmp); j--)
        {
            pwc[j+1] = pwc[j];
        }
        pwc[j+1] = wcTmp;
    }
}




BOOL bComputeGISET(IFIMETRICS * pifi, PFE * ppfe, GISET **ppgiset)
{
    BOOL bRet = TRUE;
    *ppgiset = NULL;
    GISET *pgiset;

    PFEOBJ          pfeObj(ppfe);
    PFFOBJ          pffo(pfeObj.pPFF());
    PFD_GLYPHSET    pfdg = NULL;
    BOOL bTT = (BOOL)(pffo.hdev() == (HDEV) gppdevTrueType);

    if (!bTT)
    {
        if (!(pfdg = pfeObj.pfdg()))
        {
            return FALSE;
        }
    }

    if (bTT || (pfdg->flAccel & (GS_16BIT_HANDLES | GS_8BIT_HANDLES)))
    {
    // first check if this is an accelerated case where handles are the same
    // as glyph indicies

        ULONG cig = 0;
        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, cig))
        {
            cig = ((IFIEXTRA *)(pifi + 1))->cig;
        }

        if (bTT && (cig == 0)) // most likely a corrupt font
        {
            return FALSE;
        }

        if (cig)
        {
        // one run only from zero to (cig-1);

            if (pgiset = (GISET*)PALLOCMEM(offsetof(GISET,agirun) + 1 * sizeof(GIRUN),'slgG'))
            {
            // now fill in the array of runs

                pgiset->cgiTotal = cig;
                pgiset->cGiRuns = 1;
                pgiset->agirun[0].giLow = 0;
                pgiset->agirun[0].cgi = (USHORT)cig;

            // we are done now

                *ppgiset = pgiset;
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
        // one of the goofy fonts, we will do as before

            USHORT *pgi, *pgiBegin;

        // aloc tmp buffer to contain glyph handles of all glyphs in the font

            if (pgiBegin = (USHORT*)PALLOCMEM(pfdg->cGlyphsSupported * sizeof(USHORT),'slgG'))
            {
                pgi = pgiBegin;
                for (ULONG iRun = 0; iRun < pfdg->cRuns; iRun++)
                {
                    HGLYPH *phg, *phgEnd;
                    phg = pfdg->awcrun[iRun].phg;

                    if (phg) // non unicode handles
                    {
                        phgEnd = phg + pfdg->awcrun[iRun].cGlyphs;
                        for ( ; phg < phgEnd; pgi++, phg++)
                            *pgi = (USHORT)(*phg);
                    }
                    else // unicode handles
                    {
                        USHORT wcLo = pfdg->awcrun[iRun].wcLow;
                        USHORT wcHi = wcLo + pfdg->awcrun[iRun].cGlyphs - 1;
                        for ( ; wcLo <= wcHi; wcLo++, phg++)
                            *pgi = wcLo;
                    }
                }

            // now sort the array of glyph indicies. This array will be mostly
            // sorted so that our algorithm is efficient


                qsort((void*)pgiBegin, pfdg->cGlyphsSupported, sizeof(WORD),
                  (int (__cdecl *)(const void *, const void *))CompareRoutine);


            // once the array is sorted we can easily compute the number of giRuns

                ULONG cGiRun = cComputeGISET(pgiBegin, pfdg->cGlyphsSupported, NULL, 0);

                if (pgiset = (GISET*)PALLOCMEM(offsetof(GISET,agirun) + cGiRun * sizeof(GIRUN),'slgG'))
                {
                // now fill in the array of runs

                    cComputeGISET(pgiBegin, pfdg->cGlyphsSupported, pgiset, cGiRun);
                    *ppgiset = pgiset;
                }
                else
                {
                    bRet = FALSE;
                }

                VFREEMEM(pgiBegin);
            }
            else
            {
                bRet = FALSE;
            }
        }
    }

    if (!bTT)
        pfeObj.vFreepfdg();

    return bRet;
}



//
// This is used to give ppfe->pkp something to point to if a driver
// error occurs.  That way, we won't waste time calling the driver
// again.
//

FD_KERNINGPAIR gkpNothing = { 0, 0, 0 };

static ULONG ulTimerPFE = 0;

/******************************Public*Routine******************************\
* VOID PFEOBJ::vDelete()                                                   *
*                                                                          *
* Destroy the PFE physical font entry object.                              *
*                                                                          *
* History:                                                                 *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

VOID PFEOBJ::vDelete()
{
    PDEVOBJ pdo(ppfe->pPFF->hdev);

// Save driver allocated resources in PFECLEANUP so that we can later
// call the driver to free them.

    if ((ppfe->pifi->jWinCharSet == SYMBOL_CHARSET) &&
        (ppfe->pfdg != NULL) &&
        (ppfe->pfdg->flAccel & GS_EXTENDED))
    {
        VFREEMEM(ppfe->pfdg);
    }
    else
    {
        if ((ppfe->pfdg != NULL) && PPFNVALID(pdo,Free))
        {
            pdo.Free(ppfe->pfdg, ppfe->idfdg);
        }
    }

    if (PPFNVALID(pdo,Free))
    {
        pdo.Free(ppfe->pifi, ppfe->idifi);
        pdo.Free(ppfe->pkp , ppfe->idkp );
    }

    ppfe->pfdg = NULL;
    ppfe->pifi = NULL;

    ppfe->pkp = NULL;

    if (ppfe->pgiset)
    {
        VFREEMEM(ppfe->pgiset);
        ppfe->pgiset = NULL;
    }

// Free object memory and invalidate pointer.

    ppfe = PPFENULL;
}




/******************************Public*Routine******************************\
* dpNtmi()
*
* offset to NTMW_INTERNAL within ENUMFONTDATAW, needed in enumeration
*
* History:
*  19-Nov-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



ULONG PFEOBJ::dpNtmi()
{
    ULONG dpRet = DP_NTMI0;

    if (ppfe->pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (ppfe->pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(ppfe->pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)ppfe->pifi + dpDesVec);
            dpRet += (pdvSrc->dvNumAxes * sizeof(LONG));
        }
        else
        {
            DbgPrint("Test it %d %d \n", ppfe->pifi->cjIfiExtra, offsetof(IFIEXTRA, dpDesignVector));
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
        }

    }

    return dpRet;
}


/******************************Public*Routine******************************\
*
* IsAnyCharsetDbcs
*
* Does this font support any DBCS charset?
*
* History:
*  22-Jun-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" BOOL IsAnyCharsetDbcs(IFIMETRICS *pifi)
{
    BOOL bRet = FALSE;

    if (IS_ANY_DBCS_CHARSET(pifi->jWinCharSet))
        return TRUE;

    if (pifi->dpCharSets)
    {
        BYTE *aCharSets = (BYTE *)pifi + pifi->dpCharSets;

        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_ANY_DBCS_CHARSET(*aCharSets))
            {
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

/******************************Public*Routine******************************\
* PFEOBG::pfdg()
*
* If pfdg is NULL then we need to get it from font driver
* If pfdg is valid then we only need to return it.
*
* Return
*   FD_GLYPHSET *
*
* History
*  08-March-1999 -by- Yung-Jen Tony Tsai [yungt]
* Wrote it.
\**************************************************************************/
FD_GLYPHSET * PFEOBJ::pfdg()
{
    PFFOBJ  pffo(pPFF());
    PDEVOBJ pdo(pffo.hdev());
    BOOL    bFreeTmp = FALSE;
    FD_GLYPHSET *pfdgTmp = NULL;
    ULONG_PTR   idGlyphSet;
    
    GreAcquireSemaphore(ghsemGlyphSet);
    
    if (ppfe->pfdg == NULL)
    {
        ASSERTGDI(ppfe->cPfdgRef == 0, "PFEOBJ::pfdg is not matched with cRef\n");
        
        GreReleaseSemaphore(ghsemGlyphSet);
        
        BOOL    bUMPD = pdo.bUMPD();
        
        pfdgTmp = (FD_GLYPHSET *) pdo.QueryFontTree(pffo.dhpdev(),
                                                        pffo.hff(),
                                                        iFont(),
                                                        QFT_GLYPHSET,
                                                        &idGlyphSet);        
        GreAcquireSemaphore(ghsemGlyphSet);
        
        if (pfdgTmp)
        {
            if (ppfe->pfdg == NULL)
            {
                ppfe->pfdg = pfdgTmp;
                ppfe->idfdg = idGlyphSet;

                // For UMPD
                
                if (bUMPD)
                {
                    if (ppfe->pifi->jWinCharSet == SYMBOL_CHARSET)
                    {
                        FD_GLYPHSET *pfdgNew = NULL;

                        if (bExtendGlyphSet(&pfdgTmp, &pfdgNew))
                        {
                            bFreeTmp = TRUE;
                            ppfe->pfdg = pfdgNew;
                        }
                    }
                }
            }
            else
                bFreeTmp = TRUE;
        }
    }
    
    if (ppfe->pfdg)
        ppfe->cPfdgRef++;

    GreReleaseSemaphore(ghsemGlyphSet);
    
    if (bFreeTmp)
    {
        if (PPFNVALID(pdo,Free))
        {
            pdo.Free(pfdgTmp, idGlyphSet);
        }
    }
    
    return ppfe->pfdg;
}

extern "C" VOID ttfdFreeGlyphset(ULONG_PTR  iFile, ULONG iFace);


/******************************Public*Routine******************************\
* PFEOBG::vFreepfdg()
*
* If pfdg is valid then we free it.
* If pfdg is NULL then return.
*
* Return
*   VOID
*
* History
*  08-March-1999 -by- Yung-Jen Tony Tsai [yungt]
* Wrote it.
\**************************************************************************/
VOID PFEOBJ::vFreepfdg()
{
    PFFOBJ  pffo(pPFF());
    FD_GLYPHSET *pfdgTmp = NULL;
    ULONG_PTR   idGlyphSet;

    GreAcquireSemaphore(ghsemGlyphSet);
    
    ASSERTGDI(ppfe->cPfdgRef, "cRef of pfdg is wrong\n");

    ppfe->cPfdgRef--;

    if (ppfe->cPfdgRef == 0)
    {
        if (pffo.hdev() == (HDEV) gppdevTrueType)
        {
            ttfdFreeGlyphset(pffo.hff(), iFont()) ;
            ppfe->pfdg = NULL;
        }
        else
        {
            PDEVOBJ pdo(pffo.hdev());
            if (pdo.bUMPD() && PPFNVALID(pdo,Free))
            {
                if ((ppfe->pifi->jWinCharSet == SYMBOL_CHARSET) &&
                    (ppfe->pfdg != NULL) &&
                    (ppfe->pfdg->flAccel & GS_EXTENDED))
                {
                    VFREEMEM(ppfe->pfdg);
                }
                else
                {
                    pfdgTmp = ppfe->pfdg;
                    idGlyphSet = ppfe->idfdg;
                }
                ppfe->pfdg = NULL;
            }
        }
    }

    GreReleaseSemaphore(ghsemGlyphSet);

    if (pfdgTmp)
    {
        PDEVOBJ pdo(pffo.hdev());
        pdo.Free(pfdgTmp, idGlyphSet);
    }

    return;
}

/******************************Public*Routine******************************\
*
* PFEOBJ::flFontType()
*
* Computes the flags defining the type of this font.  Allowed flags are
* identical to the flType flags returned in font enumeration.
*
* Return:
*   The flags.
*
* History:
*  04-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


FLONG PFEOBJ::flFontType()
{
    FLONG flRet;
    IFIOBJ ifio(pifi());

// Compute the FontType flags, simulations are irrelevant

    flRet =
      ifio.bTrueType() ?
        TRUETYPE_FONTTYPE : (ifio.bBitmap() ? RASTER_FONTTYPE : 0);

// Add the device flag if this is also a device specific font.

    flRet |= (bDeviceFont()) ? DEVICE_FONTTYPE : 0;

// check if this is a postscript font

    if (pifi()->flInfo & FM_INFO_TECH_TYPE1)
    {
        flRet |= FO_POSTSCRIPT;

        if (pifi()->flInfo & FM_INFO_TECH_MM)
            flRet |= FO_MULTIPLEMASTER;

        if (pifi()->flInfo & FM_INFO_TECH_CFF)
            flRet |= FO_CFF;
    }

    if (ppfe->flPFE & PFE_DBCS_FONT)
    {
        flRet |= FO_DBCS_FONT;

        if (ppfe->flPFE & PFE_VERT_FACE)
            flRet |= FO_VERT_FACE;
    }

    return (flRet);
}


/******************************Public*Routine******************************\
* PFEOBJ::efstyCompute()
*
* Compute the ENUMFONTSTYLE from the IFIMETRICS.
*
* Returns:
*   The ENUMFONTSTYLE of font.  Note that EFSTYLE_SKIP and EFSTYLE_OTHER are
*   not legal return values for this function.  These values are used only
*   to mark fonts for which another font already exists that fills our
*   category for a given enumeration of a family.
*
* History:
*  04-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ENUMFONTSTYLE PFEOBJ::efstyCompute()
{
    IFIOBJ ifio(pifi());

    switch (ifio.fsSelection() & (FM_SEL_ITALIC | FM_SEL_BOLD) )
    {
        case FM_SEL_ITALIC:
            return EFSTYLE_ITALIC;

        case FM_SEL_BOLD:
            return EFSTYLE_BOLD;

        case FM_SEL_ITALIC | FM_SEL_BOLD:
            return EFSTYLE_BOLDITALIC;

        default:
            return EFSTYLE_REGULAR;
    }
}


/******************************Public*Routine******************************\
* COUNT PFEOBJ::cKernPairs                                                 *
*                                                                          *
* Retrieve the pointer to the array of kerning pairs for this font face.   *
* The kerning pair array is loaded on demand, so it may or may not already *
* be cached in the PFE.                                                    *
*                                                                          *
* Returns:                                                                 *
*   Count of kerning pairs.                                                *
*                                                                          *
* History:                                                                 *
*  Mon 22-Mar-1993 21:31:15 -by- Charles Whitmer [chuckwh]                 *
* WARNING: Never access a pkp (pointer to a kerning pair) without an       *
* exception handler!  The kerning pairs could be living in a file across   *
* the net or even on removable media.  I've added the try-except here.     *
*                                                                          *
*  29-Oct-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

COUNT PFEOBJ::cKernPairs(FD_KERNINGPAIR **ppkp)
{
//
// If the pointer cached in the PFE isn't NULL, we already have the answer.
//
    if ( (*ppkp = ppfe->pkp) != (FD_KERNINGPAIR *) NULL )
        return ppfe->ckp;

//
// Create a PFFOBJ.  Needed to create driver user object as well as
// provide info needed to call driver function.
//
    PFFOBJ pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "gdisrv!cKernPairsPFEOBJ(): invalid PPFF\n");

    PDEVOBJ pdo(pffo.hdev());

    if ( (ppfe->pkp = (FD_KERNINGPAIR*)
                          pdo.QueryFontTree(
                            pffo.dhpdev(),
                            pffo.hff(),
                            ppfe->iFont,
                            QFT_KERNPAIRS,
                            &ppfe->idkp)) == (FD_KERNINGPAIR *) NULL )
    {
    //
    // Font has no kerning pairs and didn't even bother to send back
    // an empty list. By setting pointer to a zeroed FD_KERNINGPAIR and
    // setting count to zero, we will bail out early and avoid calling
    // the driver.
    //
        ppfe->pkp = &gkpNothing;
        ppfe->ckp = 0;

        return 0;
    }

// Find the end of the kerning pair array (indicated by a zeroed out
// FD_KERNINGPAIR structure).

    FD_KERNINGPAIR *pkpEnd = ppfe->pkp;

// Be careful, the table isn't guaranteed to stay around!

    __try
    {
        while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
            pkpEnd += 1;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pkpEnd = ppfe->pkp = &gkpNothing;
    }

// Return the kerning pair pointer.

    *ppkp = ppfe->pkp;

//
// Return count (difference between the beginning and end pointers).
//

//Sundown truncation

    ASSERT4GB((LONGLONG)(pkpEnd - ppfe->pkp));

    return (ppfe->ckp = (ULONG)(pkpEnd - ppfe->pkp));
}


/******************************Public*Routine******************************\
* bValidFont
*
* Last minute sanity checks to prevent a font that may crash the system
* from getting in.  We're primarily looking for things like potential
* divide-by-zero errors, etc.
*
* History:
*  30-Apr-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bValidFont(IFIMETRICS *pifi)
{
    BOOL bRet = TRUE;

// Em height is used to compute scaling factors.  Must not be zero or
// divide-by-zero may result.

    if (pifi->fwdUnitsPerEm == 0)
    {
        WARNING("bValidFont(): fwdUnitsPerEm is zero\n");
        bRet = FALSE;
    }

// Font height is used to compute scaling factors.  Must not be zero or
// divide-by-zero may result.

    if ((pifi->fwdWinAscender + pifi->fwdWinDescender) == 0)
    {
        WARNING("bValidFont(): font height is zero\n");
        bRet = FALSE;
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFEMEMOBJ::bInit
*
* This function copies data into the PFE from the supplied buffer.  The
* calling routine should use the PFEMEMOBJ to create a PFE large enough
*
* History:
*  14-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFEMEMOBJ::bInit
(
    PPFF         pPFF,          // handle to root PFF
    ULONG        iFont,         // index of font
    FD_GLYPHSET *pfdg,          // ptr to wc-->hg map
    ULONG_PTR        idfdg,         // driver ID for wc-->hg map
    PIFIMETRICS  pifi,          // ptr to IFIMETRICS
    ULONG_PTR        idifi,         // driver ID for IFIMETRICS
    BOOL        bDeviceFont,    // mark as device font
    PUNIVERSAL_FONT_ID pufi,    // PFE_UFIMATCH flag for remote printing
    BOOL         bEUDC          // mark as EUDC font

)
{
// Check font's validity.  This is not a comprehensive check, but rather
// a last minute check for things that may make the engine crash.  Each
// font/device driver still needs to make an effort to weed out its own
// bad fonts.

    if (!bValidFont(pifi))
    {
        WARNING("PFEMEMOBJ::bInit(): rejecting REALLY bad font\n");
        return FALSE;
    }

// init non-table stuff

    ppfe->pPFF        = pPFF;
    ppfe->iFont       = iFont;
    ppfe->pfdg        = pfdg;
    ppfe->idfdg       = idfdg;
    ppfe->pifi        = pifi;
    ppfe->idifi       = idifi;
    ppfe->pkp         = (FD_KERNINGPAIR *) NULL;
    ppfe->idkp        = (ULONG_PTR) NULL;
    ppfe->ckp         = 0;
    ppfe->flPFE       = 0;
    ppfe->pid         = 0;
    ppfe->tid         = 0;
    ppfe->cPfdgRef    = 0;

    IFIOBJ ifio(ppfe->pifi);

    if (IsAnyCharsetDbcs(ppfe->pifi))
        ppfe->flPFE |= PFE_DBCS_FONT;

    if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
        ppfe->flPFE |= PFE_VERT_FACE;

// for base font attach full axes info, else, do not.

    ppfe->cjEfdwPFE = ALIGN4(dpNtmi() + CJ_NTMI0);

    if (pifi->flInfo & FM_INFO_TECH_MM) // if base mm font
    {
        PTRDIFF    dpAXIW = 0;
        AXESLISTW *paxlSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpAxesInfoW))
        {
            dpAXIW = ((IFIEXTRA *)(pifi + 1))->dpAxesInfoW;
            paxlSrc = (AXESLISTW *)((BYTE*)pifi + dpAXIW);
            ppfe->cjEfdwPFE += (paxlSrc->axlNumAxes * sizeof(AXISINFOW));
        }
        else
        {
            ASSERTGDI(dpAXIW, "AxesInfoW needed for base MM font\n");
        }
    }

    ASSERTGDI(ppfe->cjEfdwPFE >= CJ_EFDW0, "cjEfdwPFE problem\n");

    if (bDeviceFont)
    {
        ppfe->flPFE |= PFE_DEVICEFONT;
    }
    else if(pPFF->ppfv && (pPFF->ppfv[0]->pwszPath == NULL))
    {
    // CAUTION: It is enough to check one font only to determine if remote
    // or memory

        if (pPFF->flState & PFF_STATE_MEMORY_FONT)
        {
            ppfe->flPFE |= PFE_MEMORYFONT;
        }
        else
        {
            ppfe->flPFE |= PFE_REMOTEFONT;
        }
        ppfe->pid = W32GetCurrentPID();
        ppfe->tid = (PW32THREAD)PsGetCurrentThread();
    }

    // For remote printing, fonts are added to the public font table with FR_NOT_ENUM and PFE_UFIMATCH
    // flags set so that other process won't be able to enum or map the fonts.

    if (pufi)
    {
        ppfe->flPFE |= PFE_UFIMATCH;
    }

#ifdef FE_SB
    if( bEUDC )
    {
        ppfe->flPFE |= PFE_EUDC;
    }

// mark it as a SBCS system font if the facename is right

    PWSZ pwszFace = ifio.pwszFaceName();

    if(pwszFace[0] == '@')
    {
        pwszFace += 1;
    }

    if(!_wcsicmp(pwszFace,L"SYSTEM") ||
       !_wcsicmp(pwszFace,L"FIXEDSYS") ||
       !_wcsicmp(pwszFace,L"TERMINAL") ||
       ((!_wcsicmp(pwszFace,L"SMALL FONTS") &&
         ifio.lfCharSet() == SHIFTJIS_CHARSET)))
    {
        ppfe->flPFE |= PFE_SBCS_SYSTEM;
    }

// Initialize EUDC QUICKLOOKUP Table
//
// These field was used, if this font is loaded as FaceName/Default linked EUDC.
//

    ppfe->ql.puiBits = NULL;
    ppfe->ql.wcLow   = 1;
    ppfe->ql.wcHigh  = 0;

#endif

// Record and increment the time stamp.

    ppfe->ulTimeStamp = ulTimerPFE;
    InterlockedIncrement((LONG *) &ulTimerPFE);

// Precalculate stuff from the IFIMETRICS.


    ppfe->iOrientation = ifio.lfOrientation();

// Compute UFI stuff

    if( ifio.TypeOneID() )
    {
        ppfe->ufi.Index = ifio.TypeOneID();
        ppfe->ufi.CheckSum = TYPE1_FONT_TYPE;
    }
    else
    {
        ppfe->ufi.CheckSum = pPFF->ulCheckSum;
        ppfe->ufi.Index = iFont;
        if (pufi)
        {
        // need to ensure that ufi of this pfe on the server machine is
        // the same as it used to be on the client. Client side ufi
        // one of the pfe's corresponding to this font is pointed to by pufi.

            ppfe->ufi.Index += ((pufi->Index - 1) & ~1);
        }

    }

// init the GISET

    if(!bComputeGISET(pifi, ppfe, &ppfe->pgiset))
        return FALSE;

// initialize cAlt for this family name, the number of entries in font sub
// table that point to this fam name.

    ppfe->cAlt = 0;

// only tt fonts with multiple charsets can be multiply enumerated
// as being both themselves and whatever font sub table claims they are

    if (ppfe->pifi->dpCharSets)
    {
        PFONTSUB pfs = gpfsTable;
        PFONTSUB pfsEnd = gpfsTable + gcfsTable;
        WCHAR    awchCapName[LF_FACESIZE];

    // Want case insensitive search, so capitalize the name.

        cCapString(awchCapName, ifio.pwszFamilyName() , LF_FACESIZE);

    // Scan through the font substitution table for the key string.

        PWCHAR pwcA;
        PWCHAR pwcB;

        for (; pfs < pfsEnd; pfs++)
        {
        // Do the following inline for speed:
        //
        //  if (!wcsncmpi(pwchFacename, pfs->fcsFace.awch, LF_FACESIZE))
        //      return (pfs->fcsAltFace.awch);

        // only those entries in the Font Substitution which have the form
        // face1,charset1=face2,charset2
        // where both charset1 and charset2 are valid charsets
        // count for enumeration purposes.

            if (!(pfs->fcsAltFace.fjFlags | pfs->fcsFace.fjFlags))
            {
                for (pwcA=awchCapName,pwcB=pfs->fcsAltFace.awch; *pwcA==*pwcB; pwcA++,pwcB++)
                {
                    if (*pwcA == 0)
                    {
                        ppfe->aiFamilyName[ppfe->cAlt++] = (BYTE)(pfs-gpfsTable);
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}



BOOL PFEOBJ::bCheckFamilyName(PWSZ pwszFaceName, BOOL bIgonreVertical, BOOL *pbAliasMatch)
{
    PWSZ pFaceName;
    BOOL bRet;

    if (pbAliasMatch)
    {
        *pbAliasMatch = FALSE;
    }

    pFaceName = (PWSZ) (((BYTE*) ppfe->pifi) + ppfe->pifi->dpwszFamilyName);

    if (bIgonreVertical && (*pFaceName == L'@'))
        pFaceName++;

    bRet = (_wcsicmp(pwszFaceName, pFaceName) == 0);

    if (!bRet && (ppfe->pifi->flInfo & FM_INFO_FAMILY_EQUIV))
    {
        pFaceName += (wcslen(pFaceName) + 1);
        while(!bRet && *pFaceName)
        {
            if (bIgonreVertical && (*pFaceName == L'@'))
                pFaceName++;
            bRet = (_wcsicmp(pwszFaceName, pFaceName) == 0);
            pFaceName += (wcslen(pFaceName) + 1);
        }

    // for the font mapper only: If match is found among family name aliases,
    // increase the font mapping penalty

        if (pbAliasMatch)
        {
            *pbAliasMatch = bRet;
        }
    }
    return bRet;
}




/****************************